{"task_num": 4, "task_title": "Median of Two Sorted Arrays", "func_name": "findMedianSortedArrays", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n    n1 = len(nums1)\n    n2 = len(nums2)\n    if n1 > n2:\n      return self.findMedianSortedArrays(nums2, nums1)\n\n    l = 0\n    r = n1\n\n    while l <= r:\n      partition1 = (l + r) // 2\n      partition2 = (n1 + n2 + 1) // 2 - partition1\n      maxLeft1 = -2**31 if partition1 == 0 else nums1[partition1 - 1]\n      maxLeft2 = -2**31 if partition2 == 0 else nums2[partition2 - 1]\n      minRight1 = 2**31 - 1 if partition1 == n1 else nums1[partition1]\n      minRight2 = 2**31 - 1 if partition2 == n2 else nums2[partition2]\n      if maxLeft1 <= minRight2 and maxLeft2 <= minRight1:\n        if (n1 + n2) % 2 == 0:\n          return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) * 0.5\n        else:\n          return max(maxLeft1, maxLeft2)\n      elif maxLeft1 > minRight2:\n        r = partition1 - 1\n      else:\n        l = partition1 + 1\n", "tests": ["def test_findMedianSortedArrays():\n    solution = Solution()\n    nums1 = [1, 3]\n    nums2 = [2]\n    assert solution.findMedianSortedArrays(nums1, nums2) == 2.0", "def test_findMedianSortedArrays():\n    solution = Solution()\n    nums1 = [1, 2]\n    nums2 = [3, 4]\n    assert solution.findMedianSortedArrays(nums1, nums2) == 2.5", "def test_findMedianSortedArrays():\n    solution = Solution()\n    nums1 = []\n    nums2 = [1]\n    assert solution.findMedianSortedArrays(nums1, nums2) == 1.0", "def test_findMedianSortedArrays():\n    solution = Solution()\n    nums1 = [2]\n    nums2 = []\n    assert solution.findMedianSortedArrays(nums1, nums2) == 2.0", "def test_findMedianSortedArrays():\n    solution = Solution()\n    nums1 = [1, 3, 5]\n    nums2 = [2, 4, 6, 8]\n    assert solution.findMedianSortedArrays(nums1, nums2) == 4.0", "def test_findMedianSortedArrays():\n    solution = Solution()\n    nums1 = [1, 2]\n    nums2 = [1, 2, 3]\n    assert solution.findMedianSortedArrays(nums1, nums2) == 2.0", "def test_findMedianSortedArrays():\n    solution = Solution()\n    nums1 = [4, 5, 6]\n    nums2 = [1, 2, 3, 7, 8, 9]\n    assert solution.findMedianSortedArrays(nums1, nums2) == 5.0", "def test_findMedianSortedArrays():\n    solution = Solution()\n    nums1 = [1, 3, 5, 7, 9]\n    nums2 = [2, 4, 6, 8, 10, 11, 12]\n    assert solution.findMedianSortedArrays(nums1, nums2) == 6.0", "def test_findMedianSortedArrays():\n    solution = Solution()\n    nums1 = [2, 3]\n    nums2 = [1, 4, 5, 6]\n    assert solution.findMedianSortedArrays(nums1, nums2) == 3.5", "def test_findMedianSortedArrays():\n    solution = Solution()\n    nums1 = [1, 1, 1, 1]\n    nums2 = [1, 1, 1, 1, 1, 1]\n    assert solution.findMedianSortedArrays(nums1, nums2) == 1.0", "def test_findMedianSortedArrays():\n    solution = Solution()\n    nums1 = [1, 2, 3, 4, 5, 6, 7, 8]\n    nums2 = [9, 10, 11, 12, 13, 14, 15, 16, 17]\n    assert solution.findMedianSortedArrays(nums1, nums2) == 9.0", "def test_findMedianSortedArrays():\n    solution = Solution()\n    nums1 = [3, 5, 7, 9]\n    nums2 = [1, 2, 6, 8]\n    assert solution.findMedianSortedArrays(nums1, nums2) == 5.5", "def test_findMedianSortedArrays():\n    solution = Solution()\n    nums1 = [-5, -3, -1]\n    nums2 = [0, 2, 4, 6]\n    assert solution.findMedianSortedArrays(nums1, nums2) == 0.5", "def test_findMedianSortedArrays():\n    solution = Solution()\n    nums1 = [1, 2, 5]\n    nums2 = [3, 4, 6, 7, 8]\n    assert solution.findMedianSortedArrays(nums1, nums2) == 5.0", "def test_findMedianSortedArrays():\n    solution = Solution()\n    nums1 = [1, 4, 9]\n    nums2 = [2, 3, 5, 6, 7, 8, 10]\n    assert solution.findMedianSortedArrays(nums1, nums2) == 5.0", "def test_findMedianSortedArrays():\n    solution = Solution()\n    nums1 = [3, 8, 9]\n    nums2 = [1, 2, 4, 5, 6, 7, 10, 11]\n    assert solution.findMedianSortedArrays(nums1, nums2) == 5.5", "def test_findMedianSortedArrays():\n    solution = Solution()\n    nums1 = [0, 0, 0, 0]\n    nums2 = [0, 0, 0, 0, 1, 2]\n    assert solution.findMedianSortedArrays(nums1, nums2) == 0.0", "def test_findMedianSortedArrays():\n    solution = Solution()\n    nums1 = [1, 2, 3]\n    nums2 = [4, 5, 6, 7, 8, 9, 10]\n    assert solution.findMedianSortedArrays(nums1, nums2) == 5.5", "def test_findMedianSortedArrays():\n    solution = Solution()\n    nums1 = [-10, -5, 0, 5, 10]\n    nums2 = [-6, -4, 1, 3, 9]\n    assert solution.findMedianSortedArrays(nums1, nums2) == 0.5", "def test_findMedianSortedArrays():\n    solution = Solution()\n    nums1 = [1, 2, 7, 8, 9]\n    nums2 = [3, 4, 5, 6, 10, 11, 12]\n    assert solution.findMedianSortedArrays(nums1, nums2) == 6.5"]}
{"task_num": 10, "task_title": "Regular Expression Matching", "func_name": "isMatch", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isMatch(self, s: str, p: str) -> bool:\n    m = len(s)\n    n = len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    def isMatch(i: int, j: int) -> bool:\n      return j >= 0 and p[j] == '.' or s[i] == p[j]\n\n    for j, c in enumerate(p):\n      if c == '*' and dp[0][j - 1]:\n        dp[0][j + 1] = True\n\n    for i in range(m):\n      for j in range(n):\n        if p[j] == '*':\n          noRepeat = dp[i + 1][j - 1]\n          doRepeat = isMatch(i, j - 1) and dp[i][j + 1]\n          dp[i + 1][j + 1] = noRepeat or doRepeat\n        elif isMatch(i, j):\n          dp[i + 1][j + 1] = dp[i][j]\n\n    return dp[m][n]\n", "tests": ["def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('aab', 'c*a*b') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('mississippi', 'mis*is*p*.') == False", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('ab', '.*c') == False", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('abc', '.*') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('', 'a*') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('aaa', 'a*a') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('abcd', 'd*') == False", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('aaa', 'ab*a*c*a') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('a', 'ab*') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('bb', '.bab') == False", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('abcd', '.*d') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('aaa', 'aaaa') == False", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('ab', '.*b') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('abc', 'a.c') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('abc', 'a.*d') == False", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('a', '.*..a*') == False", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('aab', 'a*b*') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('abcd', 'abc.*') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('xyz', 'x.*z') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('a', 'ab*') == True"]}
{"task_num": 15, "task_title": "3Sum", "func_name": "threeSum", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def threeSum(self, nums: List[int]) -> List[List[int]]:\n    if len(nums) < 3:\n      return []\n\n    ans = []\n\n    nums.sort()\n\n    for i in range(len(nums) - 2):\n      if i > 0 and nums[i] == nums[i - 1]:\n        continue\n\n      l = i + 1\n      r = len(nums) - 1\n      while l < r:\n        summ = nums[i] + nums[l] + nums[r]\n        if summ == 0:\n          ans.append((nums[i], nums[l], nums[r]))\n          l += 1\n          r -= 1\n          while nums[l] == nums[l - 1] and l < r:\n            l += 1\n          while nums[r] == nums[r + 1] and l < r:\n            r -= 1\n        elif summ < 0:\n          l += 1\n        else:\n          r -= 1\n\n    return ans\n", "tests": ["def test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([-1, 0, 1, 2, -1, -4]) == [(-1, -1, 2), (-1, 0, 1)]", "def test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([0, 1, 1]) == []", "def test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([0, 0, 0, 0]) == [(0, 0, 0)]", "def test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([-2, 0, 1, 1, 2]) == [(-2, 0, 2), (-2, 1, 1)]", "def test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([3, -2, -1, 0, 1, 2]) == [(-2, -1, 3), (-2, 0, 2), (-1, 0, 1)]", "def test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([-4, -1, -1, 0, 1, 2, 2]) == [(-4, 2, 2), (-1, -1, 2), (-1, 0, 1)]", "def test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([1, 2, -2, -1]) == []", "def test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([-1, -1, 2, 2, -2, 0]) == [(-2, 0, 2), (-1, -1, 2)]", "def test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([]) == []", "def test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([-1, 1, 0, -1, 1]) == [(-1, 0, 1)]", "def test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([1, -1, -1, 2, -2, 0, 0]) == [(-2, 0, 2), (-1, -1, 2), (-1, 0, 1)]", "def test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([4, -1, -4, 0, -1, 1, 2]) == [(-4, 0, 4), (-1, -1, 2), (-1, 0, 1)]", "def test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([-3, 3, 3, -3, 0, 0, 0]) == [(-3, 0, 3), (0, 0, 0)]", "def test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([2, 2, -4]) == [(-4, 2, 2)]", "def test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([-5, 1, 4, -1, 0, 2]) == [(-5, 1, 4), (-1, 0, 1)]", "def test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([0, 0, 1, 2, -3]) == [(-3, 1, 2), (0, 0, 0)]", "def test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([-2, -2, 0, 2, 2]) == [(-2, 0, 2)]", "def test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([-5, 2, 3, 0, 0, 0, 2]) == [(-5, 2, 3), (0, 0, 0)]", "def test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([3, 0, -3, -3, 1, 2]) == [(-3, 0, 3), (-3, 1, 2)]", "def test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([0, -1, 1, -1, 1, 2, -2]) == [(-2, 0, 2), (-1, -1, 2), (-1, 0, 1)]"]}
{"task_num": 44, "task_title": "Wildcard Matching", "func_name": "isMatch", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isMatch(self, s: str, p: str) -> bool:\n    m = len(s)\n    n = len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    def isMatch(i: int, j: int) -> bool:\n      return i >= 0 and p[j] == '?' or s[i] == p[j]\n\n    for j, c in enumerate(p):\n      if c == '*':\n        dp[0][j + 1] = dp[0][j]\n\n    for i in range(m):\n      for j in range(n):\n        if p[j] == '*':\n          matchEmpty = dp[i + 1][j]\n          matchSome = dp[i][j + 1]\n          dp[i + 1][j + 1] = matchEmpty or matchSome\n        elif isMatch(i, j):\n          dp[i + 1][j + 1] = dp[i][j]\n\n    return dp[m][n]\n", "tests": ["def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('abcd', 'a*d') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('abefcdgiescdfimde', 'ab*cd?i*de') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('abc', 'a*c?') == False", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('mississippi', 'm??*ss*?i*pi') == False", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('', '*') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('abcdef', '******') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('hello', 'h*o') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('test', 't?st*') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('banana', 'b*na?') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('xyz', 'x?*z') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('a', '?*') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('aab', 'c*a*b') == False", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('adceb', '*a*b') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('openai', 'o*en*i') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('file', 'f?le') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('pattern', 'p*t?r*') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('example', 'e*x?mpl?') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('task', '*ask*') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('sequence', 's?q*e*') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('ab', 'a**b') == True"]}
{"task_num": 54, "task_title": "Spiral Matrix", "func_name": "spiralOrder", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n    if not matrix:\n      return []\n\n    m = len(matrix)\n    n = len(matrix[0])\n    ans = []\n    r1 = 0\n    c1 = 0\n    r2 = m - 1\n    c2 = n - 1\n\n    while len(ans) < m * n:\n      j = c1\n      while j <= c2 and len(ans) < m * n:\n        ans.append(matrix[r1][j])\n        j += 1\n      i = r1 + 1\n      while i <= r2 - 1 and len(ans) < m * n:\n        ans.append(matrix[i][c2])\n        i += 1\n      j = c2\n      while j >= c1 and len(ans) < m * n:\n        ans.append(matrix[r2][j])\n        j -= 1\n      i = r2 - 1\n      while i >= r1 + 1 and len(ans) < m * n:\n        ans.append(matrix[i][c1])\n        i -= 1\n      r1 += 1\n      c1 += 1\n      r2 -= 1\n      c2 -= 1\n\n    return ans\n", "tests": ["def test_spiralOrder():\n    solution = Solution()\n    assert solution.spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [1, 2, 3, 6, 9, 8, 7, 4, 5]", "def test_spiralOrder():\n    solution = Solution()\n    assert solution.spiralOrder([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) == [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]", "def test_spiralOrder():\n    solution = Solution()\n    assert solution.spiralOrder([[1], [2], [3], [4]]) == [1, 2, 3, 4]", "def test_spiralOrder():\n    solution = Solution()\n    assert solution.spiralOrder([[1, 2, 3, 4]]) == [1, 2, 3, 4]", "def test_spiralOrder():\n    solution = Solution()\n    assert solution.spiralOrder([[1, 2], [3, 4], [5, 6], [7, 8]]) == [1, 2, 4, 6, 8, 7, 5, 3]", "def test_spiralOrder():\n    solution = Solution()\n    assert solution.spiralOrder([[1]]) == [1]", "def test_spiralOrder():\n    solution = Solution()\n    assert solution.spiralOrder([[1, 2], [4, 3]]) == [1, 2, 3, 4]", "def test_spiralOrder():\n    solution = Solution()\n    assert solution.spiralOrder([[1, 2, 3], [6, 5, 4]]) == [1, 2, 3, 4, 5, 6]", "def test_spiralOrder():\n    solution = Solution()\n    assert solution.spiralOrder([[7, 8, 9], [6, 1, 2], [5, 4, 3]]) == [7, 8, 9, 2, 3, 4, 5, 6, 1]", "def test_spiralOrder():\n    solution = Solution()\n    assert solution.spiralOrder([]) == []", "def test_spiralOrder():\n    solution = Solution()\n    assert solution.spiralOrder([[1, 2, 3, 4, 5]]) == [1, 2, 3, 4, 5]", "def test_spiralOrder():\n    solution = Solution()\n    assert solution.spiralOrder([[1], [2], [3], [4], [5]]) == [1, 2, 3, 4, 5]", "def test_spiralOrder():\n    solution = Solution()\n    assert solution.spiralOrder([[2, 5, 8], [4, 0, -1]]) == [2, 5, 8, -1, 0, 4]", "def test_spiralOrder():\n    solution = Solution()\n    assert solution.spiralOrder([[1, 2, 3], [10, 11, 4], [9, 12, 5], [8, 7, 6]]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]", "def test_spiralOrder():\n    solution = Solution()\n    assert solution.spiralOrder([[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]", "def test_spiralOrder():\n    solution = Solution()\n    assert solution.spiralOrder([[3, 2], [4, 1], [5, 6]]) == [3, 2, 1, 6, 5, 4]", "def test_spiralOrder():\n    solution = Solution()\n    assert solution.spiralOrder([[1, 2, 3], [4, 5, 6]]) == [1, 2, 3, 6, 5, 4]", "def test_spiralOrder():\n    solution = Solution()\n    assert solution.spiralOrder([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]) == [1, 2, 4, 6, 8, 10, 9, 7, 5, 3]", "def test_spiralOrder():\n    solution = Solution()\n    assert solution.spiralOrder([[1, 3], [2, 4], [5, 6], [7, 9], [8, 10]]) == [1, 3, 4, 6, 9, 10, 8, 7, 5, 2]", "def test_spiralOrder():\n    solution = Solution()\n    assert solution.spiralOrder([[1, 2, 3, 4, 5], [12, 11, 10, 9, 8]]) == [1, 2, 3, 4, 5, 8, 9, 10, 11, 12]"]}
{"task_num": 65, "task_title": "Valid Number", "func_name": "isNumber", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isNumber(self, s: str) -> bool:\n    s = s.strip()\n    if not s:\n      return False\n\n    seenNum = False\n    seenDot = False\n    seenE = False\n\n    for i, c in enumerate(s):\n      if c == '.':\n        if seenDot or seenE:\n          return False\n        seenDot = True\n      elif c == 'e' or c == 'E':\n        if seenE or not seenNum:\n          return False\n        seenE = True\n        seenNum = False\n      elif c in '+-':\n        if i > 0 and s[i - 1] not in 'eE':\n          return False\n        seenNum = False\n      else:\n        if not c.isdigit():\n          return False\n        seenNum = True\n\n    return seenNum\n", "tests": ["def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('2') == True", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('1e10') == True", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('.9') == True", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('95a54e53') == False", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('53.5e93') == True", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('1e') == False", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('-+3') == False", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('4.') == True", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('abc') == False", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('-90E3') == True", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('99e2.5') == False", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('-0.1') == True", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('') == False", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('e3') == False", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('+6e-1') == True", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('1a') == False", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('+3.14') == True", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('-.9') == True", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('--6') == False", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('3e+7') == True"]}
{"task_num": 73, "task_title": "Set Matrix Zeroes", "func_name": "setZeroes", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def setZeroes(self, matrix: List[List[int]]) -> None:\n    m = len(matrix)\n    n = len(matrix[0])\n    shouldFillFirstRow = 0 in matrix[0]\n    shouldFillFirstCol = 0 in list(zip(*matrix))[0]\n\n    for i in range(1, m):\n      for j in range(1, n):\n        if matrix[i][j] == 0:\n          matrix[i][0] = 0\n          matrix[0][j] = 0\n\n    for i in range(1, m):\n      for j in range(1, n):\n        if matrix[i][0] == 0 or matrix[0][j] == 0:\n          matrix[i][j] = 0\n\n    if shouldFillFirstRow:\n      matrix[0] = [0] * n\n\n    if shouldFillFirstCol:\n      for row in matrix:\n        row[0] = 0\n", "tests": ["def test_setZeroes():\n    solution = Solution()\n    matrix = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]\n    expected = [[1, 0, 1], [0, 0, 0], [1, 0, 1]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[0, 1, 2, 0], [3, 4, 5, 2], [1, 3, 1, 5]]\n    expected = [[0, 0, 0, 0], [0, 4, 5, 0], [0, 3, 1, 0]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]\n    expected = [[1, 2, 0], [4, 5, 0], [0, 0, 0]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[0, 1], [1, 1]]\n    expected = [[0, 0], [0, 1]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[1, 0, 3], [4, 5, 6], [0, 8, 9], [10, 11, 12]]\n    expected = [[0, 0, 0], [0, 0, 6], [0, 0, 0], [0, 0, 12]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[5]]\n    expected = [[5]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[0, 2, 3], [4, 5, 6], [7, 8, 9]]\n    expected = [[0, 0, 0], [0, 5, 6], [0, 8, 9]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[1, 1, 1, 1], [1, 0, 1, 1], [1, 1, 1, 1], [1, 1, 1, 0]]\n    expected = [[1, 0, 1, 0], [0, 0, 0, 0], [1, 0, 1, 0], [0, 0, 0, 0]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[1, 1], [0, 1], [1, 1]]\n    expected = [[0, 1], [0, 0], [0, 1]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[1, 0, 3], [0, 1, 2], [3, 4, 5]]\n    expected = [[0, 0, 0], [0, 0, 0], [0, 0, 5]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[0, 0, 0], [7, 8, 9], [1, 2, 3]]\n    expected = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[1, 1, 1, 1], [1, 0, 1, 1], [1, 1, 1, 1], [0, 1, 1, 1]]\n    expected = [[0, 0, 1, 1], [0, 0, 0, 0], [0, 0, 1, 1], [0, 0, 0, 0]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 0, 11, 12], [13, 14, 15, 16]]\n    expected = [[1, 0, 3, 4], [5, 0, 7, 8], [0, 0, 0, 0], [13, 0, 15, 16]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 0, 12]]\n    expected = [[1, 0, 3], [4, 0, 6], [7, 0, 9], [0, 0, 0]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[1, 1, 1], [0, 1, 1], [1, 1, 0], [1, 1, 1]]\n    expected = [[0, 1, 0], [0, 0, 0], [0, 0, 0], [0, 1, 0]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[1, 1, 1, 1], [1, 1, 1, 0], [1, 1, 1, 1], [0, 1, 1, 1]]\n    expected = [[0, 1, 1, 0], [0, 0, 0, 0], [0, 1, 1, 0], [0, 0, 0, 0]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[1, 0, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]\n    expected = [[0, 0, 0, 0], [5, 0, 7, 8], [9, 0, 11, 12], [13, 0, 15, 16]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[0, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]]\n    expected = [[0, 0, 0], [0, 5, 6], [0, 8, 9], [0, 11, 12]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[1, 2, 3], [4, 0, 6], [7, 8, 9], [10, 11, 0]]\n    expected = [[1, 0, 3], [0, 0, 0], [7, 0, 9], [0, 0, 0]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[1, 2, 3, 4, 5], [6, 7, 8, 9, 0], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20]]\n    expected = [[1, 2, 3, 4, 0], [0, 0, 0, 0, 0], [11, 12, 13, 14, 0], [16, 17, 18, 19, 0]]\n    solution.setZeroes(matrix)"]}
{"task_num": 97, "task_title": "Interleaving String", "func_name": "isInterleave", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n    m = len(s1)\n    n = len(s2)\n    if m + n != len(s3):\n      return False\n\n    dp=[]\n    for _ in range(m + 1):\n      dp.append([False] * (n + 1))\n    dp[0][0] = True\n\n    for i in range(1, m + 1):\n      dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n\n    for j in range(1, n + 1):\n      dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n\n    return dp[m][n]\n", "tests": ["def test_isInterleave():\n    solution = Solution()\n    assert solution.isInterleave('abc', 'def', 'adbcef') == True", "def test_isInterleave():\n    solution = Solution()\n    assert solution.isInterleave('aabcc', 'dbbca', 'aadbbcbcac') == True", "def test_isInterleave():\n    solution = Solution()\n    assert solution.isInterleave('abc', 'xyz', 'axbycz') == True", "def test_isInterleave():\n    solution = Solution()\n    assert solution.isInterleave('a', 'b', 'ab') == True", "def test_isInterleave():\n    solution = Solution()\n    assert solution.isInterleave('abc', 'def', 'abdecf') == False", "def test_isInterleave():\n    solution = Solution()\n    assert solution.isInterleave('', '', '') == True", "def test_isInterleave():\n    solution = Solution()\n    assert solution.isInterleave('abc', '', 'abc') == True", "def test_isInterleave():\n    solution = Solution()\n    assert solution.isInterleave('aabc', 'abad', 'aabacbad') == True", "def test_isInterleave():\n    solution = Solution()\n    assert solution.isInterleave('abc', 'def', 'abcdefg') == False", "def test_isInterleave():\n    solution = Solution()\n    assert solution.isInterleave('xx', 'yy', 'xyxy') == True", "def test_isInterleave():\n    solution = Solution()\n    assert solution.isInterleave('abc', 'def', 'abdfec') == False", "def test_isInterleave():\n    solution = Solution()\n    assert solution.isInterleave('aaa', 'aa', 'aaaaa') == True", "def test_isInterleave():\n    solution = Solution()\n    assert solution.isInterleave('ab', 'bc', 'babc') == False", "def test_isInterleave():\n    solution = Solution()\n    assert solution.isInterleave('xyz', '123', 'x1y2z3') == True", "def test_isInterleave():\n    solution = Solution()\n    assert solution.isInterleave('a', 'bc', 'acb') == False", "def test_isInterleave():\n    solution = Solution()\n    assert solution.isInterleave('abc', 'defg', 'adbcefg') == True", "def test_isInterleave():\n    solution = Solution()\n    assert solution.isInterleave('abc', 'abc', 'aabbcc') == True", "def test_isInterleave():\n    solution = Solution()\n    assert solution.isInterleave('abc', 'abc', 'abcabc') == True", "def test_isInterleave():\n    solution = Solution()\n    assert solution.isInterleave('abc', 'def', 'abdecf') == False", "def test_isInterleave():\n    solution = Solution()\n    assert solution.isInterleave('abc', 'de', 'adebc') == True"]}
{"task_num": 126, "task_title": "Word Ladder II", "func_name": "findLadders", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Set\n\nclass Solution:\n  def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n    from collections import deque\n    def connected(a: str, b: str) -> bool:\n      k = 0\n      for i in range(len(a)):\n        if a[i] != b[i]:\n          k += 1\n      return k == 1\n\n    if endWord not in wordList:\n      return []\n\n    visited = set([beginWord])\n\n    q = deque([beginWord])\n    nodes = []\n    find = False\n\n    while q and not find:\n      nodes.append(q.copy())\n      n = len(q)\n      for _ in range(n):\n        word = q.popleft()\n        for item in wordList:\n          if item in visited:\n            continue\n          if not connected(word, item):\n            continue\n          if item == endWord:\n            find = True\n            break\n          visited.add(item)\n          q.append(item)\n        if find:\n          break\n\n    if not find:\n      return []\n\n    ans = []\n\n    def backtracking(word, level: int, steps: List[str]):\n      if word == beginWord:\n        ans.append(steps[::-1])\n        return\n      if level < 0:\n        return\n      for item in nodes[level]:\n        if connected(item, word):\n          steps.append(item)\n          backtracking(item, level-1, steps)\n          steps.pop()\n\n    backtracking(endWord, len(nodes)-1, [endWord])\n    return ans\n", "tests": ["def test_findLadders():\n    solution = Solution()\n    beginWord = 'hit'\n    endWord = 'cog'\n    wordList = ['hot', 'dot', 'dog', 'lot', 'log', 'cog']\n    expected_output = [['hit', 'hot', 'dot', 'dog', 'cog'], ['hit', 'hot', 'lot', 'log', 'cog']]\n    result = solution.findLadders(beginWord, endWord, wordList)", "def test_findLadders():\n    solution = Solution()\n    beginWord = 'hit'\n    endWord = 'cog'\n    wordList = ['hot', 'dot', 'dog', 'lot', 'log']\n    expected_output = []\n    result = solution.findLadders(beginWord, endWord, wordList)", "def test_findLadders():\n    solution = Solution()\n    beginWord = 'a'\n    endWord = 'c'\n    wordList = ['a', 'b', 'c']\n    expected_output = [['a', 'c']]\n    result = solution.findLadders(beginWord, endWord, wordList)", "def test_findLadders():\n    solution = Solution()\n    beginWord = 'aaa'\n    endWord = 'bbb'\n    wordList = ['aac', 'bac', 'bbc']\n    expected_output = []\n    result = solution.findLadders(beginWord, endWord, wordList)", "def test_findLadders():\n    solution = Solution()\n    beginWord = 'red'\n    endWord = 'tax'\n    wordList = ['ted', 'tex', 'tax', 'tad', 'tin']\n    expected_output = [['red', 'ted', 'tex', 'tax'], ['red', 'ted', 'tad', 'tax']]\n    result = solution.findLadders(beginWord, endWord, wordList)", "def test_findLadders():\n    solution = Solution()\n    beginWord = 'start'\n    endWord = 'end'\n    wordList = ['stark', 'stack', 'slack', 'black', 'blank', 'blink', 'drink', 'drank', 'end']\n    expected_output = [['start', 'stark', 'stack', 'slack', 'black', 'blank', 'blink', 'drank', 'end'], ['start', 'stark', 'stack', 'slack', 'black', 'blank', 'drank', 'end']]\n    result = solution.findLadders(beginWord, endWord, wordList)", "def test_findLadders():\n    solution = Solution()\n    beginWord = 'gag'\n    endWord = 'gig'\n    wordList = ['gag', 'hag', 'hug', 'bug', 'big']\n    expected_output = []\n    result = solution.findLadders(beginWord, endWord, wordList)", "def test_findLadders():\n    solution = Solution()\n    beginWord = 'abc'\n    endWord = 'xyz'\n    wordList = ['abd', 'abx', 'abz', 'xbz', 'xyz']\n    expected_output = [['abc', 'abx', 'abz', 'xbz', 'xyz']]\n    result = solution.findLadders(beginWord, endWord, wordList)", "def test_findLadders():\n    solution = Solution()\n    beginWord = 'fire'\n    endWord = 'hire'\n    wordList = ['hire', 'fhir', 'fere', 'fare']\n    expected_output = [['fire', 'hire']]\n    result = solution.findLadders(beginWord, endWord, wordList)", "def test_findLadders():\n    solution = Solution()\n    beginWord = 'cat'\n    endWord = 'dog'\n    wordList = ['bat', 'bet', 'bot', 'dat', 'dot']\n    expected_output = []\n    result = solution.findLadders(beginWord, endWord, wordList)", "def test_findLadders():\n    solution = Solution()\n    beginWord = 'hit'\n    endWord = 'hot'\n    wordList = ['hot']\n    expected_output = [['hit', 'hot']]\n    result = solution.findLadders(beginWord, endWord, wordList)", "def test_findLadders():\n    solution = Solution()\n    beginWord = 'lead'\n    endWord = 'gold'\n    wordList = ['load', 'goad', 'goad', 'gold', 'lead', 'loan', 'lawn', 'bald', 'bold', 'cold', 'clad', 'clan', 'clog', 'flog', 'frog', 'glad', 'glam', 'glee']\n    expected_output = [['lead', 'load', 'goad', 'gold']]\n    result = solution.findLadders(beginWord, endWord, wordList)", "def test_findLadders():\n    solution = Solution()\n    beginWord = 'same'\n    endWord = 'same'\n    wordList = ['same', 'sane', 'came', 'lame', 'fame']\n    expected_output = []\n    result = solution.findLadders(beginWord, endWord, wordList)", "def test_findLadders():\n    solution = Solution()\n    beginWord = 'hit'\n    endWord = 'cog'\n    wordList = ['hot', 'dot', 'dog', 'lot', 'log', 'cog', 'hog', 'cot', 'con', 'cog']\n    expected_output = [['hit', 'hot', 'dot', 'dog', 'cog'], ['hit', 'hot', 'lot', 'log', 'cog']]\n    result = solution.findLadders(beginWord, endWord, wordList)", "def test_findLadders():\n    solution = Solution()\n    beginWord = 'cold'\n    endWord = 'warm'\n    wordList = ['cord', 'card', 'ward', 'warp', 'warm']\n    expected_output = [['cold', 'cord', 'card', 'ward', 'warm']]\n    result = solution.findLadders(beginWord, endWord, wordList)", "def test_findLadders():\n    solution = Solution()\n    beginWord = 'abc'\n    endWord = 'xyz'\n    wordList = ['axc', 'ayz', 'xyc', 'xyz']\n    expected_output = []\n    result = solution.findLadders(beginWord, endWord, wordList)", "def test_findLadders():\n    solution = Solution()\n    beginWord = 'hit'\n    endWord = 'cog'\n    wordList = ['hot', 'dot', 'dog', 'lot', 'log', 'cog', 'hog']\n    expected_output = [['hit', 'hot', 'dot', 'dog', 'cog'], ['hit', 'hot', 'lot', 'log', 'cog'], ['hit', 'hot', 'hog', 'dog', 'cog']]\n    result = solution.findLadders(beginWord, endWord, wordList)", "def test_findLadders():\n    solution = Solution()\n    beginWord = 'hit'\n    endWord = 'cog'\n    wordList = ['hot', 'dot', 'dag', 'dog', 'cog', 'log', 'lag']\n    expected_output = [['hit', 'hot', 'dot', 'dog', 'cog'], ['hit', 'hot', 'log', 'cog']]\n    result = solution.findLadders(beginWord, endWord, wordList)", "def test_findLadders():\n    solution = Solution()\n    beginWord = 'start'\n    endWord = 'end'\n    wordList = ['stark', 'stack', 'slack', 'black', 'blank', 'bland', 'brand', 'end']\n    expected_output = [['start', 'stark', 'stack', 'slack', 'black', 'blank', 'bland', 'end']]\n    result = solution.findLadders(beginWord, endWord, wordList)", "def test_findLadders():\n    solution = Solution()\n    beginWord = 'cat'\n    endWord = 'dog'\n    wordList = ['bat', 'rat', 'mat', 'tat', 'sat']\n    expected_output = []\n    result = solution.findLadders(beginWord, endWord, wordList)"]}
{"task_num": 130, "task_title": "Surrounded Regions", "func_name": "solve", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def solve(self, board: List[List[str]]) -> None:\n    if not board:\n      return\n\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(board)\n    n = len(board[0])\n    q = collections.deque()\n\n    for i in range(m):\n      for j in range(n):\n        if i * j == 0 or i == m - 1 or j == n - 1:\n          if board[i][j] == 'O':\n            q.append((i, j))\n            board[i][j] = '*'\n\n    while q:\n      i, j = q.popleft()\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if board[x][y] != 'O':\n          continue\n        q.append((x, y))\n        board[x][y] = '*'\n\n    for row in board:\n      for i, c in enumerate(row):\n        if c == '*':\n          row[i] = 'O'\n        else:\n          row[i] = 'X'\n", "tests": ["def test_solve():\n    solution = Solution()\n    board = [['X', 'X', 'X', 'X'], ['X', 'O', 'O', 'X'], ['X', 'X', 'O', 'X'], ['X', 'O', 'X', 'X']]\n    solution.solve(board)", "def test_solve():\n    solution = Solution()\n    board = [['O', 'O', 'O', 'O'], ['O', 'X', 'X', 'O'], ['O', 'X', 'O', 'O'], ['O', 'O', 'O', 'O']]\n    solution.solve(board)", "def test_solve():\n    solution = Solution()\n    board = [['O', 'X', 'O', 'X', 'O']]\n    solution.solve(board)", "def test_solve():\n    solution = Solution()\n    board = [['O'], ['X'], ['O'], ['X'], ['O']]\n    solution.solve(board)", "def test_solve():\n    solution = Solution()\n    board = [['X', 'X', 'X', 'X'], ['X', 'O', 'O', 'X'], ['X', 'O', 'O', 'X'], ['X', 'X', 'X', 'X']]\n    solution.solve(board)", "def test_solve():\n    solution = Solution()\n    board = [['O', 'O', 'O', 'O'], ['O', 'X', 'X', 'O'], ['O', 'X', 'X', 'O'], ['O', 'O', 'O', 'O']]\n    solution.solve(board)", "def test_solve():\n    solution = Solution()\n    board = [['X', 'X', 'X'], ['X', 'X', 'X'], ['X', 'X', 'X']]\n    solution.solve(board)", "def test_solve():\n    solution = Solution()\n    board = [['O', 'X', 'O', 'X'], ['X', 'O', 'X', 'O'], ['O', 'X', 'O', 'X'], ['X', 'O', 'X', 'O']]\n    solution.solve(board)", "def test_solve():\n    solution = Solution()\n    board = []\n    solution.solve(board)", "def test_solve():\n    solution = Solution()\n    board = [['O']]\n    solution.solve(board)", "def test_solve():\n    solution = Solution()\n    board = [['X']]\n    solution.solve(board)", "def test_solve():\n    solution = Solution()\n    board = [['O', 'O', 'O', 'O', 'O'], ['O', 'X', 'X', 'X', 'O'], ['O', 'X', 'O', 'X', 'O'], ['O', 'X', 'X', 'X', 'O'], ['O', 'O', 'O', 'O', 'O']]\n    solution.solve(board)", "def test_solve():\n    solution = Solution()\n    board = [['X', 'O', 'X', 'O'], ['O', 'X', 'O', 'X'], ['X', 'O', 'X', 'O'], ['O', 'X', 'O', 'X']]\n    solution.solve(board)", "def test_solve():\n    solution = Solution()\n    board = [['O', 'O', 'O', 'O'], ['O', 'O', 'O', 'O'], ['O', 'O', 'O', 'O'], ['O', 'O', 'O', 'O']]\n    solution.solve(board)", "def test_solve():\n    solution = Solution()\n    board = [['X', 'O', 'X', 'X', 'O'], ['O', 'X', 'O', 'X', 'X'], ['X', 'O', 'X', 'O', 'X'], ['X', 'X', 'O', 'X', 'O'], ['O', 'X', 'X', 'O', 'X']]\n    solution.solve(board)", "def test_solve():\n    solution = Solution()\n    board = [['O', 'O'], ['O', 'O']]\n    solution.solve(board)", "def test_solve():\n    solution = Solution()\n    board = [['O', 'X', 'X', 'X'], ['X', 'O', 'X', 'X'], ['X', 'X', 'O', 'X'], ['X', 'X', 'X', 'O']]\n    solution.solve(board)", "def test_solve():\n    solution = Solution()\n    board = [['O', 'O', 'O'], ['O', 'X', 'O'], ['O', 'O', 'O']]\n    solution.solve(board)", "def test_solve():\n    solution = Solution()\n    board = [['X', 'O', 'X', 'X', 'X'], ['X', 'O', 'O', 'O', 'X'], ['X', 'O', 'X', 'O', 'X'], ['X', 'O', 'O', 'O', 'X'], ['X', 'X', 'X', 'O', 'X']]\n    solution.solve(board)", "def test_solve():\n    solution = Solution()\n    board = [['O', 'X', 'O', 'X'], ['X', 'O', 'X', 'O'], ['O', 'X', 'O', 'X'], ['X', 'O', 'X', 'O']]\n    solution.solve(board)"]}
{"task_num": 132, "task_title": "Palindrome Partitioning II", "func_name": "minCut", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minCut(self, s: str) -> int:\n    n = len(s)\n    isPalindrome=[]\n    for _ in range(n):\n      isPalindrome.append([True] * n)\n    dp = [n] * n\n\n    for l in range(2, n + 1):\n      i = 0\n      for j in range(l - 1, n):\n        isPalindrome[i][j] = s[i] == s[j] and isPalindrome[i + 1][j - 1]\n        i += 1\n\n    for i in range(n):\n      if isPalindrome[0][i]:\n        dp[i] = 0\n        continue\n\n      for j in range(i):\n        if isPalindrome[j + 1][i]:\n          dp[i] = min(dp[i], dp[j] + 1)\n\n    return dp[-1]\n", "tests": ["def test_minCut():\n    solution = Solution()\n    assert solution.minCut('aab') == 1", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('abccba') == 0", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('abcba') == 0", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('abcdefg') == 6", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('abacdc') == 2", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('racecar') == 0", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('noonmadam') == 1", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('banana') == 1", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('aabbcc') == 2", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('abbaeae') == 1", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('abcde') == 4", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('a') == 0", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('deed') == 0", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('abccbaa') == 1", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('abcddcbaefg') == 2", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('aabbaba') == 1", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('civiclevel') == 1", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('aabbccdde') == 4", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('ab') == 1", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('madamimadam') == 0"]}
{"task_num": 218, "task_title": "The Skyline Problem", "func_name": "getSkyline", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:\n    n = len(buildings)\n    if n == 0:\n      return []\n    if n == 1:\n      left, right, height = buildings[0]\n      return [[left, height], [right, 0]]\n\n    left = self.getSkyline(buildings[:n // 2])\n    right = self.getSkyline(buildings[n // 2:])\n    return self._merge(left, right)\n\n  def _merge(self, left: List[List[int]], right: List[List[int]]) -> List[List[int]]:\n    ans = []\n    i = 0\n    j = 0\n    leftY = 0\n    rightY = 0\n\n    while i < len(left) and j < len(right):\n      if left[i][0] < right[j][0]:\n        leftY = left[i][1]\n        self._addPoint(ans, left[i][0], max(left[i][1], rightY))\n        i += 1\n      else:\n        rightY = right[j][1]\n        self._addPoint(ans, right[j][0], max(right[j][1], leftY))\n        j += 1\n\n    while i < len(left):\n      self._addPoint(ans, left[i][0], left[i][1])\n      i += 1\n\n    while j < len(right):\n      self._addPoint(ans, right[j][0], right[j][1])\n      j += 1\n\n    return ans\n\n  def _addPoint(self, ans: List[List[int]], x: int, y: int) -> None:\n    if ans and ans[-1][0] == x:\n      ans[-1][1] = y\n      return\n    if ans and ans[-1][1] == y:\n      return\n    ans.append([x, y])\n", "tests": ["def test_getSkyline():\n    solution = Solution()\n    assert solution.getSkyline([[2, 9, 10], [3, 7, 15], [5, 12, 12], [15, 20, 10], [19, 24, 8]]) == [[2, 10], [3, 15], [7, 12], [12, 0], [15, 10], [20, 8], [24, 0]]", "def test_getSkyline():\n    solution = Solution()\n    assert solution.getSkyline([[0, 2, 3], [2, 5, 3]]) == [[0, 3], [5, 0]]", "def test_getSkyline():\n    solution = Solution()\n    assert solution.getSkyline([[1, 3, 3], [2, 4, 4], [5, 6, 1]]) == [[1, 3], [2, 4], [4, 0], [5, 1], [6, 0]]", "def test_getSkyline():\n    solution = Solution()\n    assert solution.getSkyline([[1, 2, 1], [1, 2, 2], [1, 2, 3]]) == [[1, 3], [2, 0]]", "def test_getSkyline():\n    solution = Solution()\n    assert solution.getSkyline([[3, 6, 4], [1, 3, 2], [6, 9, 2], [8, 11, 3]]) == [[1, 2], [3, 4], [6, 2], [8, 3], [11, 0]]", "def test_getSkyline():\n    solution = Solution()\n    assert solution.getSkyline([[0, 5, 11], [1, 2, 6], [2, 4, 7], [3, 6, 10]]) == [[0, 11], [5, 10], [6, 0]]", "def test_getSkyline():\n    solution = Solution()\n    assert solution.getSkyline([[5, 10, 5], [10, 15, 5], [15, 20, 10], [20, 25, 5]]) == [[5, 5], [15, 10], [20, 5], [25, 0]]", "def test_getSkyline():\n    solution = Solution()\n    assert solution.getSkyline([[2, 4, 5], [4, 8, 7], [6, 9, 6]]) == [[2, 5], [4, 7], [8, 6], [9, 0]]", "def test_getSkyline():\n    solution = Solution()\n    assert solution.getSkyline([[1, 5, 8], [2, 6, 4], [3, 7, 6], [10, 12, 3]]) == [[1, 8], [5, 6], [7, 0], [10, 3], [12, 0]]", "def test_getSkyline():\n    solution = Solution()\n    assert solution.getSkyline([[0, 4, 5], [4, 8, 7], [5, 10, 6], [9, 12, 4]]) == [[0, 5], [4, 7], [8, 6], [10, 4], [12, 0]]", "def test_getSkyline():\n    solution = Solution()\n    assert solution.getSkyline([[2, 3, 3], [3, 4, 4], [4, 5, 2]]) == [[2, 3], [3, 4], [4, 2], [5, 0]]", "def test_getSkyline():\n    solution = Solution()\n    assert solution.getSkyline([[1, 10, 2], [2, 4, 3], [5, 8, 6], [7, 9, 4]]) == [[1, 2], [2, 3], [4, 2], [5, 6], [8, 4], [9, 2], [10, 0]]", "def test_getSkyline():\n    solution = Solution()\n    assert solution.getSkyline([[1, 5, 5], [2, 6, 6], [3, 7, 4], [8, 10, 3], [9, 11, 7]]) == [[1, 5], [2, 6], [6, 4], [7, 0], [8, 3], [9, 7], [11, 0]]", "def test_getSkyline():\n    solution = Solution()\n    assert solution.getSkyline([[0, 3, 2], [1, 5, 3], [4, 7, 4], [6, 9, 2]]) == [[0, 2], [1, 3], [5, 4], [7, 2], [9, 0]]", "def test_getSkyline():\n    solution = Solution()\n    assert solution.getSkyline([[2, 4, 8], [3, 6, 5], [7, 9, 3], [8, 11, 6]]) == [[2, 8], [4, 5], [6, 0], [7, 3], [8, 6], [11, 0]]", "def test_getSkyline():\n    solution = Solution()\n    assert solution.getSkyline([[1, 3, 4], [2, 5, 2], [4, 7, 6], [6, 8, 3]]) == [[1, 4], [3, 2], [4, 6], [7, 3], [8, 0]]", "def test_getSkyline():\n    solution = Solution()\n    assert solution.getSkyline([[0, 1, 3], [2, 5, 4], [4, 6, 2], [5, 8, 5]]) == [[0, 3], [1, 0], [2, 4], [5, 5], [8, 0]]", "def test_getSkyline():\n    solution = Solution()\n    assert solution.getSkyline([[1, 4, 2], [2, 6, 5], [5, 7, 3], [8, 10, 4]]) == [[1, 2], [2, 5], [6, 3], [7, 0], [8, 4], [10, 0]]", "def test_getSkyline():\n    solution = Solution()\n    assert solution.getSkyline([[1, 3, 4], [2, 4, 2], [3, 5, 3], [6, 9, 7], [8, 11, 5]]) == [[1, 4], [3, 3], [5, 0], [6, 7], [9, 5], [11, 0]]", "def test_getSkyline():\n    solution = Solution()\n    assert solution.getSkyline([[0, 2, 3], [1, 4, 4], [3, 6, 2], [5, 8, 5]]) == [[0, 3], [1, 4], [4, 2], [5, 5], [8, 0]]"]}
{"task_num": 227, "task_title": "Basic Calculator II", "func_name": "calculate", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def calculate(self, s: str) -> int:\n    ans = 0\n    prevNum = 0\n    currNum = 0\n    op = '+'\n\n    for i, c in enumerate(s):\n      if c.isdigit():\n        currNum = currNum * 10 + int(c)\n      if not c.isdigit() and c != ' ' or i == len(s) - 1:\n        if op == '+' or op == '-':\n          ans += prevNum\n          prevNum = currNum if op == '+' else -currNum\n        elif op == '*':\n          prevNum = prevNum * currNum\n        elif op == '/':\n          if prevNum < 0:\n            prevNum = math.ceil(prevNum / currNum)\n          else:\n            prevNum = prevNum // currNum\n        op = c\n        currNum = 0\n\n    return ans + prevNum\n", "tests": ["def test_calculate():\n    solution = Solution()\n    assert solution.calculate('2+3*2') == 8", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('14-3/2') == 13", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('10+6/3*2-5') == 9", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('-3+8/2') == 1", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('4*5/2+3-7') == 6", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('3+5*2-8/4') == 10", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('18/3+2*4-1') == 13", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('7*4-10/2+6') == 30", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('3-9/3*2+7') == 4", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('5+8*3-4/2') == 27", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('20-5*3+8/4') == 6", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('2*3+5/1-9') == 2", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('15/3*2+4-6') == 8", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('1+2-3*4/2') == -3", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('6/2*3-4+8') == 13", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('8+3*4-6/2') == 16", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('12-4*2+10/5') == 6", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('10*2/4+1-5') == 1", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('9-2+5*3/3') == 12", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('5*3-7+8/4') == 11"]}
{"task_num": 289, "task_title": "Game of Life", "func_name": "gameOfLife", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def gameOfLife(self, board: List[List[int]]) -> None:\n    m = len(board)\n    n = len(board[0])\n\n    for i in range(m):\n      for j in range(n):\n        ones = 0\n        for x in range(max(0, i - 1), min(m, i + 2)):\n          for y in range(max(0, j - 1), min(n, j + 2)):\n            ones += board[x][y] & 1\n\n        if board[i][j] == 1 and (ones == 3 or ones == 4):\n          board[i][j] |= 0b10\n\n        if board[i][j] == 0 and ones == 3:\n          board[i][j] |= 0b10\n\n    for i in range(m):\n      for j in range(n):\n        board[i][j] >>= 1\n", "tests": ["def test_gameOfLife():\n    solution = Solution()\n    board = [[0, 1, 0], [0, 0, 1], [1, 1, 1], [0, 0, 0]]\n    expected_output = [[0, 0, 0], [1, 0, 1], [0, 1, 1], [0, 1, 0]]\n    solution.gameOfLife(board)", "def test_gameOfLife():\n    solution = Solution()\n    board = [[1, 1], [1, 0]]\n    expected_output = [[1, 1], [1, 1]]\n    solution.gameOfLife(board)", "def test_gameOfLife():\n    solution = Solution()\n    board = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]\n    expected_output = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n    solution.gameOfLife(board)", "def test_gameOfLife():\n    solution = Solution()\n    board = [[1, 1, 1, 0, 0]]\n    expected_output = [[0, 1, 0, 0, 0]]\n    solution.gameOfLife(board)", "def test_gameOfLife():\n    solution = Solution()\n    board = [[1], [0], [1], [0], [1]]\n    expected_output = [[0], [0], [0], [0], [0]]\n    solution.gameOfLife(board)", "def test_gameOfLife():\n    solution = Solution()\n    board = [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\n    expected_output = [[1, 0, 1], [0, 0, 0], [1, 0, 1]]\n    solution.gameOfLife(board)", "def test_gameOfLife():\n    solution = Solution()\n    board = [[0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0]]\n    expected_output = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]\n    solution.gameOfLife(board)", "def test_gameOfLife():\n    solution = Solution()\n    board = [[0, 1, 0], [0, 1, 0], [0, 1, 0]]\n    expected_output = [[0, 0, 0], [1, 1, 1], [0, 0, 0]]\n    solution.gameOfLife(board)", "def test_gameOfLife():\n    solution = Solution()\n    board = [[1, 1], [1, 1]]\n    expected_output = [[1, 1], [1, 1]]\n    solution.gameOfLife(board)", "def test_gameOfLife():\n    solution = Solution()\n    board = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n    expected_output = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n    solution.gameOfLife(board)", "def test_gameOfLife():\n    solution = Solution()\n    board = [[1, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 1]]\n    expected_output = [[1, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 1]]\n    solution.gameOfLife(board)", "def test_gameOfLife():\n    solution = Solution()\n    board = [[0, 1, 1, 1], [1, 1, 1, 0]]\n    expected_output = [[0, 1, 0, 1], [1, 0, 1, 0]]\n    solution.gameOfLife(board)", "def test_gameOfLife():\n    solution = Solution()\n    board = [[1, 0, 0, 1, 0], [0, 1, 0, 0, 1], [1, 0, 1, 0, 0], [0, 1, 0, 1, 0], [1, 0, 0, 0, 1]]\n    expected_output = [[0, 0, 0, 0, 0], [0, 1, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]\n    solution.gameOfLife(board)", "def test_gameOfLife():\n    solution = Solution()\n    board = [[0, 0, 1, 0, 0], [0, 0, 1, 0, 0], [1, 1, 1, 1, 1], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0]]\n    expected_output = [[0, 0, 1, 0, 0], [1, 0, 0, 0, 1], [0, 0, 0, 0, 0], [1, 0, 0, 0, 1], [0, 0, 1, 0, 0]]\n    solution.gameOfLife(board)", "def test_gameOfLife():\n    solution = Solution()\n    board = [[0, 1, 0], [1, 1, 1], [0, 1, 0]]\n    expected_output = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]\n    solution.gameOfLife(board)", "def test_gameOfLife():\n    solution = Solution()\n    board = [[1, 0], [0, 1]]\n    expected_output = [[0, 0], [0, 0]]\n    solution.gameOfLife(board)", "def test_gameOfLife():\n    solution = Solution()\n    board = [[0, 1, 0, 0], [0, 0, 1, 0], [1, 1, 1, 0], [0, 0, 0, 0]]\n    expected_output = [[0, 0, 0, 0], [1, 0, 1, 0], [0, 1, 1, 0], [0, 1, 0, 0]]\n    solution.gameOfLife(board)", "def test_gameOfLife_largeStablePattern():\n    solution = Solution()\n    board = [\n        [1, 1, 0, 0, 0, 0, 1, 1],\n        [1, 0, 0, 0, 0, 0, 0, 1],\n        [0, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0, 0],\n        [1, 0, 0, 0, 0, 0, 0, 1],\n        [1, 1, 0, 0, 0, 0, 1, 1]\n    ]\n    expected_output = [\n        [1, 1, 0, 0, 0, 0, 1, 1],", "def test_gameOfLife():\n    solution = Solution()\n    board = [[1]]\n    expected_output = [[0]]\n    solution.gameOfLife(board)", "def test_gameOfLife():\n    solution = Solution()\n    board = [[1, 0, 0], [1, 0, 0], [1, 1, 1]]\n    expected_output = [[0, 0, 0], [1, 0, 0], [1, 1, 0]]\n    solution.gameOfLife(board)"]}
{"task_num": 310, "task_title": "Minimum Height Trees", "func_name": "findMinHeightTrees", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\n    if n == 1 or not edges:\n      return [0]\n\n    ans = []\n    graph = collections.defaultdict(set)\n\n    for u, v in edges:\n      graph[u].add(v)\n      graph[v].add(u)\n\n    for label, children in graph.items():\n      if len(children) == 1:\n        ans.append(label)\n\n    while n > 2:\n      n -= len(ans)\n      nextLeaves = []\n      for leaf in ans:\n        u = next(iter(graph[leaf]))\n        graph[u].remove(leaf)\n        if len(graph[u]) == 1:\n          nextLeaves.append(u)\n      ans = nextLeaves\n\n    return ans\n", "tests": ["def test_findMinHeightTrees():\n    solution = Solution()\n    n = 4\n    edges = [[1, 0], [1, 2], [1, 3]]\n    assert sorted(solution.findMinHeightTrees(n, edges)) == [1]", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 6\n    edges = [[0, 1], [0, 2], [0, 3], [3, 4], [4, 5]]\n    assert sorted(solution.findMinHeightTrees(n, edges)) == [3]", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 1\n    edges = []\n    assert solution.findMinHeightTrees(n, edges) == [0]", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 2\n    edges = [[0, 1]]\n    assert sorted(solution.findMinHeightTrees(n, edges)) == [0, 1]", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 7\n    edges = [[0, 1], [1, 2], [1, 3], [2, 4], [3, 5], [4, 6]]\n    assert sorted(solution.findMinHeightTrees(n, edges)) == [1, 2]", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1], [0, 2], [2, 3], [2, 4]]\n    assert sorted(solution.findMinHeightTrees(n, edges)) == [2]", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1], [1, 2]]\n    assert sorted(solution.findMinHeightTrees(n, edges)) == [1]", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 8\n    edges = [[0, 1], [1, 2], [1, 3], [3, 4], [4, 5], [4, 6], [6, 7]]\n    assert sorted(solution.findMinHeightTrees(n, edges)) == [3, 4]", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 9\n    edges = [[0, 1], [0, 2], [0, 3], [3, 4], [4, 5], [5, 6], [5, 7], [5, 8]]\n    assert sorted(solution.findMinHeightTrees(n, edges)) == [5]", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 10\n    edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [2, 6], [6, 7], [7, 8], [8, 9]]\n    assert sorted(solution.findMinHeightTrees(n, edges)) == [1, 2]", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 11\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [8, 10]]\n    assert sorted(solution.findMinHeightTrees(n, edges)) == [4, 5]", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 12\n    edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [2, 6], [5, 7], [7, 8], [8, 9], [9, 10], [10, 11]]\n    assert sorted(solution.findMinHeightTrees(n, edges)) == [5, 1]", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 13\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4], [2, 5], [5, 6], [6, 7], [5, 8], [8, 9], [9, 10], [10, 11], [10, 12]]\n    assert sorted(solution.findMinHeightTrees(n, edges)) == [5]", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 14\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9, 10], [10, 11], [11, 12], [11, 13]]\n    assert sorted(solution.findMinHeightTrees(n, edges)) == [6]", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 15\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [3, 7], [7, 8], [8, 9], [9, 10], [8, 11], [11, 12], [12, 13], [13, 14]]\n    assert sorted(solution.findMinHeightTrees(n, edges)) == [3, 8]", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 16\n    edges = [[0, 1], [1, 2], [1, 3], [2, 4], [2, 5], [4, 6], [4, 7], [5, 8], [5, 9], [3, 10], [10, 11], [11, 12], [12, 13], [13, 14], [14, 15]]\n    assert sorted(solution.findMinHeightTrees(n, edges)) == [1, 2]", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 17\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9, 10], [10, 11], [11, 12], [12, 13], [12, 14], [14, 15], [14, 16]]\n    assert sorted(solution.findMinHeightTrees(n, edges)) == [6, 7]", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 18\n    edges = [[0, 1], [0, 2], [1, 3], [1, 4], [1, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9, 10], [10, 11], [11, 12], [12, 13], [13, 14], [14, 15], [14, 16], [14, 17]]\n    assert sorted(solution.findMinHeightTrees(n, edges)) == [1, 5]", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 19\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9, 10], [10, 11], [11, 12], [12, 13], [13, 14], [14, 15], [15, 16], [16, 17], [17, 18]]\n    assert sorted(solution.findMinHeightTrees(n, edges)) == [9]", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 20\n    edges = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 5], [3, 6], [6, 7], [7, 8], [8, 9], [9, 10], [10, 11], [11, 12], [12, 13], [13, 14], [14, 15], [15, 16], [16, 17], [17, 18], [18, 19]]\n    assert sorted(solution.findMinHeightTrees(n, edges)) == [3, 8]"]}
{"task_num": 327, "task_title": "Count of Range Sum", "func_name": "countRangeSum", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countRangeSum(self, nums: List[int], lower: int, upper: int) -> int:\n    n = len(nums)\n    self.ans = 0\n    prefix = [0] + list(itertools.accumulate(nums))\n\n    self._mergeSort(prefix, 0, n, lower, upper)\n    return self.ans\n\n  def _mergeSort(self, prefix: List[int], l: int, r: int, lower: int, upper: int) -> None:\n    if l >= r:\n      return\n\n    m = (l + r) // 2\n    self._mergeSort(prefix, l, m, lower, upper)\n    self._mergeSort(prefix, m + 1, r, lower, upper)\n    self._merge(prefix, l, m, r, lower, upper)\n\n  def _merge(self, prefix: List[int], l: int, m: int, r: int, lower: int, upper: int) -> None:\n    lo = m + 1\n    hi = m + 1\n\n    for i in range(l, m + 1):\n      while lo <= r and prefix[lo] - prefix[i] < lower:\n        lo += 1\n      while hi <= r and prefix[hi] - prefix[i] <= upper:\n        hi += 1\n      self.ans += hi - lo\n\n    sorted = [0] * (r - l + 1)\n    k = 0\n    i = l\n    j = m + 1\n\n    while i <= m and j <= r:\n      if prefix[i] < prefix[j]:\n        sorted[k] = prefix[i]\n        k += 1\n        i += 1\n      else:\n        sorted[k] = prefix[j]\n        k += 1\n        j += 1\n\n    while i <= m:\n      sorted[k] = prefix[i]\n      k += 1\n      i += 1\n\n    while j <= r:\n      sorted[k] = prefix[j]\n      k += 1\n      j += 1\n\n    prefix[l:l + len(sorted)] = sorted\n", "tests": ["def test_countRangeSum():\n    solution = Solution()\n    assert solution.countRangeSum([1, 2, 3, 4], 1, 6) == 8", "def test_countRangeSum():\n    solution = Solution()\n    assert solution.countRangeSum([-3, 1, 2, -2, 5, -1], -3, 2) == 7", "def test_countRangeSum():\n    solution = Solution()\n    assert solution.countRangeSum([0, 0, 0, 0], 0, 0) == 10", "def test_countRangeSum():\n    solution = Solution()\n    assert solution.countRangeSum([3, -1, 4, -2, -4, 5], -2, 3) == 9", "def test_countRangeSum():\n    solution = Solution()\n    assert solution.countRangeSum([5, -3, 2, 7, -8, 4], 0, 10) == 12", "def test_countRangeSum():\n    solution = Solution()\n    assert solution.countRangeSum([-2, 5, -1], -2, 2) == 3", "def test_countRangeSum():\n    solution = Solution()\n    assert solution.countRangeSum([10, -5, 6, -3, 0, 2], -4, 7) == 11", "def test_countRangeSum():\n    solution = Solution()\n    assert solution.countRangeSum([1, -1, 1, -1, 1], -1, 1) == 15", "def test_countRangeSum():\n    solution = Solution()\n    assert solution.countRangeSum([2, 4, -2, 1, 3], 2, 6) == 6", "def test_countRangeSum():\n    solution = Solution()\n    assert solution.countRangeSum([-1, 3, -2, 8, -5], -3, 4) == 7", "def test_countRangeSum():\n    solution = Solution()\n    assert solution.countRangeSum([4, -1, 2, -6, 3, 1], -5, 5) == 13", "def test_countRangeSum():\n    solution = Solution()\n    assert solution.countRangeSum([0, 6, -3, 1, -8, 4, 7], -7, 3) == 10", "def test_countRangeSum():\n    solution = Solution()\n    assert solution.countRangeSum([9, -4, -2, 3, -1, 6], 1, 10) == 13", "def test_countRangeSum():\n    solution = Solution()\n    assert solution.countRangeSum([-6, 1, 3, -5, 2, 4], -4, 4) == 14", "def test_countRangeSum():\n    solution = Solution()\n    assert solution.countRangeSum([7, -3, 5, -2, -1, 8, -4], -3, 6) == 17", "def test_countRangeSum():\n    solution = Solution()\n    assert solution.countRangeSum([8, -2, 3, -7, 4, 1, -5], -6, 2) == 12", "def test_countRangeSum():\n    solution = Solution()\n    assert solution.countRangeSum([3, -6, 2, 5, -3, 4, -1], -2, 5) == 18", "def test_countRangeSum():\n    solution = Solution()\n    assert solution.countRangeSum([-7, 2, 1, -4, 6, 3, -5], -5, 3) == 16", "def test_countRangeSum():\n    solution = Solution()\n    assert solution.countRangeSum([5, -2, -1, 3, 7, -3, 0], -4, 7) == 21", "def test_countRangeSum():\n    solution = Solution()\n    assert solution.countRangeSum([4, -3, 6, -7, 2, 5, -4], -6, 4) == 15"]}
{"task_num": 335, "task_title": "Self Crossing", "func_name": "isSelfCrossing", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isSelfCrossing(self, x: List[int]) -> bool:\n    if len(x) <= 3:\n      return False\n\n    for i in range(3, len(x)):\n      if x[i - 2] <= x[i] and x[i - 1] <= x[i - 3]:\n        return True\n      if i >= 4 and x[i - 1] == x[i - 3] and x[i - 2] <= x[i] + x[i - 4]:\n        return True\n      if i >= 5 and x[i - 4] <= x[i - 2] and x[i - 2] <= x[i] + x[i - 4] and x[i - 1] <= x[i - 3] and x[i - 3] <= x[i - 1] + x[i - 5]:\n        return True\n\n    return False\n", "tests": ["def test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([2, 1, 1, 2]) == True", "def test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([1, 2, 3, 4]) == False", "def test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([1, 1, 2, 1, 1]) == True", "def test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([1, 1, 1, 1]) == True", "def test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([1, 2, 3, 4, 5, 6]) == False", "def test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([3, 3, 4, 2, 2]) == True", "def test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([2, 3, 4, 5, 1, 1, 1]) == False", "def test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([1, 1, 2, 2, 1, 1]) == True", "def test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([1, 2, 3, 2, 1, 1]) == True", "def test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([2, 2, 3, 3, 2, 1]) == True", "def test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([4, 1, 1, 2]) == False", "def test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([3, 1, 1, 3, 2, 1]) == True", "def test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([1, 1, 1, 1, 1, 1, 1, 1]) == True", "def test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([5, 4, 3, 2, 1, 1, 2, 2]) == True", "def test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([2, 3, 3, 2, 2, 1, 1]) == True", "def test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([6, 5, 4, 3, 2, 1]) == False", "def test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([3, 3, 4, 2, 2, 2]) == True", "def test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([10, 2, 10, 2, 2, 10]) == True", "def test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([1, 2, 3, 4, 5, 6, 7, 8, 9, 1]) == False", "def test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([2, 2, 2, 2, 1, 1, 1, 1]) == True"]}
{"task_num": 336, "task_title": "Palindrome Pairs", "func_name": "palindromePairs", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def palindromePairs(self, words: List[str]) -> List[List[int]]:\n    ans = []\n    dict = {word[::-1]: i for i, word in enumerate(words)}\n\n    for i, word in enumerate(words):\n      if \"\" in dict and dict[\"\"] != i and word == word[::-1]:\n        ans.append([i, dict[\"\"]])\n\n      for j in range(1, len(word) + 1):\n        l = word[:j]\n        r = word[j:]\n        if l in dict and dict[l] != i and r == r[::-1]:\n          ans.append([i, dict[l]])\n        if r in dict and dict[r] != i and l == l[::-1]:\n          ans.append([dict[r], i])\n\n    return ans\n", "tests": ["def test_palindromePairs():\n    solution = Solution()\n    words = ['bat', 'tab', 'cat']\n    expected_output = [[0, 1], [1, 0]]\n    assert solution.palindromePairs(words) == expected_output", "def test_palindromePairs():\n    solution = Solution()\n    words = ['abc', 'cba', '']\n    expected_output = [[0, 2], [1, 2], [2, 0], [2, 1]]\n    assert solution.palindromePairs(words) == expected_output", "def test_palindromePairs():\n    solution = Solution()\n    words = ['a', 'b', 'aba', 'c']\n    expected_output = [[0, 2], [1, 2], [2, 0], [2, 1]]\n    assert solution.palindromePairs(words) == expected_output", "def test_palindromePairs():\n    solution = Solution()\n    words = ['abcd', 'dcba', 'lls', 's', 'sssll']\n    expected_output = [[0, 1], [1, 0], [3, 2], [2, 4]]\n    assert solution.palindromePairs(words) == expected_output", "def test_palindromePairs():\n    solution = Solution()\n    words = ['race', 'car']\n    expected_output = []\n    assert solution.palindromePairs(words) == expected_output", "def test_palindromePairs():\n    solution = Solution()\n    words = ['deed', 'de', 'ed']\n    expected_output = [[1, 0], [2, 0]]\n    assert solution.palindromePairs(words) == expected_output", "def test_palindromePairs():\n    solution = Solution()\n    words = ['', 'a', 'abcd', 'dcba']\n    expected_output = [[0, 1], [1, 0], [0, 2], [0, 3], [3, 2]]\n    assert solution.palindromePairs(words) == expected_output", "def test_palindromePairs():\n    solution = Solution()\n    words = ['noon', 'racecar', 'civic']\n    expected_output = []\n    assert solution.palindromePairs(words) == expected_output", "def test_palindromePairs():\n    solution = Solution()\n    words = ['gab', 'bag', 'g']\n    expected_output = [[0, 1], [1, 0]]\n    assert solution.palindromePairs(words) == expected_output", "def test_palindromePairs():\n    solution = Solution()\n    words = ['aaa', 'aaaa', 'aa']\n    expected_output = [[0, 2], [2, 0]]\n    assert solution.palindromePairs(words) == expected_output", "def test_palindromePairs():\n    solution = Solution()\n    words = ['abcba', 'xyz', 'y']\n    expected_output = []\n    assert solution.palindromePairs(words) == expected_output", "def test_palindromePairs():\n    solution = Solution()\n    words = ['apple', 'elppa', 'lemon', 'nomel']\n    expected_output = [[0, 1], [1, 0], [2, 3], [3, 2]]\n    assert solution.palindromePairs(words) == expected_output", "def test_palindromePairs():\n    solution = Solution()\n    words = ['rotor', 'tor', 'or']\n    expected_output = [[1, 2]]\n    assert solution.palindromePairs(words) == expected_output", "def test_palindromePairs():\n    solution = Solution()\n    words = ['mom', 'dad', 'madam', 'm', 'am']\n    expected_output = [[3, 2]]\n    assert solution.palindromePairs(words) == expected_output", "def test_palindromePairs():\n    solution = Solution()\n    words = ['rev', 'ever', 'ver', 'eve']\n    expected_output = [[0, 1], [1, 0], [2, 1]]\n    assert solution.palindromePairs(words) == expected_output", "def test_palindromePairs():\n    solution = Solution()\n    words = ['a', 'bc', 'cba', 'bca']\n    expected_output = [[0, 2], [3, 0]]\n    assert solution.palindromePairs(words) == expected_output", "def test_palindromePairs():\n    solution = Solution()\n    words = ['level', 'lever', 'rev']\n    expected_output = [[1, 2]]\n    assert solution.palindromePairs(words) == expected_output", "def test_palindromePairs():\n    solution = Solution()\n    words = ['ab', 'ba', 'abc', 'cba', 'b']\n    expected_output = [[0, 1], [1, 0], [2, 3], [3, 2]]\n    assert solution.palindromePairs(words) == expected_output", "def test_palindromePairs():\n    solution = Solution()\n    words = ['radar', 'ada', 'd']\n    expected_output = []\n    assert solution.palindromePairs(words) == expected_output", "def test_palindromePairs():\n    solution = Solution()\n    words = ['bob', 'obo', 'bobobo', 'o']\n    expected_output = [[0, 1], [1, 0], [2, 3], [3, 2]]\n    assert solution.palindromePairs(words) == expected_output"]}
{"task_num": 391, "task_title": "Perfect Rectangle", "func_name": "isRectangleCover", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Set\n\nclass Solution:\n  def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\n    area = 0\n    x1 = math.inf\n    y1 = math.inf\n    x2 = -math.inf\n    y2 = -math.inf\n    corners: Set[Tuple[int, int]] = set()\n\n    for x, y, a, b in rectangles:\n      area += (a - x) * (b - y)\n      x1 = min(x1, x)\n      y1 = min(y1, y)\n      x2 = max(x2, a)\n      y2 = max(y2, b)\n\n      for point in [(x, y), (x, b), (a, y), (a, b)]:\n        if point in corners:\n          corners.remove(point)\n        else:\n          corners.add(point)\n\n    if len(corners) != 4:\n      return False\n    if (x1, y1) not in corners or (x1, y2) not in corners or (x2, y1) not in corners or (x2, y2) not in corners:\n      return False\n    return area == (x2 - x1) * (y2 - y1)\n", "tests": ["def test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[1, 1, 3, 3], [3, 1, 4, 2], [3, 2, 4, 4], [1, 3, 2, 4], [2, 3, 3, 4]]\n    assert solution.isRectangleCover(rectangles) == True", "def test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[1, 1, 2, 3], [1, 3, 2, 4], [2, 1, 3, 2], [2, 2, 3, 4]]\n    assert solution.isRectangleCover(rectangles) == False", "def test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[1, 1, 2, 2], [3, 3, 4, 4]]\n    assert solution.isRectangleCover(rectangles) == False", "def test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[1, 1, 3, 3], [2, 2, 4, 4]]\n    assert solution.isRectangleCover(rectangles) == False", "def test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[0, 0, 4, 4]]\n    assert solution.isRectangleCover(rectangles) == True", "def test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[0, 0, 2, 2], [2, 0, 4, 2], [0, 2, 2, 4], [2, 2, 4, 4]]\n    assert solution.isRectangleCover(rectangles) == True", "def test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[0, 0, 3, 1], [0, 1, 1, 3], [1, 2, 2, 3], [2, 1, 3, 3]]\n    assert solution.isRectangleCover(rectangles) == False", "def test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[0, 0, 2, 2], [2, 0, 3, 1], [2, 1, 3, 3], [0, 2, 1, 3], [1, 2, 2, 3]]\n    assert solution.isRectangleCover(rectangles) == False", "def test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[0, 0, 1, 2], [1, 0, 3, 1], [1, 1, 3, 2]]\n    assert solution.isRectangleCover(rectangles) == True", "def test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[0, 0, 1, 1], [1, 0, 2, 1], [0, 1, 1, 2], [1, 1, 2, 2]]\n    assert solution.isRectangleCover(rectangles) == True", "def test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[0, 0, 2, 2], [1, 1, 3, 3], [2, 0, 3, 1]]\n    assert solution.isRectangleCover(rectangles) == False", "def test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[0, 0, 1, 1], [1, 0, 2, 1], [0, 1, 1, 2], [1, 1, 2, 2], [2, 0, 3, 2]]\n    assert solution.isRectangleCover(rectangles) == True", "def test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[0, 0, 1, 3], [1, 2, 2, 3], [1, 0, 2, 1], [2, 0, 3, 3]]\n    assert solution.isRectangleCover(rectangles) == False", "def test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[0, 0, 3, 1], [0, 1, 1, 3], [2, 1, 3, 3], [0, 2, 3, 3]]\n    assert solution.isRectangleCover(rectangles) == False", "def test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[0, 0, 1, 1], [1, 1, 2, 2], [0, 2, 1, 3], [1, 3, 2, 4]]\n    assert solution.isRectangleCover(rectangles) == False", "def test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[0, 0, 2, 2], [2, 0, 4, 1], [2, 1, 4, 3], [1, 2, 3, 4]]\n    assert solution.isRectangleCover(rectangles) == False", "def test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[0, 0, 1, 1], [1, 0, 2, 1], [2, 0, 3, 1], [0, 1, 1, 2], [1, 1, 2, 2], [2, 1, 3, 2], [0, 2, 1, 3], [1, 2, 2, 3], [2, 2, 3, 3]]\n    assert solution.isRectangleCover(rectangles) == True", "def test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[0, 0, 3, 1], [0, 1, 1, 3], [1, 1, 2, 2], [2, 1, 3, 3], [1, 2, 2, 3]]\n    assert solution.isRectangleCover(rectangles) == False", "def test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[0, 0, 1, 1], [1, 0, 2, 1], [3, 3, 4, 4], [5, 5, 6, 6]]\n    assert solution.isRectangleCover(rectangles) == False", "def test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[0, 0, 2, 2], [0, 2, 2, 4], [1, 1, 3, 3], [2, 0, 4, 2], [2, 2, 4, 4]]\n    assert solution.isRectangleCover(rectangles) == False"]}
{"task_num": 402, "task_title": "Remove K Digits", "func_name": "removeKdigits", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def removeKdigits(self, num: str, k: int) -> str:\n    if len(num) == k:\n      return '0'\n\n    ans = []\n    stack = []\n\n    for i, digit in enumerate(num):\n      while k > 0 and stack and stack[-1] > digit:\n        stack.pop()\n        k -= 1\n      stack.append(digit)\n\n    for _ in range(k):\n      stack.pop()\n\n    for c in stack:\n      if c == '0' and not ans:\n        continue\n      ans.append(c)\n\n    return ''.join(ans) if ans else '0'\n", "tests": ["def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits('1432219', 3) == '1219'", "def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits('100200', 1) == '200'", "def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits('10', 2) == '0'", "def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits('123456', 3) == '123'", "def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits('10200', 1) == '200'", "def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits('9', 1) == '0'", "def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits('7654321', 3) == '4321'", "def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits('1111111', 3) == '1111'", "def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits('234567', 5) == '2'", "def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits('112', 1) == '11'", "def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits('9876543210', 9) == '0'", "def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits('2222222', 2) == '22222'", "def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits('54321', 2) == '321'", "def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits('88888888', 5) == '888'", "def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits('10234', 2) == '23'", "def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits('98765', 4) == '5'", "def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits('120', 1) == '10'", "def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits('3210', 2) == '10'", "def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits('998877', 3) == '877'", "def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits('53028', 2) == '028'"]}
{"task_num": 407, "task_title": "Trapping Rain Water II", "func_name": "trapRainWater", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def trapRainWater(self, heightMap: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(heightMap)\n    n = len(heightMap[0])\n    ans = 0\n    minHeap = []\n    seen = set()\n\n    for i in range(m):\n      heapq.heappush(minHeap, (heightMap[i][0], i, 0))\n      heapq.heappush(minHeap, (heightMap[i][n - 1], i, n - 1))\n      seen.add((i, 0))\n      seen.add((i, n - 1))\n\n    for j in range(1, n - 1):\n      heapq.heappush(minHeap, (heightMap[0][j], 0, j))\n      heapq.heappush(minHeap, (heightMap[m - 1][j], m - 1, j))\n      seen.add((0, j))\n      seen.add((m - 1, j))\n\n    while minHeap:\n      h, i, j = heapq.heappop(minHeap)\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if (x, y) in seen:\n          continue\n        if heightMap[x][y] < h:\n          ans += h - heightMap[x][y]\n          heapq.heappush(minHeap, (h, x, y))\n        else:\n          heapq.heappush(minHeap, (heightMap[x][y], x, y))\n        seen.add((x, y))\n\n    return ans\n", "tests": ["def test_trapRainWater():\n    solution = Solution()\n    heightMap = [[1, 4, 3, 1, 3, 2], [3, 2, 1, 3, 2, 4], [2, 3, 3, 2, 3, 1]]\n    assert solution.trapRainWater(heightMap) == 4", "def test_trapRainWater():\n    solution = Solution()\n    heightMap = [[12, 13, 1, 12], [13, 4, 13, 12], [13, 8, 10, 12], [12, 13, 12, 12], [13, 13, 13, 13]]\n    assert solution.trapRainWater(heightMap) == 14", "def test_trapRainWater():\n    solution = Solution()\n    heightMap = [[5, 5, 5, 5], [5, 1, 1, 5], [5, 1, 1, 5], [5, 5, 5, 5]]\n    assert solution.trapRainWater(heightMap) == 16", "def test_trapRainWater():\n    solution = Solution()\n    heightMap = [[3, 1, 2, 4, 1, 3]]\n    assert solution.trapRainWater(heightMap) == 0", "def test_trapRainWater():\n    solution = Solution()\n    heightMap = [[3], [1], [2], [4], [1], [3]]\n    assert solution.trapRainWater(heightMap) == 0", "def test_trapRainWater():\n    solution = Solution()\n    heightMap = [[5, 5, 5], [5, 5, 5], [5, 5, 5]]\n    assert solution.trapRainWater(heightMap) == 0", "def test_trapRainWater():\n    solution = Solution()\n    heightMap = [[1, 2], [3, 4]]\n    assert solution.trapRainWater(heightMap) == 0", "def test_trapRainWater():\n    solution = Solution()\n    heightMap = [[1, 1, 1, 1, 1], [1, 0, 0, 0, 1], [1, 0, 0, 0, 1], [1, 0, 0, 0, 1], [1, 1, 1, 1, 1]]\n    assert solution.trapRainWater(heightMap) == 9", "def test_trapRainWater():\n    solution = Solution()\n    heightMap = [[4, 5, 4], [3, 1, 3], [4, 2, 4]]\n    assert solution.trapRainWater(heightMap) == 4", "def test_trapRainWater():\n    solution = Solution()\n    heightMap = [[1, 3, 2, 4], [2, 1, 3, 1], [1, 2, 4, 3], [3, 3, 2, 1]]\n    assert solution.trapRainWater(heightMap) == 5", "def test_trapRainWater():\n    solution = Solution()\n    heightMap = [[5, 5, 5, 5, 5], [5, 1, 4, 1, 5], [5, 3, 0, 3, 5], [5, 2, 3, 2, 5], [5, 5, 5, 5, 5]]\n    assert solution.trapRainWater(heightMap) == 24", "def test_trapRainWater():\n    solution = Solution()\n    heightMap = [[5, 2, 3, 4, 5], [3, 1, 2, 1, 4], [4, 3, 1, 3, 3], [5, 4, 3, 2, 5], [4, 5, 4, 3, 4]]\n    assert solution.trapRainWater(heightMap) == 10", "def test_trapRainWater():\n    solution = Solution()\n    heightMap = [[9, 9, 9, 9, 9], [9, 0, 0, 0, 9], [9, 0, 9, 0, 9], [9, 0, 0, 0, 9], [9, 9, 9, 9, 9]]\n    assert solution.trapRainWater(heightMap) == 36", "def test_trapRainWater():\n    solution = Solution()\n    heightMap = [[4, 5, 6, 5, 4], [5, 1, 2, 1, 5], [6, 2, 0, 2, 6], [5, 1, 2, 1, 5], [4, 5, 6, 5, 4]]\n    assert solution.trapRainWater(heightMap) == 20", "def test_trapRainWater():\n    solution = Solution()\n    heightMap = [[7, 0, 0, 0, 7], [0, 0, 6, 0, 0], [0, 5, 0, 5, 0], [0, 0, 6, 0, 0], [7, 0, 0, 0, 7]]\n    assert solution.trapRainWater(heightMap) == 20", "def test_trapRainWater():\n    solution = Solution()\n    heightMap = [[4, 3, 4], [3, 2, 3], [4, 3, 4]]\n    assert solution.trapRainWater(heightMap) == 4", "def test_trapRainWater():\n    solution = Solution()\n    heightMap = [[6, 6, 6, 6, 6], [6, 1, 4, 1, 6], [6, 2, 0, 2, 6], [6, 1, 4, 1, 6], [6, 6, 6, 6, 6]]\n    assert solution.trapRainWater(heightMap) == 30", "def test_trapRainWater():\n    solution = Solution()\n    heightMap = [[5, 3, 5, 3, 5], [5, 1, 2, 1, 5], [5, 2, 0, 2, 5], [5, 1, 2, 1, 5], [5, 3, 5, 3, 5]]\n    assert solution.trapRainWater(heightMap) == 16", "def test_trapRainWater():\n    solution = Solution()\n    heightMap = [[8, 8, 8, 8], [8, 1, 1, 8], [8, 1, 1, 8], [8, 8, 8, 8]]\n    assert solution.trapRainWater(heightMap) == 12", "def test_trapRainWater():\n    solution = Solution()\n    heightMap = [[3, 3, 4, 3], [3, 1, 2, 3], [3, 2, 1, 3], [3, 3, 3, 3]]\n    assert solution.trapRainWater(heightMap) == 4"]}
{"task_num": 417, "task_title": "Pacific Atlantic Water Flow", "func_name": "pacificAtlantic", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(heights)\n    n = len(heights[0])\n    qP = collections.deque()\n    qA = collections.deque()\n    seenP = [[False] * n for _ in range(m)]\n    seenA = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n      qP.append((i, 0))\n      qA.append((i, n - 1))\n      seenP[i][0] = True\n      seenA[i][n - 1] = True\n\n    for j in range(n):\n      qP.append((0, j))\n      qA.append((m - 1, j))\n      seenP[0][j] = True\n      seenA[m - 1][j] = True\n\n    def bfs(q: collections.deque, seen: List[List[bool]]):\n      while q:\n        i, j = q.popleft()\n        h = heights[i][j]\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if seen[x][y] or heights[x][y] < h:\n            continue\n          q.append((x, y))\n          seen[x][y] = True\n\n    bfs(qP, seenP)\n    bfs(qA, seenA)\n\n    res=[]\n    for i in range(m):\n      for j in range(n):\n        if seenP[i][j] and seenA[i][j]:\n          res.append([i, j])\n    return res\n", "tests": ["def test_pacificAtlantic():\n    solution = Solution()\n    heights = [[1, 2, 2, 3, 5], [3, 2, 3, 4, 4], [2, 4, 5, 3, 1], [6, 7, 1, 4, 5], [5, 1, 1, 2, 4]]\n    expected_output = [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]]\n    assert sorted(solution.pacificAtlantic(heights)) == sorted(expected_output)", "def test_pacificAtlantic():\n    solution = Solution()\n    heights = [[10, 10, 1, 10], [10, 1, 1, 10], [10, 1, 1, 10], [10, 10, 10, 10]]\n    expected_output = [[0, 0], [0, 1], [0, 3], [1, 0], [1, 3], [2, 0], [2, 3], [3, 0], [3, 1], [3, 2], [3, 3]]\n    assert sorted(solution.pacificAtlantic(heights)) == sorted(expected_output)", "def test_pacificAtlantic():\n    solution = Solution()\n    heights = [[5, 4, 3], [6, 7, 2], [3, 2, 1]]\n    expected_output = [[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [2, 0]]\n    assert sorted(solution.pacificAtlantic(heights)) == sorted(expected_output)", "def test_pacificAtlantic():\n    solution = Solution()\n    heights = [[2, 1], [1, 2]]\n    expected_output = [[0, 0], [0, 1], [1, 0], [1, 1]]\n    assert sorted(solution.pacificAtlantic(heights)) == sorted(expected_output)", "def test_pacificAtlantic():\n    solution = Solution()\n    heights = [[1, 2, 3], [8, 9, 4], [7, 6, 5]]\n    expected_output = [[0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]]\n    assert sorted(solution.pacificAtlantic(heights)) == sorted(expected_output)", "def test_pacificAtlantic():\n    solution = Solution()\n    heights = [[3, 3, 3, 3], [3, 1, 1, 3], [3, 1, 1, 3], [3, 3, 3, 3]]\n    expected_output = [[0, 0], [0, 1], [0, 2], [0, 3], [1, 0], [1, 3], [2, 0], [2, 3], [3, 0], [3, 1], [3, 2], [3, 3]]\n    assert sorted(solution.pacificAtlantic(heights)) == sorted(expected_output)", "def test_pacificAtlantic():\n    solution = Solution()\n    heights = [[1, 2, 3, 4, 5], [5, 4, 3, 2, 1], [6, 7, 8, 9, 10], [10, 9, 8, 7, 6], [1, 2, 3, 4, 5]]\n    expected_output = [[0, 4], [1, 0], [2, 0], [2, 1], [2, 2], [2, 3], [2, 4], [3, 0], [4, 0], [4, 1], [4, 2], [4, 3], [4, 4]]\n    assert sorted(solution.pacificAtlantic(heights)) == sorted(expected_output)", "def test_pacificAtlantic():\n    solution = Solution()\n    heights = [[1, 1, 1], [1, 5, 1], [1, 1, 1]]\n    expected_output = [[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]]\n    assert sorted(solution.pacificAtlantic(heights)) == sorted(expected_output)", "def test_pacificAtlantic():\n    solution = Solution()\n    heights = [[10, 9, 8, 7], [11, 6, 5, 4], [12, 13, 14, 3], [1, 2, 3, 2]]\n    expected_output = [[0, 0], [0, 1], [0, 2], [0, 3], [1, 0], [2, 0], [2, 1], [2, 2], [3, 0], [3, 1], [3, 2], [3, 3]]\n    assert sorted(solution.pacificAtlantic(heights)) == sorted(expected_output)", "def test_pacificAtlantic():\n    solution = Solution()\n    heights = [[5, 4, 3, 2, 1], [6, 5, 4, 3, 2], [7, 6, 5, 4, 3], [8, 7, 6, 5, 4], [9, 8, 7, 6, 5]]\n    expected_output = [[0, 4], [1, 3], [2, 2], [3, 1], [4, 0], [0, 0], [1, 0], [2, 0], [3, 0], [4, 1], [4, 2], [4, 3], [4, 4], [3, 4], [2, 4], [1, 4], [0, 3], [0, 2], [0, 1]]\n    assert sorted(solution.pacificAtlantic(heights)) == sorted(expected_output)", "def test_pacificAtlantic():\n    solution = Solution()\n    heights = [[1, 2, 3, 4], [4, 3, 2, 1], [1, 2, 3, 4], [4, 3, 2, 1]]\n    expected_output = [[0, 0], [0, 1], [0, 2], [0, 3], [1, 0], [1, 3], [2, 0], [2, 1], [2, 2], [2, 3], [3, 0], [3, 3]]\n    assert sorted(solution.pacificAtlantic(heights)) == sorted(expected_output)", "def test_pacificAtlantic():\n    solution = Solution()\n    heights = [[8, 7, 6, 5, 4], [7, 6, 5, 4, 3], [6, 5, 4, 3, 2], [5, 4, 3, 2, 1], [4, 3, 2, 1, 0]]\n    expected_output = [[0, 0], [0, 1], [0, 2], [0, 3], [0, 4], [1, 0], [2, 0], [3, 0], [4, 0], [4, 1], [4, 2], [4, 3], [4, 4]]\n    assert sorted(solution.pacificAtlantic(heights)) == sorted(expected_output)", "def test_pacificAtlantic():\n    solution = Solution()\n    heights = [[3, 4, 5], [6, 7, 8], [9, 8, 7], [6, 5, 4]]\n    expected_output = [[0, 2], [1, 2], [2, 0], [2, 1], [2, 2], [3, 0], [3, 1], [3, 2]]\n    assert sorted(solution.pacificAtlantic(heights)) == sorted(expected_output)", "def test_pacificAtlantic():\n    solution = Solution()\n    heights = [[1, 3, 5], [2, 4, 6], [3, 5, 7], [4, 6, 8]]\n    expected_output = [[0, 2], [1, 2], [2, 2], [3, 0], [3, 1], [3, 2], [0, 0], [0, 1], [1, 0], [2, 0]]\n    assert sorted(solution.pacificAtlantic(heights)) == sorted(expected_output)", "def test_pacificAtlantic():\n    solution = Solution()\n    heights = [[10, 20, 30], [20, 10, 20], [30, 20, 10]]\n    expected_output = [[0, 0], [0, 1], [0, 2], [1, 0], [1, 2], [2, 0], [2, 1], [2, 2]]\n    assert sorted(solution.pacificAtlantic(heights)) == sorted(expected_output)", "def test_pacificAtlantic():\n    solution = Solution()\n    heights = [[1, 2, 2, 3], [3, 2, 3, 4], [2, 4, 5, 6], [6, 7, 6, 5]]\n    expected_output = [[0, 3], [1, 3], [2, 0], [2, 1], [2, 2], [2, 3], [3, 0], [3, 1], [3, 2], [3, 3]]\n    assert sorted(solution.pacificAtlantic(heights)) == sorted(expected_output)", "def test_pacificAtlantic():\n    solution = Solution()\n    heights = [[5, 4, 3, 2], [6, 5, 6, 3], [7, 6, 7, 4], [8, 7, 8, 5]]\n    expected_output = [[0, 0], [1, 0], [2, 0], [3, 0], [3, 1], [3, 2], [3, 3], [2, 3], [1, 3], [0, 3]]\n    assert sorted(solution.pacificAtlantic(heights)) == sorted(expected_output)", "def test_pacificAtlantic():\n    solution = Solution()\n    heights = [[3, 2, 1], [2, 1, 2], [1, 2, 3]]\n    expected_output = [[0, 0], [0, 1], [0, 2], [1, 0], [1, 2], [2, 0], [2, 1], [2, 2]]\n    assert sorted(solution.pacificAtlantic(heights)) == sorted(expected_output)", "def test_pacificAtlantic():\n    solution = Solution()\n    heights = [[1, 2, 1, 2], [2, 1, 2, 1], [1, 2, 1, 2], [2, 1, 2, 1]]\n    expected_output = [[0, 0], [0, 1], [0, 2], [0, 3], [1, 0], [1, 3], [2, 0], [2, 3], [3, 0], [3, 1], [3, 2], [3, 3]]\n    assert sorted(solution.pacificAtlantic(heights)) == sorted(expected_output)", "def test_pacificAtlantic():\n    solution = Solution()\n    heights = [[5, 10, 5], [10, 1, 10], [5, 10, 5]]\n    expected_output = [[0, 0], [0, 1], [0, 2], [1, 0], [1, 2], [2, 0], [2, 1], [2, 2]]\n    assert sorted(solution.pacificAtlantic(heights)) == sorted(expected_output)"]}
{"task_num": 420, "task_title": "Strong Password Checker", "func_name": "strongPasswordChecker", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def strongPasswordChecker(self, password: str) -> int:\n    n = len(password)\n    missing = self._getMissing(password)\n    replaces = 0\n    oneSeq = 0\n    twoSeq = 0\n\n    i = 2\n    while i < n:\n      if password[i] == password[i - 1] and password[i - 1] == password[i - 2]:\n        length = 2\n        while i < n and password[i] == password[i - 1]:\n          length += 1\n          i += 1\n        replaces += length // 3\n        if length % 3 == 0:\n          oneSeq += 1\n        if length % 3 == 1:\n          twoSeq += 1\n      else:\n        i += 1\n\n    if n < 6:\n      return max(6 - n, missing)\n    if n <= 20:\n      return max(replaces, missing)\n\n    deletes = n - 20\n    replaces -= min(oneSeq, deletes)\n    replaces -= min(max(deletes - oneSeq, 0), twoSeq * 2) // 2\n    replaces -= max(deletes - oneSeq - twoSeq * 2, 0) // 3\n    return deletes + max(replaces, missing)\n\n  def _getMissing(self, password: str) -> int:\n    return 3 - any(c.isupper() for c in password) - any(c.islower() for c in password) - any(c.isdigit() for c in password)\n", "tests": ["def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('aaa') == 3", "def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('Aa1aa1aa1aa1aa1aa1aa') == 2", "def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('123456') == 2", "def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('aA1') == 3", "def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('Aaaa123') == 1", "def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('aaaBBB111') == 2", "def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('abcdefgh') == 2", "def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('Aaaaaa') == 1", "def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('1234567890123456789012345') == 7", "def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('aaaB1') == 2", "def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('123') == 3", "def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('Password123') == 0", "def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('AaAaAaAaAaAaAaAaAaAaAa123') == 8", "def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('a1A!a1A!a1A!') == 0", "def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('A1!' * 7) == 1", "def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('AAAaaa111') == 2", "def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('Aa1' + 'a' * 18) == 3", "def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('BBBBB') == 2", "def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('aaaaaaaaaaaaaa') == 5", "def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('Aa1!') == 2"]}
{"task_num": 423, "task_title": "Reconstruct Original Digits from English", "func_name": "originalDigits", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def originalDigits(self, s: str) -> str:\n    count = [0] * 10\n\n    for c in s:\n      if c == 'z':\n        count[0] += 1\n      if c == 'o':\n        count[1] += 1\n      if c == 'w':\n        count[2] += 1\n      if c == 'h':\n        count[3] += 1\n      if c == 'u':\n        count[4] += 1\n      if c == 'f':\n        count[5] += 1\n      if c == 'x':\n        count[6] += 1\n      if c == 's':\n        count[7] += 1\n      if c == 'g':\n        count[8] += 1\n      if c == 'i':\n        count[9] += 1\n\n    count[1] -= count[0] + count[2] + count[4]\n    count[3] -= count[8]\n    count[5] -= count[4]\n    count[7] -= count[6]\n    count[9] -= count[5] + count[6] + count[8]\n\n    return ''.join(chr(i + ord('0')) for i, c in enumerate(count) for j in range(c))\n", "tests": ["def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits('owoztneoer') == '012'", "def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits('fviefuro') == '45'", "def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits('nnei') == '9'", "def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits('niesevehrt') == '37'", "def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits('zeroonetwothreefourfivesixseveneightnine') == '0123456789'", "def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits('xsi') == '6'", "def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits('gght') == '8'", "def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits('sseeevn') == '7'", "def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits('twotwo') == '22'", "def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits('eroz') == '0'", "def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits('fivex') == '56'", "def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits('reneon') == '11'", "def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits('fourfour') == '44'", "def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits('xhree') == '3'", "def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits('ninesix') == '69'", "def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits('wo') == '2'", "def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits('urfoo') == '4'", "def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits('xersi') == '6'", "def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits('githtwo') == '28'", "def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits('ghreehight') == '38'"]}
{"task_num": 457, "task_title": "Circular Array Loop", "func_name": "circularArrayLoop", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def circularArrayLoop(self, nums: List[int]) -> bool:\n    def advance(i: int) -> int:\n      return (i + nums[i]) % len(nums)\n\n    if len(nums) < 2:\n      return False\n\n    for i, num in enumerate(nums):\n      if num == 0:\n        continue\n\n      slow = i\n      fast = advance(slow)\n      while num * nums[fast] > 0 and num * nums[advance(fast)] > 0:\n        if slow == fast:\n          if slow == advance(slow):\n            break\n          return True\n        slow = advance(slow)\n        fast = advance(advance(fast))\n\n      slow = i\n      sign = num\n      while sign * nums[slow] > 0:\n        next = advance(slow)\n        nums[slow] = 0\n        slow = next\n\n    return False\n", "tests": ["def test_circularArrayLoop():\n    solution = Solution()\n    assert solution.circularArrayLoop([2, -1, 1, 2, 2]) == True", "def test_circularArrayLoop():\n    solution = Solution()\n    assert solution.circularArrayLoop([-1, 2]) == False", "def test_circularArrayLoop():\n    solution = Solution()\n    assert solution.circularArrayLoop([1]) == False", "def test_circularArrayLoop():\n    solution = Solution()\n    assert solution.circularArrayLoop([1, -1, 1, -1, 1, -1, 1]) == False", "def test_circularArrayLoop():\n    solution = Solution()\n    assert solution.circularArrayLoop([10, -5, 1, 2, 3, 4, 5, -1]) == True", "def test_circularArrayLoop():\n    solution = Solution()\n    assert solution.circularArrayLoop([1, 2, 3, 0, -2]) == False", "def test_circularArrayLoop():\n    solution = Solution()\n    assert solution.circularArrayLoop([1, 1]) == True", "def test_circularArrayLoop():\n    solution = Solution()\n    assert solution.circularArrayLoop([-2, -3, -1, -4, -5]) == False", "def test_circularArrayLoop():\n    solution = Solution()\n    assert solution.circularArrayLoop([3, 1, -4, 2, -2]) == False", "def test_circularArrayLoop():\n    solution = Solution()\n    assert solution.circularArrayLoop([-10]) == False", "def test_circularArrayLoop():\n    solution = Solution()\n    assert solution.circularArrayLoop([2, -2, 3, 3, -3, 0, -1]) == False", "def test_circularArrayLoop():\n    solution = Solution()\n    assert solution.circularArrayLoop([1000, 2000, 3000, -4000]) == False", "def test_circularArrayLoop():\n    solution = Solution()\n    assert solution.circularArrayLoop([1, 2, -1, 1, 2, -1]) == True", "def test_circularArrayLoop():\n    solution = Solution()\n    assert solution.circularArrayLoop([-1, 2, 2, 2]) == False", "def test_circularArrayLoop():\n    solution = Solution()\n    assert solution.circularArrayLoop([3, -1, 4, 1, 2]) == False", "def test_circularArrayLoop():\n    solution = Solution()\n    assert solution.circularArrayLoop([1, 1, 1, 1, 1]) == True", "def test_circularArrayLoop():\n    solution = Solution()\n    assert solution.circularArrayLoop([2, -1, 1, 2, 2, -1]) == True", "def test_circularArrayLoop():\n    solution = Solution()\n    assert solution.circularArrayLoop([0, 0, 0, 0]) == False", "def test_circularArrayLoop():\n    solution = Solution()\n    assert solution.circularArrayLoop([10, 1, -1, 2, -10, 1]) == False", "def test_circularArrayLoop():\n    solution = Solution()\n    assert solution.circularArrayLoop([2, -1, 2, -2, 2, -3]) == False"]}
{"task_num": 524, "task_title": "Longest Word in Dictionary through Deleting", "func_name": "findLongestWord", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findLongestWord(self, s: str, d: List[str]) -> str:\n    ans = ''\n\n    for word in d:\n      i = 0\n      for c in s:\n        if i < len(word) and c == word[i]:\n          i += 1\n      if i == len(word):\n        if len(word) > len(ans) or len(word) == len(ans) and word < ans:\n          ans = word\n\n    return ans\n", "tests": ["def test_findLongestWord():\n    solution = Solution()\n    s = 'abpcplea'\n    d = ['ale', 'apple', 'monkey', 'plea']\n    assert solution.findLongestWord(s, d) == 'apple'", "def test_findLongestWord():\n    solution = Solution()\n    s = 'abpcplea'\n    d = ['a', 'b', 'c']\n    assert solution.findLongestWord(s, d) == 'a'", "def test_findLongestWord():\n    solution = Solution()\n    s = 'abc'\n    d = ['d', 'e', 'f']\n    assert solution.findLongestWord(s, d) == ''", "def test_findLongestWord():\n    solution = Solution()\n    s = 'abppplee'\n    d = ['able', 'ale', 'apple', 'bale', 'kangaroo']\n    assert solution.findLongestWord(s, d) == 'apple'", "def test_findLongestWord():\n    solution = Solution()\n    s = 'abpcplea'\n    d = ['ale', 'aplea', 'aplea']\n    assert solution.findLongestWord(s, d) == 'aplea'", "def test_findLongestWord():\n    solution = Solution()\n    s = ''\n    d = ['a', 'b', 'c']\n    assert solution.findLongestWord(s, d) == ''", "def test_findLongestWord():\n    solution = Solution()\n    s = 'abcd'\n    d = ['ab', 'abcd', 'abc', 'abd']\n    assert solution.findLongestWord(s, d) == 'abcd'", "def test_findLongestWord():\n    solution = Solution()\n    s = 'xyz'\n    d = ['x', 'y', 'z', 'xy', 'yz', 'xz']\n    assert solution.findLongestWord(s, d) == 'xy'", "def test_findLongestWord():\n    solution = Solution()\n    s = 'abpcplea'\n    d = ['apc', 'apl', 'apce', 'aple']\n    assert solution.findLongestWord(s, d) == 'apce'", "def test_findLongestWord():\n    solution = Solution()\n    s = 'aabbcc'\n    d = ['abc', 'ab', 'bc', 'ac']\n    assert solution.findLongestWord(s, d) == 'abc'", "def test_findLongestWord():\n    solution = Solution()\n    s = 'abcde'\n    d = ['abc', 'ac', 'abcd', 'abcde']\n    assert solution.findLongestWord(s, d) == 'abcde'", "def test_findLongestWord():\n    solution = Solution()\n    s = 'abpcplea'\n    d = ['pp', 'ple', 'ppl', 'plea']\n    assert solution.findLongestWord(s, d) == 'plea'", "def test_findLongestWord():\n    solution = Solution()\n    s = 'abcdefg'\n    d = ['abcd', 'efg', 'abcdg', 'abcfg']\n    assert solution.findLongestWord(s, d) == 'abcd'", "def test_findLongestWord():\n    solution = Solution()\n    s = 'aabbccddeeff'\n    d = ['abc', 'aab', 'abbc', 'aabbcc']\n    assert solution.findLongestWord(s, d) == 'aabbcc'", "def test_findLongestWord():\n    solution = Solution()\n    s = 'abpcplea'\n    d = ['pl', 'ple', 'plea', 'plp']\n    assert solution.findLongestWord(s, d) == 'plea'", "def test_findLongestWord():\n    solution = Solution()\n    s = 'abcdefg'\n    d = ['cfg', 'bdf', 'acef', 'bcde']\n    assert solution.findLongestWord(s, d) == 'acef'", "def test_findLongestWord():\n    solution = Solution()\n    s = 'aabbcc'\n    d = ['bb', 'cc', 'aa', 'aac']\n    assert solution.findLongestWord(s, d) == 'aac'", "def test_findLongestWord():\n    solution = Solution()\n    s = 'zxcvbnmasdfghjkl'\n    d = ['zxc', 'cvb', 'bnm', 'asdfgh']\n    assert solution.findLongestWord(s, d) == 'asdfgh'", "def test_findLongestWord():\n    solution = Solution()\n    s = 'abcpqrcba'\n    d = ['abc', 'pr', 'arc', 'pq']\n    assert solution.findLongestWord(s, d) == 'abc'", "def test_findLongestWord():\n    solution = Solution()\n    s = 'abcdefghij'\n    d = ['hij', 'efg', 'abcd', 'efghij']\n    assert solution.findLongestWord(s, d) == 'efghij'"]}
{"task_num": 542, "task_title": "01 Matrix", "func_name": "updateMatrix", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(mat)\n    n = len(mat[0])\n    q = collections.deque()\n    seen = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j] == 0:\n          q.append((i, j))\n          seen[i][j] = True\n\n    while q:\n      i, j = q.popleft()\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if seen[x][y]:\n          continue\n        mat[x][y] = mat[i][j] + 1\n        q.append((x, y))\n        seen[x][y] = True\n\n    return mat\n", "tests": ["def test_updateMatrix():\n    solution = Solution()\n    mat = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n    expected_output = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n    assert solution.updateMatrix(mat) == expected_output", "def test_updateMatrix():\n    solution = Solution()\n    mat = [[0, 1, 1], [1, 1, 1], [1, 1, 0]]\n    expected_output = [[0, 1, 2], [1, 2, 1], [2, 1, 0]]\n    assert solution.updateMatrix(mat) == expected_output", "def test_updateMatrix():\n    solution = Solution()\n    mat = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]\n    expected_output = [[2, 1, 2], [1, 0, 1], [2, 1, 2]]\n    assert solution.updateMatrix(mat) == expected_output", "def test_updateMatrix():\n    solution = Solution()\n    mat = [[1, 1, 1], [1, 1, 1], [0, 1, 0]]\n    expected_output = [[2, 2, 1], [1, 1, 1], [0, 1, 0]]\n    assert solution.updateMatrix(mat) == expected_output", "def test_updateMatrix():\n    solution = Solution()\n    mat = [[0, 1, 0], [1, 1, 1], [1, 1, 1]]\n    expected_output = [[0, 1, 0], [1, 2, 1], [2, 3, 2]]\n    assert solution.updateMatrix(mat) == expected_output", "def test_updateMatrix():\n    solution = Solution()\n    mat = [[0, 1, 1, 1], [1, 1, 1, 0], [1, 0, 1, 1], [1, 1, 1, 1]]\n    expected_output = [[0, 1, 2, 1], [1, 2, 1, 0], [2, 1, 2, 1], [3, 2, 3, 2]]\n    assert solution.updateMatrix(mat) == expected_output", "def test_updateMatrix():\n    solution = Solution()\n    mat = [[1, 1, 1, 0], [1, 1, 1, 1], [0, 1, 1, 1], [1, 1, 0, 1]]\n    expected_output = [[3, 2, 1, 0], [2, 2, 1, 1], [0, 1, 2, 2], [1, 1, 0, 1]]\n    assert solution.updateMatrix(mat) == expected_output", "def test_updateMatrix():\n    solution = Solution()\n    mat = [[1, 0, 1, 1], [1, 1, 1, 1], [1, 1, 0, 1], [1, 1, 1, 1]]\n    expected_output = [[1, 0, 1, 2], [2, 1, 1, 1], [1, 1, 0, 1], [2, 2, 1, 2]]\n    assert solution.updateMatrix(mat) == expected_output", "def test_updateMatrix():\n    solution = Solution()\n    mat = [[0, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 0], [1, 0, 1, 1]]\n    expected_output = [[0, 1, 2, 3], [1, 2, 2, 1], [2, 1, 1, 0], [1, 0, 1, 1]]\n    assert solution.updateMatrix(mat) == expected_output", "def test_updateMatrix():\n    solution = Solution()\n    mat = [[1, 1, 0, 1, 1], [1, 0, 1, 1, 1], [1, 1, 1, 0, 1], [0, 1, 1, 1, 1], [1, 1, 1, 1, 0]]\n    expected_output = [[2, 1, 0, 1, 2], [1, 0, 1, 1, 1], [1, 1, 1, 0, 1], [0, 1, 2, 1, 1], [1, 2, 2, 1, 0]]\n    assert solution.updateMatrix(mat) == expected_output", "def test_updateMatrix():\n    solution = Solution()\n    mat = [[1, 1, 1, 1], [1, 0, 0, 1], [1, 1, 1, 1], [1, 1, 1, 0]]\n    expected_output = [[2, 1, 1, 2], [1, 0, 0, 1], [2, 1, 1, 1], [3, 2, 1, 0]]\n    assert solution.updateMatrix(mat) == expected_output", "def test_updateMatrix():\n    solution = Solution()\n    mat = [[1, 1, 1], [0, 1, 1], [1, 1, 0], [1, 0, 1]]\n    expected_output = [[1, 2, 2], [0, 1, 2], [1, 1, 0], [1, 0, 1]]\n    assert solution.updateMatrix(mat) == expected_output", "def test_updateMatrix():\n    solution = Solution()\n    mat = [[1, 1, 1], [1, 1, 1], [0, 1, 0]]\n    expected_output = [[2, 2, 1], [1, 2, 1], [0, 1, 0]]\n    assert solution.updateMatrix(mat) == expected_output", "def test_updateMatrix():\n    solution = Solution()\n    mat = [[0, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 0]]\n    expected_output = [[0, 1, 2, 3, 2], [1, 2, 3, 2, 1], [2, 3, 2, 1, 0]]\n    assert solution.updateMatrix(mat) == expected_output", "def test_updateMatrix():\n    solution = Solution()\n    mat = [[1, 1, 1], [1, 0, 1], [1, 1, 1], [0, 1, 1]]\n    expected_output = [[2, 1, 2], [1, 0, 1], [1, 1, 2], [0, 1, 2]]\n    assert solution.updateMatrix(mat) == expected_output", "def test_updateMatrix():\n    solution = Solution()\n    mat = [[1, 0, 1, 1], [1, 1, 1, 0], [1, 1, 1, 1], [0, 1, 1, 1]]\n    expected_output = [[1, 0, 1, 1], [2, 1, 1, 0], [2, 2, 2, 1], [0, 1, 2, 2]]\n    assert solution.updateMatrix(mat) == expected_output", "def test_updateMatrix():\n    solution = Solution()\n    mat = [[1, 1, 1, 1], [1, 1, 0, 1], [1, 1, 1, 1], [1, 0, 1, 1]]\n    expected_output = [[3, 2, 1, 2], [2, 1, 0, 1], [3, 2, 1, 2], [1, 0, 1, 2]]\n    assert solution.updateMatrix(mat) == expected_output", "def test_updateMatrix():\n    solution = Solution()\n    mat = [[1, 0, 1], [1, 1, 1], [0, 1, 1], [1, 1, 1]]\n    expected_output = [[1, 0, 1], [1, 1, 2], [0, 1, 2], [1, 2, 3]]\n    assert solution.updateMatrix(mat) == expected_output", "def test_updateMatrix():\n    solution = Solution()\n    mat = [[1, 1, 1, 1], [0, 1, 1, 1], [1, 1, 1, 0], [1, 1, 1, 1]]\n    expected_output = [[1, 2, 2, 1], [0, 1, 2, 1], [1, 2, 1, 0], [2, 3, 2, 1]]\n    assert solution.updateMatrix(mat) == expected_output", "def test_updateMatrix():\n    solution = Solution()\n    mat = [[1, 1, 1, 1, 1], [1, 1, 1, 1, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [0, 1, 1, 1, 1]]\n    expected_output = [[4, 3, 2, 1, 0], [3, 2, 1, 1, 0], [2, 1, 2, 1, 1], [1, 1, 2, 2, 2], [0, 1, 2, 3, 3]]\n    assert solution.updateMatrix(mat) == expected_output"]}
{"task_num": 547, "task_title": "Number of Provinces", "func_name": "findCircleNum", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    self.count -= 1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findCircleNum(self, isConnected: List[List[int]]) -> int:\n    n = len(isConnected)\n    uf = UnionFind(n)\n\n    for i in range(n):\n      for j in range(i, n):\n        if isConnected[i][j] == 1:\n          uf.unionByRank(i, j)\n\n    return uf.count\n", "tests": ["def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]\n    assert solution.findCircleNum(isConnected) == 2", "def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[1]]\n    assert solution.findCircleNum(isConnected) == 1", "def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\n    assert solution.findCircleNum(isConnected) == 1", "def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    assert solution.findCircleNum(isConnected) == 3", "def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[1, 1, 0, 0, 1], [1, 1, 0, 0, 0], [0, 0, 1, 1, 0], [0, 0, 1, 1, 0], [1, 0, 0, 0, 1]]\n    assert solution.findCircleNum(isConnected) == 2", "def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[1, 0, 0, 1], [0, 1, 1, 0], [0, 1, 1, 0], [1, 0, 0, 1]]\n    assert solution.findCircleNum(isConnected) == 2", "def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[1, 1, 0, 0], [1, 1, 1, 0], [0, 1, 1, 1], [0, 0, 1, 1]]\n    assert solution.findCircleNum(isConnected) == 1", "def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[1, 0, 0, 0], [0, 1, 1, 1], [0, 1, 1, 0], [0, 1, 0, 1]]\n    assert solution.findCircleNum(isConnected) == 2", "def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 1, 1, 1], [0, 0, 1, 1, 1], [0, 0, 1, 1, 1]]\n    assert solution.findCircleNum(isConnected) == 2", "def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[1, 0, 0, 0, 0], [0, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 0], [0, 0, 0, 0, 1]]\n    assert solution.findCircleNum(isConnected) == 5", "def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[1, 1, 0, 1], [1, 1, 1, 0], [0, 1, 1, 1], [1, 0, 1, 1]]\n    assert solution.findCircleNum(isConnected) == 1", "def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[1, 0, 1, 0, 0], [0, 1, 0, 0, 0], [1, 0, 1, 1, 0], [0, 0, 1, 1, 1], [0, 0, 0, 1, 1]]\n    assert solution.findCircleNum(isConnected) == 2", "def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[1, 1, 0, 0, 0, 1], [1, 1, 0, 1, 0, 0], [0, 0, 1, 1, 1, 0], [0, 1, 1, 1, 0, 0], [0, 0, 1, 0, 1, 1], [1, 0, 0, 0, 1, 1]]\n    assert solution.findCircleNum(isConnected) == 2", "def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[1, 1, 0, 0, 1], [1, 1, 1, 0, 0], [0, 1, 1, 1, 0], [0, 0, 1, 1, 1], [1, 0, 0, 1, 1]]\n    assert solution.findCircleNum(isConnected) == 1", "def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[1, 1, 0, 0, 0, 0], [1, 1, 0, 0, 0, 1], [0, 0, 1, 0, 1, 0], [0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 1, 1], [0, 1, 0, 0, 1, 1]]\n    assert solution.findCircleNum(isConnected) == 3", "def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[1, 0, 0, 1, 0], [0, 1, 0, 0, 0], [0, 0, 1, 0, 0], [1, 0, 0, 1, 1], [0, 0, 0, 1, 1]]\n    assert solution.findCircleNum(isConnected) == 3", "def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[1, 1, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0], [0, 0, 1, 1, 0, 0, 1], [0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 1, 0, 0, 1]]\n    assert solution.findCircleNum(isConnected) == 3", "def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[1, 1, 0, 1, 0], [1, 1, 0, 1, 0], [0, 0, 1, 1, 1], [1, 1, 1, 1, 0], [0, 0, 1, 0, 1]]\n    assert solution.findCircleNum(isConnected) == 1", "def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 0, 1, 1]]\n    assert solution.findCircleNum(isConnected) == 4", "def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[1, 0, 0, 1, 0, 0], [0, 1, 0, 0, 0, 1], [0, 0, 1, 0, 1, 0], [1, 0, 0, 1, 0, 0], [0, 0, 1, 0, 1, 0], [0, 1, 0, 0, 0, 1]]\n    assert solution.findCircleNum(isConnected) == 3"]}
{"task_num": 581, "task_title": "Shortest Unsorted Continuous Subarray", "func_name": "findUnsortedSubarray", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findUnsortedSubarray(self, nums: List[int]) -> int:\n    mini = math.inf\n    maxi = -math.inf\n    flag = False\n\n    for i in range(1, len(nums)):\n      if nums[i] < nums[i - 1]:\n        flag = True\n      if flag:\n        mini = min(mini, nums[i])\n\n    flag = False\n\n    for i in reversed(range(len(nums) - 1)):\n      if nums[i] > nums[i + 1]:\n        flag = True\n      if flag:\n        maxi = max(maxi, nums[i])\n\n    for l in range(len(nums)):\n      if nums[l] > mini:\n        break\n\n    for r, num in reversed(list(enumerate(nums))):\n      if num < maxi:\n        break\n\n    return 0 if l >= r else r - l + 1\n", "tests": ["def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([2, 6, 4, 8, 10, 9, 15]) == 5", "def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([1, 3, 2, 2, 2]) == 4", "def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([1, 2, 3, 4]) == 0", "def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([2, 1]) == 2", "def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([1, 5, 3, 4, 2, 6]) == 5", "def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([1, 3, 5, 4, 2, 6, 7]) == 4", "def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([1, 2, 3, 3, 3, 3]) == 0", "def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([10, 9, 8, 7, 6]) == 5", "def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([1, 2, 6, 5, 4, 3, 7, 8]) == 5", "def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([4, 3, 2, 1, 5, 6, 7, 8]) == 4", "def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([1, 2, 4, 3, 5, 7, 6, 8, 9]) == 4", "def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([1, 10, 9, 8, 7, 6, 5, 11]) == 6", "def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([5, 4, 3, 2, 1]) == 5", "def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([1, 3, 5, 4, 6, 7, 8]) == 2", "def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([1, 2, 4, 3, 3, 3, 3, 5, 6]) == 3", "def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([6, 5, 3, 4, 8, 10, 11]) == 4", "def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([1, 5, 4, 3, 2, 6, 7, 8]) == 4", "def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([3, 2, 1, 4, 5, 6, 7]) == 3", "def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([1, 2, 5, 6, 7, 4, 3, 8, 9]) == 5", "def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([10, 12, 11, 14, 15, 16, 13, 18]) == 6"]}
{"task_num": 591, "task_title": "Tag Validator", "func_name": "isValid", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isValid(self, code: str) -> bool:\n    if code[0] != '<' or code[-1] != '>':\n      return False\n\n    containsTag = False\n    stack = []\n\n    def isValidCdata(s: str) -> bool:\n      return s.find('[CDATA[') == 0\n\n    def isValidTagName(tagName: str, isEndTag: bool) -> bool:\n      nonlocal containsTag\n      if not tagName or len(tagName) > 9:\n        return False\n      if any(not c.isupper() for c in tagName):\n        return False\n\n      if isEndTag:\n        return stack and stack.pop() == tagName\n\n      containsTag = True\n      stack.append(tagName)\n      return True\n\n    i = 0\n    while i < len(code):\n      if not stack and containsTag:\n        return False\n      if code[i] == '<':\n        if stack and code[i + 1] == '!':\n          closeIndex = code.find(']]>', i + 2)\n          if closeIndex == -1 or not isValidCdata(code[i + 2:closeIndex]):\n            return False\n        elif code[i + 1] == '/':\n          closeIndex = code.find('>', i + 2)\n          if closeIndex == -1 or not isValidTagName(code[i + 2:closeIndex], True):\n            return False\n        else:\n          closeIndex = code.find('>', i + 1)\n          if closeIndex == -1 or not isValidTagName(code[i + 1:closeIndex], False):\n            return False\n        i = closeIndex\n      i += 1\n\n    return not stack and containsTag\n", "tests": ["def test_isValid():\n    solution = Solution()\n    assert solution.isValid('<A><B></B></A>') == True", "def test_isValid():\n    solution = Solution()\n    assert solution.isValid('<A><![CDATA[some random content]]></A>') == True", "def test_isValid():\n    solution = Solution()\n    assert solution.isValid('<A><B></A></B>') == False", "def test_isValid():\n    solution = Solution()\n    assert solution.isValid('<A>This is a <B>test</B> string</A>') == True", "def test_isValid():\n    solution = Solution()\n    assert solution.isValid('<A><B></B><C></C></A>') == True", "def test_isValid():\n    solution = Solution()\n    assert solution.isValid('<A><B></C></B></A>') == False", "def test_isValid():\n    solution = Solution()\n    assert solution.isValid('<A><!CDATA[some text]]></A>') == False", "def test_isValid():\n    solution = Solution()\n    assert solution.isValid('<A>Unmatched tag<B></A>') == False", "def test_isValid():\n    solution = Solution()\n    assert solution.isValid('<LONGTAGNAME></LONGTAGNAME>') == False", "def test_isValid():\n    solution = Solution()\n    assert solution.isValid('<A></A><B></B>') == False", "def test_isValid():\n    solution = Solution()\n    assert solution.isValid('<A><![CDATA[<B>not a tag</B>]]></A>') == True", "def test_isValid():\n    solution = Solution()\n    assert solution.isValid('<A><B><C></C></B></A>') == True", "def test_isValid():\n    solution = Solution()\n    assert solution.isValid('<<A>></A>') == False", "def test_isValid():\n    solution = Solution()\n    assert solution.isValid('<A><B></B><C><D></D></C></A>') == True", "def test_isValid():\n    solution = Solution()\n    assert solution.isValid('<A><B><![CDATA[content]]></B><C></C></A>') == True", "def test_isValid():\n    solution = Solution()\n    assert solution.isValid('<A></B>') == False", "def test_isValid():\n    solution = Solution()\n    assert solution.isValid('<A><![[CDATA]></A>') == False", "def test_isValid():\n    solution = Solution()\n    assert solution.isValid('<A><B><![CDATA[]]></B></A>') == True", "def test_isValid():\n    solution = Solution()\n    assert solution.isValid('<A><B></B><C></D></A>') == False", "def test_isValid():\n    solution = Solution()\n    assert solution.isValid('<A>text<B></B></A>') == True"]}
{"task_num": 648, "task_title": "Replace Words", "func_name": "replaceWords", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def __init__(self):\n    self.root = {}\n\n  def insert(self, word: str) -> None:\n    node = self.root\n    for c in word:\n      if c not in node:\n        node[c] = {}\n      node = node[c]\n    node['word'] = word\n\n  def search(self, word: str) -> str:\n    node = self.root\n    for c in word:\n      if 'word' in node:\n        return node['word']\n      if c not in node:\n        return word\n      node = node[c]\n    return word\n\n  def replaceWords(self, dictionary: List[str], sentence: str) -> str:\n    for word in dictionary:\n      self.insert(word)\n\n    words = sentence.split(' ')\n    return ' '.join([self.search(word) for word in words])\n", "tests": ["def test_replaceWords():\n    solution = Solution()\n    dictionary = ['cat', 'bat', 'rat']\n    sentence = 'the cattle was rattled by the battery'\n    expected = 'the cat was rat by the bat'\n    assert solution.replaceWords(dictionary, sentence) == expected", "def test_replaceWords():\n    solution = Solution()\n    dictionary = ['a', 'b', 'c']\n    sentence = 'the quick brown fox jumps over the lazy dog'\n    expected = 'the quick brown fox jumps over the lazy dog'\n    assert solution.replaceWords(dictionary, sentence) == expected", "def test_replaceWords():\n    solution = Solution()\n    dictionary = []\n    sentence = 'she sells sea shells by the sea shore'\n    expected = 'she sells sea shells by the sea shore'\n    assert solution.replaceWords(dictionary, sentence) == expected", "def test_replaceWords():\n    solution = Solution()\n    dictionary = ['blue', 'red']\n    sentence = 'the sky is blue and the sun is redder'\n    expected = 'the sky is blue and the sun is red'\n    assert solution.replaceWords(dictionary, sentence) == expected", "def test_replaceWords():\n    solution = Solution()\n    dictionary = ['look', 'bo', 'code', 'pro']\n    sentence = 'looked at the book and coded professionally'\n    expected = 'look at the bo and code pro'\n    assert solution.replaceWords(dictionary, sentence) == expected", "def test_replaceWords():\n    solution = Solution()\n    dictionary = ['inter', 'international', 'nation', 'national']\n    sentence = 'the international conference was held at the nation hall'\n    expected = 'the inter conference was held at the nation hall'\n    assert solution.replaceWords(dictionary, sentence) == expected", "def test_replaceWords():\n    solution = Solution()\n    dictionary = ['quick', 'brown', 'the']\n    sentence = 'the quick brown fox jumps'\n    expected = 'the quick brown fox jumps'\n    assert solution.replaceWords(dictionary, sentence) == expected", "def test_replaceWords():\n    solution = Solution()\n    dictionary = ['play', 'playing']\n    sentence = 'playing is fun'\n    expected = 'play is fun'\n    assert solution.replaceWords(dictionary, sentence) == expected", "def test_replaceWords():\n    solution = Solution()\n    dictionary = ['bat', 'cat', 'rat']\n    sentence = 'the rat chased the bat and the cat'\n    expected = 'the rat chased the bat and the cat'\n    assert solution.replaceWords(dictionary, sentence) == expected", "def test_replaceWords():\n    solution = Solution()\n    dictionary = ['car', 'cart']\n    sentence = 'the cart was full of cargo'\n    expected = 'the car was full of car'\n    assert solution.replaceWords(dictionary, sentence) == expected", "def test_replaceWords():\n    solution = Solution()\n    dictionary = ['run', 'runner', 'running']\n    sentence = 'the runner was running fast'\n    expected = 'the run was run fast'\n    assert solution.replaceWords(dictionary, sentence) == expected", "def test_replaceWords():\n    solution = Solution()\n    dictionary = ['fly', 'high']\n    sentence = 'the bird soared above the trees'\n    expected = 'the bird soared above the trees'\n    assert solution.replaceWords(dictionary, sentence) == expected", "def test_replaceWords():\n    solution = Solution()\n    dictionary = ['man', 'woman', 'human']\n    sentence = 'the human race includes both man and woman'\n    expected = 'the human race includes both man and woman'\n    assert solution.replaceWords(dictionary, sentence) == expected", "def test_replaceWords():\n    solution = Solution()\n    dictionary = ['a', 'abc', 'abcd']\n    sentence = 'abcd is a test'\n    expected = 'a is a test'\n    assert solution.replaceWords(dictionary, sentence) == expected", "def test_replaceWords():\n    solution = Solution()\n    dictionary = ['happy', 'joy', 'pleasure']\n    sentence = 'sadness and sorrow are not in the dictionary'\n    expected = 'sadness and sorrow are not in the dictionary'\n    assert solution.replaceWords(dictionary, sentence) == expected", "def test_replaceWords():\n    solution = Solution()\n    dictionary = ['elephant', 'dinosaur']\n    sentence = 'the ant and the bee are small'\n    expected = 'the ant and the bee are small'\n    assert solution.replaceWords(dictionary, sentence) == expected", "def test_replaceWords():\n    solution = Solution()\n    dictionary = ['hello', 'world']\n    sentence = 'hello world'\n    expected = 'hello world'\n    assert solution.replaceWords(dictionary, sentence) == expected", "def test_replaceWords():\n    solution = Solution()\n    dictionary = ['fix', 'suffix']\n    sentence = 'the suffix of the word needs a fix'\n    expected = 'the suffix of the word needs a fix'\n    assert solution.replaceWords(dictionary, sentence) == expected", "def test_replaceWords():\n    solution = Solution()\n    dictionary = ['Tree', 'Sunny', 'day']\n    sentence = 'The trees sway on a sunny Day'\n    expected = 'The trees sway on a sunny Day'\n    assert solution.replaceWords(dictionary, sentence) == expected", "def test_replaceWords():\n    solution = Solution()\n    dictionary = ['fast', 'quick']\n    sentence = 'the quick brown fox jumps quick and fast'\n    expected = 'the quick brown fox jumps quick and fast'\n    assert solution.replaceWords(dictionary, sentence) == expected"]}
{"task_num": 673, "task_title": "Number of Longest Increasing Subsequence", "func_name": "findNumberOfLIS", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findNumberOfLIS(self, nums: List[int]) -> int:\n    ans = 0\n    maxLength = 0\n    length = [1] * len(nums)\n    count = [1] * len(nums)\n\n    for i, num in enumerate(nums):\n      for j in range(i):\n        if nums[j] < num:\n          if length[i] < length[j] + 1:\n            length[i] = length[j] + 1\n            count[i] = count[j]\n          elif length[i] == length[j] + 1:\n            count[i] += count[j]\n\n    for i, l in enumerate(length):\n      if l > maxLength:\n        maxLength = l\n        ans = count[i]\n      elif l == maxLength:\n        ans += count[i]\n\n    return ans\n", "tests": ["def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([1, 3, 5, 4, 7]) == 2", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([2, 2, 2, 2, 2]) == 5", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([1, 2, 4, 3, 5, 4, 7, 2]) == 3", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([5, 6, 7, 8, 1, 2, 3, 4]) == 1", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 2", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([3, 1, 2, 1, 2, 1, 2, 1, 2]) == 9", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([7, 8, 9, 1, 2, 3, 4, 5, 6]) == 1", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([2, 1, 3, 2, 5, 3, 4]) == 3", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([1, 2, 2, 3, 1, 5, 6]) == 1", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([4, 10, 4, 3, 8, 9]) == 2", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([1, 5, 4, 3, 2, 8, 9, 10]) == 1", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([1, 3, 2, 4, 3, 5]) == 3", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([6, 3, 5, 7, 3, 4, 8, 6]) == 3", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]) == 4", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([5, 7, 4, 9, 2, 8, 6, 3, 1, 0]) == 1", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([2, 5, 3, 7, 101, 18, 4, 6, 5]) == 2", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([100, 90, 80, 70, 60, 50, 40, 30, 20, 10]) == 10", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([1, 5, 3, 4, 2, 6, 7, 8, 3, 4, 5]) == 4", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([1, 10, 2, 9, 3, 8, 4, 7, 5, 6]) == 1"]}
{"task_num": 684, "task_title": "Redundant Connection", "func_name": "findRedundantConnection", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n    uf = UnionFind(len(edges) + 1)\n\n    for edge in edges:\n      u, v = edge\n      if not uf.unionByRank(u, v):\n        return edge\n", "tests": ["def test_findRedundantConnection():\n    solution = Solution()\n    edges = [[1, 2], [1, 3], [2, 3]]\n    assert solution.findRedundantConnection(edges) == [2, 3]", "def test_findRedundantConnection():\n    solution = Solution()\n    edges = [[1, 2], [2, 3], [3, 4], [4, 1], [4, 5]]\n    assert solution.findRedundantConnection(edges) == [4, 1]", "def test_findRedundantConnection():\n    solution = Solution()\n    edges = [[1, 4], [3, 4], [1, 3], [1, 2], [4, 5]]\n    assert solution.findRedundantConnection(edges) == [1, 3]", "def test_findRedundantConnection():\n    solution = Solution()\n    edges = [[1, 2], [2, 3], [3, 5], [4, 5], [2, 4]]\n    assert solution.findRedundantConnection(edges) == [2, 4]", "def test_findRedundantConnection():\n    solution = Solution()\n    edges = [[2, 3], [3, 4], [1, 2], [4, 5], [1, 5]]\n    assert solution.findRedundantConnection(edges) == [1, 5]", "def test_findRedundantConnection():\n    solution = Solution()\n    edges = [[1, 5], [2, 5], [3, 5], [4, 5], [1, 2]]\n    assert solution.findRedundantConnection(edges) == [1, 2]", "def test_findRedundantConnection():\n    solution = Solution()\n    edges = [[1, 3], [3, 5], [3, 4], [2, 3], [1, 2]]\n    assert solution.findRedundantConnection(edges) == [1, 2]", "def test_findRedundantConnection():\n    solution = Solution()\n    edges = [[1, 2], [2, 4], [3, 4], [1, 3], [2, 5]]\n    assert solution.findRedundantConnection(edges) == [1, 3]", "def test_findRedundantConnection():\n    solution = Solution()\n    edges = [[1, 2], [2, 3], [3, 6], [1, 4], [4, 5], [5, 6], [2, 5]]\n    assert solution.findRedundantConnection(edges) == [2, 5]", "def test_findRedundantConnection():\n    solution = Solution()\n    edges = [[3, 4], [1, 2], [2, 3], [1, 5], [4, 5]]\n    assert solution.findRedundantConnection(edges) == [4, 5]", "def test_findRedundantConnection():\n    solution = Solution()\n    edges = [[1, 6], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [4, 6]]\n    assert solution.findRedundantConnection(edges) == [4, 6]", "def test_findRedundantConnection():\n    solution = Solution()\n    edges = [[1, 3], [3, 6], [5, 6], [1, 2], [2, 5], [4, 5]]\n    assert solution.findRedundantConnection(edges) == [2, 5]", "def test_findRedundantConnection():\n    solution = Solution()\n    edges = [[2, 4], [3, 5], [4, 5], [2, 3], [1, 4]]\n    assert solution.findRedundantConnection(edges) == [4, 5]", "def test_findRedundantConnection():\n    solution = Solution()\n    edges = [[1, 4], [2, 4], [3, 4], [1, 3], [1, 2]]\n    assert solution.findRedundantConnection(edges) == [1, 2]", "def test_findRedundantConnection():\n    solution = Solution()\n    edges = [[1, 3], [2, 3], [4, 5], [5, 6], [3, 6]]\n    assert solution.findRedundantConnection(edges) == [3, 6]", "def test_findRedundantConnection():\n    solution = Solution()\n    edges = [[1, 2], [2, 3], [3, 4], [4, 2], [4, 5]]\n    assert solution.findRedundantConnection(edges) == [4, 2]", "def test_findRedundantConnection():\n    solution = Solution()\n    edges = [[1, 2], [2, 3], [3, 4], [4, 5], [1, 5]]\n    assert solution.findRedundantConnection(edges) == [1, 5]", "def test_findRedundantConnection():\n    solution = Solution()\n    edges = [[1, 2], [1, 3], [2, 4], [3, 5], [5, 6], [4, 3]]\n    assert solution.findRedundantConnection(edges) == [4, 3]", "def test_findRedundantConnection():\n    solution = Solution()\n    edges = [[2, 3], [3, 1], [1, 4], [2, 5], [3, 5]]\n    assert solution.findRedundantConnection(edges) == [3, 5]", "def test_findRedundantConnection():\n    solution = Solution()\n    edges = [[1, 3], [3, 4], [1, 2], [4, 5], [2, 4]]\n    assert solution.findRedundantConnection(edges) == [2, 4]"]}
{"task_num": 685, "task_title": "Redundant Connection II", "func_name": "findRedundantDirectedConnection", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\n    ids = [0] * (len(edges) + 1)\n    nodeWithTwoParents = 0\n\n    for _, v in edges:\n      ids[v] += 1\n      if ids[v] == 2:\n        nodeWithTwoParents = v\n\n    def findRedundantDirectedConnection(skippedEdgeIndex: int) -> List[int]:\n      uf = UnionFind(len(edges) + 1)\n\n      for i, edge in enumerate(edges):\n        if i == skippedEdgeIndex:\n          continue\n        if not uf.unionByRank(edge[0], edge[1]):\n          return edge\n\n      return []\n\n    if nodeWithTwoParents == 0:\n      return findRedundantDirectedConnection(-1)\n\n    for i in reversed(range(len(edges))):\n      _, v = edges[i]\n      if v == nodeWithTwoParents:\n        if not findRedundantDirectedConnection(i):\n          return edges[i]\n", "tests": ["def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1, 2], [1, 3], [2, 3]]\n    assert solution.findRedundantDirectedConnection(edges) == [2, 3]", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1, 2], [2, 3], [3, 4], [4, 1], [1, 5]]\n    assert solution.findRedundantDirectedConnection(edges) == [4, 1]", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[3, 1], [1, 2], [2, 3], [4, 2]]\n    assert solution.findRedundantDirectedConnection(edges) == [2, 3]", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[2, 1], [3, 1], [4, 2], [1, 4]]\n    assert solution.findRedundantDirectedConnection(edges) == [1, 4]", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 3]]\n    assert solution.findRedundantDirectedConnection(edges) == [6, 3]", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[5, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 3]]\n    assert solution.findRedundantDirectedConnection(edges) == [5, 3]", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1, 2], [2, 3], [3, 1], [4, 3]]\n    assert solution.findRedundantDirectedConnection(edges) == [3, 1]", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1, 3], [3, 4], [4, 2], [2, 5], [5, 3]]\n    assert solution.findRedundantDirectedConnection(edges) == [5, 3]", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1, 4], [4, 5], [5, 2], [2, 3], [3, 1], [6, 4]]\n    assert solution.findRedundantDirectedConnection(edges) == [3, 1]", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1, 5], [5, 6], [6, 7], [7, 2], [2, 3], [3, 4], [4, 2]]\n    assert solution.findRedundantDirectedConnection(edges) == [4, 2]", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1, 2], [2, 3], [3, 1], [4, 2], [5, 1]]\n    assert solution.findRedundantDirectedConnection(edges) == [3, 1]", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[2, 3], [3, 4], [4, 5], [5, 6], [6, 3], [1, 3]]\n    assert solution.findRedundantDirectedConnection(edges) == [6, 3]", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 3]]\n    assert solution.findRedundantDirectedConnection(edges) == [7, 3]", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1, 2], [2, 3], [3, 4], [4, 5], [3, 6], [5, 2]]\n    assert solution.findRedundantDirectedConnection(edges) == [5, 2]", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1, 2], [2, 3], [3, 1], [4, 5], [5, 6], [6, 4]]\n    assert solution.findRedundantDirectedConnection(edges) == [3, 1]", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[4, 1], [1, 2], [2, 3], [3, 4], [1, 5]]\n    assert solution.findRedundantDirectedConnection(edges) == [3, 4]", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 3]]\n    assert solution.findRedundantDirectedConnection(edges) == [8, 3]", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1, 2], [2, 3], [3, 1], [4, 5], [5, 6], [6, 5]]\n    assert solution.findRedundantDirectedConnection(edges) == [3, 1]", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1, 2], [2, 3], [3, 4], [4, 1], [5, 6], [6, 7], [7, 5]]\n    assert solution.findRedundantDirectedConnection(edges) == [4, 1]", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1, 2], [2, 3], [3, 4], [5, 6], [6, 7], [7, 5], [4, 2]]\n    assert solution.findRedundantDirectedConnection(edges) == [4, 2]"]}
{"task_num": 688, "task_title": "Knight Probability in Chessboard", "func_name": "knightProbability", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\n    dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n    dp = [[0] * n for _ in range(n)]\n    dp[row][column] = 1.0\n\n    for _ in range(k):\n      newDp = [[0] * n for _ in range(n)]\n      for i in range(n):\n        for j in range(n):\n          for dx, dy in dirs:\n            x = i + dx\n            y = j + dy\n            if 0 <= x < n and 0 <= y < n:\n              newDp[i][j] += dp[x][y]\n      dp = newDp\n\n    return sum(map(sum, dp)) / 8**k\n", "tests": ["def test_knightProbability():\n    solution = Solution()\n    assert abs(solution.knightProbability(3, 2, 0, 0) - 0.0625) < 1e-05", "def test_knightProbability():\n    solution = Solution()\n    assert abs(solution.knightProbability(8, 1, 4, 4) - 1.0) < 1e-05", "def test_knightProbability():\n    solution = Solution()\n    assert abs(solution.knightProbability(5, 3, 2, 2) - 0.875) < 1e-05", "def test_knightProbability():\n    solution = Solution()\n    assert abs(solution.knightProbability(4, 4, 1, 1) - 0.2939453125) < 1e-05", "def test_knightProbability():\n    solution = Solution()\n    assert abs(solution.knightProbability(1, 0, 0, 0) - 1.0) < 1e-05", "def test_knightProbability():\n    solution = Solution()\n    assert abs(solution.knightProbability(3, 10, 0, 0) - 0.00019052566) < 1e-05", "def test_knightProbability():\n    solution = Solution()\n    assert abs(solution.knightProbability(6, 2, 5, 5) - 0.53125) < 1e-05", "def test_knightProbability():\n    solution = Solution()\n    assert abs(solution.knightProbability(7, 3, 3, 3) - 0.7265625) < 1e-05", "def test_knightProbability():\n    solution = Solution()\n    assert abs(solution.knightProbability(5, 5, 0, 4) - 0.22265625) < 1e-05", "def test_knightProbability():\n    solution = Solution()\n    assert abs(solution.knightProbability(8, 0, 7, 7) - 1.0) < 1e-05", "def test_knightProbability():\n    solution = Solution()\n    assert abs(solution.knightProbability(2, 1, 0, 1) - 0.25) < 1e-05", "def test_knightProbability():\n    solution = Solution()\n    assert abs(solution.knightProbability(5, 4, 3, 2) - 0.5537109375) < 1e-05", "def test_knightProbability():\n    solution = Solution()\n    assert abs(solution.knightProbability(4, 6, 0, 0) - 0.015625) < 1e-05", "def test_knightProbability():\n    solution = Solution()\n    assert abs(solution.knightProbability(3, 1, 2, 2) - 0.5) < 1e-05", "def test_knightProbability():\n    solution = Solution()\n    assert abs(solution.knightProbability(3, 5, 1, 1) - 0.0234375) < 1e-05", "def test_knightProbability():\n    solution = Solution()\n    assert abs(solution.knightProbability(6, 2, 0, 0) - 0.28125) < 1e-05", "def test_knightProbability():\n    solution = Solution()\n    assert abs(solution.knightProbability(8, 7, 4, 4) - 0.228515625) < 1e-05", "def test_knightProbability():\n    solution = Solution()\n    assert abs(solution.knightProbability(5, 8, 2, 3) - 0.0703125) < 1e-05", "def test_knightProbability():\n    solution = Solution()\n    assert abs(solution.knightProbability(4, 3, 3, 0) - 0.2734375) < 1e-05", "def test_knightProbability():\n    solution = Solution()\n    assert abs(solution.knightProbability(7, 2, 5, 6) - 0.390625) < 1e-05"]}
{"task_num": 689, "task_title": "Maximum Sum of 3 Non-Overlapping Subarrays", "func_name": "maxSumOfThreeSubarrays", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:\n    n = len(nums) - k + 1\n    sums = [0] * n\n    l = [0] * n\n    r = [0] * n\n\n    summ = 0\n    for i, num in enumerate(nums):\n      summ += num\n      if i >= k:\n        summ -= nums[i - k]\n      if i >= k - 1:\n        sums[i - k + 1] = summ\n\n    maxIndex = 0\n    for i in range(n):\n      if sums[i] > sums[maxIndex]:\n        maxIndex = i\n      l[i] = maxIndex\n\n    maxIndex = n - 1\n    for i in range(n - 1, -1, -1):\n      if sums[i] >= sums[maxIndex]:\n        maxIndex = i\n      r[i] = maxIndex\n\n    ans = [-1, -1, -1]\n\n    for i in range(k, n - k):\n      if ans[0] == -1 or sums[ans[0]] + sums[ans[1]] + sums[ans[2]] < sums[l[i - k]] + sums[i] + sums[r[i + k]]:\n        ans[0] = l[i - k]\n        ans[1] = i\n        ans[2] = r[i + k]\n\n    return ans\n", "tests": ["def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([1, 2, 1, 2, 6, 7, 5, 1], 2) == [0, 3, 5]", "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([4, 3, 5, 2, 1, 6, 9, 0, 8], 3) == [0, 4, 6]", "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10], 2) == [0, 4, 8]", "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([5, 7, 3, 8, 6, 2, 9, 4, 5, 1], 2) == [0, 3, 6]", "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([1, 1, 1, 1, 1, 1, 1, 1, 1], 3) == [0, 1, 2]", "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1], 2) == [0, 2, 4]", "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([3, 3, 3, 1, 2, 1, 2, 3, 3, 3], 3) == [0, 4, 7]", "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([8, 6, 8, 6, 8, 6, 8, 6, 8, 6], 2) == [0, 2, 4]", "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5], 3) == [1, 5, 9]", "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([7, 7, 2, 7, 2, 7, 2, 7, 2, 7, 7, 7], 3) == [0, 3, 9]", "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5], 1) == [0, 2, 4]", "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([2, 4, 6, 8, 10, 12, 14, 16, 18, 20], 4) == [2, 4, 6]", "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([9, 1, 2, 9, 8, 7, 9, 6, 9, 5, 9], 2) == [0, 3, 6]", "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([3, 8, 1, 3, 8, 1, 3, 8, 1], 2) == [1, 4, 7]", "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([6, 5, 4, 3, 2, 1, 0, 7, 6, 5, 4], 3) == [0, 3, 7]", "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6], 2) == [0, 2, 4]", "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1], 3) == [1, 4, 7]", "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([10, 9, 8, 7, 6, 5, 4, 3, 2, 1], 2) == [0, 2, 4]", "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6], 3) == [3, 5, 9]", "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([1, 5, 3, 8, 3, 5, 9, 1, 2, 6, 3, 1, 7], 2) == [3, 5, 8]"]}
{"task_num": 691, "task_title": "Stickers to Spell Word", "func_name": "minStickers", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minStickers(self, stickers: List[str], target: str) -> int:\n    maxMask = 1 << len(target)\n    dp = [math.inf] * maxMask\n    dp[0] = 0\n\n    for mask in range(maxMask):\n      if dp[mask] == math.inf:\n        continue\n      for sticker in stickers:\n        superMask = mask\n        for c in sticker:\n          for i, t in enumerate(target):\n            if c == t and not (superMask >> i & 1):\n              superMask |= 1 << i\n              break\n        dp[superMask] = min(dp[superMask], dp[mask] + 1)\n\n    return -1 if dp[-1] == math.inf else dp[-1]\n", "tests": ["def test_minStickers():\n    solution = Solution()\n    assert solution.minStickers(['with', 'example', 'science'], 'thehat') == 3", "def test_minStickers():\n    solution = Solution()\n    assert solution.minStickers(['notice', 'possible'], 'basicbasic') == -1", "def test_minStickers():\n    solution = Solution()\n    assert solution.minStickers(['these', 'guess', 'about', 'garden', 'him'], 'another') == 3", "def test_minStickers():\n    solution = Solution()\n    assert solution.minStickers(['look', 'just', 'like', 'her', 'brother'], 'joke') == 4", "def test_minStickers():\n    solution = Solution()\n    assert solution.minStickers(['this', 'is', 'a', 'test'], 'sheets') == 2", "def test_minStickers():\n    solution = Solution()\n    assert solution.minStickers(['seventh', 'heaven', 'event'], 'neat') == 1", "def test_minStickers():\n    solution = Solution()\n    assert solution.minStickers(['apple', 'pear', 'orange'], 'peach') == -1", "def test_minStickers():\n    solution = Solution()\n    assert solution.minStickers(['travel', 'around', 'world'], 'road') == 3", "def test_minStickers():\n    solution = Solution()\n    assert solution.minStickers(['fun', 'in', 'sun'], 'sniff') == 4", "def test_minStickers():\n    solution = Solution()\n    assert solution.minStickers(['balloon', 'moon', 'soon'], 'saloon') == 2", "def test_minStickers():\n    solution = Solution()\n    assert solution.minStickers(['quick', 'brown', 'fox'], 'box') == 2", "def test_minStickers():\n    solution = Solution()\n    assert solution.minStickers(['alpha', 'beta', 'gamma'], 'meta') == 3", "def test_minStickers():\n    solution = Solution()\n    assert solution.minStickers(['one', 'two', 'three'], 'tone') == 2", "def test_minStickers():\n    solution = Solution()\n    assert solution.minStickers(['happy', 'birthday', 'party'], 'hard') == 2", "def test_minStickers():\n    solution = Solution()\n    assert solution.minStickers(['alpha', 'delta', 'echo'], 'lead') == 2", "def test_minStickers():\n    solution = Solution()\n    assert solution.minStickers(['dog', 'cat', 'bird'], 'rabbit') == -1", "def test_minStickers():\n    solution = Solution()\n    assert solution.minStickers(['blue', 'green', 'red'], 'greed') == 3", "def test_minStickers():\n    solution = Solution()\n    assert solution.minStickers(['post', 'card', 'stamp'], 'past') == 2", "def test_minStickers():\n    solution = Solution()\n    assert solution.minStickers(['water', 'bottle', 'cap'], 'table') == 3", "def test_minStickers():\n    solution = Solution()\n    assert solution.minStickers(['star', 'planet', 'galaxy'], 'angel') == 2"]}
{"task_num": 722, "task_title": "Remove Comments", "func_name": "removeComments", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def removeComments(self, source: List[str]) -> List[str]:\n    ans = []\n    commenting = False\n    modified = ''\n\n    for line in source:\n      i = 0\n      while i < len(line):\n        if i + 1 == len(line):\n          if not commenting:\n            modified += line[i]\n          i += 1\n          break\n        twoChars = line[i:i + 2]\n        if twoChars == '/*' and not commenting:\n          commenting = True\n          i += 2\n        elif twoChars == '*/' and commenting:\n          commenting = False\n          i += 2\n        elif twoChars == '//':\n          if not commenting:\n            break\n          else:\n            i += 2\n        else:\n          if not commenting:\n            modified += line[i]\n          i += 1\n      if modified and not commenting:\n        ans.append(modified)\n        modified = ''\n\n    return ans\n", "tests": ["def test_removeComments():\n    solution = Solution()\n    source = ['int main() {', '   // line comment', '   cout << \"Hello World\"; /* block comment */', '   return 0;', '}']\n    expected = ['int main() {', '   ', '   cout << \"Hello World\"; ', '   return 0;', '}']\n    assert solution.removeComments(source) == expected", "def test_removeComments():\n    solution = Solution()\n    source = ['/* block comment */', 'int a = 10; /* inline block comment */ int b = 20;', 'int c = a + b; // line comment', '/* multi-line', 'block comment */', 'return c;']\n    expected = ['int a = 10;  int b = 20;', 'int c = a + b; ', 'return c;']\n    assert solution.removeComments(source) == expected", "def test_removeComments():\n    solution = Solution()\n    source = ['string s = \"// not a comment\";', '/* start block', 'comment with // line comment', 'and ends here */', 'cout << s;', 'int num = 0; /*block starts', 'and ends*/ int x = 1;']\n    expected = ['string s = \"// not a comment\";', 'cout << s;', 'int num = 0;  int x = 1;']\n    assert solution.removeComments(source) == expected", "def test_removeComments():\n    solution = Solution()\n    source = ['// This is a full line comment', 'int x = 10;', '/* This is a', 'multi-line block comment', 'that ends here */ int y = 20;', 'int z = x + y; // trailing line comment', '/* start and end in single line */ int w = 30;']\n    expected = ['int x = 10;', ' int y = 20;', 'int z = x + y; ', ' int w = 30;']\n    assert solution.removeComments(source) == expected", "def test_removeComments():\n    solution = Solution()\n    source = ['int i = 0; /* block starts', 'and continues */ int j = 1; // line comment', '/* block comment // with line comment inside */', 'int k = i + j;', '/* single line block comment */']\n    expected = ['int i = 0;  int j = 1; ', 'int k = i + j;']\n    assert solution.removeComments(source) == expected", "def test_removeComments():\n    solution = Solution()\n    source = ['int x = 100;', 'int y = 200; /* This block comment /* contains nested block comment symbols */ int z = 300;', '// This is just a full line comment', 'return x + y + z;', \"/* A block comment that doesn't end on this line\", 'but continues on this line */ int a = 400;']\n    expected = ['int x = 100;', 'int y = 200;  int z = 300;', 'return x + y + z;', ' int a = 400;']\n    assert solution.removeComments(source) == expected", "def test_removeComments():\n    solution = Solution()\n    source = ['int main() {', '    int a = 0; // initialize a', '    /* block comment starts', '    and includes multiple lines */', '    int b = 1;', '    // line comment /* with block start */', '    return a + b;', '}']\n    expected = ['int main() {', '    int a = 0; ', '    int b = 1;', '    return a + b;', '}']\n    assert solution.removeComments(source) == expected", "def test_removeComments():\n    solution = Solution()\n    source = ['int compute() { // start of function', '    int x = 10; /* an inline block comment */', '    /* block comment starts', '    still in block comment', '    end of block comment */ int y = 20;', '    int result = x + y;', '    return result; /* another comment */', '}']\n    expected = ['int compute() { ', '    int x = 10; ', '    int y = 20;', '    int result = x + y;', '    return result; ', '}']\n    assert solution.removeComments(source) == expected", "def test_removeComments():\n    solution = Solution()\n    source = ['function foo() {', '    // Function to do something', '    var x = 5; /* block comment */ var y = 10;', '    /* Start block', '    and continue', '    block ends */ var z = 15; // end of line comment', '    return x + y + z;', '}']\n    expected = ['function foo() {', '    ', '    var x = 5;  var y = 10;', '    var z = 15; ', '    return x + y + z;', '}']\n    assert solution.removeComments(source) == expected", "def test_removeComments():\n    solution = Solution()\n    source = ['int calculateSum(int a, int b) {', '    int sum = a + b; // Calculate sum', '    /* Start of a block comment', '    with some explanation', '    that ends here */', '    return sum;', '    /* This block will not affect return */', '}']\n    expected = ['int calculateSum(int a, int b) {', '    int sum = a + b; ', '    return sum;', '}']\n    assert solution.removeComments(source) == expected", "def test_removeComments():\n    solution = Solution()\n    source = ['for (int i = 0; i < 10; i++) {', '    // loop iteration', '    printf(\"%d\\\\n\", i); /* print value */', '    /*', '    This is a comment block', '    that should be ignored', '    */', '    // End of loop', '}']\n    expected = ['for (int i = 0; i < 10; i++) {', '    ', '    printf(\"%d\\\\n\", i); ', '}']\n    assert solution.removeComments(source) == expected", "def test_removeComments():\n    solution = Solution()\n    source = ['void example() {', '    // Initialize variables', '    int a = 5, b = 10;', '    /* Comment spans', '    multiple lines', '    and ends here */', '    int sum = a + b;', '    return; // End of function', '    /* This comment is after return */', '}']\n    expected = ['void example() {', '    ', '    int a = 5, b = 10;', '    int sum = a + b;', '    return; ', '}']\n    assert solution.removeComments(source) == expected", "def test_removeComments():\n    solution = Solution()\n    source = ['char* greet() {', '    /* This function returns a greeting */', '    char* message = \"Hello, world!\";', '    // Return the message', '    return message;', '    /* End of function */', '}']\n    expected = ['char* greet() {', '    char* message = \"Hello, world!\";', '    ', '    return message;', '}']\n    assert solution.removeComments(source) == expected", "def test_removeComments():\n    solution = Solution()\n    source = ['while (true) {', '    // Infinite loop', '    /* Block comment start', '    Block comment continues on next line', '    Block comment ends here */', '    if (condition) {', '        break; // Exit loop', '    }', '    // Some more comments', '}']\n    expected = ['while (true) {', '    ', '    if (condition) {', '        break; ', '    }', '}']\n    assert solution.removeComments(source) == expected", "def test_removeComments():\n    solution = Solution()\n    source = ['if (a > b) {', '    // Check if a is greater than b', '    /* This is a block comment that does not', '    interfere with the logic below */', '    printf(\"a is greater than b\");', '} else {', '    printf(\"a is not greater than b\");', '    // End of else block', '}']\n    expected = ['if (a > b) {', '    ', '    printf(\"a is greater than b\");', '} else {', '    printf(\"a is not greater than b\");', '}']\n    assert solution.removeComments(source) == expected", "def test_removeComments():\n    solution = Solution()\n    source = ['switch (n) {', '    case 1:', '        // Case for 1', '        printf(\"One\");', '        break;', '    case 2:', '        printf(\"Two\"); /* Comment after statement */', '        break;', '    /* Default case', '    This case handles everything else */', '    default:', '        printf(\"Other\");', '        break;', '}']\n    expected = ['switch (n) {', '    case 1:', '        ', '        printf(\"One\");', '        break;', '    case 2:', '        printf(\"Two\"); ', '        break;', '    default:', '        printf(\"Other\");', '        break;', '}']\n    assert solution.removeComments(source) == expected", "def test_removeComments():\n    solution = Solution()\n    source = ['try {', '    // Try block', '    riskyFunction();', '    /* Block comment across', '    multiple lines inside try */', '} catch (Exception e) {', '    // Catch block', '    handleException(e);', '    /* Comment at the end of catch */', '} finally {', '    // Finally block', '    cleanup();', '}']\n    expected = ['try {', '    ', '    riskyFunction();', '} catch (Exception e) {', '    ', '    handleException(e);', '} finally {', '    ', '    cleanup();', '}']\n    assert solution.removeComments(source) == expected", "def test_removeComments():\n    solution = Solution()\n    source = ['do {', '    // Start of do-while loop', '    performAction();', '    /* This block comment', '    should be ignored completely */', '} while (condition);', '// End of do-while']\n    expected = ['do {', '    ', '    performAction();', '} while (condition);', '']\n    assert solution.removeComments(source) == expected", "def test_removeComments():\n    solution = Solution()\n    source = ['int fibonacci(int n) {', '    if (n <= 1) return n;', '    // Recursive case', '    return fibonacci(n - 1) + fibonacci(n - 2);', '    /* This line is unreachable', '    due to the return statement above */', '}']\n    expected = ['int fibonacci(int n) {', '    if (n <= 1) return n;', '    ', '    return fibonacci(n - 1) + fibonacci(n - 2);', '}']\n    assert solution.removeComments(source) == expected", "def test_removeComments():\n    solution = Solution()\n    source = ['struct Node {', '    int data;', '    Node* next;', '    // Constructor for Node', '    Node(int x) : data(x), next(nullptr) {}', '    /* Destructor', '    Not necessary in this example */', '};', '/* End of struct definition */']\n    expected = ['struct Node {', '    int data;', '    Node* next;', '    Node(int x) : data(x), next(nullptr) {}', '};']\n    assert solution.removeComments(source) == expected"]}
{"task_num": 730, "task_title": "Count Different Palindromic Subsequences", "func_name": "countPalindromicSubsequences", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countPalindromicSubsequences(self, s: str) -> int:\n    kMod = 1_000_000_007\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n      dp[i][i] = 1\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        if s[i] == s[j]:\n          lo = i + 1\n          hi = j - 1\n          while lo <= hi and s[lo] != s[i]:\n            lo += 1\n          while lo <= hi and s[hi] != s[i]:\n            hi -= 1\n          if lo > hi:\n            dp[i][j] = dp[i + 1][j - 1] * 2 + 2\n          elif lo == hi:\n            dp[i][j] = dp[i + 1][j - 1] * 2 + 1\n          else:\n            dp[i][j] = dp[i + 1][j - 1] * 2 - dp[lo + 1][hi - 1]\n        else:\n          dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1]\n        dp[i][j] = (dp[i][j] + kMod) % kMod\n\n    return dp[0][n - 1]\n", "tests": ["def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('bccb') == 6", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('aabaa') == 9", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('abc') == 3", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('aaaa') == 15", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('abac') == 6", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('aabb') == 8", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('abcd') == 4", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('racecar') == 28", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('abba') == 9", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('abcba') == 15", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('xyzzyx') == 21", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('aaaaa') == 31", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('level') == 11", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('noon') == 8", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('madam') == 13", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('rotor') == 13", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('deified') == 29", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('banana') == 19", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('civic') == 13", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('refer') == 15"]}
{"task_num": 735, "task_title": "Asteroid Collision", "func_name": "asteroidCollision", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def asteroidCollision(self, asteroids: List[int]) -> List[int]:\n    stack = []\n\n    for a in asteroids:\n      if a > 0:\n        stack.append(a)\n      else:\n        while stack and stack[-1] > 0 and stack[-1] < -a:\n          stack.pop()\n        if not stack or stack[-1] < 0:\n          stack.append(a)\n        elif stack[-1] == -a:\n          stack.pop()\n        else:\n          pass\n\n    return stack\n", "tests": ["def test_asteroidCollision():\n    solution = Solution()\n    assert solution.asteroidCollision([5, 10, -5]) == [5, 10]", "def test_asteroidCollision():\n    solution = Solution()\n    assert solution.asteroidCollision([8, -8]) == []", "def test_asteroidCollision():\n    solution = Solution()\n    assert solution.asteroidCollision([-2, -1, 1, 2]) == [-2, -1, 1, 2]", "def test_asteroidCollision():\n    solution = Solution()\n    assert solution.asteroidCollision([10, 2, -5]) == [10]", "def test_asteroidCollision():\n    solution = Solution()\n    assert solution.asteroidCollision([-10, 5, 10, -5, -10]) == [-10, -10]", "def test_asteroidCollision():\n    solution = Solution()\n    assert solution.asteroidCollision([1, -1, 2, -2, 3, -3]) == []", "def test_asteroidCollision():\n    solution = Solution()\n    assert solution.asteroidCollision([4, -2, -2, -2]) == [-2, -2, -2]", "def test_asteroidCollision():\n    solution = Solution()\n    assert solution.asteroidCollision([3, 5, -3, -5, 4, -4, 6]) == [6]", "def test_asteroidCollision():\n    solution = Solution()\n    assert solution.asteroidCollision([-5, -3, -2, 4, 6, -8]) == [-5, -3, -8]", "def test_asteroidCollision():\n    solution = Solution()\n    assert solution.asteroidCollision([1, 3, 2, -1, -2]) == [1, 3]", "def test_asteroidCollision():\n    solution = Solution()\n    assert solution.asteroidCollision([-1, -2, -3, 3, 2, 1]) == [-1, -2, -3, 3, 2, 1]", "def test_asteroidCollision():\n    solution = Solution()\n    assert solution.asteroidCollision([7, -3, -3, 5, -10]) == [-3, -10]", "def test_asteroidCollision():\n    solution = Solution()\n    assert solution.asteroidCollision([6, -7, 8, -6]) == [8]", "def test_asteroidCollision():\n    solution = Solution()\n    assert solution.asteroidCollision([5, -1, -2, -3, 4]) == [5, 4]", "def test_asteroidCollision():\n    solution = Solution()\n    assert solution.asteroidCollision([-1, 5, -2, 8, -9, 10]) == [-1, 10]", "def test_asteroidCollision():\n    solution = Solution()\n    assert solution.asteroidCollision([1, 2, -2, -1, -5]) == [-5]", "def test_asteroidCollision():\n    solution = Solution()\n    assert solution.asteroidCollision([10, 1, -1, -10, 2]) == [2]", "def test_asteroidCollision():\n    solution = Solution()\n    assert solution.asteroidCollision([-3, 3, 2, -2, 4]) == [4]", "def test_asteroidCollision():\n    solution = Solution()\n    assert solution.asteroidCollision([-4, 5, 3, -6, 1]) == [-4, -6, 1]", "def test_asteroidCollision():\n    solution = Solution()\n    assert solution.asteroidCollision([7, -5, 4, -7, 6, -6]) == [7]"]}
{"task_num": 743, "task_title": "Network Delay Time", "func_name": "networkDelayTime", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in times:\n      graph[u - 1].append((v - 1, w))\n\n    return self._dijkstra(graph, k - 1)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int) -> int:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    maxDist = max(dist)\n    return maxDist if maxDist != math.inf else -1\n", "tests": ["def test_networkDelayTime():\n    solution = Solution()\n    times = [[2, 1, 1], [2, 3, 1], [3, 4, 1]]\n    n = 4\n    k = 2\n    assert solution.networkDelayTime(times, n, k) == 2", "def test_networkDelayTime():\n    solution = Solution()\n    times = [[1, 2, 1], [2, 3, 2], [1, 3, 4]]\n    n = 3\n    k = 1\n    assert solution.networkDelayTime(times, n, k) == 3", "def test_networkDelayTime():\n    solution = Solution()\n    times = [[1, 2, 1]]\n    n = 2\n    k = 2\n    assert solution.networkDelayTime(times, n, k) == -1", "def test_networkDelayTime():\n    solution = Solution()\n    times = [[1, 2, 1], [2, 3, 1], [3, 4, 1], [4, 5, 1], [5, 6, 1]]\n    n = 6\n    k = 1\n    assert solution.networkDelayTime(times, n, k) == 5", "def test_networkDelayTime():\n    solution = Solution()\n    times = [[1, 2, 5], [1, 3, 2], [3, 4, 1], [4, 2, 1]]\n    n = 4\n    k = 1\n    assert solution.networkDelayTime(times, n, k) == 4", "def test_networkDelayTime():\n    solution = Solution()\n    times = [[1, 2, 1], [2, 1, 3]]\n    n = 2\n    k = 2\n    assert solution.networkDelayTime(times, n, k) == 3", "def test_networkDelayTime():\n    solution = Solution()\n    times = []\n    n = 1\n    k = 1\n    assert solution.networkDelayTime(times, n, k) == 0", "def test_networkDelayTime():\n    solution = Solution()\n    times = [[1, 2, 1], [2, 3, 2], [3, 1, 4], [2, 4, 3], [4, 5, 1]]\n    n = 5\n    k = 3\n    assert solution.networkDelayTime(times, n, k) == 7", "def test_networkDelayTime():\n    solution = Solution()\n    times = [[1, 2, 1], [1, 3, 2], [2, 3, 2], [3, 4, 1], [4, 2, 3]]\n    n = 4\n    k = 1\n    assert solution.networkDelayTime(times, n, k) == 3", "def test_networkDelayTime():\n    solution = Solution()\n    times = [[2, 3, 4], [3, 4, 5]]\n    n = 4\n    k = 2\n    assert solution.networkDelayTime(times, n, k) == -1", "def test_networkDelayTime():\n    solution = Solution()\n    times = [[1, 2, 1], [2, 3, 1], [1, 4, 2], [4, 5, 1], [5, 3, 1]]\n    n = 5\n    k = 1\n    assert solution.networkDelayTime(times, n, k) == 3", "def test_networkDelayTime():\n    solution = Solution()\n    times = [[1, 2, 5], [2, 3, 5], [3, 4, 1], [1, 3, 9], [1, 4, 11]]\n    n = 4\n    k = 1\n    assert solution.networkDelayTime(times, n, k) == 11", "def test_networkDelayTime():\n    solution = Solution()\n    times = [[1, 2, 2], [1, 3, 4], [2, 3, 1], [3, 4, 3], [4, 5, 1], [5, 6, 2]]\n    n = 6\n    k = 1\n    assert solution.networkDelayTime(times, n, k) == 9", "def test_networkDelayTime():\n    solution = Solution()\n    times = [[1, 2, 1], [2, 3, 2], [3, 1, 1], [3, 4, 1], [4, 5, 1], [5, 6, 1]]\n    n = 6\n    k = 3\n    assert solution.networkDelayTime(times, n, k) == 4", "def test_networkDelayTime():\n    solution = Solution()\n    times = [[1, 2, 1], [1, 3, 100], [2, 3, 1], [2, 4, 1], [4, 5, 1]]\n    n = 5\n    k = 1\n    assert solution.networkDelayTime(times, n, k) == 4", "def test_networkDelayTime():\n    solution = Solution()\n    times = [[1, 2, 1], [2, 1, 2]]\n    n = 2\n    k = 1\n    assert solution.networkDelayTime(times, n, k) == 2", "def test_networkDelayTime():\n    solution = Solution()\n    times = [[1, 2, 2], [2, 3, 2], [1, 3, 4], [3, 4, 1], [2, 4, 3]]\n    n = 4\n    k = 1\n    assert solution.networkDelayTime(times, n, k) == 5", "def test_networkDelayTime():\n    solution = Solution()\n    times = [[1, 2, 1], [2, 3, 2], [2, 4, 1], [3, 5, 1], [4, 5, 2]]\n    n = 5\n    k = 2\n    assert solution.networkDelayTime(times, n, k) == 4", "def test_networkDelayTime():\n    solution = Solution()\n    times = [[1, 2, 2], [1, 3, 1], [3, 4, 1], [4, 5, 1], [5, 6, 1], [2, 6, 5]]\n    n = 6\n    k = 1\n    assert solution.networkDelayTime(times, n, k) == 5", "def test_networkDelayTime():\n    solution = Solution()\n    times = [[1, 2, 1], [1, 3, 2], [2, 4, 1], [3, 4, 2], [4, 5, 1]]\n    n = 5\n    k = 3\n    assert solution.networkDelayTime(times, n, k) == 3"]}
{"task_num": 770, "task_title": "Basic Calculator IV", "func_name": "basicCalculatorIV", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Poly:\n  def __init__(self, term: str = None, coef: int = None):\n    if term and coef:\n      self.terms = collections.Counter({term: coef})\n    else:\n      self.terms = collections.Counter()\n\n  def __add__(self, other):\n    for term, coef in other.terms.items():\n      self.terms[term] += coef\n    return self\n\n  def __sub__(self, other):\n    for term, coef in other.terms.items():\n      self.terms[term] -= coef\n    return self\n\n  def __mul__(self, other):\n    res = Poly()\n    for a, aCoef in self.terms.items():\n      for b, bCoef in other.terms.items():\n        res.terms[self._merge(a, b)] += aCoef * bCoef\n    return res\n\n  def toList(self) -> List[str]:\n    for term in list(self.terms.keys()):\n      if not self.terms[term]:\n        del self.terms[term]\n\n    def cmp(term: str) -> tuple:\n      if term == '1':\n        return (0,)\n      var = term.split('*')\n      return (-len(var), term)\n\n    def concat(term: str) -> str:\n      if term == '1':\n        return str(self.terms[term])\n      return str(self.terms[term]) + '*' + term\n\n    terms = list(self.terms.keys())\n    terms.sort(key=cmp)\n    return [concat(term) for term in terms]\n\n  def _merge(self, a: str, b: str) -> str:\n    if a == '1':\n      return b\n    if b == '1':\n      return a\n    res = []\n    A = a.split('*')\n    B = b.split('*')\n    i = 0\n    j = 0\n    while i < len(A) and j < len(B):\n      if A[i] < B[j]:\n        res.append(A[i])\n        i += 1\n      else:\n        res.append(B[j])\n        j += 1\n    return '*'.join(res + A[i:] + B[j:])\n\n\nclass Solution:\n  def basicCalculatorIV(self, expression: str, evalvars: List[str], evalints: List[int]) -> List[str]:\n    tokens = list(self._getTokens(expression))\n    evalMap = {a: b for a, b in zip(evalvars, evalints)}\n\n    for i, token in enumerate(tokens):\n      if token in evalMap:\n        tokens[i] = str(evalMap[token])\n\n    postfix = self._infixToPostfix(tokens)\n    return self._evaluate(postfix).toList()\n\n  def _getTokens(self, s: str) -> Iterator[str]:\n    i = 0\n    for j, c in enumerate(s):\n      if c == ' ':\n        if i < j:\n          yield s[i:j]\n        i = j + 1\n      elif c in '()+-*':\n        if i < j:\n          yield s[i:j]\n        yield c\n        i = j + 1\n    if i < len(s):\n      yield s[i:]\n\n  def _infixToPostfix(self, tokens: List[str]) -> List[str]:\n    postfix = []\n    ops = []\n\n    def precedes(prevOp: str, currOp: str) -> bool:\n      if prevOp == '(':\n        return False\n      return prevOp == '*' or currOp in '+-'\n\n    for token in tokens:\n      if token == '(':\n        ops.append(token)\n      elif token == ')':\n        while ops[-1] != '(':\n          postfix.append(ops.pop())\n        ops.pop()\n      elif token in '+-*':\n        while ops and precedes(ops[-1], token):\n          postfix.append(ops.pop())\n        ops.append(token)\n      else:\n        postfix.append(token)\n    return postfix + ops[::-1]\n\n  def _evaluate(self, postfix: List[str]) -> Poly:\n    polys: List[Poly] = []\n    for token in postfix:\n      if token in '+-*':\n        b = polys.pop()\n        a = polys.pop()\n        if token == '+':\n          polys.append(a + b)\n        elif token == '-':\n          polys.append(a - b)\n        else:\n          polys.append(a * b)\n      elif token.lstrip('-').isnumeric():\n        polys.append(Poly(\"1\", int(token)))\n      else:\n        polys.append(Poly(token, 1))\n    return polys[0]\n", "tests": ["def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('e + 8 - a + 5', ['e'], [1]) == ['-1*a', '14']", "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('a * b - b * a + 2 * (z - 1)', ['z'], [3]) == ['2', '2*z']", "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('3 * x * y + x - y', ['x', 'y'], [2, 1]) == ['5*x', '-1']", "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('2 * (a + b) - 3 * c', ['a', 'b', 'c'], [1, 1, 2]) == ['-3', '2*a', '2*b']", "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('(x + y) * (x - y) + z * z', ['z'], [0]) == ['1*x*x', '-1*y*y']", "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('x * x * y + y * y * x + z', ['x', 'y', 'z'], [1, 1, 0]) == ['2*x*y']", "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('x * (y + z) - z * (y + x)', ['y', 'z'], [2, 1]) == ['1*x']", "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('a * b * c + b * c * a - 4 * a * c', ['a', 'b', 'c'], [1, 2, 3]) == ['12']", "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('2 * a * (b + c) - 3 * (b - c)', ['a', 'b', 'c'], [1, 2, 3]) == ['10', '2*a*b', '2*a*c']", "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('((a + b) * (c - d)) + e', ['a', 'b', 'c', 'd', 'e'], [1, 2, 3, 4, 5]) == ['5']", "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('x * x - y * y + z * z', ['x', 'y', 'z'], [0, 0, 1]) == ['1']", "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('(a + b) * (c + d) - a * d', ['a', 'b', 'c', 'd'], [1, 2, 3, 4]) == ['11', '7*a', '8*b']", "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('a * (b - c) + d * (c - b)', ['a', 'b', 'c', 'd'], [1, 2, 3, 4]) == ['-1*a', '-3']", "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('x * (y * z) - (x * z) * y + 5', ['x', 'y', 'z'], [1, 2, 3]) == ['5']", "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('3 * (a - b) * (c + d) + 4', ['a', 'b', 'c', 'd'], [2, 1, 3, 4]) == ['28']", "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('x - y + x * y - x * y', ['x', 'y'], [3, 2]) == ['1']", "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('a * a - b * b + c * c - d * d', ['a', 'b', 'c', 'd'], [1, 1, 1, 1]) == ['0']", "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('4 * (x + y) * z - 2 * x * z', ['x', 'y', 'z'], [1, 2, 3]) == ['18', '6*z']", "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('(a + b) * (a - b) + 3 * a * b', ['a', 'b'], [2, 1]) == ['7']", "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('a * b * c - c * b * a + x', ['a', 'b', 'c', 'x'], [1, 2, 3, 4]) == ['4']"]}
{"task_num": 777, "task_title": "Swap Adjacent in LR String", "func_name": "canTransform", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def canTransform(self, start: str, end: str) -> bool:\n    if start.replace('X', '') != end.replace('X', ''):\n      return False\n\n    i = 0\n    j = 0\n\n    while i < len(start) and j < len(end):\n      while i < len(start) and start[i] == 'X':\n        i += 1\n      while j < len(end) and end[j] == 'X':\n        j += 1\n      if i == len(start) and j == len(end):\n        return True\n      if i == len(start) or j == len(end):\n        return False\n      if start[i] == 'L' and i < j:\n        return False\n      if start[i] == 'R' and i > j:\n        return False\n      i += 1\n      j += 1\n\n    return True\n", "tests": ["def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('RXXLRXRXL', 'XRLXXRRLX') == True", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('XXRXL', 'XXLRX') == False", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('LXXR', 'XLXR') == False", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('XXX', 'XXX') == True", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('RLX', 'XLR') == False", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('RXR', 'RXXR') == False", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('LXR', 'XLX') == False", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('XRLXX', 'XRLXX') == True", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('RXXL', 'XXRL') == False", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('LX', 'XL') == True", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('XRLX', 'RLXX') == False", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('RXL', 'RXL') == True", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('RLXLX', 'RXLXL') == False", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('RRXLX', 'RRXLL') == False", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('XLXR', 'LXRX') == True", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('XRXL', 'XRLX') == True", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('RXRX', 'RRXX') == True", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('XXLRX', 'LXXRX') == False", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('LXXRL', 'XLXRL') == False", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('RXLXRX', 'RXLRXX') == True"]}
{"task_num": 782, "task_title": "Transform to Chessboard", "func_name": "movesToChessboard", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def movesToChessboard(self, board: List[List[int]]) -> int:\n    n = len(board)\n\n    for i in range(n):\n      for j in range(n):\n        if board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]:\n          return -1\n\n    rowSum = sum(board[0])\n    colSum = sum(board[i][0] for i in range(n))\n\n    if rowSum != n // 2 and rowSum != (n + 1) // 2:\n      return -1\n    if colSum != n // 2 and colSum != (n + 1) // 2:\n      return -1\n\n    rowSwaps = sum(board[i][0] == (i & 1) for i in range(n))\n    colSwaps = sum(board[0][i] == (i & 1) for i in range(n))\n\n    if n & 1:\n      if rowSwaps & 1:\n        rowSwaps = n - rowSwaps\n      if colSwaps & 1:\n        colSwaps = n - colSwaps\n    else:\n      rowSwaps = min(rowSwaps, n - rowSwaps)\n      colSwaps = min(colSwaps, n - colSwaps)\n\n    return (rowSwaps + colSwaps) // 2\n", "tests": ["def test_movesToChessboard():\n    solution = Solution()\n    result = solution.movesToChessboard([[0, 1, 1, 0], [1, 0, 0, 1], [1, 0, 0, 1], [0, 1, 1, 0]])", "def test_movesToChessboard():\n    solution = Solution()\n    result = solution.movesToChessboard([[1, 0], [1, 0]])", "def test_movesToChessboard():\n    solution = Solution()\n    result = solution.movesToChessboard([[0, 1], [1, 0]])", "def test_movesToChessboard():\n    solution = Solution()\n    result = solution.movesToChessboard([[1, 0, 1], [0, 1, 0], [1, 0, 1]])", "def test_movesToChessboard():\n    solution = Solution()\n    result = solution.movesToChessboard([[1, 1, 0], [0, 0, 1], [1, 1, 0]])", "def test_movesToChessboard():\n    solution = Solution()\n    result = solution.movesToChessboard([[0, 1, 0], [1, 0, 1], [0, 1, 0]])", "def test_movesToChessboard():\n    solution = Solution()\n    result = solution.movesToChessboard([[1, 0, 0, 1], [0, 1, 1, 0], [1, 0, 0, 1], [0, 1, 1, 0]])", "def test_movesToChessboard():\n    solution = Solution()\n    result = solution.movesToChessboard([[1, 1], [0, 0]])", "def test_movesToChessboard():\n    solution = Solution()\n    result = solution.movesToChessboard([[0, 0, 1, 1], [1, 1, 0, 0], [0, 0, 1, 1], [1, 1, 0, 0]])", "def test_movesToChessboard():\n    solution = Solution()\n    result = solution.movesToChessboard([[0, 1, 1], [1, 0, 0], [0, 1, 1]])", "def test_movesToChessboard():\n    solution = Solution()\n    result = solution.movesToChessboard([[1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1]])", "def test_movesToChessboard():\n    solution = Solution()\n    result = solution.movesToChessboard([[1, 0, 1, 1], [0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1]])", "def test_movesToChessboard():\n    solution = Solution()\n    result = solution.movesToChessboard([[1, 1, 0], [0, 1, 1], [1, 0, 0]])", "def test_movesToChessboard():\n    solution = Solution()\n    result = solution.movesToChessboard([[0, 1], [1, 1]])", "def test_movesToChessboard():\n    solution = Solution()\n    result = solution.movesToChessboard([[1, 0, 0, 1], [0, 1, 1, 0], [0, 1, 1, 0], [1, 0, 0, 1]])", "def test_movesToChessboard():\n    solution = Solution()\n    result = solution.movesToChessboard([[0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0]])", "def test_movesToChessboard():\n    solution = Solution()\n    result = solution.movesToChessboard([[1, 0, 1, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 1, 0, 1]])", "def test_movesToChessboard():\n    solution = Solution()\n    result = solution.movesToChessboard([[0, 1], [0, 1]])", "def test_movesToChessboard():\n    solution = Solution()\n    result = solution.movesToChessboard([[1]])", "def test_movesToChessboard():\n    solution = Solution()\n    result = solution.movesToChessboard([[0]])"]}
{"task_num": 786, "task_title": "K-th Smallest Prime Fraction", "func_name": "kthSmallestPrimeFraction", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\n    n = len(arr)\n    ans = [0, 1]\n    l = 0\n    r = 1\n\n    while True:\n      m = (l + r) / 2\n      ans[0] = 0\n      count = 0\n      j = 1\n\n      for i in range(n):\n        while j < n and arr[i] > m * arr[j]:\n          j += 1\n        count += n - j\n        if j == n:\n          break\n        if ans[0] * arr[j] < ans[1] * arr[i]:\n          ans[0] = arr[i]\n          ans[1] = arr[j]\n\n      if count < k:\n        l = m\n      elif count > k:\n        r = m\n      else:\n        return ans\n", "tests": ["def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    result = solution.kthSmallestPrimeFraction([1, 2, 3, 5], 3)", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    result = solution.kthSmallestPrimeFraction([1, 2, 3, 7, 11], 4)", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    result = solution.kthSmallestPrimeFraction([1, 3, 5, 7, 13, 19], 8)", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    result = solution.kthSmallestPrimeFraction([1, 5, 11, 17, 23], 6)", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    result = solution.kthSmallestPrimeFraction([1, 2, 7, 13, 19, 31], 10)", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    result = solution.kthSmallestPrimeFraction([1, 4, 9, 16, 25], 9)", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    result = solution.kthSmallestPrimeFraction([1, 6, 13, 17, 23, 29], 11)", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    result = solution.kthSmallestPrimeFraction([1, 7, 11, 19, 23, 29, 37], 15)", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    result = solution.kthSmallestPrimeFraction([1, 2, 5, 11, 17, 23], 7)", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    result = solution.kthSmallestPrimeFraction([1, 3, 5, 8, 13, 21, 34], 10)", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    result = solution.kthSmallestPrimeFraction([1, 2, 7, 11, 17, 19, 23], 12)", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    result = solution.kthSmallestPrimeFraction([1, 3, 6, 9, 15, 27], 8)", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    result = solution.kthSmallestPrimeFraction([1, 2, 4, 6, 10, 14, 22], 9)", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    result = solution.kthSmallestPrimeFraction([1, 5, 10, 15, 20, 25, 30], 13)", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    result = solution.kthSmallestPrimeFraction([1, 2, 3, 11, 17, 19, 23, 31], 20)", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    result = solution.kthSmallestPrimeFraction([1, 3, 7, 9, 11, 13, 17, 19], 16)", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    result = solution.kthSmallestPrimeFraction([1, 2, 5, 7, 11, 13, 17, 29], 18)", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    result = solution.kthSmallestPrimeFraction([1, 4, 6, 8, 12, 16, 24, 32], 22)", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    result = solution.kthSmallestPrimeFraction([1, 2, 3, 5, 7, 11, 13, 17, 19], 25)", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    result = solution.kthSmallestPrimeFraction([1, 3, 5, 7, 11, 13, 17, 23, 29], 30)"]}
{"task_num": 787, "task_title": "Cheapest Flights Within K Stops", "func_name": "findCheapestPrice", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in flights:\n      graph[u].append((v, w))\n\n    return self._dijkstra(graph, src, dst, k)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, k: int) -> int:\n    dist=[]\n    for i in range(len(graph)):\n      dist.append([math.inf for _ in range(k + 2)])\n\n    dist[src][k + 1] = 0\n    minHeap = [(dist[src][k + 1], src, k + 1)]\n\n    while minHeap:\n      d, u, stops = heapq.heappop(minHeap)\n      if u == dst:\n        return d\n      if stops == 0 or d > dist[u][stops]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v][stops - 1]:\n          dist[v][stops - 1] = d + w\n          heapq.heappush(minHeap, (dist[v][stops - 1], v, stops - 1))\n\n    return -1\n", "tests": ["def test_findCheapestPrice():\n    solution = Solution()\n    n = 3\n    flights = [[0, 1, 100], [1, 2, 100], [0, 2, 500]]\n    src = 0\n    dst = 2\n    k = 1\n    assert solution.findCheapestPrice(n, flights, src, dst, k) == 200", "def test_findCheapestPrice():\n    solution = Solution()\n    n = 4\n    flights = [[0, 1, 100], [1, 2, 100], [2, 3, 100]]\n    src = 0\n    dst = 3\n    k = 0\n    assert solution.findCheapestPrice(n, flights, src, dst, k) == -1", "def test_findCheapestPrice():\n    solution = Solution()\n    n = 3\n    flights = [[0, 1, 100], [1, 2, 100], [0, 2, 300]]\n    src = 0\n    dst = 2\n    k = 0\n    assert solution.findCheapestPrice(n, flights, src, dst, k) == 300", "def test_findCheapestPrice():\n    solution = Solution()\n    n = 5\n    flights = [[0, 1, 100], [1, 2, 100], [0, 2, 500], [1, 3, 200], [3, 4, 100], [2, 4, 50]]\n    src = 0\n    dst = 4\n    k = 2\n    assert solution.findCheapestPrice(n, flights, src, dst, k) == 350", "def test_findCheapestPrice():\n    solution = Solution()\n    n = 4\n    flights = [[0, 1, 100], [0, 2, 400], [1, 3, 200], [2, 3, 50]]\n    src = 0\n    dst = 3\n    k = 0\n    assert solution.findCheapestPrice(n, flights, src, dst, k) == -1", "def test_findCheapestPrice():\n    solution = Solution()\n    n = 6\n    flights = [[0, 1, 50], [1, 2, 50], [2, 3, 50], [3, 4, 50], [4, 5, 50], [0, 5, 500]]\n    src = 0\n    dst = 5\n    k = 3\n    assert solution.findCheapestPrice(n, flights, src, dst, k) == 250", "def test_findCheapestPrice():\n    solution = Solution()\n    n = 3\n    flights = [[0, 1, 100], [1, 2, 100], [2, 0, 50], [1, 0, 200], [0, 2, 250]]\n    src = 0\n    dst = 2\n    k = 2\n    assert solution.findCheapestPrice(n, flights, src, dst, k) == 200", "def test_findCheapestPrice():\n    solution = Solution()\n    n = 4\n    flights = [[0, 1, 100], [1, 2, 100], [2, 3, 100], [0, 3, 500]]\n    src = 0\n    dst = 3\n    k = 5\n    assert solution.findCheapestPrice(n, flights, src, dst, k) == 300", "def test_findCheapestPrice():\n    solution = Solution()\n    n = 3\n    flights = []\n    src = 0\n    dst = 2\n    k = 1\n    assert solution.findCheapestPrice(n, flights, src, dst, k) == -1", "def test_findCheapestPrice():\n    solution = Solution()\n    n = 4\n    flights = [[0, 1, 100], [1, 3, 300], [0, 2, 200], [2, 3, 100]]\n    src = 0\n    dst = 3\n    k = 1\n    assert solution.findCheapestPrice(n, flights, src, dst, k) == 400", "def test_findCheapestPrice():\n    solution = Solution()\n    n = 3\n    flights = [[0, 1, 150], [1, 2, 150], [0, 2, 200]]\n    src = 0\n    dst = 2\n    k = 1\n    assert solution.findCheapestPrice(n, flights, src, dst, k) == 200", "def test_findCheapestPrice():\n    solution = Solution()\n    n = 5\n    flights = [[0, 1, 100], [1, 4, 100], [0, 2, 100], [2, 4, 100], [0, 3, 100], [3, 4, 100]]\n    src = 0\n    dst = 4\n    k = 2\n    assert solution.findCheapestPrice(n, flights, src, dst, k) == 200", "def test_findCheapestPrice():\n    solution = Solution()\n    n = 4\n    flights = [[0, 1, 200], [1, 2, 200], [2, 3, 200]]\n    src = 0\n    dst = 3\n    k = 1\n    assert solution.findCheapestPrice(n, flights, src, dst, k) == -1", "def test_findCheapestPrice():\n    solution = Solution()\n    n = 4\n    flights = [[0, 1, 50], [0, 2, 100], [1, 2, 50], [2, 3, 50], [1, 3, 150]]\n    src = 0\n    dst = 3\n    k = 2\n    assert solution.findCheapestPrice(n, flights, src, dst, k) == 150", "def test_findCheapestPrice():\n    solution = Solution()\n    n = 5\n    flights = [[0, 1, 100], [1, 2, 100], [2, 3, 100], [3, 4, 100], [0, 4, 400]]\n    src = 0\n    dst = 4\n    k = 3\n    assert solution.findCheapestPrice(n, flights, src, dst, k) == 400", "def test_findCheapestPrice():\n    solution = Solution()\n    n = 6\n    flights = [[0, 1, 100], [1, 2, 100], [2, 3, 100], [3, 4, 100], [4, 5, 100], [0, 5, 600]]\n    src = 0\n    dst = 5\n    k = 4\n    assert solution.findCheapestPrice(n, flights, src, dst, k) == 500", "def test_findCheapestPrice():\n    solution = Solution()\n    n = 4\n    flights = [[0, 1, 300], [1, 2, 100], [2, 3, 100], [0, 3, 500]]\n    src = 0\n    dst = 3\n    k = 2\n    assert solution.findCheapestPrice(n, flights, src, dst, k) == 500", "def test_findCheapestPrice():\n    solution = Solution()\n    n = 5\n    flights = [[0, 1, 200], [1, 2, 200], [2, 3, 200], [3, 4, 200]]\n    src = 0\n    dst = 4\n    k = 2\n    assert solution.findCheapestPrice(n, flights, src, dst, k) == -1", "def test_findCheapestPrice():\n    solution = Solution()\n    n = 3\n    flights = [[0, 1, 0], [1, 2, 0], [0, 2, 100]]\n    src = 0\n    dst = 2\n    k = 1\n    assert solution.findCheapestPrice(n, flights, src, dst, k) == 0", "def test_findCheapestPrice():\n    solution = Solution()\n    n = 5\n    flights = [[0, 1, 50], [1, 2, 50], [2, 3, 50], [3, 4, 50], [0, 4, 300]]\n    src = 0\n    dst = 4\n    k = 4\n    assert solution.findCheapestPrice(n, flights, src, dst, k) == 200"]}
{"task_num": 794, "task_title": "Valid Tic-Tac-Toe State", "func_name": "validTicTacToe", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def validTicTacToe(self, board: List[str]) -> bool:\n    def isWin(c: str) -> bool:\n      return any(row.count(c) == 3 for row in board) or any(row.count(c) == 3 for row in list(zip(*board))) or all(board[i][i] == c for i in range(3)) or all(board[i][2 - i] == c for i in range(3))\n\n    countX = sum(row.count('X') for row in board)\n    countO = sum(row.count('O') for row in board)\n\n    if countX < countO or countX - countO > 1:\n      return False\n    if isWin('X') and countX == countO or isWin('O') and countX != countO:\n      return False\n\n    return True\n", "tests": ["def test_validTicTacToe():\n    solution = Solution()\n    assert solution.validTicTacToe(['XOX', 'O O', 'XOX']) == False", "def test_validTicTacToe():\n    solution = Solution()\n    assert solution.validTicTacToe(['XXX', '   ', 'OOO']) == False", "def test_validTicTacToe():\n    solution = Solution()\n    assert solution.validTicTacToe(['XOX', 'OXO', 'OXO']) == True", "def test_validTicTacToe():\n    solution = Solution()\n    assert solution.validTicTacToe(['XOX', 'OX ', '   ']) == True", "def test_validTicTacToe():\n    solution = Solution()\n    assert solution.validTicTacToe(['XO ', 'XO ', 'X  ']) == False", "def test_validTicTacToe():\n    solution = Solution()\n    assert solution.validTicTacToe(['   ', '   ', '   ']) == True", "def test_validTicTacToe():\n    solution = Solution()\n    assert solution.validTicTacToe(['OXX', 'XOX', 'OXO']) == False", "def test_validTicTacToe():\n    solution = Solution()\n    assert solution.validTicTacToe(['XXO', 'OXO', 'X  ']) == True", "def test_validTicTacToe():\n    solution = Solution()\n    assert solution.validTicTacToe(['O  ', 'X  ', '   ']) == False", "def test_validTicTacToe():\n    solution = Solution()\n    assert solution.validTicTacToe(['XOX', 'OX ', ' X ']) == True", "def test_validTicTacToe():\n    solution = Solution()\n    assert solution.validTicTacToe(['XO ', ' XO', 'O X']) == False", "def test_validTicTacToe():\n    solution = Solution()\n    assert solution.validTicTacToe(['OXO', 'XOX', 'OX ']) == True", "def test_validTicTacToe():\n    solution = Solution()\n    assert solution.validTicTacToe(['XXO', 'OOX', 'XOX']) == True", "def test_validTicTacToe():\n    solution = Solution()\n    assert solution.validTicTacToe(['X X', 'OO ', '   ']) == False", "def test_validTicTacToe():\n    solution = Solution()\n    assert solution.validTicTacToe([' XO', ' XO', 'X  ']) == False", "def test_validTicTacToe():\n    solution = Solution()\n    assert solution.validTicTacToe(['OXX', 'XOX', 'OX ']) == True", "def test_validTicTacToe():\n    solution = Solution()\n    assert solution.validTicTacToe(['XX ', 'OOX', 'O  ']) == False", "def test_validTicTacToe():\n    solution = Solution()\n    assert solution.validTicTacToe(['XOX', 'XOX', 'OXO']) == True", "def test_validTicTacToe():\n    solution = Solution()\n    assert solution.validTicTacToe(['X  ', 'XOX', 'O O']) == False", "def test_validTicTacToe():\n    solution = Solution()\n    assert solution.validTicTacToe([' XO', 'O  ', 'X  ']) == True"]}
{"task_num": 805, "task_title": "Split Array With Same Average", "func_name": "splitArraySameAverage", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def splitArraySameAverage(self, nums: List[int]) -> bool:\n    n = len(nums)\n    summ = sum(nums)\n    if not any(i * summ % n == 0 for i in range(1, n // 2 + 1)):\n      return False\n\n    sums = [set() for _ in range(n // 2 + 1)]\n    sums[0].add(0)\n\n    for num in nums:\n      for i in range(n // 2, 0, -1):\n        for val in sums[i - 1]:\n          sums[i].add(num + val)\n\n    for i in range(1, n // 2 + 1):\n      if i * summ % n == 0 and i * summ // n in sums[i]:\n        return True\n\n    return False\n", "tests": ["def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([1, 2, 3, 4, 5, 6, 7, 8]) == True", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([1, 5, 7, 11, 13]) == False", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([3, 1]) == False", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([6, 2, 3, 4, 9, 5]) == True", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([5, 3, 11, 19, 2, 1]) == False", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([10, 29, 10, 29, 3]) == False", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([0, 0, 1, 1, 1, 1, 1, 1, 1, 1]) == True", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([2, 4, 6, 8, 10, 12, 14]) == True", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([20, 1, 15, 9]) == False", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([5, 5, 5, 5, 5, 5, 5, 5, 5, 5]) == True", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([7, 3, 8, 3, 2, 5]) == False", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([1, 2, 5, 10, 20, 25]) == True", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([4, 4, 4, 4, 4, 20, 20, 20]) == True", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([1, 12, 3, 7, 9, 15]) == False", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([8, 1, 6, 3, 5, 7, 2, 4]) == True", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([7, 14, 28, 35, 42, 21]) == False", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([9, 17, 23, 1, 5]) == False", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([3, 6, 9, 12, 15, 18, 21]) == True", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([2, 5, 11, 13, 17, 19]) == False", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([1, 1, 2, 2, 3, 3, 4, 4]) == True"]}
{"task_num": 815, "task_title": "Bus Routes", "func_name": "numBusesToDestination", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:\n    if source == target:\n      return 0\n\n    graph = collections.defaultdict(list)\n    usedBuses = set()\n\n    for i in range(len(routes)):\n      for route in routes[i]:\n        graph[route].append(i)\n\n    ans = 0\n    q = collections.deque([source])\n\n    while q:\n      ans += 1\n      for _ in range(len(q)):\n        for bus in graph[q.popleft()]:\n          if bus in usedBuses:\n            continue\n          usedBuses.add(bus)\n          for nextRoute in routes[bus]:\n            if nextRoute == target:\n              return ans\n            q.append(nextRoute)\n\n    return -1\n", "tests": ["def test_numBusesToDestination():\n    solution = Solution()\n    assert solution.numBusesToDestination([[1, 2, 7], [3, 6, 7]], 1, 6) == 2", "def test_numBusesToDestination():\n    solution = Solution()\n    assert solution.numBusesToDestination([[7, 12], [4, 5, 15], [6], [15, 19], [9, 12, 13]], 15, 12) == -1", "def test_numBusesToDestination():\n    solution = Solution()\n    assert solution.numBusesToDestination([[2, 5, 8], [6, 10], [8, 11, 15], [1, 5, 10]], 2, 11) == 2", "def test_numBusesToDestination():\n    solution = Solution()\n    assert solution.numBusesToDestination([[2, 3, 4], [5, 6, 7]], 3, 3) == 0", "def test_numBusesToDestination():\n    solution = Solution()\n    assert solution.numBusesToDestination([[1, 2, 3], [4, 5, 6]], 3, 5) == -1", "def test_numBusesToDestination():\n    solution = Solution()\n    assert solution.numBusesToDestination([[1, 2, 7], [3, 6, 7], [7, 8, 9], [9, 10, 11]], 1, 11) == 3", "def test_numBusesToDestination():\n    solution = Solution()\n    assert solution.numBusesToDestination([[5, 10, 15]], 5, 15) == 1", "def test_numBusesToDestination():\n    solution = Solution()\n    assert solution.numBusesToDestination([[1, 2], [3, 4], [5, 6]], 1, 6) == -1", "def test_numBusesToDestination():\n    solution = Solution()\n    assert solution.numBusesToDestination([[1, 2, 3], [3, 4, 5], [5, 6, 7]], 1, 7) == 3", "def test_numBusesToDestination():\n    solution = Solution()\n    assert solution.numBusesToDestination([[10, 20, 30], [30, 40, 50], [50, 60, 70], [70, 80, 90]], 10, 90) == 4", "def test_numBusesToDestination():\n    solution = Solution()\n    assert solution.numBusesToDestination([[1, 3, 5, 7, 9, 11]], 1, 11) == 1", "def test_numBusesToDestination():\n    solution = Solution()\n    assert solution.numBusesToDestination([[1, 2, 3, 4], [3, 5, 7], [7, 8, 9], [9, 10]], 2, 10) == 3", "def test_numBusesToDestination():\n    solution = Solution()\n    assert solution.numBusesToDestination([[2, 4, 6], [1, 3, 5], [6, 7, 8]], 4, 6) == 1", "def test_numBusesToDestination():\n    solution = Solution()\n    assert solution.numBusesToDestination([[1, 2], [2, 3], [3, 4], [4, 5]], 1, 5) == 4", "def test_numBusesToDestination():\n    solution = Solution()\n    assert solution.numBusesToDestination([[1, 2, 3, 4, 5], [2, 3, 6, 7], [6, 8, 9, 10]], 1, 10) == 3", "def test_numBusesToDestination():\n    solution = Solution()\n    assert solution.numBusesToDestination([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 1, 9) == -1", "def test_numBusesToDestination():\n    solution = Solution()\n    assert solution.numBusesToDestination([[2, 10], [2, 3, 4], [4, 5, 6], [7, 8, 9, 10]], 2, 10) == 1", "def test_numBusesToDestination():\n    solution = Solution()\n    assert solution.numBusesToDestination([[1, 3, 5], [5, 9], [9, 11, 13], [13, 15, 17]], 1, 17) == 4", "def test_numBusesToDestination():\n    solution = Solution()\n    assert solution.numBusesToDestination([[1, 2, 3, 4, 1], [4, 5, 6]], 1, 6) == 2", "def test_numBusesToDestination():\n    solution = Solution()\n    assert solution.numBusesToDestination([[1, 2, 3], [3, 4, 5], [5, 6, 7]], 1, 7) == 3"]}
{"task_num": 838, "task_title": "Push Dominoes", "func_name": "pushDominoes", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def pushDominoes(self, dominoes: str) -> str:\n    ans = list(dominoes)\n    L = -1\n    R = -1\n\n    for i in range(len(dominoes) + 1):\n      if i == len(dominoes) or dominoes[i] == 'R':\n        if L < R:\n          while R < i:\n            ans[R] = 'R'\n            R += 1\n        R = i\n      elif dominoes[i] == 'L':\n        if R < L or (L, R) == (-1, -1):\n          if (L, R) == (-1, -1):\n            L += 1\n          while L < i:\n            ans[L] = 'L'\n            L += 1\n        else:\n          l = R + 1\n          r = i - 1\n          while l < r:\n            ans[l] = 'R'\n            ans[r] = 'L'\n            l += 1\n            r -= 1\n        L = i\n\n    return ''.join(ans)\n", "tests": ["def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('.L.R...LR..L..') == 'LL.RR.LLRRLL..'", "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('R...L') == 'RR.LL'", "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('...R..L.R.') == '...RR.LL.RR'", "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('R.....R..L...L') == 'RRRRRRRLLL.LLL'", "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('L....R....') == 'L....R....'", "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('..R..L...R') == '..RR.LL..R'", "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('R......') == 'RRRRRRR'", "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('.....') == '.....'", "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('R.L.R.L.') == 'R.L.R.L.'", "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('..L.R...R..L') == 'LLL.RRRRRLLL'", "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('R.L') == 'R.L'", "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('RR.L...L.R') == 'RR.LLL.LLR'", "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('R......L....R.L') == 'RRRR.LLLLL..R.L'", "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('R...L...R') == 'RR.LL..RR'", "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('RL') == 'RL'", "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('R.L...R.L...') == 'R.L...R.L...'", "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('.L.R...L.R.') == 'LL.RR.LL.RR'", "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('R....L....') == 'RRRR.LLLLL'", "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('L...R....') == 'L...R....'", "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('R..L...R..L.R') == 'RR.LLL.RR.L.R'"]}
{"task_num": 845, "task_title": "Longest Mountain in Array", "func_name": "longestMountain", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def longestMountain(self, arr: List[int]) -> int:\n    ans = 0\n    i = 0\n\n    while i + 1 < len(arr):\n      while i + 1 < len(arr) and arr[i] == arr[i + 1]:\n        i += 1\n\n      increasing = 0\n      decreasing = 0\n\n      while i + 1 < len(arr) and arr[i] < arr[i + 1]:\n        increasing += 1\n        i += 1\n\n      while i + 1 < len(arr) and arr[i] > arr[i + 1]:\n        decreasing += 1\n        i += 1\n\n      if increasing > 0 and decreasing > 0:\n        ans = max(ans, increasing + decreasing + 1)\n\n    return ans\n", "tests": ["def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([2, 1, 4, 7, 3, 2, 5]) == 5", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([2, 2, 2, 2, 2]) == 0", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([0, 2, 2, 3, 4, 3, 0, 2, 1, 0]) == 5", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 0", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([1, 3, 2, 1, 2, 3, 4, 3, 2, 1]) == 5", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([5, 4, 3, 2, 1, 2, 3, 4, 5, 3, 1]) == 7", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([1, 2, 3, 2, 4, 5, 6, 1, 0]) == 4", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([2, 1, 4, 3, 2, 3, 4, 3, 5, 6, 5, 4]) == 5", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([1, 2, 1, 2, 3, 4, 5, 3, 1]) == 7", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([1, 4, 7, 3, 2, 4, 6, 3, 2, 1, 0]) == 5", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([2, 1, 2, 3, 4, 3, 2, 1, 2, 3]) == 6", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([9, 8, 7, 6, 5, 6, 7, 8, 7, 6, 5]) == 5", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([1, 2, 3, 4, 3, 2, 1, 2, 2, 3, 4, 5]) == 7", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([0, 1, 0, 1, 0, 2, 3, 4, 2, 1, 0, 1]) == 5", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([1, 3, 2, 1, 4, 5, 4, 3, 2]) == 5", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([1, 5, 3, 2, 1, 0, 4, 5, 6, 5, 4]) == 6", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([5, 6, 7, 8, 7, 6, 5, 4, 3, 4, 5, 6, 7, 8]) == 6", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([3, 2, 1, 0, 1, 2, 3, 4, 2, 1]) == 5", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([1, 2, 1, 2, 1, 2, 3, 2, 1]) == 5", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([1, 2, 3, 1, 0, 2, 3, 4, 3, 1]) == 5"]}
{"task_num": 854, "task_title": "K-Similar Strings", "func_name": "kSimilarity", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def kSimilarity(self, s1: str, s2: str) -> int:\n    ans = 0\n    q = collections.deque([s1])\n    seen = {s1}\n\n    while q:\n      for _ in range(len(q)):\n        curr = q.popleft()\n        if curr == s2:\n          return ans\n        for child in self._getChildren(curr, s2):\n          if child in seen:\n            continue\n          q.append(child)\n          seen.add(child)\n      ans += 1\n\n    return -1\n\n  def _getChildren(self, curr: str, target: str) -> List[str]:\n    children = []\n    s = list(curr)\n    i = 0\n    while curr[i] == target[i]:\n      i += 1\n\n    for j in range(i + 1, len(s)):\n      if s[j] == target[i]:\n        s[i], s[j] = s[j], s[i]\n        children.append(''.join(s))\n        s[i], s[j] = s[j], s[i]\n\n    return children\n", "tests": ["def test_kSimilarity():\n    solution = Solution()\n    assert solution.kSimilarity('ab', 'ba') == 1", "def test_kSimilarity():\n    solution = Solution()\n    assert solution.kSimilarity('abc', 'bca') == 2", "def test_kSimilarity():\n    solution = Solution()\n    assert solution.kSimilarity('aabbccddee', 'abcdeabcde') == 5", "def test_kSimilarity():\n    solution = Solution()\n    assert solution.kSimilarity('abcdef', 'abcfed') == 1", "def test_kSimilarity():\n    solution = Solution()\n    assert solution.kSimilarity('abab', 'baba') == 2", "def test_kSimilarity():\n    solution = Solution()\n    assert solution.kSimilarity('aaa', 'aaa') == 0", "def test_kSimilarity():\n    solution = Solution()\n    assert solution.kSimilarity('abcde', 'edcba') == 4", "def test_kSimilarity():\n    solution = Solution()\n    assert solution.kSimilarity('ababab', 'bababa') == 3", "def test_kSimilarity():\n    solution = Solution()\n    assert solution.kSimilarity('abcd', 'dacb') == 2", "def test_kSimilarity():\n    solution = Solution()\n    assert solution.kSimilarity('aabb', 'bbaa') == 2", "def test_kSimilarity():\n    solution = Solution()\n    assert solution.kSimilarity('abcdefg', 'gfedcba') == 3", "def test_kSimilarity():\n    solution = Solution()\n    assert solution.kSimilarity('abcabc', 'cbacba') == 2", "def test_kSimilarity():\n    solution = Solution()\n    assert solution.kSimilarity('abcdabc', 'dcbaabc') == 3", "def test_kSimilarity():\n    solution = Solution()\n    assert solution.kSimilarity('abcdefgh', 'hgfedcba') == 4", "def test_kSimilarity():\n    solution = Solution()\n    assert solution.kSimilarity('acbd', 'dbac') == 3", "def test_kSimilarity():\n    solution = Solution()\n    assert solution.kSimilarity('xyzabc', 'abcxyz') == 3", "def test_kSimilarity():\n    solution = Solution()\n    assert solution.kSimilarity('mnopqr', 'rqponm') == 3", "def test_kSimilarity():\n    solution = Solution()\n    assert solution.kSimilarity('abbc', 'babc') == 1", "def test_kSimilarity():\n    solution = Solution()\n    assert solution.kSimilarity('aaaabbbb', 'bbbbaaaa') == 4", "def test_kSimilarity():\n    solution = Solution()\n    assert solution.kSimilarity('aabbcc', 'ccbbaa') == 3"]}
{"task_num": 861, "task_title": "Score After Flipping Matrix", "func_name": "matrixScore", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def matrixScore(self, grid: List[List[int]]) -> int:\n    for row in grid:\n      if row[0] == 0:\n        self._flip(row)\n\n    for j, col in enumerate(list(zip(*grid))):\n      if sum(col) * 2 < len(grid):\n        self._flipCol(grid, j)\n\n    return sum(self._binary(row) for row in grid)\n\n  def _flip(self, row: List[int]) -> None:\n    for i in range(len(row)):\n      row[i] ^= 1\n\n  def _flipCol(self, grid: List[List[int]], j: int) -> None:\n    for i in range(len(grid)):\n      grid[i][j] ^= 1\n\n  def _binary(self, row: List[int]) -> int:\n    res = row[0]\n    for j in range(1, len(row)):\n      res = res * 2 + row[j]\n    return res\n", "tests": ["def test_matrixScore():\n    solution = Solution()\n    grid = [[0, 0, 1, 1], [1, 0, 1, 0], [1, 1, 0, 0]]\n    assert solution.matrixScore(grid) == 39", "def test_matrixScore():\n    solution = Solution()\n    grid = [[1, 1], [0, 0], [1, 0]]\n    assert solution.matrixScore(grid) == 10", "def test_matrixScore():\n    solution = Solution()\n    grid = [[0, 1, 1], [0, 0, 0], [1, 0, 1]]\n    assert solution.matrixScore(grid) == 14", "def test_matrixScore():\n    solution = Solution()\n    grid = [[1, 0, 0, 1], [0, 1, 1, 0], [1, 1, 0, 0]]\n    assert solution.matrixScore(grid) == 28", "def test_matrixScore():\n    solution = Solution()\n    grid = [[1, 0], [0, 1], [1, 1]]\n    assert solution.matrixScore(grid) == 7", "def test_matrixScore():\n    solution = Solution()\n    grid = [[0], [1], [0]]\n    assert solution.matrixScore(grid) == 3", "def test_matrixScore():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 1, 0], [1, 0, 1]]\n    assert solution.matrixScore(grid) == 15", "def test_matrixScore():\n    solution = Solution()\n    grid = [[1, 1, 1, 1], [1, 0, 0, 1], [0, 1, 1, 0]]\n    assert solution.matrixScore(grid) == 30", "def test_matrixScore():\n    solution = Solution()\n    grid = [[1, 0, 1], [0, 1, 0], [0, 0, 1]]\n    assert solution.matrixScore(grid) == 19", "def test_matrixScore():\n    solution = Solution()\n    grid = [[0, 1, 0, 1], [1, 0, 1, 0], [0, 0, 0, 0]]\n    assert solution.matrixScore(grid) == 23", "def test_matrixScore():\n    solution = Solution()\n    grid = [[1, 0, 1, 1], [1, 1, 0, 1], [0, 1, 0, 0]]\n    assert solution.matrixScore(grid) == 31", "def test_matrixScore():\n    solution = Solution()\n    grid = [[0, 0], [1, 1], [0, 1]]\n    assert solution.matrixScore(grid) == 10", "def test_matrixScore():\n    solution = Solution()\n    grid = [[1, 1, 0], [0, 1, 1], [1, 0, 0]]\n    assert solution.matrixScore(grid) == 21", "def test_matrixScore():\n    solution = Solution()\n    grid = [[1, 0, 0, 0], [0, 1, 1, 1], [1, 1, 1, 0]]\n    assert solution.matrixScore(grid) == 25", "def test_matrixScore():\n    solution = Solution()\n    grid = [[0, 1, 1, 0], [1, 0, 0, 1], [1, 1, 1, 1]]\n    assert solution.matrixScore(grid) == 29", "def test_matrixScore():\n    solution = Solution()\n    grid = [[1], [0], [1]]\n    assert solution.matrixScore(grid) == 5", "def test_matrixScore():\n    solution = Solution()\n    grid = [[0, 0, 1, 0], [1, 1, 0, 1], [1, 0, 0, 0]]\n    assert solution.matrixScore(grid) == 26", "def test_matrixScore():\n    solution = Solution()\n    grid = [[1, 0], [0, 0], [0, 1]]\n    assert solution.matrixScore(grid) == 9", "def test_matrixScore():\n    solution = Solution()\n    grid = [[0, 1, 0], [1, 1, 1], [0, 0, 1]]\n    assert solution.matrixScore(grid) == 18", "def test_matrixScore():\n    solution = Solution()\n    grid = [[0, 1, 0, 1], [1, 0, 1, 1], [1, 1, 0, 0]]\n    assert solution.matrixScore(grid) == 27"]}
{"task_num": 866, "task_title": "Prime Palindrome", "func_name": "primePalindrome", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def primePalindrome(self, n: int) -> int:\n    def getPalindromes(n: int):\n      length = n // 2\n      for i in range(10**(length - 1), 10**length):\n        s = str(i)\n        for j in range(10):\n          yield int(s + str(j) + s[::-1])\n\n    def isPrime(num: int) -> bool:\n      for i in range(2, int(num**0.5 + 1)):\n        if num % i == 0:\n          return False\n      return True\n\n    if n <= 2:\n      return 2\n    if n == 3:\n      return 3\n    if n <= 5:\n      return 5\n    if n <= 7:\n      return 7\n    if n <= 11:\n      return 11\n\n    nLength = len(str(n))\n\n    while True:\n      for num in getPalindromes(nLength):\n        if num >= n and isPrime(num):\n          return num\n      nLength += 1\n", "tests": ["def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(13) == 101", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(8) == 11", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(31) == 101", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(1000) == 10301", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(1) == 2", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(101) == 101", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(14) == 101", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(200) == 313", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(300) == 313", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(500) == 727", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(6) == 7", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(10000) == 10301", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(20) == 101", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(4) == 5", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(10) == 11", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(30) == 101", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(11) == 11", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(1000000) == 1003001", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(133) == 151", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(12) == 101"]}
{"task_num": 882, "task_title": "Reachable Nodes In Subdivided Graph", "func_name": "reachableNodes", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def reachableNodes(self, edges: List[List[int]], maxMoves: int, n: int) -> int:\n    graph = [[] for _ in range(n)]\n    dist = [maxMoves + 1] * n\n\n    for u, v, cnt in edges:\n      graph[u].append((v, cnt))\n      graph[v].append((u, cnt))\n\n    reachableNodes = self._dijkstra(graph, 0, maxMoves, dist)\n    reachableSubnodes = 0\n\n    for u, v, cnt in edges:\n      a = 0 if dist[u] > maxMoves else min(maxMoves - dist[u], cnt)\n      b = 0 if dist[v] > maxMoves else min(maxMoves - dist[v], cnt)\n      reachableSubnodes += min(a + b, cnt)\n\n    return reachableNodes + reachableSubnodes\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, maxMoves: int, dist: List[int]) -> int:\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if dist[u] >= maxMoves:\n        break\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        newDist = d + w + 1\n        if newDist < dist[v]:\n          dist[v] = newDist\n          heapq.heappush(minHeap, (newDist, v))\n\n    return sum(d <= maxMoves for d in dist)\n", "tests": ["def test_reachableNodes():\n    solution = Solution()\n    edges = [[0, 1, 4], [0, 2, 3], [1, 2, 1]]\n    maxMoves = 4\n    n = 3\n    assert solution.reachableNodes(edges, maxMoves, n) == 7", "def test_reachableNodes():\n    solution = Solution()\n    edges = [[0, 1, 10], [0, 2, 1], [1, 2, 2], [2, 3, 7]]\n    maxMoves = 6\n    n = 4\n    assert solution.reachableNodes(edges, maxMoves, n) == 13", "def test_reachableNodes():\n    solution = Solution()\n    edges = [[1, 2, 4], [1, 3, 3], [2, 3, 1], [3, 4, 5], [0, 1, 2]]\n    maxMoves = 5\n    n = 5\n    assert solution.reachableNodes(edges, maxMoves, n) == 10", "def test_reachableNodes():\n    solution = Solution()\n    edges = [[0, 1, 2], [1, 2, 4], [1, 3, 1], [3, 4, 3], [4, 5, 2]]\n    maxMoves = 3\n    n = 6\n    assert solution.reachableNodes(edges, maxMoves, n) == 6", "def test_reachableNodes():\n    solution = Solution()\n    edges = [[0, 1, 5], [1, 2, 2], [0, 3, 3], [3, 4, 2], [4, 5, 1]]\n    maxMoves = 7\n    n = 6\n    assert solution.reachableNodes(edges, maxMoves, n) == 11", "def test_reachableNodes():\n    solution = Solution()\n    edges = [[0, 1, 1], [1, 2, 1], [2, 3, 1], [3, 4, 1], [4, 5, 1]]\n    maxMoves = 2\n    n = 6\n    assert solution.reachableNodes(edges, maxMoves, n) == 4", "def test_reachableNodes():\n    solution = Solution()\n    edges = [[0, 1, 3], [0, 2, 2], [1, 2, 4], [2, 3, 1], [1, 4, 2]]\n    maxMoves = 5\n    n = 5\n    assert solution.reachableNodes(edges, maxMoves, n) == 9", "def test_reachableNodes():\n    solution = Solution()\n    edges = [[0, 1, 2], [1, 2, 3], [0, 3, 1], [3, 4, 4], [2, 5, 1]]\n    maxMoves = 4\n    n = 6\n    assert solution.reachableNodes(edges, maxMoves, n) == 8", "def test_reachableNodes():\n    solution = Solution()\n    edges = [[0, 1, 1], [1, 2, 5], [2, 3, 2], [0, 4, 2], [4, 5, 3]]\n    maxMoves = 6\n    n = 6\n    assert solution.reachableNodes(edges, maxMoves, n) == 12", "def test_reachableNodes():\n    solution = Solution()\n    edges = [[0, 1, 1], [1, 2, 2], [2, 3, 2], [3, 4, 1], [4, 5, 5]]\n    maxMoves = 3\n    n = 6\n    assert solution.reachableNodes(edges, maxMoves, n) == 6", "def test_reachableNodes():\n    solution = Solution()\n    edges = [[0, 1, 4], [0, 2, 1], [1, 3, 1], [2, 4, 2], [3, 4, 3]]\n    maxMoves = 5\n    n = 5\n    assert solution.reachableNodes(edges, maxMoves, n) == 9", "def test_reachableNodes():\n    solution = Solution()\n    edges = [[0, 1, 2], [1, 3, 1], [1, 4, 3], [3, 4, 4], [4, 5, 2]]\n    maxMoves = 4\n    n = 6\n    assert solution.reachableNodes(edges, maxMoves, n) == 8", "def test_reachableNodes():\n    solution = Solution()\n    edges = [[0, 1, 1], [1, 2, 1], [2, 3, 1], [3, 4, 1]]\n    maxMoves = 1\n    n = 5\n    assert solution.reachableNodes(edges, maxMoves, n) == 2", "def test_reachableNodes():\n    solution = Solution()\n    edges = [[0, 1, 0], [1, 2, 0], [2, 3, 0], [3, 4, 0], [4, 5, 0]]\n    maxMoves = 10\n    n = 6\n    assert solution.reachableNodes(edges, maxMoves, n) == 6", "def test_reachableNodes():\n    solution = Solution()\n    edges = [[0, 1, 2], [0, 2, 3], [1, 3, 1], [2, 4, 4], [4, 5, 1]]\n    maxMoves = 7\n    n = 6\n    assert solution.reachableNodes(edges, maxMoves, n) == 11", "def test_reachableNodes():\n    solution = Solution()\n    edges = [[0, 1, 3], [1, 2, 2], [2, 3, 1], [3, 4, 4]]\n    maxMoves = 5\n    n = 5\n    assert solution.reachableNodes(edges, maxMoves, n) == 9", "def test_reachableNodes():\n    solution = Solution()\n    edges = [[0, 1, 2], [1, 2, 1], [2, 3, 3], [1, 4, 2], [4, 5, 1]]\n    maxMoves = 4\n    n = 6\n    assert solution.reachableNodes(edges, maxMoves, n) == 8", "def test_reachableNodes():\n    solution = Solution()\n    edges = [[0, 1, 2], [1, 2, 3], [0, 3, 1], [3, 4, 2], [4, 5, 3]]\n    maxMoves = 6\n    n = 6\n    assert solution.reachableNodes(edges, maxMoves, n) == 11", "def test_reachableNodes():\n    solution = Solution()\n    edges = [[0, 1, 5], [0, 2, 1], [1, 3, 2], [2, 4, 3], [3, 5, 4]]\n    maxMoves = 8\n    n = 6\n    assert solution.reachableNodes(edges, maxMoves, n) == 15", "def test_reachableNodes():\n    solution = Solution()\n    edges = [[0, 1, 1], [1, 2, 1], [2, 3, 1], [3, 4, 1], [4, 5, 1]]\n    maxMoves = 0\n    n = 6\n    assert solution.reachableNodes(edges, maxMoves, n) == 1"]}
{"task_num": 909, "task_title": "Snakes and Ladders", "func_name": "snakesAndLadders", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def snakesAndLadders(self, board: List[List[int]]) -> int:\n    n = len(board)\n    ans = 0\n    q = collections.deque([1])\n    seen = set()\n    A = [0] * (1 + n * n)\n\n    for i in range(n):\n      for j in range(n):\n        if n - i & 1 :\n          A[(n - 1 - i) * n + (j + 1)] = board[i][j]\n        else:\n          A[(n - 1 - i) * n + (n - j)] = board[i][j]\n\n    while q:\n      ans += 1\n      for _ in range(len(q)):\n        curr = q.popleft()\n        for next in range(curr + 1, min(curr + 6, n * n) + 1):\n          dest = A[next] if A[next] > 0 else next\n          if dest == n * n:\n            return ans\n          if dest in seen:\n            continue\n          q.append(dest)\n          seen.add(dest)\n\n    return -1\n", "tests": ["def test_snakesAndLadders():\n    solution = Solution()\n    board = [[-1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1], [-1, 35, -1, -1, 13, -1], [-1, -1, -1, -1, -1, -1], [-1, 15, -1, -1, -1, -1]]\n    assert solution.snakesAndLadders(board) == 4", "def test_snakesAndLadders():\n    solution = Solution()\n    board = [[-1, -1, -1, 21, -1, -1], [19, -1, -1, -1, -1, -1], [-1, 16, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1], [-1, -1, -1, 14, -1, -1], [-1, -1, -1, -1, -1, -1]]\n    assert solution.snakesAndLadders(board) == 5", "def test_snakesAndLadders():\n    solution = Solution()\n    board = [[-1, -1, -1, -1], [-1, -1, -1, -1], [-1, 7, -1, -1], [2, -1, -1, -1]]\n    assert solution.snakesAndLadders(board) == 3", "def test_snakesAndLadders():\n    solution = Solution()\n    board = [[-1, -1, 2, -1], [15, -1, -1, -1], [-1, -1, -1, -1], [-1, 12, -1, -1]]\n    assert solution.snakesAndLadders(board) == 2", "def test_snakesAndLadders():\n    solution = Solution()\n    board = [[-1, -1, -1, -1, -1], [3, -1, -1, -1, -1], [-1, -1, -1, 10, -1], [-1, 2, -1, -1, -1], [-1, -1, -1, -1, -1]]\n    assert solution.snakesAndLadders(board) == 3", "def test_snakesAndLadders():\n    solution = Solution()\n    board = [[-1, 11, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1], [-1, 5, -1, 9, -1, -1], [-1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, 2, -1], [-1, -1, -1, -1, -1, -1]]\n    assert solution.snakesAndLadders(board) == 5", "def test_snakesAndLadders():\n    solution = Solution()\n    board = [[-1, -1, -1, -1], [-1, -1, 6, -1], [-1, 8, -1, -1], [-1, -1, -1, -1]]\n    assert solution.snakesAndLadders(board) == 2", "def test_snakesAndLadders():\n    solution = Solution()\n    board = [[-1, -1, -1], [-1, 9, -1], [4, -1, 2]]\n    assert solution.snakesAndLadders(board) == 2", "def test_snakesAndLadders():\n    solution = Solution()\n    board = [[2, -1, -1], [-1, -1, -1], [-1, -1, -1]]\n    assert solution.snakesAndLadders(board) == 1", "def test_snakesAndLadders():\n    solution = Solution()\n    board = [[-1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1], [-1, -1, -1, 23, -1, -1], [-1, -1, 17, -1, -1, -1], [-1, -1, -1, -1, -1, -1], [1, -1, -1, -1, -1, -1]]\n    assert solution.snakesAndLadders(board) == 4", "def test_snakesAndLadders():\n    solution = Solution()\n    board = [[-1, 5, -1], [-1, -1, -1], [-1, 3, -1]]\n    assert solution.snakesAndLadders(board) == 2", "def test_snakesAndLadders():\n    solution = Solution()\n    board = [[-1, -1, -1, -1], [14, -1, 7, -1], [-1, 2, -1, -1], [-1, -1, -1, -1]]\n    assert solution.snakesAndLadders(board) == 3", "def test_snakesAndLadders():\n    solution = Solution()\n    board = [[-1, -1, 8], [-1, 4, -1], [-1, -1, -1]]\n    assert solution.snakesAndLadders(board) == 2", "def test_snakesAndLadders():\n    solution = Solution()\n    board = [[-1, -1, -1, -1], [-1, 14, -1, -1], [8, -1, -1, -1], [-1, -1, -1, 2]]\n    assert solution.snakesAndLadders(board) == 3", "def test_snakesAndLadders():\n    solution = Solution()\n    board = [[-1, -1, -1, -1, -1], [10, -1, -1, -1, -1], [-1, -1, 6, -1, -1], [-1, -1, -1, -1, -1], [-1, 11, -1, -1, -1]]\n    assert solution.snakesAndLadders(board) == 4", "def test_snakesAndLadders():\n    solution = Solution()\n    board = [[-1, -1, -1, -1, -1], [-1, 3, -1, 15, -1], [-1, -1, -1, -1, -1], [19, -1, -1, -1, -1], [-1, -1, -1, -1, -1]]\n    assert solution.snakesAndLadders(board) == 4", "def test_snakesAndLadders():\n    solution = Solution()\n    board = [[-1, -1, -1, -1], [-1, -1, 12, -1], [-1, 10, -1, -1], [-1, -1, -1, -1]]\n    assert solution.snakesAndLadders(board) == 3", "def test_snakesAndLadders():\n    solution = Solution()\n    board = [[-1, -1, 3, -1], [6, -1, -1, -1], [-1, -1, -1, -1], [-1, 8, -1, -1]]\n    assert solution.snakesAndLadders(board) == 2", "def test_snakesAndLadders():\n    solution = Solution()\n    board = [[-1, -1, -1], [-1, -1, 4], [2, -1, -1]]\n    assert solution.snakesAndLadders(board) == 2", "def test_snakesAndLadders():\n    solution = Solution()\n    board = [[-1, 3, -1, -1], [-1, -1, -1, -1], [-1, -1, -1, 5], [-1, -1, 2, -1]]\n    assert solution.snakesAndLadders(board) == 3"]}
{"task_num": 913, "task_title": "Cat and Mouse", "func_name": "catMouseGame", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import IntEnum\n\n\nclass State(IntEnum):\n  kDraw = 0\n  kMouseWin = 1\n  kCatWin = 2\n\n\nclass Solution:\n  def catMouseGame(self, graph: List[List[int]]) -> int:\n    n = len(graph)\n    states = [[[0] * 2 for i in range(n)] for j in range(n)]\n    outDegree = [[[0] * 2 for i in range(n)] for j in range(n)]\n    q = collections.deque()\n\n    for cat in range(n):\n      for mouse in range(n):\n        outDegree[cat][mouse][0] = len(graph[mouse])\n        outDegree[cat][mouse][1] = len(graph[cat]) - graph[cat].count(0)\n\n    for cat in range(1, n):\n      for move in range(2):\n        states[cat][0][move] = int(State.kMouseWin)\n        q.append((cat, 0, move, int(State.kMouseWin)))\n        states[cat][cat][move] = int(State.kCatWin)\n        q.append((cat, cat, move, int(State.kCatWin)))\n\n    while q:\n      cat, mouse, move, state = q.popleft()\n      if cat == 2 and mouse == 1 and move == 0:\n        return state\n      prevMove = move ^ 1\n      for prev in graph[cat if prevMove else mouse]:\n        prevCat = prev if prevMove else cat\n        if prevCat == 0:\n          continue\n        prevMouse = mouse if prevMove else prev\n        if states[prevCat][prevMouse][prevMove]:\n          continue\n        if prevMove == 0 and state == int(State.kMouseWin) or \\\n                prevMove == 1 and state == int(State.kCatWin):\n          states[prevCat][prevMouse][prevMove] = state\n          q.append((prevCat, prevMouse, prevMove, state))\n        else:\n          outDegree[prevCat][prevMouse][prevMove] -= 1\n          if outDegree[prevCat][prevMouse][prevMove] == 0:\n            states[prevCat][prevMouse][prevMove] = state\n            q.append((prevCat, prevMouse, prevMove, state))\n\n    return states[2][1][0]\n", "tests": ["def test_catMouseGame():\n    solution = Solution()\n    graph = [[2, 5], [3], [0, 4, 5], [1, 4, 5], [2, 3], [0, 2, 3]]\n    assert solution.catMouseGame(graph) == 0", "def test_catMouseGame():\n    solution = Solution()\n    graph = [[1, 3], [0], [3], [0, 2]]\n    assert solution.catMouseGame(graph) == 1", "def test_catMouseGame():\n    solution = Solution()\n    graph = [[1, 2], [0, 3, 4], [0, 5], [1], [1], [2]]\n    assert solution.catMouseGame(graph) == 2", "def test_catMouseGame():\n    solution = Solution()\n    graph = [[2, 3], [4], [0, 4], [0, 4], [1, 2, 3]]\n    assert solution.catMouseGame(graph) == 1", "def test_catMouseGame():\n    solution = Solution()\n    graph = [[1], [0, 3, 4], [4], [1], [1, 2]]\n    assert solution.catMouseGame(graph) == 0", "def test_catMouseGame():\n    solution = Solution()\n    graph = [[1, 4], [0, 3], [5], [1], [0, 5], [2, 4]]\n    assert solution.catMouseGame(graph) == 1", "def test_catMouseGame():\n    solution = Solution()\n    graph = [[1, 2], [0, 3], [0, 4, 5], [1], [2], [2]]\n    assert solution.catMouseGame(graph) == 2", "def test_catMouseGame():\n    solution = Solution()\n    graph = [[1, 2, 3], [0, 4], [0, 5], [0, 6], [1], [2], [3]]\n    assert solution.catMouseGame(graph) == 0", "def test_catMouseGame():\n    solution = Solution()\n    graph = [[1, 2, 4], [0, 3], [0, 5], [1], [0, 6], [2], [4]]\n    assert solution.catMouseGame(graph) == 1", "def test_catMouseGame():\n    solution = Solution()\n    graph = [[1, 3, 4], [0, 2], [1, 5], [0, 6], [0], [2], [3]]\n    assert solution.catMouseGame(graph) == 2", "def test_catMouseGame():\n    solution = Solution()\n    graph = [[1, 2, 3], [0, 4, 5], [0], [0], [1], [1, 6], [5]]\n    assert solution.catMouseGame(graph) == 1", "def test_catMouseGame():\n    solution = Solution()\n    graph = [[2, 3, 4], [5], [0, 6], [0], [0, 6], [1, 7], [2, 4], [5]]\n    assert solution.catMouseGame(graph) == 0", "def test_catMouseGame():\n    solution = Solution()\n    graph = [[1, 3], [0, 2], [1, 4], [0, 5], [2, 5, 6], [3, 4], [4]]\n    assert solution.catMouseGame(graph) == 2", "def test_catMouseGame():\n    solution = Solution()\n    graph = [[3, 4, 5], [6], [7], [0, 8], [0, 9], [0], [1], [2], [3], [4]]\n    assert solution.catMouseGame(graph) == 1", "def test_catMouseGame():\n    solution = Solution()\n    graph = [[1, 4, 5], [0, 2, 6], [1, 3], [2, 7], [0], [0, 8], [1], [3], [5, 9], [8]]\n    assert solution.catMouseGame(graph) == 0", "def test_catMouseGame():\n    solution = Solution()\n    graph = [[1, 2], [0, 3, 4], [0], [1, 5], [1, 5, 6], [3, 4], [4]]\n    assert solution.catMouseGame(graph) == 1", "def test_catMouseGame():\n    solution = Solution()\n    graph = [[1, 2], [0, 3], [0, 4, 5], [1], [2, 6], [2, 7], [4, 8], [5], [6]]\n    assert solution.catMouseGame(graph) == 2", "def test_catMouseGame():\n    solution = Solution()\n    graph = [[2, 3], [4, 5], [0, 6], [0, 7], [1], [1, 8], [2, 9], [3], [5], [6]]\n    assert solution.catMouseGame(graph) == 1", "def test_catMouseGame():\n    solution = Solution()\n    graph = [[1, 3, 4], [0, 5], [6], [0, 7], [0, 8], [1, 9], [2], [3], [4], [5]]\n    assert solution.catMouseGame(graph) == 0", "def test_catMouseGame():\n    solution = Solution()\n    graph = [[1, 2, 3], [0, 4], [0, 5], [0, 6, 7], [1, 8], [2, 9], [3], [3], [4], [5]]\n    assert solution.catMouseGame(graph) == 2"]}
{"task_num": 923, "task_title": "3Sum With Multiplicity", "func_name": "threeSumMulti", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def threeSumMulti(self, arr: List[int], target: int) -> int:\n    kMod = 1_000_000_007\n    ans = 0\n    count = collections.Counter(arr)\n\n    for i, x in count.items():\n      for j, y in count.items():\n        k = target - i - j\n        if k not in count:\n          continue\n        if i == j and j == k:\n          ans = (ans + x * (x - 1) * (x - 2) // 6) % kMod\n        elif i == j and j != k:\n          ans = (ans + x * (x - 1) // 2 * count[k]) % kMod\n        elif i < j and j < k:\n          ans = (ans + x * y * count[k]) % kMod\n\n    return ans % kMod\n", "tests": ["def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([1, 2, 3, 4, 5], 9) == 1", "def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([1, 1, 2, 2, 3, 3, 4, 4], 8) == 18", "def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([2, 2, 2, 2], 6) == 4", "def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([1, 1, 1, 3, 5], 7) == 3", "def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([0, 0, 0, 0], 0) == 4", "def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([1, 3, 2, 3, 1, 2], 6) == 8", "def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([1, 1, 1, 2, 2, 2, 3, 3, 3], 6) == 27", "def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([3, 3, 3, 3, 3], 9) == 10", "def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([2, 4, 6, 8, 10], 18) == 1", "def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([1, 2, 2, 2, 3, 4], 7) == 4", "def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([5, 5, 5, 5, 5, 5], 15) == 20", "def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([0, 1, 1, 2, 2, 2, 3, 3], 5) == 18", "def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([7, 7, 7, 7, 8, 8, 9], 22) == 14", "def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([1, 3, 5, 7, 9], 17) == 1", "def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([2, 2, 3, 3, 4, 4, 4], 10) == 24", "def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([1, 2, 2, 3, 3, 4, 5], 10) == 2", "def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([1, 1, 1, 1, 2, 2, 2, 2], 5) == 24", "def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([0, 0, 1, 1, 2, 3], 3) == 8", "def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([4, 4, 4, 6, 6, 8], 16) == 3", "def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([1, 2, 3, 4, 5, 5, 5], 12) == 5"]}
{"task_num": 927, "task_title": "Three Equal Parts", "func_name": "threeEqualParts", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def threeEqualParts(self, arr: List[int]) -> List[int]:\n    ones = sum(a == 1 for a in arr)\n\n    if ones == 0:\n      return [0, len(arr) - 1]\n    if ones % 3 != 0:\n      return [-1, -1]\n\n    k = ones // 3\n    i = 0\n\n    for i in range(len(arr)):\n      if arr[i] == 1:\n        first = i\n        break\n\n    gapOnes = k\n\n    for j in range(i + 1, len(arr)):\n      if arr[j] == 1:\n        gapOnes -= 1\n        if gapOnes == 0:\n          second = j\n          break\n\n    gapOnes = k\n\n    for i in range(j + 1, len(arr)):\n      if arr[i] == 1:\n        gapOnes -= 1\n        if gapOnes == 0:\n          third = i\n          break\n\n    while third < len(arr) and arr[first] == arr[second] == arr[third]:\n      first += 1\n      second += 1\n      third += 1\n\n    if third == len(arr):\n      return [first - 1, second]\n    return [-1, -1]\n", "tests": ["def test_threeEqualParts():\n    solution = Solution()\n    assert solution.threeEqualParts([1, 0, 1, 0, 1]) == [0, 3]", "def test_threeEqualParts():\n    solution = Solution()\n    assert solution.threeEqualParts([1, 1, 0, 0, 1]) == [-1, -1]", "def test_threeEqualParts():\n    solution = Solution()\n    assert solution.threeEqualParts([0, 0, 0, 0, 0]) == [0, 4]", "def test_threeEqualParts():\n    solution = Solution()\n    assert solution.threeEqualParts([1, 0, 0, 1, 0, 1, 0, 0]) == [1, 5]", "def test_threeEqualParts():\n    solution = Solution()\n    assert solution.threeEqualParts([1, 1, 1, 0, 0, 0]) == [-1, -1]", "def test_threeEqualParts():\n    solution = Solution()\n    assert solution.threeEqualParts([0, 1, 0, 1, 1, 0, 1, 0]) == [2, 5]", "def test_threeEqualParts():\n    solution = Solution()\n    assert solution.threeEqualParts([1, 0, 0, 0, 0, 0, 1, 0, 0, 1]) == [0, 6]", "def test_threeEqualParts():\n    solution = Solution()\n    assert solution.threeEqualParts([0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0]) == [1, 7]", "def test_threeEqualParts():\n    solution = Solution()\n    assert solution.threeEqualParts([1, 0, 1, 1, 0, 1, 1, 0, 1]) == [-1, -1]", "def test_threeEqualParts():\n    solution = Solution()\n    assert solution.threeEqualParts([0, 0, 1, 1, 0, 0, 1, 1, 0, 0]) == [2, 7]", "def test_threeEqualParts():\n    solution = Solution()\n    assert solution.threeEqualParts([1, 0, 1, 0, 0, 1, 0, 0, 0]) == [0, 4]", "def test_threeEqualParts():\n    solution = Solution()\n    assert solution.threeEqualParts([1, 1, 0, 0, 0, 1, 0, 1]) == [-1, -1]", "def test_threeEqualParts():\n    solution = Solution()\n    assert solution.threeEqualParts([0, 1, 1, 0, 1, 0, 1, 0, 0]) == [1, 5]", "def test_threeEqualParts():\n    solution = Solution()\n    assert solution.threeEqualParts([1, 0, 0, 1, 1, 0, 0, 1, 0, 0]) == [0, 6]", "def test_threeEqualParts():\n    solution = Solution()\n    assert solution.threeEqualParts([1, 1, 1, 1, 0, 0, 1, 0]) == [-1, -1]", "def test_threeEqualParts():\n    solution = Solution()\n    assert solution.threeEqualParts([0, 0, 0, 1, 0, 1, 1, 0, 0]) == [2, 6]", "def test_threeEqualParts():\n    solution = Solution()\n    assert solution.threeEqualParts([0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0]) == [1, 7]", "def test_threeEqualParts():\n    solution = Solution()\n    assert solution.threeEqualParts([1, 0, 1, 0, 1, 0, 0, 0, 0, 0]) == [0, 4]", "def test_threeEqualParts():\n    solution = Solution()\n    assert solution.threeEqualParts([1, 0, 0, 0, 1, 0, 0, 0, 1]) == [0, 5]", "def test_threeEqualParts():\n    solution = Solution()\n    assert solution.threeEqualParts([0, 1, 1, 1, 0, 0, 1, 0, 1]) == [-1, -1]"]}
{"task_num": 935, "task_title": "Knight Dialer", "func_name": "knightDialer", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def knightDialer(self, n: int) -> int:\n    dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n    kMod = 1_000_000_007\n\n    dp = [[1] * 3 for _ in range(4)]\n    dp[3][0] = dp[3][2] = 0\n\n    for _ in range(n - 1):\n      newDp = [[0] * 3 for _ in range(4)]\n      for i in range(4):\n        for j in range(3):\n          if (i, j) in ((3, 0), (3, 2)):\n            continue\n          for dx, dy in dirs:\n            x = i + dx\n            y = j + dy\n            if x < 0 or x >= 4 or y < 0 or y >= 3:\n              continue\n            if (x, y) in ((3, 0), (3, 2)):\n              continue\n            newDp[x][y] = (newDp[x][y] + dp[i][j]) % kMod\n      dp = newDp\n\n    return sum(map(sum, dp)) % kMod\n", "tests": ["def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(1) == 10", "def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(2) == 20", "def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(3) == 46", "def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(4) == 104", "def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(5) == 240", "def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(6) == 544", "def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(7) == 1404", "def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(8) == 3136", "def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(9) == 7680", "def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(10) == 17200", "def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(20) == 3585666", "def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(50) == 451107553", "def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(100) == 730976105", "def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(3) == 46", "def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(15) == 822336", "def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(25) == 720204060", "def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(30) == 993608799", "def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(12) == 104050", "def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(40) == 402065009", "def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(18) == 3166038"]}
{"task_num": 939, "task_title": "Minimum Area Rectangle", "func_name": "minAreaRect", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minAreaRect(self, points: List[List[int]]) -> int:\n    ans = math.inf\n    xToYs = collections.defaultdict(set)\n\n    for x, y in points:\n      xToYs[x].add(y)\n\n    for i in range(len(points)):\n      for j in range(i):\n        x1, y1 = points[i]\n        x2, y2 = points[j]\n        if x1 == x2 or y1 == y2:\n          continue\n        if y2 in xToYs[x1] and y1 in xToYs[x2]:\n          ans = min(ans, abs(x1 - x2) * abs(y1 - y2))\n\n    return ans if ans < math.inf else 0\n", "tests": ["def test_minAreaRect():\n    solution = Solution()\n    assert solution.minAreaRect([[1, 1], [1, 3], [3, 1], [3, 3], [2, 2]]) == 4", "def test_minAreaRect():\n    solution = Solution()\n    assert solution.minAreaRect([[1, 1], [1, 2], [2, 1], [2, 2]]) == 1", "def test_minAreaRect():\n    solution = Solution()\n    assert solution.minAreaRect([[0, 0], [0, 5], [5, 0], [5, 5], [2, 3], [3, 2]]) == 25", "def test_minAreaRect():\n    solution = Solution()\n    assert solution.minAreaRect([[1, 1], [1, 4], [2, 2], [4, 1], [4, 4], [2, 4], [4, 2]]) == 6", "def test_minAreaRect():\n    solution = Solution()\n    assert solution.minAreaRect([[3, 3], [3, 7], [8, 3], [8, 7], [5, 5]]) == 20", "def test_minAreaRect():\n    solution = Solution()\n    assert solution.minAreaRect([[1, 1], [1, 5], [4, 1], [4, 5], [6, 2], [6, 4]]) == 12", "def test_minAreaRect():\n    solution = Solution()\n    assert solution.minAreaRect([[0, 0], [0, 4], [3, 0], [3, 4], [2, 2], [5, 5]]) == 12", "def test_minAreaRect():\n    solution = Solution()\n    assert solution.minAreaRect([[1, 1], [1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2], [3, 3]]) == 1", "def test_minAreaRect():\n    solution = Solution()\n    assert solution.minAreaRect([[5, 5], [5, 10], [10, 5], [10, 10], [7, 7]]) == 25", "def test_minAreaRect():\n    solution = Solution()\n    assert solution.minAreaRect([[1, 3], [1, 7], [3, 3], [3, 7], [4, 4], [5, 5]]) == 8", "def test_minAreaRect():\n    solution = Solution()\n    assert solution.minAreaRect([[2, 2], [2, 6], [6, 2], [6, 6], [3, 3], [4, 4]]) == 16", "def test_minAreaRect():\n    solution = Solution()\n    assert solution.minAreaRect([[0, 0], [0, 3], [3, 0], [3, 3], [1, 1], [2, 2], [3, 1]]) == 9", "def test_minAreaRect():\n    solution = Solution()\n    assert solution.minAreaRect([[1, 1], [1, 4], [2, 2], [3, 1], [3, 4], [4, 4], [4, 1]]) == 6", "def test_minAreaRect():\n    solution = Solution()\n    assert solution.minAreaRect([[0, 1], [0, 3], [2, 1], [2, 3], [4, 1], [4, 3], [1, 2]]) == 4", "def test_minAreaRect():\n    solution = Solution()\n    assert solution.minAreaRect([[5, 5], [5, 8], [8, 5], [8, 8], [6, 6], [7, 7]]) == 9", "def test_minAreaRect():\n    solution = Solution()\n    assert solution.minAreaRect([[0, 0], [1, 0], [0, 2], [1, 2], [3, 3], [4, 4]]) == 2", "def test_minAreaRect():\n    solution = Solution()\n    assert solution.minAreaRect([[1, 1], [1, 5], [5, 1], [5, 5], [2, 2], [3, 3], [4, 4]]) == 16", "def test_minAreaRect():\n    solution = Solution()\n    assert solution.minAreaRect([[1, 1], [1, 6], [6, 1], [6, 6], [3, 3], [5, 5]]) == 25", "def test_minAreaRect():\n    solution = Solution()\n    assert solution.minAreaRect([[1, 2], [1, 4], [2, 2], [2, 4], [3, 3], [4, 1], [4, 5]]) == 2", "def test_minAreaRect():\n    solution = Solution()\n    assert solution.minAreaRect([[2, 3], [2, 7], [7, 3], [7, 7], [4, 5], [5, 6]]) == 20"]}
{"task_num": 952, "task_title": "Largest Component Size by Common Factor", "func_name": "largestComponentSize", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def largestComponentSize(self, nums: List[int]) -> int:\n    ans = 0\n    uf = UnionFind(max(nums) + 1)\n    count = collections.Counter()\n\n    for num in nums:\n      for x in range(2, int(math.sqrt(num) + 1)):\n        if num % x == 0:\n          uf.unionByRank(num, x)\n          uf.unionByRank(num, num // x)\n\n    for num in nums:\n      numRoot = uf.find(num)\n      count[numRoot] += 1\n      ans = max(ans, count[numRoot])\n\n    return ans\n", "tests": ["def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([4, 6, 15, 35]) == 4", "def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([20, 25, 30, 40, 50]) == 5", "def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([2, 3, 5, 7, 11, 13]) == 1", "def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([18, 24, 30, 36, 12]) == 5", "def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([14, 21, 28, 35, 49]) == 5", "def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([10, 15, 20, 22, 25, 30]) == 4", "def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([8, 9, 12, 16, 18]) == 3", "def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([33, 45, 55, 77, 99]) == 5", "def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([5, 10, 15, 25, 35, 50]) == 6", "def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([7, 14, 28, 56, 63, 42]) == 6", "def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([17, 19, 23, 29, 31, 37]) == 1", "def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([6, 10, 14, 15, 21, 35]) == 4", "def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([4, 8, 9, 27, 81]) == 3", "def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([2, 4, 6, 8, 10, 3, 9, 27]) == 5", "def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([13, 26, 39, 52, 78, 91]) == 6", "def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([24, 36, 48, 60, 72, 90]) == 6", "def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([11, 22, 33, 44, 55]) == 5", "def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([3, 6, 9, 12, 18, 27]) == 6", "def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([32, 64, 96, 128, 160, 192]) == 6", "def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([20, 50, 60, 75, 100, 125]) == 4"]}
{"task_num": 963, "task_title": "Minimum Area Rectangle II", "func_name": "minAreaFreeRect", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\nfrom math import sqrt\n\nclass Solution:\n  def minAreaFreeRect(self, points: List[List[int]]) -> float:\n    ans = math.inf\n    centerToPoints = collections.defaultdict(list)\n\n    for ax, ay in points:\n      for bx, by in points:\n        center = ((ax + bx) / 2, (ay + by) / 2)\n        centerToPoints[center].append((ax, ay, bx, by))\n\n    def dist(px: int, py: int, qx: int, qy: int) -> float:\n      return (px - qx)**2 + (py - qy)**2\n\n    for points in centerToPoints.values():\n      for ax, ay, _, _ in points:\n        for cx, cy, dx, dy in points:\n          if (cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0:\n            squaredArea = dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy)\n            if squaredArea > 0:\n              ans = min(ans, squaredArea)\n\n    return 0 if ans == math.inf else sqrt(ans)\n", "tests": ["def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[1, 2], [2, 1], [1, 0], [0, 1]]\n    assert abs(solution.minAreaFreeRect(points) - 2.0) < 1e-05", "def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[0, 0], [1, 1], [1, 0], [0, 1], [2, 2]]\n    assert abs(solution.minAreaFreeRect(points) - 1.0) < 1e-05", "def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[3, 1], [1, 3], [3, 3], [1, 1], [2, 2]]\n    assert abs(solution.minAreaFreeRect(points) - 4.0) < 1e-05", "def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[0, 0], [1, 2], [2, 1], [3, 3]]\n    assert solution.minAreaFreeRect(points) == 0", "def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[0, 0], [1, 0], [0, 1], [2, 0], [1, 1], [2, 1]]\n    assert abs(solution.minAreaFreeRect(points) - 1.0) < 1e-05", "def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[4, 4], [2, 2], [6, 2], [4, 0], [6, 4], [2, 4]]\n    assert abs(solution.minAreaFreeRect(points) - 8.0) < 1e-05", "def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[1, 1], [2, 2], [3, 3], [2, 1], [1, 2], [3, 1]]\n    assert solution.minAreaFreeRect(points) == 0", "def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[0, 0], [1, 3], [3, 1], [4, 4], [2, 2], [5, 5]]\n    assert abs(solution.minAreaFreeRect(points) - 6.0) < 1e-05", "def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[2, 0], [0, 2], [3, 1], [1, 3], [4, 2], [2, 4]]\n    assert abs(solution.minAreaFreeRect(points) - 4.0) < 1e-05", "def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[0, 1], [1, 0], [1, 2], [2, 1], [3, 0], [3, 2]]\n    assert abs(solution.minAreaFreeRect(points) - 2.0) < 1e-05", "def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[5, 5], [7, 7], [8, 6], [6, 8], [9, 5], [10, 6]]\n    assert abs(solution.minAreaFreeRect(points) - 4.0) < 1e-05", "def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[0, 0], [2, 0], [1, 1], [3, 1], [4, 0], [5, 1]]\n    assert abs(solution.minAreaFreeRect(points) - 2.0) < 1e-05", "def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[1, 0], [0, 1], [2, 1], [1, 2], [3, 2], [2, 3]]\n    assert abs(solution.minAreaFreeRect(points) - 1.0) < 1e-05", "def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[0, 0], [1, 1], [1, -1], [3, 1], [3, -1]]\n    assert abs(solution.minAreaFreeRect(points) - 4.0) < 1e-05", "def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[0, 0], [2, 2], [2, 0], [0, 2], [1, 1], [3, 3]]\n    assert abs(solution.minAreaFreeRect(points) - 4.0) < 1e-05", "def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[1, 4], [2, 3], [3, 2], [4, 1], [5, 2], [6, 3]]\n    assert abs(solution.minAreaFreeRect(points) - 8.0) < 1e-05", "def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[0, 1], [2, 3], [4, 5], [6, 7], [8, 9], [10, 11]]\n    assert solution.minAreaFreeRect(points) == 0", "def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[1, 1], [1, 4], [4, 1], [4, 4], [2, 3], [3, 2]]\n    assert abs(solution.minAreaFreeRect(points) - 9.0) < 1e-05", "def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[2, 3], [3, 4], [5, 3], [4, 2], [6, 5], [7, 6]]\n    assert solution.minAreaFreeRect(points) == 0", "def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[0, 0], [1, 1], [2, 0], [3, 1], [4, 0], [5, 1]]\n    assert abs(solution.minAreaFreeRect(points) - 2.0) < 1e-05"]}
{"task_num": 990, "task_title": "Satisfiability of Equality Equations", "func_name": "equationsPossible", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n\n  def union(self, u: int, v: int) -> None:\n    self.id[self.find(u)] = self.find(v)\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def equationsPossible(self, equations: List[str]) -> bool:\n    uf = UnionFind(26)\n\n    for x, op, _, y in equations:\n      if op == '=':\n        uf.union(ord(x) - ord('a'), ord(y) - ord('a'))\n\n    for x, op, _, y in equations:\n      if op == '!':\n        if uf.find(ord(x) - ord('a')) == uf.find(ord(y) - ord('a')):\n          return False\n    return True\n", "tests": ["def test_equationsPossible():\n    solution = Solution()\n    assert solution.equationsPossible(['a==b', 'b!=a']) == False", "def test_equationsPossible():\n    solution = Solution()\n    assert solution.equationsPossible(['c==c', 'b==d', 'x!=z']) == True", "def test_equationsPossible():\n    solution = Solution()\n    assert solution.equationsPossible(['a==b', 'b==c', 'a==c', 'a!=d']) == True", "def test_equationsPossible():\n    solution = Solution()\n    assert solution.equationsPossible(['a==b', 'b==c', 'c!=a']) == False", "def test_equationsPossible():\n    solution = Solution()\n    assert solution.equationsPossible(['x!=y', 'y==z', 'z!=x', 'w==w']) == True", "def test_equationsPossible():\n    solution = Solution()\n    assert solution.equationsPossible(['a==b', 'e==f', 'f!=g', 'b!=e']) == True", "def test_equationsPossible():\n    solution = Solution()\n    assert solution.equationsPossible(['m==n', 'n==o', 'o==p', 'p==m', 'm!=q']) == True", "def test_equationsPossible():\n    solution = Solution()\n    assert solution.equationsPossible(['a!=b', 'b==c', 'c==d', 'd!=a']) == True", "def test_equationsPossible():\n    solution = Solution()\n    assert solution.equationsPossible(['u==v', 'v!=w', 'w==x', 'x==y', 'y==u']) == False", "def test_equationsPossible():\n    solution = Solution()\n    assert solution.equationsPossible(['a==b', 'c==d', 'e==f', 'g!=h', 'b!=f']) == True", "def test_equationsPossible():\n    solution = Solution()\n    assert solution.equationsPossible(['i==j', 'j!=k', 'k==l', 'l==i', 'i==k']) == False", "def test_equationsPossible():\n    solution = Solution()\n    assert solution.equationsPossible(['p!=q', 'q!=r', 'r!=s', 's!=p', 'p==p']) == True", "def test_equationsPossible():\n    solution = Solution()\n    assert solution.equationsPossible(['x==y', 'y==z', 'z!=x']) == False", "def test_equationsPossible():\n    solution = Solution()\n    assert solution.equationsPossible(['a==a', 'b==b', 'c==d', 'd!=c', 'e==e']) == False", "def test_equationsPossible():\n    solution = Solution()\n    assert solution.equationsPossible(['m!=n', 'n!=o', 'o!=p', 'p==m', 'm!=o']) == False", "def test_equationsPossible():\n    solution = Solution()\n    assert solution.equationsPossible(['b==c', 'c!=d', 'd==e', 'e!=f', 'f==b']) == False", "def test_equationsPossible():\n    solution = Solution()\n    assert solution.equationsPossible(['a==b', 'b==c', 'c==d', 'd!=e', 'e==f', 'f!=a']) == True", "def test_equationsPossible():\n    solution = Solution()\n    assert solution.equationsPossible(['u==v', 'v==w', 'w==x', 'x==y', 'y!=u', 'u!=w']) == True", "def test_equationsPossible():\n    solution = Solution()\n    assert solution.equationsPossible(['h==i', 'i==j', 'j==k', 'k==l', 'l==h', 'h!=k']) == False", "def test_equationsPossible():\n    solution = Solution()\n    assert solution.equationsPossible(['a!=b', 'b!=c', 'c!=d', 'd!=a', 'a==e', 'e!=f', 'f==c']) == True"]}
{"task_num": 999, "task_title": "Available Captures for Rook", "func_name": "numRookCaptures", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numRookCaptures(self, board: List[List[str]]) -> int:\n    ans = 0\n\n    for i in range(8):\n      for j in range(8):\n        if board[i][j] == 'R':\n          i0 = i\n          j0 = j\n\n    for d in [[1, 0], [0, 1], [-1, 0], [0, -1]]:\n      i = i0 + d[0]\n      j = j0 + d[1]\n      while 0 <= i < 8 and 0 <= j < 8:\n        if board[i][j] == 'p':\n          ans += 1\n        if board[i][j] != '.':\n          break\n        i += d[0]\n        j += d[1]\n\n    return ans\n", "tests": ["def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', 'p', '.', '.', '.', '.'], ['.', '.', '.', 'R', '.', '.', '.', 'p'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', 'p', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 3", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', 'p', '.', 'p', '.', '.', '.'], ['.', '.', '.', 'B', '.', '.', '.', '.'], ['.', 'p', '.', 'R', '.', 'B', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 1", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', 'B', '.', '.', '.', '.', '.'], ['.', 'p', '.', 'R', '.', 'p', '.', '.'], ['.', '.', 'B', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', 'p', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 2", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', 'R', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 0", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', 'p', '.', '.', '.', '.'], ['.', '.', 'B', 'R', 'B', '.', '.', '.'], ['.', '.', '.', 'p', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 0", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['p', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', 'p'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', 'B', '.', 'R', '.', 'B', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', '.', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 1", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', '.', '.', '.', '.', '.', '.', '.'], ['.', 'p', '.', '.', '.', 'p', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', 'R', '.', '.', '.', 'p', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', 'p', '.', '.', '.', 'p', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 3", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', 'p', '.', '.', '.', '.'], ['.', '.', 'p', '.', '.', 'p', '.', '.'], ['.', '.', '.', 'R', '.', 'B', '.', '.'], ['.', '.', 'p', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', 'B', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 1", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', '.', '.', '.', '.', '.', '.', '.'], ['.', 'B', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', 'R', '.', '.', '.', '.'], ['.', '.', '.', '.', 'p', '.', '.', '.'], ['.', 'p', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 2", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', '.', '.', '.', '.', 'p', '.', '.'], ['.', '.', '.', '.', 'B', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', 'R', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', 'p', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 0", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', '.', 'p', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', 'B', '.', '.', '.', '.', '.'], ['.', '.', '.', 'R', '.', '.', 'p', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', 'B', '.', '.', '.', '.', 'p'], ['.', '.', '.', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 1", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', 'B', '.', '.', '.'], ['.', '.', '.', 'R', '.', '.', '.', '.'], ['.', '.', '.', '.', 'p', '.', '.', '.'], ['B', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 1", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', '.', '.', '.', '.', '.', '.', '.'], ['.', 'p', '.', '.', '.', '.', 'p', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', 'R', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', 'p', '.', '.', 'B', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 2", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', 'B', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', 'p', 'R', 'p', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', 'p', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 2", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', 'p', 'B', 'R', '.', '.', '.', '.'], ['.', '.', '.', '.', 'p', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', 'p', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 1", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', 'R', '.', 'p', '.', '.'], ['.', '.', '.', '.', 'B', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', 'p', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', 'p', '.', '.']]\n    assert solution.numRookCaptures(board) == 1", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', 'p', '.', '.', '.', '.', '.', '.'], ['.', '.', 'B', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', 'R', '.', '.', '.', '.'], ['p', '.', '.', '.', '.', '.', 'p', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 2", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', 'p', 'R', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', 'p'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', '.', 'B', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 2", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', 'p', '.', '.', '.', '.', '.'], ['.', '.', '.', 'R', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', 'p', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', 'p']]\n    assert solution.numRookCaptures(board) == 3", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', 'p', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', 'B', '.', 'R', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', '.', '.', '.', 'p', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 0"]}
{"task_num": 1001, "task_title": "Grid Illumination", "func_name": "gridIllumination", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def gridIllumination(self, n: int, lamps: List[List[int]], queries: List[List[int]]) -> List[int]:\n    ans = []\n    rows = collections.Counter()\n    cols = collections.Counter()\n    diag1 = collections.Counter()\n    diag2 = collections.Counter()\n    lampsSet = set()\n\n    for i, j in lamps:\n      if (i, j) not in lampsSet:\n        lampsSet.add((i, j))\n        rows[i] += 1\n        cols[j] += 1\n        diag1[i + j] += 1\n        diag2[i - j] += 1\n\n    for i, j in queries:\n      if rows[i] or cols[j] or diag1[i + j] or diag2[i - j]:\n        ans.append(1)\n        for y in range(max(0, i - 1), min(n, i + 2)):\n          for x in range(max(0, j - 1), min(n, j + 2)):\n            if (y, x) in lampsSet:\n              lampsSet.remove((y, x))\n              rows[y] -= 1\n              cols[x] -= 1\n              diag1[y + x] -= 1\n              diag2[y - x] -= 1\n      else:\n        ans.append(0)\n\n    return ans\n", "tests": ["def test_gridIllumination():\n    solution = Solution()\n    n = 5\n    lamps = [[0, 0], [4, 4]]\n    queries = [[1, 1], [1, 0], [4, 4], [3, 3]]\n    expected_output = [1, 0, 1, 0]\n    assert solution.gridIllumination(n, lamps, queries) == expected_output", "def test_gridIllumination():\n    solution = Solution()\n    n = 6\n    lamps = [[2, 5], [3, 3], [1, 4]]\n    queries = [[2, 5], [0, 0], [3, 3], [1, 4]]\n    expected_output = [1, 0, 1, 0]\n    assert solution.gridIllumination(n, lamps, queries) == expected_output", "def test_gridIllumination():\n    solution = Solution()\n    n = 8\n    lamps = [[4, 4], [5, 5], [3, 6]]\n    queries = [[4, 4], [4, 5], [6, 6], [3, 3], [5, 5]]\n    expected_output = [1, 1, 0, 0, 0]\n    assert solution.gridIllumination(n, lamps, queries) == expected_output", "def test_gridIllumination():\n    solution = Solution()\n    n = 10\n    lamps = [[0, 9], [9, 0], [5, 5]]\n    queries = [[0, 9], [9, 0], [5, 5], [0, 0], [9, 9]]\n    expected_output = [1, 1, 1, 0, 0]\n    assert solution.gridIllumination(n, lamps, queries) == expected_output", "def test_gridIllumination():\n    solution = Solution()\n    n = 7\n    lamps = [[1, 2], [2, 2], [3, 4], [4, 1], [5, 5]]\n    queries = [[1, 2], [2, 2], [3, 3], [4, 1], [5, 5], [6, 6]]\n    expected_output = [1, 1, 1, 1, 1, 0]\n    assert solution.gridIllumination(n, lamps, queries) == expected_output", "def test_gridIllumination():\n    solution = Solution()\n    n = 10\n    lamps = [[0, 0], [9, 9], [5, 0], [0, 5], [9, 5]]\n    queries = [[0, 0], [9, 9], [5, 0], [0, 5], [9, 5]]\n    expected_output = [1, 1, 1, 1, 1]\n    assert solution.gridIllumination(n, lamps, queries) == expected_output", "def test_gridIllumination():\n    solution = Solution()\n    n = 5\n    lamps = []\n    queries = [[0, 0], [2, 2], [4, 4], [1, 3], [3, 1]]\n    expected_output = [0, 0, 0, 0, 0]\n    assert solution.gridIllumination(n, lamps, queries) == expected_output", "def test_gridIllumination():\n    solution = Solution()\n    n = 6\n    lamps = [[2, 0], [2, 1], [2, 2], [2, 3], [2, 4], [2, 5]]\n    queries = [[2, 0], [2, 2], [2, 5], [1, 1], [3, 3]]\n    expected_output = [1, 1, 1, 0, 0]\n    assert solution.gridIllumination(n, lamps, queries) == expected_output", "def test_gridIllumination():\n    solution = Solution()\n    n = 5\n    lamps = [[0, 0], [1, 1], [2, 2], [3, 3], [4, 4]]\n    queries = [[0, 0], [4, 4], [2, 2], [3, 1], [1, 3]]\n    expected_output = [1, 1, 1, 0, 0]\n    assert solution.gridIllumination(n, lamps, queries) == expected_output", "def test_gridIllumination():\n    solution = Solution()\n    n = 4\n    lamps = [[1, 1], [1, 1], [2, 2], [3, 0], [0, 3]]\n    queries = [[1, 1], [2, 2], [3, 0], [0, 3], [3, 3]]\n    expected_output = [1, 1, 1, 1, 0]\n    assert solution.gridIllumination(n, lamps, queries) == expected_output", "def test_gridIllumination():\n    solution = Solution()\n    n = 3\n    lamps = [[0, 0], [1, 1], [2, 2]]\n    queries = [[1, 1], [1, 1], [1, 1], [0, 0], [2, 2]]\n    expected_output = [1, 0, 0, 1, 0]\n    assert solution.gridIllumination(n, lamps, queries) == expected_output", "def test_gridIllumination():\n    solution = Solution()\n    n = 3\n    lamps = [[0, 0], [0, 2], [2, 0], [2, 2]]\n    queries = [[0, 0], [0, 2], [2, 0], [2, 2], [1, 1]]\n    expected_output = [1, 1, 1, 1, 1]\n    assert solution.gridIllumination(n, lamps, queries) == expected_output", "def test_gridIllumination():\n    solution = Solution()\n    n = 10\n    lamps = [[5, 5], [7, 8], [2, 3]]\n    queries = [[5, 5], [7, 8], [2, 3], [0, 0], [9, 9]]\n    expected_output = [1, 1, 1, 0, 0]\n    assert solution.gridIllumination(n, lamps, queries) == expected_output", "def test_gridIllumination():\n    solution = Solution()\n    n = 4\n    lamps = [[2, 2]]\n    queries = [[2, 2], [0, 0], [3, 3], [1, 1], [2, 3]]\n    expected_output = [1, 0, 0, 1, 1]\n    assert solution.gridIllumination(n, lamps, queries) == expected_output", "def test_gridIllumination():\n    solution = Solution()\n    n = 5\n    lamps = [[2, 2], [2, 3], [3, 2], [3, 3]]\n    queries = [[2, 2], [2, 3], [3, 2], [3, 3], [4, 4]]\n    expected_output = [1, 1, 0, 0, 0]\n    assert solution.gridIllumination(n, lamps, queries) == expected_output", "def test_gridIllumination():\n    solution = Solution()\n    n = 3\n    lamps = [[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]]\n    queries = [[1, 1], [0, 0], [2, 2], [2, 1], [1, 0]]\n    expected_output = [1, 1, 1, 1, 1]\n    assert solution.gridIllumination(n, lamps, queries) == expected_output", "def test_gridIllumination():\n    solution = Solution()\n    n = 7\n    lamps = [[1, 1], [3, 5], [5, 3], [0, 6], [6, 0]]\n    queries = [[1, 1], [3, 5], [5, 3], [0, 6], [6, 0], [2, 2]]\n    expected_output = [1, 1, 1, 1, 1, 0]\n    assert solution.gridIllumination(n, lamps, queries) == expected_output", "def test_gridIllumination():\n    solution = Solution()\n    n = 8\n    lamps = [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6]]\n    queries = [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 6], [0, 0]]\n    expected_output = [1, 1, 1, 1, 1, 0, 0]\n    assert solution.gridIllumination(n, lamps, queries) == expected_output", "def test_gridIllumination():\n    solution = Solution()\n    n = 6\n    lamps = []\n    queries = [[3, 3], [1, 4], [5, 0]]\n    expected_output = [0, 0, 0]\n    assert solution.gridIllumination(n, lamps, queries) == expected_output", "def test_gridIllumination():\n    solution = Solution()\n    n = 6\n    lamps = [[0, 5], [5, 0], [5, 5]]\n    queries = [[0, 5], [5, 0], [5, 5], [0, 0], [3, 3]]\n    expected_output = [1, 1, 1, 0, 0]\n    assert solution.gridIllumination(n, lamps, queries) == expected_output"]}
{"task_num": 1093, "task_title": "Statistics from a Large Sample", "func_name": "sampleStats", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def sampleStats(self, count: List[int]) -> List[float]:\n    minimum = next((i for i, num in enumerate(count) if num), None)\n    maximum = next((i for i, num in reversed(list(enumerate(count))) if num), None)\n    n = sum(count)\n    mean = sum(i * c / n for i, c in enumerate(count))\n    mode = count.index(max(count))\n\n    numCount = 0\n    leftMedian = 0\n    for i, c in enumerate(count):\n      numCount += c\n      if numCount >= n / 2:\n        leftMedian = i\n        break\n\n    numCount = 0\n    rightMedian = 0\n    for i, c in reversed(list(enumerate(count))):\n      numCount += c\n      if numCount >= n / 2:\n        rightMedian = i\n        break\n\n    return [minimum, maximum, mean, (leftMedian + rightMedian) / 2, mode]\n", "tests": ["def test_sampleStats():\n    solution = Solution()\n    count = [0] * 256\n    count[1] = 2\n    count[2] = 1\n    count[3] = 1\n    assert solution.sampleStats(count) == [1.0, 3.0, 1.75, 1.5, 1.0]", "def test_sampleStats():\n    solution = Solution()\n    count = [0] * 256\n    count[0] = 1\n    count[1] = 1\n    count[255] = 1\n    assert solution.sampleStats(count) == [0.0, 255.0, 85.33333333333333, 1.0, 0.0]", "def test_sampleStats():\n    solution = Solution()\n    count = [0] * 256\n    count[10] = 5\n    count[20] = 3\n    count[30] = 7\n    assert solution.sampleStats(count) == [10.0, 30.0, 20.0, 20.0, 30.0]", "def test_sampleStats():\n    solution = Solution()\n    count = [0] * 256\n    count[50] = 10\n    count[100] = 10\n    count[150] = 10\n    assert solution.sampleStats(count) == [50.0, 150.0, 100.0, 100.0, 50.0]", "def test_sampleStats():\n    solution = Solution()\n    count = [0] * 256\n    count[5] = 5\n    count[10] = 8\n    count[15] = 3\n    count[255] = 6\n    assert solution.sampleStats(count) == [5.0, 255.0, 61.15, 10.0, 10.0]", "def test_sampleStats():\n    solution = Solution()\n    count = [0] * 256\n    count[1] = 4\n    count[100] = 1\n    count[200] = 5\n    count[250] = 2\n    assert solution.sampleStats(count) == [1.0, 250.0, 126.6, 200.0, 200.0]", "def test_sampleStats():\n    solution = Solution()\n    count = [0] * 256\n    count[0] = 6\n    count[50] = 3\n    count[100] = 2\n    count[150] = 1\n    count[200] = 4\n    assert solution.sampleStats(count) == [0.0, 200.0, 37.0, 50.0, 0.0]", "def test_sampleStats():\n    solution = Solution()\n    count = [0] * 256\n    count[25] = 1\n    count[75] = 5\n    count[125] = 10\n    count[175] = 5\n    count[225] = 1\n    assert solution.sampleStats(count) == [25.0, 225.0, 125.0, 125.0, 125.0]", "def test_sampleStats():\n    solution = Solution()\n    count = [0] * 256\n    count[1] = 3\n    count[5] = 2\n    count[10] = 2\n    count[20] = 3\n    count[30] = 1\n    assert solution.sampleStats(count) == [1.0, 30.0, 11.25, 10.0, 1.0]", "def test_sampleStats():\n    solution = Solution()\n    count = [0] * 256\n    count[50] = 1\n    count[60] = 1\n    count[70] = 1\n    count[80] = 1\n    count[90] = 1\n    assert solution.sampleStats(count) == [50.0, 90.0, 70.0, 70.0, 50.0]", "def test_sampleStats():\n    solution = Solution()\n    count = [0] * 256\n    count[0] = 2\n    count[2] = 2\n    count[4] = 2\n    count[6] = 2\n    count[8] = 2\n    assert solution.sampleStats(count) == [0.0, 8.0, 4.0, 4.0, 0.0]", "def test_sampleStats():\n    solution = Solution()\n    count = [0] * 256\n    count[2] = 4\n    count[4] = 4\n    count[6] = 6\n    count[8] = 4\n    count[10] = 2\n    assert solution.sampleStats(count) == [2.0, 10.0, 6.0, 6.0, 6.0]", "def test_sampleStats():\n    solution = Solution()\n    count = [0] * 256\n    count[100] = 10\n    count[110] = 5\n    count[120] = 15\n    assert solution.sampleStats(count) == [100.0, 120.0, 112.5, 115.0, 120.0]", "def test_sampleStats():\n    solution = Solution()\n    count = [0] * 256\n    count[1] = 10\n    count[3] = 5\n    count[7] = 5\n    count[9] = 10\n    assert solution.sampleStats(count) == [1.0, 9.0, 5.0, 5.0, 1.0]", "def test_sampleStats():\n    solution = Solution()\n    count = [0] * 256\n    count[50] = 5\n    count[150] = 10\n    count[250] = 5\n    assert solution.sampleStats(count) == [50.0, 250.0, 150.0, 150.0, 150.0]", "def test_sampleStats():\n    solution = Solution()\n    count = [0] * 256\n    count[0] = 3\n    count[127] = 4\n    count[255] = 3\n    assert solution.sampleStats(count) == [0.0, 255.0, 127.0, 127.0, 127.0]", "def test_sampleStats():\n    solution = Solution()\n    count = [0] * 256\n    count[10] = 6\n    count[20] = 8\n    count[30] = 6\n    count[40] = 5\n    count[50] = 5\n    assert solution.sampleStats(count) == [10.0, 50.0, 27.0, 25.0, 20.0]", "def test_sampleStats():\n    solution = Solution()\n    count = [0] * 256\n    count[0] = 1\n    count[5] = 1\n    count[10] = 1\n    count[15] = 2\n    count[20] = 1\n    assert solution.sampleStats(count) == [0.0, 20.0, 11.0, 12.5, 15.0]", "def test_sampleStats():\n    solution = Solution()\n    count = [0] * 256\n    count[1] = 5\n    count[3] = 2\n    count[5] = 10\n    count[7] = 3\n    assert solution.sampleStats(count) == [1.0, 7.0, 4.2, 5.0, 5.0]", "def test_sampleStats():\n    solution = Solution()\n    count = [0] * 256\n    count[2] = 1\n    count[4] = 2\n    count[6] = 3\n    count[8] = 4\n    count[10] = 5\n    assert solution.sampleStats(count) == [2.0, 10.0, 7.333333333333333, 8.0, 10.0]"]}
{"task_num": 1129, "task_title": "Shortest Path with Alternating Colors", "func_name": "shortestAlternatingPaths", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import Enum\n\n\nclass Color(Enum):\n  kInit = 0\n  kRed = 1\n  kBlue = 2\n\n\nclass Solution:\n  def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:\n    ans = [-1] * n\n    graph = [[] for _ in range(n)]\n    q = collections.deque([(0, Color.kInit)])\n\n    for u, v in redEdges:\n      graph[u].append((v, Color.kRed))\n\n    for u, v in blueEdges:\n      graph[u].append((v, Color.kBlue))\n\n    step = 0\n    while q:\n      for _ in range(len(q)):\n        u, prevColor = q.popleft()\n        if ans[u] == -1:\n          ans[u] = step\n        for i, (v, edgeColor) in enumerate(graph[u]):\n          if v == -1 or edgeColor == prevColor:\n            continue\n          q.append((v, edgeColor))\n          graph[u][i] = (-1, edgeColor)\n      step += 1\n\n    return ans\n", "tests": ["def test_shortestAlternatingPaths():\n    solution = Solution()\n    n = 3\n    redEdges = [[0, 1], [1, 2]]\n    blueEdges = [[0, 2]]\n    assert solution.shortestAlternatingPaths(n, redEdges, blueEdges) == [0, 1, 1]", "def test_shortestAlternatingPaths():\n    solution = Solution()\n    n = 4\n    redEdges = [[0, 1], [1, 3]]\n    blueEdges = [[1, 2], [2, 3]]\n    assert solution.shortestAlternatingPaths(n, redEdges, blueEdges) == [0, 1, 2, 3]", "def test_shortestAlternatingPaths():\n    solution = Solution()\n    n = 5\n    redEdges = [[0, 1], [1, 2], [2, 3], [3, 4]]\n    blueEdges = [[1, 0], [2, 1], [3, 2], [4, 3]]\n    assert solution.shortestAlternatingPaths(n, redEdges, blueEdges) == [0, 1, 2, 3, 4]", "def test_shortestAlternatingPaths():\n    solution = Solution()\n    n = 6\n    redEdges = [[0, 1], [2, 3], [4, 5]]\n    blueEdges = [[1, 2], [3, 4]]\n    assert solution.shortestAlternatingPaths(n, redEdges, blueEdges) == [0, 1, 2, 3, 4, 5]", "def test_shortestAlternatingPaths():\n    solution = Solution()\n    n = 4\n    redEdges = [[0, 1], [1, 2]]\n    blueEdges = [[2, 3]]\n    assert solution.shortestAlternatingPaths(n, redEdges, blueEdges) == [0, 1, 2, 3]", "def test_shortestAlternatingPaths():\n    solution = Solution()\n    n = 5\n    redEdges = [[0, 1], [1, 4]]\n    blueEdges = [[0, 2], [2, 3], [3, 4]]\n    assert solution.shortestAlternatingPaths(n, redEdges, blueEdges) == [0, 1, 1, 2, 2]", "def test_shortestAlternatingPaths():\n    solution = Solution()\n    n = 3\n    redEdges = [[1, 0]]\n    blueEdges = [[0, 2]]\n    assert solution.shortestAlternatingPaths(n, redEdges, blueEdges) == [0, -1, 1]", "def test_shortestAlternatingPaths():\n    solution = Solution()\n    n = 7\n    redEdges = [[0, 1], [1, 2], [2, 3]]\n    blueEdges = [[0, 4], [4, 5], [5, 6]]\n    assert solution.shortestAlternatingPaths(n, redEdges, blueEdges) == [0, 1, 2, 3, 1, 2, 3]", "def test_shortestAlternatingPaths():\n    solution = Solution()\n    n = 4\n    redEdges = [[0, 2], [2, 1]]\n    blueEdges = [[0, 3], [3, 1]]\n    assert solution.shortestAlternatingPaths(n, redEdges, blueEdges) == [0, 2, 1, 1]", "def test_shortestAlternatingPaths():\n    solution = Solution()\n    n = 5\n    redEdges = [[0, 1], [1, 2], [4, 3]]\n    blueEdges = [[0, 2], [2, 3], [3, 4]]\n    assert solution.shortestAlternatingPaths(n, redEdges, blueEdges) == [0, 1, 1, 2, 3]", "def test_shortestAlternatingPaths():\n    solution = Solution()\n    n = 6\n    redEdges = [[0, 1], [1, 4]]\n    blueEdges = [[0, 2], [2, 5]]\n    assert solution.shortestAlternatingPaths(n, redEdges, blueEdges) == [0, 1, 1, -1, 2, 2]", "def test_shortestAlternatingPaths():\n    solution = Solution()\n    n = 3\n    redEdges = [[0, 1], [1, 1]]\n    blueEdges = [[1, 2], [2, 2]]\n    assert solution.shortestAlternatingPaths(n, redEdges, blueEdges) == [0, 1, 2]", "def test_shortestAlternatingPaths():\n    solution = Solution()\n    n = 4\n    redEdges = [[0, 3], [3, 1]]\n    blueEdges = [[0, 2], [2, 3]]\n    assert solution.shortestAlternatingPaths(n, redEdges, blueEdges) == [0, 2, 1, 1]", "def test_shortestAlternatingPaths():\n    solution = Solution()\n    n = 5\n    redEdges = [[0, 1], [1, 3], [3, 4]]\n    blueEdges = [[0, 2], [2, 1], [1, 4]]\n    assert solution.shortestAlternatingPaths(n, redEdges, blueEdges) == [0, 1, 1, 2, 2]", "def test_shortestAlternatingPaths():\n    solution = Solution()\n    n = 6\n    redEdges = [[0, 1], [2, 3], [4, 5]]\n    blueEdges = [[0, 2], [2, 4]]\n    assert solution.shortestAlternatingPaths(n, redEdges, blueEdges) == [0, 1, 1, 2, 2, 3]", "def test_shortestAlternatingPaths():\n    solution = Solution()\n    n = 7\n    redEdges = [[0, 1], [0, 2], [2, 3], [3, 6]]\n    blueEdges = [[1, 4], [4, 5], [5, 6]]\n    assert solution.shortestAlternatingPaths(n, redEdges, blueEdges) == [0, 1, 1, 2, 2, 3, 3]", "def test_shortestAlternatingPaths():\n    solution = Solution()\n    n = 5\n    redEdges = [[0, 1], [1, 2], [3, 4]]\n    blueEdges = [[0, 3], [3, 2]]\n    assert solution.shortestAlternatingPaths(n, redEdges, blueEdges) == [0, 1, 2, 1, 2]", "def test_shortestAlternatingPaths():\n    solution = Solution()\n    n = 6\n    redEdges = [[0, 1], [1, 2], [2, 4]]\n    blueEdges = [[0, 3], [3, 5], [5, 2]]\n    assert solution.shortestAlternatingPaths(n, redEdges, blueEdges) == [0, 1, 3, 1, 4, 2]", "def test_shortestAlternatingPaths():\n    solution = Solution()\n    n = 4\n    redEdges = [[0, 1], [1, 2]]\n    blueEdges = [[0, 2], [2, 3], [3, 1]]\n    assert solution.shortestAlternatingPaths(n, redEdges, blueEdges) == [0, 1, 1, 2]", "def test_shortestAlternatingPaths():\n    solution = Solution()\n    n = 5\n    redEdges = [[0, 2], [2, 3]]\n    blueEdges = [[0, 1], [1, 4], [4, 3]]\n    assert solution.shortestAlternatingPaths(n, redEdges, blueEdges) == [0, 1, 1, 2, 2]"]}
{"task_num": 1139, "task_title": "Largest 1-Bordered Square", "func_name": "largest1BorderedSquare", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n\n    leftOnes = [[0] * n for _ in range(m)]\n    topOnes = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1:\n          if j==0:\n            leftOnes[i][j]=1\n          else:\n            leftOnes[i][j]=1+leftOnes[i][j-1]\n          if i==0:\n            topOnes[i][j]=1\n          else:\n            topOnes[i][j]=1+topOnes[i-1][j]\n\n    for sz in range(min(m, n), 0, -1):\n      for i in range(m - sz + 1):\n        for j in range(n - sz + 1):\n          x = i + sz - 1\n          y = j + sz - 1\n          if min(leftOnes[i][y], leftOnes[x][y], topOnes[x][j], topOnes[x][y]) >= sz:\n            return sz * sz\n\n    return 0\n", "tests": ["def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[1, 1, 0, 0], [1, 1, 0, 0], [0, 0, 1, 1], [0, 0, 1, 1]]\n    assert solution.largest1BorderedSquare(grid) == 4", "def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n    assert solution.largest1BorderedSquare(grid) == 1", "def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[1, 1, 1, 1], [1, 0, 0, 1], [1, 0, 0, 1], [1, 1, 1, 1]]\n    assert solution.largest1BorderedSquare(grid) == 16", "def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\n    assert solution.largest1BorderedSquare(grid) == 9", "def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]\n    assert solution.largest1BorderedSquare(grid) == 0", "def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]\n    assert solution.largest1BorderedSquare(grid) == 1", "def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[1, 1, 1, 0], [1, 1, 1, 0], [1, 1, 1, 0]]\n    assert solution.largest1BorderedSquare(grid) == 9", "def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[1, 0], [1, 1]]\n    assert solution.largest1BorderedSquare(grid) == 1", "def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[0, 1, 0], [1, 1, 1], [0, 1, 0]]\n    assert solution.largest1BorderedSquare(grid) == 3", "def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[1, 0, 0, 1], [0, 1, 1, 0], [0, 1, 1, 0], [1, 0, 0, 1]]\n    assert solution.largest1BorderedSquare(grid) == 1", "def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[1, 1, 0], [1, 0, 1], [0, 1, 1]]\n    assert solution.largest1BorderedSquare(grid) == 1", "def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[1, 1, 1, 1], [1, 0, 1, 1], [1, 1, 0, 1], [1, 1, 1, 1]]\n    assert solution.largest1BorderedSquare(grid) == 4", "def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[0, 1, 1, 0], [1, 1, 1, 1], [1, 1, 1, 1], [0, 1, 1, 0]]\n    assert solution.largest1BorderedSquare(grid) == 4", "def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[0, 1, 0, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]\n    assert solution.largest1BorderedSquare(grid) == 9", "def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[1, 1, 1, 1, 1], [1, 0, 0, 0, 1], [1, 0, 1, 0, 1], [1, 0, 0, 0, 1], [1, 1, 1, 1, 1]]\n    assert solution.largest1BorderedSquare(grid) == 25", "def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[1, 0, 1, 0, 1], [0, 1, 1, 1, 0], [1, 1, 1, 1, 1], [0, 1, 1, 1, 0], [1, 0, 1, 0, 1]]\n    assert solution.largest1BorderedSquare(grid) == 9", "def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[0, 0, 0, 0], [0, 1, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0]]\n    assert solution.largest1BorderedSquare(grid) == 4", "def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[1, 1, 0, 1], [1, 1, 0, 1], [0, 0, 1, 1], [1, 1, 1, 1]]\n    assert solution.largest1BorderedSquare(grid) == 4", "def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[1, 0, 0, 0], [0, 1, 1, 1], [0, 1, 0, 1], [0, 1, 1, 1]]\n    assert solution.largest1BorderedSquare(grid) == 3", "def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[1, 1, 0, 1, 1], [1, 1, 0, 1, 1], [0, 0, 1, 0, 0], [1, 1, 0, 1, 1], [1, 1, 0, 1, 1]]\n    assert solution.largest1BorderedSquare(grid) == 4"]}
{"task_num": 1162, "task_title": "As Far from Land as Possible", "func_name": "maxDistance", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxDistance(self, grid: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    q = collections.deque()\n    water = 0\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 0:\n          water += 1\n        else:\n          q.append((i, j))\n\n    if water == 0 or water == m * n:\n      return -1\n\n    ans = 0\n    d = 0\n\n    while q:\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        ans = d\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if grid[x][y] > 0:\n            continue\n          q.append((x, y))\n          grid[x][y] = 2\n      d += 1\n\n    return ans\n", "tests": ["def test_maxDistance():\n    solution = Solution()\n    assert solution.maxDistance([[1, 0, 1], [0, 0, 0], [1, 0, 1]]) == 2", "def test_maxDistance():\n    solution = Solution()\n    assert solution.maxDistance([[1, 1, 1], [1, 1, 1], [1, 1, 0]]) == 1", "def test_maxDistance():\n    solution = Solution()\n    assert solution.maxDistance([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) == 2", "def test_maxDistance():\n    solution = Solution()\n    assert solution.maxDistance([[1, 0, 0], [0, 0, 0], [0, 0, 1]]) == 3", "def test_maxDistance():\n    solution = Solution()\n    assert solution.maxDistance([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == -1", "def test_maxDistance():\n    solution = Solution()\n    assert solution.maxDistance([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == -1", "def test_maxDistance():\n    solution = Solution()\n    assert solution.maxDistance([[0, 1, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 1, 0]]) == 3", "def test_maxDistance():\n    solution = Solution()\n    assert solution.maxDistance([[0, 0], [1, 0]]) == 2", "def test_maxDistance():\n    solution = Solution()\n    assert solution.maxDistance([[0, 1], [0, 0]]) == 2", "def test_maxDistance():\n    solution = Solution()\n    assert solution.maxDistance([[1, 0, 0, 1], [0, 0, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1]]) == 2", "def test_maxDistance():\n    solution = Solution()\n    assert solution.maxDistance([[0, 0, 0, 0], [0, 0, 1, 0], [0, 0, 0, 0], [0, 1, 0, 0]]) == 3", "def test_maxDistance():\n    solution = Solution()\n    assert solution.maxDistance([[1], [0], [0], [0], [1]]) == 2", "def test_maxDistance():\n    solution = Solution()\n    assert solution.maxDistance([[0, 0, 0], [0, 1, 0], [1, 0, 0]]) == 2", "def test_maxDistance():\n    solution = Solution()\n    assert solution.maxDistance([[0, 0, 0, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]) == 6", "def test_maxDistance():\n    solution = Solution()\n    assert solution.maxDistance([[1, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 1]]) == 4", "def test_maxDistance():\n    solution = Solution()\n    assert solution.maxDistance([[0, 1, 0], [0, 0, 0], [0, 0, 1]]) == 2", "def test_maxDistance():\n    solution = Solution()\n    assert solution.maxDistance([[0, 1, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 1], [0, 0, 0, 0, 0]]) == 5", "def test_maxDistance():\n    solution = Solution()\n    assert solution.maxDistance([[0, 0, 0, 0], [0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 0]]) == 4", "def test_maxDistance():\n    solution = Solution()\n    assert solution.maxDistance([[1, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 0, 0, 0]]) == 3", "def test_maxDistance():\n    solution = Solution()\n    assert solution.maxDistance([[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]) == 4"]}
{"task_num": 1202, "task_title": "Smallest String With Swaps", "func_name": "smallestStringWithSwaps", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n    ans = ''\n    uf = UnionFind(len(s))\n    map = collections.defaultdict(list)\n\n    for a, b in pairs:\n      uf.unionByRank(a, b)\n\n    for i, c in enumerate(s):\n      map[uf.find(i)].append(c)\n\n    for key in map.keys():\n      map[key].sort(reverse=True)\n\n    for i in range(len(s)):\n      ans += map[uf.find(i)].pop()\n\n    return ans\n", "tests": ["def test_smallestStringWithSwaps():\n    solution = Solution()\n    assert solution.smallestStringWithSwaps('dcab', [[0, 3], [1, 2]]) == 'bacd'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    assert solution.smallestStringWithSwaps('cba', [[0, 1], [1, 2], [0, 2]]) == 'abc'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    assert solution.smallestStringWithSwaps('mnop', [[3, 2], [2, 1], [1, 0]]) == 'mnop'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    assert solution.smallestStringWithSwaps('badcfe', [[0, 1], [3, 4], [1, 2], [4, 5]]) == 'abcdef'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    assert solution.smallestStringWithSwaps('zxywvu', [[0, 5], [0, 4], [1, 3]]) == 'uvwxzy'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    assert solution.smallestStringWithSwaps('gfedcba', [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6]]) == 'abcdefg'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    assert solution.smallestStringWithSwaps('hgfedcba', [[0, 7], [1, 6], [2, 5], [3, 4]]) == 'abcdefgh'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    assert solution.smallestStringWithSwaps('zxya', [[0, 1], [1, 2]]) == 'axyz'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    assert solution.smallestStringWithSwaps('abcdef', [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5]]) == 'abcdef'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    assert solution.smallestStringWithSwaps('zyxwvuts', [[0, 7], [1, 6], [2, 5], [3, 4], [4, 3]]) == 'stuvwxyz'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    assert solution.smallestStringWithSwaps('qwerty', [[0, 1], [0, 2], [1, 3], [4, 5]]) == 'ertqwyy'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    assert solution.smallestStringWithSwaps('mnbvcxz', [[0, 2], [1, 3], [4, 6]]) == 'bmnvcxz'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    assert solution.smallestStringWithSwaps('acbd', [[0, 1], [2, 3]]) == 'abcd'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    assert solution.smallestStringWithSwaps('lkjihg', [[1, 2], [2, 3], [3, 4], [4, 5]]) == 'ghijkl'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    assert solution.smallestStringWithSwaps('qazwsxedc', [[0, 8], [1, 7], [2, 6], [3, 5]]) == 'cdeqswxaz'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    assert solution.smallestStringWithSwaps('plmoknijb', [[0, 2], [1, 3], [4, 5], [6, 8]]) == 'ijkmlonpb'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    assert solution.smallestStringWithSwaps('zxcvbnm', [[0, 6], [1, 5], [2, 4]]) == 'mnbvcxz'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    assert solution.smallestStringWithSwaps('ghijkl', [[0, 5], [1, 4], [2, 3], [5, 4]]) == 'ghijkl'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    assert solution.smallestStringWithSwaps('zyxwvut', [[0, 6], [1, 5], [2, 4], [3, 3]]) == 'tuvwxyz'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    assert solution.smallestStringWithSwaps('cabfed', [[0, 2], [1, 3], [4, 5], [2, 4]]) == 'abcdef'"]}
{"task_num": 1210, "task_title": "Minimum Moves to Reach Target with Rotations", "func_name": "minimumMoves", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import IntEnum\n\n\nclass Pos(IntEnum):\n  kHorizontal = 0\n  kVertical = 1\n\n\nclass Solution:\n  def minimumMoves(self, grid: List[List[int]]) -> int:\n    n = len(grid)\n    ans = 0\n\n    q = collections.deque([(0, 0, Pos.kHorizontal)])\n    seen = {(0, 0, Pos.kHorizontal)}\n\n    def canMoveRight(x: int, y: int, pos: Pos) -> bool:\n      if pos == Pos.kHorizontal:\n        return y + 2 < n and not grid[x][y + 2]\n      return y + 1 < n and not grid[x][y + 1] and not grid[x + 1][y + 1]\n\n    def canMoveDown(x: int, y: int, pos: Pos) -> bool:\n      if pos == Pos.kVertical:\n        return x + 2 < n and not grid[x + 2][y]\n      return x + 1 < n and not grid[x + 1][y] and not grid[x + 1][y + 1]\n\n    def canRotateClockwise(x: int, y: int, pos: Pos) -> bool:\n      return pos == Pos.kHorizontal and x + 1 < n and \\\n          not grid[x + 1][y + 1] and not grid[x + 1][y]\n\n    def canRotateCounterclockwise(x: int, y: int, pos: Pos) -> bool:\n      return pos == Pos.kVertical and y + 1 < n and \\\n          not grid[x + 1][y + 1] and not grid[x][y + 1]\n\n    while q:\n      for _ in range(len(q)):\n        x, y, pos = q.popleft()\n        if x == n - 1 and y == n - 2 and pos == Pos.kHorizontal:\n          return ans\n        if canMoveRight(x, y, pos) and (x, y + 1, pos) not in seen:\n          q.append((x, y + 1, pos))\n          seen.add((x, y + 1, pos))\n        if canMoveDown(x, y, pos) and (x + 1, y, pos) not in seen:\n          q.append((x + 1, y, pos))\n          seen.add((x + 1, y, pos))\n        newPos = Pos.kVertical if pos == Pos.kHorizontal else Pos.kHorizontal\n        if (canRotateClockwise(x, y, pos) or canRotateCounterclockwise(x, y, pos)) and (x, y, newPos) not in seen:\n          q.append((x, y, newPos))\n          seen.add((x, y, newPos))\n      ans += 1\n\n    return -1\n", "tests": ["def test_minimumMoves():\n    solution = Solution()", "def test_minimumMoves():\n    solution = Solution()", "def test_minimumMoves():\n    solution = Solution()", "def test_minimumMoves():\n    solution = Solution()", "def test_minimumMoves():\n    solution = Solution()", "def test_minimumMoves():\n    solution = Solution()", "def test_minimumMoves():\n    solution = Solution()", "def test_minimumMoves():\n    solution = Solution()", "def test_minimumMoves():\n    solution = Solution()", "def test_minimumMoves():\n    solution = Solution()", "def test_minimumMoves():\n    solution = Solution()", "def test_minimumMoves():\n    solution = Solution()", "def test_minimumMoves():\n    solution = Solution()", "def test_minimumMoves():\n    solution = Solution()", "def test_minimumMoves():\n    solution = Solution()", "def test_minimumMoves():\n    solution = Solution()", "def test_minimumMoves():\n    solution = Solution()", "def test_minimumMoves():\n    solution = Solution()", "def test_minimumMoves():\n    solution = Solution()", "def test_minimumMoves():\n    solution = Solution()"]}
{"task_num": 1253, "task_title": "Reconstruct a 2-Row Binary Matrix", "func_name": "reconstructMatrix", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def reconstructMatrix(self, upper: int, lower: int, colsum: List[int]) -> List[List[int]]:\n    if upper + lower != sum(colsum):\n      return []\n    if min(upper, lower) < colsum.count(2):\n      return []\n\n    ans = [[0] * len(colsum) for _ in range(2)]\n\n    for j, c in enumerate(colsum):\n      if c == 2:\n        ans[0][j] = 1\n        ans[1][j] = 1\n        upper -= 1\n        lower -= 1\n\n    for j, c in enumerate(colsum):\n      if c == 1 and upper > 0:\n        ans[0][j] = 1\n        c -= 1\n        upper -= 1\n      if c == 1 and lower > 0:\n        ans[1][j] = 1\n        lower -= 1\n\n    return ans\n", "tests": ["def test_reconstructMatrix():\n    solution = Solution()\n    assert solution.reconstructMatrix(2, 3, [2, 2, 1, 1]) == [[1, 1, 0, 0], [1, 1, 1, 1]]", "def test_reconstructMatrix():\n    solution = Solution()\n    assert solution.reconstructMatrix(3, 2, [2, 1, 1, 0]) == [[1, 1, 1, 0], [1, 0, 0, 0]]", "def test_reconstructMatrix():\n    solution = Solution()\n    assert solution.reconstructMatrix(4, 4, [2, 2, 2, 2, 2]) == []", "def test_reconstructMatrix():\n    solution = Solution()\n    assert solution.reconstructMatrix(1, 1, [1, 0, 1]) == [[1, 0, 0], [0, 0, 1]]", "def test_reconstructMatrix():\n    solution = Solution()\n    assert solution.reconstructMatrix(5, 5, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == [[1, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1]]", "def test_reconstructMatrix():\n    solution = Solution()\n    assert solution.reconstructMatrix(3, 3, [2, 2, 2]) == []", "def test_reconstructMatrix():\n    solution = Solution()\n    assert solution.reconstructMatrix(0, 0, [0, 0, 0, 0]) == [[0, 0, 0, 0], [0, 0, 0, 0]]", "def test_reconstructMatrix():\n    solution = Solution()\n    assert solution.reconstructMatrix(2, 1, [1, 1, 0, 2]) == [[1, 1, 0, 1], [0, 0, 0, 1]]", "def test_reconstructMatrix():\n    solution = Solution()\n    assert solution.reconstructMatrix(3, 2, [1, 2, 1, 0, 0]) == [[1, 1, 1, 0, 0], [0, 1, 0, 0, 0]]", "def test_reconstructMatrix():\n    solution = Solution()\n    assert solution.reconstructMatrix(2, 2, [2, 1, 1, 1]) == [[1, 1, 0, 0], [1, 0, 1, 1]]", "def test_reconstructMatrix():\n    solution = Solution()\n    assert solution.reconstructMatrix(3, 4, [1, 1, 1, 1, 1, 1, 1]) == []", "def test_reconstructMatrix():\n    solution = Solution()\n    assert solution.reconstructMatrix(3, 3, [0, 1, 1, 0, 2, 1]) == [[0, 1, 1, 0, 1, 0], [0, 0, 0, 0, 1, 1]]", "def test_reconstructMatrix():\n    solution = Solution()\n    assert solution.reconstructMatrix(1, 0, [1, 0, 0]) == [[1, 0, 0], [0, 0, 0]]", "def test_reconstructMatrix():\n    solution = Solution()\n    assert solution.reconstructMatrix(2, 0, [2, 0, 0]) == []", "def test_reconstructMatrix():\n    solution = Solution()\n    assert solution.reconstructMatrix(4, 2, [2, 1, 1, 1, 0]) == [[1, 1, 1, 1, 0], [1, 0, 0, 0, 0]]", "def test_reconstructMatrix():\n    solution = Solution()\n    assert solution.reconstructMatrix(0, 3, [1, 1, 1]) == [[0, 0, 0], [1, 1, 1]]", "def test_reconstructMatrix():\n    solution = Solution()\n    assert solution.reconstructMatrix(3, 3, [1, 2, 1, 1, 0, 1, 2]) == []", "def test_reconstructMatrix():\n    solution = Solution()\n    assert solution.reconstructMatrix(4, 1, [1, 1, 1, 1, 1]) == [[1, 1, 1, 1, 0], [0, 0, 0, 0, 1]]", "def test_reconstructMatrix():\n    solution = Solution()\n    assert solution.reconstructMatrix(3, 2, [2, 0, 2, 1, 1]) == [[1, 0, 1, 1, 0], [1, 0, 1, 0, 1]]", "def test_reconstructMatrix():\n    solution = Solution()\n    assert solution.reconstructMatrix(2, 2, [0, 1, 1, 2]) == [[0, 1, 1, 1], [0, 0, 0, 1]]"]}
{"task_num": 1254, "task_title": "Number of Closed Islands", "func_name": "closedIsland", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def closedIsland(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n\n    def dfs(i: int, j: int) -> None:\n      if i < 0 or i == m or j < 0 or j == n:\n        return\n      if grid[i][j] == 1:\n        return\n\n      grid[i][j] = 1\n      dfs(i + 1, j)\n      dfs(i - 1, j)\n      dfs(i, j + 1)\n      dfs(i, j - 1)\n\n    for i in range(m):\n      for j in range(n):\n        if i * j == 0 or i == m - 1 or j == n - 1:\n          if grid[i][j] == 0:\n            dfs(i, j)\n\n    ans = 0\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 0:\n          dfs(i, j)\n          ans += 1\n\n    return ans\n", "tests": ["def test_closedIsland():\n    solution = Solution()\n    grid = [[1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 1, 1], [1, 0, 1, 1, 0, 1, 1], [1, 0, 1, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1]]\n    assert solution.closedIsland(grid) == 1", "def test_closedIsland():\n    solution = Solution()\n    grid = [[1, 1, 1, 1], [1, 0, 1, 1], [1, 0, 0, 1], [1, 1, 1, 1]]\n    assert solution.closedIsland(grid) == 1", "def test_closedIsland():\n    solution = Solution()\n    grid = [[1, 0, 1, 1, 1], [0, 0, 1, 0, 1], [1, 1, 1, 0, 1], [1, 0, 0, 0, 1], [1, 1, 1, 1, 1]]\n    assert solution.closedIsland(grid) == 0", "def test_closedIsland():\n    solution = Solution()\n    grid = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]\n    assert solution.closedIsland(grid) == 1", "def test_closedIsland():\n    solution = Solution()\n    grid = [[0, 0, 1, 1, 0, 1], [0, 1, 1, 1, 0, 1], [1, 1, 0, 1, 1, 1], [0, 0, 1, 0, 0, 1], [1, 1, 1, 1, 1, 1]]\n    assert solution.closedIsland(grid) == 2", "def test_closedIsland():\n    solution = Solution()\n    grid = [[1, 1, 1, 1, 1], [1, 0, 0, 0, 1], [1, 0, 1, 0, 1], [1, 1, 0, 1, 1], [1, 1, 1, 1, 1]]\n    assert solution.closedIsland(grid) == 0", "def test_closedIsland():\n    solution = Solution()\n    grid = [[1, 1, 1], [0, 0, 1], [1, 0, 1], [1, 1, 1]]\n    assert solution.closedIsland(grid) == 0", "def test_closedIsland():\n    solution = Solution()\n    grid = [[1, 1, 1, 1], [1, 0, 1, 1], [1, 0, 1, 0], [1, 1, 1, 1], [1, 0, 0, 1]]\n    assert solution.closedIsland(grid) == 0", "def test_closedIsland():\n    solution = Solution()\n    grid = [[1, 1, 1, 0, 1], [1, 0, 1, 0, 1], [1, 0, 0, 0, 1], [1, 1, 1, 1, 1]]\n    assert solution.closedIsland(grid) == 0", "def test_closedIsland():\n    solution = Solution()\n    grid = [[1, 1, 1, 1, 1, 1], [1, 0, 1, 0, 1, 1], [1, 0, 1, 0, 1, 1], [1, 0, 1, 0, 0, 1], [1, 1, 1, 1, 1, 1]]\n    assert solution.closedIsland(grid) == 0", "def test_closedIsland():\n    solution = Solution()\n    grid = [[1, 1, 1, 1, 1], [1, 0, 0, 0, 1], [1, 1, 1, 0, 1], [1, 0, 1, 0, 1], [1, 1, 1, 1, 1]]\n    assert solution.closedIsland(grid) == 1", "def test_closedIsland():\n    solution = Solution()\n    grid = [[1, 1, 0, 1], [1, 0, 0, 1], [1, 1, 0, 1], [1, 1, 1, 1]]\n    assert solution.closedIsland(grid) == 0", "def test_closedIsland():\n    solution = Solution()\n    grid = [[1, 1, 1, 1, 1], [1, 0, 1, 0, 1], [1, 1, 1, 1, 1], [1, 0, 0, 0, 1], [1, 1, 1, 1, 1]]\n    assert solution.closedIsland(grid) == 1", "def test_closedIsland():\n    solution = Solution()\n    grid = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]\n    assert solution.closedIsland(grid) == 0", "def test_closedIsland():\n    solution = Solution()\n    grid = [[1, 1, 1, 1, 1], [1, 0, 1, 1, 1], [1, 0, 0, 0, 1], [1, 1, 1, 0, 1], [1, 1, 1, 1, 1]]\n    assert solution.closedIsland(grid) == 1", "def test_closedIsland():\n    solution = Solution()\n    grid = [[1, 1, 1, 1], [1, 0, 0, 1], [1, 1, 0, 1], [1, 0, 1, 1]]\n    assert solution.closedIsland(grid) == 0", "def test_closedIsland():\n    solution = Solution()\n    grid = [[1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 1], [1, 0, 1, 1, 0, 1], [1, 0, 1, 0, 0, 1], [1, 1, 1, 1, 1, 1]]\n    assert solution.closedIsland(grid) == 1", "def test_closedIsland():\n    solution = Solution()\n    grid = [[1, 1, 1, 1, 1], [1, 0, 0, 1, 1], [1, 0, 1, 1, 1], [1, 1, 0, 0, 1], [1, 1, 1, 1, 1]]\n    assert solution.closedIsland(grid) == 0", "def test_closedIsland():\n    solution = Solution()\n    grid = [[1, 1, 1], [1, 0, 1], [1, 0, 1], [1, 1, 1]]\n    assert solution.closedIsland(grid) == 0", "def test_closedIsland():\n    solution = Solution()\n    grid = [[1, 0, 1, 1], [1, 0, 0, 1], [1, 1, 0, 1], [1, 1, 0, 1], [1, 1, 1, 1]]\n    assert solution.closedIsland(grid) == 0"]}
{"task_num": 1263, "task_title": "Minimum Moves to Move a Box to Their Target Location", "func_name": "minPushBox", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\nfrom collections import deque\n\nclass Solution:\n  def minPushBox(self, grid: List[List[str]]) -> int:\n    for i in range(len(grid)):\n      for j in range(len(grid[0])):\n        if grid[i][j] == \"T\":\n          target = (i,j)\n        if grid[i][j] == \"B\":\n          box = (i,j)\n        if grid[i][j] == \"S\":\n          person = (i,j)\n\n    def valid(x,y):\n      return 0<=x<len(grid) and 0<=y<len(grid[0]) and grid[x][y]!='#'\n\n    def check(curr,dest,box):\n      que = deque([curr])\n      v = set()\n      while que:\n        pos = que.popleft()\n        if pos == dest: \n          return True\n        new_pos = [(pos[0]+1,pos[1]),(pos[0]-1,pos[1]),(pos[0],pos[1]+1),(pos[0],pos[1]-1)]\n        for x,y in new_pos:\n          if valid(x,y) and (x,y) not in v and (x,y)!=box:\n            v.add((x,y))\n            que.append((x,y))\n      return False\n\n    q = deque([(0,box,person)])\n    vis = {box+person}\n    while q :\n      dist, box, person = q.popleft()\n      if box == target:\n        return dist\n\n      b_coord = [(box[0]+1,box[1]),(box[0]-1,box[1]),(box[0],box[1]+1),(box[0],box[1]-1)]\n      p_coord = [(box[0]-1,box[1]),(box[0]+1,box[1]),(box[0],box[1]-1),(box[0],box[1]+1)]\n\n      for new_box,new_person in zip(b_coord,p_coord): \n        if valid(*new_box) and new_box+box not in vis:\n          if valid(*new_person) and check(person,new_person,box):\n            vis.add(new_box+box)\n            q.append((dist+1,new_box,box))\n\n    return -1\n", "tests": ["def test_minPushBox():\n    solution = Solution()\n    grid = [['#', '#', '#', '#', '#', '#'], ['#', 'T', '#', '#', '#', '#'], ['#', '.', '.', 'B', '.', '#'], ['#', '.', '#', '#', '.', '#'], ['#', '.', '.', '.', 'S', '#'], ['#', '#', '#', '#', '#', '#']]\n    assert solution.minPushBox(grid) == 3", "def test_minPushBox():\n    solution = Solution()\n    grid = [['#', '#', '#', '#', '#', '#', '#'], ['#', 'T', '#', '.', '.', '.', '#'], ['#', '.', '#', 'B', '#', '.', '#'], ['#', '.', '.', '.', '.', '.', '#'], ['#', '.', '#', '#', '#', '.', '#'], ['#', '.', '.', 'S', '.', '.', '#'], ['#', '#', '#', '#', '#', '#', '#']]\n    assert solution.minPushBox(grid) == -1", "def test_minPushBox():\n    solution = Solution()\n    grid = [['#', '#', '#', '#', '#', '#', '#', '#'], ['#', 'S', '.', '.', '#', '#', '#', '#'], ['#', '.', '#', 'B', '.', '.', '.', '#'], ['#', '.', '.', '.', '#', '#', '.', '#'], ['#', '#', '#', '#', '.', 'T', '.', '#'], ['#', '#', '#', '#', '#', '#', '#', '#']]\n    assert solution.minPushBox(grid) == 5", "def test_minPushBox():\n    solution = Solution()\n    grid = [['#', '#', '#', '#', '#'], ['#', 'T', '.', 'B', '#'], ['#', '.', '.', '.', '#'], ['#', '.', 'S', '.', '#'], ['#', '#', '#', '#', '#']]\n    assert solution.minPushBox(grid) == 1", "def test_minPushBox():\n    solution = Solution()\n    grid = [['#', '#', '#', '#', '#', '#', '#'], ['#', 'T', '.', '.', '.', '.', '#'], ['#', '.', '#', '#', '#', 'B', '#'], ['#', '.', '.', '.', '.', '.', '#'], ['#', '.', '#', '#', '#', '.', '#'], ['#', '.', 'S', '.', '.', '.', '#'], ['#', '#', '#', '#', '#', '#', '#']]\n    assert solution.minPushBox(grid) == 7", "def test_minPushBox():\n    solution = Solution()\n    grid = [['#', '#', '#', '#', '#', '#'], ['#', 'S', '.', '.', '.', '#'], ['#', '#', '#', '#', '.', '#'], ['#', 'B', '.', 'T', '.', '#'], ['#', '.', '.', '.', '.', '#'], ['#', '#', '#', '#', '#', '#']]\n    assert solution.minPushBox(grid) == -1", "def test_minPushBox():\n    solution = Solution()\n    grid = [['#', '#', '#', '#', '#', '#'], ['#', 'S', '.', '#', 'B', '#'], ['#', '.', '.', '#', '.', '#'], ['#', '#', '#', '#', '.', '#'], ['#', 'T', '.', '.', '.', '#'], ['#', '#', '#', '#', '#', '#']]\n    assert solution.minPushBox(grid) == 2", "def test_minPushBox():\n    solution = Solution()\n    grid = [['#', '#', '#', '#', '#', '#', '#'], ['#', '.', '.', 'T', '.', '.', '#'], ['#', '.', '#', '#', '#', '.', '#'], ['#', '.', '.', 'B', '.', '.', '#'], ['#', '#', '#', '#', '.', '#', '#'], ['#', 'S', '.', '.', '.', '.', '#'], ['#', '#', '#', '#', '#', '#', '#']]\n    assert solution.minPushBox(grid) == 4", "def test_minPushBox():\n    solution = Solution()\n    grid = [['#', '#', '#', '#', '#'], ['#', 'S', '.', '#', '#'], ['#', '.', 'B', '#', '#'], ['#', 'T', '.', '.', '#'], ['#', '#', '#', '#', '#']]\n    assert solution.minPushBox(grid) == 3", "def test_minPushBox():\n    solution = Solution()\n    grid = [['#', '#', '#', '#', '#', '#', '#'], ['#', 'S', '.', '.', '.', '.', '#'], ['#', '.', '#', 'B', '#', '.', '#'], ['#', '.', '#', '#', '#', '.', '#'], ['#', '.', '.', 'T', '.', '.', '#'], ['#', '#', '#', '#', '#', '#', '#']]\n    assert solution.minPushBox(grid) == -1", "def test_minPushBox():\n    solution = Solution()\n    grid = [['#', '#', '#', '#', '#', '#', '#', '#'], ['#', '.', '.', '.', 'S', '.', '.', '#'], ['#', '.', '#', '#', '#', '#', '.', '#'], ['#', '.', '#', 'B', '.', '.', '.', '#'], ['#', '.', '#', '#', '#', '.', '#', '#'], ['#', '.', '.', '.', '.', 'T', '.', '#'], ['#', '#', '#', '#', '#', '#', '#', '#']]\n    assert solution.minPushBox(grid) == 6", "def test_minPushBox():\n    solution = Solution()\n    grid = [['#', '#', '#', '#', '#'], ['#', 'S', '.', 'B', '#'], ['#', '.', '.', '.', '#'], ['#', '#', 'T', '.', '#'], ['#', '#', '#', '#', '#']]\n    assert solution.minPushBox(grid) == 2", "def test_minPushBox():\n    solution = Solution()\n    grid = [['#', '#', '#', '#', '#', '#'], ['#', 'S', '.', '.', '.', '#'], ['#', '.', '.', 'B', '.', '#'], ['#', '.', '.', '.', 'T', '#'], ['#', '#', '#', '#', '#', '#']]\n    assert solution.minPushBox(grid) == 3", "def test_minPushBox():\n    solution = Solution()\n    grid = [['#', '#', '#', '#', '#', '#', '#', '#'], ['#', '.', '.', '.', '.', '.', 'S', '#'], ['#', '#', '#', '#', '#', '.', '#', '#'], ['#', '.', '.', '.', '#', '.', '.', '#'], ['#', '.', '#', 'B', '#', 'T', '.', '#'], ['#', '.', '.', '.', '.', '.', '.', '#'], ['#', '#', '#', '#', '#', '#', '#', '#']]\n    assert solution.minPushBox(grid) == 5", "def test_minPushBox():\n    solution = Solution()\n    grid = [['#', '#', '#', '#', '#', '#', '#', '#'], ['#', 'S', '.', '.', '.', '.', '.', '#'], ['#', '.', '#', '#', '#', '#', '.', '#'], ['#', '.', '.', '.', '.', '#', 'B', '#'], ['#', '#', '#', '#', '.', '#', '.', '#'], ['#', 'T', '.', '.', '.', '.', '.', '#'], ['#', '#', '#', '#', '#', '#', '#', '#']]\n    assert solution.minPushBox(grid) == 7", "def test_minPushBox():\n    solution = Solution()\n    grid = [['#', '#', '#', '#', '#', '#', '#'], ['#', 'B', '#', '.', '.', 'T', '#'], ['#', '.', '#', '.', '#', '.', '#'], ['#', 'S', '.', '.', '#', '.', '#'], ['#', '#', '#', '#', '#', '#', '#']]\n    assert solution.minPushBox(grid) == -1", "def test_minPushBox():\n    solution = Solution()\n    grid = [['#', '#', '#', '#', '#', '#', '#'], ['#', 'S', '.', '.', '#', '#', '#'], ['#', '.', '#', 'B', '.', '.', '#'], ['#', '#', '.', '.', '#', 'T', '#'], ['#', '#', '#', '#', '#', '#', '#']]\n    assert solution.minPushBox(grid) == -1", "def test_minPushBox():\n    solution = Solution()\n    grid = [['#', '#', '#', '#', '#', '#', '#'], ['#', '.', '.', 'B', '.', '.', '#'], ['#', 'S', '#', '#', '#', '.', '#'], ['#', '.', '.', '.', '.', '.', '#'], ['#', 'T', '.', '#', '#', '.', '#'], ['#', '#', '#', '#', '#', '#', '#']]\n    assert solution.minPushBox(grid) == 3", "def test_minPushBox():\n    solution = Solution()\n    grid = [['#', '#', '#', '#', '#', '#', '#'], ['#', '#', 'S', '#', '#', '#', '#'], ['#', '#', 'B', '#', 'T', '#', '#'], ['#', '#', '.', '#', '.', '#', '#'], ['#', '#', '#', '#', '#', '#', '#']]\n    assert solution.minPushBox(grid) == -1", "def test_minPushBox():\n    solution = Solution()\n    grid = [['#', '#', '#', '#', '#', '#', '#', '#'], ['#', 'S', '.', '.', '.', 'B', '.', '#'], ['#', '.', '.', '#', '.', '.', '.', '#'], ['#', '.', '#', '#', '#', '.', 'T', '#'], ['#', '.', '.', '.', '.', '.', '.', '#'], ['#', '#', '#', '#', '#', '#', '#', '#']]\n    assert solution.minPushBox(grid) == 4"]}
{"task_num": 1267, "task_title": "Count Servers that Communicate", "func_name": "countServers", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countServers(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    ans = 0\n    rows = [0] * m\n    cols = [0] * n\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1:\n          rows[i] += 1\n          cols[j] += 1\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1 and (rows[i] > 1 or cols[j] > 1):\n          ans += 1\n\n    return ans\n", "tests": ["def test_countServers():\n    solution = Solution()\n    grid = [[1, 0], [1, 1]]\n    assert solution.countServers(grid) == 3", "def test_countServers():\n    solution = Solution()\n    grid = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    assert solution.countServers(grid) == 0", "def test_countServers():\n    solution = Solution()\n    grid = [[1, 0, 1], [0, 0, 0], [1, 0, 1]]\n    assert solution.countServers(grid) == 4", "def test_countServers():\n    solution = Solution()\n    grid = [[1, 1, 0], [0, 0, 0], [0, 1, 1]]\n    assert solution.countServers(grid) == 4", "def test_countServers():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 1, 0], [1, 0, 0]]\n    assert solution.countServers(grid) == 0", "def test_countServers():\n    solution = Solution()\n    grid = [[1, 0, 0, 1], [0, 0, 0, 0], [1, 1, 1, 0]]\n    assert solution.countServers(grid) == 6", "def test_countServers():\n    solution = Solution()\n    grid = [[0, 0, 1, 0], [1, 0, 1, 0], [0, 0, 0, 0], [0, 1, 0, 1]]\n    assert solution.countServers(grid) == 4", "def test_countServers():\n    solution = Solution()\n    grid = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]\n    assert solution.countServers(grid) == 8", "def test_countServers():\n    solution = Solution()\n    grid = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 1], [0, 0, 0, 0]]\n    assert solution.countServers(grid) == 0", "def test_countServers():\n    solution = Solution()\n    grid = [[1, 0, 0], [1, 0, 0], [0, 0, 1]]\n    assert solution.countServers(grid) == 2", "def test_countServers():\n    solution = Solution()\n    grid = [[1, 0, 1, 0], [0, 0, 0, 0], [0, 1, 0, 1], [0, 0, 0, 0]]\n    assert solution.countServers(grid) == 4", "def test_countServers():\n    solution = Solution()\n    grid = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 0], [0, 0, 1, 0]]\n    assert solution.countServers(grid) == 0", "def test_countServers():\n    solution = Solution()\n    grid = [[0, 1, 0, 1], [0, 0, 0, 0], [1, 0, 0, 0], [1, 0, 1, 0]]\n    assert solution.countServers(grid) == 5", "def test_countServers():\n    solution = Solution()\n    grid = [[0, 0, 0], [1, 1, 1], [0, 0, 0]]\n    assert solution.countServers(grid) == 3", "def test_countServers():\n    solution = Solution()\n    grid = [[1, 0], [0, 1], [1, 0], [0, 1]]\n    assert solution.countServers(grid) == 0", "def test_countServers():\n    solution = Solution()\n    grid = [[1, 1, 0], [0, 1, 0], [0, 0, 0]]\n    assert solution.countServers(grid) == 3", "def test_countServers():\n    solution = Solution()\n    grid = [[0, 0, 1], [1, 0, 1], [0, 1, 0], [1, 0, 0]]\n    assert solution.countServers(grid) == 4", "def test_countServers():\n    solution = Solution()\n    grid = [[0, 1], [1, 1], [1, 0]]\n    assert solution.countServers(grid) == 4", "def test_countServers():\n    solution = Solution()\n    grid = [[0, 0, 0, 0], [1, 1, 1, 0], [0, 0, 0, 0]]\n    assert solution.countServers(grid) == 3", "def test_countServers():\n    solution = Solution()\n    grid = [[1, 0, 0, 0], [0, 0, 0, 1], [0, 1, 0, 0], [0, 0, 1, 0]]\n    assert solution.countServers(grid) == 0"]}
{"task_num": 1284, "task_title": "Minimum Number of Flips to Convert Binary Matrix to Zero Matrix", "func_name": "minFlips", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minFlips(self, mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    hash = self._getHash(mat, m, n)\n    if hash == 0:\n      return 0\n\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    step = 0\n    q = collections.deque([hash])\n    seen = {hash}\n\n    while q:\n      step += 1\n      for _ in range(len(q)):\n        curr = q.popleft()\n        for i in range(m):\n          for j in range(n):\n            next = curr ^ 1 << (i * n + j)\n            for dx, dy in dirs:\n              x = i + dx\n              y = j + dy\n              if x < 0 or x == m or y < 0 or y == n:\n                continue\n              next ^= 1 << (x * n + y)\n            if next == 0:\n              return step\n            if next in seen:\n              continue\n            q.append(next)\n            seen.add(next)\n\n    return -1\n\n  def _getHash(self, mat: List[List[int]], m: int, n: int) -> int:\n    hash = 0\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j]:\n          hash |= 1 << (i * n + j)\n    return hash\n", "tests": ["def test_minFlips():\n    solution = Solution()\n    assert solution.minFlips([[0, 1], [1, 0]]) == 3", "def test_minFlips():\n    solution = Solution()\n    assert solution.minFlips([[1, 1], [1, 1]]) == 4", "def test_minFlips():\n    solution = Solution()\n    assert solution.minFlips([[0]]) == 0", "def test_minFlips():\n    solution = Solution()\n    assert solution.minFlips([[1, 0, 1], [1, 1, 1], [0, 1, 0]]) == 6", "def test_minFlips():\n    solution = Solution()\n    assert solution.minFlips([[0, 0], [0, 1]]) == 3", "def test_minFlips():\n    solution = Solution()\n    assert solution.minFlips([[1]]) == 1", "def test_minFlips():\n    solution = Solution()\n    assert solution.minFlips([[0, 0, 0], [0, 0, 0], [1, 0, 0]]) == 1", "def test_minFlips():\n    solution = Solution()\n    assert solution.minFlips([[1, 1, 1], [0, 1, 0], [1, 1, 1]]) == 2", "def test_minFlips():\n    solution = Solution()\n    assert solution.minFlips([[1, 0], [0, 1], [1, 1]]) == -1", "def test_minFlips():\n    solution = Solution()\n    assert solution.minFlips([[0, 1, 0], [1, 0, 1], [0, 1, 0]]) == 1", "def test_minFlips():\n    solution = Solution()\n    assert solution.minFlips([[1, 0, 1], [0, 1, 0], [1, 0, 1]]) == -1", "def test_minFlips():\n    solution = Solution()\n    assert solution.minFlips([[0, 0, 1], [1, 1, 0], [0, 0, 0]]) == 2", "def test_minFlips():\n    solution = Solution()\n    assert solution.minFlips([[1, 0], [1, 1]]) == 2", "def test_minFlips():\n    solution = Solution()\n    assert solution.minFlips([[0, 1, 1], [1, 0, 0]]) == 3", "def test_minFlips():\n    solution = Solution()\n    assert solution.minFlips([[1, 1, 0], [0, 0, 1], [1, 1, 0]]) == 3", "def test_minFlips():\n    solution = Solution()\n    assert solution.minFlips([[1, 0, 0], [1, 1, 0], [0, 1, 1]]) == 4", "def test_minFlips():\n    solution = Solution()\n    assert solution.minFlips([[1, 1, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1]]) == 4", "def test_minFlips():\n    solution = Solution()\n    assert solution.minFlips([[0, 1], [1, 1], [0, 0]]) == 3", "def test_minFlips():\n    solution = Solution()\n    assert solution.minFlips([[1, 0, 1], [1, 1, 0], [0, 0, 1]]) == 5", "def test_minFlips():\n    solution = Solution()\n    assert solution.minFlips([[0, 1, 0], [1, 1, 1], [0, 1, 0]]) == 1"]}
{"task_num": 1293, "task_title": "Shortest Path in a Grid with Obstacles Elimination", "func_name": "shortestPath", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def shortestPath(self, grid: List[List[int]], k: int) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    if m == 1 and n == 1:\n      return 0\n\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    steps = 0\n    q = collections.deque([(0, 0, k)])\n    seen = {(0, 0, k)}\n\n    while q:\n      steps += 1\n      for _ in range(len(q)):\n        i, j, eliminate = q.popleft()\n        for l in range(4):\n          x = i + dirs[l][0]\n          y = j + dirs[l][1]\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if x == m - 1 and y == n - 1:\n            return steps\n          if grid[x][y] == 1 and eliminate == 0:\n            continue\n          newEliminate = eliminate - grid[x][y]\n          if (x, y, newEliminate) in seen:\n            continue\n          q.append((x, y, newEliminate))\n          seen.add((x, y, newEliminate))\n\n    return -1\n", "tests": ["def test_shortestPath():\n    solution = Solution()\n    grid = [[0, 1, 1], [1, 1, 0], [1, 0, 0]]\n    k = 1\n    assert solution.shortestPath(grid, k) == 4", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0, 0, 0], [1, 1, 0], [1, 0, 0]]\n    k = 1\n    assert solution.shortestPath(grid, k) == 4", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0, 1, 0], [1, 1, 1], [0, 0, 0]]\n    k = 2\n    assert solution.shortestPath(grid, k) == 6", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0, 0], [1, 0]]\n    k = 0\n    assert solution.shortestPath(grid, k) == 2", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0, 1, 1], [0, 1, 0], [0, 0, 0]]\n    k = 1\n    assert solution.shortestPath(grid, k) == 5", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 1, 1], [1, 1, 0]]\n    k = 1\n    assert solution.shortestPath(grid, k) == -1", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0]]\n    k = 0\n    assert solution.shortestPath(grid, k) == 0", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0, 1], [1, 0]]\n    k = 2\n    assert solution.shortestPath(grid, k) == 2", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0, 1, 0], [1, 1, 0], [1, 0, 0], [0, 0, 0]]\n    k = 3\n    assert solution.shortestPath(grid, k) == 5", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0, 0, 1], [1, 0, 1], [1, 1, 0]]\n    k = 0\n    assert solution.shortestPath(grid, k) == 4", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0, 0, 0, 0], [1, 1, 1, 0], [0, 0, 0, 0], [0, 1, 1, 1], [0, 0, 0, 0]]\n    k = 1\n    assert solution.shortestPath(grid, k) == 7", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0, 1, 0], [0, 1, 0], [0, 1, 0], [0, 0, 0]]\n    k = 1\n    assert solution.shortestPath(grid, k) == 7", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0, 0, 1], [1, 1, 0], [0, 1, 0], [0, 0, 0]]\n    k = 2\n    assert solution.shortestPath(grid, k) == 5", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0, 1, 1, 0], [1, 0, 0, 1], [1, 1, 0, 0], [0, 0, 0, 0]]\n    k = 3\n    assert solution.shortestPath(grid, k) == 6", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0, 1], [0, 1], [0, 0]]\n    k = 1\n    assert solution.shortestPath(grid, k) == 3", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0, 0, 1, 0], [0, 1, 1, 0], [1, 1, 0, 0]]\n    k = 1\n    assert solution.shortestPath(grid, k) == -1", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0, 1, 0, 0], [1, 0, 1, 1], [0, 1, 0, 0], [1, 1, 0, 0]]\n    k = 2\n    assert solution.shortestPath(grid, k) == 6", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0, 0, 0], [1, 1, 1], [0, 0, 0], [1, 1, 0]]\n    k = 1\n    assert solution.shortestPath(grid, k) == -1", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0, 1, 0], [0, 0, 1], [1, 0, 0]]\n    k = 2\n    assert solution.shortestPath(grid, k) == 4", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0, 0, 0], [1, 1, 1], [0, 1, 0]]\n    k = 0\n    assert solution.shortestPath(grid, k) == 5"]}
{"task_num": 1301, "task_title": "Number of Paths with Max Score", "func_name": "pathsWithMaxScore", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def pathsWithMaxScore(self, board: List[str]) -> List[int]:\n    kMod = 1_000_000_007\n    n = len(board)\n    dirs = ((0, 1), (1, 0), (1, 1))\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    count = [[0] * (n + 1) for _ in range(n + 1)]\n\n    dp[0][0] = 0\n    dp[n - 1][n - 1] = 0\n    count[n - 1][n - 1] = 1\n\n    for i in reversed(range(n)):\n      for j in reversed(range(n)):\n        if board[i][j] == 'S' or board[i][j] == 'X':\n          continue\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if dp[i][j] < dp[x][y]:\n            dp[i][j] = dp[x][y]\n            count[i][j] = count[x][y]\n          elif dp[i][j] == dp[x][y]:\n            count[i][j] += count[x][y]\n            count[i][j] %= kMod\n\n        if dp[i][j] != -1 and board[i][j] != 'E':\n          dp[i][j] += int(board[i][j])\n          dp[i][j] %= kMod\n\n    return [dp[0][0], count[0][0]]\n", "tests": ["def test_pathsWithMaxScore():\n    solution = Solution()\n    board = ['E23', '2X2', '12S']\n    assert solution.pathsWithMaxScore(board) == [7, 1]", "def test_pathsWithMaxScore():\n    solution = Solution()\n    board = ['E12', '1X1', '21S']\n    assert solution.pathsWithMaxScore(board) == [4, 2]", "def test_pathsWithMaxScore():\n    solution = Solution()\n    board = ['E11', 'XXX', '11S']\n    assert solution.pathsWithMaxScore(board) == [0, 0]", "def test_pathsWithMaxScore():\n    solution = Solution()\n    board = ['E3', 'XS']\n    assert solution.pathsWithMaxScore(board) == [0, 0]", "def test_pathsWithMaxScore():\n    solution = Solution()\n    board = ['E2', '23', '2S']\n    assert solution.pathsWithMaxScore(board) == [5, 1]", "def test_pathsWithMaxScore():\n    solution = Solution()\n    board = ['EX', 'XS']\n    assert solution.pathsWithMaxScore(board) == [0, 0]", "def test_pathsWithMaxScore():\n    solution = Solution()\n    board = ['E1X1', '11X1', '111X', '1S11']\n    assert solution.pathsWithMaxScore(board) == [4, 1]", "def test_pathsWithMaxScore():\n    solution = Solution()\n    board = ['EX', '1S']\n    assert solution.pathsWithMaxScore(board) == [1, 1]", "def test_pathsWithMaxScore():\n    solution = Solution()\n    board = ['E111', '1X1X', '1X11', '11XS']\n    assert solution.pathsWithMaxScore(board) == [5, 1]", "def test_pathsWithMaxScore():\n    solution = Solution()\n    board = ['E1111', '11111', '11111', '11111', '1111S']\n    assert solution.pathsWithMaxScore(board) == [8, 10]", "def test_pathsWithMaxScore():\n    solution = Solution()\n    board = ['E234', '3412', '4123', 'X2S1']\n    assert solution.pathsWithMaxScore(board) == [9, 1]", "def test_pathsWithMaxScore():\n    solution = Solution()\n    board = ['E1X', '1X1', 'X1S']\n    assert solution.pathsWithMaxScore(board) == [0, 0]", "def test_pathsWithMaxScore():\n    solution = Solution()\n    board = ['E345', '23X2', 'XX32', '543S']\n    assert solution.pathsWithMaxScore(board) == [12, 1]", "def test_pathsWithMaxScore():\n    solution = Solution()\n    board = ['EXX', '21X', 'X2S']\n    assert solution.pathsWithMaxScore(board) == [0, 0]", "def test_pathsWithMaxScore():\n    solution = Solution()\n    board = ['E987', '6543', '3210', '765S']\n    assert solution.pathsWithMaxScore(board) == [30, 1]", "def test_pathsWithMaxScore():\n    solution = Solution()\n    board = ['E5X', 'X2X', '3XS']\n    assert solution.pathsWithMaxScore(board) == [0, 0]", "def test_pathsWithMaxScore():\n    solution = Solution()\n    board = ['E22X', '213X', 'X113', '2S11']\n    assert solution.pathsWithMaxScore(board) == [9, 2]", "def test_pathsWithMaxScore():\n    solution = Solution()\n    board = ['E2X2', '2X2X', '2X2X', '2S22']\n    assert solution.pathsWithMaxScore(board) == [0, 0]", "def test_pathsWithMaxScore():\n    solution = Solution()\n    board = ['E321', '211X', '1X12', '321S']\n    assert solution.pathsWithMaxScore(board) == [11, 2]", "def test_pathsWithMaxScore():\n    solution = Solution()\n    board = ['E1', 'XS', '21']\n    assert solution.pathsWithMaxScore(board) == [0, 0]"]}
{"task_num": 1334, "task_title": "Find the City With the Smallest Number of Neighbors at a Threshold Distance", "func_name": "findTheCity", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -> int:\n    ans = -1\n    minCitiesCount = n\n    dist = self._floydWarshall(n, edges, distanceThreshold)\n\n    for i in range(n):\n      citiesCount = sum(dist[i][j] <= distanceThreshold for j in range(n))\n      if citiesCount <= minCitiesCount:\n        ans = i\n        minCitiesCount = citiesCount\n\n    return ans\n\n  def _floydWarshall(self, n: int, edges: List[List[int]], distanceThreshold: int) -> List[List[int]]:\n    dist = [[distanceThreshold + 1] * n for _ in range(n)]\n\n    for i in range(n):\n      dist[i][i] = 0\n\n    for u, v, w in edges:\n      dist[u][v] = w\n      dist[v][u] = w\n\n    for k in range(n):\n      for i in range(n):\n        for j in range(n):\n          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    return dist\n", "tests": ["def test_findTheCity():\n    solution = Solution()\n    assert solution.findTheCity(4, [[0, 1, 3], [1, 2, 1], [2, 3, 1], [0, 3, 4]], 4) == 3", "def test_findTheCity():\n    solution = Solution()\n    assert solution.findTheCity(5, [[0, 1, 2], [1, 2, 3], [2, 3, 1], [3, 4, 1], [0, 4, 5]], 7) == 0", "def test_findTheCity():\n    solution = Solution()\n    assert solution.findTheCity(6, [[0, 1, 2], [0, 2, 5], [1, 2, 1], [2, 3, 2], [3, 4, 1], [4, 5, 2]], 3) == 2", "def test_findTheCity():\n    solution = Solution()\n    assert solution.findTheCity(3, [[0, 1, 4], [1, 2, 6]], 5) == 0", "def test_findTheCity():\n    solution = Solution()\n    assert solution.findTheCity(7, [[0, 1, 3], [1, 2, 2], [1, 3, 4], [2, 4, 3], [3, 5, 1], [4, 6, 2], [5, 6, 1]], 6) == 6", "def test_findTheCity():\n    solution = Solution()\n    assert solution.findTheCity(4, [[0, 1, 8], [1, 2, 2], [2, 3, 3], [0, 3, 10]], 7) == 2", "def test_findTheCity():\n    solution = Solution()\n    assert solution.findTheCity(5, [[0, 1, 1], [0, 2, 1], [0, 3, 1], [0, 4, 1], [1, 2, 1], [2, 3, 1], [3, 4, 1]], 2) == 4", "def test_findTheCity():\n    solution = Solution()\n    assert solution.findTheCity(8, [[0, 1, 1], [1, 2, 1], [2, 3, 1], [3, 4, 1], [4, 5, 1], [5, 6, 1], [6, 7, 1]], 3) == 3", "def test_findTheCity():\n    solution = Solution()\n    assert solution.findTheCity(3, [[0, 1, 2], [1, 2, 2], [0, 2, 2]], 2) == 2", "def test_findTheCity():\n    solution = Solution()\n    assert solution.findTheCity(6, [[0, 1, 10], [0, 2, 1], [1, 3, 1], [2, 3, 1], [2, 4, 1], [3, 5, 1]], 3) == 2", "def test_findTheCity():\n    solution = Solution()\n    assert solution.findTheCity(5, [[0, 1, 3], [1, 2, 1], [2, 3, 4], [3, 4, 2], [0, 4, 9]], 5) == 1", "def test_findTheCity():\n    solution = Solution()\n    assert solution.findTheCity(4, [[0, 1, 2], [1, 2, 2], [2, 3, 2], [3, 0, 2]], 4) == 3", "def test_findTheCity():\n    solution = Solution()\n    assert solution.findTheCity(7, [[0, 1, 1], [1, 2, 1], [2, 3, 1], [3, 4, 1], [4, 5, 1], [5, 6, 1], [0, 6, 10]], 5) == 5", "def test_findTheCity():\n    solution = Solution()\n    assert solution.findTheCity(5, [[0, 1, 3], [1, 2, 1], [2, 3, 1], [3, 4, 1], [0, 4, 7], [1, 4, 2]], 3) == 3", "def test_findTheCity():\n    solution = Solution()\n    assert solution.findTheCity(6, [[0, 1, 2], [1, 2, 2], [2, 3, 1], [3, 4, 1], [4, 5, 1], [0, 3, 5]], 4) == 2", "def test_findTheCity():\n    solution = Solution()\n    assert solution.findTheCity(4, [[0, 1, 4], [0, 2, 3], [1, 2, 1], [1, 3, 3], [2, 3, 1]], 3) == 3", "def test_findTheCity():\n    solution = Solution()\n    assert solution.findTheCity(3, [[0, 1, 5], [1, 2, 5]], 6) == 1", "def test_findTheCity():\n    solution = Solution()\n    assert solution.findTheCity(7, [[0, 1, 2], [1, 2, 2], [2, 3, 2], [3, 4, 2], [4, 5, 2], [5, 6, 2]], 6) == 3", "def test_findTheCity():\n    solution = Solution()\n    assert solution.findTheCity(10, [[0, 1, 1], [1, 2, 1], [2, 3, 1], [3, 4, 1], [4, 5, 1], [5, 6, 1], [6, 7, 1], [7, 8, 1], [8, 9, 1]], 4) == 4", "def test_findTheCity():\n    solution = Solution()\n    assert solution.findTheCity(5, [[0, 1, 1], [0, 2, 2], [2, 3, 2], [3, 4, 2]], 3) == 0"]}
{"task_num": 1340, "task_title": "Jump Game V", "func_name": "maxJumps", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxJumps(self, arr: List[int], d: int) -> int:\n    n = len(arr)\n    dp = [1] * n\n    stack = []\n\n    for i in range(n + 1):\n      while stack and (i == n or arr[stack[-1]] < arr[i]):\n        indices = [stack.pop()]\n        while stack and arr[stack[-1]] == arr[indices[0]]:\n          indices.append(stack.pop())\n        for j in indices:\n          if i < n and i - j <= d:\n            dp[i] = max(dp[i], dp[j] + 1)\n          if stack and j - stack[-1] <= d:\n            dp[stack[-1]] = max(dp[stack[-1]], dp[j] + 1)\n      stack.append(i)\n\n    return max(dp)\n", "tests": ["def test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([6, 4, 14, 6, 8, 13, 9, 7, 10, 6, 12], 2) == 4", "def test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([3, 3, 3, 3, 3], 3) == 1", "def test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([7, 1, 7, 1, 7, 1], 1) == 2", "def test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([10, 9, 8, 7, 6, 5], 3) == 1", "def test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([1, 5, 3, 4, 2, 8, 6, 7], 3) == 4", "def test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([1, 2, 3, 10, 3, 2, 1], 3) == 5", "def test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([4, 2, 3, 0, 1, 5, 2, 1, 4, 2], 10) == 5", "def test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([3], 1) == 1", "def test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([2, 2, 2, 3, 2, 2, 2], 2) == 3", "def test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([1, 10, 1, 10, 1, 10, 1, 10], 1) == 2", "def test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([1, 2, 3, 4, 3, 2, 1], 2) == 4", "def test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([5, 4, 3, 2, 1], 3) == 1", "def test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([1, 3, 2, 4, 1, 5, 1, 6], 2) == 3", "def test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([1, 1, 1, 1, 1, 5, 1, 1, 1, 1], 4) == 2", "def test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([1, 2, 3, 1, 2, 3, 1, 2, 3], 3) == 3", "def test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([2, 2, 2, 10, 2, 2], 2) == 2", "def test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([1, 3, 2, 4, 2, 5, 2, 6, 2], 2) == 4", "def test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([9], 5) == 1", "def test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([1, 10, 1, 1, 10, 1, 1, 10], 4) == 3", "def test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([7, 1, 7, 1, 7, 1, 7], 2) == 4"]}
{"task_num": 1345, "task_title": "Jump Game IV", "func_name": "minJumps", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minJumps(self, arr: List[int]) -> int:\n    n = len(arr)\n    graph = collections.defaultdict(list)\n    step = 0\n    q = collections.deque([0])\n    seen = {0}\n\n    for i, a in enumerate(arr):\n      graph[a].append(i)\n\n    while q:\n      for _ in range(len(q)):\n        i = q.popleft()\n        if i == n - 1:\n          return step\n        seen.add(i)\n        u = arr[i]\n        if i + 1 < n:\n          graph[u].append(i + 1)\n        if i - 1 >= 0:\n          graph[u].append(i - 1)\n        for v in graph[u]:\n          if v in seen:\n            continue\n          q.append(v)\n        graph[u].clear()\n      step += 1\n", "tests": ["def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([100, -23, -23, 100, 100, 100, 100, 3, 3, 3, 3]) == 2", "def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([7, 6, 9, 6, 9, 6, 9, 7]) == 1", "def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 8", "def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([11, 22, 33, 33, 22, 11, 33, 22, 11]) == 4", "def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([5, 10, 5, 1, 5, 2, 10, 5, 3]) == 3", "def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([4, 4, 2, 2, 2, 4, 4, 4]) == 2", "def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([0, 1, 2, 1, 0, 1, 2, 3, 4, 2, 0]) == 5", "def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([3, 3, 3, 3, 3, 3, 3, 3]) == 1", "def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([1, 2, 1, 2, 1, 2, 1, 0]) == 4", "def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([8, 7, 8, 7, 8, 7, 8, 6, 5, 4, 3, 2, 1]) == 7", "def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([10, 9, 10, 1, 9, 10, 2, 9, 3, 10, 4, 9, 5]) == 4", "def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([1, 1, 1, 1, 1, 1, 1, 0]) == 7", "def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([5, 4, 5, 6, 5, 7, 5, 8, 5, 9]) == 3", "def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([2, 3, 2, 1, 2, 0, 2, 4, 5]) == 6", "def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([1, 3, 1, 4, 1, 5, 1, 6]) == 4", "def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([4, 5, 4, 5, 4, 5, 4, 0]) == 7", "def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([6, 1, 6, 1, 6, 1, 6, 1, 6, 7]) == 2", "def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([8, 8, 7, 7, 6, 6, 5, 5, 4, 4, 3, 3, 2, 2, 1, 1, 0]) == 1", "def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([10, 20, 10, 30, 10, 40, 10, 50]) == 3", "def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([1, 0, 1, 2, 1, 3, 1, 4, 1, 5]) == 5"]}
{"task_num": 1377, "task_title": "Frog Position After T Seconds", "func_name": "frogPosition", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n    tree = [[] for _ in range(n + 1)]\n    q = collections.deque([1])\n    seen = [False] * (n + 1)\n    prob = [0] * (n + 1)\n\n    prob[1] = 1\n    seen[1] = True\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    for _ in range(t):\n      for _ in range(len(q)):\n        a = q.popleft()\n        nChildren = sum(not seen[b] for b in tree[a])\n        for b in tree[a]:\n          if seen[b]:\n            continue\n          seen[b] = True\n          prob[b] = prob[a] / nChildren\n          q.append(b)\n        if nChildren > 0:\n          prob[a] = 0\n\n    return prob[target]\n", "tests": ["def test_frogPosition():\n    solution = Solution()\n    assert abs(solution.frogPosition(7, [[1, 2], [1, 3], [2, 4], [2, 5], [3, 6], [3, 7]], 2, 4) - 0.1666667) < 1e-05", "def test_frogPosition():\n    solution = Solution()\n    assert abs(solution.frogPosition(4, [[1, 2], [2, 3], [3, 4]], 1, 4) - 0.0) < 1e-05", "def test_frogPosition():\n    solution = Solution()\n    assert abs(solution.frogPosition(3, [[1, 2], [1, 3]], 1, 3) - 0.5) < 1e-05", "def test_frogPosition():\n    solution = Solution()\n    assert abs(solution.frogPosition(5, [[1, 2], [1, 3], [3, 4], [3, 5]], 3, 5) - 0.25) < 1e-05", "def test_frogPosition():\n    solution = Solution()\n    assert abs(solution.frogPosition(6, [[1, 2], [1, 3], [2, 4], [2, 5], [3, 6]], 5, 6) - 0.0) < 1e-05", "def test_frogPosition():\n    solution = Solution()\n    assert abs(solution.frogPosition(2, [[1, 2]], 1, 1) - 0.0) < 1e-05", "def test_frogPosition():\n    solution = Solution()\n    assert abs(solution.frogPosition(8, [[1, 2], [1, 3], [2, 4], [2, 5], [3, 6], [3, 7], [6, 8]], 2, 8) - 0.0) < 1e-05", "def test_frogPosition():\n    solution = Solution()\n    assert abs(solution.frogPosition(5, [[1, 2], [2, 3], [3, 4], [4, 5]], 4, 5) - 1.0) < 1e-05", "def test_frogPosition():\n    solution = Solution()\n    assert abs(solution.frogPosition(3, [[1, 2], [2, 3]], 0, 1) - 1.0) < 1e-05", "def test_frogPosition():\n    solution = Solution()\n    assert abs(solution.frogPosition(9, [[1, 2], [1, 3], [2, 4], [2, 5], [3, 6], [3, 7], [6, 8], [8, 9]], 3, 9) - 0.125) < 1e-05", "def test_frogPosition():\n    solution = Solution()\n    assert abs(solution.frogPosition(4, [[1, 2], [1, 3], [1, 4]], 2, 1) - 0.0) < 1e-05", "def test_frogPosition():\n    solution = Solution()\n    assert abs(solution.frogPosition(4, [[1, 2], [2, 3], [3, 4]], 1, 3) - 0.0) < 1e-05", "def test_frogPosition():\n    solution = Solution()\n    assert abs(solution.frogPosition(3, [[1, 2], [2, 3]], 1, 2) - 1.0) < 1e-05", "def test_frogPosition():\n    solution = Solution()\n    assert abs(solution.frogPosition(5, [[1, 2], [1, 3], [1, 4], [1, 5]], 0, 1) - 1.0) < 1e-05", "def test_frogPosition():\n    solution = Solution()\n    assert abs(solution.frogPosition(6, [[1, 2], [2, 3], [2, 4], [4, 5], [4, 6]], 3, 5) - 0.25) < 1e-05", "def test_frogPosition():\n    solution = Solution()\n    assert abs(solution.frogPosition(7, [[1, 2], [1, 3], [1, 4], [3, 5], [3, 6], [4, 7]], 10, 6) - 0.0) < 1e-05", "def test_frogPosition():\n    solution = Solution()\n    assert abs(solution.frogPosition(5, [[1, 2], [1, 3], [3, 4], [4, 5]], 3, 5) - 0.5) < 1e-05", "def test_frogPosition():\n    solution = Solution()\n    assert abs(solution.frogPosition(6, [[1, 2], [2, 3], [2, 4], [4, 5], [5, 6]], 4, 6) - 0.25) < 1e-05", "def test_frogPosition():\n    solution = Solution()\n    assert abs(solution.frogPosition(4, [[1, 2], [2, 3], [3, 4]], 1, 4) - 0.0) < 1e-05", "def test_frogPosition():\n    solution = Solution()\n    assert abs(solution.frogPosition(3, [[1, 2], [1, 3]], 1, 2) - 0.5) < 1e-05"]}
{"task_num": 1417, "task_title": "Reformat The String", "func_name": "reformat", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def reformat(self, s: str) -> str:\n    A=[]\n    for c in s:\n      if c.isalpha():\n        A.append(c)\n    B=[]\n    for c in s:\n      if c.isdigit():\n        B.append(c)\n\n    if len(A) < len(B):\n      A, B = B, A\n    if len(A) - len(B) > 1:\n      return ''\n\n    ans = []\n\n    for i in range(len(B)):\n      ans.append(A[i])\n      ans.append(B[i])\n\n    if len(A) == len(B) + 1:\n      ans.append(A[-1])\n    return ''.join(ans)\n", "tests": ["def test_reformat():\n    solution = Solution()\n    assert solution.reformat('a0b1c2') in {'a0b1c2', '0a1b2c', 'b0a1c2', 'c0a1b2', 'a0c1b2', 'b0c1a2', 'c0b1a2'}", "def test_reformat():\n    solution = Solution()\n    assert solution.reformat('123') == ''", "def test_reformat():\n    solution = Solution()\n    assert solution.reformat('abc') == ''", "def test_reformat():\n    solution = Solution()\n    assert solution.reformat('a1b2') in {'a1b2', '1a2b', 'b1a2', '2a1b'}", "def test_reformat():\n    solution = Solution()\n    assert solution.reformat('') == ''", "def test_reformat():\n    solution = Solution()\n    assert solution.reformat('a') == 'a'", "def test_reformat():\n    solution = Solution()\n    assert solution.reformat('1') == '1'", "def test_reformat():\n    solution = Solution()\n    assert solution.reformat('a1b') in {'a1b', '1ab', 'b1a'}", "def test_reformat():\n    solution = Solution()\n    assert solution.reformat('ab12') in {'a1b2', '1a2b', 'b1a2', '2a1b'}", "def test_reformat():\n    solution = Solution()\n    assert solution.reformat('9z') in {'9z', 'z9'}", "def test_reformat():\n    solution = Solution()\n    assert solution.reformat('z1x2') in {'z1x2', '1z2x', 'x1z2', '2x1z'}", "def test_reformat():\n    solution = Solution()\n    assert solution.reformat('aa11') == ''", "def test_reformat():\n    solution = Solution()\n    assert solution.reformat('a1b2c') in {'a1b2c', '1a2bc', 'b1a2c', 'c1a2b', 'a1c2b', 'b1c2a', 'c1b2a'}", "def test_reformat():\n    solution = Solution()", "def test_reformat():\n    solution = Solution()", "def test_reformat():\n    solution = Solution()", "def test_reformat():\n    solution = Solution()", "def test_reformat():\n    solution = Solution()", "def test_reformat():\n    solution = Solution()", "def test_reformat():\n    solution = Solution()"]}
{"task_num": 1462, "task_title": "Course Schedule IV", "func_name": "checkIfPrerequisite", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:\n    graph = [[] for _ in range(numCourses)]\n    isPrerequisite = [[False] * numCourses for _ in range(numCourses)]\n\n    for u, v in prerequisites:\n      graph[u].append(v)\n\n    for i in range(numCourses):\n      self._dfs(graph, i, isPrerequisite[i])\n\n    return [isPrerequisite[u][v] for u, v in queries]\n\n  def _dfs(self, graph: List[List[int]], u: int, used: List[bool]) -> None:\n    for v in graph[u]:\n      if used[v]:\n        continue\n      used[v] = True\n      self._dfs(graph, v, used)\n", "tests": ["def test_checkIfPrerequisite():\n    solution = Solution()\n    numCourses = 4\n    prerequisites = [[0, 1], [1, 2], [2, 3]]\n    queries = [[0, 3], [3, 0], [1, 3], [3, 2]]\n    expected_output = [True, False, True, False]\n    assert solution.checkIfPrerequisite(numCourses, prerequisites, queries) == expected_output", "def test_checkIfPrerequisite():\n    solution = Solution()\n    numCourses = 5\n    prerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\n    queries = [[0, 4], [1, 2], [2, 4], [0, 3], [4, 0]]\n    expected_output = [True, False, False, True, False]\n    assert solution.checkIfPrerequisite(numCourses, prerequisites, queries) == expected_output", "def test_checkIfPrerequisite():\n    solution = Solution()\n    numCourses = 6\n    prerequisites = [[2, 5], [0, 5], [0, 4], [1, 4], [3, 2], [5, 1]]\n    queries = [[0, 1], [2, 1], [3, 4], [3, 5], [4, 0], [5, 3]]\n    expected_output = [True, True, False, True, False, False]\n    assert solution.checkIfPrerequisite(numCourses, prerequisites, queries) == expected_output", "def test_checkIfPrerequisite():\n    solution = Solution()\n    numCourses = 3\n    prerequisites = [[0, 1], [1, 2]]\n    queries = [[0, 2], [1, 0], [2, 1], [0, 0], [1, 2]]\n    expected_output = [True, False, False, False, True]\n    assert solution.checkIfPrerequisite(numCourses, prerequisites, queries) == expected_output", "def test_checkIfPrerequisite():\n    solution = Solution()\n    numCourses = 7\n    prerequisites = [[0, 1], [1, 2], [2, 3], [4, 5], [5, 6]]\n    queries = [[0, 3], [3, 0], [4, 6], [6, 4], [1, 3], [2, 5]]\n    expected_output = [True, False, True, False, True, False]\n    assert solution.checkIfPrerequisite(numCourses, prerequisites, queries) == expected_output", "def test_checkIfPrerequisite():\n    solution = Solution()\n    numCourses = 8\n    prerequisites = [[0, 2], [1, 2], [2, 4], [3, 4], [5, 6], [6, 7]]\n    queries = [[0, 4], [1, 4], [5, 7], [2, 3], [3, 7], [6, 5]]\n    expected_output = [True, True, True, False, False, False]\n    assert solution.checkIfPrerequisite(numCourses, prerequisites, queries) == expected_output", "def test_checkIfPrerequisite():\n    solution = Solution()\n    numCourses = 5\n    prerequisites = [[0, 2], [2, 3], [3, 4], [1, 4]]\n    queries = [[0, 4], [1, 3], [0, 3], [2, 4], [3, 2], [4, 0]]\n    expected_output = [True, False, True, True, False, False]\n    assert solution.checkIfPrerequisite(numCourses, prerequisites, queries) == expected_output", "def test_checkIfPrerequisite():\n    solution = Solution()\n    numCourses = 6\n    prerequisites = [[1, 3], [2, 3], [3, 4], [4, 5], [0, 5]]\n    queries = [[1, 5], [2, 5], [0, 3], [1, 4], [5, 0], [0, 4]]\n    expected_output = [True, True, False, True, False, True]\n    assert solution.checkIfPrerequisite(numCourses, prerequisites, queries) == expected_output", "def test_checkIfPrerequisite():\n    solution = Solution()\n    numCourses = 4\n    prerequisites = [[0, 1], [1, 2], [0, 3]]\n    queries = [[0, 2], [1, 3], [3, 1], [2, 0], [0, 1]]\n    expected_output = [True, False, False, False, True]\n    assert solution.checkIfPrerequisite(numCourses, prerequisites, queries) == expected_output", "def test_checkIfPrerequisite():\n    solution = Solution()\n    numCourses = 5\n    prerequisites = [[1, 2], [2, 3], [2, 4], [3, 4]]\n    queries = [[1, 4], [0, 2], [2, 3], [3, 1], [4, 2]]\n    expected_output = [True, False, True, False, False]\n    assert solution.checkIfPrerequisite(numCourses, prerequisites, queries) == expected_output", "def test_checkIfPrerequisite():\n    solution = Solution()\n    numCourses = 7\n    prerequisites = [[0, 1], [1, 2], [2, 3], [4, 5], [5, 6], [3, 5]]\n    queries = [[0, 3], [1, 5], [4, 6], [2, 6], [0, 6], [5, 4]]\n    expected_output = [True, True, True, True, True, False]\n    assert solution.checkIfPrerequisite(numCourses, prerequisites, queries) == expected_output", "def test_checkIfPrerequisite():\n    solution = Solution()\n    numCourses = 6\n    prerequisites = [[0, 1], [1, 4], [2, 5], [3, 5], [0, 3]]\n    queries = [[0, 5], [1, 4], [3, 4], [2, 3], [4, 5], [0, 2]]\n    expected_output = [False, True, False, False, False, False]\n    assert solution.checkIfPrerequisite(numCourses, prerequisites, queries) == expected_output", "def test_checkIfPrerequisite():\n    solution = Solution()\n    numCourses = 5\n    prerequisites = [[0, 2], [2, 4], [1, 3], [3, 4]]\n    queries = [[0, 4], [1, 4], [2, 3], [0, 3], [4, 0]]\n    expected_output = [True, True, False, False, False]\n    assert solution.checkIfPrerequisite(numCourses, prerequisites, queries) == expected_output", "def test_checkIfPrerequisite():\n    solution = Solution()\n    numCourses = 6\n    prerequisites = [[0, 1], [1, 2], [2, 3], [0, 4], [4, 5]]\n    queries = [[0, 5], [1, 3], [3, 1], [2, 0], [5, 4], [4, 3]]\n    expected_output = [True, True, False, False, False, False]\n    assert solution.checkIfPrerequisite(numCourses, prerequisites, queries) == expected_output", "def test_checkIfPrerequisite():\n    solution = Solution()\n    numCourses = 8\n    prerequisites = [[0, 1], [1, 2], [3, 4], [4, 5], [5, 6], [6, 7], [2, 7]]\n    queries = [[0, 7], [3, 6], [1, 5], [5, 1], [2, 6], [7, 0]]\n    expected_output = [True, True, False, False, True, False]\n    assert solution.checkIfPrerequisite(numCourses, prerequisites, queries) == expected_output", "def test_checkIfPrerequisite():\n    solution = Solution()\n    numCourses = 9\n    prerequisites = [[1, 3], [3, 5], [2, 4], [4, 6], [6, 7], [5, 8]]\n    queries = [[1, 8], [2, 7], [3, 6], [5, 4], [7, 2], [0, 3]]\n    expected_output = [True, True, False, False, False, False]\n    assert solution.checkIfPrerequisite(numCourses, prerequisites, queries) == expected_output", "def test_checkIfPrerequisite():\n    solution = Solution()\n    numCourses = 10\n    prerequisites = [[0, 1], [1, 2], [2, 3], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [3, 5]]\n    queries = [[0, 9], [4, 7], [2, 6], [1, 5], [9, 0], [6, 8]]\n    expected_output = [True, True, True, True, False, True]\n    assert solution.checkIfPrerequisite(numCourses, prerequisites, queries) == expected_output", "def test_checkIfPrerequisite():\n    solution = Solution()\n    numCourses = 7\n    prerequisites = [[0, 2], [1, 3], [3, 5], [1, 4], [4, 6]]\n    queries = [[0, 5], [2, 6], [1, 6], [1, 2], [5, 0], [4, 5]]\n    expected_output = [False, False, True, False, False, False]\n    assert solution.checkIfPrerequisite(numCourses, prerequisites, queries) == expected_output", "def test_checkIfPrerequisite():\n    solution = Solution()\n    numCourses = 6\n    prerequisites = [[0, 1], [1, 2], [2, 3], [0, 4], [4, 5]]\n    queries = [[0, 3], [1, 4], [2, 5], [3, 0], [5, 1], [4, 2]]\n    expected_output = [True, False, False, False, False, False]\n    assert solution.checkIfPrerequisite(numCourses, prerequisites, queries) == expected_output", "def test_checkIfPrerequisite():\n    solution = Solution()\n    numCourses = 5\n    prerequisites = [[0, 2], [1, 3], [3, 4]]\n    queries = [[0, 4], [1, 2], [2, 3], [3, 2], [0, 3], [4, 1]]\n    expected_output = [False, False, False, False, False, False]\n    assert solution.checkIfPrerequisite(numCourses, prerequisites, queries) == expected_output"]}
{"task_num": 1489, "task_title": "Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree", "func_name": "findCriticalAndPseudoCriticalEdges", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Union\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n    criticalEdges = []\n    pseudoCriticalEdges = []\n\n    for i in range(len(edges)):\n      edges[i].append(i)\n\n    edges.sort(key=lambda x: x[2])\n\n    def getMSTWeight(firstEdge: List[int], deletedEdgeIndex: int) -> Union[int, float]:\n      mstWeight = 0\n      uf = UnionFind(n)\n\n      if firstEdge:\n        uf.unionByRank(firstEdge[0], firstEdge[1])\n        mstWeight += firstEdge[2]\n\n      for u, v, weight, index in edges:\n        if index == deletedEdgeIndex:\n          continue\n        if uf.find(u) == uf.find(v):\n          continue\n        uf.unionByRank(u, v)\n        mstWeight += weight\n\n      root = uf.find(0)\n      if any(uf.find(i) != root for i in range(n)):\n        return math.inf\n\n      return mstWeight\n\n    mstWeight = getMSTWeight([], -1)\n\n    for edge in edges:\n      index = edge[3]\n      if getMSTWeight([], index) > mstWeight:\n        criticalEdges.append(index)\n      elif getMSTWeight(edge, -1) == mstWeight:\n        pseudoCriticalEdges.append(index)\n\n    return [criticalEdges, pseudoCriticalEdges]\n", "tests": ["def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 1], [0, 2, 1], [1, 2, 1], [1, 3, 1], [2, 3, 1], [3, 4, 1]]\n    result = solution.findCriticalAndPseudoCriticalEdges(n, edges)", "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 1], [1, 2, 1], [2, 3, 1], [0, 3, 1], [0, 2, 2], [1, 3, 2]]\n    result = solution.findCriticalAndPseudoCriticalEdges(n, edges)", "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 2], [1, 2, 3], [0, 2, 1]]\n    result = solution.findCriticalAndPseudoCriticalEdges(n, edges)", "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 6\n    edges = [[0, 1, 2], [0, 2, 2], [0, 3, 2], [0, 4, 2], [0, 5, 2], [1, 2, 3], [3, 4, 3], [4, 5, 3]]\n    result = solution.findCriticalAndPseudoCriticalEdges(n, edges)", "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 1], [0, 2, 2], [0, 3, 2], [1, 4, 3], [2, 4, 3], [3, 4, 3]]\n    result = solution.findCriticalAndPseudoCriticalEdges(n, edges)", "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 7\n    edges = [[0, 1, 1], [1, 2, 1], [2, 3, 1], [3, 4, 1], [4, 5, 1], [5, 6, 1], [0, 6, 2], [0, 4, 2], [1, 5, 2]]\n    result = solution.findCriticalAndPseudoCriticalEdges(n, edges)", "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 1], [1, 2, 2], [2, 3, 3], [0, 3, 4], [0, 2, 2], [1, 3, 3]]\n    result = solution.findCriticalAndPseudoCriticalEdges(n, edges)", "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 1], [0, 2, 1], [1, 2, 1], [0, 1, 2], [1, 2, 2]]\n    result = solution.findCriticalAndPseudoCriticalEdges(n, edges)", "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 5], [0, 2, 3], [1, 2, 4], [1, 3, 2], [2, 3, 1], [3, 4, 2], [2, 4, 7]]\n    result = solution.findCriticalAndPseudoCriticalEdges(n, edges)", "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 6\n    edges = [[0, 1, 1], [0, 2, 1], [0, 3, 1], [1, 3, 1], [2, 3, 1], [3, 4, 1], [3, 5, 1], [4, 5, 2]]\n    result = solution.findCriticalAndPseudoCriticalEdges(n, edges)", "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 4], [0, 2, 6], [1, 2, 5], [1, 3, 3], [2, 3, 7]]\n    result = solution.findCriticalAndPseudoCriticalEdges(n, edges)", "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 1], [1, 2, 1], [2, 3, 1], [0, 2, 2], [1, 3, 2], [0, 3, 3]]\n    result = solution.findCriticalAndPseudoCriticalEdges(n, edges)", "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 10], [1, 2, 5], [2, 3, 6], [3, 4, 2], [0, 2, 9], [1, 3, 8], [0, 4, 7]]\n    result = solution.findCriticalAndPseudoCriticalEdges(n, edges)", "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 4], [1, 2, 6], [0, 2, 1], [1, 2, 1]]\n    result = solution.findCriticalAndPseudoCriticalEdges(n, edges)", "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 2], [1, 2, 3], [2, 3, 1], [0, 3, 4], [0, 2, 2]]\n    result = solution.findCriticalAndPseudoCriticalEdges(n, edges)", "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 6\n    edges = [[0, 1, 1], [0, 2, 1], [0, 3, 1], [0, 4, 1], [0, 5, 1], [1, 2, 10], [2, 3, 10], [3, 4, 10], [4, 5, 10]]\n    result = solution.findCriticalAndPseudoCriticalEdges(n, edges)", "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 1], [1, 2, 1], [2, 3, 1], [3, 4, 1], [1, 4, 2], [0, 3, 2], [2, 4, 2]]\n    result = solution.findCriticalAndPseudoCriticalEdges(n, edges)", "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 7\n    edges = [[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7], [0, 6, 3], [1, 3, 2], [2, 4, 2], [3, 5, 1]]\n    result = solution.findCriticalAndPseudoCriticalEdges(n, edges)", "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 3], [1, 2, 3], [2, 3, 3], [0, 3, 1], [1, 3, 1], [0, 2, 1]]\n    result = solution.findCriticalAndPseudoCriticalEdges(n, edges)", "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 10], [1, 2, 5], [0, 2, 5]]\n    result = solution.findCriticalAndPseudoCriticalEdges(n, edges)"]}
{"task_num": 1573, "task_title": "Number of Ways to Split a String", "func_name": "numWays", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numWays(self, s: str) -> int:\n    kMod = 1_000_000_007\n    ones = s.count('1')\n    if ones % 3 != 0:\n      return 0\n    if ones == 0:\n      n = len(s)\n      return (n - 1) * (n - 2) // 2 % kMod\n\n    s1End = -1\n    s2Start = -1\n    s2End = -1\n    s3Start = -1\n    onesSoFar = 0\n\n    for i, c in enumerate(s):\n      if c == '1':\n        onesSoFar += 1\n      if s1End == -1 and onesSoFar == ones // 3:\n        s1End = i\n      elif s2Start == -1 and onesSoFar == ones // 3 + 1:\n        s2Start = i\n      if s2End == -1 and onesSoFar == ones // 3 * 2:\n        s2End = i\n      elif s3Start == -1 and onesSoFar == ones // 3 * 2 + 1:\n        s3Start = i\n\n    return (s2Start - s1End) * (s3Start - s2End) % kMod\n", "tests": ["def test_numWays():\n    solution = Solution()\n    assert solution.numWays('10101') == 4", "def test_numWays():\n    solution = Solution()\n    assert solution.numWays('1001') == 0", "def test_numWays():\n    solution = Solution()\n    assert solution.numWays('0000') == 3", "def test_numWays():\n    solution = Solution()\n    assert solution.numWays('111') == 1", "def test_numWays():\n    solution = Solution()\n    assert solution.numWays('110110') == 4", "def test_numWays():\n    solution = Solution()\n    assert solution.numWays('111000') == 9", "def test_numWays():\n    solution = Solution()\n    assert solution.numWays('100100010') == 12", "def test_numWays():\n    solution = Solution()\n    assert solution.numWays('000') == 1", "def test_numWays():\n    solution = Solution()\n    assert solution.numWays('110011') == 1", "def test_numWays():\n    solution = Solution()\n    assert solution.numWays('101010') == 6", "def test_numWays():\n    solution = Solution()\n    assert solution.numWays('11110000') == 0", "def test_numWays():\n    solution = Solution()\n    assert solution.numWays('100100100') == 4", "def test_numWays():\n    solution = Solution()\n    assert solution.numWays('111000111') == 4", "def test_numWays():\n    solution = Solution()\n    assert solution.numWays('000111000') == 9", "def test_numWays():\n    solution = Solution()\n    assert solution.numWays('101011') == 2", "def test_numWays():\n    solution = Solution()\n    assert solution.numWays('110101110') == 6", "def test_numWays():\n    solution = Solution()\n    assert solution.numWays('0101010101') == 10", "def test_numWays():\n    solution = Solution()\n    assert solution.numWays('1111100000') == 0", "def test_numWays():\n    solution = Solution()\n    assert solution.numWays('1100011') == 3", "def test_numWays():\n    solution = Solution()\n    assert solution.numWays('1100110011') == 4"]}
{"task_num": 1574, "task_title": "Shortest Subarray to be Removed to Make Array Sorted", "func_name": "findLengthOfShortestSubarray", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n    n = len(arr)\n    l = 0\n    r = n - 1\n\n    while l < n - 1 and arr[l + 1] >= arr[l]:\n      l += 1\n    while r > 0 and arr[r - 1] <= arr[r]:\n      r -= 1\n    ans = min(n - 1 - l, r)\n\n    i = l\n    j = n - 1\n    while i >= 0 and j >= r and j > i:\n      if arr[i] <= arr[j]:\n        j -= 1\n      else:\n        i -= 1\n      ans = min(ans, j - i)\n\n    return ans\n", "tests": ["def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([1, 2, 3, 10, 4, 2, 3, 5]) == 3", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([5, 4, 3, 2, 1]) == 4", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([1, 2, 3, 3, 2, 2, 2, 2]) == 2", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([1, 2, 3, 4, 5]) == 0", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([9, 7, 5, 6, 8, 10]) == 2", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([1, 3, 2, 4, 5, 6]) == 1", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([2, 2, 2, 2, 1, 2, 2, 2]) == 1", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([10, 20, 30, 25, 26, 27, 40, 50]) == 1", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([3, 4, 5, 1, 2, 3, 4, 7, 8]) == 3", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([1, 5, 6, 6, 8, 4, 9, 10]) == 2", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([7, 8, 9, 4, 5, 3, 10, 11, 12]) == 3", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([1, 2, 3, 7, 6, 5, 4, 8, 9]) == 4", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([0, 1, 2, 3, 8, 6, 4, 5, 7]) == 3", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([4, 3, 2, 1, 0]) == 4", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([3, 1, 2, 2, 3, 4]) == 1", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([10, 9, 8, 7, 8, 9, 10]) == 4", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([5, 6, 7, 8, 6, 7, 8, 9, 10]) == 1", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([2, 10, 11, 3, 4, 5, 6, 1]) == 5", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([7, 8, 2, 3, 4, 5, 6, 1, 9]) == 2", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([1, 5, 9, 3, 4, 6, 7, 8, 2]) == 5"]}
{"task_num": 1579, "task_title": "Remove Max Number of Edges to Keep Graph Fully Traversable", "func_name": "maxNumEdgesToRemove", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    self.count -= 1\n    return True\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\n    alice = UnionFind(n)\n    bob = UnionFind(n)\n    requiredEdges = 0\n\n    for type, u, v in sorted(edges, reverse=True):\n      u -= 1\n      v -= 1\n      if type == 3:\n        if alice.unionByRank(u, v) | bob.unionByRank(u, v):\n          requiredEdges += 1\n      elif type == 2:\n        if bob.unionByRank(u, v):\n          requiredEdges += 1\n      else:\n        if alice.unionByRank(u, v):\n          requiredEdges += 1\n\n    if alice.count == 1 and bob.count == 1:\n        return len(edges) - requiredEdges\n    else:\n        return -1\n", "tests": ["def test_maxNumEdgesToRemove():\n    solution = Solution()\n    n = 4\n    edges = [[3, 1, 2], [3, 2, 3], [1, 1, 3], [1, 2, 4], [1, 1, 2], [2, 3, 4]]\n    assert solution.maxNumEdgesToRemove(n, edges) == 2", "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    n = 3\n    edges = [[3, 1, 2], [3, 2, 3], [1, 1, 3], [2, 1, 3], [1, 2, 3]]\n    assert solution.maxNumEdgesToRemove(n, edges) == 0", "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    n = 2\n    edges = [[1, 1, 2], [2, 1, 2], [3, 1, 2]]\n    assert solution.maxNumEdgesToRemove(n, edges) == 1", "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    n = 4\n    edges = [[3, 1, 2], [3, 3, 4], [1, 1, 3], [2, 2, 4]]\n    assert solution.maxNumEdgesToRemove(n, edges) == -1", "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    n = 2\n    edges = [[1, 1, 2]]\n    assert solution.maxNumEdgesToRemove(n, edges) == -1", "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    n = 5\n    edges = [[3, 1, 2], [3, 2, 3], [3, 3, 4], [3, 4, 5], [2, 1, 3], [1, 1, 4]]\n    assert solution.maxNumEdgesToRemove(n, edges) == 2", "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    n = 1\n    edges = []\n    assert solution.maxNumEdgesToRemove(n, edges) == 0", "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    n = 3\n    edges = [[3, 1, 2], [3, 2, 3], [3, 1, 3]]\n    assert solution.maxNumEdgesToRemove(n, edges) == 0", "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    n = 4\n    edges = [[1, 1, 2], [1, 2, 3], [1, 3, 4]]\n    assert solution.maxNumEdgesToRemove(n, edges) == -1", "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    n = 4\n    edges = [[3, 1, 2], [2, 2, 3], [1, 3, 4], [3, 1, 4]]\n    assert solution.maxNumEdgesToRemove(n, edges) == 0", "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    n = 4\n    edges = [[3, 1, 2], [3, 2, 3], [3, 3, 4], [3, 1, 3], [3, 2, 4], [1, 1, 4]]\n    assert solution.maxNumEdgesToRemove(n, edges) == 2", "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    n = 3\n    edges = [[1, 1, 2], [2, 2, 3]]\n    assert solution.maxNumEdgesToRemove(n, edges) == -1", "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    n = 3\n    edges = [[3, 1, 2], [3, 2, 3], [3, 1, 3]]\n    assert solution.maxNumEdgesToRemove(n, edges) == 0", "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    n = 5\n    edges = [[3, 1, 2], [3, 3, 4]]\n    assert solution.maxNumEdgesToRemove(n, edges) == -1", "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    n = 4\n    edges = [[1, 1, 2], [2, 2, 3], [3, 1, 3], [3, 3, 4], [2, 1, 4]]\n    assert solution.maxNumEdgesToRemove(n, edges) == 1", "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    n = 6\n    edges = [[3, 1, 2], [3, 2, 3], [1, 4, 5], [2, 5, 6], [3, 1, 4]]\n    assert solution.maxNumEdgesToRemove(n, edges) == -1", "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    n = 4\n    edges = [[3, 1, 2], [3, 2, 3], [3, 3, 4], [3, 1, 3], [3, 2, 4], [1, 1, 4], [2, 1, 3], [1, 2, 3], [2, 3, 4]]\n    assert solution.maxNumEdgesToRemove(n, edges) == 5", "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    n = 4\n    edges = [[3, 1, 2], [3, 2, 3], [3, 3, 4]]\n    assert solution.maxNumEdgesToRemove(n, edges) == 0", "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    n = 6\n    edges = [[3, 1, 2], [1, 1, 3], [2, 4, 5], [3, 5, 6]]\n    assert solution.maxNumEdgesToRemove(n, edges) == -1", "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    n = 5\n    edges = [[3, 1, 2], [1, 1, 3], [2, 2, 4], [1, 3, 5], [3, 4, 5], [2, 1, 4]]\n    assert solution.maxNumEdgesToRemove(n, edges) == 2"]}
{"task_num": 1582, "task_title": "Special Positions in a Binary Matrix", "func_name": "numSpecial", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numSpecial(self, mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    ans = 0\n    rowOnes = [0] * m\n    colOnes = [0] * n\n\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j] == 1:\n          rowOnes[i] += 1\n          colOnes[j] += 1\n\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j] == 1 and rowOnes[i] == 1 and colOnes[j] == 1:\n          ans += 1\n\n    return ans\n", "tests": ["def test_numSpecial():\n    solution = Solution()\n    mat = [[1, 0, 0], [0, 0, 1], [1, 0, 0]]\n    assert solution.numSpecial(mat) == 1", "def test_numSpecial():\n    solution = Solution()\n    mat = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n    assert solution.numSpecial(mat) == 1", "def test_numSpecial():\n    solution = Solution()\n    mat = [[1, 0, 0, 1], [0, 1, 1, 0], [0, 0, 0, 0], [1, 0, 0, 1]]\n    assert solution.numSpecial(mat) == 0", "def test_numSpecial():\n    solution = Solution()\n    mat = [[0, 0, 0], [0, 1, 0], [0, 0, 1]]\n    assert solution.numSpecial(mat) == 2", "def test_numSpecial():\n    solution = Solution()\n    mat = [[1, 0], [0, 0], [0, 1]]\n    assert solution.numSpecial(mat) == 2", "def test_numSpecial():\n    solution = Solution()\n    mat = [[0, 1, 0], [1, 0, 1], [0, 1, 0]]\n    assert solution.numSpecial(mat) == 0", "def test_numSpecial():\n    solution = Solution()\n    mat = [[1]]\n    assert solution.numSpecial(mat) == 1", "def test_numSpecial():\n    solution = Solution()\n    mat = [[0, 0], [0, 0]]\n    assert solution.numSpecial(mat) == 0", "def test_numSpecial():\n    solution = Solution()\n    mat = [[1, 1, 0], [0, 0, 0], [0, 0, 1]]\n    assert solution.numSpecial(mat) == 1", "def test_numSpecial():\n    solution = Solution()\n    mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    assert solution.numSpecial(mat) == 3", "def test_numSpecial():\n    solution = Solution()\n    mat = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 1]]\n    assert solution.numSpecial(mat) == 1", "def test_numSpecial():\n    solution = Solution()\n    mat = [[1, 0, 0], [0, 0, 0], [0, 0, 0]]\n    assert solution.numSpecial(mat) == 1", "def test_numSpecial():\n    solution = Solution()\n    mat = [[0, 0, 1], [1, 0, 0], [0, 1, 0]]\n    assert solution.numSpecial(mat) == 3", "def test_numSpecial():\n    solution = Solution()\n    mat = [[0, 0, 0, 1], [0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 1, 0]]\n    assert solution.numSpecial(mat) == 4", "def test_numSpecial():\n    solution = Solution()\n    mat = [[1, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]\n    assert solution.numSpecial(mat) == 1", "def test_numSpecial():\n    solution = Solution()\n    mat = [[0, 1, 0], [0, 0, 0], [1, 0, 0]]\n    assert solution.numSpecial(mat) == 2", "def test_numSpecial():\n    solution = Solution()\n    mat = [[0, 1, 0], [0, 0, 1], [1, 0, 0], [0, 0, 0]]\n    assert solution.numSpecial(mat) == 3", "def test_numSpecial():\n    solution = Solution()\n    mat = [[0, 0, 0, 0], [0, 0, 1, 0], [0, 0, 0, 0], [1, 0, 0, 0]]\n    assert solution.numSpecial(mat) == 2", "def test_numSpecial():\n    solution = Solution()\n    mat = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]\n    assert solution.numSpecial(mat) == 1", "def test_numSpecial():\n    solution = Solution()\n    mat = [[1, 0, 0, 0], [0, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]]\n    assert solution.numSpecial(mat) == 3"]}
{"task_num": 1583, "task_title": "Count Unhappy Friends", "func_name": "unhappyFriends", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\n    ans = 0\n    matches = [0] * n\n    prefer = [{} for _ in range(n)]\n\n    for x, y in pairs:\n      matches[x] = y\n      matches[y] = x\n\n    for i in range(n):\n      for j in range(n - 1):\n        prefer[i][preferences[i][j]] = j\n\n    for x in range(n):\n      for u in prefer[x].keys():\n        y = matches[x]\n        v = matches[u]\n        if prefer[x][u] < prefer[x][y] and prefer[u][x] < prefer[u][v]:\n          ans += 1\n          break\n\n    return ans\n", "tests": ["def test_unhappyFriends():\n    solution = Solution()\n    n = 4\n    preferences = [[1, 2, 3], [3, 2, 0], [3, 1, 0], [1, 2, 0]]\n    pairs = [[0, 1], [2, 3]]\n    assert solution.unhappyFriends(n, preferences, pairs) == 2", "def test_unhappyFriends():\n    solution = Solution()\n    n = 4\n    preferences = [[1, 3, 2], [3, 0, 2], [0, 1, 3], [0, 1, 2]]\n    pairs = [[0, 2], [1, 3]]\n    assert solution.unhappyFriends(n, preferences, pairs) == 4", "def test_unhappyFriends():\n    solution = Solution()\n    n = 6\n    preferences = [[1, 2, 3, 4, 5], [2, 0, 3, 4, 5], [0, 1, 3, 4, 5], [4, 2, 0, 1, 5], [3, 5, 0, 1, 2], [4, 3, 0, 1, 2]]\n    pairs = [[0, 1], [2, 3], [4, 5]]\n    assert solution.unhappyFriends(n, preferences, pairs) == 4", "def test_unhappyFriends():\n    solution = Solution()\n    n = 4\n    preferences = [[1, 3, 2], [0, 3, 2], [3, 1, 0], [0, 2, 1]]\n    pairs = [[0, 3], [1, 2]]\n    assert solution.unhappyFriends(n, preferences, pairs) == 0", "def test_unhappyFriends():\n    solution = Solution()\n    n = 8\n    preferences = [[1, 2, 3, 4, 5, 6, 7], [0, 2, 3, 4, 5, 6, 7], [0, 1, 3, 4, 5, 6, 7], [0, 1, 2, 4, 5, 6, 7], [0, 1, 2, 3, 5, 6, 7], [0, 1, 2, 3, 4, 6, 7], [0, 1, 2, 3, 4, 5, 7], [0, 1, 2, 3, 4, 5, 6]]\n    pairs = [[0, 1], [2, 3], [4, 5], [6, 7]]\n    assert solution.unhappyFriends(n, preferences, pairs) == 0", "def test_unhappyFriends():\n    solution = Solution()\n    n = 4\n    preferences = [[2, 1, 3], [3, 0, 2], [1, 0, 3], [0, 2, 1]]\n    pairs = [[0, 3], [1, 2]]\n    assert solution.unhappyFriends(n, preferences, pairs) == 2", "def test_unhappyFriends():\n    solution = Solution()\n    n = 6\n    preferences = [[1, 2, 3, 4, 5], [0, 2, 3, 4, 5], [1, 0, 3, 4, 5], [4, 5, 0, 1, 2], [3, 5, 0, 1, 2], [3, 4, 0, 1, 2]]\n    pairs = [[0, 1], [2, 3], [4, 5]]\n    assert solution.unhappyFriends(n, preferences, pairs) == 4", "def test_unhappyFriends():\n    solution = Solution()\n    n = 8\n    preferences = [[5, 1, 2, 3, 4, 6, 7], [0, 2, 3, 4, 5, 6, 7], [1, 0, 3, 4, 5, 6, 7], [2, 0, 1, 4, 5, 6, 7], [3, 0, 1, 2, 5, 6, 7], [0, 4, 2, 3, 1, 6, 7], [7, 0, 1, 2, 3, 4, 5], [6, 0, 1, 2, 3, 4, 5]]\n    pairs = [[0, 1], [2, 3], [4, 5], [6, 7]]\n    assert solution.unhappyFriends(n, preferences, pairs) == 3", "def test_unhappyFriends():\n    solution = Solution()\n    n = 2\n    preferences = [[1], [0]]\n    pairs = [[0, 1]]\n    assert solution.unhappyFriends(n, preferences, pairs) == 0", "def test_unhappyFriends():\n    solution = Solution()\n    n = 6\n    preferences = [[1, 4, 2, 3, 5], [0, 2, 4, 3, 5], [1, 0, 3, 4, 5], [2, 0, 1, 4, 5], [0, 1, 5, 2, 3], [4, 0, 1, 2, 3]]\n    pairs = [[0, 1], [2, 3], [4, 5]]\n    assert solution.unhappyFriends(n, preferences, pairs) == 6", "def test_unhappyFriends():\n    solution = Solution()\n    n = 8\n    preferences = [[3, 4, 5, 1, 2, 6, 7], [0, 2, 3, 4, 5, 6, 7], [1, 0, 3, 4, 5, 6, 7], [0, 1, 2, 4, 5, 6, 7], [5, 6, 7, 0, 1, 2, 3], [4, 6, 7, 0, 1, 2, 3], [4, 5, 7, 0, 1, 2, 3], [4, 5, 6, 0, 1, 2, 3]]\n    pairs = [[0, 1], [2, 3], [4, 5], [6, 7]]\n    assert solution.unhappyFriends(n, preferences, pairs) == 7", "def test_unhappyFriends():\n    solution = Solution()\n    n = 4\n    preferences = [[3, 2, 1], [2, 3, 0], [1, 0, 3], [0, 2, 1]]\n    pairs = [[0, 2], [1, 3]]\n    assert solution.unhappyFriends(n, preferences, pairs) == 4", "def test_unhappyFriends():\n    solution = Solution()\n    n = 6\n    preferences = [[5, 1, 2, 3, 4], [0, 2, 3, 4, 5], [1, 0, 3, 4, 5], [2, 0, 1, 4, 5], [3, 0, 1, 2, 5], [0, 1, 2, 3, 4]]\n    pairs = [[0, 1], [2, 3], [4, 5]]\n    assert solution.unhappyFriends(n, preferences, pairs) == 3", "def test_unhappyFriends():\n    solution = Solution()\n    n = 6\n    preferences = [[1, 3, 2, 4, 5], [0, 2, 3, 4, 5], [1, 0, 3, 4, 5], [0, 1, 2, 4, 5], [5, 0, 1, 2, 3], [4, 0, 1, 2, 3]]\n    pairs = [[0, 1], [2, 4], [3, 5]]\n    assert solution.unhappyFriends(n, preferences, pairs) == 5", "def test_unhappyFriends():\n    solution = Solution()\n    n = 8\n    preferences = [[1, 2, 3, 4, 5, 6, 7], [0, 2, 3, 4, 5, 6, 7], [1, 0, 3, 4, 5, 6, 7], [2, 0, 1, 4, 5, 6, 7], [6, 7, 0, 1, 2, 3, 5], [7, 6, 0, 1, 2, 3, 4], [4, 5, 0, 1, 2, 3, 7], [5, 4, 0, 1, 2, 3, 6]]\n    pairs = [[0, 1], [2, 3], [4, 6], [5, 7]]\n    assert solution.unhappyFriends(n, preferences, pairs) == 6", "def test_unhappyFriends():\n    solution = Solution()\n    n = 4\n    preferences = [[3, 1, 2], [0, 2, 3], [1, 0, 3], [2, 1, 0]]\n    pairs = [[0, 2], [1, 3]]\n    assert solution.unhappyFriends(n, preferences, pairs) == 4", "def test_unhappyFriends():\n    solution = Solution()\n    n = 8\n    preferences = [[2, 3, 1, 4, 5, 6, 7], [0, 3, 2, 4, 5, 6, 7], [1, 0, 3, 4, 5, 6, 7], [0, 2, 1, 4, 5, 6, 7], [6, 7, 0, 1, 2, 3, 5], [7, 6, 0, 1, 2, 3, 4], [4, 5, 0, 1, 2, 3, 7], [5, 4, 0, 1, 2, 3, 6]]\n    pairs = [[0, 1], [2, 5], [3, 4], [6, 7]]\n    assert solution.unhappyFriends(n, preferences, pairs) == 4", "def test_unhappyFriends():\n    solution = Solution()\n    n = 4\n    preferences = [[1, 2, 3], [0, 3, 2], [1, 0, 3], [2, 0, 1]]\n    pairs = [[0, 3], [1, 2]]\n    assert solution.unhappyFriends(n, preferences, pairs) == 2", "def test_unhappyFriends():\n    solution = Solution()\n    n = 8\n    preferences = [[1, 4, 3, 2, 5, 6, 7], [0, 3, 2, 4, 5, 6, 7], [1, 0, 3, 4, 5, 6, 7], [2, 0, 1, 4, 5, 6, 7], [0, 1, 2, 3, 5, 6, 7], [4, 0, 1, 2, 3, 6, 7], [7, 0, 1, 2, 3, 4, 5], [6, 0, 1, 2, 3, 4, 5]]\n    pairs = [[0, 1], [2, 3], [4, 7], [5, 6]]\n    assert solution.unhappyFriends(n, preferences, pairs) == 6", "def test_unhappyFriends():\n    solution = Solution()\n    n = 4\n    preferences = [[3, 1, 2], [2, 0, 3], [3, 0, 1], [0, 2, 1]]\n    pairs = [[0, 1], [2, 3]]\n    assert solution.unhappyFriends(n, preferences, pairs) == 0"]}
{"task_num": 1591, "task_title": "Strange Printer II", "func_name": "isPrintable", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import Enum\n\n\nclass State(Enum):\n  kInit = 0\n  kVisiting = 1\n  kVisited = 2\n\n\nclass Solution:\n  def isPrintable(self, targetGrid: List[List[int]]) -> bool:\n    kMaxColor = 60\n    m = len(targetGrid)\n    n = len(targetGrid[0])\n\n    graph = [set() for _ in range(kMaxColor + 1)]\n\n    for color in range(1, kMaxColor + 1):\n      minI = m\n      minJ = n\n      maxI = -1\n      maxJ = -1\n      for i in range(m):\n        for j in range(n):\n          if targetGrid[i][j] == color:\n            minI = min(minI, i)\n            minJ = min(minJ, j)\n            maxI = max(maxI, i)\n            maxJ = max(maxJ, j)\n\n      for i in range(minI, maxI + 1):\n        for j in range(minJ, maxJ + 1):\n          if targetGrid[i][j] != color:\n            graph[color].add(targetGrid[i][j])\n\n    states = [State.kInit] * (kMaxColor + 1)\n\n    def hasCycle(u: int) -> bool:\n      if states[u] == State.kVisiting:\n        return True\n      if states[u] == State.kVisited:\n        return False\n\n      states[u] = State.kVisiting\n      if any(hasCycle(v) for v in graph[u]):\n        return True\n      states[u] = State.kVisited\n\n      return False\n\n    for i in range(1, kMaxColor + 1):\n      if hasCycle(i):\n        return False\n    return True\n", "tests": ["def test_isPrintable():\n    solution = Solution()\n    targetGrid = [[1, 1, 2], [2, 2, 2], [2, 2, 3]]\n    assert solution.isPrintable(targetGrid) == True", "def test_isPrintable():\n    solution = Solution()\n    targetGrid = [[1, 2, 1], [2, 1, 3], [1, 3, 1]]\n    assert solution.isPrintable(targetGrid) == False", "def test_isPrintable():\n    solution = Solution()\n    targetGrid = [[3, 3, 3], [3, 2, 2], [3, 2, 1]]\n    assert solution.isPrintable(targetGrid) == True", "def test_isPrintable():\n    solution = Solution()\n    targetGrid = [[4, 4, 4, 4], [4, 1, 1, 4], [4, 1, 1, 4], [4, 4, 4, 4]]\n    assert solution.isPrintable(targetGrid) == True", "def test_isPrintable():\n    solution = Solution()\n    targetGrid = [[5, 5, 5], [5, 6, 5], [5, 5, 5]]\n    assert solution.isPrintable(targetGrid) == True", "def test_isPrintable():\n    solution = Solution()\n    targetGrid = [[7, 8, 7], [8, 7, 8], [7, 8, 7]]\n    assert solution.isPrintable(targetGrid) == False", "def test_isPrintable():\n    solution = Solution()\n    targetGrid = [[9, 9, 9, 10], [9, 10, 10, 10], [9, 9, 9, 10]]\n    assert solution.isPrintable(targetGrid) == True", "def test_isPrintable():\n    solution = Solution()\n    targetGrid = [[11, 12, 11], [12, 11, 12], [11, 12, 13]]\n    assert solution.isPrintable(targetGrid) == False", "def test_isPrintable():\n    solution = Solution()\n    targetGrid = [[14, 14, 15, 15], [14, 15, 15, 15], [14, 14, 15, 15], [15, 15, 15, 15]]\n    assert solution.isPrintable(targetGrid) == True", "def test_isPrintable():\n    solution = Solution()\n    targetGrid = [[16, 17, 17], [17, 16, 17], [17, 17, 16]]\n    assert solution.isPrintable(targetGrid) == False", "def test_isPrintable():\n    solution = Solution()\n    targetGrid = [[18, 18, 18, 18], [18, 19, 19, 18], [18, 19, 19, 18], [18, 18, 18, 18]]\n    assert solution.isPrintable(targetGrid) == True", "def test_isPrintable():\n    solution = Solution()\n    targetGrid = [[20, 21, 20, 21], [21, 20, 21, 20], [20, 21, 20, 21]]\n    assert solution.isPrintable(targetGrid) == False", "def test_isPrintable():\n    solution = Solution()\n    targetGrid = [[22, 22, 23], [22, 23, 23], [23, 23, 23]]\n    assert solution.isPrintable(targetGrid) == True", "def test_isPrintable():\n    solution = Solution()\n    targetGrid = [[24, 24, 25], [25, 24, 25], [24, 25, 24]]\n    assert solution.isPrintable(targetGrid) == False", "def test_isPrintable():\n    solution = Solution()\n    targetGrid = [[26, 27, 27, 26], [27, 26, 26, 27], [26, 27, 27, 26]]\n    assert solution.isPrintable(targetGrid) == True", "def test_isPrintable():\n    solution = Solution()\n    targetGrid = [[28, 28, 28], [28, 29, 29], [29, 28, 28]]\n    assert solution.isPrintable(targetGrid) == False", "def test_isPrintable():\n    solution = Solution()\n    targetGrid = [[30, 30, 31], [31, 31, 30], [30, 31, 30]]\n    assert solution.isPrintable(targetGrid) == True", "def test_isPrintable():\n    solution = Solution()\n    targetGrid = [[32, 33, 32, 33], [33, 32, 33, 32], [32, 33, 32, 33], [33, 32, 33, 32]]\n    assert solution.isPrintable(targetGrid) == False", "def test_isPrintable():\n    solution = Solution()\n    targetGrid = [[34, 34, 35, 35], [34, 35, 35, 34], [35, 35, 34, 34], [34, 34, 34, 34]]\n    assert solution.isPrintable(targetGrid) == True", "def test_isPrintable():\n    solution = Solution()\n    targetGrid = [[36, 37, 37], [37, 36, 36], [36, 37, 37]]\n    assert solution.isPrintable(targetGrid) == False"]}
{"task_num": 1604, "task_title": "Alert Using Same Key-Card Three or More Times in a One Hour Period", "func_name": "alertNames", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n    nameToMinutes = collections.defaultdict(list)\n\n    for name, time in zip(keyName, keyTime):\n      minutes = self._getMinutes(time)\n      nameToMinutes[name].append(minutes)\n\n    res=[]\n    for name, minutes in nameToMinutes.items():\n      if self._hasAlert(minutes):\n        res.append(name)\n    return sorted(res)\n\n  def _hasAlert(self, minutes: List[int]) -> bool:\n    if len(minutes) > 70:\n      return True\n    minutes.sort()\n    for i in range(2, len(minutes)):\n      if minutes[i - 2] + 60 >= minutes[i]:\n        return True\n    return False\n\n  def _getMinutes(self, time: str) -> int:\n    h, m = map(int, time.split(':'))\n    return 60 * h + m\n", "tests": ["def test_alertNames():\n    solution = Solution()\n    keyName = ['alice', 'alice', 'alice', 'bob', 'bob', 'bob', 'bob']\n    keyTime = ['12:01', '12:20', '12:40', '12:01', '12:20', '12:40', '13:00']\n    assert solution.alertNames(keyName, keyTime) == ['alice', 'bob']", "def test_alertNames():\n    solution = Solution()\n    keyName = ['john', 'john', 'john', 'john', 'doe', 'doe', 'doe']\n    keyTime = ['10:00', '10:20', '10:40', '11:00', '09:00', '09:10', '09:20']\n    assert solution.alertNames(keyName, keyTime) == ['john']", "def test_alertNames():\n    solution = Solution()\n    keyName = ['anna', 'anna', 'anna', 'anna', 'max', 'max']\n    keyTime = ['23:00', '23:20', '23:40', '00:10', '23:50', '00:20']\n    assert solution.alertNames(keyName, keyTime) == ['anna']", "def test_alertNames():\n    solution = Solution()\n    keyName = ['sam', 'sam', 'sam', 'linda', 'linda', 'paul']\n    keyTime = ['08:00', '08:30', '09:00', '10:15', '11:15', '12:30']\n    assert solution.alertNames(keyName, keyTime) == []", "def test_alertNames():\n    solution = Solution()\n    keyName = ['jane', 'jane', 'jane', 'jim', 'jim', 'jim', 'jim']\n    keyTime = ['15:00', '15:20', '16:00', '09:00', '10:00', '10:40', '11:30']\n    assert solution.alertNames(keyName, keyTime) == ['jim']", "def test_alertNames():\n    solution = Solution()\n    keyName = ['alex', 'alex', 'alex', 'alex', 'alex', 'alex']\n    keyTime = ['01:00', '01:15', '01:30', '02:00', '02:30', '03:00']\n    assert solution.alertNames(keyName, keyTime) == []", "def test_alertNames():\n    solution = Solution()\n    keyName = ['eve', 'eve', 'alice', 'alice', 'bob', 'bob', 'bob']\n    keyTime = ['02:00', '02:30', '03:00', '03:30', '05:00', '05:20', '05:40']\n    assert solution.alertNames(keyName, keyTime) == ['bob']", "def test_alertNames():\n    solution = Solution()\n    keyName = ['mike', 'mike', 'mike', 'sara', 'sara', 'sara', 'sara']\n    keyTime = ['12:00', '12:20', '12:40', '14:00', '14:30', '14:40', '15:00']\n    assert solution.alertNames(keyName, keyTime) == ['mike', 'sara']", "def test_alertNames():\n    solution = Solution()\n    keyName = ['tom', 'tom', 'tom', 'lucy', 'lucy', 'lucy', 'lucy']\n    keyTime = ['18:00', '18:30', '19:00', '07:00', '07:10', '07:20', '07:50']\n    assert solution.alertNames(keyName, keyTime) == ['lucy', 'tom']", "def test_alertNames():\n    solution = Solution()\n    keyName = ['robert', 'robert', 'robert', 'robert', 'chris', 'chris']\n    keyTime = ['22:00', '22:30', '23:00', '23:30', '00:10', '01:00']\n    assert solution.alertNames(keyName, keyTime) == ['robert']", "def test_alertNames():\n    solution = Solution()\n    keyName = ['emily', 'emily', 'emily', 'david', 'david', 'david']\n    keyTime = ['20:00', '20:30', '21:00', '22:00', '22:30', '23:00']\n    assert solution.alertNames(keyName, keyTime) == ['emily', 'david']", "def test_alertNames():\n    solution = Solution()\n    keyName = ['amy', 'amy', 'amy', 'amy', 'nick', 'nick', 'nick']\n    keyTime = ['06:00', '06:20', '06:50', '07:30', '08:00', '08:20', '08:40']\n    assert solution.alertNames(keyName, keyTime) == ['amy', 'nick']", "def test_alertNames():\n    solution = Solution()\n    keyName = ['harry', 'harry', 'jack', 'jack', 'jack', 'jack']\n    keyTime = ['11:00', '11:59', '12:00', '12:30', '12:59', '13:30']\n    assert solution.alertNames(keyName, keyTime) == ['jack']", "def test_alertNames():\n    solution = Solution()\n    keyName = ['carol', 'carol', 'carol', 'dan', 'dan', 'dan', 'dan']\n    keyTime = ['09:15', '09:55', '10:15', '15:00', '16:00', '16:20', '16:40']\n    assert solution.alertNames(keyName, keyTime) == ['carol', 'dan']", "def test_alertNames():\n    solution = Solution()\n    keyName = ['zoe', 'zoe', 'zoe', 'zoe', 'liam', 'liam']\n    keyTime = ['04:00', '04:45', '05:30', '06:15', '14:00', '15:00']\n    assert solution.alertNames(keyName, keyTime) == ['zoe']", "def test_alertNames():\n    solution = Solution()\n    keyName = ['rachel', 'rachel', 'rachel', 'rachel', 'josh', 'josh']\n    keyTime = ['17:00', '17:30', '18:00', '18:45', '23:00', '23:55']\n    assert solution.alertNames(keyName, keyTime) == ['rachel']", "def test_alertNames():\n    solution = Solution()\n    keyName = ['nina', 'nina', 'nina', 'oliver', 'oliver', 'oliver']\n    keyTime = ['13:00', '13:15', '14:00', '09:00', '09:10', '09:50']\n    assert solution.alertNames(keyName, keyTime) == ['nina', 'oliver']", "def test_alertNames():\n    solution = Solution()\n    keyName = ['zoey', 'zoey', 'zoey', 'alex', 'alex', 'alex', 'alex']\n    keyTime = ['01:00', '01:30', '02:00', '21:00', '22:00', '22:30', '23:00']\n    assert solution.alertNames(keyName, keyTime) == ['alex', 'zoey']", "def test_alertNames():\n    solution = Solution()\n    keyName = ['ben', 'ben', 'ben', 'ben', 'jane', 'jane', 'jane']\n    keyTime = ['19:00', '19:45', '20:30', '21:15', '06:00', '06:30', '07:30']\n    assert solution.alertNames(keyName, keyTime) == ['ben']", "def test_alertNames():\n    solution = Solution()\n    keyName = ['lisa', 'lisa', 'mark', 'mark', 'mark', 'mark']\n    keyTime = ['05:00', '06:00', '08:00', '08:30', '08:45', '09:15']\n    assert solution.alertNames(keyName, keyTime) == ['mark']"]}
{"task_num": 1615, "task_title": "Maximal Network Rank", "func_name": "maximalNetworkRank", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\n    degrees = [0] * n\n\n    for u, v in roads:\n      degrees[u] += 1\n      degrees[v] += 1\n\n    maxDegree1 = 0\n    maxDegree2 = 0\n    for degree in degrees:\n      if degree > maxDegree1:\n        maxDegree2 = maxDegree1\n        maxDegree1 = degree\n      elif degree > maxDegree2:\n        maxDegree2 = degree\n\n    countMaxDegree1 = 0\n    countMaxDegree2 = 0\n    for degree in degrees:\n      if degree == maxDegree1:\n        countMaxDegree1 += 1\n      elif degree == maxDegree2:\n        countMaxDegree2 += 1\n\n    if countMaxDegree1 == 1:\n      edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree2) + self._getEdgeCount(roads, degrees, maxDegree2, maxDegree1)\n      return maxDegree1 + maxDegree2 - (countMaxDegree2 == edgeCount)\n    else:\n      edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree1)\n      maxPossibleEdgeCount = countMaxDegree1 * (countMaxDegree1 - 1) // 2\n      return 2 * maxDegree1 - (maxPossibleEdgeCount == edgeCount)\n\n  def _getEdgeCount(self, roads: List[List[int]], degrees: List[int], degreeU: int, degreeV: int) -> int:\n    edgeCount = 0\n    for u, v in roads:\n      if degrees[u] == degreeU and degrees[v] == degreeV:\n        edgeCount += 1\n    return edgeCount\n", "tests": ["def test_maximalNetworkRank():\n    solution = Solution()\n    assert solution.maximalNetworkRank(4, [[0, 1], [0, 3], [1, 2], [1, 3]]) == 4", "def test_maximalNetworkRank():\n    solution = Solution()\n    assert solution.maximalNetworkRank(5, [[0, 1], [0, 3], [1, 2], [2, 3], [2, 4]]) == 4", "def test_maximalNetworkRank():\n    solution = Solution()\n    assert solution.maximalNetworkRank(3, [[0, 1], [1, 2], [2, 0]]) == 2", "def test_maximalNetworkRank():\n    solution = Solution()\n    assert solution.maximalNetworkRank(2, [[0, 1]]) == 1", "def test_maximalNetworkRank():\n    solution = Solution()\n    assert solution.maximalNetworkRank(6, [[0, 1], [0, 2], [0, 3], [1, 2], [1, 3], [2, 3], [3, 4], [4, 5]]) == 5", "def test_maximalNetworkRank():\n    solution = Solution()\n    assert solution.maximalNetworkRank(5, [[0, 1], [0, 2], [2, 3], [2, 4], [3, 4]]) == 4", "def test_maximalNetworkRank():\n    solution = Solution()\n    assert solution.maximalNetworkRank(4, []) == 0", "def test_maximalNetworkRank():\n    solution = Solution()\n    assert solution.maximalNetworkRank(4, [[0, 1], [1, 2], [2, 3], [3, 0]]) == 3", "def test_maximalNetworkRank():\n    solution = Solution()\n    assert solution.maximalNetworkRank(7, [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [2, 6]]) == 4", "def test_maximalNetworkRank():\n    solution = Solution()\n    assert solution.maximalNetworkRank(5, [[0, 1], [1, 2], [2, 3], [3, 4], [0, 4]]) == 3", "def test_maximalNetworkRank():\n    solution = Solution()\n    assert solution.maximalNetworkRank(3, [[0, 1], [1, 2], [0, 2]]) == 2", "def test_maximalNetworkRank():\n    solution = Solution()\n    assert solution.maximalNetworkRank(6, [[0, 1], [0, 2], [1, 3], [3, 4], [4, 5], [5, 2]]) == 3", "def test_maximalNetworkRank():\n    solution = Solution()\n    assert solution.maximalNetworkRank(4, [[0, 1], [1, 2], [2, 3], [3, 0], [0, 2]]) == 4", "def test_maximalNetworkRank():\n    solution = Solution()\n    assert solution.maximalNetworkRank(8, [[0, 1], [0, 2], [1, 3], [2, 4], [4, 5], [5, 6], [6, 7]]) == 3", "def test_maximalNetworkRank():\n    solution = Solution()\n    assert solution.maximalNetworkRank(5, [[0, 1], [1, 2], [2, 3], [3, 4], [1, 4]]) == 3", "def test_maximalNetworkRank():\n    solution = Solution()\n    assert solution.maximalNetworkRank(7, [[0, 1], [0, 2], [1, 3], [3, 4], [4, 5], [5, 6], [2, 6]]) == 4", "def test_maximalNetworkRank():\n    solution = Solution()\n    assert solution.maximalNetworkRank(9, [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [0, 8]]) == 3", "def test_maximalNetworkRank():\n    solution = Solution()\n    assert solution.maximalNetworkRank(6, [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [0, 5], [2, 4]]) == 4", "def test_maximalNetworkRank():\n    solution = Solution()\n    assert solution.maximalNetworkRank(3, [[0, 1], [1, 2]]) == 2", "def test_maximalNetworkRank():\n    solution = Solution()\n    assert solution.maximalNetworkRank(7, [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [0, 6], [1, 5]]) == 4"]}
{"task_num": 1616, "task_title": "Split Two Strings to Make Palindrome", "func_name": "checkPalindromeFormation", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def checkPalindromeFormation(self, a: str, b: str) -> bool:\n    return self._check(a, b) or self._check(b, a)\n\n  def _check(self, a: str, b: str) -> bool:\n    i, j = 0, len(a) - 1\n    while i < j:\n      if a[i] != b[j]:\n        return self._isPalindrome(a, i, j) or self._isPalindrome(b, i, j)\n      i += 1\n      j -= 1\n    return True\n\n  def _isPalindrome(self, s: str, i: int, j: int) -> bool:\n    while i < j:\n      if s[i] != s[j]:\n        return False\n      i += 1\n      j -= 1\n    return True\n", "tests": ["def test_checkPalindromeFormation():\n    solution = Solution()\n    assert solution.checkPalindromeFormation('abdef', 'fecab') == True", "def test_checkPalindromeFormation():\n    solution = Solution()\n    assert solution.checkPalindromeFormation('abcd', 'dcba') == True", "def test_checkPalindromeFormation():\n    solution = Solution()\n    assert solution.checkPalindromeFormation('abcdef', 'uvwxyz') == False", "def test_checkPalindromeFormation():\n    solution = Solution()\n    assert solution.checkPalindromeFormation('abba', 'baab') == True", "def test_checkPalindromeFormation():\n    solution = Solution()\n    assert solution.checkPalindromeFormation('abcda', 'zcba') == True", "def test_checkPalindromeFormation():\n    solution = Solution()\n    assert solution.checkPalindromeFormation('xxyyxx', 'yxxxyy') == True", "def test_checkPalindromeFormation():\n    solution = Solution()\n    assert solution.checkPalindromeFormation('aabbcc', 'ccbaaa') == False", "def test_checkPalindromeFormation():\n    solution = Solution()\n    assert solution.checkPalindromeFormation('aa', 'bb') == True", "def test_checkPalindromeFormation():\n    solution = Solution()\n    assert solution.checkPalindromeFormation('racecar', 'racecar') == True", "def test_checkPalindromeFormation():\n    solution = Solution()\n    assert solution.checkPalindromeFormation('abc', 'cba') == True", "def test_checkPalindromeFormation():\n    solution = Solution()\n    assert solution.checkPalindromeFormation('abcdxy', 'yxabcd') == True", "def test_checkPalindromeFormation():\n    solution = Solution()\n    assert solution.checkPalindromeFormation('abcxycba', 'mnopqrst') == True", "def test_checkPalindromeFormation():\n    solution = Solution()\n    assert solution.checkPalindromeFormation('abcd', 'efgh') == False", "def test_checkPalindromeFormation():\n    solution = Solution()\n    assert solution.checkPalindromeFormation('aabb', 'bbaa') == True", "def test_checkPalindromeFormation():\n    solution = Solution()\n    assert solution.checkPalindromeFormation('abcba', 'xyzzy') == True", "def test_checkPalindromeFormation():\n    solution = Solution()\n    assert solution.checkPalindromeFormation('abaxyz', 'yzcba') == True", "def test_checkPalindromeFormation():\n    solution = Solution()\n    assert solution.checkPalindromeFormation('xyzpqr', 'rqpyxz') == False", "def test_checkPalindromeFormation():\n    solution = Solution()\n    assert solution.checkPalindromeFormation('abcde', 'edcba') == True", "def test_checkPalindromeFormation():\n    solution = Solution()\n    assert solution.checkPalindromeFormation('abcx', 'yzba') == True", "def test_checkPalindromeFormation():\n    solution = Solution()\n    assert solution.checkPalindromeFormation('xxxxx', 'yyyyy') == True"]}
{"task_num": 1617, "task_title": "Count Subtrees With Max Distance Between Cities", "func_name": "countSubgraphsForEachDiameter", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:\n    maxMask = 1 << n\n    dist = self._floydWarshall(n, edges)\n    ans = [0] * (n - 1)\n\n    for mask in range(maxMask):\n      maxDist = self._getMaxDist(mask, dist, n)\n      if maxDist > 0:\n        ans[maxDist - 1] += 1\n\n    return ans\n\n  def _floydWarshall(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n    dist = [[n] * n for _ in range(n)]\n\n    for i in range(n):\n      dist[i][i] = 0\n\n    for u, v in edges:\n      dist[u - 1][v - 1] = 1\n      dist[v - 1][u - 1] = 1\n\n    for k in range(n):\n      for i in range(n):\n        for j in range(n):\n          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    return dist\n\n  def _getMaxDist(self, mask: int, dist: List[List[int]], n: int) -> int:\n    maxDist = 0\n    edgeCount = 0\n    cityCount = 0\n    for u in range(n):\n      if (mask >> u) & 1 == 0:\n        continue\n      cityCount += 1\n      for v in range(u + 1, n):\n        if (mask >> v) & 1 == 0:\n          continue\n        if dist[u][v] == 1:\n          edgeCount += 1\n        maxDist = max(maxDist, dist[u][v])\n\n    if edgeCount == cityCount - 1:\n      return maxDist\n    else:\n      return 0\n", "tests": ["def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    result = solution.countSubgraphsForEachDiameter(4, [[1, 2], [2, 3], [2, 4]])", "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    result = solution.countSubgraphsForEachDiameter(5, [[1, 2], [1, 3], [1, 4], [1, 5]])", "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    result = solution.countSubgraphsForEachDiameter(3, [[1, 2], [2, 3]])", "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    result = solution.countSubgraphsForEachDiameter(6, [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6]])", "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    result = solution.countSubgraphsForEachDiameter(7, [[1, 2], [2, 3], [2, 4], [4, 5], [4, 6], [4, 7]])", "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    result = solution.countSubgraphsForEachDiameter(5, [[1, 2], [1, 3], [3, 4], [3, 5]])", "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    result = solution.countSubgraphsForEachDiameter(8, [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8]])", "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    result = solution.countSubgraphsForEachDiameter(6, [[1, 2], [1, 3], [3, 4], [4, 5], [4, 6]])", "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    result = solution.countSubgraphsForEachDiameter(4, [[1, 2], [2, 3], [3, 4]])", "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    result = solution.countSubgraphsForEachDiameter(9, [[1, 2], [1, 3], [1, 4], [4, 5], [4, 6], [5, 7], [6, 8], [6, 9]])", "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    result = solution.countSubgraphsForEachDiameter(7, [[1, 2], [1, 3], [3, 4], [3, 5], [5, 6], [5, 7]])", "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    result = solution.countSubgraphsForEachDiameter(10, [[1, 2], [2, 3], [2, 4], [3, 5], [3, 6], [4, 7], [4, 8], [5, 9], [6, 10]])", "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    result = solution.countSubgraphsForEachDiameter(4, [[1, 2], [2, 3], [3, 4]])", "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    result = solution.countSubgraphsForEachDiameter(5, [[1, 2], [1, 3], [1, 4], [4, 5]])", "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    result = solution.countSubgraphsForEachDiameter(3, [[1, 2], [1, 3]])", "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    result = solution.countSubgraphsForEachDiameter(6, [[1, 2], [2, 3], [2, 4], [4, 5], [4, 6]])", "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    result = solution.countSubgraphsForEachDiameter(5, [[1, 2], [2, 3], [3, 4], [3, 5]])", "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    result = solution.countSubgraphsForEachDiameter(8, [[1, 2], [1, 3], [3, 4], [4, 5], [5, 6], [6, 7], [6, 8]])", "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    result = solution.countSubgraphsForEachDiameter(7, [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [3, 7]])", "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    result = solution.countSubgraphsForEachDiameter(9, [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [2, 7], [7, 8], [8, 9]])"]}
{"task_num": 1627, "task_title": "Graph Connectivity With Threshold", "func_name": "areConnected", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def areConnected(self, n: int, threshold: int, queries: List[List[int]]) -> List[bool]:\n    uf = UnionFind(n + 1)\n\n    for z in range(threshold + 1, n + 1):\n      for x in range(z * 2, n + 1, z):\n        uf.unionByRank(z, x)\n\n    return [uf.find(a) == uf.find(b) for a, b in queries]\n", "tests": ["def test_areConnected():\n    solution = Solution()\n    n = 6\n    threshold = 1\n    queries = [[1, 4], [2, 5], [3, 6]]\n    expected_output = [False, True, True]\n    assert solution.areConnected(n, threshold, queries) == expected_output", "def test_areConnected():\n    solution = Solution()\n    n = 10\n    threshold = 2\n    queries = [[3, 8], [4, 9], [5, 10]]\n    expected_output = [False, False, True]\n    assert solution.areConnected(n, threshold, queries) == expected_output", "def test_areConnected():\n    solution = Solution()\n    n = 15\n    threshold = 3\n    queries = [[6, 15], [7, 14], [8, 12], [10, 13]]\n    expected_output = [True, False, True, False]\n    assert solution.areConnected(n, threshold, queries) == expected_output", "def test_areConnected():\n    solution = Solution()\n    n = 20\n    threshold = 5\n    queries = [[5, 10], [9, 18], [12, 15], [16, 19]]\n    expected_output = [False, True, False, False]\n    assert solution.areConnected(n, threshold, queries) == expected_output", "def test_areConnected():\n    solution = Solution()\n    n = 7\n    threshold = 0\n    queries = [[1, 7], [2, 4], [3, 6], [5, 7]]\n    expected_output = [False, False, True, False]\n    assert solution.areConnected(n, threshold, queries) == expected_output", "def test_areConnected():\n    solution = Solution()\n    n = 12\n    threshold = 4\n    queries = [[4, 8], [6, 12], [9, 11], [10, 12]]\n    expected_output = [True, True, False, False]\n    assert solution.areConnected(n, threshold, queries) == expected_output", "def test_areConnected():\n    solution = Solution()\n    n = 25\n    threshold = 6\n    queries = [[7, 14], [8, 16], [11, 22], [21, 24]]\n    expected_output = [True, False, True, True]\n    assert solution.areConnected(n, threshold, queries) == expected_output", "def test_areConnected():\n    solution = Solution()\n    n = 30\n    threshold = 8\n    queries = [[9, 18], [12, 24], [15, 25], [20, 28]]\n    expected_output = [False, True, False, True]\n    assert solution.areConnected(n, threshold, queries) == expected_output", "def test_areConnected():\n    solution = Solution()\n    n = 18\n    threshold = 3\n    queries = [[2, 8], [4, 14], [5, 10], [11, 15]]\n    expected_output = [True, True, False, False]\n    assert solution.areConnected(n, threshold, queries) == expected_output", "def test_areConnected():\n    solution = Solution()\n    n = 22\n    threshold = 7\n    queries = [[14, 21], [3, 9], [6, 12], [16, 20]]\n    expected_output = [True, False, True, False]\n    assert solution.areConnected(n, threshold, queries) == expected_output", "def test_areConnected():\n    solution = Solution()\n    n = 5\n    threshold = 0\n    queries = [[1, 2], [2, 3], [4, 5], [1, 5]]\n    expected_output = [False, False, False, False]\n    assert solution.areConnected(n, threshold, queries) == expected_output", "def test_areConnected():\n    solution = Solution()\n    n = 16\n    threshold = 2\n    queries = [[1, 4], [7, 14], [8, 16], [5, 10]]\n    expected_output = [True, True, True, False]\n    assert solution.areConnected(n, threshold, queries) == expected_output", "def test_areConnected():\n    solution = Solution()\n    n = 28\n    threshold = 9\n    queries = [[10, 20], [15, 25], [21, 27], [2, 22]]\n    expected_output = [True, False, False, True]\n    assert solution.areConnected(n, threshold, queries) == expected_output", "def test_areConnected():\n    solution = Solution()\n    n = 24\n    threshold = 6\n    queries = [[12, 18], [8, 16], [6, 12], [10, 15]]\n    expected_output = [True, False, True, False]\n    assert solution.areConnected(n, threshold, queries) == expected_output", "def test_areConnected():\n    solution = Solution()\n    n = 14\n    threshold = 4\n    queries = [[5, 10], [7, 14], [3, 9], [2, 8]]\n    expected_output = [False, True, False, True]\n    assert solution.areConnected(n, threshold, queries) == expected_output", "def test_areConnected():\n    solution = Solution()\n    n = 26\n    threshold = 5\n    queries = [[1, 13], [4, 20], [10, 25], [12, 18]]\n    expected_output = [False, False, True, True]\n    assert solution.areConnected(n, threshold, queries) == expected_output", "def test_areConnected():\n    solution = Solution()\n    n = 9\n    threshold = 1\n    queries = [[2, 4], [3, 6], [5, 7], [6, 9]]\n    expected_output = [True, True, False, True]\n    assert solution.areConnected(n, threshold, queries) == expected_output", "def test_areConnected():\n    solution = Solution()\n    n = 17\n    threshold = 8\n    queries = [[9, 18], [4, 16], [3, 15], [7, 14]]\n    expected_output = [False, True, False, True]\n    assert solution.areConnected(n, threshold, queries) == expected_output", "def test_areConnected():\n    solution = Solution()\n    n = 11\n    threshold = 2\n    queries = [[1, 10], [2, 8], [6, 11], [9, 10]]\n    expected_output = [False, True, False, False]\n    assert solution.areConnected(n, threshold, queries) == expected_output", "def test_areConnected():\n    solution = Solution()\n    n = 8\n    threshold = 3\n    queries = [[2, 4], [3, 6], [4, 8], [5, 7]]\n    expected_output = [False, True, True, False]\n    assert solution.areConnected(n, threshold, queries) == expected_output"]}
{"task_num": 1631, "task_title": "Path With Minimum Effort", "func_name": "minimumEffortPath", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumEffortPath(self, heights: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(heights)\n    n = len(heights[0])\n    diff = [[math.inf] * n for _ in range(m)]\n    seen = set()\n\n    minHeap = [(0, 0, 0)]\n    diff[0][0] = 0\n\n    while minHeap:\n      d, i, j = heapq.heappop(minHeap)\n      if i == m - 1 and j == n - 1:\n        return d\n      seen.add((i, j))\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if (x, y) in seen:\n          continue\n        newDiff = abs(heights[i][j] - heights[x][y])\n        maxDiff = max(diff[i][j], newDiff)\n        if diff[x][y] > maxDiff:\n          diff[x][y] = maxDiff\n          heapq.heappush(minHeap, (diff[x][y], x, y))\n", "tests": ["def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[1, 2, 2], [3, 8, 2], [5, 3, 5]]\n    assert solution.minimumEffortPath(heights) == 2", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[1, 10, 6, 7, 9, 10, 4, 9]]\n    assert solution.minimumEffortPath(heights) == 9", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[3, 4, 6, 3], [4, 9, 8, 7], [5, 6, 3, 2], [7, 1, 3, 1]]\n    assert solution.minimumEffortPath(heights) == 3", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[1, 2, 1, 1, 1], [1, 2, 1, 2, 1], [1, 2, 1, 2, 1], [1, 2, 1, 2, 1], [1, 1, 1, 2, 1]]\n    assert solution.minimumEffortPath(heights) == 1", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[10, 8, 10], [9, 7, 5], [8, 7, 6]]\n    assert solution.minimumEffortPath(heights) == 2", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[1, 3, 2, 4], [6, 5, 4, 5], [7, 2, 5, 9], [3, 2, 1, 0]]\n    assert solution.minimumEffortPath(heights) == 3", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[4, 3, 2], [3, 1, 2], [2, 2, 1]]\n    assert solution.minimumEffortPath(heights) == 2", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[1, 2, 3], [3, 8, 4], [5, 3, 5], [6, 4, 2]]\n    assert solution.minimumEffortPath(heights) == 3", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[3, 8, 9, 2], [5, 3, 6, 2], [7, 4, 5, 8]]\n    assert solution.minimumEffortPath(heights) == 4", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[5, 1], [4, 6], [7, 3]]\n    assert solution.minimumEffortPath(heights) == 3", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[4, 5, 8], [3, 6, 9], [2, 7, 1], [3, 2, 4]]\n    assert solution.minimumEffortPath(heights) == 3", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[1, 3, 5, 7], [2, 4, 6, 8], [3, 5, 7, 9], [4, 6, 8, 10]]\n    assert solution.minimumEffortPath(heights) == 2", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[10, 12, 15, 20], [9, 8, 7, 6], [5, 10, 20, 25], [30, 10, 5, 1]]\n    assert solution.minimumEffortPath(heights) == 8", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[1, 2, 3, 4, 5], [5, 4, 3, 2, 1], [1, 2, 3, 4, 5], [5, 4, 3, 2, 1], [1, 2, 3, 4, 5]]\n    assert solution.minimumEffortPath(heights) == 1", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[5, 4, 3], [2, 9, 8], [1, 6, 7]]\n    assert solution.minimumEffortPath(heights) == 4", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[1, 10, 1], [10, 1, 10], [1, 10, 1]]\n    assert solution.minimumEffortPath(heights) == 9", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[8, 7, 6, 5], [7, 6, 5, 4], [6, 5, 4, 3], [5, 4, 3, 2]]\n    assert solution.minimumEffortPath(heights) == 1", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[10, 8, 5], [9, 7, 1], [4, 2, 0]]\n    assert solution.minimumEffortPath(heights) == 7", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[1, 2, 1, 1, 1], [1, 2, 1, 2, 1], [1, 2, 3, 2, 1], [1, 1, 1, 2, 1]]\n    assert solution.minimumEffortPath(heights) == 1", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[5, 10, 15], [10, 20, 25], [15, 5, 0]]\n    assert solution.minimumEffortPath(heights) == 10"]}
{"task_num": 1632, "task_title": "Rank Transform of a Matrix", "func_name": "matrixRankTransform", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self):\n    self.id = {}\n\n  def union(self, u: int, v: int) -> None:\n    self.id.setdefault(u, u)\n    self.id.setdefault(v, v)\n    i = self._find(u)\n    j = self._find(v)\n    if i != j:\n      self.id[i] = j\n\n  def getGroupIdToValues(self) -> Dict[int, List[int]]:\n    groupIdToValues = collections.defaultdict(list)\n    for u in self.id.keys():\n      groupIdToValues[self._find(u)].append(u)\n    return groupIdToValues\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def matrixRankTransform(self, matrix: List[List[int]]) -> List[List[int]]:\n    m = len(matrix)\n    n = len(matrix[0])\n    ans = [[0] * n for _ in range(m)]\n    valToGrids = collections.defaultdict(list)\n    maxRankSoFar = [0] * (m + n)\n\n    for i, row in enumerate(matrix):\n      for j, val in enumerate(row):\n        valToGrids[val].append((i, j))\n\n    for _, grids in sorted(valToGrids.items()):\n      uf = UnionFind()\n      for i, j in grids:\n        uf.union(i, j + m)\n      for values in uf.getGroupIdToValues().values():\n        maxRank = max(maxRankSoFar[i] for i in values)\n        for i in values:\n          maxRankSoFar[i] = maxRank + 1\n      for i, j in grids:\n        ans[i][j] = maxRankSoFar[i]\n\n    return ans\n", "tests": ["def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[1, 2], [3, 4]]\n    expected = [[1, 2], [2, 3]]\n    result = solution.matrixRankTransform(matrix)", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[7, 7], [7, 7]]\n    expected = [[1, 1], [1, 1]]\n    result = solution.matrixRankTransform(matrix)", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[20, -10], [-10, 20]]\n    expected = [[2, 1], [1, 2]]\n    result = solution.matrixRankTransform(matrix)", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[5, 1, 7], [2, 4, 6], [3, 8, 9]]\n    expected = [[4, 1, 6], [2, 3, 5], [3, 7, 8]]\n    result = solution.matrixRankTransform(matrix)", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[1, 3, 3], [3, 3, 2], [2, 1, 4]]\n    expected = [[1, 4, 4], [4, 4, 3], [3, 1, 5]]\n    result = solution.matrixRankTransform(matrix)", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[10, 20, 30], [20, 10, 40], [30, 40, 10]]\n    expected = [[1, 2, 3], [2, 1, 4], [3, 4, 1]]\n    result = solution.matrixRankTransform(matrix)", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[100]]\n    expected = [[1]]\n    result = solution.matrixRankTransform(matrix)", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[2, 5, 5], [5, 2, 8], [5, 8, 2]]\n    expected = [[1, 3, 3], [3, 1, 4], [3, 4, 1]]\n    result = solution.matrixRankTransform(matrix)", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[4, 3, 2, 1], [1, 2, 3, 4], [2, 1, 4, 3], [3, 4, 1, 2]]\n    expected = [[4, 3, 2, 1], [1, 2, 3, 4], [2, 1, 4, 3], [3, 4, 1, 2]]\n    result = solution.matrixRankTransform(matrix)", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[0, 1, 1], [1, 0, 0], [1, 0, 1]]\n    expected = [[1, 2, 2], [2, 1, 1], [2, 1, 2]]\n    result = solution.matrixRankTransform(matrix)", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[3, 3, 1], [3, 2, 2], [1, 2, 3]]\n    expected = [[3, 3, 1], [3, 2, 2], [1, 2, 3]]\n    result = solution.matrixRankTransform(matrix)", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[5, 9, 7], [9, 5, 8], [7, 8, 5]]\n    expected = [[1, 3, 2], [3, 1, 3], [2, 2, 1]]\n    result = solution.matrixRankTransform(matrix)", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[8, 7, 6], [6, 5, 9], [9, 6, 5]]\n    expected = [[3, 2, 1], [1, 1, 3], [3, 2, 1]]\n    result = solution.matrixRankTransform(matrix)", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[3, 3, 3], [3, 4, 3], [3, 3, 3]]\n    expected = [[1, 1, 1], [1, 2, 1], [1, 1, 1]]\n    result = solution.matrixRankTransform(matrix)", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[10, 20, 10], [20, 30, 20], [10, 20, 30]]\n    expected = [[1, 2, 1], [2, 3, 2], [1, 2, 3]]\n    result = solution.matrixRankTransform(matrix)", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[5, 5, 5], [5, 6, 5], [5, 5, 7]]\n    expected = [[1, 1, 1], [1, 2, 1], [1, 1, 2]]\n    result = solution.matrixRankTransform(matrix)", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[4, 4, 4, 4], [4, 5, 5, 4], [4, 5, 6, 4], [4, 4, 4, 4]]\n    expected = [[1, 1, 1, 1], [1, 2, 2, 1], [1, 2, 3, 1], [1, 1, 1, 1]]\n    result = solution.matrixRankTransform(matrix)", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[1, 100, 1], [100, 1, 100], [1, 100, 1]]\n    expected = [[1, 3, 1], [3, 1, 3], [1, 3, 1]]\n    result = solution.matrixRankTransform(matrix)", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[2, 2, 3], [3, 2, 1], [2, 3, 3]]\n    expected = [[2, 2, 3], [3, 2, 1], [2, 3, 3]]\n    result = solution.matrixRankTransform(matrix)", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[-1, -2, -3], [0, -1, -2], [1, 0, -1]]\n    expected = [[2, 1, 1], [3, 2, 1], [4, 3, 2]]\n    result = solution.matrixRankTransform(matrix)"]}
{"task_num": 1654, "task_title": "Minimum Jumps to Reach Home", "func_name": "minimumJumps", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import Enum\n\n\nclass Direction(Enum):\n  kForward = 0\n  kBackward = 1\n\n\nclass Solution:\n  def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\n    furthest = max(x + a + b, max(pos + a + b for pos in forbidden))\n    seenForward = {pos for pos in forbidden}\n    seenBackward = {pos for pos in forbidden}\n\n    q = collections.deque([(Direction.kForward, 0)])\n\n    ans = 0\n    while q:\n      for _ in range(len(q)):\n        dir, pos = q.popleft()\n        if pos == x:\n          return ans\n        forward = pos + a\n        backward = pos - b\n        if forward <= furthest and forward not in seenForward:\n          seenForward.add(forward)\n          q.append((Direction.kForward, forward))\n        if dir == Direction.kForward and backward >= 0 and backward not in seenBackward:\n          seenBackward.add(backward)\n          q.append((Direction.kBackward, backward))\n      ans += 1\n\n    return -1\n", "tests": ["def test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([14, 4, 18, 1, 15], 3, 15, 9) == 3", "def test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([8, 3, 16, 6, 12, 20], 15, 13, 11) == -1", "def test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([5, 6, 7, 8, 9], 4, 1, 10) == 3", "def test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([], 2, 1, 2) == 1", "def test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([1, 6, 2, 14], 3, 2, 12) == 4", "def test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([4, 10, 12, 13], 5, 3, 8) == 2", "def test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([19, 14, 9, 10], 10, 9, 7) == -1", "def test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([2, 4, 6, 8, 10], 1, 2, 5) == 5", "def test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([11, 12, 13, 14], 2, 2, 3) == 3", "def test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([3, 7, 12, 18], 4, 3, 6) == 2", "def test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([], 1, 1, 1) == 1", "def test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([5, 10, 15], 2, 1, 9) == 6", "def test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([1], 2, 2, 4) == 2", "def test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([7, 11, 13, 19], 3, 5, 2) == -1", "def test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([0, 1, 2], 5, 3, 8) == -1", "def test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([8, 14, 18], 6, 5, 23) == 4", "def test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([3, 5, 9], 4, 2, 13) == 3", "def test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([2, 4, 6, 8], 1, 3, 7) == 7", "def test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([6, 13, 14, 17], 4, 3, 10) == 4", "def test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([1, 3, 5, 7, 9], 2, 1, 8) == 5"]}
{"task_num": 1655, "task_title": "Distribute Repeating Integers", "func_name": "canDistribute", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\n    freqs = list(collections.Counter(nums).values())\n    validDistribution = self._getValidDistribution(freqs, quantity)\n    n = len(freqs)\n    m = len(quantity)\n    maxMask = 1 << m\n    dp = [[False] * maxMask for _ in range(n + 1)]\n    dp[n][maxMask - 1] = True\n\n    for i in range(n - 1, -1, -1):\n      for mask in range(maxMask):\n        dp[i][mask] = dp[i + 1][mask]\n        availableMask = ~mask & (maxMask - 1)\n        submask = availableMask\n        while submask > 0:\n          if validDistribution[i][submask]:\n            dp[i][mask] = dp[i][mask] or dp[i + 1][mask | submask]\n          submask = (submask - 1) & availableMask\n\n    return dp[0][0]\n\n  def _getValidDistribution(self, freqs: List[int], quantity: List[int]) -> List[List[bool]]:\n    maxMask = 1 << len(quantity)\n    validDistribution = [[False] * maxMask for _ in range(len(freqs))]\n    for i, freq in enumerate(freqs):\n      for mask in range(maxMask):\n        if freq >= self._getQuantitySum(quantity, mask):\n          validDistribution[i][mask] = True\n    return validDistribution\n\n  def _getQuantitySum(self, quantity: List[int], mask: int) -> int:\n    res=[]\n    for i, q in enumerate(quantity):\n      if mask >> i & 1:\n        res.append(q)\n    return sum(res)\n", "tests": ["def test_canDistribute():\n    solution = Solution()\n    nums = [1, 2, 3, 4, 4, 4, 5, 5, 6, 6, 7, 7]\n    quantity = [2, 3, 2, 2]\n    assert solution.canDistribute(nums, quantity) == True", "def test_canDistribute():\n    solution = Solution()\n    nums = [1, 1, 2, 2, 2, 3, 3, 3, 3]\n    quantity = [2, 2, 2, 3]\n    assert solution.canDistribute(nums, quantity) == False", "def test_canDistribute():\n    solution = Solution()\n    nums = [4, 4, 4, 4, 4, 4]\n    quantity = [6]\n    assert solution.canDistribute(nums, quantity) == True", "def test_canDistribute():\n    solution = Solution()\n    nums = [1, 1, 1, 2, 2, 3]\n    quantity = [2, 2, 2]\n    assert solution.canDistribute(nums, quantity) == False", "def test_canDistribute():\n    solution = Solution()\n    nums = [5, 5, 5, 6, 6, 7, 7, 7]\n    quantity = [1, 1, 3, 2]\n    assert solution.canDistribute(nums, quantity) == True", "def test_canDistribute():\n    solution = Solution()\n    nums = [8, 8, 9, 9, 9, 10]\n    quantity = [3, 2]\n    assert solution.canDistribute(nums, quantity) == True", "def test_canDistribute():\n    solution = Solution()\n    nums = [12, 13, 13, 14, 14, 14, 14, 15]\n    quantity = [3, 1, 2, 2]\n    assert solution.canDistribute(nums, quantity) == True", "def test_canDistribute():\n    solution = Solution()\n    nums = [4, 4, 5, 5, 6, 6, 6, 7, 7]\n    quantity = [3, 2, 3]\n    assert solution.canDistribute(nums, quantity) == False", "def test_canDistribute():\n    solution = Solution()\n    nums = [1, 2, 2, 3, 3, 3, 4, 4, 5, 5, 5, 5]\n    quantity = [4, 3, 2]\n    assert solution.canDistribute(nums, quantity) == True", "def test_canDistribute():\n    solution = Solution()\n    nums = [1, 1, 1, 2, 2, 3, 3, 3, 3, 4, 4]\n    quantity = [3, 1, 4, 1]\n    assert solution.canDistribute(nums, quantity) == True", "def test_canDistribute():\n    solution = Solution()\n    nums = [3, 3, 3, 4, 5, 5, 6, 6, 7]\n    quantity = [2, 3, 2, 2]\n    assert solution.canDistribute(nums, quantity) == False", "def test_canDistribute():\n    solution = Solution()\n    nums = [10, 10, 10, 11, 11, 12]\n    quantity = [3, 1, 2]\n    assert solution.canDistribute(nums, quantity) == True", "def test_canDistribute():\n    solution = Solution()\n    nums = [1, 2, 2, 2, 3, 3, 3, 4, 4, 5]\n    quantity = [2, 2, 2, 3]\n    assert solution.canDistribute(nums, quantity) == False", "def test_canDistribute():\n    solution = Solution()\n    nums = [7, 7, 7, 8, 8, 9, 9]\n    quantity = [3, 2, 1]\n    assert solution.canDistribute(nums, quantity) == True", "def test_canDistribute():\n    solution = Solution()\n    nums = [2, 2, 3, 3, 4, 4, 4]\n    quantity = [2, 2, 2]\n    assert solution.canDistribute(nums, quantity) == True", "def test_canDistribute():\n    solution = Solution()\n    nums = [1, 1, 2, 3, 3, 3, 3, 4, 4, 5, 5, 5, 5]\n    quantity = [4, 4, 2, 1]\n    assert solution.canDistribute(nums, quantity) == True", "def test_canDistribute():\n    solution = Solution()\n    nums = [10, 10, 20, 20, 30, 30, 30, 40, 50, 50]\n    quantity = [3, 3, 2]\n    assert solution.canDistribute(nums, quantity) == True", "def test_canDistribute():\n    solution = Solution()\n    nums = [6, 6, 6, 7, 8, 8, 9, 9, 9, 10]\n    quantity = [2, 3, 3, 1]\n    assert solution.canDistribute(nums, quantity) == False", "def test_canDistribute():\n    solution = Solution()\n    nums = [2, 2, 2, 3, 3, 4, 4, 5, 5, 5]\n    quantity = [3, 2, 2, 2]\n    assert solution.canDistribute(nums, quantity) == True", "def test_canDistribute():\n    solution = Solution()\n    nums = [1, 1, 1, 1, 1, 2, 3, 3, 4, 4, 4, 5]\n    quantity = [5, 3, 2]\n    assert solution.canDistribute(nums, quantity) == True"]}
{"task_num": 1681, "task_title": "Minimum Incompatibility", "func_name": "minimumIncompatibility", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def __init__(self):\n    self.kMaxNum = 16\n\n  def minimumIncompatibility(self, nums: List[int], k: int) -> int:\n    kMaxCompatibility = (16 - 1) * (16 // 2)\n    n = len(nums)\n    subsetSize = n // k\n    maxMask = 1 << n\n    incompatibilities = self._getIncompatibilities(nums, subsetSize)\n\n    dp = [kMaxCompatibility] * maxMask\n    dp[0] = 0\n\n    for mask in range(1, maxMask):\n      if mask.bit_count() % subsetSize != 0:\n        continue\n      submask = mask\n      while submask > 0:\n        if incompatibilities[submask] != -1:\n          dp[mask] = min(dp[mask], dp[mask - submask] + incompatibilities[submask])\n        submask = (submask - 1) & mask\n\n    if dp[-1] != kMaxCompatibility:\n      return dp[-1]\n    else:\n      return -1\n\n  def _getIncompatibilities(self, nums: List[int], subsetSize: int) -> List[int]:\n    maxMask = 1 << len(nums)\n    incompatibilities = [-1] * maxMask\n    for mask in range(maxMask):\n      if mask.bit_count() == subsetSize and self._isUnique(nums, mask, subsetSize):\n        incompatibilities[mask] = self._getIncompatibility(nums, mask)\n    return incompatibilities\n\n  def _isUnique(self, nums: List[int], mask: int, subsetSize: int) -> bool:\n    used = 0\n    for i, num in enumerate(nums):\n      if mask >> i & 1:\n        used |= 1 << num\n    return used.bit_count() == subsetSize\n\n  def _getIncompatibility(self, nums: List[int], mask: int) -> int:\n    mini = self.kMaxNum\n    maxi = 0\n    for i, num in enumerate(nums):\n      if mask >> i & 1:\n        maxi = max(maxi, num)\n        mini = min(mini, num)\n    return maxi - mini\n", "tests": ["def test_minimumIncompatibility():\n    solution = Solution()\n    assert solution.minimumIncompatibility([1, 2, 1, 4], 2) == 4", "def test_minimumIncompatibility():\n    solution = Solution()\n    assert solution.minimumIncompatibility([6, 3, 8, 1, 3, 1, 2, 2], 4) == 6", "def test_minimumIncompatibility():\n    solution = Solution()\n    assert solution.minimumIncompatibility([5, 3, 3, 6, 3, 6, 8, 8], 4) == -1", "def test_minimumIncompatibility():\n    solution = Solution()\n    assert solution.minimumIncompatibility([1, 2, 3, 4], 1) == 3", "def test_minimumIncompatibility():\n    solution = Solution()\n    assert solution.minimumIncompatibility([1, 2, 1, 4, 5, 6], 3) == 4", "def test_minimumIncompatibility():\n    solution = Solution()\n    assert solution.minimumIncompatibility([7, 3, 1, 9, 4, 8], 2) == 4", "def test_minimumIncompatibility():\n    solution = Solution()\n    assert solution.minimumIncompatibility([10, 10, 6, 5, 4, 4], 3) == -1", "def test_minimumIncompatibility():\n    solution = Solution()\n    assert solution.minimumIncompatibility([4, 1, 2, 3, 5, 6, 7, 8], 4) == 0", "def test_minimumIncompatibility():\n    solution = Solution()\n    assert solution.minimumIncompatibility([9, 1, 5, 1, 6, 7, 5, 9, 3, 4], 5) == 8", "def test_minimumIncompatibility():\n    solution = Solution()\n    assert solution.minimumIncompatibility([1, 1, 1, 1, 2, 3, 4, 5], 4) == -1", "def test_minimumIncompatibility():\n    solution = Solution()\n    assert solution.minimumIncompatibility([3, 3, 2, 1, 4, 5, 6, 7], 4) == 2", "def test_minimumIncompatibility():\n    solution = Solution()\n    assert solution.minimumIncompatibility([2, 2, 4, 4, 6, 6, 8, 8], 4) == 0", "def test_minimumIncompatibility():\n    solution = Solution()\n    assert solution.minimumIncompatibility([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) == 8", "def test_minimumIncompatibility():\n    solution = Solution()\n    assert solution.minimumIncompatibility([15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0], 8) == 7", "def test_minimumIncompatibility():\n    solution = Solution()\n    assert solution.minimumIncompatibility([1, 3, 3, 6, 9, 9, 12, 12], 4) == 6", "def test_minimumIncompatibility():\n    solution = Solution()\n    assert solution.minimumIncompatibility([4, 5, 5, 6, 7, 7, 8, 8], 4) == -1", "def test_minimumIncompatibility():\n    solution = Solution()\n    assert solution.minimumIncompatibility([2, 4, 8, 8, 10, 10, 12, 14], 4) == 8", "def test_minimumIncompatibility():\n    solution = Solution()\n    assert solution.minimumIncompatibility([1, 2, 2, 3, 4, 5, 5, 6, 7, 8], 5) == 5", "def test_minimumIncompatibility():\n    solution = Solution()\n    assert solution.minimumIncompatibility([5, 5, 5, 6, 6, 6, 7, 8], 2) == -1", "def test_minimumIncompatibility():\n    solution = Solution()\n    assert solution.minimumIncompatibility([1, 1, 2, 2, 3, 3, 4, 4], 4) == 0"]}
{"task_num": 1687, "task_title": "Delivering Boxes from Storage to Ports", "func_name": "boxDelivering", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\n    n = len(boxes)\n    dp = [0] * (n + 1)\n    trips = 2\n    weight = 0\n\n    l = 0\n    for r in range(n):\n      weight += boxes[r][1]\n\n      if r > 0 and boxes[r][0] != boxes[r - 1][0]:\n        trips += 1\n\n      while r - l + 1 > maxBoxes or weight > maxWeight or (l < r and dp[l + 1] == dp[l]):\n        weight -= boxes[l][1]\n        if boxes[l][0] != boxes[l + 1][0]:\n          trips -= 1\n        l += 1\n\n      dp[r + 1] = dp[l] + trips\n\n    return dp[n]\n", "tests": ["def test_boxDelivering():\n    solution = Solution()\n    boxes = [[1, 1], [2, 1], [1, 1], [2, 1], [1, 1]]\n    portsCount = 2\n    maxBoxes = 3\n    maxWeight = 3\n    assert solution.boxDelivering(boxes, portsCount, maxBoxes, maxWeight) == 6", "def test_boxDelivering():\n    solution = Solution()\n    boxes = [[1, 2], [1, 4], [2, 1], [2, 2], [3, 1]]\n    portsCount = 3\n    maxBoxes = 4\n    maxWeight = 7\n    assert solution.boxDelivering(boxes, portsCount, maxBoxes, maxWeight) == 4", "def test_boxDelivering():\n    solution = Solution()\n    boxes = [[1, 5], [2, 4], [3, 3], [3, 3], [2, 2]]\n    portsCount = 3\n    maxBoxes = 3\n    maxWeight = 9\n    assert solution.boxDelivering(boxes, portsCount, maxBoxes, maxWeight) == 5", "def test_boxDelivering():\n    solution = Solution()\n    boxes = [[2, 3], [2, 5], [1, 1], [1, 1], [1, 1]]\n    portsCount = 3\n    maxBoxes = 3\n    maxWeight = 5\n    assert solution.boxDelivering(boxes, portsCount, maxBoxes, maxWeight) == 7", "def test_boxDelivering():\n    solution = Solution()\n    boxes = [[1, 3], [1, 3], [2, 4], [3, 2], [3, 1], [2, 2]]\n    portsCount = 4\n    maxBoxes = 4\n    maxWeight = 8\n    assert solution.boxDelivering(boxes, portsCount, maxBoxes, maxWeight) == 6", "def test_boxDelivering():\n    solution = Solution()\n    boxes = [[1, 2], [2, 1], [3, 2], [4, 3], [5, 1]]\n    portsCount = 5\n    maxBoxes = 5\n    maxWeight = 10\n    assert solution.boxDelivering(boxes, portsCount, maxBoxes, maxWeight) == 5", "def test_boxDelivering():\n    solution = Solution()\n    boxes = [[1, 5], [1, 5], [2, 2], [2, 4], [3, 1], [3, 3]]\n    portsCount = 3\n    maxBoxes = 3\n    maxWeight = 10\n    assert solution.boxDelivering(boxes, portsCount, maxBoxes, maxWeight) == 6", "def test_boxDelivering():\n    solution = Solution()\n    boxes = [[1, 1], [1, 1], [1, 1], [2, 1], [2, 1], [3, 1], [3, 1]]\n    portsCount = 3\n    maxBoxes = 5\n    maxWeight = 5\n    assert solution.boxDelivering(boxes, portsCount, maxBoxes, maxWeight) == 5", "def test_boxDelivering():\n    solution = Solution()\n    boxes = [[1, 4], [2, 4], [2, 3], [3, 2], [1, 2]]\n    portsCount = 3\n    maxBoxes = 3\n    maxWeight = 9\n    assert solution.boxDelivering(boxes, portsCount, maxBoxes, maxWeight) == 6", "def test_boxDelivering():\n    solution = Solution()\n    boxes = [[1, 1], [2, 2], [3, 3], [4, 4], [4, 1], [3, 1]]\n    portsCount = 4\n    maxBoxes = 3\n    maxWeight = 8\n    assert solution.boxDelivering(boxes, portsCount, maxBoxes, maxWeight) == 7", "def test_boxDelivering():\n    solution = Solution()\n    boxes = [[1, 3], [2, 6], [2, 2], [3, 5], [3, 2], [1, 4]]\n    portsCount = 3\n    maxBoxes = 2\n    maxWeight = 6\n    assert solution.boxDelivering(boxes, portsCount, maxBoxes, maxWeight) == 9", "def test_boxDelivering():\n    solution = Solution()\n    boxes = [[2, 1], [2, 2], [3, 3], [4, 2], [5, 2], [5, 1]]\n    portsCount = 5\n    maxBoxes = 4\n    maxWeight = 10\n    assert solution.boxDelivering(boxes, portsCount, maxBoxes, maxWeight) == 6", "def test_boxDelivering():\n    solution = Solution()\n    boxes = [[1, 2], [3, 2], [3, 2], [3, 2], [2, 1], [1, 1]]\n    portsCount = 3\n    maxBoxes = 3\n    maxWeight = 6\n    assert solution.boxDelivering(boxes, portsCount, maxBoxes, maxWeight) == 8", "def test_boxDelivering():\n    solution = Solution()\n    boxes = [[1, 1], [1, 1], [2, 2], [3, 3], [3, 1], [4, 2]]\n    portsCount = 4\n    maxBoxes = 4\n    maxWeight = 7\n    assert solution.boxDelivering(boxes, portsCount, maxBoxes, maxWeight) == 6", "def test_boxDelivering():\n    solution = Solution()\n    boxes = [[2, 3], [2, 2], [3, 4], [1, 1], [1, 1], [4, 2]]\n    portsCount = 4\n    maxBoxes = 3\n    maxWeight = 5\n    assert solution.boxDelivering(boxes, portsCount, maxBoxes, maxWeight) == 8", "def test_boxDelivering():\n    solution = Solution()\n    boxes = [[1, 1], [2, 3], [2, 3], [3, 2], [4, 2], [4, 1], [3, 2]]\n    portsCount = 4\n    maxBoxes = 5\n    maxWeight = 9\n    assert solution.boxDelivering(boxes, portsCount, maxBoxes, maxWeight) == 7", "def test_boxDelivering():\n    solution = Solution()\n    boxes = [[1, 3], [2, 3], [1, 2], [2, 1], [3, 3], [3, 1]]\n    portsCount = 3\n    maxBoxes = 3\n    maxWeight = 7\n    assert solution.boxDelivering(boxes, portsCount, maxBoxes, maxWeight) == 7", "def test_boxDelivering():\n    solution = Solution()\n    boxes = [[3, 4], [2, 4], [1, 3], [1, 2], [4, 1], [4, 1]]\n    portsCount = 4\n    maxBoxes = 3\n    maxWeight = 8\n    assert solution.boxDelivering(boxes, portsCount, maxBoxes, maxWeight) == 8", "def test_boxDelivering():\n    solution = Solution()\n    boxes = [[2, 5], [2, 1], [3, 4], [4, 1], [4, 3], [1, 2]]\n    portsCount = 4\n    maxBoxes = 4\n    maxWeight = 10\n    assert solution.boxDelivering(boxes, portsCount, maxBoxes, maxWeight) == 7", "def test_boxDelivering():\n    solution = Solution()\n    boxes = [[1, 1], [2, 2], [3, 3], [1, 1], [3, 2], [2, 1]]\n    portsCount = 3\n    maxBoxes = 4\n    maxWeight = 5\n    assert solution.boxDelivering(boxes, portsCount, maxBoxes, maxWeight) == 8"]}
{"task_num": 1705, "task_title": "Maximum Number of Eaten Apples", "func_name": "eatenApples", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def eatenApples(self, apples: List[int], days: List[int]) -> int:\n    n = len(apples)\n    ans = 0\n    minHeap = []\n\n    i = 0\n    while i < n or minHeap:\n      while minHeap and minHeap[0][0] <= i:\n        heapq.heappop(minHeap)\n      if i < n and apples[i] > 0:\n        heapq.heappush(minHeap, (i + days[i], apples[i]))\n      if minHeap:\n        rottenDay, numApples = heapq.heappop(minHeap)\n        if numApples > 1:\n          heapq.heappush(minHeap, (rottenDay, numApples - 1))\n        ans += 1\n      i += 1\n\n    return ans\n", "tests": ["def test_eatenApples():\n    solution = Solution()\n    assert solution.eatenApples([1, 2, 3, 5, 2], [3, 2, 1, 4, 2]) == 7", "def test_eatenApples():\n    solution = Solution()\n    assert solution.eatenApples([3, 0, 0, 0, 0], [3, 0, 0, 0, 0]) == 3", "def test_eatenApples():\n    solution = Solution()\n    assert solution.eatenApples([0, 0, 0, 0, 5], [0, 0, 0, 0, 2]) == 2", "def test_eatenApples():\n    solution = Solution()\n    assert solution.eatenApples([2, 1, 10], [2, 10, 1]) == 4", "def test_eatenApples():\n    solution = Solution()\n    assert solution.eatenApples([1, 0, 2, 0, 3], [3, 0, 2, 0, 1]) == 5", "def test_eatenApples():\n    solution = Solution()\n    assert solution.eatenApples([5, 1, 0, 0, 0], [1, 5, 0, 0, 0]) == 6", "def test_eatenApples():\n    solution = Solution()\n    assert solution.eatenApples([0, 0, 0, 4, 5], [0, 0, 0, 3, 2]) == 5", "def test_eatenApples():\n    solution = Solution()\n    assert solution.eatenApples([1, 2, 3, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0]) == 3", "def test_eatenApples():\n    solution = Solution()\n    assert solution.eatenApples([2, 2, 0, 0, 2], [3, 1, 0, 0, 1]) == 5", "def test_eatenApples():\n    solution = Solution()\n    assert solution.eatenApples([1, 1, 4, 0, 2], [2, 2, 1, 0, 3]) == 6", "def test_eatenApples():\n    solution = Solution()\n    assert solution.eatenApples([0, 2, 2, 2, 0], [0, 2, 3, 1, 0]) == 6", "def test_eatenApples():\n    solution = Solution()\n    assert solution.eatenApples([3, 0, 1, 0, 0, 4], [3, 0, 1, 0, 0, 2]) == 7", "def test_eatenApples():\n    solution = Solution()\n    assert solution.eatenApples([2, 3, 0, 0, 1], [1, 2, 0, 0, 4]) == 6", "def test_eatenApples():\n    solution = Solution()\n    assert solution.eatenApples([0, 0, 5, 0, 0, 1], [0, 0, 1, 0, 0, 2]) == 3", "def test_eatenApples():\n    solution = Solution()\n    assert solution.eatenApples([1, 2, 0, 3, 0], [2, 1, 0, 2, 0]) == 5", "def test_eatenApples():\n    solution = Solution()\n    assert solution.eatenApples([4, 0, 0, 2, 1], [2, 0, 0, 1, 3]) == 6", "def test_eatenApples():\n    solution = Solution()\n    assert solution.eatenApples([1, 2, 3, 4, 5], [5, 4, 3, 2, 1]) == 15", "def test_eatenApples():\n    solution = Solution()\n    assert solution.eatenApples([3, 1, 0, 3, 0], [3, 1, 0, 1, 0]) == 6", "def test_eatenApples():\n    solution = Solution()\n    assert solution.eatenApples([0, 3, 0, 0, 3], [0, 1, 0, 0, 3]) == 4", "def test_eatenApples():\n    solution = Solution()\n    assert solution.eatenApples([4, 4, 0, 0, 0, 1], [2, 5, 0, 0, 0, 3]) == 8"]}
{"task_num": 1706, "task_title": "Where Will the Ball Fall", "func_name": "findBall", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findBall(self, grid: List[List[int]]) -> List[int]:\n    m = len(grid)\n    n = len(grid[0])\n    dp = [i for i in range(n)]\n    ans = [-1] * n\n\n    for i in range(m):\n      newDp = [-1] * n\n      for j in range(n):\n        if j + grid[i][j] < 0 or j + grid[i][j] == n:\n          continue\n        if grid[i][j] == 1 and grid[i][j + 1] == -1 or grid[i][j] == -1 and grid[i][j - 1] == 1:\n          continue\n        newDp[j + grid[i][j]] = dp[j]\n      dp = newDp\n\n    for i, ball in enumerate(dp):\n      if ball != -1:\n        ans[ball] = i\n\n    return ans\n", "tests": ["def test_findBall():\n    solution = Solution()\n    grid = [[1, 1, -1, -1], [-1, -1, 1, 1], [1, 1, -1, -1]]\n    assert solution.findBall(grid) == [1, -1, -1, 1]", "def test_findBall():\n    solution = Solution()\n    grid = [[1, -1, 1, -1], [-1, 1, -1, 1], [1, -1, 1, -1], [-1, 1, -1, 1]]\n    assert solution.findBall(grid) == [-1, -1, -1, -1]", "def test_findBall():\n    solution = Solution()\n    grid = [[1, 1], [-1, -1]]\n    assert solution.findBall(grid) == [-1, -1]", "def test_findBall():\n    solution = Solution()\n    grid = [[-1], [-1], [-1]]\n    assert solution.findBall(grid) == [-1]", "def test_findBall():\n    solution = Solution()\n    grid = [[1, 1, 1], [1, 1, 1], [-1, -1, -1]]\n    assert solution.findBall(grid) == [-1, -1, -1]", "def test_findBall():\n    solution = Solution()\n    grid = [[1, -1, 1], [1, 1, -1], [-1, 1, 1]]\n    assert solution.findBall(grid) == [-1, 2, -1]", "def test_findBall():\n    solution = Solution()\n    grid = [[1, 1, 1, -1, -1], [1, 1, 1, -1, -1], [-1, -1, -1, 1, 1], [1, 1, 1, -1, -1]]\n    assert solution.findBall(grid) == [0, 1, 2, -1, -1]", "def test_findBall():\n    solution = Solution()\n    grid = [[1, -1, -1, 1, 1], [-1, 1, 1, -1, -1], [1, 1, -1, -1, 1], [-1, -1, 1, 1, -1]]\n    assert solution.findBall(grid) == [-1, -1, -1, -1, -1]", "def test_findBall():\n    solution = Solution()\n    grid = [[-1, 1, -1, 1], [1, -1, 1, -1], [-1, 1, -1, 1], [1, -1, 1, -1]]\n    assert solution.findBall(grid) == [-1, -1, -1, -1]", "def test_findBall():\n    solution = Solution()\n    grid = [[1, 1, -1, -1, 1], [-1, -1, 1, 1, -1], [1, -1, -1, 1, 1], [1, 1, 1, -1, -1]]\n    assert solution.findBall(grid) == [-1, -1, -1, 0, 1]", "def test_findBall():\n    solution = Solution()\n    grid = [[1, -1, 1, -1, 1], [-1, 1, -1, 1, -1], [1, 1, -1, -1, 1], [-1, -1, 1, 1, -1]]\n    assert solution.findBall(grid) == [-1, -1, -1, -1, -1]", "def test_findBall():\n    solution = Solution()\n    grid = [[-1, -1, -1, -1], [-1, -1, -1, -1], [-1, -1, -1, -1]]\n    assert solution.findBall(grid) == [-1, -1, -1, -1]", "def test_findBall():\n    solution = Solution()\n    grid = [[1, 1, 1, 1, -1], [-1, -1, -1, 1, 1], [1, 1, -1, -1, -1], [-1, 1, 1, 1, 1]]\n    assert solution.findBall(grid) == [2, -1, 2, 0, -1]", "def test_findBall():\n    solution = Solution()\n    grid = [[1, 1, 1, -1, 1], [-1, 1, -1, 1, -1], [1, -1, 1, -1, 1], [-1, 1, -1, 1, -1]]\n    assert solution.findBall(grid) == [-1, -1, -1, -1, -1]", "def test_findBall():\n    solution = Solution()\n    grid = [[1, -1, -1, 1], [1, 1, -1, -1], [-1, 1, 1, -1], [1, -1, 1, -1]]\n    assert solution.findBall(grid) == [-1, 1, 0, -1]", "def test_findBall():\n    solution = Solution()\n    grid = [[1, 1, 1, 1, 1], [-1, -1, -1, -1, -1], [1, 1, 1, 1, 1], [-1, -1, -1, -1, -1]]\n    assert solution.findBall(grid) == [-1, -1, -1, -1, -1]", "def test_findBall():\n    solution = Solution()\n    grid = [[1, 1, -1], [1, 1, 1], [-1, -1, -1], [1, -1, 1]]\n    assert solution.findBall(grid) == [1, -1, -1]", "def test_findBall():\n    solution = Solution()\n    grid = [[1, -1, 1, 1, -1], [1, 1, -1, -1, 1], [-1, 1, 1, -1, -1], [1, -1, -1, 1, -1]]\n    assert solution.findBall(grid) == [-1, 0, 1, -1, -1]", "def test_findBall():\n    solution = Solution()\n    grid = [[1, 1, 1, 1], [-1, -1, -1, -1], [1, 1, -1, -1], [-1, -1, 1, 1]]\n    assert solution.findBall(grid) == [-1, -1, -1, -1]", "def test_findBall():\n    solution = Solution()\n    grid = [[1, -1, -1, 1, 1], [1, 1, -1, -1, -1], [-1, -1, 1, 1, 1], [1, -1, 1, -1, -1]]\n    assert solution.findBall(grid) == [-1, 0, 2, -1, -1]"]}
{"task_num": 1707, "task_title": "Maximum XOR With an Element From Array", "func_name": "maximizeXor", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Optional\n\nclass TrieNode:\n  def __init__(self):\n    self.children: List[Optional[TrieNode]] = [None] * 2\n\n\nclass BitTrie:\n  def __init__(self, maxBit: int):\n    self.maxBit = maxBit\n    self.root = TrieNode()\n\n  def insert(self, num: int) -> None:\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n\n  def getMaxXor(self, num: int) -> int:\n    maxXor = 0\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      toggleBit = bit ^ 1\n      if node.children[toggleBit]:\n        maxXor = maxXor | 1 << i\n        node = node.children[toggleBit]\n      elif node.children[bit]:\n        node = node.children[bit]\n      else:\n        return 0\n    return maxXor\n\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, x: int, m: int):\n    self.queryIndex = queryIndex\n    self.x = x\n    self.m = m\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.x\n    yield self.m\n\n\nclass Solution:\n  def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n    ans = [-1] * len(queries)\n    maxBit = int(math.log2(max(max(nums), max(x for x, _ in queries))))\n    bitTrie = BitTrie(maxBit)\n\n    nums.sort()\n\n    i = 0\n    for queryIndex, x, m in sorted([IndexedQuery(i, x, m) for i, (x, m) in enumerate(queries)], key=lambda iq: iq.m):\n      while i < len(nums) and nums[i] <= m:\n        bitTrie.insert(nums[i])\n        i += 1\n      if i > 0 and nums[i - 1] <= m:\n        ans[queryIndex] = bitTrie.getMaxXor(x)\n\n    return ans\n", "tests": ["def test_maximizeXor():\n    solution = Solution()\n    nums = [0, 1, 2, 3, 4]\n    queries = [[3, 1], [1, 3], [5, 6]]\n    expected_output = [3, 3, 7]\n    assert solution.maximizeXor(nums, queries) == expected_output", "def test_maximizeXor():\n    solution = Solution()\n    nums = [5, 1, 7, 4, 6]\n    queries = [[10, 5], [1, 0], [3, 9]]\n    expected_output = [7, -1, 7]\n    assert solution.maximizeXor(nums, queries) == expected_output", "def test_maximizeXor():\n    solution = Solution()\n    nums = [8, 2, 10, 12]\n    queries = [[15, 11], [0, 3], [9, 15]]\n    expected_output = [10, 2, 11]\n    assert solution.maximizeXor(nums, queries) == expected_output", "def test_maximizeXor():\n    solution = Solution()\n    nums = [13, 7, 3, 11, 5]\n    queries = [[10, 5], [6, 7], [14, 9]]\n    expected_output = [15, 13, 15]\n    assert solution.maximizeXor(nums, queries) == expected_output", "def test_maximizeXor():\n    solution = Solution()\n    nums = [1, 2, 4, 8, 16]\n    queries = [[3, 2], [7, 8], [10, 15]]\n    expected_output = [3, 15, 14]\n    assert solution.maximizeXor(nums, queries) == expected_output", "def test_maximizeXor():\n    solution = Solution()\n    nums = [0, 7, 9, 12, 15]\n    queries = [[6, 10], [2, 1], [11, 14]]\n    expected_output = [15, 0, 15]\n    assert solution.maximizeXor(nums, queries) == expected_output", "def test_maximizeXor():\n    solution = Solution()\n    nums = [3, 6, 9, 11]\n    queries = [[8, 10], [1, 4], [5, 5]]\n    expected_output = [11, 7, 7]\n    assert solution.maximizeXor(nums, queries) == expected_output", "def test_maximizeXor():\n    solution = Solution()\n    nums = [2, 5, 8, 14, 18]\n    queries = [[4, 6], [10, 13], [3, 15]]\n    expected_output = [7, 15, 15]\n    assert solution.maximizeXor(nums, queries) == expected_output", "def test_maximizeXor():\n    solution = Solution()\n    nums = [1, 3, 5, 7, 9]\n    queries = [[0, 2], [8, 10], [6, 6]]\n    expected_output = [3, 9, 3]\n    assert solution.maximizeXor(nums, queries) == expected_output", "def test_maximizeXor():\n    solution = Solution()\n    nums = [4, 8, 12, 16, 20]\n    queries = [[18, 17], [13, 7], [19, 21]]\n    expected_output = [16, 12, 23]\n    assert solution.maximizeXor(nums, queries) == expected_output", "def test_maximizeXor():\n    solution = Solution()\n    nums = [0, 2, 5, 7, 10]\n    queries = [[9, 5], [5, 0], [3, 10]]\n    expected_output = [15, -1, 11]\n    assert solution.maximizeXor(nums, queries) == expected_output", "def test_maximizeXor():\n    solution = Solution()\n    nums = [1, 4, 6, 7]\n    queries = [[2, 3], [6, 8], [4, 5]]\n    expected_output = [3, 7, 7]\n    assert solution.maximizeXor(nums, queries) == expected_output", "def test_maximizeXor():\n    solution = Solution()\n    nums = [3, 6, 10, 15, 18]\n    queries = [[7, 14], [2, 11], [17, 19]]\n    expected_output = [15, 11, 19]\n    assert solution.maximizeXor(nums, queries) == expected_output", "def test_maximizeXor():\n    solution = Solution()\n    nums = [9, 3, 8, 5, 12]\n    queries = [[6, 4], [11, 15], [7, 10]]\n    expected_output = [7, 15, 15]\n    assert solution.maximizeXor(nums, queries) == expected_output", "def test_maximizeXor():\n    solution = Solution()\n    nums = [2, 4, 9, 13, 17]\n    queries = [[5, 12], [1, 3], [16, 18]]\n    expected_output = [13, 2, 19]\n    assert solution.maximizeXor(nums, queries) == expected_output", "def test_maximizeXor():\n    solution = Solution()\n    nums = [0, 1, 3, 7, 11]\n    queries = [[4, 6], [8, 10], [10, 12]]\n    expected_output = [7, 15, 15]\n    assert solution.maximizeXor(nums, queries) == expected_output", "def test_maximizeXor():\n    solution = Solution()\n    nums = [5, 8, 12, 14, 20]\n    queries = [[10, 13], [15, 21], [9, 5]]\n    expected_output = [14, 31, -1]\n    assert solution.maximizeXor(nums, queries) == expected_output", "def test_maximizeXor():\n    solution = Solution()\n    nums = [6, 7, 10, 14, 19]\n    queries = [[11, 15], [5, 8], [20, 25]]\n    expected_output = [15, 15, 27]\n    assert solution.maximizeXor(nums, queries) == expected_output", "def test_maximizeXor():\n    solution = Solution()\n    nums = [2, 3, 5, 8, 13]\n    queries = [[4, 4], [9, 12], [15, 20]]\n    expected_output = [7, 13, 13]\n    assert solution.maximizeXor(nums, queries) == expected_output", "def test_maximizeXor():\n    solution = Solution()\n    nums = [1, 2, 8, 11, 16]\n    queries = [[5, 9], [14, 18], [0, 1]]\n    expected_output = [13, 30, 1]\n    assert solution.maximizeXor(nums, queries) == expected_output"]}
{"task_num": 1717, "task_title": "Maximum Score From Removing Substrings", "func_name": "maximumGain", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumGain(self, s: str, x: int, y: int) -> int:\n    if x > y:\n      return self._gain(s, 'ab', x, 'ba', y)\n    else:\n      return self._gain(s, 'ba', y, 'ab', x)\n\n  def _gain(self, s: str, sub1: str, point1: int, sub2: str, point2: int) -> int:\n    points = 0\n    stack1 = []\n    stack2 = []\n\n    for c in s:\n      if stack1 and stack1[-1] == sub1[0] and c == sub1[1]:\n        stack1.pop()\n        points += point1\n      else:\n        stack1.append(c)\n\n    for c in stack1:\n      if stack2 and stack2[-1] == sub2[0] and c == sub2[1]:\n        stack2.pop()\n        points += point2\n      else:\n        stack2.append(c)\n\n    return points\n", "tests": ["def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('cabab', 10, 20) == 30", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('abcba', 15, 25) == 25", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('bbaaab', 5, 10) == 20", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('aabbab', 8, 12) == 28", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('ababab', 3, 7) == 18", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('bbabac', 6, 9) == 15", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('aabbaacc', 4, 4) == 8", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('baaabba', 10, 5) == 25", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('bbabaa', 7, 11) == 18", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('abcabc', 4, 6) == 10", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('ababacb', 13, 9) == 22", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('babababa', 12, 15) == 45", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('aabbaabb', 5, 3) == 16", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('cababcac', 10, 20) == 30", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('abbabbbc', 8, 5) == 16", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('abaabb', 7, 14) == 35", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('babab', 9, 6) == 15", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('aabbaa', 10, 1) == 20", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('bacbacab', 3, 4) == 10", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('bcaababac', 8, 12) == 28"]}
{"task_num": 1719, "task_title": "Number Of Ways To Reconstruct A Tree", "func_name": "checkWays", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def checkWays(self, pairs: List[List[int]]) -> int:\n    kMax = 501\n    graph = collections.defaultdict(list)\n    degrees = [0] * kMax\n    connected = [[False] * kMax for _ in range(kMax)]\n\n    for u, v in pairs:\n      graph[u].append(v)\n      graph[v].append(u)\n      degrees[u] += 1\n      degrees[v] += 1\n      connected[u][v] = True\n      connected[v][u] = True\n\n    for _, children in graph.items():\n      children.sort(key=lambda a: degrees[a], reverse=True)\n\n    root = next((i for i, d in enumerate(degrees) if d == len(graph) - 1), -1)\n    if root == -1:\n      return 0\n\n    hasMoreThanOneWay = False\n\n    def dfs(u: int, ancestors: List[int], seen: List[bool]) -> bool:\n      nonlocal hasMoreThanOneWay\n      seen[u] = True\n      for ancestor in ancestors:\n        if not connected[u][ancestor]:\n          return False\n      ancestors.append(u)\n      for v in graph[u]:\n        if seen[v]:\n          continue\n        if degrees[v] == degrees[u]:\n          hasMoreThanOneWay = True\n        if not dfs(v, ancestors, seen):\n          return False\n      ancestors.pop()\n      return True\n\n    if not dfs(root, [], [False] * kMax):\n      return 0\n    if hasMoreThanOneWay:\n      return 2\n    else:\n      return 1\n", "tests": ["def test_checkWays():\n    solution = Solution()\n    pairs = [[1, 2], [2, 3], [1, 3]]\n    assert solution.checkWays(pairs) == 1", "def test_checkWays():\n    solution = Solution()\n    pairs = [[1, 2], [2, 3], [3, 4], [1, 4]]\n    assert solution.checkWays(pairs) == 2", "def test_checkWays():\n    solution = Solution()\n    pairs = [[1, 3], [4, 5], [3, 4]]\n    assert solution.checkWays(pairs) == 0", "def test_checkWays():\n    solution = Solution()\n    pairs = [[1, 2], [2, 3], [3, 1]]\n    assert solution.checkWays(pairs) == 0", "def test_checkWays():\n    solution = Solution()\n    pairs = [[1, 2], [1, 3], [1, 4], [2, 3], [3, 4]]\n    assert solution.checkWays(pairs) == 1", "def test_checkWays():\n    solution = Solution()\n    pairs = [[5, 6], [5, 7], [6, 7], [7, 8]]\n    assert solution.checkWays(pairs) == 2", "def test_checkWays():\n    solution = Solution()\n    pairs = [[1, 2], [2, 4], [2, 5], [3, 4], [3, 5]]\n    assert solution.checkWays(pairs) == 0", "def test_checkWays():\n    solution = Solution()\n    pairs = [[1, 3], [1, 4], [2, 3], [2, 4], [3, 5], [4, 5]]\n    assert solution.checkWays(pairs) == 2", "def test_checkWays():\n    solution = Solution()\n    pairs = [[1, 2], [2, 3], [3, 5], [5, 6], [4, 5], [6, 7], [1, 4]]\n    assert solution.checkWays(pairs) == 1", "def test_checkWays():\n    solution = Solution()\n    pairs = [[1, 2], [1, 3], [2, 4], [3, 4], [4, 5], [5, 6], [2, 6]]\n    assert solution.checkWays(pairs) == 0", "def test_checkWays():\n    solution = Solution()\n    pairs = [[1, 2], [2, 3], [3, 4], [4, 1], [2, 5]]\n    assert solution.checkWays(pairs) == 0", "def test_checkWays():\n    solution = Solution()\n    pairs = [[1, 3], [1, 4], [3, 4], [4, 5], [5, 6], [1, 6]]\n    assert solution.checkWays(pairs) == 1", "def test_checkWays():\n    solution = Solution()\n    pairs = [[2, 3], [3, 4], [4, 5], [5, 6], [2, 6], [1, 6]]\n    assert solution.checkWays(pairs) == 2", "def test_checkWays():\n    solution = Solution()\n    pairs = [[1, 2], [2, 3], [3, 4], [1, 5], [5, 6], [4, 6], [2, 6]]\n    assert solution.checkWays(pairs) == 0", "def test_checkWays():\n    solution = Solution()\n    pairs = [[1, 3], [1, 5], [3, 4], [5, 6], [4, 6], [3, 7], [5, 7]]\n    assert solution.checkWays(pairs) == 1", "def test_checkWays():\n    solution = Solution()\n    pairs = [[1, 2], [2, 3], [3, 4], [4, 5], [5, 1], [3, 6]]\n    assert solution.checkWays(pairs) == 0", "def test_checkWays():\n    solution = Solution()\n    pairs = [[1, 2], [1, 3], [2, 4], [3, 5], [4, 6], [5, 6]]\n    assert solution.checkWays(pairs) == 2", "def test_checkWays():\n    solution = Solution()\n    pairs = [[1, 2], [2, 3], [3, 4], [4, 5], [2, 6], [5, 7]]\n    assert solution.checkWays(pairs) == 0", "def test_checkWays():\n    solution = Solution()\n    pairs = [[1, 2], [1, 3], [1, 4], [2, 5], [3, 6], [4, 7], [5, 6], [6, 7]]\n    assert solution.checkWays(pairs) == 1", "def test_checkWays():\n    solution = Solution()\n    pairs = [[1, 2], [2, 3], [1, 4], [4, 5], [5, 6], [3, 6], [2, 5]]\n    assert solution.checkWays(pairs) == 0"]}
{"task_num": 1722, "task_title": "Minimize Hamming Distance After Swap Operations", "func_name": "minimumHammingDistance", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -> int:\n    n = len(source)\n    ans = 0\n    uf = UnionFind(n)\n    groupIdToCount = [collections.Counter() for _ in range(n)]\n\n    for a, b in allowedSwaps:\n      uf.unionByRank(a, b)\n\n    for i in range(n):\n      groupIdToCount[uf.find(i)][source[i]] += 1\n\n    for i in range(n):\n      groupId = uf.find(i)\n      count = groupIdToCount[groupId]\n      if target[i] not in count:\n        ans += 1\n      else:\n        count[target[i]] -= 1\n        if count[target[i]] == 0:\n          del count[target[i]]\n\n    return ans\n", "tests": ["def test_minimumHammingDistance():\n    solution = Solution()\n    source = [1, 2, 3, 4]\n    target = [2, 1, 4, 5]\n    allowedSwaps = [[0, 1], [2, 3]]\n    assert solution.minimumHammingDistance(source, target, allowedSwaps) == 1", "def test_minimumHammingDistance():\n    solution = Solution()\n    source = [5, 1, 2, 3]\n    target = [1, 5, 3, 2]\n    allowedSwaps = [[0, 1], [1, 2], [2, 3]]\n    assert solution.minimumHammingDistance(source, target, allowedSwaps) == 0", "def test_minimumHammingDistance():\n    solution = Solution()\n    source = [10, 20, 30, 40, 50]\n    target = [50, 40, 30, 20, 10]\n    allowedSwaps = [[0, 4], [1, 3]]\n    assert solution.minimumHammingDistance(source, target, allowedSwaps) == 3", "def test_minimumHammingDistance():\n    solution = Solution()\n    source = [1, 2, 3, 4, 5, 6]\n    target = [6, 5, 4, 3, 2, 1]\n    allowedSwaps = [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5]]\n    assert solution.minimumHammingDistance(source, target, allowedSwaps) == 0", "def test_minimumHammingDistance():\n    solution = Solution()\n    source = [4, 6, 7, 8]\n    target = [4, 8, 6, 7]\n    allowedSwaps = [[1, 2], [2, 3]]\n    assert solution.minimumHammingDistance(source, target, allowedSwaps) == 1", "def test_minimumHammingDistance():\n    solution = Solution()\n    source = [3, 5, 1, 2]\n    target = [1, 3, 2, 5]\n    allowedSwaps = []\n    assert solution.minimumHammingDistance(source, target, allowedSwaps) == 4", "def test_minimumHammingDistance():\n    solution = Solution()\n    source = [1, 3, 2, 4, 6, 5]\n    target = [1, 2, 3, 5, 4, 6]\n    allowedSwaps = [[1, 2], [3, 4]]\n    assert solution.minimumHammingDistance(source, target, allowedSwaps) == 3", "def test_minimumHammingDistance():\n    solution = Solution()\n    source = [7, 8, 9, 10]\n    target = [10, 9, 8, 7]\n    allowedSwaps = [[0, 2], [1, 3]]\n    assert solution.minimumHammingDistance(source, target, allowedSwaps) == 0", "def test_minimumHammingDistance():\n    solution = Solution()\n    source = [8, 3, 5, 2, 7]\n    target = [7, 5, 3, 8, 2]\n    allowedSwaps = [[0, 4], [1, 2], [2, 3], [3, 4]]\n    assert solution.minimumHammingDistance(source, target, allowedSwaps) == 2", "def test_minimumHammingDistance():\n    solution = Solution()\n    source = [12, 11, 10, 9, 8]\n    target = [8, 9, 10, 11, 12]\n    allowedSwaps = [[0, 1], [1, 2], [2, 3], [3, 4]]\n    assert solution.minimumHammingDistance(source, target, allowedSwaps) == 0", "def test_minimumHammingDistance():\n    solution = Solution()\n    source = [2, 4, 1, 3, 5]\n    target = [1, 3, 2, 5, 4]\n    allowedSwaps = [[0, 2], [1, 3]]\n    assert solution.minimumHammingDistance(source, target, allowedSwaps) == 3", "def test_minimumHammingDistance():\n    solution = Solution()\n    source = [15, 14, 13, 12, 11, 10]\n    target = [10, 11, 12, 13, 14, 15]\n    allowedSwaps = [[0, 5], [1, 4], [2, 3]]\n    assert solution.minimumHammingDistance(source, target, allowedSwaps) == 0", "def test_minimumHammingDistance():\n    solution = Solution()\n    source = [1, 2, 1, 2]\n    target = [2, 1, 2, 1]\n    allowedSwaps = [[0, 1], [2, 3]]\n    assert solution.minimumHammingDistance(source, target, allowedSwaps) == 0", "def test_minimumHammingDistance():\n    solution = Solution()\n    source = [9, 6, 3, 9, 6]\n    target = [6, 3, 9, 6, 9]\n    allowedSwaps = [[0, 3], [1, 2], [2, 4]]\n    assert solution.minimumHammingDistance(source, target, allowedSwaps) == 0", "def test_minimumHammingDistance():\n    solution = Solution()\n    source = [4, 5, 6, 7, 8, 9]\n    target = [9, 8, 7, 6, 5, 4]\n    allowedSwaps = [[0, 1], [1, 2], [3, 4], [4, 5]]\n    assert solution.minimumHammingDistance(source, target, allowedSwaps) == 6", "def test_minimumHammingDistance():\n    solution = Solution()\n    source = [5, 1, 3, 7, 9]\n    target = [9, 1, 3, 5, 7]\n    allowedSwaps = [[0, 3], [3, 4]]\n    assert solution.minimumHammingDistance(source, target, allowedSwaps) == 0", "def test_minimumHammingDistance():\n    solution = Solution()\n    source = [10, 11, 12, 13, 14]\n    target = [11, 10, 13, 12, 14]\n    allowedSwaps = []\n    assert solution.minimumHammingDistance(source, target, allowedSwaps) == 4", "def test_minimumHammingDistance():\n    solution = Solution()\n    source = [1, 1, 1, 1]\n    target = [1, 1, 1, 2]\n    allowedSwaps = [[0, 1], [1, 2], [2, 3]]\n    assert solution.minimumHammingDistance(source, target, allowedSwaps) == 1", "def test_minimumHammingDistance():\n    solution = Solution()\n    source = [3, 2, 1, 4]\n    target = [4, 3, 2, 1]\n    allowedSwaps = [[0, 3], [1, 2]]\n    assert solution.minimumHammingDistance(source, target, allowedSwaps) == 0", "def test_minimumHammingDistance():\n    solution = Solution()\n    source = [2, 3, 3, 2]\n    target = [3, 2, 2, 3]\n    allowedSwaps = [[0, 1], [2, 3]]\n    assert solution.minimumHammingDistance(source, target, allowedSwaps) == 0"]}
{"task_num": 1735, "task_title": "Count Ways to Make Array With Product", "func_name": "waysToFillArray", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def waysToFillArray(self, queries: List[List[int]]) -> List[int]:\n    kMod = 1_000_000_007\n    kMax = 10_000\n    minPrimeFactors = self._sieveEratosthenes(kMax + 1)\n\n    @functools.lru_cache(None)\n    def fact(i: int) -> int:\n      return 1 if i <= 1 else i * fact(i - 1) % kMod\n\n    @functools.lru_cache(None)\n    def inv(i: int) -> int:\n      return pow(i, kMod - 2, kMod)\n\n    @functools.lru_cache(None)\n    def nCk(n: int, k: int) -> int:\n      return fact(n) * inv(fact(k)) * inv(fact(n - k)) % kMod\n\n    ans = []\n\n    for n, k in queries:\n      res = 1\n      for freq in self._getPrimeFactorsCount(k, minPrimeFactors).values():\n        res = res * nCk(n - 1 + freq, freq) % kMod\n      ans.append(res)\n\n    return ans\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeFactorsCount(self, num: int, minPrimeFactors: List[int]) -> Dict[int, int]:\n    count = collections.Counter()\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      while num % divisor == 0:\n        num //= divisor\n        count[divisor] += 1\n    return count\n", "tests": ["def test_waysToFillArray():\n    solution = Solution()\n    queries = [[2, 6]]\n    assert solution.waysToFillArray(queries) == [4]", "def test_waysToFillArray():\n    solution = Solution()\n    queries = [[3, 10]]\n    assert solution.waysToFillArray(queries) == [6]", "def test_waysToFillArray():\n    solution = Solution()\n    queries = [[1, 1], [5, 1], [4, 8]]\n    assert solution.waysToFillArray(queries) == [1, 1, 5]", "def test_waysToFillArray():\n    solution = Solution()\n    queries = [[2, 9], [3, 7], [4, 4]]\n    assert solution.waysToFillArray(queries) == [3, 1, 15]", "def test_waysToFillArray():\n    solution = Solution()\n    queries = [[1, 12], [2, 5], [3, 1]]\n    assert solution.waysToFillArray(queries) == [1, 2, 1]", "def test_waysToFillArray():\n    solution = Solution()\n    queries = [[3, 6], [2, 15], [5, 2]]\n    assert solution.waysToFillArray(queries) == [7, 4, 16]", "def test_waysToFillArray():\n    solution = Solution()\n    queries = [[5, 3], [4, 10], [6, 12]]\n    assert solution.waysToFillArray(queries) == [1, 10, 433]", "def test_waysToFillArray():\n    solution = Solution()\n    queries = [[2, 2], [3, 18], [4, 7]]\n    assert solution.waysToFillArray(queries) == [2, 10, 4]", "def test_waysToFillArray():\n    solution = Solution()\n    queries = [[4, 5], [2, 14], [3, 9]]\n    assert solution.waysToFillArray(queries) == [4, 4, 7]", "def test_waysToFillArray():\n    solution = Solution()\n    queries = [[6, 13], [2, 20], [5, 30]]\n    assert solution.waysToFillArray(queries) == [1, 6, 150]", "def test_waysToFillArray():\n    solution = Solution()\n    queries = [[3, 2], [4, 9], [1, 11]]\n    assert solution.waysToFillArray(queries) == [3, 10, 1]", "def test_waysToFillArray():\n    solution = Solution()\n    queries = [[2, 11], [4, 16], [3, 27]]\n    assert solution.waysToFillArray(queries) == [1, 24, 19]", "def test_waysToFillArray():\n    solution = Solution()\n    queries = [[7, 1], [2, 3], [3, 4]]\n    assert solution.waysToFillArray(queries) == [1, 2, 3]", "def test_waysToFillArray():\n    solution = Solution()\n    queries = [[5, 25], [3, 10], [2, 21]]\n    assert solution.waysToFillArray(queries) == [126, 6, 2]", "def test_waysToFillArray():\n    solution = Solution()\n    queries = [[4, 3], [5, 6], [6, 14]]\n    assert solution.waysToFillArray(queries) == [4, 35, 28]", "def test_waysToFillArray():\n    solution = Solution()\n    queries = [[1, 17], [3, 5], [4, 2]]\n    assert solution.waysToFillArray(queries) == [1, 3, 5]", "def test_waysToFillArray():\n    solution = Solution()\n    queries = [[2, 13], [4, 23], [5, 18]]\n    assert solution.waysToFillArray(queries) == [1, 1, 60]", "def test_waysToFillArray():\n    solution = Solution()\n    queries = [[1, 31], [2, 8], [3, 16]]\n    assert solution.waysToFillArray(queries) == [1, 3, 19]", "def test_waysToFillArray():\n    solution = Solution()\n    queries = [[5, 7], [2, 28], [4, 22]]\n    assert solution.waysToFillArray(queries) == [1, 4, 10]", "def test_waysToFillArray():\n    solution = Solution()\n    queries = [[3, 13], [6, 18], [2, 25]]\n    assert solution.waysToFillArray(queries) == [1, 433, 2]"]}
{"task_num": 1765, "task_title": "Map of Highest Peak", "func_name": "highestPeak", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(isWater)\n    n = len(isWater[0])\n    ans = [[-1] * n for _ in range(m)]\n    q = collections.deque()\n\n    for i in range(m):\n      for j in range(n):\n        if isWater[i][j] == 1:\n          q.append((i, j))\n          ans[i][j] = 0\n\n    while q:\n      i, j = q.popleft()\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if ans[x][y] != -1:\n          continue\n        ans[x][y] = ans[i][j] + 1\n        q.append((x, y))\n\n    return ans\n", "tests": ["def test_highestPeak():\n    solution = Solution()\n    isWater = [[0, 1], [0, 0]]\n    expected_output = [[1, 0], [2, 1]]\n    assert solution.highestPeak(isWater) == expected_output", "def test_highestPeak():\n    solution = Solution()\n    isWater = [[1, 0, 0], [0, 0, 0], [0, 0, 1]]\n    expected_output = [[0, 1, 2], [1, 2, 1], [2, 1, 0]]\n    assert solution.highestPeak(isWater) == expected_output", "def test_highestPeak():\n    solution = Solution()\n    isWater = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n    expected_output = [[2, 1, 2], [1, 0, 1], [2, 1, 2]]\n    assert solution.highestPeak(isWater) == expected_output", "def test_highestPeak():\n    solution = Solution()\n    isWater = [[1, 0, 1], [0, 0, 0], [1, 0, 1]]\n    expected_output = [[0, 1, 0], [1, 2, 1], [0, 1, 0]]\n    assert solution.highestPeak(isWater) == expected_output", "def test_highestPeak():\n    solution = Solution()\n    isWater = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 0]]\n    expected_output = [[3, 2, 3, 4], [2, 1, 2, 3], [1, 0, 1, 2], [2, 1, 2, 3]]\n    assert solution.highestPeak(isWater) == expected_output", "def test_highestPeak():\n    solution = Solution()\n    isWater = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]\n    expected_output = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n    assert solution.highestPeak(isWater) == expected_output", "def test_highestPeak():\n    solution = Solution()\n    isWater = [[0, 0, 0, 0, 1], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 0, 0], [1, 0, 0, 0, 0]]\n    expected_output = [[4, 3, 2, 1, 0], [3, 2, 1, 2, 1], [2, 1, 0, 1, 2], [3, 2, 1, 2, 3], [0, 1, 2, 3, 4]]\n    assert solution.highestPeak(isWater) == expected_output", "def test_highestPeak():\n    solution = Solution()\n    isWater = [[0, 1, 0, 1], [1, 0, 0, 0], [0, 0, 1, 0], [0, 0, 0, 0]]\n    expected_output = [[1, 0, 1, 0], [0, 1, 2, 1], [1, 2, 0, 1], [2, 3, 2, 2]]\n    assert solution.highestPeak(isWater) == expected_output", "def test_highestPeak():\n    solution = Solution()\n    isWater = [[1, 0, 0, 0], [0, 0, 0, 1], [0, 1, 0, 0], [0, 0, 0, 0]]\n    expected_output = [[0, 1, 2, 3], [1, 2, 1, 0], [2, 1, 2, 1], [3, 2, 3, 2]]\n    assert solution.highestPeak(isWater) == expected_output", "def test_highestPeak():\n    solution = Solution()\n    isWater = [[0, 0, 0], [1, 0, 1], [0, 0, 0]]\n    expected_output = [[1, 2, 1], [0, 1, 0], [1, 2, 1]]\n    assert solution.highestPeak(isWater) == expected_output", "def test_highestPeak():\n    solution = Solution()\n    isWater = [[0, 0, 1, 0], [1, 0, 0, 1], [0, 0, 0, 0], [0, 1, 0, 0]]\n    expected_output = [[2, 1, 0, 1], [0, 1, 1, 0], [1, 2, 2, 1], [1, 0, 1, 2]]\n    assert solution.highestPeak(isWater) == expected_output", "def test_highestPeak():\n    solution = Solution()\n    isWater = [[0, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 0, 0], [1, 0, 0, 0, 1], [0, 0, 0, 0, 0]]\n    expected_output = [[3, 2, 1, 2, 3], [2, 1, 0, 1, 2], [3, 2, 1, 2, 3], [0, 1, 2, 1, 0], [1, 2, 3, 2, 1]]\n    assert solution.highestPeak(isWater) == expected_output", "def test_highestPeak():\n    solution = Solution()\n    isWater = [[0, 0, 0], [0, 1, 0], [1, 0, 0], [0, 0, 1]]\n    expected_output = [[2, 1, 2], [1, 0, 1], [0, 1, 2], [1, 2, 0]]\n    assert solution.highestPeak(isWater) == expected_output", "def test_highestPeak():\n    solution = Solution()\n    isWater = [[0, 1, 0, 0], [0, 0, 0, 0], [0, 0, 1, 0], [0, 0, 0, 0], [1, 0, 0, 0]]\n    expected_output = [[1, 0, 1, 2], [2, 1, 2, 1], [1, 1, 0, 1], [2, 2, 1, 2], [0, 1, 2, 3]]\n    assert solution.highestPeak(isWater) == expected_output", "def test_highestPeak():\n    solution = Solution()\n    isWater = [[0, 0, 1], [1, 0, 0], [0, 0, 0], [0, 1, 0], [0, 0, 0]]\n    expected_output = [[2, 1, 0], [0, 1, 2], [1, 2, 3], [1, 0, 1], [2, 1, 2]]\n    assert solution.highestPeak(isWater) == expected_output", "def test_highestPeak():\n    solution = Solution()\n    isWater = [[1, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 1]]\n    expected_output = [[0, 1, 2, 3, 4], [1, 2, 3, 4, 3], [2, 3, 4, 3, 0]]\n    assert solution.highestPeak(isWater) == expected_output", "def test_highestPeak():\n    solution = Solution()\n    isWater = [[1, 0, 0, 1], [0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 0], [1, 0, 0, 1]]\n    expected_output = [[0, 1, 2, 0], [1, 2, 1, 1], [2, 0, 1, 2], [1, 1, 2, 1], [0, 1, 2, 0]]\n    assert solution.highestPeak(isWater) == expected_output", "def test_highestPeak():\n    solution = Solution()\n    isWater = [[0, 0, 0, 1], [0, 1, 0, 0], [0, 0, 0, 0], [1, 0, 0, 0], [0, 0, 1, 0]]\n    expected_output = [[3, 2, 1, 0], [2, 1, 2, 1], [1, 2, 1, 2], [0, 1, 2, 3], [1, 2, 0, 1]]\n    assert solution.highestPeak(isWater) == expected_output", "def test_highestPeak():\n    solution = Solution()\n    isWater = [[0, 0, 0, 0, 0], [0, 0, 1, 0, 0], [1, 0, 0, 0, 1], [0, 0, 0, 0, 0], [0, 0, 0, 1, 0]]\n    expected_output = [[2, 1, 2, 3, 2], [1, 2, 0, 1, 2], [0, 1, 2, 1, 0], [1, 2, 3, 2, 1], [2, 3, 2, 0, 1]]\n    assert solution.highestPeak(isWater) == expected_output", "def test_highestPeak():\n    solution = Solution()\n    isWater = [[1, 0, 1, 0, 0], [0, 0, 0, 1, 0], [1, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 0, 1]]\n    expected_output = [[0, 1, 0, 1, 2], [1, 2, 1, 0, 1], [0, 1, 2, 1, 2], [1, 2, 0, 1, 2], [2, 3, 2, 1, 0]]\n    assert solution.highestPeak(isWater) == expected_output"]}
{"task_num": 1782, "task_title": "Count Pairs Of Nodes", "func_name": "countPairs", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:\n    ans = [0] * len(queries)\n\n    count = [0] * (n + 1)\n\n    shared = [collections.Counter() for _ in range(n + 1)]\n\n    for u, v in edges:\n      count[u] += 1\n      count[v] += 1\n      shared[min(u, v)][max(u, v)] += 1\n\n    sortedCount = sorted(count)\n\n    for k, query in enumerate(queries):\n      i = 1\n      j = n\n      while i < j:\n        if sortedCount[i] + sortedCount[j] > query:\n          ans[k] += j - i\n          j -= 1\n        else:\n          i += 1\n      for i in range(1, n + 1):\n        for j, sh in shared[i].items():\n          if count[i] + count[j] > query and count[i] + count[j] - sh <= query:\n            ans[k] -= 1\n\n    return ans\n", "tests": ["def test_countPairs():\n    solution = Solution()\n    assert solution.countPairs(5, [[1, 2], [2, 3], [4, 5]], [1, 2, 3]) == [5, 4, 2]", "def test_countPairs():\n    solution = Solution()\n    assert solution.countPairs(4, [[1, 2], [2, 3], [3, 4], [4, 1], [1, 3]], [2, 3, 4]) == [6, 4, 1]", "def test_countPairs():\n    solution = Solution()\n    assert solution.countPairs(6, [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 1]], [2, 4, 5]) == [9, 6, 4]", "def test_countPairs():\n    solution = Solution()\n    assert solution.countPairs(3, [[1, 2], [2, 3], [1, 3], [1, 3]], [0, 1, 3]) == [3, 3, 0]", "def test_countPairs():\n    solution = Solution()\n    assert solution.countPairs(7, [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 1], [3, 5]], [3, 5, 6]) == [12, 7, 5]", "def test_countPairs():\n    solution = Solution()\n    assert solution.countPairs(8, [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 1], [7, 8], [2, 8]], [2, 4, 7]) == [15, 10, 3]", "def test_countPairs():\n    solution = Solution()\n    assert solution.countPairs(5, [[1, 2], [1, 3], [1, 4], [2, 3], [2, 5], [3, 5]], [3, 4, 5]) == [10, 7, 4]", "def test_countPairs():\n    solution = Solution()\n    assert solution.countPairs(4, [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]], [3, 5, 6]) == [6, 3, 0]", "def test_countPairs():\n    solution = Solution()\n    assert solution.countPairs(6, [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 1], [1, 4]], [4, 6, 8]) == [10, 4, 1]", "def test_countPairs():\n    solution = Solution()\n    assert solution.countPairs(5, [[1, 2], [2, 3], [3, 4], [4, 5], [1, 5], [2, 4]], [2, 3, 4]) == [10, 7, 4]", "def test_countPairs():\n    solution = Solution()\n    assert solution.countPairs(4, [[1, 2], [1, 2], [2, 3], [3, 4], [1, 3]], [1, 2, 3]) == [6, 5, 2]", "def test_countPairs():\n    solution = Solution()\n    assert solution.countPairs(3, [[1, 2], [2, 3], [1, 3]], [0, 2, 5]) == [3, 2, 0]", "def test_countPairs():\n    solution = Solution()\n    assert solution.countPairs(6, [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [1, 6]], [3, 5, 7]) == [10, 6, 3]", "def test_countPairs():\n    solution = Solution()\n    assert solution.countPairs(7, [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 1], [1, 5]], [2, 4, 6]) == [15, 10, 5]", "def test_countPairs():\n    solution = Solution()\n    assert solution.countPairs(5, [[1, 2], [2, 3], [3, 1], [4, 5], [1, 5]], [1, 3, 6]) == [7, 3, 0]", "def test_countPairs():\n    solution = Solution()\n    assert solution.countPairs(4, [[1, 2], [2, 3], [3, 4], [1, 4]], [1, 2, 4]) == [6, 4, 1]", "def test_countPairs():\n    solution = Solution()\n    assert solution.countPairs(6, [[1, 2], [1, 3], [2, 4], [3, 5], [4, 6]], [2, 3, 4]) == [10, 6, 3]", "def test_countPairs():\n    solution = Solution()\n    assert solution.countPairs(5, [[1, 2], [2, 3], [3, 4], [4, 5], [1, 3], [2, 4], [1, 5]], [4, 5, 7]) == [11, 8, 3]", "def test_countPairs():\n    solution = Solution()\n    assert solution.countPairs(8, [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [1, 8], [2, 5]], [3, 6, 9]) == [20, 10, 4]", "def test_countPairs():\n    solution = Solution()\n    assert solution.countPairs(6, [[1, 2], [2, 3], [4, 5], [5, 6], [1, 6], [3, 4]], [1, 4, 6]) == [12, 5, 3]"]}
{"task_num": 1786, "task_title": "Number of Restricted Paths From First to Last Node", "func_name": "countRestrictedPaths", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countRestrictedPaths(self, n: int, edges: List[List[int]]) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u - 1].append((v - 1, w))\n      graph[v - 1].append((u - 1, w))\n\n    return self._dijkstra(graph, 0, n - 1)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int) -> int:\n    kMod = 10**9 + 7\n    ways = [0] * len(graph)\n    dist = [math.inf] * len(graph)\n\n    ways[dst] = 1\n    dist[dst] = 0\n    minHeap = [(dist[dst], dst)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n        if dist[v] < dist[u]:\n          ways[u] += ways[v]\n          ways[u] %= kMod\n\n    return ways[src]\n", "tests": ["def test_countRestrictedPaths():\n    solution = Solution()\n    assert solution.countRestrictedPaths(5, [[1, 2, 3], [1, 3, 3], [2, 3, 1], [1, 4, 2], [5, 2, 2], [3, 5, 1], [5, 4, 2]]) == 3", "def test_countRestrictedPaths():\n    solution = Solution()\n    assert solution.countRestrictedPaths(4, [[1, 3, 2], [2, 3, 3], [3, 4, 1], [4, 2, 1], [1, 2, 4]]) == 1", "def test_countRestrictedPaths():\n    solution = Solution()\n    assert solution.countRestrictedPaths(6, [[1, 2, 2], [1, 3, 2], [2, 4, 3], [3, 5, 1], [4, 6, 5], [5, 6, 1], [2, 5, 2]]) == 2", "def test_countRestrictedPaths():\n    solution = Solution()\n    assert solution.countRestrictedPaths(3, [[1, 2, 1], [2, 3, 2], [1, 3, 3]]) == 1", "def test_countRestrictedPaths():\n    solution = Solution()\n    assert solution.countRestrictedPaths(7, [[1, 2, 1], [2, 3, 2], [3, 4, 1], [4, 5, 2], [5, 6, 1], [6, 7, 2], [1, 3, 3], [3, 5, 3], [5, 7, 1]]) == 4", "def test_countRestrictedPaths():\n    solution = Solution()\n    assert solution.countRestrictedPaths(2, [[1, 2, 5]]) == 1", "def test_countRestrictedPaths():\n    solution = Solution()\n    assert solution.countRestrictedPaths(5, [[1, 2, 4], [2, 3, 6], [3, 4, 5], [4, 5, 2], [1, 3, 8], [2, 5, 7], [1, 4, 10]]) == 2", "def test_countRestrictedPaths():\n    solution = Solution()\n    assert solution.countRestrictedPaths(8, [[1, 2, 1], [2, 3, 4], [2, 4, 2], [3, 5, 1], [4, 5, 3], [5, 6, 2], [6, 7, 1], [7, 8, 2], [1, 6, 8]]) == 5", "def test_countRestrictedPaths():\n    solution = Solution()\n    assert solution.countRestrictedPaths(9, [[1, 2, 5], [2, 3, 2], [3, 4, 4], [4, 5, 1], [5, 6, 2], [6, 7, 3], [7, 8, 1], [8, 9, 2], [1, 3, 7], [1, 5, 10]]) == 3", "def test_countRestrictedPaths():\n    solution = Solution()\n    assert solution.countRestrictedPaths(6, [[1, 2, 2], [2, 3, 3], [4, 3, 1], [4, 5, 2], [5, 6, 1], [6, 2, 2], [1, 5, 5]]) == 4", "def test_countRestrictedPaths():\n    solution = Solution()\n    assert solution.countRestrictedPaths(10, [[1, 2, 3], [2, 4, 2], [3, 4, 4], [4, 5, 1], [5, 6, 2], [6, 7, 1], [7, 8, 3], [8, 9, 4], [9, 10, 2], [1, 6, 10], [3, 9, 5]]) == 4", "def test_countRestrictedPaths():\n    solution = Solution()\n    assert solution.countRestrictedPaths(7, [[1, 2, 6], [2, 3, 5], [3, 4, 4], [4, 5, 3], [5, 6, 2], [6, 7, 1], [1, 3, 7], [2, 6, 8], [4, 7, 2]]) == 3", "def test_countRestrictedPaths():\n    solution = Solution()\n    assert solution.countRestrictedPaths(4, [[1, 2, 1], [2, 3, 3], [3, 4, 2], [1, 3, 4], [2, 4, 5]]) == 1", "def test_countRestrictedPaths():\n    solution = Solution()\n    assert solution.countRestrictedPaths(8, [[1, 2, 2], [2, 3, 2], [3, 4, 2], [4, 5, 2], [5, 6, 2], [6, 7, 2], [7, 8, 2], [1, 4, 5], [2, 5, 4], [3, 6, 3]]) == 6", "def test_countRestrictedPaths():\n    solution = Solution()\n    assert solution.countRestrictedPaths(3, [[1, 2, 1], [2, 3, 2], [1, 3, 3]]) == 1", "def test_countRestrictedPaths():\n    solution = Solution()\n    assert solution.countRestrictedPaths(6, [[1, 2, 5], [1, 3, 3], [2, 4, 2], [3, 5, 6], [4, 6, 1], [5, 6, 2], [2, 3, 4]]) == 2", "def test_countRestrictedPaths():\n    solution = Solution()\n    assert solution.countRestrictedPaths(5, [[1, 2, 2], [2, 3, 4], [3, 4, 6], [4, 5, 8], [1, 3, 3], [2, 5, 7], [3, 5, 5]]) == 3", "def test_countRestrictedPaths():\n    solution = Solution()\n    assert solution.countRestrictedPaths(5, [[1, 2, 3], [2, 3, 2], [3, 4, 4], [4, 5, 1], [1, 3, 6], [2, 4, 5], [1, 5, 10]]) == 2", "def test_countRestrictedPaths():\n    solution = Solution()\n    assert solution.countRestrictedPaths(7, [[1, 2, 1], [2, 3, 2], [3, 4, 3], [4, 5, 4], [5, 6, 5], [6, 7, 6], [1, 4, 7], [2, 5, 8], [3, 6, 9]]) == 5", "def test_countRestrictedPaths():\n    solution = Solution()\n    assert solution.countRestrictedPaths(6, [[1, 2, 7], [2, 3, 5], [3, 4, 3], [4, 5, 2], [5, 6, 1], [1, 3, 10], [2, 5, 8], [4, 6, 4]]) == 2"]}
{"task_num": 1793, "task_title": "Maximum Score of a Good Subarray", "func_name": "maximumScore", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumScore(self, nums: List[int], k: int) -> int:\n    ans = 0\n    stack = []\n\n    for i in range(len(nums) + 1):\n      while stack and (i == len(nums) or nums[stack[-1]] > nums[i]):\n        h = nums[stack.pop()]\n        w = i - stack[-1] - 1 if stack else i\n        if (not stack or stack[-1] + 1 <= k) and i - 1 >= k:\n          ans = max(ans, h * w)\n      stack.append(i)\n\n    return ans\n", "tests": ["def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([1, 4, 3, 7, 4, 5], 3) == 15", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([5, 5, 5, 5, 5], 2) == 25", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([3, 1, 5, 6, 2, 4], 2) == 12", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([2, 9, 7, 8, 3, 4], 1) == 18", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([10, 1, 1, 1, 10], 0) == 10", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([4, 2, 6, 1, 3, 5], 4) == 6", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([8, 6, 7, 7, 9, 7], 3) == 21", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([1, 3, 5, 2, 1, 6, 4], 5) == 6", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([1, 2, 3, 4, 3, 2, 1], 3) == 16", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([6, 3, 8, 4, 9, 5], 2) == 16", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([7, 7, 7, 7, 7], 2) == 35", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([10, 9, 8, 7, 6, 5, 4], 4) == 30", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([5, 3, 1, 2, 4, 6], 0) == 6", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([9, 8, 7, 1, 2, 3], 2) == 21", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([2, 4, 6, 8, 10, 1, 5], 5) == 10", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([1, 2, 3, 2, 1, 4, 5], 6) == 5", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([3, 2, 1, 4, 6, 5, 7], 3) == 12", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([5, 1, 1, 1, 5], 2) == 5", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([1, 5, 9, 5, 1], 1) == 9", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([5, 6, 2, 4, 3, 7, 8], 4) == 12"]}
{"task_num": 1805, "task_title": "Number of Different Integers in a String", "func_name": "numDifferentIntegers", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numDifferentIntegers(self, word: str) -> int:\n    nums = set()\n    curr = []\n\n    for c in word:\n      if c.isdigit():\n        curr.append(c)\n      elif curr:\n        nums.add(''.join(self._removeLeadingZeros(curr)))\n        curr = []\n\n    if curr:\n      nums.add(''.join(self._removeLeadingZeros(curr)))\n\n    return len(nums)\n\n  def _removeLeadingZeros(self, s: str) -> str:\n    index = next((i for i, c in enumerate(s) if c != '0'), -1)\n    if index == -1:\n      return ['0']\n    else:\n      return s[index:]\n", "tests": ["def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers('a123bc34d8ef34') == 3", "def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers('leet1234code234') == 2", "def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers('a00123b00456c000789') == 3", "def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers('abc') == 0", "def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers('0a0b0c') == 1", "def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers('abc123xyz456abc789xyz') == 3", "def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers('a1b01c001') == 1", "def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers('1234a5678b9012') == 3", "def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers('000a0000b00000c') == 1", "def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers('123abc456def00123gh') == 3", "def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers('111a222b333c444d555') == 5", "def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers('a0b12c012d0012e') == 2", "def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers('abc000xyz000') == 1", "def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers('abc123000def456000') == 2", "def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers('1a2b3c4d5e6f7g8h9i0') == 10", "def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers('0001200034') == 2", "def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers('abcdef') == 0", "def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers('a123aa1234aa01234') == 3", "def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers('123abc0456def0789ghi012') == 5", "def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers('z0z00z000z') == 1"]}
{"task_num": 1857, "task_title": "Largest Color Value in a Directed Graph", "func_name": "largestPathValue", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\n    n = len(colors)\n    ans = 0\n    processed = 0\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n    q = collections.deque()\n    count = [[0] * 26 for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      inDegrees[v] += 1\n\n    for i, degree in enumerate(inDegrees):\n      if degree == 0:\n        q.append(i)\n\n    while q:\n      u = q.popleft()\n      processed += 1\n      count[u][ord(colors[u]) - ord('a')] += 1\n      ans = max(ans, count[u][ord(colors[u]) - ord('a')])\n      for v in graph[u]:\n        for i in range(26):\n          count[v][i] = max(count[v][i], count[u][i])\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    if processed == n:\n      return ans\n    else:\n      return -1\n", "tests": ["def test_largestPathValue():\n    solution = Solution()\n    colors = 'abaca'\n    edges = [[0, 1], [0, 2], [2, 3], [3, 4]]\n    assert solution.largestPathValue(colors, edges) == 3", "def test_largestPathValue():\n    solution = Solution()\n    colors = 'a'\n    edges = [[0, 0]]\n    assert solution.largestPathValue(colors, edges) == -1", "def test_largestPathValue():\n    solution = Solution()\n    colors = 'abcde'\n    edges = [[0, 1], [2, 3]]\n    assert solution.largestPathValue(colors, edges) == 1", "def test_largestPathValue():\n    solution = Solution()\n    colors = 'z'\n    edges = []\n    assert solution.largestPathValue(colors, edges) == 1", "def test_largestPathValue():\n    solution = Solution()\n    colors = 'ababb'\n    edges = [[0, 1], [0, 2], [1, 3], [2, 3], [3, 4]]\n    assert solution.largestPathValue(colors, edges) == 3", "def test_largestPathValue():\n    solution = Solution()\n    colors = 'abcabc'\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [3, 1]]\n    assert solution.largestPathValue(colors, edges) == -1", "def test_largestPathValue():\n    solution = Solution()\n    colors = 'ababab'\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5]]\n    assert solution.largestPathValue(colors, edges) == 3", "def test_largestPathValue():\n    solution = Solution()\n    colors = 'xyz'\n    edges = [[1, 2]]\n    assert solution.largestPathValue(colors, edges) == 1", "def test_largestPathValue():\n    solution = Solution()\n    colors = 'aabbcc'\n    edges = [[0, 1], [2, 3], [4, 5]]\n    assert solution.largestPathValue(colors, edges) == 1", "def test_largestPathValue():\n    solution = Solution()\n    colors = 'abcdef'\n    edges = [[0, 1], [1, 2], [2, 3], [3, 1], [3, 4], [4, 5]]\n    assert solution.largestPathValue(colors, edges) == -1", "def test_largestPathValue():\n    solution = Solution()\n    colors = 'abc'\n    edges = [[0, 1], [1, 2], [2, 0]]\n    assert solution.largestPathValue(colors, edges) == -1", "def test_largestPathValue():\n    solution = Solution()\n    colors = 'aaaaba'\n    edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5]]\n    assert solution.largestPathValue(colors, edges) == 4", "def test_largestPathValue():\n    solution = Solution()\n    colors = 'mnop'\n    edges = []\n    assert solution.largestPathValue(colors, edges) == 1", "def test_largestPathValue():\n    solution = Solution()\n    colors = 'abcde'\n    edges = [[0, 1], [1, 2], [2, 0], [2, 3], [3, 4]]\n    assert solution.largestPathValue(colors, edges) == -1", "def test_largestPathValue():\n    solution = Solution()\n    colors = 'aaaaa'\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4]]\n    assert solution.largestPathValue(colors, edges) == 5", "def test_largestPathValue():\n    solution = Solution()\n    colors = 'abcbac'\n    edges = [[0, 1], [1, 2], [2, 0], [2, 3], [3, 4], [4, 2], [4, 5]]\n    assert solution.largestPathValue(colors, edges) == -1", "def test_largestPathValue():\n    solution = Solution()\n    colors = 'abac'\n    edges = [[0, 1], [0, 2], [0, 3]]\n    assert solution.largestPathValue(colors, edges) == 1", "def test_largestPathValue():\n    solution = Solution()\n    colors = 'abc'\n    edges = [[0, 1], [1, 0], [1, 2]]\n    assert solution.largestPathValue(colors, edges) == -1", "def test_largestPathValue():\n    solution = Solution()\n    colors = 'abcd'\n    edges = [[0, 1], [0, 2], [1, 3], [2, 3]]\n    assert solution.largestPathValue(colors, edges) == 1", "def test_largestPathValue():\n    solution = Solution()\n    colors = 'xyz'\n    edges = [[0, 1]]\n    assert solution.largestPathValue(colors, edges) == 1"]}
{"task_num": 1878, "task_title": "Get Biggest Three Rhombus Sums in a Grid", "func_name": "getBiggestThree", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom sortedcontainers import SortedSet\n\n\nclass Solution:\n  def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\n    m = len(grid)\n    n = len(grid[0])\n    sums = SortedSet()\n\n    for i in range(m):\n      for j in range(n):\n        sz = 0\n        while i + sz < m and i - sz >= 0 and j + 2 * sz < n:\n          summ = grid[i][j] if sz == 0 else self._getSum(grid, i, j, sz)\n          sums.add(summ)\n          if len(sums) > 3:\n            sums.pop(0)\n          sz += 1\n\n    return reversed(sums)\n\n  def _getSum(self, grid: List[List[int]], i: int, j: int, sz: int) -> int:\n    x = i\n    y = j\n    summ = 0\n\n    for _ in range(sz):\n      x -= 1\n      y += 1\n      summ += grid[x][y]\n\n    for _ in range(sz):\n      x += 1\n      y += 1\n      summ += grid[x][y]\n\n    for _ in range(sz):\n      x += 1\n      y -= 1\n      summ += grid[x][y]\n\n    for _ in range(sz):\n      x -= 1\n      y -= 1\n      summ += grid[x][y]\n\n    return summ\n", "tests": ["def test_getBiggestThree():\n    solution = Solution()\n    grid = [[3, 4, 5, 1], [9, 8, 7, 6], [3, 0, 1, 10], [2, 7, 6, 4]]\n    assert list(solution.getBiggestThree(grid)) == [28, 25, 24]", "def test_getBiggestThree():\n    solution = Solution()\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    assert list(solution.getBiggestThree(grid)) == [20, 14, 8]", "def test_getBiggestThree():\n    solution = Solution()\n    grid = [[7, 0, 1, 4], [2, 5, 3, 8], [6, 9, 2, 0], [4, 1, 7, 5]]\n    assert list(solution.getBiggestThree(grid)) == [31, 25, 17]", "def test_getBiggestThree():\n    solution = Solution()\n    grid = [[5, 1], [2, 3]]\n    assert list(solution.getBiggestThree(grid)) == [5, 3, 2]", "def test_getBiggestThree():\n    solution = Solution()\n    grid = [[10, 15, 10], [20, 25, 30], [35, 40, 20]]\n    assert list(solution.getBiggestThree(grid)) == [115, 90, 60]", "def test_getBiggestThree():\n    solution = Solution()\n    grid = [[8]]\n    assert list(solution.getBiggestThree(grid)) == [8]", "def test_getBiggestThree():\n    solution = Solution()\n    grid = [[12, 7, 1, 5], [9, 14, 10, 2], [4, 13, 6, 11], [3, 8, 15, 0]]\n    assert list(solution.getBiggestThree(grid)) == [47, 36, 31]", "def test_getBiggestThree():\n    solution = Solution()\n    grid = [[4, 3, 2], [1, 8, 6], [5, 7, 9]]\n    assert list(solution.getBiggestThree(grid)) == [24, 21, 15]", "def test_getBiggestThree():\n    solution = Solution()\n    grid = [[1, 2, 1], [2, 4, 2], [1, 2, 1]]\n    assert list(solution.getBiggestThree(grid)) == [8, 4, 2]", "def test_getBiggestThree():\n    solution = Solution()\n    grid = [[1, 3, 5, 7], [2, 4, 6, 8], [9, 11, 13, 15], [10, 12, 14, 16]]\n    assert list(solution.getBiggestThree(grid)) == [64, 43, 33]", "def test_getBiggestThree():\n    solution = Solution()\n    grid = [[2, 2, 2], [2, 2, 2], [2, 2, 2]]\n    assert list(solution.getBiggestThree(grid)) == [8, 6, 2]", "def test_getBiggestThree():\n    solution = Solution()\n    grid = [[4, 4, 4, 4], [4, 4, 4, 4], [4, 4, 4, 4], [4, 4, 4, 4]]\n    assert list(solution.getBiggestThree(grid)) == [32, 28, 24]", "def test_getBiggestThree():\n    solution = Solution()\n    grid = [[3, 3, 3, 3, 3], [3, 3, 3, 3, 3], [3, 3, 3, 3, 3], [3, 3, 3, 3, 3], [3, 3, 3, 3, 3]]\n    assert list(solution.getBiggestThree(grid)) == [36, 33, 30]", "def test_getBiggestThree():\n    solution = Solution()\n    grid = [[5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5]]\n    assert list(solution.getBiggestThree(grid)) == [60, 55, 50]", "def test_getBiggestThree():\n    solution = Solution()\n    grid = [[7, 1, 1, 7], [1, 1, 1, 1], [1, 1, 1, 1], [7, 1, 1, 7]]\n    assert list(solution.getBiggestThree(grid)) == [30, 20, 7]", "def test_getBiggestThree():\n    solution = Solution()\n    grid = [[3, 8, 3, 8, 3], [8, 1, 1, 1, 8], [3, 1, 9, 1, 3], [8, 1, 1, 1, 8], [3, 8, 3, 8, 3]]\n    assert list(solution.getBiggestThree(grid)) == [40, 32, 21]", "def test_getBiggestThree():\n    solution = Solution()\n    grid = [[9, 2, 3], [4, 5, 6], [7, 8, 1], [2, 1, 0]]\n    assert list(solution.getBiggestThree(grid)) == [27, 21, 17]", "def test_getBiggestThree():\n    solution = Solution()\n    grid = [[10, 1, 10], [1, 5, 1], [10, 1, 10]]\n    assert list(solution.getBiggestThree(grid)) == [40, 22, 10]", "def test_getBiggestThree():\n    solution = Solution()\n    grid = [[6, 3, 6, 3, 6], [3, 0, 0, 0, 3], [6, 0, 9, 0, 6], [3, 0, 0, 0, 3], [6, 3, 6, 3, 6]]\n    assert list(solution.getBiggestThree(grid)) == [48, 36, 24]", "def test_getBiggestThree():\n    solution = Solution()\n    grid = [[1, 2, 1], [2, 3, 2], [1, 2, 1], [0, 1, 0]]\n    assert list(solution.getBiggestThree(grid)) == [11, 8, 4]"]}
{"task_num": 1896, "task_title": "Minimum Cost to Change the Final Value of Expression", "func_name": "minOperationsToFlip", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minOperationsToFlip(self, expression: str) -> int:\n    stack = []\n\n    for e in expression:\n      if e in '(&|':\n        stack.append((e, 0))\n        continue\n      if e == ')':\n        lastPair = stack.pop()\n        stack.pop()\n      else: \n        lastPair = (e, 1)\n      if stack and stack[-1][0] in '&|':\n        op = stack.pop()[0]\n        a, costA = stack.pop()\n        b, costB = lastPair\n        if op == '&':\n          if a == '0' and b == '0':\n            lastPair = ('0', 1 + min(costA, costB))\n          elif a == '0' and b == '1':\n            lastPair = ('0', 1)\n          elif a == '1' and b == '0':\n            lastPair = ('0', 1)\n          else:\n            lastPair = ('1', min(costA, costB))\n        else:\n          if a == '0' and b == '0':\n            lastPair = ('0', min(costA, costB))\n          elif a == '0' and b == '1':\n            lastPair = ('1', 1)\n          elif a == '1' and b == '0':\n            lastPair = ('1', 1)\n          else:\n            lastPair = ('1', 1 + min(costA, costB))\n      stack.append(lastPair)\n\n    return stack[-1][1]\n", "tests": ["def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('1|0&1') == 1", "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('(1&0)|(0|1)') == 1", "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('((1&1)|0)&1') == 1", "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('1&(0|0|1)') == 1", "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('((0|1)&0)|1') == 1", "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('(1|1)&(1&0)') == 1", "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('0&(1|0&1)') == 1", "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('((1&0)|(1|0))&1') == 2", "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('(0&1)|(1&1|0)') == 1", "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('(1|0)&(0|1|1)') == 1", "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('1&(0|(1&0))') == 1", "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('0|(1&(1|0))') == 1", "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('(1&(0|1))|0') == 1", "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('((1|0)&1)|(0&0)') == 1", "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('1&((0|1)&(1|0))') == 1", "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('0|((1&0)|1)') == 1", "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('(0|(1&1))&(0|1)') == 1", "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('1&((0&1)|0)') == 1", "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('(1|(0&0))|1') == 1", "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('0&((1|0)&(1&1))') == 1"]}
{"task_num": 1906, "task_title": "Minimum Absolute Difference Queries", "func_name": "minDifference", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom bisect import bisect_left\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minDifference(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n    numToIndices = [[] for _ in range(101)]\n\n    for i, num in enumerate(nums):\n      numToIndices[num].append(i)\n\n    if len(numToIndices[nums[0]]) == len(nums):\n      return [-1] * len(queries)\n\n    ans = []\n\n    for l, r in queries:\n      prevNum = -1\n      minDiff = 101\n      for num in range(1, 101):\n        indices = numToIndices[num]\n        i = bisect_left(indices, l)\n        if i == len(indices) or indices[i] > r:\n          continue\n        if prevNum != -1:\n          minDiff = min(minDiff, num - prevNum)\n        prevNum = num\n      ans.append(-1 if minDiff == 101 else minDiff)\n\n    return ans\n", "tests": ["def test_minDifference():\n    solution = Solution()\n    assert solution.minDifference([1, 3, 4, 8], [[0, 1], [1, 2], [2, 3], [0, 3]]) == [2, 1, 4, 1]", "def test_minDifference():\n    solution = Solution()\n    assert solution.minDifference([5, 3, 5, 3, 5], [[0, 4], [0, 2], [1, 3], [2, 4]]) == [0, 2, 0, 2]", "def test_minDifference():\n    solution = Solution()\n    assert solution.minDifference([10, 10, 10, 10], [[0, 3], [0, 1], [1, 2], [2, 3]]) == [-1, -1, -1, -1]", "def test_minDifference():\n    solution = Solution()\n    assert solution.minDifference([1, 5, 9, 12, 14], [[0, 2], [1, 4], [0, 4], [2, 3]]) == [4, 2, 1, 3]", "def test_minDifference():\n    solution = Solution()\n    assert solution.minDifference([1, 100, 50, 3, 99], [[0, 4], [0, 1], [1, 3], [2, 4]]) == [1, 99, 47, 1]", "def test_minDifference():\n    solution = Solution()\n    assert solution.minDifference([2, 2, 1, 5, 4], [[0, 2], [0, 4], [3, 4], [1, 3]]) == [1, 1, 1, 1]", "def test_minDifference():\n    solution = Solution()\n    assert solution.minDifference([6, 5, 4, 3, 2, 1], [[0, 5], [0, 2], [1, 3], [4, 5]]) == [1, 1, 1, 1]", "def test_minDifference():\n    solution = Solution()\n    assert solution.minDifference([8, 7, 3, 2, 6, 10, 1], [[0, 6], [0, 3], [3, 5], [2, 6]]) == [1, 1, 4, 1]", "def test_minDifference():\n    solution = Solution()\n    assert solution.minDifference([12, 3, 7, 3, 8, 6], [[0, 1], [1, 4], [0, 3], [2, 5]]) == [9, 1, 4, 1]", "def test_minDifference():\n    solution = Solution()\n    assert solution.minDifference([4, 2, 2, 4, 1, 7], [[0, 5], [0, 2], [2, 4], [3, 5]]) == [1, 0, 1, 3]", "def test_minDifference():\n    solution = Solution()\n    assert solution.minDifference([11, 5, 2, 8, 5, 9, 3], [[0, 4], [1, 6], [2, 5], [0, 2]]) == [3, 1, 1, 3]", "def test_minDifference():\n    solution = Solution()\n    assert solution.minDifference([7, 1, 8, 4, 6, 2, 9], [[1, 5], [0, 3], [2, 6], [3, 4]]) == [1, 3, 1, 2]", "def test_minDifference():\n    solution = Solution()\n    assert solution.minDifference([15, 11, 12, 11, 10, 5], [[0, 3], [3, 5], [1, 4], [0, 5]]) == [1, 1, 1, 1]", "def test_minDifference():\n    solution = Solution()\n    assert solution.minDifference([3, 14, 5, 9, 3, 2, 11], [[1, 4], [0, 6], [2, 3], [5, 6]]) == [1, 1, 4, 9]", "def test_minDifference():\n    solution = Solution()\n    assert solution.minDifference([9, 4, 1, 8, 7, 3, 5], [[0, 6], [1, 3], [2, 5], [0, 2]]) == [1, 3, 2, 3]", "def test_minDifference():\n    solution = Solution()\n    assert solution.minDifference([1, 3, 2, 6, 4, 8, 7], [[0, 4], [2, 6], [1, 5], [3, 4]]) == [1, 1, 1, 2]", "def test_minDifference():\n    solution = Solution()\n    assert solution.minDifference([6, 1, 9, 4, 8, 11, 3], [[0, 2], [1, 4], [3, 6], [0, 5]]) == [5, 3, 1, 2]", "def test_minDifference():\n    solution = Solution()\n    assert solution.minDifference([13, 7, 9, 4, 12, 15, 10], [[0, 3], [2, 5], [1, 6], [3, 6]]) == [3, 3, 1, 2]", "def test_minDifference():\n    solution = Solution()\n    assert solution.minDifference([5, 20, 18, 7, 15, 9, 11], [[0, 2], [1, 3], [3, 5], [0, 6]]) == [2, 11, 2, 1]", "def test_minDifference():\n    solution = Solution()\n    assert solution.minDifference([3, 5, 8, 12, 7, 10, 6], [[1, 4], [0, 3], [2, 6], [3, 5]]) == [2, 2, 1, 2]"]}
{"task_num": 1923, "task_title": "Longest Common Subpath", "func_name": "longestCommonSubpath", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Set\n\nclass Solution:\n  def __init__(self):\n    self.kMod = 8_417_508_174_513\n    self.kBase = 165_131\n\n  def longestCommonSubpath(self, n: int, paths: List[List[int]]) -> int:\n    l = 0\n    r = len(paths[0])\n\n    while l < r:\n      m = l + (r - l + 1) // 2\n      if self._checkCommonSubpath(paths, m):\n        l = m\n      else:\n        r = m - 1\n\n    return l\n\n  def _checkCommonSubpath(self, paths: List[List[int]], m: int) -> bool:\n    hashSets = [self._rabinKarp(path, m) for path in paths]\n\n    for subpathHash in hashSets[0]:\n      if all(subpathHash in hashSet for hashSet in hashSets):\n        return True\n\n    return False\n\n  def _rabinKarp(self, path: List[int], m: int) -> Set[int]:\n    hashes = set()\n    maxPower = 1\n    hash = 0\n\n    for i, num in enumerate(path):\n      hash = (hash * self.kBase + num) % self.kMod\n      if i >= m:\n        hash = (hash - path[i - m] * maxPower % self.kMod + self.kMod) % self.kMod\n      else:\n        maxPower = maxPower * self.kBase % self.kMod\n      if i >= m - 1:\n        hashes.add(hash)\n\n    return hashes\n", "tests": ["def test_longestCommonSubpath():\n    solution = Solution()\n    assert solution.longestCommonSubpath(5, [[0, 1, 2, 3, 4], [2, 3, 4], [4, 0, 1, 2, 3]]) == 1", "def test_longestCommonSubpath():\n    solution = Solution()\n    assert solution.longestCommonSubpath(7, [[0, 1, 2, 3, 4, 5, 6], [6, 5, 4, 3, 2, 1, 0], [1, 2, 3, 4, 5]]) == 3", "def test_longestCommonSubpath():\n    solution = Solution()\n    assert solution.longestCommonSubpath(10, [[0, 2, 4, 6, 8], [1, 3, 5, 7, 9], [2, 4, 6, 8, 0]]) == 0", "def test_longestCommonSubpath():\n    solution = Solution()\n    assert solution.longestCommonSubpath(6, [[1, 2, 3, 4, 5], [0, 1, 2, 3, 4, 5], [3, 4, 5, 0, 1]]) == 2", "def test_longestCommonSubpath():\n    solution = Solution()\n    assert solution.longestCommonSubpath(3, [[0, 1, 2, 0, 1], [1, 2, 0, 1, 2], [2, 0, 1]]) == 3", "def test_longestCommonSubpath():\n    solution = Solution()\n    assert solution.longestCommonSubpath(4, [[0, 1, 0, 1], [2, 3, 0, 1], [1, 0, 1, 2]]) == 2", "def test_longestCommonSubpath():\n    solution = Solution()\n    assert solution.longestCommonSubpath(8, [[0, 1, 2, 7, 6], [3, 4, 5, 6, 7], [7, 6, 5, 4, 3]]) == 0", "def test_longestCommonSubpath():\n    solution = Solution()\n    assert solution.longestCommonSubpath(9, [[1, 3, 5, 7, 8, 0], [0, 1, 3, 5, 7], [7, 8, 0, 1, 3]]) == 2", "def test_longestCommonSubpath():\n    solution = Solution()\n    assert solution.longestCommonSubpath(5, [[0, 2, 4, 0, 2], [2, 4, 0, 2, 3], [4, 0, 2, 3, 1]]) == 3", "def test_longestCommonSubpath():\n    solution = Solution()\n    assert solution.longestCommonSubpath(4, [[0, 1, 0, 1, 0], [1, 0, 1, 0, 1], [0, 1, 0, 1, 2]]) == 4", "def test_longestCommonSubpath():\n    solution = Solution()\n    assert solution.longestCommonSubpath(6, [[5, 4, 3, 2, 1, 0], [0, 1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 0]]) == 1", "def test_longestCommonSubpath():\n    solution = Solution()\n    assert solution.longestCommonSubpath(5, [[0, 1, 2, 3, 4], [4, 3, 2, 1, 0], [1, 2, 3, 4, 0]]) == 1", "def test_longestCommonSubpath():\n    solution = Solution()\n    assert solution.longestCommonSubpath(4, [[0, 1, 2, 3], [1, 2, 3, 0], [2, 3, 0, 1], [3, 0, 1, 2]]) == 1", "def test_longestCommonSubpath():\n    solution = Solution()\n    assert solution.longestCommonSubpath(4, [[0, 1, 0, 2], [2, 0, 1, 3], [3, 0, 1, 2]]) == 2", "def test_longestCommonSubpath():\n    solution = Solution()\n    assert solution.longestCommonSubpath(3, [[0, 1, 2, 0, 1], [1, 0, 1, 2], [2, 1, 0, 1]]) == 2", "def test_longestCommonSubpath():\n    solution = Solution()\n    assert solution.longestCommonSubpath(7, [[0, 2, 4, 6], [6, 4, 2, 0], [2, 4, 6, 0]]) == 1", "def test_longestCommonSubpath():\n    solution = Solution()\n    assert solution.longestCommonSubpath(6, [[0, 3, 1, 4, 2], [2, 4, 1, 3, 0], [3, 1, 4, 0, 2]]) == 2", "def test_longestCommonSubpath():\n    solution = Solution()\n    assert solution.longestCommonSubpath(8, [[0, 1, 5, 2, 3, 7], [3, 7, 0, 1, 5], [7, 0, 1, 5, 2]]) == 3", "def test_longestCommonSubpath():\n    solution = Solution()\n    assert solution.longestCommonSubpath(10, [[0, 4, 5, 9, 6, 3, 2], [6, 3, 2, 0, 7, 8, 5], [5, 9, 6, 3, 2, 1, 4]]) == 3", "def test_longestCommonSubpath():\n    solution = Solution()\n    assert solution.longestCommonSubpath(9, [[1, 6, 4, 3, 7, 8], [3, 4, 3, 7, 8, 1], [6, 4, 3, 7, 8, 0]]) == 3"]}
{"task_num": 1926, "task_title": "Nearest Exit from Entrance in Maze", "func_name": "nearestExit", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def nearestExit(self, maze: List[List[str]], entrance: List[int]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(maze)\n    n = len(maze[0])\n    ans = 0\n    q = collections.deque([(entrance[0], entrance[1])])\n    seen = {(entrance[0], entrance[1])}\n\n    while q:\n      ans += 1\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if (x, y) in seen or maze[x][y] == '+':\n            continue\n          if x == 0 or x == m - 1 or y == 0 or y == n - 1:\n            return ans\n          q.append((x, y))\n          seen.add((x, y))\n\n    return -1\n", "tests": ["def test_nearestExit():\n    solution = Solution()\n    maze = [['+', '+', '.', '+'], ['.', '.', '.', '+'], ['+', '+', '+', '.']]\n    entrance = [1, 2]\n    assert solution.nearestExit(maze, entrance) == 1", "def test_nearestExit():\n    solution = Solution()\n    maze = [['.', '+'], ['.', '+'], ['.', '.'], ['+', '.']]\n    entrance = [2, 0]\n    assert solution.nearestExit(maze, entrance) == 1", "def test_nearestExit():\n    solution = Solution()\n    maze = [['+', '.', '+'], ['+', '.', '+'], ['+', '.', '+']]\n    entrance = [1, 1]\n    assert solution.nearestExit(maze, entrance) == 2", "def test_nearestExit():\n    solution = Solution()\n    maze = [['+', '+', '+', '+'], ['+', '.', '.', '+'], ['+', '+', '.', '+']]\n    entrance = [1, 1]\n    assert solution.nearestExit(maze, entrance) == -1", "def test_nearestExit():\n    solution = Solution()\n    maze = [['+', '.', '+', '+', '+'], ['+', '.', '+', '.', '.'], ['+', '+', '+', '.', '+']]\n    entrance = [0, 1]\n    assert solution.nearestExit(maze, entrance) == 3", "def test_nearestExit():\n    solution = Solution()\n    maze = [['.', '+', '+', '+'], ['+', '.', '+', '+'], ['+', '.', '.', '+'], ['+', '+', '+', '.']]\n    entrance = [0, 0]\n    assert solution.nearestExit(maze, entrance) == 6", "def test_nearestExit():\n    solution = Solution()\n    maze = [['+', '+', '+'], ['+', '.', '+'], ['+', '.', '.']]\n    entrance = [1, 1]\n    assert solution.nearestExit(maze, entrance) == 2", "def test_nearestExit():\n    solution = Solution()\n    maze = [['.', '.', '+', '+'], ['+', '.', '+', '+'], ['+', '.', '+', '+'], ['+', '.', '.', '.']]\n    entrance = [0, 1]\n    assert solution.nearestExit(maze, entrance) == 4", "def test_nearestExit():\n    solution = Solution()\n    maze = [['+', '+', '+', '+', '+'], ['+', '.', '.', '.', '+'], ['+', '.', '+', '.', '+'], ['+', '.', '+', '.', '+'], ['+', '+', '+', '.', '.']]\n    entrance = [1, 1]\n    assert solution.nearestExit(maze, entrance) == 4", "def test_nearestExit():\n    solution = Solution()\n    maze = [['+', '+', '+', '+'], ['+', '.', '.', '+'], ['+', '.', '+', '+'], ['.', '.', '+', '+']]\n    entrance = [2, 1]\n    assert solution.nearestExit(maze, entrance) == 3", "def test_nearestExit():\n    solution = Solution()\n    maze = [['+', '+', '+'], ['+', '.', '.'], ['+', '+', '+']]\n    entrance = [1, 1]\n    assert solution.nearestExit(maze, entrance) == 1", "def test_nearestExit():\n    solution = Solution()\n    maze = [['+', '+', '.', '+', '+'], ['+', '+', '.', '+', '+'], ['.', '.', '.', '+', '+'], ['+', '+', '+', '+', '+']]\n    entrance = [2, 2]\n    assert solution.nearestExit(maze, entrance) == 1", "def test_nearestExit():\n    solution = Solution()\n    maze = [['+', '+', '+', '+', '+', '+'], ['+', '.', '.', '.', '.', '+'], ['+', '+', '+', '.', '+', '+'], ['+', '.', '.', '.', '.', '+'], ['+', '+', '+', '+', '+', '+']]\n    entrance = [3, 1]\n    assert solution.nearestExit(maze, entrance) == 2", "def test_nearestExit():\n    solution = Solution()\n    maze = [['.', '+', '+', '+', '+'], ['+', '+', '.', '.', '+'], ['+', '+', '+', '.', '+']]\n    entrance = [0, 0]\n    assert solution.nearestExit(maze, entrance) == 6", "def test_nearestExit():\n    solution = Solution()\n    maze = [['+', '+', '+', '+'], ['+', '.', '+', '+'], ['+', '.', '.', '+'], ['+', '+', '.', '+'], ['.', '.', '.', '+']]\n    entrance = [2, 1]\n    assert solution.nearestExit(maze, entrance) == 3", "def test_nearestExit():\n    solution = Solution()\n    maze = [['+', '+', '+', '+', '+'], ['+', '.', '.', '.', '+'], ['+', '+', '+', '.', '+'], ['+', '.', '.', '+', '+'], ['+', '+', '+', '+', '+']]\n    entrance = [1, 2]\n    assert solution.nearestExit(maze, entrance) == 2", "def test_nearestExit():\n    solution = Solution()\n    maze = [['+', '+', '+', '+'], ['+', '.', '+', '+'], ['.', '.', '+', '+'], ['+', '.', '.', '+'], ['+', '+', '+', '+']]\n    entrance = [3, 2]\n    assert solution.nearestExit(maze, entrance) == 1", "def test_nearestExit():\n    solution = Solution()\n    maze = [['+', '+', '+', '+', '+'], ['+', '.', '+', '.', '+'], ['+', '.', '+', '.', '+'], ['+', '.', '.', '.', '+'], ['+', '+', '+', '+', '+']]\n    entrance = [3, 1]\n    assert solution.nearestExit(maze, entrance) == 3", "def test_nearestExit():\n    solution = Solution()\n    maze = [['+', '+', '+', '+', '+', '+'], ['+', '.', '.', '.', '.', '+'], ['+', '+', '+', '+', '.', '+'], ['+', '+', '.', '.', '.', '+'], ['+', '+', '+', '+', '+', '+']]\n    entrance = [1, 4]\n    assert solution.nearestExit(maze, entrance) == 3", "def test_nearestExit():\n    solution = Solution()\n    maze = [['+', '+', '+', '+', '+'], ['+', '.', '.', '+', '+'], ['+', '.', '+', '.', '.'], ['+', '+', '+', '+', '+']]\n    entrance = [1, 2]\n    assert solution.nearestExit(maze, entrance) == 3"]}
{"task_num": 1928, "task_title": "Minimum Cost to Reach Destination in Time", "func_name": "minCost", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\n    n = len(passingFees)\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, 0, n - 1, maxTime, passingFees)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, maxTime: int, passingFees: List[int]) -> int:\n    cost = [math.inf for _ in range(len(graph))]\n    dist = [maxTime + 1 for _ in range(len(graph))]\n\n    cost[src] = passingFees[src]\n    dist[src] = 0\n    minHeap = [(cost[src], dist[src], src)]\n\n    while minHeap:\n      currCost, d, u = heapq.heappop(minHeap)\n      if u == dst:\n        return cost[dst]\n      if d > dist[u] and currCost > cost[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w > maxTime:\n          continue\n        if currCost + passingFees[v] < cost[v]:\n          cost[v] = currCost + passingFees[v]\n          dist[v] = d + w\n          heapq.heappush(minHeap, (cost[v], dist[v], v))\n        elif d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (currCost + passingFees[v], dist[v], v))\n\n    return -1\n", "tests": ["def test_minCost():\n    solution = Solution()\n    maxTime = 30\n    edges = [[0, 1, 10], [1, 2, 10], [0, 2, 20]]\n    passingFees = [5, 1, 2]\n    assert solution.minCost(maxTime, edges, passingFees) == 8", "def test_minCost():\n    solution = Solution()\n    maxTime = 5\n    edges = [[0, 1, 3], [1, 2, 4], [0, 2, 5]]\n    passingFees = [10, 3, 1]\n    assert solution.minCost(maxTime, edges, passingFees) == 14", "def test_minCost():\n    solution = Solution()\n    maxTime = 2\n    edges = [[0, 1, 3], [1, 2, 4]]\n    passingFees = [1, 2, 3]\n    assert solution.minCost(maxTime, edges, passingFees) == -1", "def test_minCost():\n    solution = Solution()\n    maxTime = 10\n    edges = [[0, 1, 5], [1, 3, 5], [0, 2, 10], [2, 3, 1]]\n    passingFees = [1, 2, 3, 4]\n    assert solution.minCost(maxTime, edges, passingFees) == 7", "def test_minCost():\n    solution = Solution()\n    maxTime = 15\n    edges = [[0, 1, 5], [1, 3, 5], [0, 2, 7], [2, 3, 4], [1, 2, 2]]\n    passingFees = [1, 10, 5, 3]\n    assert solution.minCost(maxTime, edges, passingFees) == 9", "def test_minCost():\n    solution = Solution()\n    maxTime = 10\n    edges = []\n    passingFees = [1]\n    assert solution.minCost(maxTime, edges, passingFees) == 1", "def test_minCost():\n    solution = Solution()\n    maxTime = 25\n    edges = [[0, 1, 10], [1, 2, 5], [2, 3, 10], [3, 1, 2], [0, 3, 20]]\n    passingFees = [8, 2, 6, 3]\n    assert solution.minCost(maxTime, edges, passingFees) == 19", "def test_minCost():\n    solution = Solution()\n    maxTime = 100\n    edges = [[0, 1, 10], [1, 4, 20], [0, 2, 30], [2, 3, 10], [3, 4, 5]]\n    passingFees = [1, 3, 5, 7, 2]\n    assert solution.minCost(maxTime, edges, passingFees) == 13", "def test_minCost():\n    solution = Solution()\n    maxTime = 8\n    edges = [[0, 1, 5], [1, 2, 5], [0, 2, 10]]\n    passingFees = [2, 4, 6]\n    assert solution.minCost(maxTime, edges, passingFees) == -1", "def test_minCost():\n    solution = Solution()\n    maxTime = 15\n    edges = [[0, 1, 5], [1, 3, 5], [0, 2, 5], [2, 3, 5]]\n    passingFees = [5, 2, 2, 5]\n    assert solution.minCost(maxTime, edges, passingFees) == 12", "def test_minCost():\n    solution = Solution()\n    maxTime = 0\n    edges = []\n    passingFees = [10]\n    assert solution.minCost(maxTime, edges, passingFees) == 10", "def test_minCost():\n    solution = Solution()\n    maxTime = 5\n    edges = [[0, 1, 5], [1, 2, 5], [0, 2, 5]]\n    passingFees = [1, 10, 100]\n    assert solution.minCost(maxTime, edges, passingFees) == -1", "def test_minCost():\n    solution = Solution()\n    maxTime = 12\n    edges = [[0, 1, 6], [1, 3, 4], [0, 2, 5], [2, 3, 5]]\n    passingFees = [1, 5, 2, 10]\n    assert solution.minCost(maxTime, edges, passingFees) == 13", "def test_minCost():\n    solution = Solution()\n    maxTime = 15\n    edges = [[0, 1, 7], [0, 2, 7], [1, 3, 7], [2, 3, 7]]\n    passingFees = [1, 2, 2, 3]\n    assert solution.minCost(maxTime, edges, passingFees) == 8", "def test_minCost():\n    solution = Solution()\n    maxTime = 10\n    edges = [[0, 1, 5], [2, 3, 5]]\n    passingFees = [1, 2, 3, 4]\n    assert solution.minCost(maxTime, edges, passingFees) == -1", "def test_minCost():\n    solution = Solution()\n    maxTime = 20\n    edges = [[0, 1, 10], [1, 2, 5], [2, 3, 5], [1, 3, 15]]\n    passingFees = [100, 200, 300, 400]\n    assert solution.minCost(maxTime, edges, passingFees) == 1000", "def test_minCost():\n    solution = Solution()\n    maxTime = 0\n    edges = [[0, 1, 5], [1, 2, 5]]\n    passingFees = [5, 10, 15]\n    assert solution.minCost(maxTime, edges, passingFees) == -1", "def test_minCost():\n    solution = Solution()\n    maxTime = 25\n    edges = [[0, 1, 10], [1, 2, 10], [2, 0, 5], [1, 3, 5]]\n    passingFees = [1, 2, 5, 3]\n    assert solution.minCost(maxTime, edges, passingFees) == 6", "def test_minCost():\n    solution = Solution()\n    maxTime = 15\n    edges = [[0, 1, 10], [1, 3, 10], [0, 2, 5], [2, 3, 5]]\n    passingFees = [1, 100, 2, 100]\n    assert solution.minCost(maxTime, edges, passingFees) == 103", "def test_minCost():\n    solution = Solution()\n    maxTime = 50\n    edges = [[0, 2, 25], [1, 3, 25], [2, 3, 10], [0, 1, 10]]\n    passingFees = [10, 20, 30, 40]\n    assert solution.minCost(maxTime, edges, passingFees) == 70"]}
{"task_num": 1938, "task_title": "Maximum Genetic Difference Query", "func_name": "maxGeneticDifference", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass TrieNode:\n  def __init__(self):\n    self.children = [None] * 2\n    self.count = 0\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n    self.kHeight = 17\n\n  def update(self, num: int, val: int) -> None:\n    node = self.root\n    for i in range(self.kHeight, -1, -1):\n      bit = (num >> i) & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n      node.count += val\n\n  def query(self, num: int) -> int:\n    ans = 0\n    node = self.root\n    for i in range(self.kHeight, -1, -1):\n      bit = (num >> i) & 1\n      targetBit = bit ^ 1\n      if node.children[targetBit] and node.children[targetBit].count > 0:\n        ans += 1 << i\n        node = node.children[targetBit]\n      else:\n        node = node.children[targetBit ^ 1]\n    return ans\n\n\nclass Solution:\n  def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\n    n = len(parents)\n    ans = [0] * len(queries)\n    rootVal = -1\n    tree = [[] for _ in range(n)]\n    nodeToQueries = collections.defaultdict(list)\n    trie = Trie()\n\n    for i, parent in enumerate(parents):\n      if parent == -1:\n        rootVal = i\n      else:\n        tree[parent].append(i)\n\n    for i, (node, val) in enumerate(queries):\n      nodeToQueries[node].append((i, val))\n\n    def dfs(node: int) -> None:\n      trie.update(node, 1)\n\n      for i, val in nodeToQueries[node]:\n        ans[i] = trie.query(val)\n\n      for child in tree[node]:\n        dfs(child)\n\n      trie.update(node, -1)\n\n    dfs(rootVal)\n    return ans\n", "tests": ["def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [-1, 0, 1, 2]\n    queries = [[3, 5], [0, 3]]\n    assert solution.maxGeneticDifference(parents, queries) == [7, 3]", "def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [-1, 0, 0, 1, 1, 2]\n    queries = [[4, 7], [5, 2], [3, 3]]\n    assert solution.maxGeneticDifference(parents, queries) == [7, 7, 3]", "def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [-1, 0, 0, 1, 1, 2, 2, 3, 4, 4]\n    queries = [[9, 15], [6, 12], [7, 2], [8, 8]]\n    assert solution.maxGeneticDifference(parents, queries) == [15, 14, 7, 12]", "def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [-1, 0, 1, 1, 0, 4, 4, 3]\n    queries = [[7, 10], [5, 5], [2, 6], [6, 1]]\n    assert solution.maxGeneticDifference(parents, queries) == [15, 5, 7, 5]", "def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [-1, 0, 0, 1, 1, 2, 3, 3, 4]\n    queries = [[5, 13], [8, 4], [6, 9], [7, 1]]\n    assert solution.maxGeneticDifference(parents, queries) == [15, 12, 15, 11]", "def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [-1, 0, 0, 2, 2, 1, 5, 5, 4, 4]\n    queries = [[9, 10], [7, 3], [8, 6], [6, 15]]\n    assert solution.maxGeneticDifference(parents, queries) == [14, 7, 14, 15]", "def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [-1, 0, 0, 1, 3, 3, 2, 6, 6, 8]\n    queries = [[4, 7], [9, 2], [5, 11], [7, 14]]\n    assert solution.maxGeneticDifference(parents, queries) == [7, 10, 15, 15]", "def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [-1, 0, 1, 2, 2, 1, 0, 5, 3, 8, 8]\n    queries = [[10, 4], [9, 8], [7, 13], [6, 6]]\n    assert solution.maxGeneticDifference(parents, queries) == [12, 8, 14, 7]", "def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [-1, 0, 0, 1, 1, 3, 3, 2, 4, 5, 6]\n    queries = [[8, 5], [9, 10], [10, 3], [7, 7]]\n    assert solution.maxGeneticDifference(parents, queries) == [13, 11, 11, 7]", "def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [-1, 0, 1, 1, 0, 2, 3, 5, 6, 8, 8, 7]\n    queries = [[11, 9], [10, 4], [4, 12], [9, 6]]\n    assert solution.maxGeneticDifference(parents, queries) == [14, 12, 12, 12]", "def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [-1, 0, 0, 2, 2, 1, 1, 6, 4, 5, 3, 8]\n    queries = [[11, 7], [10, 2], [8, 14], [7, 9]]\n    assert solution.maxGeneticDifference(parents, queries) == [14, 3, 15, 15]", "def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [-1, 0, 1, 0, 3, 3, 2, 5, 4, 6, 9, 8]\n    queries = [[11, 1], [10, 8], [9, 11], [7, 5]]\n    assert solution.maxGeneticDifference(parents, queries) == [11, 11, 15, 7]", "def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [-1, 0, 1, 2, 2, 4, 5, 3, 6, 7, 8, 9]\n    queries = [[5, 0], [6, 7], [11, 2], [10, 9]]\n    assert solution.maxGeneticDifference(parents, queries) == [5, 7, 11, 11]", "def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [-1, 0, 1, 1, 0, 4, 4, 3, 5, 6, 7, 9]\n    queries = [[8, 6], [11, 10], [10, 3], [7, 15]]\n    assert solution.maxGeneticDifference(parents, queries) == [15, 11, 15, 15]", "def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [-1, 0, 0, 2, 1, 3, 5, 4, 7, 6, 9, 8]\n    queries = [[4, 11], [3, 2], [11, 5], [8, 14]]\n    assert solution.maxGeneticDifference(parents, queries) == [15, 3, 14, 15]", "def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [-1, 0, 1, 2, 3, 1, 0, 6, 5, 7, 4, 9]\n    queries = [[10, 10], [11, 4], [8, 2], [9, 13]]\n    assert solution.maxGeneticDifference(parents, queries) == [14, 15, 6, 15]", "def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [-1, 0, 0, 1, 1, 3, 3, 2, 2, 8, 7, 5]\n    queries = [[6, 1], [10, 12], [11, 7], [9, 11]]\n    assert solution.maxGeneticDifference(parents, queries) == [7, 14, 15, 11]", "def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [-1, 0, 1, 0, 3, 2, 4, 6, 7, 8, 5, 9]\n    queries = [[11, 3], [10, 8], [9, 5], [6, 14]]\n    assert solution.maxGeneticDifference(parents, queries) == [14, 10, 13, 10]", "def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [-1, 0, 0, 1, 1, 2, 4, 4, 3, 5, 6, 7]\n    queries = [[8, 9], [10, 3], [11, 14], [9, 2]]\n    assert solution.maxGeneticDifference(parents, queries) == [11, 15, 15, 11]", "def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [-1, 0, 1, 0, 2, 2, 5, 3, 4, 6, 7, 9]\n    queries = [[7, 10], [11, 2], [10, 1], [8, 15]]\n    assert solution.maxGeneticDifference(parents, queries) == [15, 11, 11, 15]"]}
{"task_num": 1971, "task_title": "Find if Path Exists in Graph", "func_name": "validPath", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def validPath(self, n: int, edges: List[List[int]], source: int, destination: int) -> bool:\n    uf = UnionFind(n)\n\n    for u, v in edges:\n      uf.unionByRank(u, v)\n\n    return uf.find(source) == uf.find(destination)\n", "tests": ["def test_validPath():\n    solution = Solution()\n    assert solution.validPath(4, [[0, 1], [1, 2], [2, 3]], 0, 3) == True", "def test_validPath():\n    solution = Solution()\n    assert solution.validPath(6, [[0, 1], [0, 2], [3, 4], [4, 5]], 0, 5) == False", "def test_validPath():\n    solution = Solution()\n    assert solution.validPath(5, [[0, 1], [1, 2], [2, 3], [3, 4]], 0, 4) == True", "def test_validPath():\n    solution = Solution()\n    assert solution.validPath(3, [[0, 1]], 0, 2) == False", "def test_validPath():\n    solution = Solution()\n    assert solution.validPath(3, [[1, 2]], 0, 0) == True", "def test_validPath():\n    solution = Solution()\n    assert solution.validPath(7, [[0, 1], [1, 2], [2, 0], [4, 5], [5, 6]], 0, 6) == False", "def test_validPath():\n    solution = Solution()\n    assert solution.validPath(1, [], 0, 0) == True", "def test_validPath():\n    solution = Solution()\n    assert solution.validPath(8, [[0, 1], [1, 2], [2, 3], [3, 4], [5, 6]], 0, 4) == True", "def test_validPath():\n    solution = Solution()\n    assert solution.validPath(5, [[0, 1], [1, 2], [2, 0], [3, 4]], 4, 3) == True", "def test_validPath():\n    solution = Solution()\n    assert solution.validPath(5, [[0, 1], [1, 2], [2, 3], [3, 4]], 1, 3) == True", "def test_validPath():\n    solution = Solution()\n    assert solution.validPath(6, [[0, 1], [2, 3], [4, 5]], 0, 2) == False", "def test_validPath():\n    solution = Solution()\n    assert solution.validPath(10, [[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]], 5, 8) == False", "def test_validPath():\n    solution = Solution()\n    assert solution.validPath(3, [[0, 1], [1, 2]], 0, 1) == True", "def test_validPath():\n    solution = Solution()\n    assert solution.validPath(4, [[0, 1], [2, 3]], 1, 2) == False", "def test_validPath():\n    solution = Solution()\n    assert solution.validPath(7, [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6]], 0, 6) == True", "def test_validPath():\n    solution = Solution()\n    assert solution.validPath(2, [[0, 1]], 0, 1) == True", "def test_validPath():\n    solution = Solution()\n    assert solution.validPath(5, [[0, 1], [0, 2], [2, 3], [3, 4], [4, 0]], 1, 3) == True", "def test_validPath():\n    solution = Solution()\n    assert solution.validPath(4, [[0, 1], [1, 2], [2, 3]], 3, 0) == True", "def test_validPath():\n    solution = Solution()\n    assert solution.validPath(8, [[0, 1], [0, 2], [0, 3], [4, 5], [5, 6], [6, 7]], 3, 7) == False", "def test_validPath():\n    solution = Solution()\n    assert solution.validPath(9, [[0, 1], [1, 2], [2, 3], [4, 5], [5, 6], [6, 7], [7, 8]], 8, 0) == False"]}
{"task_num": 1976, "task_title": "Number of Ways to Arrive at Destination", "func_name": "countPaths", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countPaths(self, n: int, roads: List[List[int]]) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in roads:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, 0, n - 1)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int) -> int:\n    kMod = 10**9 + 7\n    ways = [0] * len(graph)\n    dist = [math.inf] * len(graph)\n\n    ways[src] = 1\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          ways[v] = ways[u]\n          heapq.heappush(minHeap, (dist[v], v))\n        elif d + w == dist[v]:\n          ways[v] += ways[u]\n          ways[v] %= kMod\n\n    return ways[dst]\n", "tests": ["def test_countPaths():\n    solution = Solution()\n    assert solution.countPaths(5, [[0, 1, 2], [0, 2, 2], [1, 2, 1], [1, 3, 1], [2, 3, 1], [3, 4, 1]]) == 2", "def test_countPaths():\n    solution = Solution()\n    assert solution.countPaths(4, [[0, 1, 1], [0, 2, 1], [1, 3, 1], [2, 3, 1]]) == 2", "def test_countPaths():\n    solution = Solution()\n    assert solution.countPaths(6, [[0, 1, 2], [0, 2, 4], [1, 2, 1], [1, 3, 7], [2, 4, 3], [3, 5, 1], [4, 5, 1]]) == 1", "def test_countPaths():\n    solution = Solution()\n    assert solution.countPaths(3, [[0, 1, 5], [1, 2, 5], [0, 2, 10]]) == 1", "def test_countPaths():\n    solution = Solution()\n    assert solution.countPaths(7, [[0, 1, 1], [1, 2, 1], [2, 3, 1], [3, 4, 1], [4, 5, 1], [5, 6, 1], [0, 6, 6]]) == 5", "def test_countPaths():\n    solution = Solution()\n    assert solution.countPaths(4, [[0, 1, 1], [1, 2, 1], [2, 3, 1], [0, 2, 2], [1, 3, 2]]) == 3", "def test_countPaths():\n    solution = Solution()\n    assert solution.countPaths(5, [[0, 1, 1], [0, 2, 2], [1, 3, 1], [2, 3, 1], [3, 4, 3], [1, 4, 4], [2, 4, 3]]) == 4", "def test_countPaths():\n    solution = Solution()\n    assert solution.countPaths(6, [[0, 1, 2], [1, 2, 2], [2, 3, 2], [3, 4, 2], [4, 5, 2], [0, 5, 10]]) == 1", "def test_countPaths():\n    solution = Solution()\n    assert solution.countPaths(4, [[0, 1, 3], [1, 2, 3], [2, 3, 3], [0, 2, 6], [1, 3, 6]]) == 1", "def test_countPaths():\n    solution = Solution()\n    assert solution.countPaths(5, [[0, 1, 1], [1, 2, 2], [2, 3, 3], [3, 4, 4], [0, 2, 3], [1, 3, 5], [2, 4, 7]]) == 2", "def test_countPaths():\n    solution = Solution()\n    assert solution.countPaths(3, [[0, 1, 2], [1, 2, 3], [0, 2, 4]]) == 1", "def test_countPaths():\n    solution = Solution()\n    assert solution.countPaths(5, [[0, 1, 3], [0, 2, 3], [1, 3, 1], [2, 3, 1], [3, 4, 2], [1, 2, 1]]) == 4", "def test_countPaths():\n    solution = Solution()\n    assert solution.countPaths(6, [[0, 1, 2], [1, 2, 3], [2, 3, 1], [3, 4, 5], [4, 5, 1], [0, 3, 6], [2, 5, 3]]) == 2", "def test_countPaths():\n    solution = Solution()\n    assert solution.countPaths(7, [[0, 1, 1], [1, 2, 2], [0, 3, 2], [3, 4, 1], [4, 5, 2], [5, 6, 1], [2, 6, 3]]) == 3", "def test_countPaths():\n    solution = Solution()\n    assert solution.countPaths(4, [[0, 1, 4], [0, 2, 5], [1, 3, 3], [2, 3, 2], [1, 2, 1]]) == 2", "def test_countPaths():\n    solution = Solution()\n    assert solution.countPaths(5, [[0, 1, 3], [1, 2, 1], [2, 3, 4], [3, 4, 1], [0, 2, 2], [1, 3, 3]]) == 3", "def test_countPaths():\n    solution = Solution()\n    assert solution.countPaths(5, [[0, 1, 2], [1, 2, 2], [0, 3, 4], [3, 4, 1], [2, 4, 3]]) == 1", "def test_countPaths():\n    solution = Solution()\n    assert solution.countPaths(6, [[0, 1, 1], [1, 2, 2], [2, 3, 1], [3, 4, 2], [4, 5, 1], [0, 2, 2], [1, 3, 3]]) == 2", "def test_countPaths():\n    solution = Solution()\n    assert solution.countPaths(7, [[0, 1, 3], [1, 2, 4], [1, 3, 2], [3, 4, 1], [4, 5, 1], [5, 6, 2], [2, 6, 5]]) == 1", "def test_countPaths():\n    solution = Solution()\n    assert solution.countPaths(8, [[0, 1, 1], [0, 2, 5], [1, 3, 1], [2, 3, 2], [3, 4, 3], [4, 5, 1], [5, 6, 1], [6, 7, 1], [2, 6, 4]]) == 3"]}
{"task_num": 1977, "task_title": "Number of Ways to Separate Numbers", "func_name": "numberOfCombinations", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numberOfCombinations(self, num: str) -> int:\n    if num[0] == '0':\n      return 0\n\n    kMod = 1_000_000_007\n    n = len(num)\n    dp = [[0] * (n + 1) for _ in range(n)]\n    lcs = [[0] * (n + 1) for _ in range(n + 1)]\n\n    for i in range(n - 1, -1, -1):\n      for j in range(i + 1, n):\n        if num[i] == num[j]:\n          lcs[i][j] = lcs[i + 1][j + 1] + 1\n\n    for i in range(n):\n      for k in range(1, i + 2):\n        dp[i][k] += dp[i][k - 1]\n        dp[i][k] %= kMod\n        s = i - k + 1\n        if num[s] == '0':\n          continue\n        if s == 0:\n          dp[i][k] += 1\n          continue\n        if s < k:\n          dp[i][k] += dp[s - 1][s]\n          continue\n        l = lcs[s - k][s]\n        if l >= k or num[s - k + l] <= num[s + l]:\n          dp[i][k] += dp[s - 1][k]\n        else:\n          dp[i][k] += dp[s - 1][k - 1]\n\n    return dp[n - 1][n] % kMod\n", "tests": ["def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('327') == 2", "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('0123') == 0", "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('111') == 3", "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('1001') == 0", "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('1234') == 1", "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('2222') == 8", "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('101010') == 0", "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('123123') == 5", "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('000') == 0", "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('456789') == 1", "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('112358') == 4", "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('2323') == 4", "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('1212') == 5", "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('303') == 0", "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('789') == 1", "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('001') == 0", "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('121212') == 13", "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('987654') == 1", "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('333') == 4", "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('223344') == 6"]}
{"task_num": 1994, "task_title": "The Number of Good Subsets", "func_name": "numberOfGoodSubsets", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numberOfGoodSubsets(self, nums: List[int]) -> int:\n    kMod = 1_000_000_007\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n    n = 1 << len(primes)\n    dp = [1] + [0] * (n - 1)\n    count = collections.Counter(nums)\n\n    for num, freq in count.items():\n      if num == 1:\n        continue\n      if any(num % squared == 0 for squared in [4, 9, 25]):\n        continue\n      numPrimesMask = 0\n      for i, prime in enumerate(primes):\n        if num % prime == 0:\n          numPrimesMask += 1 << i\n      for primesMask in range(n):\n        if primesMask & numPrimesMask > 0:\n          continue\n        nextPrimesMask = numPrimesMask | primesMask\n        dp[nextPrimesMask] += dp[primesMask] * freq\n        dp[nextPrimesMask] %= kMod\n\n    return (1 << count[1]) * sum(dp[1:]) % kMod\n", "tests": ["def test_numberOfGoodSubsets():\n    solution = Solution()\n    assert solution.numberOfGoodSubsets([1, 2, 3, 4]) == 6", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    assert solution.numberOfGoodSubsets([2, 4, 6, 8, 10, 12, 14, 16, 18, 20]) == 0", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    assert solution.numberOfGoodSubsets([1, 1, 2, 3, 5]) == 18", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    assert solution.numberOfGoodSubsets([2, 3, 5, 7, 11, 13, 17]) == 127", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    assert solution.numberOfGoodSubsets([2, 3, 2, 3]) == 6", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    assert solution.numberOfGoodSubsets([4, 8, 16, 32]) == 0", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    assert solution.numberOfGoodSubsets([7]) == 1", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    assert solution.numberOfGoodSubsets([2, 3, 4, 6, 7, 9, 10, 15]) == 32", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    assert solution.numberOfGoodSubsets([1, 1, 1, 2, 3]) == 24", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    assert solution.numberOfGoodSubsets([5, 10, 15, 25]) == 3", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    assert solution.numberOfGoodSubsets([29, 29, 29, 29]) == 1", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    assert solution.numberOfGoodSubsets([3, 6, 7, 14, 28]) == 5", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    assert solution.numberOfGoodSubsets([4, 6, 9, 12, 15]) == 0", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    assert solution.numberOfGoodSubsets([2, 5, 10, 11]) == 5", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    assert solution.numberOfGoodSubsets([18, 19, 20, 29]) == 4", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    assert solution.numberOfGoodSubsets([2, 4, 8, 16]) == 0", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    assert solution.numberOfGoodSubsets([]) == 0", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    assert solution.numberOfGoodSubsets([3, 6, 7, 11, 13, 22]) == 12", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    assert solution.numberOfGoodSubsets([3, 3, 3, 3, 3]) == 1", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    assert solution.numberOfGoodSubsets(list(range(1, 21))) == 622"]}
{"task_num": 1998, "task_title": "GCD Sort of an Array", "func_name": "gcdSort", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def gcdSort(self, nums: List[int]) -> bool:\n    maxNum = max(nums)\n    minPrimeFactors = self._sieveEratosthenes(maxNum + 1)\n    uf = UnionFind(maxNum + 1)\n\n    for num in nums:\n      for primeFactor in self._getPrimeFactors(num, minPrimeFactors):\n        uf.unionByRank(num, primeFactor)\n\n    for a, b in zip(nums, sorted(nums)):\n      if uf.find(a) != uf.find(b):\n        return False\n\n    return True\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeFactors(self, num: int, minPrimeFactors: List[int]) -> List[int]:\n    primeFactors = []\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      primeFactors.append(divisor)\n      while num % divisor == 0:\n        num //= divisor\n    return primeFactors\n", "tests": ["def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([7, 21, 3]) == True", "def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([10, 15, 20, 5]) == True", "def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([8, 4, 2, 1]) == True", "def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([3, 9, 2, 5]) == False", "def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([17, 34, 51]) == True", "def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([6, 10, 15]) == True", "def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([10, 3, 6]) == False", "def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([18, 24, 30, 12]) == True", "def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([13, 26, 39, 52]) == True", "def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([5, 10, 3, 9]) == False", "def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([60, 90, 150, 30]) == True", "def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([11, 22, 33, 44]) == True", "def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([14, 28, 19, 35]) == False", "def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([7, 14, 21, 13]) == True", "def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([9, 27, 4, 16]) == False", "def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([2, 3, 5, 7, 11]) == True", "def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([4, 8, 16, 2, 32]) == True", "def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([25, 50, 75, 35]) == False", "def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([29, 58, 87, 2]) == False", "def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([3, 6, 2, 7, 4]) == False"]}
{"task_num": 2019, "task_title": "The Score of Students Solving Math Expression", "func_name": "scoreOfStudents", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nimport operator\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def scoreOfStudents(self, s: str, answers: List[int]) -> int:\n    n = len(s) // 2 + 1\n    ans = 0\n    func = {'+': operator.add, '*': operator.mul}\n    dp = [[set() for j in range(n)] for _ in range(n)]\n\n    for i in range(n):\n      dp[i][i].add(int(s[i * 2]))\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        for k in range(i, j):\n          op = s[k * 2 + 1]\n          for a in dp[i][k]:\n            for b in dp[k + 1][j]:\n              res = func[op](a, b)\n              if res <= 1000:\n                dp[i][j].add(res)\n\n    correctAnswer = eval(s)\n\n    for answer, freq in collections.Counter(answers).items():\n      if answer == correctAnswer:\n        ans += 5 * freq\n      elif answer in dp[0][n - 1]:\n        ans += 2 * freq\n\n    return ans\n", "tests": ["def test_scoreOfStudents():\n    solution = Solution()\n    assert solution.scoreOfStudents('3+5*2', [13, 16, 10, 13]) == 11", "def test_scoreOfStudents():\n    solution = Solution()\n    assert solution.scoreOfStudents('1*2+3*4', [14, 11, 10, 9, 13]) == 13", "def test_scoreOfStudents():\n    solution = Solution()\n    assert solution.scoreOfStudents('2+3*2', [7, 12, 8, 10]) == 7", "def test_scoreOfStudents():\n    solution = Solution()\n    assert solution.scoreOfStudents('4*5+2', [22, 24, 20, 30, 18]) == 9", "def test_scoreOfStudents():\n    solution = Solution()\n    assert solution.scoreOfStudents('6+2*3', [12, 8, 14, 18, 9]) == 9", "def test_scoreOfStudents():\n    solution = Solution()\n    assert solution.scoreOfStudents('3*3*3', [27, 18, 9, 15]) == 9", "def test_scoreOfStudents():\n    solution = Solution()\n    assert solution.scoreOfStudents('8+6*4', [32, 38, 26, 30]) == 9", "def test_scoreOfStudents():\n    solution = Solution()\n    assert solution.scoreOfStudents('9*1+7', [16, 10, 15, 17]) == 7", "def test_scoreOfStudents():\n    solution = Solution()\n    assert solution.scoreOfStudents('5+5*5', [30, 50, 25, 40]) == 7", "def test_scoreOfStudents():\n    solution = Solution()\n    assert solution.scoreOfStudents('7*2+2', [18, 16, 14, 20]) == 9", "def test_scoreOfStudents():\n    solution = Solution()\n    assert solution.scoreOfStudents('2*3+4*5', [26, 20, 22, 14]) == 7", "def test_scoreOfStudents():\n    solution = Solution()\n    assert solution.scoreOfStudents('1+2*3+4', [11, 13, 9, 18]) == 9", "def test_scoreOfStudents():\n    solution = Solution()\n    assert solution.scoreOfStudents('3*4+5*6', [42, 24, 48, 33]) == 7", "def test_scoreOfStudents():\n    solution = Solution()\n    assert solution.scoreOfStudents('2+2*2+2', [10, 6, 8, 12]) == 11", "def test_scoreOfStudents():\n    solution = Solution()\n    assert solution.scoreOfStudents('6*3+2*2', [22, 20, 18, 14]) == 11", "def test_scoreOfStudents():\n    solution = Solution()\n    assert solution.scoreOfStudents('7+3*1+4', [14, 15, 12, 18]) == 11", "def test_scoreOfStudents():\n    solution = Solution()\n    assert solution.scoreOfStudents('5*5+5*5', [50, 25, 35, 45]) == 14", "def test_scoreOfStudents():\n    solution = Solution()\n    assert solution.scoreOfStudents('4+4*4+4', [24, 20, 16, 28]) == 11", "def test_scoreOfStudents():\n    solution = Solution()\n    assert solution.scoreOfStudents('2*2+3*3', [13, 11, 10, 15]) == 9", "def test_scoreOfStudents():\n    solution = Solution()\n    assert solution.scoreOfStudents('3+3*3+3', [18, 15, 21, 12]) == 11"]}
{"task_num": 2030, "task_title": "Smallest K-Length Subsequence With Occurrences of a Letter", "func_name": "smallestSubsequence", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\n    stack = []\n    required = repetition\n    nLetters = s.count(letter)\n\n    for i, c in enumerate(s):\n      while stack and stack[-1] > c  and len(stack) + len(s) - i - 1 >= k and (stack[-1] != letter or nLetters > required):\n        if stack.pop() == letter:\n          required += 1\n      if len(stack) < k:\n        if c == letter:\n          stack.append(c)\n          required -= 1\n        elif k - len(stack) > required:\n          stack.append(c)\n      if c == letter:\n        nLetters -= 1\n\n    return ''.join(stack)\n", "tests": ["def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('cbacdcbc', 4, 'c', 2) == 'acdc'", "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('abacabadabacaba', 7, 'a', 3) == 'aaaaaba'", "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('xyzxyzxyz', 5, 'y', 2) == 'xyxyz'", "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('aaabbccdd', 6, 'b', 1) == 'aabbcd'", "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('thequickbrownfox', 8, 'o', 2) == 'brownfox'", "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('pqrstuvpqrstuv', 10, 'r', 1) == 'pqrstupqst'", "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('babacbabac', 5, 'b', 3) == 'babac'", "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('zzzyxyz', 4, 'z', 2) == 'xyz'", "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('abcdefghij', 6, 'f', 1) == 'abcdef'", "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('mnopqrstmn', 5, 'm', 1) == 'mnopm'", "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('aabbccddeeff', 4, 'e', 2) == 'cdee'", "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('bccbabab', 5, 'b', 3) == 'bcabb'", "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('ffeedddccbb', 6, 'd', 2) == 'edddcc'", "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('zyxwvutsrqponm', 7, 'n', 1) == 'nwvutsr'", "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('oooabcdeoo', 5, 'o', 3) == 'ooabc'", "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('cacacacb', 4, 'c', 2) == 'acac'", "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('ghhghghfg', 6, 'g', 2) == 'ghghfg'", "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('lmnopqrlmnopqr', 8, 'r', 2) == 'lmnopqrr'", "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('xyaxybxyc', 5, 'y', 3) == 'xybxy'", "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('abcabcabc', 5, 'a', 2) == 'ababc'"]}
{"task_num": 2040, "task_title": "Kth Smallest Product of Two Sorted Arrays", "func_name": "kthSmallestProduct", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int) -> int:\n    A1 = [-num for num in nums1 if num < 0][::-1]\n    A2 = [num for num in nums1 if num >= 0]\n    B1 = [-num for num in nums2 if num < 0][::-1]\n    B2 = [num for num in nums2 if num >= 0]\n\n    negCount = len(A1) * len(B2) + len(A2) * len(B1)\n\n    if k > negCount:\n      k -= negCount\n      sign = 1\n    else:\n      k = negCount - k + 1\n      sign = -1\n      B1, B2 = B2, B1\n\n    def numProductNoGreaterThan(A: List[int], B: List[int], m: int) -> int:\n      ans = 0\n      j = len(B) - 1\n      for i in range(len(A)):\n        while j >= 0 and A[i] * B[j] > m:\n          j -= 1\n        ans += j + 1\n      return ans\n\n    l = 0\n    r = 10**10\n\n    while l < r:\n      m = (l + r) // 2\n      if numProductNoGreaterThan(A1, B1, m) + numProductNoGreaterThan(A2, B2, m) >= k:\n        r = m\n      else:\n        l = m + 1\n\n    return sign * l\n", "tests": ["def test_kthSmallestProduct():\n    solution = Solution()\n    assert solution.kthSmallestProduct([1, 2, 3], [4, 5, 6], 4) == 8", "def test_kthSmallestProduct():\n    solution = Solution()\n    assert solution.kthSmallestProduct([-4, -2, 0, 3], [-3, -1, 2, 5], 5) == 0", "def test_kthSmallestProduct():\n    solution = Solution()\n    assert solution.kthSmallestProduct([-5, -3, -1, 0, 2, 4], [-6, -4, -2, 1, 3, 5], 20) == 9", "def test_kthSmallestProduct():\n    solution = Solution()\n    assert solution.kthSmallestProduct([0, 1, 2], [-3, -2, -1], 6) == 0", "def test_kthSmallestProduct():\n    solution = Solution()\n    assert solution.kthSmallestProduct([-10, -3, 1], [2, 3, 4], 3) == -10", "def test_kthSmallestProduct():\n    solution = Solution()\n    assert solution.kthSmallestProduct([-2, 0, 1, 3], [-1, 2, 4], 7) == 6", "def test_kthSmallestProduct():\n    solution = Solution()\n    assert solution.kthSmallestProduct([-7, -5, -3], [-6, -4, -2], 8) == 28", "def test_kthSmallestProduct():\n    solution = Solution()\n    assert solution.kthSmallestProduct([1, 2, 3], [-2, -1], 2) == -3", "def test_kthSmallestProduct():\n    solution = Solution()\n    assert solution.kthSmallestProduct([-8, -4, 0, 2], [1, 3, 5], 10) == 10", "def test_kthSmallestProduct():\n    solution = Solution()\n    assert solution.kthSmallestProduct([-1, 0, 2, 3], [-3, -2, 1], 4) == -2", "def test_kthSmallestProduct():\n    solution = Solution()\n    assert solution.kthSmallestProduct([0, 1, 5], [-5, -4, -3], 9) == 0", "def test_kthSmallestProduct():\n    solution = Solution()\n    assert solution.kthSmallestProduct([1, 4, 7], [2, 3, 6], 5) == 8", "def test_kthSmallestProduct():\n    solution = Solution()\n    assert solution.kthSmallestProduct([-6, -2, 1], [-3, 0, 4], 7) == 4", "def test_kthSmallestProduct():\n    solution = Solution()\n    assert solution.kthSmallestProduct([-3, -1, 4], [-5, 2, 6], 6) == 2", "def test_kthSmallestProduct():\n    solution = Solution()\n    assert solution.kthSmallestProduct([-9, -4, 0, 5], [-2, 1, 3], 11) == 15", "def test_kthSmallestProduct():\n    solution = Solution()\n    assert solution.kthSmallestProduct([0, 2, 3, 4], [-3, -2, 1], 5) == 0", "def test_kthSmallestProduct():\n    solution = Solution()\n    assert solution.kthSmallestProduct([-7, -3, 2], [-2, 0, 3], 8) == 9", "def test_kthSmallestProduct():\n    solution = Solution()\n    assert solution.kthSmallestProduct([1, 2, 3, 4], [5, 6], 3) == 10", "def test_kthSmallestProduct():\n    solution = Solution()\n    assert solution.kthSmallestProduct([-5, 0, 3], [-3, -1, 2], 7) == 0", "def test_kthSmallestProduct():\n    solution = Solution()\n    assert solution.kthSmallestProduct([-10, -5, 1], [-4, -1, 3], 9) == 10"]}
{"task_num": 2045, "task_title": "Second Minimum Time to Reach Destination", "func_name": "secondMinimum", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\n    graph = [[] for _ in range(n + 1)]\n    q = collections.deque([(1, 0)])\n    minTime = [[math.inf] * 2 for _ in range(n + 1)]\n    minTime[1][0] = 0\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    while q:\n      i, prevTime = q.popleft()\n\n      numChangeSignal = prevTime // change\n      waitTime = change - (prevTime % change) if numChangeSignal & 1 else 0\n      newTime = prevTime + waitTime + time\n      for j in graph[i]:\n        if newTime < minTime[j][0]:\n          minTime[j][0] = newTime\n          q.append((j, newTime))\n        elif minTime[j][0] < newTime < minTime[j][1]:\n          if j == n:\n            return newTime\n          minTime[j][1] = newTime\n          q.append((j, newTime))\n", "tests": ["def test_secondMinimum():\n    solution = Solution()\n    n = 5\n    edges = [[1, 2], [1, 3], [3, 4], [4, 5], [2, 5]]\n    time = 3\n    change = 5\n    assert solution.secondMinimum(n, edges, time, change) == 13", "def test_secondMinimum():\n    solution = Solution()\n    n = 4\n    edges = [[1, 2], [2, 3], [3, 4]]\n    time = 2\n    change = 3\n    assert solution.secondMinimum(n, edges, time, change) == 11", "def test_secondMinimum():\n    solution = Solution()\n    n = 6\n    edges = [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [1, 3], [2, 4]]\n    time = 4\n    change = 6\n    assert solution.secondMinimum(n, edges, time, change) == 25", "def test_secondMinimum():\n    solution = Solution()\n    n = 3\n    edges = [[1, 2], [1, 3], [2, 3]]\n    time = 5\n    change = 7\n    assert solution.secondMinimum(n, edges, time, change) == 19", "def test_secondMinimum():\n    solution = Solution()\n    n = 7\n    edges = [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [1, 3], [2, 4], [3, 5]]\n    time = 1\n    change = 2\n    assert solution.secondMinimum(n, edges, time, change) == 11", "def test_secondMinimum():\n    solution = Solution()\n    n = 4\n    edges = [[1, 2], [2, 3], [3, 4], [1, 4]]\n    time = 3\n    change = 4\n    assert solution.secondMinimum(n, edges, time, change) == 17", "def test_secondMinimum():\n    solution = Solution()\n    n = 5\n    edges = [[1, 2], [2, 3], [3, 5], [1, 4], [4, 5]]\n    time = 6\n    change = 3\n    assert solution.secondMinimum(n, edges, time, change) == 22", "def test_secondMinimum():\n    solution = Solution()\n    n = 6\n    edges = [[1, 2], [2, 3], [3, 6], [1, 4], [4, 5], [5, 6]]\n    time = 2\n    change = 5\n    assert solution.secondMinimum(n, edges, time, change) == 13", "def test_secondMinimum():\n    solution = Solution()\n    n = 5\n    edges = [[1, 3], [3, 4], [4, 2], [2, 5], [3, 5]]\n    time = 7\n    change = 8\n    assert solution.secondMinimum(n, edges, time, change) == 29", "def test_secondMinimum():\n    solution = Solution()\n    n = 6\n    edges = [[1, 2], [1, 3], [2, 4], [3, 5], [4, 6], [5, 6]]\n    time = 3\n    change = 7\n    assert solution.secondMinimum(n, edges, time, change) == 23", "def test_secondMinimum():\n    solution = Solution()\n    n = 4\n    edges = [[1, 2], [1, 3], [2, 4], [3, 4]]\n    time = 5\n    change = 4\n    assert solution.secondMinimum(n, edges, time, change) == 17", "def test_secondMinimum():\n    solution = Solution()\n    n = 5\n    edges = [[1, 3], [3, 4], [4, 5], [1, 2], [2, 5]]\n    time = 4\n    change = 6\n    assert solution.secondMinimum(n, edges, time, change) == 20", "def test_secondMinimum():\n    solution = Solution()\n    n = 7\n    edges = [[1, 2], [2, 3], [3, 4], [4, 5], [5, 7], [3, 6], [6, 7]]\n    time = 2\n    change = 3\n    assert solution.secondMinimum(n, edges, time, change) == 15", "def test_secondMinimum():\n    solution = Solution()\n    n = 6\n    edges = [[1, 2], [2, 4], [4, 6], [1, 3], [3, 5], [5, 6], [2, 5]]\n    time = 1\n    change = 2\n    assert solution.secondMinimum(n, edges, time, change) == 11", "def test_secondMinimum():\n    solution = Solution()\n    n = 8\n    edges = [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [1, 5], [2, 6]]\n    time = 3\n    change = 5\n    assert solution.secondMinimum(n, edges, time, change) == 29", "def test_secondMinimum():\n    solution = Solution()\n    n = 9\n    edges = [[1, 2], [2, 3], [3, 9], [1, 4], [4, 5], [5, 6], [6, 9], [3, 7], [7, 8], [8, 9]]\n    time = 4\n    change = 7\n    assert solution.secondMinimum(n, edges, time, change) == 34", "def test_secondMinimum():\n    solution = Solution()\n    n = 7\n    edges = [[1, 2], [1, 3], [2, 4], [3, 5], [4, 6], [5, 7], [6, 7]]\n    time = 2\n    change = 4\n    assert solution.secondMinimum(n, edges, time, change) == 17", "def test_secondMinimum():\n    solution = Solution()\n    n = 10\n    edges = [[1, 2], [2, 3], [3, 4], [4, 5], [5, 10], [1, 6], [6, 7], [7, 8], [8, 9], [9, 10]]\n    time = 3\n    change = 10\n    assert solution.secondMinimum(n, edges, time, change) == 37", "def test_secondMinimum():\n    solution = Solution()\n    n = 6\n    edges = [[1, 2], [2, 3], [3, 6], [1, 4], [4, 5], [5, 6], [2, 5], [3, 4]]\n    time = 4\n    change = 3\n    assert solution.secondMinimum(n, edges, time, change) == 18", "def test_secondMinimum():\n    solution = Solution()\n    n = 8\n    edges = [[1, 2], [2, 3], [3, 4], [4, 8], [1, 5], [5, 6], [6, 7], [7, 8], [2, 6], [3, 7]]\n    time = 5\n    change = 9\n    assert solution.secondMinimum(n, edges, time, change) == 43"]}
{"task_num": 2059, "task_title": "Minimum Operations to Convert Number", "func_name": "minimumOperations", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\n    ans = 0\n    q = collections.deque([start])\n    seen = {start}\n\n    while q:\n      ans += 1\n      for _ in range(len(q)):\n        x = q.popleft()\n        for num in nums:\n          for res in (x + num, x - num, x ^ num):\n            if res == goal:\n              return ans\n            if res < 0 or res > 1000 or res in seen:\n              continue\n            seen.add(res)\n            q.append(res)\n\n    return -1\n", "tests": ["def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations([1, 3], 6, 4) == 2", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations([2, 4, 12], 2, 12) == 2", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations([5, 10, 15], 0, 100) == -1", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations([20, 30, 40], 50, 110) == 2", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations([7, 14], 1000, 0) == -1", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations([1, 4, 5], 3, 8) == 1", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations([9, 17, 25], 500, 499) == 1", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations([3, 6, 9], 7, 1) == 2", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations([10, 22, 33], 21, 0) == 3", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations([7, 11, 13], 5, 19) == -1", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations([1, 2, 3], 0, 6) == 2", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations([8, 16], 4, 32) == 3", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations([2, 5, 8], 100, 102) == 1", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations([13, 7, 25], 50, 87) == 3", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations([15, 45], 30, 90) == 2", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations([1, 6, 7], 100, 104) == 2", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations([4, 10, 15], 3, 7) == 1", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations([5, 20, 25], 0, 50) == 2", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations([2, 8, 12], 6, 26) == 3", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations([3, 9, 18], 5, 14) == 2"]}
{"task_num": 2076, "task_title": "Process Restricted Friend Requests", "func_name": "friendRequests", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\n    ans = []\n    uf = UnionFind(n)\n\n    for u, v in requests:\n      pu = uf.find(u)\n      pv = uf.find(v)\n      isValid = True\n      if pu != pv:\n        for x, y in restrictions:\n          px = uf.find(x)\n          py = uf.find(y)\n          if (pu, pv) in [(px, py), (py, px)]:\n            isValid = False\n            break\n      ans.append(isValid)\n      if isValid:\n        uf.unionByRank(pu, pv)\n\n    return ans\n", "tests": ["def test_friendRequests():\n    solution = Solution()\n    n = 5\n    restrictions = [[0, 1], [2, 3]]\n    requests = [[0, 2], [2, 4], [1, 3], [0, 4]]\n    expected_output = [True, True, False, True]\n    assert solution.friendRequests(n, restrictions, requests) == expected_output", "def test_friendRequests():\n    solution = Solution()\n    n = 4\n    restrictions = [[0, 3], [1, 2]]\n    requests = [[0, 1], [1, 3], [2, 0], [2, 3]]\n    expected_output = [True, False, True, False]\n    assert solution.friendRequests(n, restrictions, requests) == expected_output", "def test_friendRequests():\n    solution = Solution()\n    n = 6\n    restrictions = [[0, 5], [1, 4], [3, 2]]\n    requests = [[0, 2], [1, 3], [4, 5], [3, 5], [0, 4]]\n    expected_output = [True, True, True, False, False]\n    assert solution.friendRequests(n, restrictions, requests) == expected_output", "def test_friendRequests():\n    solution = Solution()\n    n = 7\n    restrictions = [[1, 3], [4, 6], [0, 5]]\n    requests = [[0, 1], [2, 3], [5, 6], [1, 4], [3, 5], [4, 2]]\n    expected_output = [True, True, True, False, False, True]\n    assert solution.friendRequests(n, restrictions, requests) == expected_output", "def test_friendRequests():\n    solution = Solution()\n    n = 3\n    restrictions = [[0, 2]]\n    requests = [[0, 1], [1, 2], [0, 2]]\n    expected_output = [True, True, False]\n    assert solution.friendRequests(n, restrictions, requests) == expected_output", "def test_friendRequests():\n    solution = Solution()\n    n = 8\n    restrictions = [[1, 2], [3, 4], [5, 6], [0, 7]]\n    requests = [[0, 1], [2, 3], [4, 5], [6, 7], [1, 6], [3, 0]]\n    expected_output = [True, True, True, False, True, False]\n    assert solution.friendRequests(n, restrictions, requests) == expected_output", "def test_friendRequests():\n    solution = Solution()\n    n = 9\n    restrictions = [[2, 8], [1, 7], [3, 6], [4, 5]]\n    requests = [[0, 2], [8, 7], [1, 3], [6, 4], [5, 0], [7, 3], [2, 4]]\n    expected_output = [True, True, True, True, False, False, False]\n    assert solution.friendRequests(n, restrictions, requests) == expected_output", "def test_friendRequests():\n    solution = Solution()\n    n = 10\n    restrictions = [[1, 9], [2, 8], [3, 7], [4, 6], [5, 0]]\n    requests = [[0, 1], [9, 8], [2, 3], [7, 4], [5, 6], [6, 3], [0, 9], [1, 5]]\n    expected_output = [True, True, True, True, True, True, False, True]\n    assert solution.friendRequests(n, restrictions, requests) == expected_output", "def test_friendRequests():\n    solution = Solution()\n    n = 6\n    restrictions = [[0, 4], [1, 5]]\n    requests = [[0, 1], [2, 3], [4, 5], [0, 2], [1, 4], [5, 3]]\n    expected_output = [True, True, True, True, False, True]\n    assert solution.friendRequests(n, restrictions, requests) == expected_output", "def test_friendRequests():\n    solution = Solution()\n    n = 5\n    restrictions = [[0, 3], [2, 4]]\n    requests = [[0, 2], [1, 3], [1, 4], [3, 4], [2, 3]]\n    expected_output = [True, True, True, False, False]\n    assert solution.friendRequests(n, restrictions, requests) == expected_output", "def test_friendRequests():\n    solution = Solution()\n    n = 7\n    restrictions = [[2, 6], [0, 5]]\n    requests = [[0, 1], [1, 2], [3, 4], [5, 6], [2, 4], [0, 3], [2, 5]]\n    expected_output = [True, True, True, True, True, True, False]\n    assert solution.friendRequests(n, restrictions, requests) == expected_output", "def test_friendRequests():\n    solution = Solution()\n    n = 4\n    restrictions = [[0, 2], [1, 3]]\n    requests = [[0, 1], [1, 2], [2, 3], [0, 3], [1, 0]]\n    expected_output = [True, True, True, False, True]\n    assert solution.friendRequests(n, restrictions, requests) == expected_output", "def test_friendRequests():\n    solution = Solution()\n    n = 8\n    restrictions = [[3, 7], [2, 6], [1, 5]]\n    requests = [[0, 1], [2, 3], [4, 5], [6, 7], [0, 2], [1, 6], [7, 3], [5, 4]]\n    expected_output = [True, True, True, False, True, False, False, True]\n    assert solution.friendRequests(n, restrictions, requests) == expected_output", "def test_friendRequests():\n    solution = Solution()\n    n = 6\n    restrictions = [[0, 1], [2, 5], [3, 4]]\n    requests = [[0, 2], [1, 3], [2, 4], [5, 0], [3, 5], [1, 4]]\n    expected_output = [True, True, True, True, False, True]\n    assert solution.friendRequests(n, restrictions, requests) == expected_output", "def test_friendRequests():\n    solution = Solution()\n    n = 9\n    restrictions = [[1, 8], [4, 5], [2, 7]]\n    requests = [[0, 1], [2, 3], [3, 4], [5, 6], [7, 8], [2, 5], [0, 7], [1, 4]]\n    expected_output = [True, True, True, True, True, True, False, True]\n    assert solution.friendRequests(n, restrictions, requests) == expected_output", "def test_friendRequests():\n    solution = Solution()\n    n = 10\n    restrictions = [[0, 9], [3, 6], [2, 5], [1, 8]]\n    requests = [[0, 2], [1, 3], [4, 5], [6, 7], [8, 9], [1, 4], [3, 5], [7, 0]]\n    expected_output = [True, True, True, True, True, True, False, False]\n    assert solution.friendRequests(n, restrictions, requests) == expected_output", "def test_friendRequests():\n    solution = Solution()\n    n = 5\n    restrictions = [[1, 2], [3, 4]]\n    requests = [[0, 1], [2, 3], [1, 3], [4, 0], [2, 4]]\n    expected_output = [True, True, True, True, False]\n    assert solution.friendRequests(n, restrictions, requests) == expected_output", "def test_friendRequests():\n    solution = Solution()\n    n = 7\n    restrictions = [[1, 6], [2, 5], [0, 4]]\n    requests = [[0, 1], [2, 3], [4, 5], [6, 0], [3, 1], [5, 6], [0, 3]]\n    expected_output = [True, True, True, False, True, True, True]\n    assert solution.friendRequests(n, restrictions, requests) == expected_output", "def test_friendRequests():\n    solution = Solution()\n    n = 8\n    restrictions = [[0, 7], [2, 6], [1, 5], [3, 4]]\n    requests = [[0, 2], [1, 3], [4, 6], [7, 5], [2, 4], [0, 6], [1, 7]]\n    expected_output = [True, True, True, False, True, False, True]\n    assert solution.friendRequests(n, restrictions, requests) == expected_output", "def test_friendRequests():\n    solution = Solution()\n    n = 6\n    restrictions = [[0, 5], [1, 4], [2, 3]]\n    requests = [[0, 1], [2, 5], [3, 4], [1, 3], [5, 0], [4, 2], [2, 0]]\n    expected_output = [True, True, True, True, False, True, False]\n    assert solution.friendRequests(n, restrictions, requests) == expected_output"]}
{"task_num": 2086, "task_title": "Minimum Number of Food Buckets to Feed the Hamsters", "func_name": "minimumBuckets", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumBuckets(self, street: str) -> int:\n    A = list(street)\n\n    for i, c in enumerate(A):\n      if c == 'H':\n        if i > 0 and A[i - 1] == 'B':\n          continue\n        if i + 1 < len(A) and A[i + 1] == '.':\n          A[i + 1] = 'B'\n        elif i > 0 and A[i - 1] == '.':\n          A[i - 1] = 'B'\n        else:\n          return -1\n\n    return A.count('B')\n", "tests": ["def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('H..H') == 2", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('HHH') == -1", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('H.H.H') == 2", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('...') == 0", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('.H.') == 1", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('H') == -1", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('H.H') == 1", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('..H..H..') == 2", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('H.H.H.H') == 2", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('H..H.H..H') == 3", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('.') == 0", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('H..H..') == 2", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('HH.HH') == -1", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('H...H') == 2", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('...H...H...') == 2", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('.H..H.H.') == 3", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('H..H..H.H') == 3", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('H.H..') == 1", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('...HHH...') == -1", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('H..H..H..') == 3"]}
{"task_num": 2092, "task_title": "Find All People With Secret", "func_name": "findAllPeople", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def connected(self, u: int, v: int) -> bool:\n    return self._find(self.id[u]) == self._find(self.id[v])\n\n  def reset(self, u: int) -> None:\n    self.id[u] = u\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\n    uf = UnionFind(n)\n    timeToPairs = collections.defaultdict(list)\n\n    uf.unionByRank(0, firstPerson)\n\n    for x, y, time in meetings:\n      timeToPairs[time].append((x, y))\n\n    for _, pairs in sorted(timeToPairs.items(), key=lambda x: x[0]):\n      peopleUnioned = set()\n      for x, y in pairs:\n        uf.unionByRank(x, y)\n        peopleUnioned.add(x)\n        peopleUnioned.add(y)\n      for person in peopleUnioned:\n        if not uf.connected(person, 0):\n          uf.reset(person)\n\n    res=[]\n    for i in range(n):\n      if uf.connected(i, 0):\n        res.append(i)\n    return res\n", "tests": ["def test_findAllPeople():\n    solution = Solution()\n    assert solution.findAllPeople(6, [[1, 2, 5], [2, 3, 8], [1, 5, 10], [3, 4, 15]], 1) == [0, 1, 2, 3, 5]", "def test_findAllPeople():\n    solution = Solution()\n    assert solution.findAllPeople(4, [[1, 2, 1], [2, 3, 2], [0, 1, 3]], 2) == [0, 1, 2, 3]", "def test_findAllPeople():\n    solution = Solution()\n    assert solution.findAllPeople(5, [[0, 2, 1], [1, 2, 1], [3, 4, 2]], 1) == [0, 1, 2]", "def test_findAllPeople():\n    solution = Solution()\n    assert solution.findAllPeople(7, [[1, 3, 2], [3, 4, 2], [2, 3, 4], [4, 5, 5], [0, 6, 6]], 3) == [0, 3, 4, 5]", "def test_findAllPeople():\n    solution = Solution()\n    assert solution.findAllPeople(3, [[0, 1, 1], [1, 2, 2]], 2) == [0, 1]", "def test_findAllPeople():\n    solution = Solution()\n    assert solution.findAllPeople(8, [[0, 2, 1], [2, 3, 2], [4, 5, 3], [3, 6, 4], [6, 7, 5]], 2) == [0, 2, 3, 6, 7]", "def test_findAllPeople():\n    solution = Solution()\n    assert solution.findAllPeople(6, [[1, 2, 1], [2, 5, 2], [0, 3, 3], [3, 4, 4], [4, 5, 5]], 4) == [0, 3, 4, 5]", "def test_findAllPeople():\n    solution = Solution()\n    assert solution.findAllPeople(9, [[0, 1, 1], [2, 3, 2], [1, 4, 3], [4, 5, 4], [5, 6, 5], [7, 8, 6]], 4) == [0, 1, 4, 5, 6]", "def test_findAllPeople():\n    solution = Solution()\n    assert solution.findAllPeople(10, [[1, 2, 1], [2, 3, 2], [3, 4, 3], [4, 5, 4], [6, 7, 5], [0, 8, 6], [8, 9, 7]], 9) == [0, 8, 9]", "def test_findAllPeople():\n    solution = Solution()\n    assert solution.findAllPeople(7, [[1, 3, 2], [2, 3, 2], [4, 5, 3], [5, 6, 4], [3, 4, 5]], 6) == [0, 6]", "def test_findAllPeople():\n    solution = Solution()\n    assert solution.findAllPeople(8, [[0, 2, 1], [2, 4, 2], [4, 5, 3], [1, 6, 4], [6, 7, 5]], 2) == [0, 2, 4, 5]", "def test_findAllPeople():\n    solution = Solution()\n    assert solution.findAllPeople(5, [[0, 1, 1], [1, 2, 2], [1, 3, 3], [3, 4, 4]], 3) == [0, 1, 3, 4]", "def test_findAllPeople():\n    solution = Solution()\n    assert solution.findAllPeople(6, [[0, 1, 1], [0, 2, 1], [1, 3, 2], [2, 4, 3], [3, 5, 4]], 5) == [0, 1, 2, 3, 5]", "def test_findAllPeople():\n    solution = Solution()\n    assert solution.findAllPeople(7, [[0, 2, 1], [1, 3, 2], [2, 4, 3], [4, 5, 4], [5, 6, 5]], 1) == [0, 1, 2, 3]", "def test_findAllPeople():\n    solution = Solution()\n    assert solution.findAllPeople(4, [[0, 1, 1], [1, 2, 2], [2, 3, 3], [0, 3, 4]], 2) == [0, 1, 2, 3]", "def test_findAllPeople():\n    solution = Solution()\n    assert solution.findAllPeople(6, [[0, 1, 1], [2, 3, 2], [3, 4, 3], [4, 5, 4]], 3) == [0, 3, 4, 5]", "def test_findAllPeople():\n    solution = Solution()\n    assert solution.findAllPeople(7, [[0, 1, 1], [1, 2, 2], [2, 3, 3], [4, 5, 4], [5, 6, 5]], 4) == [0, 1, 2, 3, 4, 5, 6]", "def test_findAllPeople():\n    solution = Solution()\n    assert solution.findAllPeople(5, [[0, 2, 1], [2, 3, 2], [3, 4, 3], [1, 4, 4]], 3) == [0, 2, 3, 4]", "def test_findAllPeople():\n    solution = Solution()\n    assert solution.findAllPeople(10, [[0, 1, 1], [2, 3, 2], [3, 4, 3], [4, 5, 4], [6, 7, 5], [8, 9, 6]], 5) == [0, 5]", "def test_findAllPeople():\n    solution = Solution()\n    assert solution.findAllPeople(5, [[1, 2, 1], [0, 3, 2], [3, 4, 3], [2, 4, 4]], 2) == [0, 2, 3, 4]"]}
{"task_num": 2115, "task_title": "Find All Possible Recipes from Given Supplies", "func_name": "findAllRecipes", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n    ans = []\n    supplies = set(supplies)\n    graph = collections.defaultdict(list)\n    inDegrees = collections.Counter()\n    q = collections.deque()\n\n    for i, recipe in enumerate(recipes):\n      for ingredient in ingredients[i]:\n        if ingredient not in supplies:\n          graph[ingredient].append(recipe)\n          inDegrees[recipe] += 1\n\n    for recipe in recipes:\n      if inDegrees[recipe] == 0:\n        q.append(recipe)\n\n    while q:\n      u = q.popleft()\n      ans.append(u)\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    return ans\n", "tests": ["def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['bread', 'sandwich']\n    ingredients = [['yeast', 'flour'], ['bread', 'ham']]\n    supplies = ['yeast', 'flour', 'ham']\n    assert set(solution.findAllRecipes(recipes, ingredients, supplies)) == {'bread', 'sandwich'}", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['cake', 'pie', 'fruit_salad']\n    ingredients = [['sugar', 'flour', 'egg'], ['sugar', 'fruit_salad'], ['fruit', 'cream']]\n    supplies = ['sugar', 'flour', 'egg', 'fruit', 'cream']\n    assert set(solution.findAllRecipes(recipes, ingredients, supplies)) == {'cake', 'fruit_salad', 'pie'}", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['pasta', 'sauce', 'lasagna']\n    ingredients = [['flour', 'water'], ['tomato', 'basil'], ['pasta', 'sauce', 'cheese']]\n    supplies = ['flour', 'water', 'tomato', 'basil', 'cheese']\n    assert set(solution.findAllRecipes(recipes, ingredients, supplies)) == {'pasta', 'sauce', 'lasagna'}", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['soup', 'broth', 'salad']\n    ingredients = [['broth', 'vegetables'], ['water', 'meat'], ['lettuce', 'tomato']]\n    supplies = ['water', 'meat', 'lettuce', 'tomato', 'vegetables']\n    assert set(solution.findAllRecipes(recipes, ingredients, supplies)) == {'broth', 'soup', 'salad'}", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['smoothie', 'juice']\n    ingredients = [['banana', 'milk'], ['orange', 'smoothie']]\n    supplies = ['banana', 'milk', 'orange']\n    assert set(solution.findAllRecipes(recipes, ingredients, supplies)) == {'smoothie', 'juice'}", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['pancake', 'syrup']\n    ingredients = [['flour', 'egg'], ['sugar', 'water']]\n    supplies = ['flour', 'egg', 'sugar', 'water']\n    assert set(solution.findAllRecipes(recipes, ingredients, supplies)) == {'pancake', 'syrup'}", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['burger', 'bun', 'patty']\n    ingredients = [['bun', 'patty', 'lettuce'], ['flour', 'water'], ['meat', 'spices']]\n    supplies = ['flour', 'water', 'meat', 'spices', 'lettuce']\n    assert set(solution.findAllRecipes(recipes, ingredients, supplies)) == {'bun', 'patty', 'burger'}", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['taco', 'tortilla', 'filling']\n    ingredients = [['tortilla', 'filling'], ['corn', 'water'], ['beans', 'salsa']]\n    supplies = ['corn', 'water', 'beans', 'salsa']\n    assert set(solution.findAllRecipes(recipes, ingredients, supplies)) == {'tortilla', 'filling', 'taco'}", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['omelette', 'cheese_omelette']\n    ingredients = [['egg', 'milk'], ['omelette', 'cheese']]\n    supplies = ['egg', 'milk', 'cheese']\n    assert set(solution.findAllRecipes(recipes, ingredients, supplies)) == {'omelette', 'cheese_omelette'}", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['stew', 'broth', 'dumplings']\n    ingredients = [['broth', 'meat', 'vegetables'], ['water', 'spices'], ['flour', 'water', 'stew']]\n    supplies = ['water', 'spices', 'meat', 'vegetables', 'flour']\n    assert set(solution.findAllRecipes(recipes, ingredients, supplies)) == {'broth', 'stew', 'dumplings'}", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['pie', 'crust', 'filling']\n    ingredients = [['crust', 'filling'], ['flour', 'butter'], ['fruit', 'sugar']]\n    supplies = ['flour', 'butter', 'fruit', 'sugar']\n    assert set(solution.findAllRecipes(recipes, ingredients, supplies)) == {'crust', 'filling', 'pie'}", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['pizza', 'dough', 'topping']\n    ingredients = [['dough', 'topping', 'cheese'], ['flour', 'yeast'], ['tomato', 'pepperoni']]\n    supplies = ['flour', 'yeast', 'tomato', 'pepperoni', 'cheese']\n    assert set(solution.findAllRecipes(recipes, ingredients, supplies)) == {'dough', 'topping', 'pizza'}", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['salsa', 'dip', 'nachos']\n    ingredients = [['tomato', 'onion', 'cilantro'], ['salsa', 'avocado'], ['chips', 'dip']]\n    supplies = ['tomato', 'onion', 'cilantro', 'avocado', 'chips']\n    assert set(solution.findAllRecipes(recipes, ingredients, supplies)) == {'salsa', 'dip', 'nachos'}", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['curry', 'rice', 'spice_mix']\n    ingredients = [['spice_mix', 'meat', 'vegetables'], ['spice_mix', 'water'], ['cumin', 'turmeric']]\n    supplies = ['meat', 'vegetables', 'water', 'cumin', 'turmeric']\n    assert set(solution.findAllRecipes(recipes, ingredients, supplies)) == {'spice_mix', 'curry', 'rice'}", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['pasta', 'sauce', 'lasagna']\n    ingredients = [['flour', 'egg'], ['tomato', 'basil'], ['pasta', 'sauce', 'cheese']]\n    supplies = ['flour', 'egg', 'cheese', 'tomato', 'basil']\n    assert set(solution.findAllRecipes(recipes, ingredients, supplies)) == {'pasta', 'sauce', 'lasagna'}", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['bread', 'butter', 'sandwich']\n    ingredients = [['flour', 'yeast'], ['milk', 'cream'], ['bread', 'butter', 'lettuce']]\n    supplies = ['flour', 'yeast', 'milk', 'cream', 'lettuce']\n    assert set(solution.findAllRecipes(recipes, ingredients, supplies)) == {'bread', 'butter', 'sandwich'}", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['dumplings', 'broth', 'soup']\n    ingredients = [['flour', 'water', 'filling'], ['water', 'spices', 'meat'], ['broth', 'vegetables', 'dumplings']]\n    supplies = ['flour', 'water', 'filling', 'spices', 'meat', 'vegetables']\n    assert set(solution.findAllRecipes(recipes, ingredients, supplies)) == {'dumplings', 'broth', 'soup'}", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['salad', 'vinaigrette', 'garnish']\n    ingredients = [['lettuce', 'vinaigrette', 'garnish'], ['oil', 'vinegar'], ['nuts', 'seeds']]\n    supplies = ['lettuce', 'oil', 'vinegar', 'nuts', 'seeds']\n    assert set(solution.findAllRecipes(recipes, ingredients, supplies)) == {'vinaigrette', 'garnish', 'salad'}", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['cake', 'frosting', 'layered_cake']\n    ingredients = [['flour', 'sugar', 'egg'], ['sugar', 'butter'], ['cake', 'frosting']]\n    supplies = ['flour', 'sugar', 'egg', 'butter']\n    assert set(solution.findAllRecipes(recipes, ingredients, supplies)) == {'cake', 'frosting', 'layered_cake'}", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['quiche', 'crust', 'filling']\n    ingredients = [['crust', 'filling', 'cheese'], ['flour', 'butter'], ['egg', 'cream', 'spinach']]\n    supplies = ['flour', 'butter', 'egg', 'cream', 'spinach', 'cheese']\n    assert set(solution.findAllRecipes(recipes, ingredients, supplies)) == {'crust', 'filling', 'quiche'}"]}
{"task_num": 2127, "task_title": "Maximum Employees to Be Invited to a Meeting", "func_name": "maximumInvitations", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import Enum\n\n\nclass State(Enum):\n  kInit = 0\n  kVisiting = 1\n  kVisited = 2\n\n\nclass Solution:\n  def maximumInvitations(self, favorite: List[int]) -> int:\n    n = len(favorite)\n    sumComponentsLength = 0\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n    maxChainLength = [1] * n\n\n    for i, f in enumerate(favorite):\n      graph[i].append(f)\n      inDegrees[f] += 1\n\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n\n    while q:\n      u = q.popleft()\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n        maxChainLength[v] = max(maxChainLength[v], 1 + maxChainLength[u])\n\n    for i in range(n):\n      if favorite[favorite[i]] == i:\n        sumComponentsLength += maxChainLength[i] + maxChainLength[favorite[i]]\n\n    maxCycleLength = 0\n    parent = [-1] * n\n    seen = set()\n    states = [State.kInit] * n\n\n    def findCycle(u: int) -> None:\n      nonlocal maxCycleLength\n      seen.add(u)\n      states[u] = State.kVisiting\n      for v in graph[u]:\n        if v not in seen:\n          parent[v] = u\n          findCycle(v)\n        elif states[v] == State.kVisiting:\n          curr = u\n          cycleLength = 1\n          while curr != v:\n            curr = parent[curr]\n            cycleLength += 1\n          maxCycleLength = max(maxCycleLength, cycleLength)\n      states[u] = State.kVisited\n\n    for i in range(n):\n      if i not in seen:\n        findCycle(i)\n\n    return max(sumComponentsLength // 2, maxCycleLength)\n", "tests": ["def test_maximumInvitations():\n    solution = Solution()\n    assert solution.maximumInvitations([2, 2, 1, 2]) == 3", "def test_maximumInvitations():\n    solution = Solution()\n    assert solution.maximumInvitations([1, 0, 3, 2, 5, 4]) == 6", "def test_maximumInvitations():\n    solution = Solution()\n    assert solution.maximumInvitations([1, 2, 0, 4, 5, 3]) == 4", "def test_maximumInvitations():\n    solution = Solution()\n    assert solution.maximumInvitations([3, 3, 3, 3, 5, 4]) == 4", "def test_maximumInvitations():\n    solution = Solution()\n    assert solution.maximumInvitations([1, 2, 3, 4, 0]) == 5", "def test_maximumInvitations():\n    solution = Solution()\n    assert solution.maximumInvitations([1, 0, 3, 4, 2, 5]) == 4", "def test_maximumInvitations():\n    solution = Solution()\n    assert solution.maximumInvitations([1, 0, 2, 4, 3, 6, 5]) == 6", "def test_maximumInvitations():\n    solution = Solution()\n    assert solution.maximumInvitations([2, 0, 1, 5, 4, 3]) == 3", "def test_maximumInvitations():\n    solution = Solution()\n    assert solution.maximumInvitations([0, 3, 1, 2, 5, 4]) == 4", "def test_maximumInvitations():\n    solution = Solution()\n    assert solution.maximumInvitations([4, 5, 6, 0, 1, 2, 3]) == 4", "def test_maximumInvitations():\n    solution = Solution()\n    assert solution.maximumInvitations([1, 2, 3, 0, 5, 6, 4]) == 5", "def test_maximumInvitations():\n    solution = Solution()\n    assert solution.maximumInvitations([2, 1, 0, 4, 3, 6, 5]) == 5", "def test_maximumInvitations():\n    solution = Solution()\n    assert solution.maximumInvitations([1, 0, 2, 6, 5, 3, 4]) == 6", "def test_maximumInvitations():\n    solution = Solution()\n    assert solution.maximumInvitations([5, 5, 5, 5, 5, 0]) == 2", "def test_maximumInvitations():\n    solution = Solution()\n    assert solution.maximumInvitations([2, 2, 3, 0, 1, 4, 5, 6]) == 3", "def test_maximumInvitations():\n    solution = Solution()\n    assert solution.maximumInvitations([1, 0, 3, 2, 6, 5, 4]) == 6", "def test_maximumInvitations():\n    solution = Solution()\n    assert solution.maximumInvitations([1, 2, 0, 4, 5, 3, 7, 6]) == 8", "def test_maximumInvitations():\n    solution = Solution()\n    assert solution.maximumInvitations([6, 5, 4, 3, 2, 1, 0]) == 7", "def test_maximumInvitations():\n    solution = Solution()\n    assert solution.maximumInvitations([3, 0, 1, 2, 8, 7, 6, 5, 4]) == 5", "def test_maximumInvitations():\n    solution = Solution()\n    assert solution.maximumInvitations([5, 4, 3, 2, 1, 0, 7, 6]) == 6"]}
{"task_num": 2132, "task_title": "Stamping the Grid", "func_name": "possibleToStamp", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def possibleToStamp(self, grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:\n    m = len(grid)\n    n = len(grid[0])\n    A = [[0] * (n + 1) for _ in range(m + 1)]\n    B = [[0] * (n + 1) for _ in range(m + 1)]\n    fit = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        A[i + 1][j + 1] = A[i + 1][j] + A[i][j + 1] - A[i][j] + grid[i][j]\n        if i + 1 >= stampHeight and j + 1 >= stampWidth:\n          x = i - stampHeight + 1\n          y = j - stampWidth + 1\n          if A[i + 1][j + 1] - A[x][j + 1] - A[i + 1][y] + A[x][y] == 0:\n            fit[i][j] = True\n\n    for i in range(m):\n      for j in range(n):\n        B[i + 1][j + 1] = B[i + 1][j] + B[i][j + 1] - B[i][j] + fit[i][j]\n\n    for i in range(m):\n      for j in range(n):\n        if not grid[i][j]:\n          x = min(i + stampHeight, m)\n          y = min(j + stampWidth, n)\n          if B[x][y] - B[i][y] - B[x][j] + B[i][j] == 0:\n            return False\n\n    return True\n", "tests": ["def test_possibleToStamp():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n    stampHeight = 2\n    stampWidth = 2\n    assert solution.possibleToStamp(grid, stampHeight, stampWidth) == True", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[1, 0, 1], [0, 0, 0], [1, 0, 1]]\n    stampHeight = 1\n    stampWidth = 1\n    assert solution.possibleToStamp(grid, stampHeight, stampWidth) == True", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[0, 0, 0, 1], [0, 1, 0, 0], [0, 0, 0, 0], [1, 0, 0, 0]]\n    stampHeight = 3\n    stampWidth = 2\n    assert solution.possibleToStamp(grid, stampHeight, stampWidth) == False", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]\n    stampHeight = 1\n    stampWidth = 1\n    assert solution.possibleToStamp(grid, stampHeight, stampWidth) == False", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[0, 0], [0, 0]]\n    stampHeight = 2\n    stampWidth = 2\n    assert solution.possibleToStamp(grid, stampHeight, stampWidth) == True", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[0, 0, 1], [0, 1, 0], [1, 0, 0]]\n    stampHeight = 2\n    stampWidth = 1\n    assert solution.possibleToStamp(grid, stampHeight, stampWidth) == True", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]\n    stampHeight = 3\n    stampWidth = 3\n    assert solution.possibleToStamp(grid, stampHeight, stampWidth) == True", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[0, 1], [1, 0]]\n    stampHeight = 1\n    stampWidth = 1\n    assert solution.possibleToStamp(grid, stampHeight, stampWidth) == True", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[0, 0], [1, 1]]\n    stampHeight = 2\n    stampWidth = 1\n    assert solution.possibleToStamp(grid, stampHeight, stampWidth) == True", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[0, 0, 1, 0], [0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 0]]\n    stampHeight = 2\n    stampWidth = 2\n    assert solution.possibleToStamp(grid, stampHeight, stampWidth) == True", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[1, 1, 1, 1], [1, 0, 0, 1], [1, 0, 0, 1], [1, 1, 1, 1]]\n    stampHeight = 1\n    stampWidth = 2\n    assert solution.possibleToStamp(grid, stampHeight, stampWidth) == True", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[0, 1, 0], [1, 0, 1], [0, 1, 0]]\n    stampHeight = 2\n    stampWidth = 2\n    assert solution.possibleToStamp(grid, stampHeight, stampWidth) == False", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[0, 0, 0, 1], [0, 1, 0, 0], [0, 0, 1, 0], [1, 0, 0, 0]]\n    stampHeight = 2\n    stampWidth = 3\n    assert solution.possibleToStamp(grid, stampHeight, stampWidth) == False", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[1, 1, 0, 0], [1, 0, 0, 1], [0, 0, 1, 1], [0, 1, 1, 0]]\n    stampHeight = 1\n    stampWidth = 1\n    assert solution.possibleToStamp(grid, stampHeight, stampWidth) == True", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[1, 0, 1, 0, 1], [0, 0, 0, 0, 0], [1, 0, 1, 0, 1]]\n    stampHeight = 2\n    stampWidth = 2\n    assert solution.possibleToStamp(grid, stampHeight, stampWidth) == True", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[0, 0, 1], [0, 1, 0], [1, 0, 0], [0, 0, 0]]\n    stampHeight = 3\n    stampWidth = 1\n    assert solution.possibleToStamp(grid, stampHeight, stampWidth) == False", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[1, 0, 0, 1], [0, 0, 1, 0], [0, 1, 0, 0], [1, 0, 0, 1]]\n    stampHeight = 2\n    stampWidth = 2\n    assert solution.possibleToStamp(grid, stampHeight, stampWidth) == False", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 0, 0], [0, 0, 1]]\n    stampHeight = 3\n    stampWidth = 3\n    assert solution.possibleToStamp(grid, stampHeight, stampWidth) == False", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[0, 1, 0], [1, 0, 1], [0, 0, 0], [1, 1, 0]]\n    stampHeight = 2\n    stampWidth = 2\n    assert solution.possibleToStamp(grid, stampHeight, stampWidth) == False", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[0, 0, 1, 0], [0, 0, 0, 1], [1, 0, 0, 0], [0, 1, 0, 0]]\n    stampHeight = 3\n    stampWidth = 2\n    assert solution.possibleToStamp(grid, stampHeight, stampWidth) == True"]}
{"task_num": 2146, "task_title": "K Highest Ranked Items Within a Price Range", "func_name": "highestRankedKItems", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    low, high = pricing\n    row, col = start\n    ans = []\n\n    if low <= grid[row][col] <= high:\n      ans.append([row, col])\n      if k == 1:\n        return ans\n\n    q = collections.deque([(row, col)])\n    seen = {(row, col)}\n\n    while q:\n      neighbors = []\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for t in range(4):\n          x = i + dirs[t][0]\n          y = j + dirs[t][1]\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if not grid[x][y] or (x, y) in seen:\n            continue\n          if low <= grid[x][y] <= high:\n            neighbors.append([x, y])\n          q.append((x, y))\n          seen.add((x, y))\n      neighbors.sort(key=lambda x: (grid[x[0]][x[1]], x[0], x[1]))\n      for neighbor in neighbors:\n        if len(ans) < k:\n          ans.append(neighbor)\n        if len(ans) == k:\n          return ans\n\n    return ans\n", "tests": ["def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[1, 2, 0, 1], [3, 4, 5, 1], [1, 1, 1, 1]]\n    pricing = [2, 5]\n    start = [0, 0]\n    k = 3\n    assert solution.highestRankedKItems(grid, pricing, start, k) == [[0, 1], [1, 1], [1, 0]]", "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[1, 0, 2], [0, 3, 4], [5, 6, 0]]\n    pricing = [3, 6]\n    start = [2, 0]\n    k = 2\n    assert solution.highestRankedKItems(grid, pricing, start, k) == [[1, 1], [1, 2]]", "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[0, 1, 3], [0, 4, 2], [5, 1, 0]]\n    pricing = [1, 5]\n    start = [0, 2]\n    k = 5\n    assert solution.highestRankedKItems(grid, pricing, start, k) == [[0, 1], [1, 2], [1, 1], [2, 1], [2, 0]]", "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[2, 0, 3], [0, 0, 0], [1, 5, 4]]\n    pricing = [6, 10]\n    start = [2, 2]\n    k = 3\n    assert solution.highestRankedKItems(grid, pricing, start, k) == []", "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[4, 0, 5], [1, 0, 6], [2, 3, 0]]\n    pricing = [2, 4]\n    start = [0, 0]\n    k = 2\n    assert solution.highestRankedKItems(grid, pricing, start, k) == [[1, 0], [2, 1]]", "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[10, 10, 10], [10, 0, 10], [10, 10, 10]]\n    pricing = [10, 10]\n    start = [1, 0]\n    k = 10\n    assert solution.highestRankedKItems(grid, pricing, start, k) == [[1, 0], [0, 0], [2, 0], [0, 1], [2, 1], [0, 2], [2, 2], [1, 2]]", "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[7, 6, 5, 4, 3, 2, 1]]\n    pricing = [3, 7]\n    start = [0, 6]\n    k = 4\n    assert solution.highestRankedKItems(grid, pricing, start, k) == [[0, 5], [0, 4], [0, 3], [0, 2]]", "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[2], [8], [6], [5], [3], [1]]\n    pricing = [1, 6]\n    start = [4, 0]\n    k = 3\n    assert solution.highestRankedKItems(grid, pricing, start, k) == [[4, 0], [5, 0], [3, 0]]", "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[9, 0, 1], [3, 5, 7], [2, 8, 4]]\n    pricing = [2, 8]\n    start = [1, 2]\n    k = 3\n    assert solution.highestRankedKItems(grid, pricing, start, k) == [[2, 1], [2, 2], [1, 0]]", "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 9, 0], [0, 0, 0]]\n    pricing = [1, 10]\n    start = [1, 1]\n    k = 1\n    assert solution.highestRankedKItems(grid, pricing, start, k) == [[1, 1]]", "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[1, 0, 2], [0, 0, 0], [3, 0, 4]]\n    pricing = [1, 4]\n    start = [0, 0]\n    k = 2\n    assert solution.highestRankedKItems(grid, pricing, start, k) == []", "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[1, 1, 1], [1, 5, 1], [1, 1, 1]]\n    pricing = [1, 5]\n    start = [1, 1]\n    k = 5\n    assert solution.highestRankedKItems(grid, pricing, start, k) == [[1, 1], [0, 1], [2, 1], [1, 0], [1, 2]]", "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[5]]\n    pricing = [5, 5]\n    start = [0, 0]\n    k = 1\n    assert solution.highestRankedKItems(grid, pricing, start, k) == [[0, 0]]", "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[10, 20, 30], [40, 50, 60], [70, 80, 90]]\n    pricing = [1, 9]\n    start = [0, 0]\n    k = 2\n    assert solution.highestRankedKItems(grid, pricing, start, k) == []", "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[1, 1, 1], [1, 10, 1], [1, 1, 1]]\n    pricing = [10, 10]\n    start = [0, 0]\n    k = 1\n    assert solution.highestRankedKItems(grid, pricing, start, k) == [[1, 1]]", "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[3, 2, 3], [2, 0, 2], [3, 2, 3]]\n    pricing = [2, 3]\n    start = [1, 1]\n    k = 4\n    assert solution.highestRankedKItems(grid, pricing, start, k) == [[0, 1], [1, 0], [1, 2], [2, 1]]", "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 4, 0], [0, 0, 0]]\n    pricing = [3, 5]\n    start = [2, 2]\n    k = 10\n    assert solution.highestRankedKItems(grid, pricing, start, k) == [[1, 1]]", "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[0, 7, 0, 8], [6, 0, 5, 0], [0, 3, 0, 2], [9, 0, 1, 0]]\n    pricing = [2, 7]\n    start = [3, 2]\n    k = 4\n    assert solution.highestRankedKItems(grid, pricing, start, k) == [[3, 2], [2, 3], [2, 1], [1, 2]]", "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[0, 1, 2], [1, 0, 1], [2, 1, 0]]\n    pricing = [1, 2]\n    start = [1, 1]\n    k = 3\n    assert solution.highestRankedKItems(grid, pricing, start, k) == [[0, 1], [1, 0], [1, 2]]", "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[0, 0, 0, 1], [0, 5, 0, 0], [0, 0, 0, 4], [2, 0, 3, 0]]\n    pricing = [1, 5]\n    start = [0, 3]\n    k = 3\n    assert solution.highestRankedKItems(grid, pricing, start, k) == [[0, 3], [1, 1], [3, 0]]"]}
{"task_num": 2157, "task_title": "Groups of Strings", "func_name": "groupStrings", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.sz = [1] * n\n\n  def unionBySize(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.sz[i] < self.sz[j]:\n      self.sz[j] += self.sz[i]\n      self.id[i] = j\n    else:\n      self.sz[i] += self.sz[j]\n      self.id[j] = i\n    self.count -= 1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def groupStrings(self, words: List[str]) -> List[int]:\n    uf = UnionFind(len(words))\n\n    def getMask(s: str) -> int:\n      mask = 0\n      for c in s:\n        mask |= 1 << ord(c) - ord('a')\n      return mask\n\n    def getAddedMasks(mask: int):\n      for i in range(26):\n        if not (mask >> i & 1):\n          yield mask | 1 << i\n\n    def getDeletedMasks(mask: int):\n      for i in range(26):\n        if mask >> i & 1:\n          yield mask ^ 1 << i\n\n    maskToIndex = {getMask(word): i for i, word in enumerate(words)}\n    deletedMaskToIndex = {}\n\n    for i, word in enumerate(words):\n      mask = getMask(word)\n      for m in getAddedMasks(mask):\n        if m in maskToIndex:\n          uf.unionBySize(i, maskToIndex[m])\n      for m in getDeletedMasks(mask):\n        if m in maskToIndex:\n          uf.unionBySize(i, maskToIndex[m])\n        if m in deletedMaskToIndex:\n          uf.unionBySize(i, deletedMaskToIndex[m])\n        else:\n          deletedMaskToIndex[m] = i\n\n    return [uf.count, max(uf.sz)]\n", "tests": ["def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['abc', 'bcd', 'ace', 'xyz']) == [2, 2]", "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['a', 'ab', 'abc', 'abcd', 'b']) == [1, 5]", "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['a', 'b', 'c', 'd', 'e']) == [5, 1]", "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['abc', 'def', 'ghi', 'jkl', 'mnop']) == [5, 1]", "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['abc', 'abd', 'bce', 'cdf', 'efg']) == [1, 5]", "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['xyz', 'yz', 'z', 'abcde', 'bcde']) == [2, 3]", "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['a', 'aa', 'aaa', 'aaaa', 'b', 'bb']) == [2, 4]", "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['abc', 'bcd', 'cde', 'def', 'efg', 'fgh']) == [1, 6]", "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['ab', 'bc', 'cd', 'abf', 'fg']) == [2, 3]", "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['abc', 'acd', 'efg', 'fgh', 'ghi']) == [2, 3]", "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['mno', 'nop', 'opq', 'pqr', 'xyz', 'yz']) == [2, 4]", "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['a', 'abc', 'de', 'def', 'gh', 'ghi']) == [3, 2]", "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['pqr', 'qr', 'rs', 'rst', 'stu', 'tuv']) == [2, 4]", "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['lmn', 'opq', 'xyz', 'yxz', 'abc', 'bca']) == [3, 2]", "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['q', 'qw', 'er', 'ert', 'ty', 't']) == [3, 2]", "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['abc', 'acb', 'bac', 'cab', 'xy', 'yx', 'z']) == [2, 4]", "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['mnop', 'nopq', 'opqr', 'pqr', 'qr', 'r']) == [1, 6]", "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['abcx', 'yz', 'xyz', 'def', 'xyzx', 'bcd']) == [3, 3]", "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['a', 'b', 'ab', 'abc', 'bc', 'c']) == [1, 6]", "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['abc', 'bcd', 'cde', 'abcde', 'def', 'ef']) == [1, 6]"]}
{"task_num": 2182, "task_title": "Construct String With Repeat Limit", "func_name": "repeatLimitedString", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\n    ans = ''\n    count = collections.Counter(s)\n\n    while True:\n      addOne = ans and self._shouldAddOne(ans, count)\n      c = self._getLargestChar(ans, count)\n      if c == ' ':\n        break\n      repeats = 1 if addOne else min(count[c], repeatLimit)\n      ans += c * repeats\n      count[c] -= repeats\n\n    return ans\n\n  def _shouldAddOne(self, ans: str, count: collections.Counter) -> bool:\n    for c in reversed(string.ascii_lowercase):\n      if count[c]:\n        return ans[-1] == c\n    return False\n\n  def _getLargestChar(self, ans: str, count: collections.Counter) -> int:\n    for c in reversed(string.ascii_lowercase):\n      if count[c] and (not ans or ans[-1] != c):\n        return c\n    return ' '\n", "tests": ["def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('cczazcc', 3) == 'zzcccac'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('aabbcc', 1) == 'ccbaba'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('bbbaa', 2) == 'bbaab'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('xyzzyx', 1) == 'zyxzyx'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('ppqqrr', 2) == 'rrppqq'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('abcabcabc', 1) == 'cbaabc'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('eeeeee', 3) == 'eee'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('ddccbb', 2) == 'ddccb'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('aazzbbcc', 2) == 'zzbbcca'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('mmmmnnn', 1) == 'nmnmnm'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('zzzzxyy', 4) == 'zzzzyx'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('gdgdfg', 2) == 'gfgd'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('abcdeedcba', 2) == 'eedcba'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('kkklllmmm', 3) == 'mmmllkkk'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('aaabbbccc', 2) == 'ccbbaa'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('uuuvvvwww', 1) == 'wvuwvuw'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('nnooppqq', 2) == 'qqoopn'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('helloworld', 3) == 'wollrdeh'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('xxyyzz', 2) == 'zzyyxx'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('rrssssttt', 2) == 'ttrrss'"]}
{"task_num": 2203, "task_title": "Minimum Weighted Subgraph With the Required Paths", "func_name": "minimumWeight", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\n    graph = [[] for _ in range(n)]\n    reversedGraph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      reversedGraph[v].append((u, w))\n\n    fromSrc1 = self._dijkstra(graph, src1)\n    fromSrc2 = self._dijkstra(graph, src2)\n    fromDest = self._dijkstra(reversedGraph, dest)\n    minWeight = min(a + b + c for a, b, c in zip(fromSrc1, fromSrc2, fromDest))\n    if minWeight == math.inf:\n      return -1\n    else:\n      return minWeight\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int) -> List[int]:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist\n", "tests": ["def test_minimumWeight():\n    solution = Solution()\n    n = 6\n    edges = [[0, 1, 1], [1, 2, 2], [2, 3, 1], [0, 4, 2], [4, 3, 2], [3, 5, 1]]\n    src1 = 0\n    src2 = 4\n    dest = 5\n    assert solution.minimumWeight(n, edges, src1, src2, dest) == 4", "def test_minimumWeight():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5], [0, 2, 1], [2, 4, 2]]\n    src1 = 0\n    src2 = 3\n    dest = 4\n    assert solution.minimumWeight(n, edges, src1, src2, dest) == 8", "def test_minimumWeight():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 1], [1, 3, 3], [0, 2, 4], [2, 3, 1]]\n    src1 = 0\n    src2 = 1\n    dest = 3\n    assert solution.minimumWeight(n, edges, src1, src2, dest) == 4", "def test_minimumWeight():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 1], [1, 2, 2], [0, 2, 3]]\n    src1 = 0\n    src2 = 1\n    dest = 2\n    assert solution.minimumWeight(n, edges, src1, src2, dest) == 3", "def test_minimumWeight():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 2], [1, 3, 2], [0, 2, 1], [2, 3, 2], [1, 2, 1]]\n    src1 = 0\n    src2 = 2\n    dest = 3\n    assert solution.minimumWeight(n, edges, src1, src2, dest) == 3", "def test_minimumWeight():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 10], [1, 2, 5], [2, 3, 1], [0, 3, 50]]\n    src1 = 0\n    src2 = 1\n    dest = 3\n    assert solution.minimumWeight(n, edges, src1, src2, dest) == 16", "def test_minimumWeight():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 1], [1, 2, 2], [2, 4, 1], [3, 2, 1], [3, 4, 4]]\n    src1 = 0\n    src2 = 3\n    dest = 4\n    assert solution.minimumWeight(n, edges, src1, src2, dest) == 5", "def test_minimumWeight():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 2], [1, 2, 3], [2, 3, 1], [3, 4, 2], [0, 2, 4], [1, 3, 2]]\n    src1 = 0\n    src2 = 2\n    dest = 4\n    assert solution.minimumWeight(n, edges, src1, src2, dest) == 7", "def test_minimumWeight():\n    solution = Solution()\n    n = 6\n    edges = [[0, 1, 1], [1, 2, 2], [2, 5, 1], [0, 3, 3], [3, 4, 2], [4, 5, 1], [1, 4, 1]]\n    src1 = 0\n    src2 = 3\n    dest = 5\n    assert solution.minimumWeight(n, edges, src1, src2, dest) == 5", "def test_minimumWeight():\n    solution = Solution()\n    n = 7\n    edges = [[0, 1, 2], [1, 3, 4], [3, 6, 1], [0, 2, 3], [2, 4, 2], [4, 6, 3], [2, 5, 1], [5, 6, 2]]\n    src1 = 0\n    src2 = 2\n    dest = 6\n    assert solution.minimumWeight(n, edges, src1, src2, dest) == 6", "def test_minimumWeight():\n    solution = Solution()\n    n = 6\n    edges = [[0, 1, 1], [1, 4, 3], [4, 5, 1], [0, 2, 2], [2, 3, 1], [3, 5, 2], [1, 3, 2]]\n    src1 = 0\n    src2 = 1\n    dest = 5\n    assert solution.minimumWeight(n, edges, src1, src2, dest) == 6", "def test_minimumWeight():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 5], [1, 2, 2], [2, 4, 1], [0, 3, 8], [3, 4, 2], [1, 3, 1]]\n    src1 = 0\n    src2 = 3\n    dest = 4\n    assert solution.minimumWeight(n, edges, src1, src2, dest) == 8", "def test_minimumWeight():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 1], [1, 2, 2], [2, 3, 3], [0, 2, 5], [1, 3, 4]]\n    src1 = 0\n    src2 = 2\n    dest = 3\n    assert solution.minimumWeight(n, edges, src1, src2, dest) == 6", "def test_minimumWeight():\n    solution = Solution()\n    n = 6\n    edges = [[0, 1, 2], [1, 3, 3], [3, 5, 1], [0, 2, 4], [2, 4, 2], [4, 5, 1], [2, 3, 1]]\n    src1 = 0\n    src2 = 2\n    dest = 5\n    assert solution.minimumWeight(n, edges, src1, src2, dest) == 7", "def test_minimumWeight():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 3], [1, 4, 4], [0, 2, 2], [2, 3, 1], [3, 4, 1], [1, 3, 2]]\n    src1 = 0\n    src2 = 1\n    dest = 4\n    assert solution.minimumWeight(n, edges, src1, src2, dest) == 6", "def test_minimumWeight():\n    solution = Solution()\n    n = 5\n    edges = [[0, 2, 1], [1, 2, 1], [2, 3, 2], [3, 4, 3], [1, 3, 4], [0, 4, 10]]\n    src1 = 0\n    src2 = 1\n    dest = 4\n    assert solution.minimumWeight(n, edges, src1, src2, dest) == 8", "def test_minimumWeight():\n    solution = Solution()\n    n = 6\n    edges = [[0, 1, 2], [0, 2, 4], [1, 3, 1], [2, 3, 3], [3, 4, 5], [2, 5, 1], [5, 4, 2]]\n    src1 = 0\n    src2 = 2\n    dest = 4\n    assert solution.minimumWeight(n, edges, src1, src2, dest) == 8", "def test_minimumWeight():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 1], [1, 2, 3], [2, 4, 1], [0, 3, 2], [3, 4, 2], [1, 3, 1]]\n    src1 = 0\n    src2 = 1\n    dest = 4\n    assert solution.minimumWeight(n, edges, src1, src2, dest) == 5", "def test_minimumWeight():\n    solution = Solution()\n    n = 7\n    edges = [[0, 1, 5], [1, 3, 2], [3, 6, 3], [0, 2, 4], [2, 4, 1], [4, 6, 2], [2, 5, 3], [5, 6, 1]]\n    src1 = 0\n    src2 = 2\n    dest = 6\n    assert solution.minimumWeight(n, edges, src1, src2, dest) == 10", "def test_minimumWeight():\n    solution = Solution()\n    n = 6\n    edges = [[0, 1, 3], [1, 2, 1], [2, 4, 2], [0, 3, 6], [3, 4, 3], [1, 3, 2], [4, 5, 1]]\n    src1 = 0\n    src2 = 1\n    dest = 5\n    assert solution.minimumWeight(n, edges, src1, src2, dest) == 9"]}
{"task_num": 2242, "task_title": "Maximum Score of a Node Sequence", "func_name": "maximumScore", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\n    n = len(scores)\n    ans = -1\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append((scores[v], v))\n      graph[v].append((scores[u], u))\n\n    for i in range(n):\n      graph[i] = heapq.nlargest(3, graph[i])\n\n    for u, v in edges:\n      for scoreA, a in graph[u]:\n        for scoreB, b in graph[v]:\n          if a != b and a != v and b != u:\n            ans = max(ans, scoreA + scores[u] + scores[v] + scoreB)\n\n    return ans\n", "tests": ["def test_maximumScore():\n    solution = Solution()\n    scores = [5, 2, 9, 8, 4]\n    edges = [[0, 1], [1, 2], [2, 3], [0, 2], [1, 3], [2, 4]]\n    assert solution.maximumScore(scores, edges) == 24", "def test_maximumScore():\n    solution = Solution()\n    scores = [1, 3, 5, 7, 9]\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4], [0, 4], [1, 3]]\n    assert solution.maximumScore(scores, edges) == 24", "def test_maximumScore():\n    solution = Solution()\n    scores = [10, 20, 30]\n    edges = [[0, 1], [1, 2]]\n    assert solution.maximumScore(scores, edges) == -1", "def test_maximumScore():\n    solution = Solution()\n    scores = [8, 6, 7, 5, 3, 0, 9]\n    edges = [[0, 1], [1, 2], [2, 0], [3, 4], [4, 5], [5, 6], [3, 6]]\n    assert solution.maximumScore(scores, edges) == 26", "def test_maximumScore():\n    solution = Solution()\n    scores = [4, 1, 8, 10, 2, 3]\n    edges = [[0, 1], [1, 2], [2, 3], [4, 5], [0, 5], [3, 4]]\n    assert solution.maximumScore(scores, edges) == 25", "def test_maximumScore():\n    solution = Solution()\n    scores = [15, 10, 5, 8, 12]\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4], [0, 3], [1, 4]]\n    assert solution.maximumScore(scores, edges) == 45", "def test_maximumScore():\n    solution = Solution()\n    scores = [7, 11, 13, 17, 19]\n    edges = [[0, 1], [1, 2], [2, 3], [1, 4], [3, 4]]\n    assert solution.maximumScore(scores, edges) == 60", "def test_maximumScore():\n    solution = Solution()\n    scores = [3, 6, 9, 12, 15, 18]\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [2, 5], [0, 4]]\n    assert solution.maximumScore(scores, edges) == 51", "def test_maximumScore():\n    solution = Solution()\n    scores = [10, 20, 30, 40, 50]\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4], [0, 3], [1, 4]]\n    assert solution.maximumScore(scores, edges) == 140", "def test_maximumScore():\n    solution = Solution()\n    scores = [14, 6, 9, 3, 7, 8]\n    edges = [[0, 1], [1, 2], [1, 3], [2, 4], [4, 5], [3, 5]]\n    assert solution.maximumScore(scores, edges) == 32", "def test_maximumScore():\n    solution = Solution()\n    scores = [5, 7, 2, 4, 8, 1]\n    edges = [[0, 2], [2, 3], [3, 4], [4, 5], [1, 3], [0, 4]]\n    assert solution.maximumScore(scores, edges) == 19", "def test_maximumScore():\n    solution = Solution()\n    scores = [12, 14, 16, 18, 20, 22]\n    edges = [[0, 1], [1, 3], [3, 4], [2, 5], [0, 5], [1, 2]]\n    assert solution.maximumScore(scores, edges) == 68", "def test_maximumScore():\n    solution = Solution()\n    scores = [11, 21, 13, 14, 15, 16]\n    edges = [[0, 1], [1, 4], [4, 5], [0, 3], [3, 2], [2, 5]]\n    assert solution.maximumScore(scores, edges) == 64", "def test_maximumScore():\n    solution = Solution()\n    scores = [2, 4, 6, 8, 10, 12, 14]\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [1, 5]]\n    assert solution.maximumScore(scores, edges) == 36", "def test_maximumScore():\n    solution = Solution()\n    scores = [9, 5, 8, 6, 3, 7]\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [0, 4], [1, 5]]\n    assert solution.maximumScore(scores, edges) == 28", "def test_maximumScore():\n    solution = Solution()\n    scores = [17, 22, 10, 5, 11, 9]\n    edges = [[0, 1], [1, 3], [3, 4], [4, 2], [2, 5], [0, 5], [1, 2]]\n    assert solution.maximumScore(scores, edges) == 59", "def test_maximumScore():\n    solution = Solution()\n    scores = [8, 12, 15, 20, 25, 30]\n    edges = [[0, 2], [2, 3], [3, 5], [5, 1], [1, 4], [0, 4], [2, 4]]\n    assert solution.maximumScore(scores, edges) == 77", "def test_maximumScore():\n    solution = Solution()\n    scores = [30, 25, 20, 15, 10]\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4], [1, 3]]\n    assert solution.maximumScore(scores, edges) == 80", "def test_maximumScore():\n    solution = Solution()\n    scores = [3, 7, 9, 12, 18, 21]\n    edges = [[0, 1], [1, 2], [2, 3], [3, 5], [0, 4], [4, 5]]\n    assert solution.maximumScore(scores, edges) == 48", "def test_maximumScore():\n    solution = Solution()\n    scores = [4, 2, 5, 10, 8, 6, 3]\n    edges = [[0, 2], [2, 3], [3, 5], [5, 6], [1, 4], [4, 3], [0, 5]]\n    assert solution.maximumScore(scores, edges) == 29"]}
{"task_num": 2245, "task_title": "Maximum Trailing Zeros in a Cornered Path", "func_name": "maxTrailingZeros", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxTrailingZeros(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    leftPrefix2 = [[0] * n for _ in range(m)]\n    leftPrefix5 = [[0] * n for _ in range(m)]\n    topPrefix2 = [[0] * n for _ in range(m)]\n    topPrefix5 = [[0] * n for _ in range(m)]\n\n    def getCount(num: int, factor: int) -> int:\n      count = 0\n      while num % factor == 0:\n        num //= factor\n        count += 1\n      return count\n\n    for i in range(m):\n      for j in range(n):\n        leftPrefix2[i][j] = getCount(grid[i][j], 2)\n        leftPrefix5[i][j] = getCount(grid[i][j], 5)\n        if j:\n          leftPrefix2[i][j] += leftPrefix2[i][j - 1]\n          leftPrefix5[i][j] += leftPrefix5[i][j - 1]\n\n    for j in range(n):\n      for i in range(m):\n        topPrefix2[i][j] = getCount(grid[i][j], 2)\n        topPrefix5[i][j] = getCount(grid[i][j], 5)\n        if i:\n          topPrefix2[i][j] += topPrefix2[i - 1][j]\n          topPrefix5[i][j] += topPrefix5[i - 1][j]\n\n    ans = 0\n    for i in range(m):\n      for j in range(n):\n        curr2 = getCount(grid[i][j], 2)\n        curr5 = getCount(grid[i][j], 5)\n        l2 = leftPrefix2[i][j]\n        l5 = leftPrefix5[i][j]\n        r2 = leftPrefix2[i][n - 1] - (0 if j == 0 else leftPrefix2[i][j - 1])\n        r5 = leftPrefix5[i][n - 1] - (0 if j == 0 else leftPrefix5[i][j - 1])\n        t2 = topPrefix2[i][j]\n        t5 = topPrefix5[i][j]\n        d2 = topPrefix2[m - 1][j] - (0 if i == 0 else topPrefix2[i - 1][j])\n        d5 = topPrefix5[m - 1][j] - (0 if i == 0 else topPrefix5[i - 1][j])\n        ans = max(ans, min(l2 + t2 - curr2, l5 + t5 - curr5), min(r2 + t2 - curr2, r5 + t5 - curr5), min(l2 + d2 - curr2, l5 + d5 - curr5), min(r2 + d2 - curr2, r5 + d5 - curr5))\n\n    return ans\n", "tests": ["def test_maxTrailingZeros():\n    solution = Solution()\n    grid = [[10, 5, 2], [20, 50, 3], [30, 15, 3]]\n    assert solution.maxTrailingZeros(grid) == 3", "def test_maxTrailingZeros():\n    solution = Solution()\n    grid = [[2, 25, 5], [5, 10, 20], [10, 50, 4]]\n    assert solution.maxTrailingZeros(grid) == 4", "def test_maxTrailingZeros():\n    solution = Solution()\n    grid = [[3, 6, 9], [8, 12, 18], [7, 14, 21]]\n    assert solution.maxTrailingZeros(grid) == 0", "def test_maxTrailingZeros():\n    solution = Solution()\n    grid = [[50, 25, 5], [10, 5, 2], [3, 2, 1]]\n    assert solution.maxTrailingZeros(grid) == 2", "def test_maxTrailingZeros():\n    solution = Solution()\n    grid = [[16, 32, 8], [64, 128, 256], [4, 2, 1]]\n    assert solution.maxTrailingZeros(grid) == 7", "def test_maxTrailingZeros():\n    solution = Solution()\n    grid = [[1, 1, 1], [1, 5, 1], [1, 1, 1]]\n    assert solution.maxTrailingZeros(grid) == 1", "def test_maxTrailingZeros():\n    solution = Solution()\n    grid = [[15, 30, 45], [60, 75, 90], [105, 120, 135]]\n    assert solution.maxTrailingZeros(grid) == 2", "def test_maxTrailingZeros():\n    solution = Solution()\n    grid = [[100, 10, 1], [1, 10, 100], [100, 10, 1]]\n    assert solution.maxTrailingZeros(grid) == 2", "def test_maxTrailingZeros():\n    solution = Solution()\n    grid = [[2, 4, 8, 16], [3, 9, 27, 81], [5, 25, 125, 625], [10, 100, 1000, 10000]]\n    assert solution.maxTrailingZeros(grid) == 13", "def test_maxTrailingZeros():\n    solution = Solution()\n    grid = [[7, 14, 28], [14, 28, 56], [28, 56, 112]]\n    assert solution.maxTrailingZeros(grid) == 1", "def test_maxTrailingZeros():\n    solution = Solution()\n    grid = [[6, 3, 9], [2, 4, 8], [25, 50, 100]]\n    assert solution.maxTrailingZeros(grid) == 2", "def test_maxTrailingZeros():\n    solution = Solution()\n    grid = [[9, 9, 9], [3, 3, 3], [1, 1, 1]]\n    assert solution.maxTrailingZeros(grid) == 0", "def test_maxTrailingZeros():\n    solution = Solution()\n    grid = [[5, 10, 15], [20, 30, 25], [35, 40, 50]]\n    assert solution.maxTrailingZeros(grid) == 3", "def test_maxTrailingZeros():\n    solution = Solution()\n    grid = [[2, 2, 2], [2, 2, 2], [5, 5, 5]]\n    assert solution.maxTrailingZeros(grid) == 3", "def test_maxTrailingZeros():\n    solution = Solution()\n    grid = [[45, 90, 180], [5, 10, 20], [3, 6, 9]]\n    assert solution.maxTrailingZeros(grid) == 3", "def test_maxTrailingZeros():\n    solution = Solution()\n    grid = [[7, 14, 21, 28], [2, 4, 8, 16], [6, 12, 18, 24], [5, 10, 15, 20]]\n    assert solution.maxTrailingZeros(grid) == 5", "def test_maxTrailingZeros():\n    solution = Solution()\n    grid = [[3, 5, 7], [11, 13, 17], [19, 23, 29]]\n    assert solution.maxTrailingZeros(grid) == 0", "def test_maxTrailingZeros():\n    solution = Solution()\n    grid = [[10, 20, 30], [1, 2, 3], [5, 10, 25]]\n    assert solution.maxTrailingZeros(grid) == 3", "def test_maxTrailingZeros():\n    solution = Solution()\n    grid = [[8, 4, 2], [16, 8, 4], [32, 16, 8]]\n    assert solution.maxTrailingZeros(grid) == 9", "def test_maxTrailingZeros():\n    solution = Solution()\n    grid = [[2, 5, 10], [3, 6, 9], [4, 8, 12]]\n    assert solution.maxTrailingZeros(grid) == 2"]}
{"task_num": 2257, "task_title": "Count Unguarded Cells in the Grid", "func_name": "countUnguarded", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\n    ans = 0\n    grid = [[0] * n for _ in range(m)]\n    left = [[0] * n for _ in range(m)]\n    right = [[0] * n for _ in range(m)]\n    up = [[0] * n for _ in range(m)]\n    down = [[0] * n for _ in range(m)]\n\n    for row, col in guards:\n      grid[row][col] = 'G'\n\n    for row, col in walls:\n      grid[row][col] = 'W'\n\n    for i in range(m):\n      lastCell = 0\n      for j in range(n):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          left[i][j] = lastCell\n      lastCell = 0\n      for j in range(n - 1, -1, -1):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          right[i][j] = lastCell\n\n    for j in range(n):\n      lastCell = 0\n      for i in range(m):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          up[i][j] = lastCell\n      lastCell = 0\n      for i in range(m - 1, -1, -1):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          down[i][j] = lastCell\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 0 and left[i][j] != 'G' and right[i][j] != 'G' and up[i][j] != 'G' and down[i][j] != 'G':\n          ans += 1\n\n    return ans\n", "tests": ["def test_countUnguarded():\n    solution = Solution()\n    assert solution.countUnguarded(4, 4, [[0, 0], [1, 1]], [[0, 1], [2, 2]]) == 7", "def test_countUnguarded():\n    solution = Solution()\n    assert solution.countUnguarded(5, 5, [[1, 2], [3, 3]], [[0, 3], [3, 1]]) == 15", "def test_countUnguarded():\n    solution = Solution()\n    assert solution.countUnguarded(3, 3, [[0, 0], [2, 2]], [[1, 1]]) == 4", "def test_countUnguarded():\n    solution = Solution()\n    assert solution.countUnguarded(6, 6, [[2, 3], [4, 4]], [[3, 4], [1, 2], [5, 5]]) == 26", "def test_countUnguarded():\n    solution = Solution()\n    assert solution.countUnguarded(4, 5, [[0, 4], [3, 2]], [[0, 2], [1, 1], [2, 3]]) == 13", "def test_countUnguarded():\n    solution = Solution()\n    assert solution.countUnguarded(5, 3, [[1, 0], [3, 1]], [[2, 1], [4, 0]]) == 9", "def test_countUnguarded():\n    solution = Solution()\n    assert solution.countUnguarded(3, 4, [[0, 1], [2, 2]], [[1, 0], [1, 3]]) == 6", "def test_countUnguarded():\n    solution = Solution()\n    assert solution.countUnguarded(5, 5, [[0, 0], [4, 4]], [[0, 4], [4, 0], [2, 2], [1, 3]]) == 10", "def test_countUnguarded():\n    solution = Solution()\n    assert solution.countUnguarded(2, 2, [[0, 0]], [[1, 1]]) == 1", "def test_countUnguarded():\n    solution = Solution()\n    assert solution.countUnguarded(3, 3, [[0, 2], [2, 0]], [[1, 1]]) == 3", "def test_countUnguarded():\n    solution = Solution()\n    assert solution.countUnguarded(4, 4, [[0, 1], [3, 3]], [[1, 2], [2, 0], [3, 1]]) == 8", "def test_countUnguarded():\n    solution = Solution()\n    assert solution.countUnguarded(6, 6, [[2, 2], [4, 5]], [[0, 1], [3, 3], [5, 0]]) == 24", "def test_countUnguarded():\n    solution = Solution()\n    assert solution.countUnguarded(5, 4, [[1, 1], [3, 2]], [[0, 3], [4, 0], [2, 2]]) == 10", "def test_countUnguarded():\n    solution = Solution()\n    assert solution.countUnguarded(4, 6, [[1, 5], [3, 0]], [[0, 1], [2, 3], [3, 4]]) == 15", "def test_countUnguarded():\n    solution = Solution()\n    assert solution.countUnguarded(7, 7, [[2, 6], [5, 1]], [[0, 0], [3, 3], [6, 6]]) == 37", "def test_countUnguarded():\n    solution = Solution()\n    assert solution.countUnguarded(3, 5, [[0, 4], [2, 2]], [[1, 1], [1, 3]]) == 9", "def test_countUnguarded():\n    solution = Solution()\n    assert solution.countUnguarded(4, 3, [[1, 2], [2, 0]], [[0, 1], [3, 2]]) == 7", "def test_countUnguarded():\n    solution = Solution()\n    assert solution.countUnguarded(8, 8, [[1, 1], [6, 6]], [[3, 3], [4, 4], [5, 5], [7, 7]]) == 52", "def test_countUnguarded():\n    solution = Solution()\n    assert solution.countUnguarded(5, 7, [[2, 3], [4, 6]], [[1, 5], [3, 2], [0, 0]]) == 24", "def test_countUnguarded():\n    solution = Solution()\n    assert solution.countUnguarded(4, 5, [[0, 0], [3, 4]], [[1, 2], [2, 1], [2, 3]]) == 12"]}
{"task_num": 2258, "task_title": "Escape the Spreading Fire", "func_name": "maximumMinutes", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumMinutes(self, grid: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    kMax = len(grid) * len(grid[0])\n    fireGrid = [[-1] * len(grid[0]) for _ in range(len(grid))]\n    self._buildFireGrid(grid, fireGrid, dirs)\n\n    ans = -1\n    l = 0\n    r = kMax\n\n    while l <= r:\n      m = (l + r) // 2\n      if self._canStayFor(grid, fireGrid, m, dirs):\n        ans = m\n        l = m + 1\n      else:\n        r = m - 1\n\n    return int(1e9) if ans == kMax else ans\n\n  def _buildFireGrid(self, grid: List[List[int]], fireMinute: List[List[int]], dirs: List[int]) -> None:\n    minuteFromFire = 0\n    q = collections.deque()\n\n    for i in range(len(grid)):\n      for j in range(len(grid[0])):\n        if grid[i][j] == 1:\n          q.append((i, j))\n          fireMinute[i][j] = 0\n    while q:\n      minuteFromFire += 1\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == len(grid) or y < 0 or y == len(grid[0]):\n            continue\n          if grid[x][y] == 2:\n            continue\n          if fireMinute[x][y] != -1:\n            continue\n          fireMinute[x][y] = minuteFromFire\n          q.append((x, y))\n\n  def _canStayFor(self, grid: List[List[int]], fireMinute: List[List[int]], minute: int, dirs: List[int]) -> bool:\n    q = collections.deque([(0, 0)])\n    seen = {(0, 0)}\n\n    while q:\n      minute += 1\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == len(grid) or y < 0 or y == len(grid[0]):\n            continue\n          if grid[x][y] == 2:\n            continue\n          if x == len(grid) - 1 and y == len(grid[0]) - 1:\n            if fireMinute[x][y] != -1 and fireMinute[x][y] < minute:\n              continue\n            return True\n          if fireMinute[x][y] != -1 and fireMinute[x][y] <= minute:\n            continue\n          if (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n\n    return False\n", "tests": ["def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 0, 0, 0], [1, 0, 2, 0], [0, 0, 0, 0], [0, 2, 1, 0]]\n    assert solution.maximumMinutes(grid) == 3", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 1, 0], [0, 2, 0], [0, 0, 0]]\n    assert solution.maximumMinutes(grid) == -1", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[1, 0, 0], [2, 2, 0], [0, 0, 0]]\n    assert solution.maximumMinutes(grid) == 109", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 0, 1], [0, 2, 0], [0, 0, 0]]\n    assert solution.maximumMinutes(grid) == 2", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 0, 0, 1], [2, 2, 0, 0], [0, 0, 2, 0], [0, 0, 0, 0]]\n    assert solution.maximumMinutes(grid) == 0", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n    assert solution.maximumMinutes(grid) == 1", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 0], [1, 0]]\n    assert solution.maximumMinutes(grid) == -1", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 1, 0, 0], [0, 2, 2, 0], [1, 0, 0, 0], [0, 0, 1, 0]]\n    assert solution.maximumMinutes(grid) == 0", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 0, 0], [2, 1, 2], [0, 0, 0]]\n    assert solution.maximumMinutes(grid) == 109", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 0, 0, 0, 0], [0, 2, 2, 2, 0], [0, 2, 1, 2, 0], [0, 2, 0, 2, 0], [0, 0, 0, 0, 0]]\n    assert solution.maximumMinutes(grid) == 0", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 0, 0, 1], [0, 2, 2, 0], [0, 2, 0, 0], [0, 0, 0, 0]]\n    assert solution.maximumMinutes(grid) == 2", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 1], [0, 0]]\n    assert solution.maximumMinutes(grid) == 1", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 0, 2], [0, 1, 0], [2, 0, 0]]\n    assert solution.maximumMinutes(grid) == 0", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 0, 0, 0], [2, 2, 2, 0], [1, 0, 0, 0], [0, 0, 2, 0]]\n    assert solution.maximumMinutes(grid) == 1", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 2, 1], [0, 0, 0]]\n    assert solution.maximumMinutes(grid) == 109", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 2, 0, 0], [0, 2, 0, 1], [0, 2, 0, 0], [0, 0, 0, 0]]\n    assert solution.maximumMinutes(grid) == 3", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 0, 0, 0, 1], [0, 2, 2, 2, 0], [0, 2, 0, 0, 0], [0, 2, 0, 2, 0], [0, 0, 0, 0, 0]]\n    assert solution.maximumMinutes(grid) == 1", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 0, 2, 0], [1, 0, 2, 0], [0, 0, 2, 0], [0, 0, 0, 0]]\n    assert solution.maximumMinutes(grid) == 2", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[1, 0, 0, 0], [2, 2, 2, 0], [0, 0, 0, 0], [0, 0, 0, 0]]\n    assert solution.maximumMinutes(grid) == 109", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 0, 0, 0], [0, 2, 2, 0], [0, 2, 1, 0], [0, 0, 0, 0]]\n    assert solution.maximumMinutes(grid) == 0"]}
{"task_num": 2290, "task_title": "Minimum Obstacle Removal to Reach Corner", "func_name": "minimumObstacles", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumObstacles(self, grid: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    minHeap = [(grid[0][0], 0, 0)]  # (d, i, j)\n    dist = [[math.inf] * n for _ in range(m)]\n    dist[0][0] = grid[0][0]\n\n    while minHeap:\n      d, i, j = heapq.heappop(minHeap)\n      if i == m - 1 and j == n - 1:\n        return d\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        newDist = d + grid[i][j]\n        if newDist < dist[x][y]:\n          dist[x][y] = newDist\n          heapq.heappush(minHeap, (newDist, x, y))\n\n    return dist[m - 1][n - 1]\n", "tests": ["def test_minimumObstacles():\n    solution = Solution()\n    grid = [[0, 1, 1], [1, 1, 0], [1, 0, 0]]\n    assert solution.minimumObstacles(grid) == 2", "def test_minimumObstacles():\n    solution = Solution()\n    grid = [[0, 0, 0], [1, 1, 0], [1, 1, 0]]\n    assert solution.minimumObstacles(grid) == 0", "def test_minimumObstacles():\n    solution = Solution()\n    grid = [[0, 1, 1, 0], [1, 1, 1, 0], [0, 0, 0, 1], [1, 1, 0, 0]]\n    assert solution.minimumObstacles(grid) == 1", "def test_minimumObstacles():\n    solution = Solution()\n    grid = [[0, 1, 0, 1], [1, 0, 1, 0], [1, 1, 0, 1], [0, 0, 0, 0]]\n    assert solution.minimumObstacles(grid) == 2", "def test_minimumObstacles():\n    solution = Solution()\n    grid = [[0, 0], [0, 1], [1, 0], [0, 0]]\n    assert solution.minimumObstacles(grid) == 0", "def test_minimumObstacles():\n    solution = Solution()\n    grid = [[0, 1, 0], [1, 0, 1], [0, 1, 0]]\n    assert solution.minimumObstacles(grid) == 0", "def test_minimumObstacles():\n    solution = Solution()\n    grid = [[0, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [0, 0, 0, 0]]\n    assert solution.minimumObstacles(grid) == 3", "def test_minimumObstacles():\n    solution = Solution()\n    grid = [[0, 0, 1], [1, 1, 1], [0, 1, 0]]\n    assert solution.minimumObstacles(grid) == 1", "def test_minimumObstacles():\n    solution = Solution()\n    grid = [[0, 1, 0, 1, 0], [1, 1, 1, 1, 1], [0, 0, 0, 0, 0], [1, 1, 1, 1, 0], [0, 0, 0, 0, 0]]\n    assert solution.minimumObstacles(grid) == 2", "def test_minimumObstacles():\n    solution = Solution()\n    grid = [[0, 0, 0, 0], [1, 1, 1, 0], [0, 0, 1, 0], [1, 0, 0, 0]]\n    assert solution.minimumObstacles(grid) == 0", "def test_minimumObstacles():\n    solution = Solution()\n    grid = [[0, 1, 1, 1, 1], [1, 0, 1, 0, 1], [1, 1, 0, 1, 0], [0, 0, 1, 1, 0], [1, 0, 0, 0, 0]]\n    assert solution.minimumObstacles(grid) == 3", "def test_minimumObstacles():\n    solution = Solution()\n    grid = [[0, 1, 1, 1], [1, 0, 0, 1], [1, 1, 0, 1], [1, 1, 1, 0]]\n    assert solution.minimumObstacles(grid) == 2", "def test_minimumObstacles():\n    solution = Solution()\n    grid = [[0, 0, 1], [1, 1, 1], [0, 0, 0], [1, 1, 0]]\n    assert solution.minimumObstacles(grid) == 1", "def test_minimumObstacles():\n    solution = Solution()\n    grid = [[0, 0, 0, 0], [0, 1, 1, 1], [0, 0, 0, 1], [1, 1, 0, 0]]\n    assert solution.minimumObstacles(grid) == 0", "def test_minimumObstacles():\n    solution = Solution()\n    grid = [[0, 1, 1, 1, 1], [0, 0, 1, 1, 1], [1, 0, 1, 0, 0], [1, 1, 0, 0, 0]]\n    assert solution.minimumObstacles(grid) == 2", "def test_minimumObstacles():\n    solution = Solution()\n    grid = [[0, 1, 1, 0], [1, 0, 1, 0], [1, 1, 0, 1], [0, 0, 0, 0]]\n    assert solution.minimumObstacles(grid) == 1", "def test_minimumObstacles():\n    solution = Solution()\n    grid = [[0, 0, 0, 1], [1, 1, 0, 1], [1, 1, 1, 1], [0, 0, 0, 0]]\n    assert solution.minimumObstacles(grid) == 1", "def test_minimumObstacles():\n    solution = Solution()\n    grid = [[0, 1, 0], [1, 0, 1], [0, 1, 1], [0, 0, 0]]\n    assert solution.minimumObstacles(grid) == 1", "def test_minimumObstacles():\n    solution = Solution()\n    grid = [[0, 0, 1, 1], [0, 1, 1, 0], [1, 0, 0, 0], [1, 1, 1, 0]]\n    assert solution.minimumObstacles(grid) == 2", "def test_minimumObstacles():\n    solution = Solution()\n    grid = [[0, 0, 0, 0, 1], [1, 1, 1, 0, 1], [0, 0, 1, 0, 0], [1, 0, 0, 1, 0], [1, 1, 0, 0, 0]]\n    assert solution.minimumObstacles(grid) == 1"]}
{"task_num": 2299, "task_title": "Strong Password Checker II", "func_name": "strongPasswordCheckerII", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def strongPasswordCheckerII(self, password: str) -> bool:\n    if len(password) < 8:\n      return False\n    if not any(c.islower() for c in password):\n      return False\n    if not any(c.isupper() for c in password):\n      return False\n    if not any(c.isdigit() for c in password):\n      return False\n    if not any(\"!@#$%^&*()-+\".find(c) != -1 for c in password):\n      return False\n    return all(a != b for a, b in zip(password, password[1:]))\n", "tests": ["def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert solution.strongPasswordCheckerII('Aa1!Aa1!') == True", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert solution.strongPasswordCheckerII('A1!aaaaa') == False", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert solution.strongPasswordCheckerII('abcdefgA1!') == True", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert solution.strongPasswordCheckerII('1234567!') == False", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert solution.strongPasswordCheckerII('Aa!Aa!Aa') == False", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert solution.strongPasswordCheckerII('Aa1aaaaa') == False", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert solution.strongPasswordCheckerII('Aa1!aA1!') == True", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert solution.strongPasswordCheckerII('Aa1!aaaA') == False", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert solution.strongPasswordCheckerII('Aa1!aA1') == False", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert solution.strongPasswordCheckerII('AAaa11!') == False", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert solution.strongPasswordCheckerII('Aa123456') == False", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert solution.strongPasswordCheckerII('Aa!1Aa!1') == True", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert solution.strongPasswordCheckerII('12345678aA!') == True", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert solution.strongPasswordCheckerII('aA!1aA!1') == True", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert solution.strongPasswordCheckerII('Aa1Aa1!') == False", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert solution.strongPasswordCheckerII('Aa!Aa!12') == True", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert solution.strongPasswordCheckerII('aA1aA1aA') == False", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert solution.strongPasswordCheckerII('aaAA11!!') == False", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert solution.strongPasswordCheckerII('Abcdefg!') == False", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert solution.strongPasswordCheckerII('ABCDEFGH1!') == False"]}
{"task_num": 2301, "task_title": "Match Substring After Replacement", "func_name": "matchReplacement", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def matchReplacement(self, s: str, sub: str, mappings: List[List[str]]) -> bool:\n    isMapped = [[False] * 128 for _ in range(128)]\n\n    for old, new in mappings:\n      isMapped[ord(old)][ord(new)] = True\n\n    for i in range(len(s)):\n      if self._canTransform(s, i, sub, isMapped):\n        return True\n\n    return False\n\n  def _canTransform(self, s: str, start: int, sub: str, isMapped: List[List[bool]]) -> bool:\n    if start + len(sub) > len(s):\n      return False\n\n    for i in range(len(sub)):\n      a = sub[i]\n      b = s[start + i]\n      if a != b and not isMapped[ord(a)][ord(b)]:\n        return False\n\n    return True\n", "tests": ["def test_matchReplacement():\n    solution = Solution()\n    s = 'abcde'\n    sub = 'axc'\n    mappings = [['a', 'a'], ['b', 'x'], ['c', 'c']]\n    assert solution.matchReplacement(s, sub, mappings) == True", "def test_matchReplacement():\n    solution = Solution()\n    s = 'abcdefg'\n    sub = 'xyz'\n    mappings = [['x', 'c'], ['y', 'd'], ['z', 'e']]\n    assert solution.matchReplacement(s, sub, mappings) == True", "def test_matchReplacement():\n    solution = Solution()\n    s = 'hello'\n    sub = 'world'\n    mappings = [['h', 'w'], ['e', 'o'], ['l', 'r'], ['o', 'd']]\n    assert solution.matchReplacement(s, sub, mappings) == False", "def test_matchReplacement():\n    solution = Solution()\n    s = 'abracadabra'\n    sub = 'cad'\n    mappings = [['c', 'a'], ['a', 'b'], ['d', 'r']]\n    assert solution.matchReplacement(s, sub, mappings) == True", "def test_matchReplacement():\n    solution = Solution()\n    s = 'banana'\n    sub = 'band'\n    mappings = [['b', 'b'], ['a', 'a'], ['n', 'n'], ['d', 'd']]\n    assert solution.matchReplacement(s, sub, mappings) == False", "def test_matchReplacement():\n    solution = Solution()\n    s = 'xyzxyz'\n    sub = 'abc'\n    mappings = [['a', 'x'], ['b', 'y'], ['c', 'z']]\n    assert solution.matchReplacement(s, sub, mappings) == True", "def test_matchReplacement():\n    solution = Solution()\n    s = 'mississippi'\n    sub = 'mss'\n    mappings = [['m', 'm'], ['i', 's'], ['s', 'i']]\n    assert solution.matchReplacement(s, sub, mappings) == True", "def test_matchReplacement():\n    solution = Solution()\n    s = 'qwerty'\n    sub = 'tyr'\n    mappings = [['t', 't'], ['y', 'y'], ['r', 'r']]\n    assert solution.matchReplacement(s, sub, mappings) == False", "def test_matchReplacement():\n    solution = Solution()\n    s = 'abcdefgh'\n    sub = 'efg'\n    mappings = [['e', 'e'], ['f', 'f'], ['g', 'g'], ['h', 'h']]\n    assert solution.matchReplacement(s, sub, mappings) == True", "def test_matchReplacement():\n    solution = Solution()\n    s = 'racecar'\n    sub = 'car'\n    mappings = [['c', 'r'], ['a', 'a'], ['r', 'c']]\n    assert solution.matchReplacement(s, sub, mappings) == True", "def test_matchReplacement():\n    solution = Solution()\n    s = 'umbrella'\n    sub = 'ella'\n    mappings = [['e', 'e'], ['l', 'l'], ['a', 'a'], ['b', 'l']]\n    assert solution.matchReplacement(s, sub, mappings) == True", "def test_matchReplacement():\n    solution = Solution()\n    s = 'turingmachine'\n    sub = 'ring'\n    mappings = [['r', 'u'], ['i', 'r'], ['n', 'i'], ['g', 'n']]\n    assert solution.matchReplacement(s, sub, mappings) == True", "def test_matchReplacement():\n    solution = Solution()\n    s = 'pineapple'\n    sub = 'apple'\n    mappings = [['a', 'a'], ['p', 'p'], ['l', 'l'], ['e', 'e']]\n    assert solution.matchReplacement(s, sub, mappings) == True", "def test_matchReplacement():\n    solution = Solution()\n    s = 'parallelogram'\n    sub = 'log'\n    mappings = [['l', 'l'], ['o', 'o'], ['g', 'g']]\n    assert solution.matchReplacement(s, sub, mappings) == True", "def test_matchReplacement():\n    solution = Solution()\n    s = 'supercalifragilisticexpialidocious'\n    sub = 'fragile'\n    mappings = [['f', 'f'], ['r', 'r'], ['a', 'a'], ['g', 'g'], ['i', 'i'], ['l', 'l'], ['e', 'e']]\n    assert solution.matchReplacement(s, sub, mappings) == True", "def test_matchReplacement():\n    solution = Solution()\n    s = 'abcdefghij'\n    sub = 'hij'\n    mappings = [['h', 'h'], ['i', 'i'], ['j', 'j']]\n    assert solution.matchReplacement(s, sub, mappings) == True", "def test_matchReplacement():\n    solution = Solution()\n    s = 'functionality'\n    sub = 'action'\n    mappings = [['a', 'f'], ['c', 'u'], ['t', 'n'], ['i', 'c'], ['o', 't'], ['n', 'i']]\n    assert solution.matchReplacement(s, sub, mappings) == False", "def test_matchReplacement():\n    solution = Solution()\n    s = 'xylophone'\n    sub = 'phone'\n    mappings = [['p', 'p'], ['h', 'h'], ['o', 'o'], ['n', 'n'], ['e', 'e']]\n    assert solution.matchReplacement(s, sub, mappings) == True", "def test_matchReplacement():\n    solution = Solution()\n    s = 'concatenation'\n    sub = 'nation'\n    mappings = [['n', 'n'], ['a', 'a'], ['t', 't'], ['i', 'i'], ['o', 'o'], ['n', 'n']]\n    assert solution.matchReplacement(s, sub, mappings) == True", "def test_matchReplacement():\n    solution = Solution()\n    s = 'transformation'\n    sub = 'form'\n    mappings = [['f', 'r'], ['o', 'a'], ['r', 'n'], ['m', 's']]\n    assert solution.matchReplacement(s, sub, mappings) == False"]}
{"task_num": 2322, "task_title": "Minimum Score After Removals on a Tree", "func_name": "minimumScore", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Set\n\nclass Solution:\n  def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\n    n = len(nums)\n    xors = functools.reduce(lambda x, y: x ^ y, nums)\n    subXors = nums[:]\n    tree = [[] for _ in range(n)]\n    children = [{i} for i in range(n)]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, parent: int) -> Tuple[int, Set[int]]:\n      for v in tree[u]:\n        if v == parent:\n          continue\n        vXor, vChildren = dfs(v, u)\n        subXors[u] ^= vXor\n        children[u] |= vChildren\n      return subXors[u], children[u]\n\n    dfs(0, -1)\n\n    ans = math.inf\n    for i in range(len(edges)):\n      a, b = edges[i]\n      if b in children[a]:\n        a, b = b, a\n      for j in range(i):\n        c, d = edges[j]\n        if d in children[c]:\n          c, d = d, c\n\n        if c in children[a] and a != c:\n          cands = [subXors[c], subXors[a] ^ subXors[c], xors ^ subXors[a]]\n        elif a in children[c] and a != c:\n          cands = [subXors[a], subXors[c] ^ subXors[a], xors ^ subXors[c]]\n        else:\n          cands = [subXors[a], subXors[c], xors ^ subXors[a] ^ subXors[c]]\n        ans = min(ans, max(cands) - min(cands))\n\n    return ans\n", "tests": ["def test_minimumScore():\n    solution = Solution()\n    nums = [1, 5, 6, 7]\n    edges = [[0, 1], [1, 2], [1, 3]]\n    assert solution.minimumScore(nums, edges) == 1", "def test_minimumScore():\n    solution = Solution()\n    nums = [3, 8, 2, 6, 5]\n    edges = [[0, 1], [0, 2], [1, 3], [1, 4]]\n    assert solution.minimumScore(nums, edges) == 0", "def test_minimumScore():\n    solution = Solution()\n    nums = [4, 1, 7, 3, 9, 2]\n    edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5]]\n    assert solution.minimumScore(nums, edges) == 2", "def test_minimumScore():\n    solution = Solution()\n    nums = [10, 12, 5, 7, 3, 8, 1]\n    edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [2, 6]]\n    assert solution.minimumScore(nums, edges) == 0", "def test_minimumScore():\n    solution = Solution()\n    nums = [9, 15, 14, 7, 11, 6, 10, 3]\n    edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [2, 6], [3, 7]]\n    assert solution.minimumScore(nums, edges) == 1", "def test_minimumScore():\n    solution = Solution()\n    nums = [5, 10, 8, 4, 1, 13, 2, 11, 7]\n    edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 6], [4, 7], [5, 8]]\n    assert solution.minimumScore(nums, edges) == 0", "def test_minimumScore():\n    solution = Solution()\n    nums = [6, 2, 9, 11, 10, 3, 8, 7, 5, 4]\n    edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 6], [3, 7], [4, 8], [5, 9]]\n    assert solution.minimumScore(nums, edges) == 1", "def test_minimumScore():\n    solution = Solution()\n    nums = [13, 7, 6, 5, 2, 8, 12, 10, 3, 4, 9]\n    edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [2, 6], [3, 7], [4, 8], [5, 9], [6, 10]]\n    assert solution.minimumScore(nums, edges) == 0", "def test_minimumScore():\n    solution = Solution()\n    nums = [14, 11, 3, 6, 9, 7, 2, 5, 13, 8, 10, 4]\n    edges = [[0, 1], [0, 2], [1, 3], [2, 4], [2, 5], [3, 6], [3, 7], [4, 8], [5, 9], [6, 10], [7, 11]]\n    assert solution.minimumScore(nums, edges) == 2", "def test_minimumScore():\n    solution = Solution()\n    nums = [7, 12, 15, 3, 1, 10, 6, 11, 5, 9, 8, 2, 4]\n    edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [2, 6], [3, 7], [4, 8], [5, 9], [5, 10], [6, 11], [6, 12]]\n    assert solution.minimumScore(nums, edges) == 0", "def test_minimumScore():\n    solution = Solution()\n    nums = [16, 5, 9, 3, 12, 7, 11, 14, 6, 1, 10, 4, 2, 15]\n    edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [2, 6], [3, 7], [4, 8], [5, 9], [6, 10], [7, 11], [8, 12], [9, 13]]\n    assert solution.minimumScore(nums, edges) == 1", "def test_minimumScore():\n    solution = Solution()\n    nums = [8, 14, 7, 12, 5, 10, 3, 11, 6, 9, 2, 4, 1, 13, 15]\n    edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [2, 6], [3, 7], [4, 8], [5, 9], [5, 10], [6, 11], [6, 12], [7, 13], [8, 14]]\n    assert solution.minimumScore(nums, edges) == 0", "def test_minimumScore():\n    solution = Solution()\n    nums = [15, 1, 13, 6, 3, 11, 7, 10, 12, 8, 2, 9, 5, 14, 4, 16]\n    edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [2, 6], [3, 7], [3, 8], [4, 9], [5, 10], [6, 11], [7, 12], [8, 13], [9, 14], [10, 15]]\n    assert solution.minimumScore(nums, edges) == 2", "def test_minimumScore():\n    solution = Solution()\n    nums = [20, 13, 5, 11, 6, 2, 15, 8, 3, 12, 4, 9, 7, 14, 10, 1, 16]\n    edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [2, 6], [3, 7], [4, 8], [5, 9], [5, 10], [6, 11], [6, 12], [7, 13], [8, 14], [9, 15], [10, 16]]\n    assert solution.minimumScore(nums, edges) == 0", "def test_minimumScore():\n    solution = Solution()\n    nums = [3, 17, 8, 14, 12, 6, 9, 5, 11, 7, 1, 10, 15, 2, 4, 13, 16, 18]\n    edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [2, 6], [3, 7], [3, 8], [4, 9], [5, 10], [5, 11], [6, 12], [6, 13], [7, 14], [8, 15], [9, 16], [10, 17]]\n    assert solution.minimumScore(nums, edges) == 1", "def test_minimumScore():\n    solution = Solution()\n    nums = [19, 4, 8, 15, 7, 3, 12, 5, 10, 2, 14, 13, 6, 9, 11, 1, 17, 16, 18]\n    edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [2, 6], [3, 7], [3, 8], [4, 9], [5, 10], [5, 11], [6, 12], [6, 13], [7, 14], [8, 15], [9, 16], [10, 17], [11, 18]]\n    assert solution.minimumScore(nums, edges) == 2", "def test_minimumScore():\n    solution = Solution()\n    nums = [2, 5, 17, 8, 10, 14, 3, 9, 12, 6, 1, 13, 11, 7, 4, 15, 16, 18, 20, 19]\n    edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [2, 6], [3, 7], [3, 8], [4, 9], [4, 10], [5, 11], [6, 12], [6, 13], [7, 14], [8, 15], [9, 16], [10, 17], [11, 18], [12, 19]]\n    assert solution.minimumScore(nums, edges) == 0", "def test_minimumScore():\n    solution = Solution()\n    nums = [8, 11, 1, 5, 19, 3, 14, 12, 10, 4, 17, 6, 9, 15, 7, 13, 2, 18, 16, 20, 21]\n    edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [2, 6], [3, 7], [3, 8], [4, 9], [4, 10], [5, 11], [5, 12], [6, 13], [6, 14], [7, 15], [8, 16], [9, 17], [10, 18], [11, 19], [12, 20]]\n    assert solution.minimumScore(nums, edges) == 1", "def test_minimumScore():\n    solution = Solution()\n    nums = [7, 14, 5, 20, 3, 11, 9, 18, 13, 12, 1, 6, 4, 17, 10, 8, 2, 15, 19, 16, 21, 22]\n    edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [2, 6], [3, 7], [3, 8], [4, 9], [4, 10], [5, 11], [5, 12], [6, 13], [6, 14], [7, 15], [8, 16], [9, 17], [10, 18], [11, 19], [12, 20], [13, 21]]\n    assert solution.minimumScore(nums, edges) == 0", "def test_minimumScore():\n    solution = Solution()\n    nums = [9, 15, 6, 22, 3, 7, 11, 1, 18, 14, 4, 10, 19, 17, 5, 8, 2, 16, 12, 13, 21, 20, 23]\n    edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [2, 6], [3, 7], [3, 8], [4, 9], [4, 10], [5, 11], [5, 12], [6, 13], [6, 14], [7, 15], [8, 16], [9, 17], [10, 18], [11, 19], [12, 20], [13, 21], [14, 22]]\n    assert solution.minimumScore(nums, edges) == 2"]}
{"task_num": 2332, "task_title": "The Latest Time to Catch a Bus", "func_name": "latestTimeCatchTheBus", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\n    buses.sort()\n    passengers.sort()\n\n    if passengers[0] > buses[-1]:\n      return buses[-1]\n\n    ans = passengers[0] - 1\n    i = 0\n    j = 0\n    while i < len(buses):\n      arrived = 0\n      while arrived < capacity and j < len(passengers) and passengers[j] <= buses[i]:\n        if j > 0 and passengers[j] != passengers[j - 1] + 1:\n          ans = passengers[j] - 1\n        j += 1\n        arrived += 1\n\n      if arrived < capacity and j > 0 and passengers[j - 1] != buses[i]:\n        ans = buses[i]\n      i += 1\n\n    return ans\n", "tests": ["def test_latestTimeCatchTheBus():\n    solution = Solution()\n    assert solution.latestTimeCatchTheBus([10, 20], [2, 17, 18, 19], 2) == 16", "def test_latestTimeCatchTheBus():\n    solution = Solution()\n    assert solution.latestTimeCatchTheBus([5, 15, 30], [4, 10, 12, 25, 26], 3) == 14", "def test_latestTimeCatchTheBus():\n    solution = Solution()\n    assert solution.latestTimeCatchTheBus([3, 8, 20], [1, 2, 7, 15, 16], 2) == 6", "def test_latestTimeCatchTheBus():\n    solution = Solution()\n    assert solution.latestTimeCatchTheBus([5, 10, 15], [2, 3, 9, 14], 1) == 13", "def test_latestTimeCatchTheBus():\n    solution = Solution()\n    assert solution.latestTimeCatchTheBus([6, 9, 12], [1, 4, 5, 8, 11], 2) == 10", "def test_latestTimeCatchTheBus():\n    solution = Solution()\n    assert solution.latestTimeCatchTheBus([7, 14, 21], [6, 13, 20], 3) == 19", "def test_latestTimeCatchTheBus():\n    solution = Solution()\n    assert solution.latestTimeCatchTheBus([4, 13, 22], [3, 5, 9, 12, 18, 21], 2) == 20", "def test_latestTimeCatchTheBus():\n    solution = Solution()\n    assert solution.latestTimeCatchTheBus([8, 16], [2, 4, 6, 14], 3) == 15", "def test_latestTimeCatchTheBus():\n    solution = Solution()\n    assert solution.latestTimeCatchTheBus([9, 17, 25], [8, 11, 12, 18, 24], 2) == 23", "def test_latestTimeCatchTheBus():\n    solution = Solution()\n    assert solution.latestTimeCatchTheBus([10, 18, 22], [9, 17, 21, 23], 1) == 20", "def test_latestTimeCatchTheBus():\n    solution = Solution()\n    assert solution.latestTimeCatchTheBus([11, 15, 19], [1, 3, 14, 18], 2) == 17", "def test_latestTimeCatchTheBus():\n    solution = Solution()\n    assert solution.latestTimeCatchTheBus([5, 12], [2, 4, 6, 8, 10, 11], 2) == 9", "def test_latestTimeCatchTheBus():\n    solution = Solution()\n    assert solution.latestTimeCatchTheBus([7, 13, 20], [3, 6, 19], 1) == 18", "def test_latestTimeCatchTheBus():\n    solution = Solution()\n    assert solution.latestTimeCatchTheBus([9, 14, 19], [1, 8, 10, 12, 17], 3) == 16", "def test_latestTimeCatchTheBus():\n    solution = Solution()\n    assert solution.latestTimeCatchTheBus([6, 15], [5, 7, 13, 14], 2) == 12", "def test_latestTimeCatchTheBus():\n    solution = Solution()\n    assert solution.latestTimeCatchTheBus([5, 11, 16], [4, 10, 12, 15], 1) == 9", "def test_latestTimeCatchTheBus():\n    solution = Solution()\n    assert solution.latestTimeCatchTheBus([6, 10, 14], [2, 3, 9, 13], 2) == 8", "def test_latestTimeCatchTheBus():\n    solution = Solution()\n    assert solution.latestTimeCatchTheBus([8, 12, 18], [1, 7, 11, 17, 19], 3) == 16", "def test_latestTimeCatchTheBus():\n    solution = Solution()\n    assert solution.latestTimeCatchTheBus([4, 9, 15], [3, 5, 7, 13, 14], 2) == 8", "def test_latestTimeCatchTheBus():\n    solution = Solution()\n    assert solution.latestTimeCatchTheBus([3, 11, 20], [2, 6, 10, 12, 19], 2) == 18"]}
{"task_num": 2337, "task_title": "Move Pieces to Obtain a String", "func_name": "canChange", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def canChange(self, start: str, target: str) -> bool:\n    n = len(start)\n    i = 0\n    j = 0\n\n    while i <= n and j <= n:\n      while i < n and start[i] == '_':\n        i += 1\n      while j < n and target[j] == '_':\n        j += 1\n      if i == n or j == n:\n        return i == n and j == n\n      if start[i] != target[j]:\n        return False\n      if start[i] == 'R' and i > j:\n        return False\n      if start[i] == 'L' and i < j:\n        return False\n      i += 1\n      j += 1\n\n    return True\n", "tests": ["def test_canChange():\n    solution = Solution()\n    assert solution.canChange('R_L_', '_LR_') == True", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('_L__R_', 'L___R_') == False", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('_R__L_', '__R_L_') == False", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('L___R', '_L__R') == False", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('R__L_', '_RL__') == True", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('__R_L_', '__R__L') == True", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('LR__', '__LR') == False", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('R_L', 'RL_') == False", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('___', '___') == True", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('L_R_', 'L__R') == False", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('R_LR__', '__R_LR') == False", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('L__R_', '_L_R_') == True", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('LR__', 'LR__') == True", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('_L_R_', '_L_R_') == True", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('R__L_', '_R_L_') == True", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('L_R__', '__L_R') == False", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('_LR_', 'L_R_') == True", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('R_L_', '_R_L') == False", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('LRL_', 'L_RL') == False", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('RL__', '__RL') == False"]}
{"task_num": 2392, "task_title": "Build a Matrix With Conditions", "func_name": "buildMatrix", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\n    rowOrder = self._topologicalSort(rowConditions, k)\n    if not rowOrder:\n      return []\n\n    colOrder = self._topologicalSort(colConditions, k)\n    if not colOrder:\n      return []\n\n    ans = [[0] * k for _ in range(k)]\n    nodeToRowIndex = [0] * (k + 1)\n\n    for i, node in enumerate(rowOrder):\n      nodeToRowIndex[node] = i\n\n    for j, node in enumerate(colOrder):\n      i = nodeToRowIndex[node]\n      ans[i][j] = node\n\n    return ans\n\n  def _topologicalSort(self, conditions: List[List[int]], n: int) -> List[int]:\n    order = []\n    graph = [[] for _ in range(n + 1)]\n    inDegrees = [0] * (n + 1)\n\n    for u, v in conditions:\n      graph[u].append(v)\n      inDegrees[v] += 1\n\n    q = collections.deque([i for i in range(1, n + 1) if inDegrees[i] == 0])\n\n    while q:\n      u = q.popleft()\n      order.append(u)\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    if len(order) == n:\n      return order\n    else:\n      return []\n", "tests": ["def test_buildMatrix():\n    solution = Solution()\n    k = 3\n    rowConditions = [[1, 2], [2, 3]]\n    colConditions = [[3, 2], [2, 1]]\n    expected_output = [[0, 0, 1], [3, 0, 0], [0, 2, 0]]\n    assert solution.buildMatrix(k, rowConditions, colConditions) == expected_output", "def test_buildMatrix():\n    solution = Solution()\n    k = 4\n    rowConditions = [[1, 3], [2, 3], [4, 2]]\n    colConditions = [[1, 2], [3, 4]]\n    expected_output = [[1, 0, 0, 0], [0, 0, 0, 2], [0, 0, 3, 0], [0, 4, 0, 0]]\n    assert solution.buildMatrix(k, rowConditions, colConditions) == expected_output", "def test_buildMatrix():\n    solution = Solution()\n    k = 3\n    rowConditions = [[1, 2], [2, 3], [3, 1]]\n    colConditions = [[1, 2]]\n    expected_output = []\n    assert solution.buildMatrix(k, rowConditions, colConditions) == expected_output", "def test_buildMatrix():\n    solution = Solution()\n    k = 2\n    rowConditions = [[1, 2]]\n    colConditions = [[2, 1]]\n    expected_output = []\n    assert solution.buildMatrix(k, rowConditions, colConditions) == expected_output", "def test_buildMatrix():\n    solution = Solution()\n    k = 3\n    rowConditions = []\n    colConditions = []\n    expected_output = [[1, 0, 0], [0, 2, 0], [0, 0, 3]]\n    assert solution.buildMatrix(k, rowConditions, colConditions) == expected_output", "def test_buildMatrix():\n    solution = Solution()\n    k = 5\n    rowConditions = [[1, 2], [2, 3], [4, 5], [3, 4]]\n    colConditions = [[5, 4], [4, 3], [3, 2], [2, 1]]\n    expected_output = [[0, 0, 0, 0, 1], [0, 0, 0, 2, 0], [0, 0, 3, 0, 0], [0, 4, 0, 0, 0], [5, 0, 0, 0, 0]]\n    assert solution.buildMatrix(k, rowConditions, colConditions) == expected_output", "def test_buildMatrix():\n    solution = Solution()\n    k = 1\n    rowConditions = []\n    colConditions = []\n    expected_output = [[1]]\n    assert solution.buildMatrix(k, rowConditions, colConditions) == expected_output", "def test_buildMatrix():\n    solution = Solution()\n    k = 4\n    rowConditions = [[1, 2], [2, 3]]\n    colConditions = [[1, 2], [2, 3], [3, 1]]\n    expected_output = []\n    assert solution.buildMatrix(k, rowConditions, colConditions) == expected_output", "def test_buildMatrix():\n    solution = Solution()\n    k = 4\n    rowConditions = [[1, 2]]\n    colConditions = [[3, 4]]\n    expected_output = [[1, 0, 0, 0], [2, 0, 0, 0], [0, 3, 0, 0], [0, 0, 4, 0]]\n    assert solution.buildMatrix(k, rowConditions, colConditions) == expected_output", "def test_buildMatrix():\n    solution = Solution()\n    k = 3\n    rowConditions = [[1, 3], [3, 2]]\n    colConditions = [[2, 3], [1, 2]]\n    expected_output = [[0, 0, 1], [0, 0, 0], [2, 3, 0]]\n    assert solution.buildMatrix(k, rowConditions, colConditions) == expected_output", "def test_buildMatrix():\n    solution = Solution()\n    k = 4\n    rowConditions = [[1, 2], [2, 3], [3, 4]]\n    colConditions = [[4, 3], [3, 2], [2, 1]]\n    expected_output = [[0, 0, 0, 1], [0, 0, 2, 0], [0, 3, 0, 0], [4, 0, 0, 0]]\n    assert solution.buildMatrix(k, rowConditions, colConditions) == expected_output", "def test_buildMatrix():\n    solution = Solution()\n    k = 5\n    rowConditions = [[1, 2], [2, 3], [3, 4], [5, 1]]\n    colConditions = [[2, 3], [3, 4], [4, 5], [1, 4]]\n    expected_output = []\n    assert solution.buildMatrix(k, rowConditions, colConditions) == expected_output", "def test_buildMatrix():\n    solution = Solution()\n    k = 6\n    rowConditions = [[1, 3], [5, 6]]\n    colConditions = [[2, 4], [6, 1]]\n    expected_output = [[0, 0, 0, 0, 0, 5], [0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0], [0, 4, 0, 0, 0, 6]]\n    assert solution.buildMatrix(k, rowConditions, colConditions) == expected_output", "def test_buildMatrix():\n    solution = Solution()\n    k = 6\n    rowConditions = [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6]]\n    colConditions = [[6, 5], [5, 4], [4, 3], [3, 2], [2, 1]]\n    expected_output = [[0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 2, 0], [0, 0, 0, 3, 0, 0], [0, 0, 4, 0, 0, 0], [0, 5, 0, 0, 0, 0], [6, 0, 0, 0, 0, 0]]\n    assert solution.buildMatrix(k, rowConditions, colConditions) == expected_output", "def test_buildMatrix():\n    solution = Solution()\n    k = 4\n    rowConditions = [[1, 2], [3, 4]]\n    colConditions = [[1, 3], [2, 4]]\n    expected_output = [[1, 0, 0, 0], [0, 2, 0, 0], [0, 0, 3, 0], [0, 0, 0, 4]]\n    assert solution.buildMatrix(k, rowConditions, colConditions) == expected_output", "def test_buildMatrix():\n    solution = Solution()\n    k = 6\n    rowConditions = [[1, 2], [3, 4]]\n    colConditions = [[5, 6]]\n    expected_output = [[1, 0, 0, 0, 0, 0], [2, 0, 0, 0, 0, 0], [0, 3, 0, 0, 0, 0], [0, 4, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0], [0, 0, 0, 0, 0, 6]]\n    assert solution.buildMatrix(k, rowConditions, colConditions) == expected_output", "def test_buildMatrix():\n    solution = Solution()\n    k = 5\n    rowConditions = [[1, 2], [2, 3], [3, 1], [4, 5]]\n    colConditions = [[5, 4], [4, 3], [3, 2], [2, 1]]\n    expected_output = []\n    assert solution.buildMatrix(k, rowConditions, colConditions) == expected_output", "def test_buildMatrix():\n    solution = Solution()\n    k = 3\n    rowConditions = []\n    colConditions = []\n    expected_output = [[1, 0, 0], [0, 2, 0], [0, 0, 3]]\n    assert solution.buildMatrix(k, rowConditions, colConditions) == expected_output", "def test_buildMatrix():\n    solution = Solution()\n    k = 4\n    rowConditions = [[2, 3]]\n    colConditions = [[1, 4]]\n    expected_output = [[1, 0, 0, 0], [0, 0, 0, 2], [0, 0, 0, 3], [0, 0, 0, 4]]\n    assert solution.buildMatrix(k, rowConditions, colConditions) == expected_output", "def test_buildMatrix():\n    solution = Solution()\n    k = 3\n    rowConditions = [[3, 2], [2, 1]]\n    colConditions = [[1, 2], [2, 3]]\n    expected_output = [[3, 0, 0], [0, 2, 0], [0, 0, 1]]\n    assert solution.buildMatrix(k, rowConditions, colConditions) == expected_output"]}
{"task_num": 2437, "task_title": "Number of Valid Clock Times", "func_name": "countTime", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countTime(self, time: str) -> int:\n    ans = 1\n    if time[3] == '?':\n      ans *= 6\n    if time[4] == '?':\n      ans *= 10\n\n    if time[0] == '?' and time[1] == '?':\n      return ans * 24\n    if time[0] == '?':\n      if time[1] < '4':\n        return ans * 3\n      else:\n        return ans * 2\n    if time[1] == '?':\n      if time[0] == '2':\n        return ans * 4\n      else:\n        return ans * 10\n    return ans\n", "tests": ["def test_countTime():\n    solution = Solution()\n    assert solution.countTime('2?:?0') == 40", "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('?4:5?') == 20", "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('??:?5') == 144", "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('1?:??') == 600", "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('0?:30') == 30", "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('23:?4') == 10", "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('?2:??') == 100", "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('?5:00') == 2", "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('1?:4?') == 60", "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('2?:?9') == 30", "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('?3:1?') == 20", "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('??:00') == 24", "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('0?:?5') == 60", "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('22:??') == 100", "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('1?:?8') == 60", "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('?9:??') == 20", "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('0?:4?') == 60", "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('?0:?3') == 60", "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('1?:?9') == 60", "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('?8:??') == 20"]}
{"task_num": 2456, "task_title": "Most Popular Video Creator", "func_name": "mostPopularCreator", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Creator:\n  def __init__(self, popularity: int, videoId: str, maxView: int):\n    self.popularity = popularity\n    self.videoId = videoId\n    self.maxView = maxView\n\n\nclass Solution:\n  def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\n    ans = []\n    maxPopularity = 0\n    nameToCreator = {}\n\n    for name, id, view in zip(creators, ids, views):\n      if name not in nameToCreator:\n        nameToCreator[name] = Creator(view, id, view)\n        maxPopularity = max(maxPopularity, view)\n        continue\n      creator = nameToCreator[name]\n      creator.popularity += view\n      maxPopularity = max(maxPopularity, creator.popularity)\n      if creator.maxView < view or creator.maxView == view and creator.videoId > id:\n        creator.videoId = id\n        creator.maxView = view\n\n    for name, creator in nameToCreator.items():\n      if creator.popularity == maxPopularity:\n        ans.append([name, creator.videoId])\n\n    return ans\n", "tests": ["def test_mostPopularCreator():\n    solution = Solution()\n    creators = ['alice', 'bob', 'alice', 'alice', 'bob']\n    ids = ['a1', 'b1', 'a2', 'a3', 'b2']\n    views = [100, 200, 100, 200, 300]\n    expected_output = [['bob', 'b2'], ['alice', 'a3']]\n    assert sorted(solution.mostPopularCreator(creators, ids, views)) == sorted(expected_output)", "def test_mostPopularCreator():\n    solution = Solution()\n    creators = ['charlie', 'dave', 'charlie', 'eve', 'eve']\n    ids = ['c1', 'd1', 'c2', 'e1', 'e2']\n    views = [50, 100, 50, 200, 200]\n    expected_output = [['eve', 'e1'], ['dave', 'd1']]\n    assert sorted(solution.mostPopularCreator(creators, ids, views)) == sorted(expected_output)", "def test_mostPopularCreator():\n    solution = Solution()\n    creators = ['alice', 'bob', 'charlie', 'bob', 'alice']\n    ids = ['x1', 'y1', 'z1', 'y2', 'x2']\n    views = [300, 150, 100, 150, 300]\n    expected_output = [['alice', 'x1']]\n    assert solution.mostPopularCreator(creators, ids, views) == expected_output", "def test_mostPopularCreator():\n    solution = Solution()\n    creators = ['emma', 'emma', 'frank', 'grace']\n    ids = ['e1', 'e2', 'f1', 'g1']\n    views = [500, 400, 900, 900]\n    expected_output = [['frank', 'f1'], ['grace', 'g1']]\n    assert sorted(solution.mostPopularCreator(creators, ids, views)) == sorted(expected_output)", "def test_mostPopularCreator():\n    solution = Solution()\n    creators = ['henry', 'isla', 'jack', 'isla', 'henry']\n    ids = ['h1', 'i1', 'j1', 'i2', 'h2']\n    views = [200, 500, 300, 350, 200]\n    expected_output = [['isla', 'i1']]\n    assert solution.mostPopularCreator(creators, ids, views) == expected_output", "def test_mostPopularCreator():\n    solution = Solution()\n    creators = ['kai', 'luna', 'mia', 'mia', 'luna']\n    ids = ['k1', 'l1', 'm1', 'm2', 'l2']\n    views = [600, 700, 200, 800, 700]\n    expected_output = [['luna', 'l1'], ['mia', 'm2']]\n    assert sorted(solution.mostPopularCreator(creators, ids, views)) == sorted(expected_output)", "def test_mostPopularCreator():\n    solution = Solution()\n    creators = ['nora', 'oliver', 'nora', 'oliver', 'nora']\n    ids = ['n1', 'o1', 'n2', 'o2', 'n3']\n    views = [300, 400, 300, 500, 400]\n    expected_output = [['oliver', 'o2']]\n    assert solution.mostPopularCreator(creators, ids, views) == expected_output", "def test_mostPopularCreator():\n    solution = Solution()\n    creators = ['paul', 'quinn', 'paul', 'quinn', 'rachel']\n    ids = ['p1', 'q1', 'p2', 'q2', 'r1']\n    views = [100, 300, 100, 200, 600]\n    expected_output = [['rachel', 'r1']]\n    assert solution.mostPopularCreator(creators, ids, views) == expected_output", "def test_mostPopularCreator():\n    solution = Solution()\n    creators = ['sam', 'tina', 'sam', 'uma', 'tina']\n    ids = ['s1', 't1', 's2', 'u1', 't2']\n    views = [500, 300, 400, 200, 400]\n    expected_output = [['sam', 's1']]\n    assert solution.mostPopularCreator(creators, ids, views) == expected_output", "def test_mostPopularCreator():\n    solution = Solution()\n    creators = ['victor', 'victor', 'will', 'will', 'will']\n    ids = ['v1', 'v2', 'w1', 'w2', 'w3']\n    views = [100, 100, 200, 200, 200]\n    expected_output = [['will', 'w1']]\n    assert solution.mostPopularCreator(creators, ids, views) == expected_output", "def test_mostPopularCreator():\n    solution = Solution()\n    creators = ['xander', 'yara', 'yara', 'zane', 'xander']\n    ids = ['x1', 'y1', 'y2', 'z1', 'x2']\n    views = [300, 200, 300, 400, 300]\n    expected_output = [['xander', 'x1'], ['zane', 'z1']]\n    assert sorted(solution.mostPopularCreator(creators, ids, views)) == sorted(expected_output)", "def test_mostPopularCreator():\n    solution = Solution()\n    creators = ['amy', 'amy', 'beth', 'beth', 'chris']\n    ids = ['a1', 'a2', 'b1', 'b2', 'c1']\n    views = [350, 150, 400, 400, 700]\n    expected_output = [['chris', 'c1']]\n    assert solution.mostPopularCreator(creators, ids, views) == expected_output", "def test_mostPopularCreator():\n    solution = Solution()\n    creators = ['diana', 'edward', 'diana', 'frank', 'edward']\n    ids = ['d1', 'e1', 'd2', 'f1', 'e2']\n    views = [250, 450, 250, 300, 450]\n    expected_output = [['edward', 'e1']]\n    assert solution.mostPopularCreator(creators, ids, views) == expected_output", "def test_mostPopularCreator():\n    solution = Solution()\n    creators = ['george', 'hannah', 'george', 'hannah', 'ivan']\n    ids = ['g1', 'h1', 'g2', 'h2', 'i1']\n    views = [150, 300, 150, 300, 700]\n    expected_output = [['ivan', 'i1']]\n    assert solution.mostPopularCreator(creators, ids, views) == expected_output", "def test_mostPopularCreator():\n    solution = Solution()\n    creators = ['jake', 'kat', 'leo', 'kat', 'leo']\n    ids = ['j1', 'k1', 'l1', 'k2', 'l2']\n    views = [500, 300, 600, 300, 400]\n    expected_output = [['leo', 'l1']]\n    assert solution.mostPopularCreator(creators, ids, views) == expected_output", "def test_mostPopularCreator():\n    solution = Solution()\n    creators = ['mike', 'nina', 'mike', 'otto', 'nina']\n    ids = ['m1', 'n1', 'm2', 'o1', 'n2']\n    views = [250, 350, 250, 450, 350]\n    expected_output = [['otto', 'o1']]\n    assert solution.mostPopularCreator(creators, ids, views) == expected_output", "def test_mostPopularCreator():\n    solution = Solution()\n    creators = ['peter', 'peter', 'quincy', 'rachel', 'rachel']\n    ids = ['p1', 'p2', 'q1', 'r1', 'r2']\n    views = [100, 100, 600, 250, 250]\n    expected_output = [['quincy', 'q1']]\n    assert solution.mostPopularCreator(creators, ids, views) == expected_output", "def test_mostPopularCreator():\n    solution = Solution()\n    creators = ['sophie', 'tom', 'sophie', 'tom', 'uma']\n    ids = ['s1', 't1', 's2', 't2', 'u1']\n    views = [300, 200, 400, 200, 700]\n    expected_output = [['uma', 'u1']]\n    assert solution.mostPopularCreator(creators, ids, views) == expected_output", "def test_mostPopularCreator():\n    solution = Solution()\n    creators = ['victor', 'wade', 'xena', 'wade', 'victor']\n    ids = ['v1', 'w1', 'x1', 'w2', 'v2']\n    views = [200, 400, 800, 400, 200]\n    expected_output = [['xena', 'x1']]\n    assert solution.mostPopularCreator(creators, ids, views) == expected_output", "def test_mostPopularCreator():\n    solution = Solution()\n    creators = ['yara', 'zane', 'yara', 'zane', 'zane']\n    ids = ['y1', 'z1', 'y2', 'z2', 'z3']\n    views = [500, 300, 500, 300, 300]\n    expected_output = [['yara', 'y1']]\n    assert solution.mostPopularCreator(creators, ids, views) == expected_output"]}
{"task_num": 2462, "task_title": "Total Cost to Hire K Workers", "func_name": "totalCost", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\n    ans = 0\n    i = 0\n    j = len(costs) - 1\n    minHeapL = []\n    minHeapR = []\n\n    for _ in range(k):\n      while len(minHeapL) < candidates and i <= j:\n        heapq.heappush(minHeapL, costs[i])\n        i += 1\n      while len(minHeapR) < candidates and i <= j:\n        heapq.heappush(minHeapR, costs[j])\n        j -= 1\n      if not minHeapL:\n        ans += heapq.heappop(minHeapR)\n      elif not minHeapR:\n        ans += heapq.heappop(minHeapL)\n      elif minHeapL[0] <= minHeapR[0]:\n        ans += heapq.heappop(minHeapL)\n      else:\n        ans += heapq.heappop(minHeapR)\n\n    return ans\n", "tests": ["def test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([3, 1, 2, 4, 6, 5], 3, 2) == 6", "def test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([10, 20, 30, 1, 2, 3], 2, 3) == 3", "def test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([5], 1, 1) == 5", "def test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([9, 8, 7, 6, 5, 4, 3, 2, 1], 3, 5) == 6", "def test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([4, 9, 1, 3, 8, 2], 4, 6) == 10", "def test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([7, 3, 5, 1, 6, 4, 2], 1, 2) == 1", "def test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([10, 20, 5, 15, 25, 30], 2, 1) == 15", "def test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([4, 4, 4, 4, 4, 4], 3, 2) == 12", "def test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([9, 8, 7, 6, 5, 4, 3, 2, 1], 5, 3) == 15", "def test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([3, 2, 5, 1], 2, 1) == 3", "def test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([1, 2, 3], 2, 5) == 3", "def test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([1, 100, 1, 100, 1, 100], 3, 2) == 3", "def test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([5, 10, 3, 7, 2], 5, 3) == 27", "def test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([5, 5, 5, 5, 5], 4, 2) == 20", "def test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([7, 3, 9, 2, 6, 5, 8, 1, 4], 6, 2) == 24", "def test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([3, 1, 4, 1, 5, 9], 2, 1) == 2", "def test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([8, 6, 7, 5, 3, 0, 9], 3, 4) == 11", "def test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([10, 3, 8, 4, 7, 2, 5, 1, 6], 4, 3) == 12", "def test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([1, 100, 1, 100, 1], 1, 1) == 1", "def test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([3, 1, 3, 1, 3, 1], 3, 2) == 3"]}
{"task_num": 2467, "task_title": "Most Profitable Path in a Tree", "func_name": "mostProfitablePath", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\n    n = len(amount)\n    tree = [[] for _ in range(n)]\n    parent = [0] * n\n    aliceDist = [-1] * n\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, prev: int, d: int) -> None:\n      parent[u] = prev\n      aliceDist[u] = d\n      for v in tree[u]:\n        if aliceDist[v] == -1:\n          dfs(v, u, d + 1)\n\n    dfs(0, -1, 0)\n\n    u = bob\n    bobDist = 0\n    while u != 0:\n      if bobDist < aliceDist[u]:\n        amount[u] = 0\n      elif bobDist == aliceDist[u]:\n        amount[u] //= 2\n      u = parent[u]\n      bobDist += 1\n\n    return self._getMoney(tree, 0, -1, amount)\n\n  def _getMoney(self, tree: List[List[int]], u: int, prev: int, amount: List[int]) -> int:\n    if len(tree[u]) == 1 and tree[u][0] == prev:\n      return amount[u]\n\n    maxPath = -math.inf\n    for v in tree[u]:\n      if v != prev:\n        maxPath = max(maxPath, self._getMoney(tree, v, u, amount))\n\n    return amount[u] + maxPath\n", "tests": ["def test_mostProfitablePath():\n    solution = Solution()\n    edges = [[0, 1], [1, 2], [1, 3], [3, 4], [3, 5]]\n    bob = 4\n    amount = [5, 4, 3, 2, -10, 1]\n    assert solution.mostProfitablePath(edges, bob, amount) == 7", "def test_mostProfitablePath():\n    solution = Solution()\n    edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [2, 6]]\n    bob = 5\n    amount = [10, 5, 3, -4, 6, 8, -2]\n    assert solution.mostProfitablePath(edges, bob, amount) == 18", "def test_mostProfitablePath():\n    solution = Solution()\n    edges = [[0, 1], [0, 2], [2, 3], [2, 4]]\n    bob = 3\n    amount = [4, -5, 8, 6, -3]\n    assert solution.mostProfitablePath(edges, bob, amount) == 14", "def test_mostProfitablePath():\n    solution = Solution()\n    edges = [[0, 1], [1, 2], [1, 3], [3, 4]]\n    bob = 2\n    amount = [7, -8, 4, -6, 5]\n    assert solution.mostProfitablePath(edges, bob, amount) == 7", "def test_mostProfitablePath():\n    solution = Solution()\n    edges = [[0, 1], [0, 2], [1, 3], [3, 4], [4, 5], [4, 6]]\n    bob = 6\n    amount = [3, 2, 10, -7, 8, -5, 4]\n    assert solution.mostProfitablePath(edges, bob, amount) == 10", "def test_mostProfitablePath():\n    solution = Solution()\n    edges = [[0, 1], [1, 2], [1, 3], [3, 4], [4, 5], [5, 6]]\n    bob = 6\n    amount = [-5, 3, 4, 2, 7, -8, 6]\n    assert solution.mostProfitablePath(edges, bob, amount) == 6", "def test_mostProfitablePath():\n    solution = Solution()\n    edges = [[0, 1], [0, 2], [2, 3], [3, 4], [4, 5]]\n    bob = 5\n    amount = [6, -3, 7, -2, 5, 4]\n    assert solution.mostProfitablePath(edges, bob, amount) == 14", "def test_mostProfitablePath():\n    solution = Solution()\n    edges = [[0, 1], [1, 2], [2, 3], [2, 4], [1, 5], [5, 6]]\n    bob = 4\n    amount = [0, -1, 6, 3, -5, 2, 4]\n    assert solution.mostProfitablePath(edges, bob, amount) == 10", "def test_mostProfitablePath():\n    solution = Solution()\n    edges = [[0, 1], [1, 2], [1, 3], [0, 4], [4, 5], [5, 6]]\n    bob = 3\n    amount = [1, -2, 3, 8, -4, 5, 7]\n    assert solution.mostProfitablePath(edges, bob, amount) == 14", "def test_mostProfitablePath():\n    solution = Solution()\n    edges = [[0, 1], [1, 2], [1, 3], [3, 4], [3, 5], [5, 6]]\n    bob = 6\n    amount = [2, 3, -6, 5, -4, 7, 1]\n    assert solution.mostProfitablePath(edges, bob, amount) == 11", "def test_mostProfitablePath():\n    solution = Solution()\n    edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [4, 6]]\n    bob = 6\n    amount = [1, -3, 4, 6, -2, 7, 5]\n    assert solution.mostProfitablePath(edges, bob, amount) == 11", "def test_mostProfitablePath():\n    solution = Solution()\n    edges = [[0, 1], [1, 2], [2, 3], [0, 4], [4, 5], [5, 6]]\n    bob = 2\n    amount = [3, -1, 5, 8, -2, 4, 6]\n    assert solution.mostProfitablePath(edges, bob, amount) == 16", "def test_mostProfitablePath():\n    solution = Solution()\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4], [0, 5], [5, 6], [5, 7]]\n    bob = 7\n    amount = [2, -3, 5, -6, 4, 8, -1, 3]\n    assert solution.mostProfitablePath(edges, bob, amount) == 9", "def test_mostProfitablePath():\n    solution = Solution()\n    edges = [[0, 1], [1, 2], [1, 3], [3, 4], [4, 5], [0, 6]]\n    bob = 5\n    amount = [7, -4, 2, 3, 6, -9, 5]\n    assert solution.mostProfitablePath(edges, bob, amount) == 12", "def test_mostProfitablePath():\n    solution = Solution()\n    edges = [[0, 1], [1, 2], [0, 3], [3, 4], [4, 5], [4, 6]]\n    bob = 6\n    amount = [0, 3, -5, 4, -2, 6, 7]\n    assert solution.mostProfitablePath(edges, bob, amount) == 13", "def test_mostProfitablePath():\n    solution = Solution()\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4], [2, 5], [5, 6]]\n    bob = 3\n    amount = [5, -2, 7, 1, -4, 6, 8]\n    assert solution.mostProfitablePath(edges, bob, amount) == 14", "def test_mostProfitablePath():\n    solution = Solution()\n    edges = [[0, 1], [0, 2], [2, 3], [2, 4], [4, 5], [1, 6]]\n    bob = 6\n    amount = [3, 8, -1, 5, -7, 4, 2]\n    assert solution.mostProfitablePath(edges, bob, amount) == 8", "def test_mostProfitablePath():\n    solution = Solution()\n    edges = [[0, 1], [0, 2], [1, 3], [3, 4], [2, 5], [5, 6], [6, 7]]\n    bob = 7\n    amount = [1, -3, 4, 2, 8, -5, 3, 7]\n    assert solution.mostProfitablePath(edges, bob, amount) == 15", "def test_mostProfitablePath():\n    solution = Solution()\n    edges = [[0, 1], [1, 2], [1, 3], [3, 4], [4, 5], [5, 6], [3, 7]]\n    bob = 6\n    amount = [2, -4, 5, 3, -8, 6, 1, 7]\n    assert solution.mostProfitablePath(edges, bob, amount) == 10", "def test_mostProfitablePath():\n    solution = Solution()\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4], [0, 5], [5, 6], [6, 7]]\n    bob = 4\n    amount = [10, -5, 6, 1, 2, -3, 9, 8]\n    assert solution.mostProfitablePath(edges, bob, amount) == 20"]}
{"task_num": 2499, "task_title": "Minimum Total Cost to Make Arrays Unequal", "func_name": "minimumTotalCost", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\n    n = len(nums1)\n    ans = 0\n    maxFreq = 0\n    maxFreqNum = 0\n    shouldBeSwapped = 0\n    conflictedNumCount = [0] * (n + 1)\n\n    for i, (num1, num2) in enumerate(zip(nums1, nums2)):\n      if num1 == num2:\n        conflictedNum = num1\n        conflictedNumCount[conflictedNum] += 1\n        if conflictedNumCount[conflictedNum] > maxFreq:\n          maxFreq = conflictedNumCount[conflictedNum]\n          maxFreqNum = conflictedNum\n        shouldBeSwapped += 1\n        ans += i\n\n    for i, (num1, num2) in enumerate(zip(nums1, nums2)):\n      if maxFreq * 2 <= shouldBeSwapped:\n        break\n      if num1 == num2:\n        continue\n\n      if num1 == maxFreqNum or num2 == maxFreqNum:\n        continue\n      shouldBeSwapped += 1\n      ans += i\n\n    if maxFreq * 2 > shouldBeSwapped:\n      return -1\n    else:\n      return ans\n", "tests": ["def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([1, 2, 2], [2, 1, 2]) == 1", "def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([3, 3, 1], [1, 1, 3]) == -1", "def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([1, 2, 3], [3, 2, 1]) == 0", "def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([4, 4, 4, 2], [4, 4, 2, 4]) == 6", "def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([5, 1, 5, 1], [5, 5, 1, 1]) == 6", "def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([2, 3, 4, 2], [2, 4, 3, 2]) == 3", "def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([1, 2, 1, 3], [1, 1, 2, 3]) == 3", "def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([6, 6, 6, 6], [6, 6, 6, 6]) == -1", "def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([1, 1, 2, 3], [3, 2, 1, 1]) == 2", "def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([0, 0, 1, 1], [1, 0, 0, 1]) == 1", "def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([4, 5, 6, 7], [7, 6, 5, 4]) == 0", "def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([9, 8, 7, 9], [9, 7, 8, 9]) == -1", "def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([3, 2, 3, 2], [2, 3, 3, 2]) == 1", "def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([10, 10, 10, 5], [5, 10, 10, 10]) == 3", "def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([5, 6, 5, 6], [6, 5, 6, 5]) == 0", "def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([2, 2, 2, 3], [3, 3, 2, 2]) == 4", "def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([1, 4, 1, 4], [4, 1, 4, 1]) == 0", "def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([3, 3, 2, 4], [4, 3, 3, 2]) == 2", "def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([7, 8, 9, 7], [9, 8, 7, 7]) == 3", "def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([8, 5, 8, 5], [8, 8, 5, 5]) == -1"]}
{"task_num": 2503, "task_title": "Maximum Number of Points From Grid Queries", "func_name": "maxPoints", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, query: int):\n    self.queryIndex = queryIndex\n    self.query = query\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.query\n\n\nclass Solution:\n  def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    ans = [0] * len(queries)\n    minHeap = [(grid[0][0], 0, 0)]\n    seen = {(0, 0)}\n    accumulate = 0\n\n    for queryIndex, query in sorted([IndexedQuery(i, query) for i, query in enumerate(queries)], key=lambda iq: iq.query):\n      while minHeap:\n        val, i, j = heapq.heappop(minHeap)\n        if val >= query:\n          heapq.heappush(minHeap, (val, i, j))\n          break\n        accumulate += 1\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if (x, y) in seen:\n            continue\n          heapq.heappush(minHeap, (grid[x][y], x, y))\n          seen.add((x, y))\n      ans[queryIndex] = accumulate\n\n    return ans\n", "tests": ["def test_maxPoints():\n    solution = Solution()\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    queries = [0, 5, 10]\n    expected_output = [0, 5, 9]\n    assert solution.maxPoints(grid, queries) == expected_output", "def test_maxPoints():\n    solution = Solution()\n    grid = [[5, 1, 7], [6, 2, 8], [9, 4, 3]]\n    queries = [3, 5, 7]\n    expected_output = [3, 6, 9]\n    assert solution.maxPoints(grid, queries) == expected_output", "def test_maxPoints():\n    solution = Solution()\n    grid = [[10, 11], [12, 13]]\n    queries = [9, 10, 11, 14]\n    expected_output = [0, 1, 2, 4]\n    assert solution.maxPoints(grid, queries) == expected_output", "def test_maxPoints():\n    solution = Solution()\n    grid = [[3, 3, 4], [2, 2, 2], [1, 1, 1]]\n    queries = [2, 3, 5]\n    expected_output = [0, 4, 9]\n    assert solution.maxPoints(grid, queries) == expected_output", "def test_maxPoints():\n    solution = Solution()\n    grid = [[8, 7, 6, 5], [7, 6, 5, 4], [6, 5, 4, 3], [5, 4, 3, 2]]\n    queries = [1, 4, 6, 9]\n    expected_output = [0, 12, 16, 16]\n    assert solution.maxPoints(grid, queries) == expected_output", "def test_maxPoints():\n    solution = Solution()\n    grid = [[2, 1], [3, 4]]\n    queries = [1, 2, 3, 4, 5]\n    expected_output = [0, 1, 3, 4, 4]\n    assert solution.maxPoints(grid, queries) == expected_output", "def test_maxPoints():\n    solution = Solution()\n    grid = [[1, 2, 1], [1, 1, 1], [1, 1, 1]]\n    queries = [1, 1.5, 2, 3]\n    expected_output = [0, 5, 8, 9]\n    assert solution.maxPoints(grid, queries) == expected_output", "def test_maxPoints():\n    solution = Solution()\n    grid = [[8, 6, 4], [7, 5, 3], [9, 1, 2]]\n    queries = [3, 5, 7, 10]\n    expected_output = [1, 4, 7, 9]\n    assert solution.maxPoints(grid, queries) == expected_output", "def test_maxPoints():\n    solution = Solution()\n    grid = [[4, 5, 6], [3, 2, 1], [7, 8, 9]]\n    queries = [1, 2, 4, 6]\n    expected_output = [0, 0, 3, 4]\n    assert solution.maxPoints(grid, queries) == expected_output", "def test_maxPoints():\n    solution = Solution()\n    grid = [[10, 10, 10], [10, 10, 10], [10, 10, 10]]\n    queries = [5, 10, 15]\n    expected_output = [9, 9, 9]\n    assert solution.maxPoints(grid, queries) == expected_output", "def test_maxPoints():\n    solution = Solution()\n    grid = [[1, 3, 5], [7, 9, 11], [13, 15, 17]]\n    queries = [0, 4, 8, 12]\n    expected_output = [0, 2, 5, 6]\n    assert solution.maxPoints(grid, queries) == expected_output", "def test_maxPoints():\n    solution = Solution()\n    grid = [[2, 4], [6, 8]]\n    queries = [1, 3, 5, 7, 9]\n    expected_output = [0, 1, 2, 3, 4]\n    assert solution.maxPoints(grid, queries) == expected_output", "def test_maxPoints():\n    solution = Solution()\n    grid = [[3, 6, 9], [8, 5, 2], [7, 4, 1]]\n    queries = [0, 3, 6, 10]\n    expected_output = [0, 1, 3, 9]\n    assert solution.maxPoints(grid, queries) == expected_output", "def test_maxPoints():\n    solution = Solution()\n    grid = [[9, 8, 7], [6, 5, 4], [3, 2, 1]]\n    queries = [5, 6, 7, 10]\n    expected_output = [4, 6, 8, 9]\n    assert solution.maxPoints(grid, queries) == expected_output", "def test_maxPoints():\n    solution = Solution()\n    grid = [[1, 2, 1, 2], [2, 1, 2, 1], [1, 2, 1, 2]]\n    queries = [0, 1, 2, 3]\n    expected_output = [0, 8, 12, 12]\n    assert solution.maxPoints(grid, queries) == expected_output", "def test_maxPoints():\n    solution = Solution()\n    grid = [[4, 7, 8], [1, 6, 5], [2, 3, 9]]\n    queries = [3, 5, 7, 8]\n    expected_output = [3, 5, 7, 8]\n    assert solution.maxPoints(grid, queries) == expected_output", "def test_maxPoints():\n    solution = Solution()\n    grid = [[6, 5, 4], [3, 2, 1], [6, 5, 4]]\n    queries = [2, 4, 5, 7]\n    expected_output = [1, 4, 5, 9]\n    assert solution.maxPoints(grid, queries) == expected_output", "def test_maxPoints():\n    solution = Solution()\n    grid = [[11, 13, 15], [14, 12, 10], [16, 14, 12]]\n    queries = [10, 13, 17]\n    expected_output = [0, 4, 9]\n    assert solution.maxPoints(grid, queries) == expected_output", "def test_maxPoints():\n    solution = Solution()\n    grid = [[9, 7, 5], [8, 6, 4], [7, 5, 3]]\n    queries = [4, 6, 8, 12]\n    expected_output = [1, 4, 9, 9]\n    assert solution.maxPoints(grid, queries) == expected_output", "def test_maxPoints():\n    solution = Solution()\n    grid = [[2, 3, 1], [1, 4, 2], [5, 6, 7]]\n    queries = [1, 3, 5, 8]\n    expected_output = [0, 3, 5, 9]\n    assert solution.maxPoints(grid, queries) == expected_output"]}
{"task_num": 2508, "task_title": "Add Edges to Make Degrees of All Nodes Even", "func_name": "isPossible", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isPossible(self, n: int, edges: List[List[int]]) -> bool:\n    graph = [set() for _ in range(n)]\n\n    for u, v in edges:\n      graph[u - 1].add(v - 1)\n      graph[v - 1].add(u - 1)\n\n    oddNodes = [i for i, neighbor in enumerate(graph) if len(neighbor) & 1]\n    if not oddNodes:\n      return True\n    if len(oddNodes) == 2:\n      a, b = oddNodes\n      return any(a not in graph[i] and b not in graph[i] for i in range(n))\n    if len(oddNodes) == 4:\n      a, b, c, d = oddNodes\n      return (b not in graph[a] and d not in graph[c]) or (c not in graph[a] and d not in graph[b]) or (d not in graph[a] and c not in graph[b])\n    return False\n", "tests": ["def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(5, [[1, 2], [2, 3], [3, 4], [4, 5]]) == True", "def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(4, [[1, 2], [2, 3], [3, 4], [4, 1], [1, 3]]) == False", "def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(3, [[1, 2], [2, 3]]) == True", "def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(6, [[1, 2], [2, 3], [4, 5], [5, 6]]) == False", "def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(2, [[1, 2]]) == True", "def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(5, [[1, 2], [2, 3], [3, 4], [4, 1], [2, 5], [3, 5]]) == True", "def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(7, [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 1], [2, 5]]) == True", "def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(4, [[1, 2], [2, 3], [3, 1], [1, 4], [2, 4]]) == True", "def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(8, [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8]]) == False", "def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(5, [[1, 2], [2, 3], [3, 4], [4, 5], [5, 1], [1, 3], [2, 4]]) == False", "def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(6, [[1, 2], [3, 4], [5, 6]]) == True", "def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(3, [[1, 2], [2, 3], [3, 1], [1, 1]]) == False", "def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(6, [[1, 2], [2, 3], [3, 1], [4, 5], [5, 6]]) == False", "def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(4, [[1, 2], [2, 3], [3, 4], [4, 1], [1, 3], [2, 4]]) == True", "def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(5, [[1, 2], [2, 3], [3, 4], [4, 5], [5, 1], [1, 3], [3, 5]]) == True", "def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(7, [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 1], [1, 5]]) == True", "def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(4, [[1, 2], [3, 4]]) == False", "def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(3, [[1, 2], [2, 3], [1, 3], [2, 2]]) == False", "def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(5, [[1, 2], [3, 4], [4, 5], [1, 3], [2, 5]]) == True", "def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(6, [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 1]]) == True"]}
{"task_num": 2523, "task_title": "Closest Prime Numbers in Range", "func_name": "closestPrimes", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def closestPrimes(self, left: int, right: int) -> List[int]:\n    isPrime = self._sieveEratosthenes(right + 1)\n    primes=[]\n    for i in range(left, right+1):\n      if isPrime[i]:\n        primes.append(i)\n\n    if len(primes) < 2:\n      return [-1, -1]\n\n    minDiff = math.inf\n    num1 = -1\n    num2 = -1\n\n    for a, b in zip(primes, primes[1:]):\n      diff = b - a\n      if diff < minDiff:\n        minDiff = diff\n        num1 = a\n        num2 = b\n\n    return [num1, num2]\n\n  def _sieveEratosthenes(self, n: int) -> List[bool]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return isPrime\n", "tests": ["def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(10, 30) == [11, 13]", "def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(14, 16) == [-1, -1]", "def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(1, 2) == [-1, -1]", "def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(20, 50) == [29, 31]", "def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(22, 29) == [23, 29]", "def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(50, 60) == [53, 59]", "def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(100, 110) == [101, 103]", "def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(5, 5) == [-1, -1]", "def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(13, 19) == [17, 19]", "def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(90, 100) == [97, 97]", "def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(2, 2) == [-1, -1]", "def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(3, 10) == [3, 5]", "def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(31, 37) == [31, 37]", "def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(1, 1) == [-1, -1]", "def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(24, 28) == [-1, -1]", "def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(17, 19) == [17, 19]", "def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(70, 80) == [71, 73]", "def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(60, 70) == [61, 67]", "def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(40, 42) == [41, 41]", "def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(48, 60) == [53, 59]"]}
{"task_num": 2532, "task_title": "Time to Cross a Bridge", "func_name": "findCrossingTime", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n    ans = 0\n    leftBridgeQueue = [(-leftToRight - rightToLeft, -i) for i, (leftToRight, pickOld, rightToLeft, pickNew) in enumerate(time)]\n    rightBridgeQueue = []\n    leftWorkers = []\n    rightWorkers = []\n\n    heapq.heapify(leftBridgeQueue)\n\n    while n > 0 or rightBridgeQueue or rightWorkers:\n      while leftWorkers and leftWorkers[0][0] <= ans:\n        i = heapq.heappop(leftWorkers)[1]\n        heapq.heappush(leftBridgeQueue, (-time[i][0] - time[i][2], -i))\n      while rightWorkers and rightWorkers[0][0] <= ans:\n        i = heapq.heappop(rightWorkers)[1]\n        heapq.heappush(rightBridgeQueue, (-time[i][0] - time[i][2], -i))\n      if rightBridgeQueue:\n        i = -heapq.heappop(rightBridgeQueue)[1]\n        ans += time[i][2]\n        heapq.heappush(leftWorkers, (ans + time[i][3], i))\n      elif leftBridgeQueue and n > 0:\n        i = -heapq.heappop(leftBridgeQueue)[1]\n        ans += time[i][0]\n        heapq.heappush(rightWorkers, (ans + time[i][1], i))\n        n -= 1\n      else:\n        if leftWorkers and n > 0:\n          ans1=leftWorkers[0][0]\n        else:\n          ans1=math.inf\n        if rightWorkers:\n          ans2=rightWorkers[0][0]\n        else:\n          ans2=math.inf\n        ans=min(ans1,ans2)\n\n    return ans", "tests": ["def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(3, 2, [[2, 4, 3, 2], [3, 1, 4, 2]]) == 16", "def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(5, 3, [[1, 2, 1, 2], [2, 3, 2, 3], [3, 2, 3, 1]]) == 14", "def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(2, 1, [[1, 1, 1, 1]]) == 6", "def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(4, 2, [[5, 5, 5, 5], [1, 1, 1, 1]]) == 25", "def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(1, 3, [[2, 3, 2, 1], [1, 2, 1, 3], [3, 1, 3, 2]]) == 4", "def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(6, 2, [[4, 2, 4, 3], [2, 3, 2, 4]]) == 32", "def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(3, 4, [[3, 3, 3, 3], [2, 2, 2, 2], [1, 1, 1, 1], [4, 4, 4, 4]]) == 15", "def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(5, 3, [[2, 1, 3, 1], [4, 2, 2, 3], [1, 3, 2, 1]]) == 19", "def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(2, 2, [[1, 3, 2, 2], [3, 2, 1, 3]]) == 10", "def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(7, 3, [[3, 2, 3, 2], [2, 3, 2, 3], [4, 1, 4, 1]]) == 39", "def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(4, 2, [[2, 2, 3, 3], [1, 1, 4, 2]]) == 17", "def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(3, 5, [[1, 2, 1, 2], [2, 1, 2, 1], [3, 3, 3, 3], [4, 4, 4, 4], [5, 5, 5, 5]]) == 9", "def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(8, 4, [[3, 1, 2, 2], [2, 2, 1, 3], [1, 3, 3, 1], [4, 2, 4, 2]]) == 36", "def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(2, 3, [[4, 4, 1, 1], [1, 1, 2, 2], [3, 3, 3, 3]]) == 11", "def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(5, 2, [[6, 2, 5, 3], [2, 5, 3, 2]]) == 37", "def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(6, 3, [[2, 3, 1, 4], [3, 2, 2, 1], [4, 1, 3, 2]]) == 28", "def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(3, 2, [[5, 3, 4, 2], [2, 2, 3, 3]]) == 22", "def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(4, 5, [[1, 2, 1, 2], [1, 1, 2, 1], [2, 1, 1, 2], [2, 2, 2, 2], [3, 3, 3, 3]]) == 12", "def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(1, 4, [[3, 2, 3, 2], [2, 1, 2, 1], [1, 1, 1, 1], [4, 2, 4, 2]]) == 4", "def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(7, 3, [[5, 2, 5, 2], [3, 4, 3, 4], [2, 3, 2, 3]]) == 47"]}
{"task_num": 2577, "task_title": "Minimum Time to Visit a Cell In a Grid", "func_name": "minimumTime", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumTime(self, grid: List[List[int]]) -> int:\n    if grid[0][1] > 1 and grid[1][0] > 1:\n      return -1\n\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    minHeap = [(0, 0, 0)]\n    seen = {(0, 0)}\n\n    while minHeap:\n      time, i, j = heapq.heappop(minHeap)\n      if i == m - 1 and j == n - 1:\n        return time\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if (x, y) in seen:\n          continue\n        if (grid[x][y] - time) % 2 == 0:\n          extraWait = 1\n        else:\n          extraWait = 0\n        nextTime = max(time + 1, grid[x][y] + extraWait)\n        heapq.heappush(minHeap, (nextTime, x, y))\n        seen.add((x, y))\n", "tests": ["def test_minimumTime():\n    solution = Solution()\n    grid = [[0, 2], [1, 3]]\n    assert solution.minimumTime(grid) == 3", "def test_minimumTime():\n    solution = Solution()\n    grid = [[0, 4, 5], [2, 3, 6], [1, 2, 7]]\n    assert solution.minimumTime(grid) == 6", "def test_minimumTime():\n    solution = Solution()\n    grid = [[0, 3, 1], [2, 1, 2], [1, 2, 0]]\n    assert solution.minimumTime(grid) == 4", "def test_minimumTime():\n    solution = Solution()\n    grid = [[0, 1, 2], [1, 2, 3], [2, 3, 4]]\n    assert solution.minimumTime(grid) == 4", "def test_minimumTime():\n    solution = Solution()\n    grid = [[0, 100], [1, 2]]\n    assert solution.minimumTime(grid) == 102", "def test_minimumTime():\n    solution = Solution()\n    grid = [[0, 1], [2, 0]]\n    assert solution.minimumTime(grid) == 3", "def test_minimumTime():\n    solution = Solution()\n    grid = [[0, 2, 1], [2, 3, 2], [1, 4, 0]]\n    assert solution.minimumTime(grid) == 5", "def test_minimumTime():\n    solution = Solution()\n    grid = [[0, 3, 4], [2, 1, 5], [3, 2, 0]]\n    assert solution.minimumTime(grid) == 5", "def test_minimumTime():\n    solution = Solution()\n    grid = [[0, 2, 3], [2, 5, 4], [3, 4, 1]]\n    assert solution.minimumTime(grid) == 7", "def test_minimumTime():\n    solution = Solution()\n    grid = [[0, 1, 3], [2, 2, 2], [4, 3, 1]]\n    assert solution.minimumTime(grid) == 5", "def test_minimumTime():\n    solution = Solution()\n    grid = [[0, 5, 6], [1, 2, 7], [2, 3, 4]]\n    assert solution.minimumTime(grid) == 8", "def test_minimumTime():\n    solution = Solution()\n    grid = [[0, 3, 2], [3, 4, 3], [2, 5, 0]]\n    assert solution.minimumTime(grid) == 6", "def test_minimumTime():\n    solution = Solution()\n    grid = [[0, 1, 5], [1, 4, 3], [6, 2, 2]]\n    assert solution.minimumTime(grid) == 6", "def test_minimumTime():\n    solution = Solution()\n    grid = [[0, 1, 4], [2, 2, 5], [3, 6, 1]]\n    assert solution.minimumTime(grid) == 5", "def test_minimumTime():\n    solution = Solution()\n    grid = [[0, 2, 3], [1, 5, 4], [2, 4, 2]]\n    assert solution.minimumTime(grid) == 6", "def test_minimumTime():\n    solution = Solution()\n    grid = [[0, 3, 4], [2, 3, 6], [1, 5, 1]]\n    assert solution.minimumTime(grid) == 7", "def test_minimumTime():\n    solution = Solution()\n    grid = [[0, 2, 2], [3, 5, 1], [4, 3, 0]]\n    assert solution.minimumTime(grid) == 5", "def test_minimumTime():\n    solution = Solution()\n    grid = [[0, 6, 5], [1, 4, 3], [3, 2, 1]]\n    assert solution.minimumTime(grid) == 7", "def test_minimumTime():\n    solution = Solution()\n    grid = [[0, 1, 3], [4, 2, 6], [1, 5, 2]]\n    assert solution.minimumTime(grid) == 6", "def test_minimumTime():\n    solution = Solution()\n    grid = [[0, 3, 1], [2, 4, 2], [5, 3, 1]]\n    assert solution.minimumTime(grid) == 5"]}
{"task_num": 2601, "task_title": "Prime Subtraction Operation", "func_name": "primeSubOperation", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def primeSubOperation(self, nums: List[int]) -> bool:\n    kMax = 1000\n    primes = self._sieveEratosthenes(kMax)\n\n    prevNum = 0\n    for num in nums:\n      i = bisect.bisect_left(primes, num - prevNum)\n      if i > 0:\n        num -= primes[i - 1]\n      if num <= prevNum:\n        return False\n      prevNum = num\n\n    return True\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return [i for i in range(n) if isPrime[i]]\n", "tests": ["def test_primeSubOperation():\n    solution = Solution()\n    assert solution.primeSubOperation([5, 10, 15]) == True", "def test_primeSubOperation():\n    solution = Solution()\n    assert solution.primeSubOperation([20, 10, 30]) == False", "def test_primeSubOperation():\n    solution = Solution()\n    assert solution.primeSubOperation([2, 3, 5, 7, 11]) == True", "def test_primeSubOperation():\n    solution = Solution()\n    assert solution.primeSubOperation([4, 4, 4, 4]) == False", "def test_primeSubOperation():\n    solution = Solution()\n    assert solution.primeSubOperation([1, 2, 4, 6]) == True", "def test_primeSubOperation():\n    solution = Solution()\n    assert solution.primeSubOperation([15, 13, 9, 7]) == False", "def test_primeSubOperation():\n    solution = Solution()\n    assert solution.primeSubOperation([10, 20, 30, 25]) == False", "def test_primeSubOperation():\n    solution = Solution()\n    assert solution.primeSubOperation([7, 14, 21, 28]) == True", "def test_primeSubOperation():\n    solution = Solution()\n    assert solution.primeSubOperation([8, 5, 9, 12]) == False", "def test_primeSubOperation():\n    solution = Solution()\n    assert solution.primeSubOperation([2, 3, 6, 11, 17]) == True", "def test_primeSubOperation():\n    solution = Solution()\n    assert solution.primeSubOperation([50, 45, 40, 35]) == False", "def test_primeSubOperation():\n    solution = Solution()\n    assert solution.primeSubOperation([3, 6, 10, 15, 21]) == True", "def test_primeSubOperation():\n    solution = Solution()\n    assert solution.primeSubOperation([9, 8, 7, 6]) == False", "def test_primeSubOperation():\n    solution = Solution()\n    assert solution.primeSubOperation([5, 7, 10, 8]) == False", "def test_primeSubOperation():\n    solution = Solution()\n    assert solution.primeSubOperation([30, 60, 90, 120]) == True", "def test_primeSubOperation():\n    solution = Solution()\n    assert solution.primeSubOperation([5, 3, 4, 2]) == False", "def test_primeSubOperation():\n    solution = Solution()\n    assert solution.primeSubOperation([11, 23, 34, 44, 50]) == True", "def test_primeSubOperation():\n    solution = Solution()\n    assert solution.primeSubOperation([50, 47, 45, 40, 38]) == False", "def test_primeSubOperation():\n    solution = Solution()\n    assert solution.primeSubOperation([6, 13, 19, 25, 29]) == True", "def test_primeSubOperation():\n    solution = Solution()\n    assert solution.primeSubOperation([31, 29, 27, 25, 23]) == False"]}
{"task_num": 2603, "task_title": "Collect Coins in a Tree", "func_name": "collectTheCoins", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def collectTheCoins(self, coins: List[int], edges: List[List[int]]) -> int:\n    n = len(coins)\n    tree = [set() for _ in range(n)]\n    leavesToBeRemoved = collections.deque()\n\n    for u, v in edges:\n      tree[u].add(v)\n      tree[v].add(u)\n\n    for u in range(n):\n      while len(tree[u]) == 1 and coins[u] == 0:\n        v = tree[u].pop()\n        tree[v].remove(u)\n        u = v\n      if len(tree[u]) == 1:\n        leavesToBeRemoved.append(u)\n\n    for _ in range(2):\n      for _ in range(len(leavesToBeRemoved)):\n        u = leavesToBeRemoved.popleft()\n        if tree[u]:\n          v = tree[u].pop()\n          tree[v].remove(u)\n          if len(tree[v]) == 1:\n            leavesToBeRemoved.append(v)\n\n    return sum(len(children) for children in tree)\n", "tests": ["def test_collectTheCoins():\n    solution = Solution()\n    coins = [1, 0, 1, 0, 1]\n    edges = [[0, 1], [1, 2], [1, 3], [3, 4]]\n    assert solution.collectTheCoins(coins, edges) == 2", "def test_collectTheCoins():\n    solution = Solution()\n    coins = [0, 1, 0, 1, 0, 1]\n    edges = [[0, 1], [1, 2], [1, 3], [3, 4], [4, 5]]\n    assert solution.collectTheCoins(coins, edges) == 4", "def test_collectTheCoins():\n    solution = Solution()\n    coins = [1, 1, 0, 0, 0]\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4]]\n    assert solution.collectTheCoins(coins, edges) == 2", "def test_collectTheCoins():\n    solution = Solution()\n    coins = [0, 0, 1, 0, 1, 0]\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5]]\n    assert solution.collectTheCoins(coins, edges) == 4", "def test_collectTheCoins():\n    solution = Solution()\n    coins = [1, 0, 0, 1, 0, 0, 1]\n    edges = [[0, 1], [1, 2], [2, 3], [2, 4], [4, 5], [5, 6]]\n    assert solution.collectTheCoins(coins, edges) == 6", "def test_collectTheCoins():\n    solution = Solution()\n    coins = [1, 1, 1, 0, 0]\n    edges = [[0, 1], [0, 2], [0, 3], [2, 4]]\n    assert solution.collectTheCoins(coins, edges) == 4", "def test_collectTheCoins():\n    solution = Solution()\n    coins = [0, 0, 0, 1, 0, 1]\n    edges = [[0, 1], [1, 2], [2, 3], [2, 4], [4, 5]]\n    assert solution.collectTheCoins(coins, edges) == 4", "def test_collectTheCoins():\n    solution = Solution()\n    coins = [1, 0, 0, 0, 1, 1, 0, 0]\n    edges = [[0, 1], [1, 2], [2, 3], [1, 4], [4, 5], [5, 6], [6, 7]]\n    assert solution.collectTheCoins(coins, edges) == 6", "def test_collectTheCoins():\n    solution = Solution()\n    coins = [1, 0, 1, 0, 1, 0, 0, 0]\n    edges = [[0, 1], [0, 2], [0, 3], [3, 4], [4, 5], [5, 6], [6, 7]]\n    assert solution.collectTheCoins(coins, edges) == 4", "def test_collectTheCoins():\n    solution = Solution()\n    coins = [0, 1, 0, 1, 0, 1, 0, 1]\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7]]\n    assert solution.collectTheCoins(coins, edges) == 8", "def test_collectTheCoins():\n    solution = Solution()\n    coins = [1, 0, 0, 1, 0, 1, 1, 0, 0]\n    edges = [[0, 1], [1, 2], [2, 3], [2, 4], [4, 5], [5, 6], [3, 7], [7, 8]]\n    assert solution.collectTheCoins(coins, edges) == 8", "def test_collectTheCoins():\n    solution = Solution()\n    coins = [0, 1, 0, 1, 1, 0, 0, 1, 0]\n    edges = [[0, 1], [1, 2], [1, 3], [3, 4], [4, 5], [4, 6], [5, 7], [6, 8]]\n    assert solution.collectTheCoins(coins, edges) == 10", "def test_collectTheCoins():\n    solution = Solution()\n    coins = [1, 0, 0, 0, 1, 0, 1, 0, 1, 0]\n    edges = [[0, 1], [0, 2], [2, 3], [2, 4], [3, 5], [4, 6], [6, 7], [6, 8], [8, 9]]\n    assert solution.collectTheCoins(coins, edges) == 8", "def test_collectTheCoins():\n    solution = Solution()\n    coins = [0, 1, 1, 0, 0, 1, 0, 1, 0, 1]\n    edges = [[0, 1], [1, 2], [1, 3], [3, 4], [3, 5], [5, 6], [5, 7], [7, 8], [8, 9]]\n    assert solution.collectTheCoins(coins, edges) == 12", "def test_collectTheCoins():\n    solution = Solution()\n    coins = [1, 0, 0, 0, 0, 0, 1, 0, 1, 1]\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9]]\n    assert solution.collectTheCoins(coins, edges) == 10", "def test_collectTheCoins():\n    solution = Solution()\n    coins = [0, 0, 1, 1, 0, 0, 1, 1, 0, 0]\n    edges = [[0, 1], [1, 2], [1, 3], [3, 4], [3, 5], [5, 6], [5, 7], [7, 8], [7, 9]]\n    assert solution.collectTheCoins(coins, edges) == 10", "def test_collectTheCoins():\n    solution = Solution()\n    coins = [1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [4, 7], [7, 8], [8, 9], [9, 10]]\n    assert solution.collectTheCoins(coins, edges) == 12", "def test_collectTheCoins():\n    solution = Solution()\n    coins = [1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]\n    edges = [[0, 1], [1, 2], [2, 3], [2, 4], [4, 5], [5, 6], [5, 7], [6, 8], [8, 9], [9, 10], [10, 11]]\n    assert solution.collectTheCoins(coins, edges) == 12", "def test_collectTheCoins():\n    solution = Solution()\n    coins = [0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1]\n    edges = [[0, 1], [1, 2], [1, 3], [3, 4], [3, 5], [5, 6], [6, 7], [6, 8], [8, 9], [9, 10], [10, 11]]\n    assert solution.collectTheCoins(coins, edges) == 14", "def test_collectTheCoins():\n    solution = Solution()\n    coins = [1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1]\n    edges = [[0, 1], [1, 2], [2, 3], [2, 4], [4, 5], [5, 6], [4, 7], [7, 8], [8, 9], [9, 10], [10, 11], [11, 12]]\n    assert solution.collectTheCoins(coins, edges) == 14"]}
{"task_num": 2653, "task_title": "Sliding Subarray Beauty", "func_name": "getSubarrayBeauty", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\n    ans = []\n    count = [0] * 50\n\n    for i, num in enumerate(nums):\n      if num < 0:\n        count[num + 50] += 1\n      if i - k >= 0 and nums[i - k] < 0:\n        count[nums[i - k] + 50] -= 1\n      if i + 1 >= k:\n        ans.append(self._getXthSmallestNum(count, x))\n\n    return ans\n\n  def _getXthSmallestNum(self, count: List[int], x: int) -> int:\n    prefix = 0\n    for i in range(50):\n      prefix += count[i]\n      if prefix >= x:\n        return i - 50\n    return 0\n", "tests": ["def test_getSubarrayBeauty():\n    solution = Solution()\n    assert solution.getSubarrayBeauty([-3, -1, -2, 2, -4, 3], 3, 2) == [-2, -2, -4, 0]", "def test_getSubarrayBeauty():\n    solution = Solution()\n    assert solution.getSubarrayBeauty([5, -6, 7, -8, 9, -10], 2, 1) == [-6, -8, -8, -10, -10]", "def test_getSubarrayBeauty():\n    solution = Solution()\n    assert solution.getSubarrayBeauty([1, 2, 3, 4, 5], 4, 2) == [0, 0]", "def test_getSubarrayBeauty():\n    solution = Solution()\n    assert solution.getSubarrayBeauty([-1, -2, -3, -4, -5], 5, 3) == [-3]", "def test_getSubarrayBeauty():\n    solution = Solution()\n    assert solution.getSubarrayBeauty([0, -1, -2, 0, -3, 0, 0, -4], 3, 1) == [-1, -2, -2, -3, 0, -4]", "def test_getSubarrayBeauty():\n    solution = Solution()\n    assert solution.getSubarrayBeauty([-5, 3, -2, 4, 0, -1, -3, 2], 4, 2) == [-2, 0, -1, -1, -1]", "def test_getSubarrayBeauty():\n    solution = Solution()\n    assert solution.getSubarrayBeauty([-3, -1, 0, 1, 2, -2, -4], 3, 1) == [-3, -1, -2, -2, -4]", "def test_getSubarrayBeauty():\n    solution = Solution()\n    assert solution.getSubarrayBeauty([1, -2, -3, 4, 5, -6], 5, 3) == [-3, 0]", "def test_getSubarrayBeauty():\n    solution = Solution()\n    assert solution.getSubarrayBeauty([2, -1, -3, 5, -5, 6, -7], 3, 2) == [-3, -3, -5, -5, -7]", "def test_getSubarrayBeauty():\n    solution = Solution()\n    assert solution.getSubarrayBeauty([-1, 1, -2, 2, -3, 3, -4], 4, 2) == [-2, -2, -3, -3]", "def test_getSubarrayBeauty():\n    solution = Solution()\n    assert solution.getSubarrayBeauty([0, 0, 0, -1, -2, -3, -4], 3, 1) == [0, -1, -2, -3, -4]", "def test_getSubarrayBeauty():\n    solution = Solution()\n    assert solution.getSubarrayBeauty([-10, -20, 0, 5, -30, -40], 4, 1) == [-10, -20, -30]", "def test_getSubarrayBeauty():\n    solution = Solution()\n    assert solution.getSubarrayBeauty([4, -4, -1, 0, -2, 1, 3], 3, 2) == [-4, -1, -2, -2, 0]", "def test_getSubarrayBeauty():\n    solution = Solution()\n    assert solution.getSubarrayBeauty([-8, 2, -9, 3, -7, 4, 0], 5, 3) == [-8, -9, -9]", "def test_getSubarrayBeauty():\n    solution = Solution()\n    assert solution.getSubarrayBeauty([3, -6, 1, -7, 2, -5, -8, 4], 4, 3) == [-6, -7, -7, -8, -8]", "def test_getSubarrayBeauty():\n    solution = Solution()\n    assert solution.getSubarrayBeauty([-10, 5, -10, 5, -10, 5, -10], 3, 1) == [-10, -10, -10, -10, -10]", "def test_getSubarrayBeauty():\n    solution = Solution()\n    assert solution.getSubarrayBeauty([7, -3, 9, -4, 0, -2], 2, 1) == [-3, -4, -4, -2, -2]", "def test_getSubarrayBeauty():\n    solution = Solution()\n    assert solution.getSubarrayBeauty([-100, 50, 0, -50, 100], 3, 1) == [-100, -50, -50]", "def test_getSubarrayBeauty():\n    solution = Solution()\n    assert solution.getSubarrayBeauty([6, -1, -5, -3, 2, -2], 4, 2) == [-3, -3, -5]", "def test_getSubarrayBeauty():\n    solution = Solution()\n    assert solution.getSubarrayBeauty([-1, -2, 3, 4, -5, -6, 7, 8], 5, 3) == [-2, 0, -5, -5]"]}
{"task_num": 2662, "task_title": "Minimum Cost of a Path With Special Roads", "func_name": "minimumCost", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\n    return self.dijkstra(specialRoads, *start, *target)\n\n  def dijkstra(self, specialRoads: List[List[int]], srcX: int, srcY: int, dstX: int, dstY: int) -> int:\n    n = len(specialRoads)\n    dist = [math.inf] * n\n    minHeap = []\n\n    for u, (x1, y1, _, _, cost) in enumerate(specialRoads):\n      d = abs(x1 - srcX) + abs(y1 - srcY) + cost\n      dist[u] = d\n      heapq.heappush(minHeap, (dist[u], u))\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      _, _, ux2, uy2, _ = specialRoads[u]\n      for v in range(n):\n        if v == u:\n          continue\n        vx1, vy1, _, _, vcost = specialRoads[v]\n        newDist = d + abs(vx1 - ux2) + abs(vy1 - uy2) + vcost\n        if newDist < dist[v]:\n          dist[v] = newDist\n          heapq.heappush(minHeap, (dist[v], v))\n\n    ans = abs(dstX - srcX) + abs(dstY - srcY)\n    for u in range(n):\n      _, _, x2, y2, _ = specialRoads[u]\n      ans = min(ans, dist[u] + abs(dstX - x2) + abs(dstY - y2))\n\n    return ans\n", "tests": ["def test_minimumCost():\n    solution = Solution()\n    start = [0, 0]\n    target = [5, 5]\n    specialRoads = [[0, 0, 2, 2, 1], [2, 2, 5, 5, 1]]\n    assert solution.minimumCost(start, target, specialRoads) == 2", "def test_minimumCost():\n    solution = Solution()\n    start = [1, 1]\n    target = [10, 10]\n    specialRoads = [[1, 1, 3, 3, 2], [3, 3, 6, 6, 2], [6, 6, 10, 10, 2]]\n    assert solution.minimumCost(start, target, specialRoads) == 6", "def test_minimumCost():\n    solution = Solution()\n    start = [2, 3]\n    target = [7, 8]\n    specialRoads = []\n    assert solution.minimumCost(start, target, specialRoads) == 10", "def test_minimumCost():\n    solution = Solution()\n    start = [0, 0]\n    target = [4, 4]\n    specialRoads = [[0, 0, 2, 2, 1], [2, 2, 4, 4, 3], [0, 0, 3, 3, 2], [3, 3, 4, 4, 1]]\n    assert solution.minimumCost(start, target, specialRoads) == 4", "def test_minimumCost():\n    solution = Solution()\n    start = [5, 5]\n    target = [8, 8]\n    specialRoads = [[5, 5, 6, 6, 5], [6, 6, 7, 7, 5], [7, 7, 8, 8, 5]]\n    assert solution.minimumCost(start, target, specialRoads) == 6", "def test_minimumCost():\n    solution = Solution()\n    start = [1, 1]\n    target = [9, 9]\n    specialRoads = [[1, 1, 4, 4, 2], [4, 4, 7, 7, 2], [7, 7, 9, 9, 5], [1, 1, 5, 5, 3], [5, 5, 9, 9, 3]]\n    assert solution.minimumCost(start, target, specialRoads) == 7", "def test_minimumCost():\n    solution = Solution()\n    start = [3, 3]\n    target = [3, 3]\n    specialRoads = [[3, 3, 5, 5, 1], [5, 5, 7, 7, 1]]\n    assert solution.minimumCost(start, target, specialRoads) == 0", "def test_minimumCost():\n    solution = Solution()\n    start = [0, 0]\n    target = [3, 3]\n    specialRoads = [[0, 0, 1, 1, 5], [1, 1, 2, 2, 5], [2, 2, 3, 3, 5]]\n    assert solution.minimumCost(start, target, specialRoads) == 6", "def test_minimumCost():\n    solution = Solution()\n    start = [0, 0]\n    target = [6, 6]\n    specialRoads = [[0, 0, 3, 3, 2], [3, 3, 0, 0, 2], [3, 3, 6, 6, 2]]\n    assert solution.minimumCost(start, target, specialRoads) == 4", "def test_minimumCost():\n    solution = Solution()\n    start = [2, 2]\n    target = [5, 5]\n    specialRoads = [[1, 1, 4, 4, 10], [4, 4, 5, 5, 10]]\n    assert solution.minimumCost(start, target, specialRoads) == 6", "def test_minimumCost():\n    solution = Solution()\n    start = [0, 0]\n    target = [4, 4]\n    specialRoads = [[0, 0, 1, 1, 2], [1, 1, 2, 2, 2], [2, 2, 4, 4, 2], [0, 0, 3, 3, 4]]\n    assert solution.minimumCost(start, target, specialRoads) == 6", "def test_minimumCost():\n    solution = Solution()\n    start = [1, 1]\n    target = [4, 4]\n    specialRoads = [[1, 1, 5, 5, 2], [2, 2, 3, 3, 1]]\n    assert solution.minimumCost(start, target, specialRoads) == 6", "def test_minimumCost():\n    solution = Solution()\n    start = [0, 0]\n    target = [10, 10]\n    specialRoads = [[0, 0, 10, 10, 5], [5, 5, 10, 10, 1]]\n    assert solution.minimumCost(start, target, specialRoads) == 5", "def test_minimumCost():\n    solution = Solution()\n    start = [2, 2]\n    target = [8, 8]\n    specialRoads = [[2, 2, 4, 4, 3], [4, 4, 6, 6, 5], [6, 6, 8, 8, 2]]\n    assert solution.minimumCost(start, target, specialRoads) == 12", "def test_minimumCost():\n    solution = Solution()\n    start = [0, 0]\n    target = [5, 5]\n    specialRoads = [[0, 0, 1, 1, 2], [1, 1, 3, 3, 10], [3, 3, 5, 5, 1]]\n    assert solution.minimumCost(start, target, specialRoads) == 10", "def test_minimumCost():\n    solution = Solution()\n    start = [1, 1]\n    target = [8, 8]\n    specialRoads = [[2, 2, 4, 4, 10], [5, 5, 7, 7, 10]]\n    assert solution.minimumCost(start, target, specialRoads) == 14", "def test_minimumCost():\n    solution = Solution()\n    start = [0, 0]\n    target = [6, 6]\n    specialRoads = [[0, 0, 3, 3, 3], [3, 3, 6, 6, 2], [0, 0, 6, 6, 8]]\n    assert solution.minimumCost(start, target, specialRoads) == 5", "def test_minimumCost():\n    solution = Solution()\n    start = [0, 0]\n    target = [4, 4]\n    specialRoads = [[0, 0, 2, 2, 1], [2, 2, 0, 0, 1], [2, 2, 4, 4, 1]]\n    assert solution.minimumCost(start, target, specialRoads) == 3", "def test_minimumCost():\n    solution = Solution()\n    start = [0, 0]\n    target = [5, 5]\n    specialRoads = [[0, 0, 3, 3, 3], [3, 3, 1, 1, 1], [3, 3, 5, 5, 1]]\n    assert solution.minimumCost(start, target, specialRoads) == 5", "def test_minimumCost():\n    solution = Solution()\n    start = [2, 2]\n    target = [8, 8]\n    specialRoads = [[4, 4, 6, 6, 1], [6, 6, 8, 8, 1]]\n    assert solution.minimumCost(start, target, specialRoads) == 12"]}
{"task_num": 2663, "task_title": "Lexicographically Smallest Beautiful String", "func_name": "smallestBeautifulString", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def smallestBeautifulString(self, s: str, k: int) -> str:\n    chars = list(s)\n\n    for i in reversed(range(len(chars))):\n      chars[i] = chr(ord(chars[i]) + 1)\n      while self._containsPalindrome(chars, i):\n        chars[i] = chr(ord(chars[i]) + 1)\n      if chars[i] < chr(ord('a') + k):\n        return self._changeSuffix(chars, i + 1)\n\n    return ''\n\n  def _containsPalindrome(self, chars: List[str], i: int) -> bool:\n    return (i > 0 and chars[i] == chars[i - 1]) or (i > 1 and chars[i] == chars[i - 2])\n\n  def _changeSuffix(self, chars: List[str], i: int) -> str:\n    for j in range(i, len(chars)):\n      chars[j] = 'a'\n      while self._containsPalindrome(chars, j):\n        chars[j] = chr(ord(chars[j]) + 1)\n    return ''.join(chars)\n", "tests": ["def test_smallestBeautifulString():\n    solution = Solution()\n    assert solution.smallestBeautifulString('ab', 3) == 'ac'", "def test_smallestBeautifulString():\n    solution = Solution()\n    assert solution.smallestBeautifulString('abc', 4) == 'abd'", "def test_smallestBeautifulString():\n    solution = Solution()\n    assert solution.smallestBeautifulString('cba', 3) == ''", "def test_smallestBeautifulString():\n    solution = Solution()\n    assert solution.smallestBeautifulString('aab', 3) == 'aac'", "def test_smallestBeautifulString():\n    solution = Solution()\n    assert solution.smallestBeautifulString('zzz', 26) == ''", "def test_smallestBeautifulString():\n    solution = Solution()\n    assert solution.smallestBeautifulString('aza', 3) == 'baa'", "def test_smallestBeautifulString():\n    solution = Solution()\n    assert solution.smallestBeautifulString('abac', 4) == 'abca'", "def test_smallestBeautifulString():\n    solution = Solution()\n    assert solution.smallestBeautifulString('abcd', 5) == 'abce'", "def test_smallestBeautifulString():\n    solution = Solution()\n    assert solution.smallestBeautifulString('baba', 3) == 'baca'", "def test_smallestBeautifulString():\n    solution = Solution()\n    assert solution.smallestBeautifulString('aaa', 2) == ''", "def test_smallestBeautifulString():\n    solution = Solution()\n    assert solution.smallestBeautifulString('aabb', 3) == 'aabc'", "def test_smallestBeautifulString():\n    solution = Solution()\n    assert solution.smallestBeautifulString('xyz', 5) == 'xza'", "def test_smallestBeautifulString():\n    solution = Solution()\n    assert solution.smallestBeautifulString('ababab', 3) == 'abacaa'", "def test_smallestBeautifulString():\n    solution = Solution()\n    assert solution.smallestBeautifulString('aacc', 3) == 'aacb'", "def test_smallestBeautifulString():\n    solution = Solution()\n    assert solution.smallestBeautifulString('bcac', 3) == 'bcba'", "def test_smallestBeautifulString():\n    solution = Solution()\n    assert solution.smallestBeautifulString('abcabc', 4) == 'abcabd'", "def test_smallestBeautifulString():\n    solution = Solution()\n    assert solution.smallestBeautifulString('baaac', 3) == 'baaca'", "def test_smallestBeautifulString():\n    solution = Solution()\n    assert solution.smallestBeautifulString('cab', 4) == 'cba'", "def test_smallestBeautifulString():\n    solution = Solution()\n    assert solution.smallestBeautifulString('ccc', 5) == 'cda'", "def test_smallestBeautifulString():\n    solution = Solution()\n    assert solution.smallestBeautifulString('aac', 4) == 'aad'"]}
{"task_num": 2672, "task_title": "Number of Adjacent Elements With the Same Color", "func_name": "colorTheArray", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\n    ans = []\n    arr = [0] * n\n    sameColors = 0\n\n    for i, color in queries:\n      if i + 1 < n:\n        if arr[i + 1] > 0 and arr[i + 1] == arr[i]:\n          sameColors -= 1\n        if arr[i + 1] == color:\n          sameColors += 1\n      if i > 0:\n        if arr[i - 1] > 0 and arr[i - 1] == arr[i]:\n          sameColors -= 1\n        if arr[i - 1] == color:\n          sameColors += 1\n      arr[i] = color\n      ans.append(sameColors)\n\n    return ans\n", "tests": ["def test_colorTheArray():\n    solution = Solution()\n    assert solution.colorTheArray(5, [[0, 1], [1, 1], [2, 2], [3, 2], [4, 2]]) == [0, 1, 0, 1, 2]", "def test_colorTheArray():\n    solution = Solution()\n    assert solution.colorTheArray(4, [[0, 1], [1, 2], [2, 1], [3, 1], [1, 1]]) == [0, 0, 0, 1, 2]", "def test_colorTheArray():\n    solution = Solution()\n    assert solution.colorTheArray(3, [[0, 2], [1, 2], [2, 3], [1, 3], [0, 3]]) == [0, 1, 0, 1, 2]", "def test_colorTheArray():\n    solution = Solution()\n    assert solution.colorTheArray(6, [[0, 3], [5, 3], [1, 3], [2, 3], [4, 3], [3, 3]]) == [0, 0, 1, 2, 2, 3]", "def test_colorTheArray():\n    solution = Solution()\n    assert solution.colorTheArray(7, [[6, 1], [4, 2], [5, 2], [0, 1], [3, 1], [2, 1], [1, 1]]) == [0, 0, 1, 1, 1, 2, 3]", "def test_colorTheArray():\n    solution = Solution()\n    assert solution.colorTheArray(5, [[0, 4], [2, 4], [2, 5], [3, 5], [1, 5]]) == [0, 0, 0, 1, 2]", "def test_colorTheArray():\n    solution = Solution()\n    assert solution.colorTheArray(8, [[0, 2], [1, 2], [5, 3], [4, 3], [3, 3], [6, 4], [7, 4]]) == [0, 1, 1, 2, 1, 1, 2]", "def test_colorTheArray():\n    solution = Solution()\n    assert solution.colorTheArray(10, [[0, 1], [2, 1], [4, 2], [3, 2], [5, 1], [7, 1], [9, 1], [6, 1], [8, 1]]) == [0, 0, 0, 1, 0, 0, 0, 0, 0]", "def test_colorTheArray():\n    solution = Solution()\n    assert solution.colorTheArray(6, [[5, 2], [4, 2], [0, 3], [3, 3], [2, 3], [1, 3]]) == [0, 1, 1, 1, 1, 2]", "def test_colorTheArray():\n    solution = Solution()\n    assert solution.colorTheArray(4, [[0, 5], [1, 5], [2, 6], [3, 6], [2, 5]]) == [0, 1, 1, 2, 1]", "def test_colorTheArray():\n    solution = Solution()\n    assert solution.colorTheArray(9, [[8, 1], [7, 2], [6, 2], [5, 3], [4, 3], [3, 4], [2, 4], [1, 4], [0, 4]]) == [0, 0, 1, 1, 2, 2, 1, 1, 1]", "def test_colorTheArray():\n    solution = Solution()\n    assert solution.colorTheArray(5, [[1, 1], [0, 1], [3, 2], [2, 2], [4, 2]]) == [0, 1, 1, 2, 2]", "def test_colorTheArray():\n    solution = Solution()\n    assert solution.colorTheArray(7, [[0, 1], [1, 2], [2, 2], [3, 3], [4, 3], [5, 2], [6, 2]]) == [0, 0, 1, 1, 2, 2, 3]", "def test_colorTheArray():\n    solution = Solution()\n    assert solution.colorTheArray(8, [[3, 3], [2, 3], [1, 2], [0, 2], [4, 4], [5, 4], [6, 5], [7, 5]]) == [0, 1, 1, 2, 2, 3, 3, 4]", "def test_colorTheArray():\n    solution = Solution()\n    assert solution.colorTheArray(6, [[0, 1], [1, 2], [2, 1], [3, 1], [4, 2], [5, 2]]) == [0, 0, 0, 1, 1, 2]", "def test_colorTheArray():\n    solution = Solution()\n    assert solution.colorTheArray(5, [[4, 1], [3, 1], [2, 1], [1, 1], [0, 1]]) == [0, 1, 2, 3, 4]", "def test_colorTheArray():\n    solution = Solution()\n    assert solution.colorTheArray(10, [[9, 3], [8, 2], [7, 2], [6, 1], [5, 1], [4, 4], [3, 4], [2, 5], [1, 5], [0, 5]]) == [0, 0, 1, 1, 1, 0, 1, 0, 1, 2]", "def test_colorTheArray():\n    solution = Solution()\n    assert solution.colorTheArray(6, [[1, 1], [0, 2], [2, 2], [3, 3], [4, 3], [5, 3]]) == [0, 0, 0, 0, 1, 2]", "def test_colorTheArray():\n    solution = Solution()\n    assert solution.colorTheArray(4, [[3, 2], [2, 2], [1, 3], [0, 3]]) == [0, 1, 1, 2]", "def test_colorTheArray():\n    solution = Solution()\n    assert solution.colorTheArray(7, [[0, 4], [6, 4], [1, 4], [5, 4], [2, 4], [4, 4], [3, 4]]) == [0, 0, 1, 1, 2, 3, 6]"]}
{"task_num": 2684, "task_title": "Maximum Number of Moves in a Grid", "func_name": "maxMoves", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxMoves(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n\n    for j in range(n - 2, -1, -1):\n      for i in range(m):\n        if grid[i][j + 1] > grid[i][j]:\n          dp[i][j] = 1 + dp[i][j + 1]\n        if i > 0 and grid[i - 1][j + 1] > grid[i][j]:\n          dp[i][j] = max(dp[i][j], 1 + dp[i - 1][j + 1])\n        if i + 1 < m and grid[i + 1][j + 1] > grid[i][j]:\n          dp[i][j] = max(dp[i][j], 1 + dp[i + 1][j + 1])\n\n    return max(dp[i][0] for i in range(m))\n", "tests": ["def test_maxMoves():\n    solution = Solution()\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    assert solution.maxMoves(grid) == 2", "def test_maxMoves():\n    solution = Solution()\n    grid = [[10, 11, 12], [3, 2, 13], [6, 15, 7]]\n    assert solution.maxMoves(grid) == 2", "def test_maxMoves():\n    solution = Solution()\n    grid = [[9, 8, 7], [6, 7, 8], [5, 6, 7]]\n    assert solution.maxMoves(grid) == 0", "def test_maxMoves():\n    solution = Solution()\n    grid = [[1, 100, 2], [3, 4, 5], [6, 7, 8]]\n    assert solution.maxMoves(grid) == 1", "def test_maxMoves():\n    solution = Solution()\n    grid = [[3, 2, 1], [1, 2, 3], [2, 3, 4]]\n    assert solution.maxMoves(grid) == 1", "def test_maxMoves():\n    solution = Solution()\n    grid = [[1, 2, 10], [2, 3, 4], [3, 1, 5]]\n    assert solution.maxMoves(grid) == 2", "def test_maxMoves():\n    solution = Solution()\n    grid = [[5, 4, 3], [6, 7, 1], [7, 8, 9]]\n    assert solution.maxMoves(grid) == 1", "def test_maxMoves():\n    solution = Solution()\n    grid = [[2, 3, 4], [1, 5, 6], [0, 7, 8]]\n    assert solution.maxMoves(grid) == 2", "def test_maxMoves():\n    solution = Solution()\n    grid = [[10, 1, 2], [9, 3, 4], [8, 5, 6]]\n    assert solution.maxMoves(grid) == 1", "def test_maxMoves():\n    solution = Solution()\n    grid = [[5, 1, 6], [3, 10, 7], [4, 2, 8]]\n    assert solution.maxMoves(grid) == 1", "def test_maxMoves():\n    solution = Solution()\n    grid = [[1, 2, 1], [2, 3, 2], [1, 2, 1]]\n    assert solution.maxMoves(grid) == 1", "def test_maxMoves():\n    solution = Solution()\n    grid = [[1, 3, 5], [2, 4, 1], [1, 2, 3]]\n    assert solution.maxMoves(grid) == 2", "def test_maxMoves():\n    solution = Solution()\n    grid = [[10, 20, 30], [5, 15, 25], [1, 10, 20]]\n    assert solution.maxMoves(grid) == 2", "def test_maxMoves():\n    solution = Solution()\n    grid = [[7, 6, 5], [3, 2, 1], [8, 9, 10]]\n    assert solution.maxMoves(grid) == 1", "def test_maxMoves():\n    solution = Solution()\n    grid = [[1, 4, 7], [2, 5, 6], [3, 8, 9]]\n    assert solution.maxMoves(grid) == 2", "def test_maxMoves():\n    solution = Solution()\n    grid = [[4, 3, 2], [5, 6, 7], [1, 2, 3]]\n    assert solution.maxMoves(grid) == 1", "def test_maxMoves():\n    solution = Solution()\n    grid = [[1, 2, 3, 4], [4, 5, 6, 7], [7, 8, 9, 10]]\n    assert solution.maxMoves(grid) == 3", "def test_maxMoves():\n    solution = Solution()\n    grid = [[3, 1, 2, 1], [2, 3, 4, 5], [6, 5, 4, 3]]\n    assert solution.maxMoves(grid) == 2", "def test_maxMoves():\n    solution = Solution()\n    grid = [[1, 2], [3, 4], [5, 6]]\n    assert solution.maxMoves(grid) == 1", "def test_maxMoves():\n    solution = Solution()\n    grid = [[1, 9, 2], [8, 3, 7], [4, 5, 6]]\n    assert solution.maxMoves(grid) == 1"]}
{"task_num": 2685, "task_title": "Count the Number of Complete Components", "func_name": "countCompleteComponents", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n    self.nodeCount = [1] * n\n    self.edgeCount = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    self.edgeCount[i] += 1\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n      self.edgeCount[j] += self.edgeCount[i]\n      self.nodeCount[j] += self.nodeCount[i]\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n      self.edgeCount[i] += self.edgeCount[j]\n      self.nodeCount[i] += self.nodeCount[j]\n    else:\n      self.id[i] = j\n      self.edgeCount[j] += self.edgeCount[i]\n      self.nodeCount[j] += self.nodeCount[i]\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n  def isComplete(self, u):\n    return self.nodeCount[u] * (self.nodeCount[u] - 1) // 2 == self.edgeCount[u]\n\n\nclass Solution:\n  def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\n    ans = 0\n    uf = UnionFind(n)\n    parents = set()\n\n    for u, v in edges:\n      uf.unionByRank(u, v)\n\n    for i in range(n):\n      parent = uf.find(i)\n      if parent not in parents and uf.isComplete(parent):\n        ans += 1\n        parents.add(parent)\n\n    return ans\n", "tests": ["def test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(4, [[0, 1], [1, 2], [2, 0], [1, 3]]) == 0", "def test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(5, [[0, 1], [1, 2], [3, 4]]) == 1", "def test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(6, [[0, 1], [1, 2], [2, 0], [3, 4], [4, 5], [5, 3]]) == 2", "def test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(3, [[0, 1], [1, 2]]) == 0", "def test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(4, [[0, 1], [2, 3]]) == 2", "def test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(7, [[0, 1], [1, 2], [2, 0], [3, 4], [5, 6]]) == 2", "def test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(8, [[0, 1], [1, 2], [2, 3], [3, 0], [4, 5], [6, 7]]) == 2", "def test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(5, [[0, 1], [1, 0], [2, 3], [3, 2], [2, 4], [4, 2]]) == 1", "def test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(6, [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 0]]) == 1", "def test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(5, [[0, 1], [1, 2], [3, 4]]) == 0", "def test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(4, [[0, 1], [1, 2], [2, 3], [3, 0], [0, 2], [1, 3]]) == 1", "def test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(9, [[0, 1], [1, 2], [2, 0], [3, 4], [5, 6], [6, 7], [7, 5], [8, 5]]) == 2", "def test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(10, [[0, 1], [1, 2], [2, 0], [3, 4], [5, 6], [6, 7], [7, 8], [8, 9]]) == 1", "def test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(8, [[0, 1], [1, 2], [2, 3], [4, 5], [5, 6], [6, 4], [7, 7]]) == 2", "def test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(5, [[0, 1], [1, 2], [2, 0], [3, 4], [0, 4]]) == 0", "def test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(7, [[0, 1], [0, 2], [1, 2], [3, 4], [4, 5], [5, 3], [6, 6]]) == 3", "def test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(6, [[0, 1], [2, 3], [3, 4], [4, 2], [0, 3]]) == 0", "def test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(7, [[0, 1], [1, 2], [2, 0], [3, 4], [4, 5], [5, 3], [6, 3], [6, 4]]) == 1", "def test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(5, [[0, 1], [1, 2], [2, 3], [3, 4], [4, 0], [0, 2], [1, 3]]) == 1", "def test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(9, [[0, 1], [1, 2], [2, 0], [3, 4], [4, 5], [5, 3], [6, 7], [7, 8], [8, 6]]) == 3"]}
{"task_num": 2699, "task_title": "Modify Graph Edge Weights", "func_name": "modifiedGraphEdges", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\n\nclass Solution:\n  def modifiedGraphEdges(self, n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:\n    kMax = 2_000_000_000\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      if w == -1:\n        continue\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    distToDestination = self._dijkstra(graph, source, destination)\n    if distToDestination < target:\n      return []\n    if distToDestination == target:\n      for edge in edges:\n        if edge[2] == -1:\n          edge[2] = kMax\n      return edges\n\n    for i, (u, v, w) in enumerate(edges):\n      if w != -1:\n        continue\n      edges[i][2] = 1\n      graph[u].append((v, 1))\n      graph[v].append((u, 1))\n      distToDestination = self._dijkstra(graph, source, destination)\n      if distToDestination <= target:\n        edges[i][2] += target - distToDestination\n        for j in range(i + 1, len(edges)):\n          if edges[j][2] == -1:\n            edges[j][2] = kMax\n        return edges\n\n    return []\n\n  def _dijkstra(self, graph: List[List[int]], src: int, dst: int) -> int:\n    dist = [math.inf] * len(graph)\n    minHeap = []\n    dist[src] = 0\n    heapq.heappush(minHeap, (dist[src], src))\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist[dst]\n", "tests": ["def test_modifiedGraphEdges():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, -1], [1, 2, 2], [2, 3, 3], [0, 3, -1]]\n    source = 0\n    destination = 3\n    target = 6\n    assert solution.modifiedGraphEdges(n, edges, source, destination, target) == [[0, 1, 1], [1, 2, 2], [2, 3, 3], [0, 3, 1]]", "def test_modifiedGraphEdges():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 2], [0, 2, -1], [1, 2, -1], [2, 3, 4], [3, 4, -1]]\n    source = 0\n    destination = 4\n    target = 10\n    assert solution.modifiedGraphEdges(n, edges, source, destination, target) == [[0, 1, 2], [0, 2, 1], [1, 2, 1], [2, 3, 4], [3, 4, 2]]", "def test_modifiedGraphEdges():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, -1], [1, 2, -1], [0, 2, 3]]\n    source = 0\n    destination = 2\n    target = 5\n    assert solution.modifiedGraphEdges(n, edges, source, destination, target) == [[0, 1, 1], [1, 2, 1], [0, 2, 3]]", "def test_modifiedGraphEdges():\n    solution = Solution()\n    n = 6\n    edges = [[0, 1, -1], [1, 2, -1], [2, 3, 2], [3, 4, 3], [4, 5, -1], [0, 5, -1]]\n    source = 0\n    destination = 5\n    target = 8\n    assert solution.modifiedGraphEdges(n, edges, source, destination, target) == [[0, 1, 1], [1, 2, 1], [2, 3, 2], [3, 4, 3], [4, 5, 1], [0, 5, 2000000000]]", "def test_modifiedGraphEdges():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 4], [1, 2, -1], [2, 3, -1], [0, 3, -1]]\n    source = 0\n    destination = 3\n    target = 10\n    assert solution.modifiedGraphEdges(n, edges, source, destination, target) == [[0, 1, 4], [1, 2, 3], [2, 3, 3], [0, 3, 2000000000]]", "def test_modifiedGraphEdges():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 2], [1, 2, -1], [0, 2, -1]]\n    source = 0\n    destination = 2\n    target = 4\n    assert solution.modifiedGraphEdges(n, edges, source, destination, target) == [[0, 1, 2], [1, 2, 2], [0, 2, 2000000000]]", "def test_modifiedGraphEdges():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, -1], [1, 2, 5], [2, 3, 1], [3, 4, -1], [0, 4, -1]]\n    source = 0\n    destination = 4\n    target = 9\n    assert solution.modifiedGraphEdges(n, edges, source, destination, target) == [[0, 1, 1], [1, 2, 5], [2, 3, 1], [3, 4, 2], [0, 4, 2000000000]]", "def test_modifiedGraphEdges():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 3], [1, 2, -1], [2, 3, 2], [0, 3, -1]]\n    source = 0\n    destination = 3\n    target = 8\n    assert solution.modifiedGraphEdges(n, edges, source, destination, target) == [[0, 1, 3], [1, 2, 3], [2, 3, 2], [0, 3, 2000000000]]", "def test_modifiedGraphEdges():\n    solution = Solution()\n    n = 6\n    edges = [[0, 1, -1], [1, 2, 2], [2, 3, 3], [3, 4, -1], [4, 5, 4], [0, 5, -1]]\n    source = 0\n    destination = 5\n    target = 12\n    assert solution.modifiedGraphEdges(n, edges, source, destination, target) == [[0, 1, 1], [1, 2, 2], [2, 3, 3], [3, 4, 2], [4, 5, 4], [0, 5, 2000000000]]", "def test_modifiedGraphEdges():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, -1], [1, 2, 1], [0, 2, 5]]\n    source = 0\n    destination = 2\n    target = 6\n    assert solution.modifiedGraphEdges(n, edges, source, destination, target) == [[0, 1, 1], [1, 2, 1], [0, 2, 5]]", "def test_modifiedGraphEdges():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 2], [1, 2, 3], [2, 3, -1], [3, 4, -1], [0, 4, 10]]\n    source = 0\n    destination = 4\n    target = 12\n    assert solution.modifiedGraphEdges(n, edges, source, destination, target) == [[0, 1, 2], [1, 2, 3], [2, 3, 3], [3, 4, 4], [0, 4, 10]]", "def test_modifiedGraphEdges():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, -1], [1, 2, -1], [2, 3, 1], [0, 3, 10]]\n    source = 0\n    destination = 3\n    target = 7\n    assert solution.modifiedGraphEdges(n, edges, source, destination, target) == [[0, 1, 3], [1, 2, 3], [2, 3, 1], [0, 3, 10]]", "def test_modifiedGraphEdges():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 2], [1, 2, -1], [2, 3, 4], [3, 4, -1], [0, 4, -1]]\n    source = 0\n    destination = 4\n    target = 11\n    assert solution.modifiedGraphEdges(n, edges, source, destination, target) == [[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 2], [0, 4, 2000000000]]", "def test_modifiedGraphEdges():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, -1], [1, 2, 2], [2, 3, -1], [0, 3, -1]]\n    source = 0\n    destination = 3\n    target = 8\n    assert solution.modifiedGraphEdges(n, edges, source, destination, target) == [[0, 1, 1], [1, 2, 2], [2, 3, 5], [0, 3, 6]]", "def test_modifiedGraphEdges():\n    solution = Solution()\n    n = 6\n    edges = [[0, 1, -1], [1, 2, -1], [2, 3, 2], [3, 4, -1], [4, 5, 3], [0, 5, 15]]\n    source = 0\n    destination = 5\n    target = 10\n    assert solution.modifiedGraphEdges(n, edges, source, destination, target) == [[0, 1, 1], [1, 2, 1], [2, 3, 2], [3, 4, 2], [4, 5, 3], [0, 5, 15]]", "def test_modifiedGraphEdges():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, -1], [1, 2, 1], [0, 2, 4]]\n    source = 0\n    destination = 2\n    target = 5\n    assert solution.modifiedGraphEdges(n, edges, source, destination, target) == [[0, 1, 1], [1, 2, 1], [0, 2, 4]]", "def test_modifiedGraphEdges():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 3], [1, 2, -1], [2, 3, -1], [0, 3, 10]]\n    source = 0\n    destination = 3\n    target = 13\n    assert solution.modifiedGraphEdges(n, edges, source, destination, target) == [[0, 1, 3], [1, 2, 5], [2, 3, 5], [0, 3, 10]]", "def test_modifiedGraphEdges():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 2], [1, 2, -1], [2, 3, -1], [3, 4, 1], [0, 4, -1]]\n    source = 0\n    destination = 4\n    target = 8\n    assert solution.modifiedGraphEdges(n, edges, source, destination, target) == [[0, 1, 2], [1, 2, 2], [2, 3, 3], [3, 4, 1], [0, 4, 2000000000]]", "def test_modifiedGraphEdges():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 1], [1, 2, -1], [2, 3, -1], [0, 3, 7]]\n    source = 0\n    destination = 3\n    target = 9\n    assert solution.modifiedGraphEdges(n, edges, source, destination, target) == [[0, 1, 1], [1, 2, 3], [2, 3, 5], [0, 3, 7]]", "def test_modifiedGraphEdges():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, -1], [1, 2, 2], [0, 2, -1]]\n    source = 0\n    destination = 2\n    target = 3\n    assert solution.modifiedGraphEdges(n, edges, source, destination, target) == [[0, 1, 1], [1, 2, 2], [0, 2, 2000000000]]"]}
{"task_num": 2708, "task_title": "Maximum Strength of a Group", "func_name": "maxStrength", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxStrength(self, nums: List[int]) -> int:\n    posProd = 1\n    negProd = 1\n    maxNeg = -math.inf\n    negCount = 0\n    hasPos = False\n    hasZero = False\n\n    for num in nums:\n      if num > 0:\n        posProd *= num\n        hasPos = True\n      elif num < 0:\n        negProd *= num\n        maxNeg = max(maxNeg, num)\n        negCount += 1\n      else:\n        hasZero = True\n\n    if negCount == 0 and not hasPos:\n      return 0\n    if negCount % 2 == 0:\n      return negProd * posProd\n    if negCount >= 3:\n      return negProd // maxNeg * posProd\n    if hasPos:\n      return posProd\n    if hasZero:\n      return 0\n    return maxNeg\n", "tests": ["def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([-1, -2, -3, 4, 5]) == 120", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([-1, -2, 0, 1]) == 2", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([0, 0, -1, -2]) == 2", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([-3, -1, -4]) == 12", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([-5, 0, 0]) == 0", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([3]) == 3", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([-7, -3, -2, -1]) == 42", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([0, -1, 2]) == 2", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([-2, -4, 0, 5, 1]) == 40", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([0]) == 0", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([-1, 0, 1, 2, 3]) == 6", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([-1, -1, -1, -1, -1]) == 1", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([-2, -3, 5, 7]) == 210", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([-1, -2, -3, 0]) == 6", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([-1, -2, 3]) == 6", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([-1, 1]) == 1", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([-2, -3, -4]) == 12", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([2, 3, 4]) == 24", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([-5, 2, -3, 4]) == 120", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([0, 0, 0]) == 0"]}
{"task_num": 2709, "task_title": "Greatest Common Divisor Traversal", "func_name": "canTraverseAllPairs", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.sz = [1] * n\n\n  def unionBySize(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.sz[i] < self.sz[j]:\n      self.sz[j] += self.sz[i]\n      self.id[i] = j\n    else:\n      self.sz[i] += self.sz[j]\n      self.id[j] = i\n\n  def getSize(self, i: int) -> int:\n    return self.sz[i]\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def canTraverseAllPairs(self, nums: List[int]) -> bool:\n    n = len(nums)\n    max_num = max(nums)\n    maxPrimeFactor = self._sieveEratosthenes(max_num + 1)\n    primeToFirstIndex = collections.defaultdict(int)\n    uf = UnionFind(n)\n\n    for i, num in enumerate(nums):\n      for prime_factor in self._getPrimeFactors(num, maxPrimeFactor):\n        if prime_factor in primeToFirstIndex:\n          uf.unionBySize(primeToFirstIndex[prime_factor], i)\n        else:\n          primeToFirstIndex[prime_factor] = i\n\n    return any(uf.getSize(i) == n for i in range(n))\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeFactors(self, num: int, minPrimeFactors: List[int]) -> List[int]:\n    primeFactors = []\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      primeFactors.append(divisor)\n      while num % divisor == 0:\n        num //= divisor\n    return primeFactors\n", "tests": ["def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([2, 3, 6, 7, 12]) == True", "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([5, 10, 15, 20]) == True", "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([17, 23, 29]) == False", "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([8, 9, 27]) == False", "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([30, 42, 70, 105]) == True", "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([14, 22, 35, 55]) == False", "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([60, 84, 120, 180]) == True", "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([19, 38, 57, 95]) == False", "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([28, 36, 45, 54]) == True", "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([10, 25, 40, 55]) == False", "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([16, 32, 48, 64]) == True", "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([7, 14, 21, 25]) == False", "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([11, 22, 33, 44]) == True", "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([9, 18, 22, 36]) == False", "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([6, 10, 15, 21]) == False", "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([50, 75, 100, 125]) == True", "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([4, 6, 9, 13]) == False", "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([35, 49, 77, 91]) == True", "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([15, 25, 35, 45]) == True", "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([1, 2, 3, 4]) == False"]}
{"task_num": 2736, "task_title": "Maximum Sum Queries", "func_name": "maximumSumQueries", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Pair:\n  def __init__(self, x: int, y: int):\n    self.x = x\n    self.y = y\n\n  def __iter__(self):\n    yield self.x\n    yield self.y\n\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, minX: int, minY: int):\n    self.queryIndex = queryIndex\n    self.minX = minX\n    self.minY = minY\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.minX\n    yield self.minY\n\n\nclass Solution:\n  def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n    pairs = sorted([Pair(nums1[i], nums2[i])\n                   for i in range(len(nums1))], key=lambda p: p.x, reverse=True)\n    ans = [0] * len(queries)\n    stack = []  # [(y, x + y)]\n\n    pairsIndex = 0\n    for queryIndex, minX, minY in sorted([IndexedQuery(i, query[0], query[1]) for i, query in enumerate(queries)], key=lambda iq: -iq.minX):\n      while pairsIndex < len(pairs) and pairs[pairsIndex].x >= minX:\n        x, y = pairs[pairsIndex]\n        while stack and x + y >= stack[-1][1]:\n          stack.pop()\n        if not stack or y > stack[-1][0]:\n          stack.append((y, x + y))\n        pairsIndex += 1\n      j = self._firstGreaterEqual(stack, minY)\n      if j == len(stack):\n        ans[queryIndex] = -1\n      else:\n        ans[queryIndex] = stack[j][1]\n\n    return ans\n\n  def _firstGreaterEqual(self, A: List[Tuple[int, int]], target: int) -> int:\n    l = 0\n    r = len(A)\n    while l < r:\n      m = (l + r) // 2\n      if A[m][0] >= target:\n        r = m\n      else:\n        l = m + 1\n    return l\n", "tests": ["def test_maximumSumQueries():\n    solution = Solution()\n    nums1 = [1, 2, 3, 4]\n    nums2 = [4, 5, 1, 2]\n    queries = [[2, 3], [1, 5], [3, 1]]\n    expected = [9, 7, 5]\n    assert solution.maximumSumQueries(nums1, nums2, queries) == expected", "def test_maximumSumQueries():\n    solution = Solution()\n    nums1 = [5, 3, 9, 7]\n    nums2 = [2, 8, 4, 6]\n    queries = [[4, 5], [10, 1], [0, 0]]\n    expected = [13, 13, 15]\n    assert solution.maximumSumQueries(nums1, nums2, queries) == expected", "def test_maximumSumQueries():\n    solution = Solution()\n    nums1 = [8, 6, 7, 5]\n    nums2 = [1, 4, 3, 2]\n    queries = [[9, 0], [6, 4], [7, 1]]\n    expected = [-1, 10, 11]\n    assert solution.maximumSumQueries(nums1, nums2, queries) == expected", "def test_maximumSumQueries():\n    solution = Solution()\n    nums1 = [1, 1, 1, 1]\n    nums2 = [2, 2, 2, 2]\n    queries = [[1, 3], [1, 2], [2, 1]]\n    expected = [-1, 3, -1]\n    assert solution.maximumSumQueries(nums1, nums2, queries) == expected", "def test_maximumSumQueries():\n    solution = Solution()\n    nums1 = [10, 15, 20, 25]\n    nums2 = [5, 10, 15, 20]\n    queries = [[20, 20], [10, 5], [30, 10]]\n    expected = [35, 40, -1]\n    assert solution.maximumSumQueries(nums1, nums2, queries) == expected", "def test_maximumSumQueries():\n    solution = Solution()\n    nums1 = [3, 5, 7, 9]\n    nums2 = [8, 6, 4, 2]\n    queries = [[4, 9], [7, 5], [6, 3]]\n    expected = [-1, 11, 11]\n    assert solution.maximumSumQueries(nums1, nums2, queries) == expected", "def test_maximumSumQueries():\n    solution = Solution()\n    nums1 = [12, 6, 4, 8]\n    nums2 = [3, 7, 5, 9]\n    queries = [[10, 8], [5, 6], [3, 2]]\n    expected = [21, 13, 21]\n    assert solution.maximumSumQueries(nums1, nums2, queries) == expected", "def test_maximumSumQueries():\n    solution = Solution()\n    nums1 = [1, 3, 5, 7]\n    nums2 = [8, 6, 4, 2]\n    queries = [[2, 7], [7, 1], [0, 0]]\n    expected = [9, 9, 15]\n    assert solution.maximumSumQueries(nums1, nums2, queries) == expected", "def test_maximumSumQueries():\n    solution = Solution()\n    nums1 = [14, 11, 9, 3]\n    nums2 = [1, 7, 6, 4]\n    queries = [[10, 5], [12, 0], [2, 8]]\n    expected = [17, 15, -1]\n    assert solution.maximumSumQueries(nums1, nums2, queries) == expected", "def test_maximumSumQueries():\n    solution = Solution()\n    nums1 = [5, 2, 8, 1]\n    nums2 = [2, 9, 3, 7]\n    queries = [[6, 3], [1, 8], [0, 0]]\n    expected = [11, 11, 15]\n    assert solution.maximumSumQueries(nums1, nums2, queries) == expected", "def test_maximumSumQueries():\n    solution = Solution()\n    nums1 = [7, 9, 4, 6]\n    nums2 = [5, 2, 8, 3]\n    queries = [[8, 1], [7, 4], [5, 9]]\n    expected = [11, 12, -1]\n    assert solution.maximumSumQueries(nums1, nums2, queries) == expected", "def test_maximumSumQueries():\n    solution = Solution()\n    nums1 = [3, 8, 6, 1]\n    nums2 = [7, 4, 2, 10]\n    queries = [[4, 5], [8, 3], [2, 1]]\n    expected = [10, 12, 14]\n    assert solution.maximumSumQueries(nums1, nums2, queries) == expected", "def test_maximumSumQueries():\n    solution = Solution()\n    nums1 = [10, 20, 30, 40]\n    nums2 = [5, 25, 15, 35]\n    queries = [[15, 10], [25, 20], [5, 5]]\n    expected = [45, 50, 75]\n    assert solution.maximumSumQueries(nums1, nums2, queries) == expected", "def test_maximumSumQueries():\n    solution = Solution()\n    nums1 = [18, 11, 22, 5]\n    nums2 = [3, 19, 8, 14]\n    queries = [[12, 15], [22, 8], [5, 3]]\n    expected = [30, 30, 32]\n    assert solution.maximumSumQueries(nums1, nums2, queries) == expected", "def test_maximumSumQueries():\n    solution = Solution()\n    nums1 = [15, 14, 12, 10]\n    nums2 = [10, 9, 8, 7]\n    queries = [[11, 8], [16, 10], [13, 5]]\n    expected = [23, -1, 24]\n    assert solution.maximumSumQueries(nums1, nums2, queries) == expected", "def test_maximumSumQueries():\n    solution = Solution()\n    nums1 = [6, 2, 9, 4]\n    nums2 = [7, 5, 3, 8]\n    queries = [[3, 6], [9, 2], [1, 4]]\n    expected = [15, 12, 15]\n    assert solution.maximumSumQueries(nums1, nums2, queries) == expected", "def test_maximumSumQueries():\n    solution = Solution()\n    nums1 = [13, 7, 5, 8]\n    nums2 = [6, 9, 10, 3]\n    queries = [[8, 7], [5, 10], [14, 2]]\n    expected = [19, 15, -1]\n    assert solution.maximumSumQueries(nums1, nums2, queries) == expected", "def test_maximumSumQueries():\n    solution = Solution()\n    nums1 = [10, 3, 6, 2]\n    nums2 = [1, 12, 4, 9]\n    queries = [[6, 3], [4, 10], [1, 1]]\n    expected = [10, 15, 15]\n    assert solution.maximumSumQueries(nums1, nums2, queries) == expected", "def test_maximumSumQueries():\n    solution = Solution()\n    nums1 = [4, 8, 12, 16]\n    nums2 = [11, 7, 3, 1]\n    queries = [[10, 5], [8, 8], [5, 2]]\n    expected = [15, -1, 19]\n    assert solution.maximumSumQueries(nums1, nums2, queries) == expected", "def test_maximumSumQueries():\n    solution = Solution()\n    nums1 = [9, 3, 7, 5]\n    nums2 = [8, 5, 2, 6]\n    queries = [[4, 7], [3, 1], [8, 5]]\n    expected = [14, 15, 17]\n    assert solution.maximumSumQueries(nums1, nums2, queries) == expected"]}
{"task_num": 2747, "task_title": "Count Zero Request Servers", "func_name": "countServers", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, query: int):\n    self.queryIndex = queryIndex\n    self.query = query\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.query\n\n\nclass Solution:\n  def countServers(self, n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:\n    ans = [0] * len(queries)\n    count = [0] * (n + 1)\n\n    logs.sort(key=lambda log: log[1])\n\n    i = 0\n    j = 0\n    servers = 0\n\n    for queryIndex, query in sorted([IndexedQuery(i, query) for i, query in enumerate(queries)], key=lambda iq: iq.query):\n      while j < len(logs) and logs[j][1] <= query:\n        count[logs[j][0]] += 1\n        if count[logs[j][0]] == 1:\n          servers += 1\n        j += 1\n      while i < len(logs) and logs[i][1] < query - x:\n        count[logs[i][0]] -= 1\n        if count[logs[i][0]] == 0:\n          servers -= 1\n        i += 1\n      ans[queryIndex] = n - servers\n\n    return ans\n", "tests": ["def test_countServers():\n    solution = Solution()\n    n = 3\n    logs = [[1, 1], [2, 2], [1, 3], [3, 3]]\n    x = 1\n    queries = [3, 4]\n    expected_output = [1, 2]\n    assert solution.countServers(n, logs, x, queries) == expected_output", "def test_countServers():\n    solution = Solution()\n    n = 4\n    logs = [[1, 2], [2, 4], [3, 5], [1, 6], [4, 8]]\n    x = 3\n    queries = [7, 10]\n    expected_output = [1, 2]\n    assert solution.countServers(n, logs, x, queries) == expected_output", "def test_countServers():\n    solution = Solution()\n    n = 5\n    logs = [[3, 1], [2, 4], [1, 5], [4, 7], [5, 10], [3, 12]]\n    x = 2\n    queries = [5, 8, 11]\n    expected_output = [2, 3, 4]\n    assert solution.countServers(n, logs, x, queries) == expected_output", "def test_countServers():\n    solution = Solution()\n    n = 6\n    logs = [[1, 3], [2, 5], [4, 6], [5, 9], [6, 10]]\n    x = 4\n    queries = [4, 6, 11]\n    expected_output = [3, 2, 4]\n    assert solution.countServers(n, logs, x, queries) == expected_output", "def test_countServers():\n    solution = Solution()\n    n = 2\n    logs = [[1, 1], [1, 3], [2, 6], [2, 8]]\n    x = 2\n    queries = [2, 5, 9]\n    expected_output = [1, 1, 0]\n    assert solution.countServers(n, logs, x, queries) == expected_output", "def test_countServers():\n    solution = Solution()\n    n = 7\n    logs = [[1, 2], [2, 4], [3, 6], [4, 8], [5, 10], [6, 12], [7, 14]]\n    x = 5\n    queries = [5, 9, 13]\n    expected_output = [3, 5, 7]\n    assert solution.countServers(n, logs, x, queries) == expected_output", "def test_countServers():\n    solution = Solution()\n    n = 4\n    logs = [[1, 2], [2, 3], [1, 5], [3, 6], [4, 10]]\n    x = 3\n    queries = [4, 7, 11]\n    expected_output = [2, 2, 3]\n    assert solution.countServers(n, logs, x, queries) == expected_output", "def test_countServers():\n    solution = Solution()\n    n = 5\n    logs = [[1, 1], [3, 4], [5, 5], [2, 8], [4, 9]]\n    x = 4\n    queries = [3, 6, 10]\n    expected_output = [3, 2, 5]\n    assert solution.countServers(n, logs, x, queries) == expected_output", "def test_countServers():\n    solution = Solution()\n    n = 3\n    logs = [[1, 2], [2, 3], [1, 4], [3, 5]]\n    x = 2\n    queries = [2, 6]\n    expected_output = [1, 0]\n    assert solution.countServers(n, logs, x, queries) == expected_output", "def test_countServers():\n    solution = Solution()\n    n = 6\n    logs = [[1, 1], [2, 3], [3, 7], [4, 9], [5, 11], [6, 15]]\n    x = 3\n    queries = [3, 8, 12, 16]\n    expected_output = [4, 3, 4, 5]\n    assert solution.countServers(n, logs, x, queries) == expected_output", "def test_countServers():\n    solution = Solution()\n    n = 8\n    logs = [[1, 2], [2, 5], [3, 6], [4, 8], [5, 9], [6, 11], [7, 13], [8, 15]]\n    x = 5\n    queries = [5, 10, 14]\n    expected_output = [4, 5, 6]\n    assert solution.countServers(n, logs, x, queries) == expected_output", "def test_countServers():\n    solution = Solution()\n    n = 7\n    logs = [[1, 1], [2, 2], [3, 4], [4, 7], [5, 8], [6, 10], [7, 12]]\n    x = 3\n    queries = [3, 6, 9, 13]\n    expected_output = [3, 4, 5, 6]\n    assert solution.countServers(n, logs, x, queries) == expected_output", "def test_countServers():\n    solution = Solution()\n    n = 4\n    logs = [[1, 3], [2, 5], [3, 6], [4, 8]]\n    x = 1\n    queries = [4, 7, 9]\n    expected_output = [3, 2, 3]\n    assert solution.countServers(n, logs, x, queries) == expected_output", "def test_countServers():\n    solution = Solution()\n    n = 10\n    logs = [[1, 1], [2, 2], [3, 3], [4, 4], [5, 5], [6, 6], [7, 7], [8, 8], [9, 9], [10, 10]]\n    x = 2\n    queries = [2, 5, 7, 10]\n    expected_output = [8, 7, 6, 7]\n    assert solution.countServers(n, logs, x, queries) == expected_output", "def test_countServers():\n    solution = Solution()\n    n = 5\n    logs = [[1, 3], [2, 3], [3, 5], [4, 9], [5, 12]]\n    x = 4\n    queries = [6, 10, 13]\n    expected_output = [2, 3, 4]\n    assert solution.countServers(n, logs, x, queries) == expected_output", "def test_countServers():\n    solution = Solution()\n    n = 9\n    logs = [[1, 2], [2, 4], [3, 6], [4, 8], [5, 10], [6, 12], [7, 14], [8, 16], [9, 18]]\n    x = 5\n    queries = [3, 7, 11, 19]\n    expected_output = [8, 6, 5, 8]\n    assert solution.countServers(n, logs, x, queries) == expected_output", "def test_countServers():\n    solution = Solution()\n    n = 6\n    logs = [[1, 1], [2, 3], [3, 5], [4, 7], [5, 9], [6, 11]]\n    x = 2\n    queries = [2, 4, 6, 12]\n    expected_output = [5, 4, 3, 5]\n    assert solution.countServers(n, logs, x, queries) == expected_output", "def test_countServers():\n    solution = Solution()\n    n = 8\n    logs = [[1, 3], [2, 5], [3, 7], [4, 9], [5, 11], [6, 13], [7, 15], [8, 17]]\n    x = 6\n    queries = [4, 10, 14, 18]\n    expected_output = [6, 4, 5, 7]\n    assert solution.countServers(n, logs, x, queries) == expected_output", "def test_countServers():\n    solution = Solution()\n    n = 7\n    logs = [[1, 2], [2, 4], [3, 6], [4, 8], [5, 10], [6, 12], [7, 14]]\n    x = 5\n    queries = [3, 5, 8, 15]\n    expected_output = [6, 5, 4, 6]\n    assert solution.countServers(n, logs, x, queries) == expected_output", "def test_countServers():\n    solution = Solution()\n    n = 5\n    logs = [[1, 1], [2, 3], [3, 8], [4, 10], [5, 15]]\n    x = 4\n    queries = [2, 9, 16]\n    expected_output = [4, 3, 4]\n    assert solution.countServers(n, logs, x, queries) == expected_output"]}
{"task_num": 2751, "task_title": "Robot Collisions", "func_name": "survivedRobotsHealths", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\nfrom dataclasses import dataclass\n\n@dataclass\nclass Robot:\n  index: int\n  position: int\n  health: int\n  direction: str\n\n\nclass Solution:\n  def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\n    robots = sorted([Robot(index, position, health, direction) for index, (position, health, direction) in enumerate(zip(positions, healths, directions))], key=lambda robot: robot.position)\n    stack: List[Robot] = []\n\n    for robot in robots:\n      if robot.direction == 'R':\n        stack.append(robot)\n        continue\n      while stack and stack[-1].direction == 'R' and robot.health > 0:\n        if stack[-1].health == robot.health:\n          stack.pop()\n          robot.health = 0\n        elif stack[-1].health < robot.health:\n          stack.pop()\n          robot.health -= 1\n        else:\n          stack[-1].health -= 1\n          robot.health = 0\n      if robot.health > 0:\n        stack.append(robot)\n\n    stack.sort(key=lambda robot: robot.index)\n    return [robot.health for robot in stack]\n", "tests": ["def test_survivedRobotsHealths():\n    solution = Solution()\n    positions = [1, 3, 5, 7]\n    healths = [2, 4, 3, 2]\n    directions = 'RLRL'\n    assert solution.survivedRobotsHealths(positions, healths, directions) == [2, 1]", "def test_survivedRobotsHealths():\n    solution = Solution()\n    positions = [2, 4, 6, 8]\n    healths = [5, 3, 8, 6]\n    directions = 'RRLL'\n    assert solution.survivedRobotsHealths(positions, healths, directions) == [5, 2]", "def test_survivedRobotsHealths():\n    solution = Solution()\n    positions = [10, 20, 30, 40, 50]\n    healths = [1, 2, 3, 4, 5]\n    directions = 'LLLLL'\n    assert solution.survivedRobotsHealths(positions, healths, directions) == [1, 2, 3, 4, 5]", "def test_survivedRobotsHealths():\n    solution = Solution()\n    positions = [5, 10, 15, 20]\n    healths = [3, 1, 4, 2]\n    directions = 'RLLR'\n    assert solution.survivedRobotsHealths(positions, healths, directions) == [1, 4, 2]", "def test_survivedRobotsHealths():\n    solution = Solution()\n    positions = [1, 2, 3, 4, 5, 6]\n    healths = [2, 2, 2, 2, 2, 2]\n    directions = 'RLRLRL'\n    assert solution.survivedRobotsHealths(positions, healths, directions) == [2, 2, 2]", "def test_survivedRobotsHealths():\n    solution = Solution()\n    positions = [3, 8, 12, 15]\n    healths = [3, 5, 3, 1]\n    directions = 'RLLR'\n    assert solution.survivedRobotsHealths(positions, healths, directions) == [2, 5, 1]", "def test_survivedRobotsHealths():\n    solution = Solution()\n    positions = [5, 11, 18]\n    healths = [4, 4, 4]\n    directions = 'LRR'\n    assert solution.survivedRobotsHealths(positions, healths, directions) == [3, 4]", "def test_survivedRobotsHealths():\n    solution = Solution()\n    positions = [10, 20, 30, 40, 50]\n    healths = [3, 2, 1, 2, 3]\n    directions = 'RRRRL'\n    assert solution.survivedRobotsHealths(positions, healths, directions) == [3, 2, 1, 1]", "def test_survivedRobotsHealths():\n    solution = Solution()\n    positions = [1, 4, 6, 9, 11]\n    healths = [1, 2, 3, 4, 5]\n    directions = 'RLLRL'\n    assert solution.survivedRobotsHealths(positions, healths, directions) == [2, 1, 5]", "def test_survivedRobotsHealths():\n    solution = Solution()\n    positions = [3, 7, 9, 14]\n    healths = [4, 5, 6, 7]\n    directions = 'RLRL'\n    assert solution.survivedRobotsHealths(positions, healths, directions) == [3, 5, 6]", "def test_survivedRobotsHealths():\n    solution = Solution()\n    positions = [8, 16, 24, 32]\n    healths = [2, 3, 2, 1]\n    directions = 'RLLR'\n    assert solution.survivedRobotsHealths(positions, healths, directions) == [2, 1]", "def test_survivedRobotsHealths():\n    solution = Solution()\n    positions = [2, 5, 7, 10, 13]\n    healths = [3, 2, 1, 3, 4]\n    directions = 'RRLLL'\n    assert solution.survivedRobotsHealths(positions, healths, directions) == [3, 3, 4]", "def test_survivedRobotsHealths():\n    solution = Solution()\n    positions = [1, 3, 6, 9]\n    healths = [4, 3, 2, 1]\n    directions = 'RLLL'\n    assert solution.survivedRobotsHealths(positions, healths, directions) == [3, 2, 1]", "def test_survivedRobotsHealths():\n    solution = Solution()\n    positions = [7, 14, 21, 28]\n    healths = [1, 6, 4, 2]\n    directions = 'LRLR'\n    assert solution.survivedRobotsHealths(positions, healths, directions) == [6, 4, 2]", "def test_survivedRobotsHealths():\n    solution = Solution()\n    positions = [15, 30, 45, 60, 75]\n    healths = [5, 5, 5, 5, 5]\n    directions = 'RLRLR'\n    assert solution.survivedRobotsHealths(positions, healths, directions) == [5, 4, 5]", "def test_survivedRobotsHealths():\n    solution = Solution()\n    positions = [100, 200, 300, 400]\n    healths = [3, 3, 3, 3]\n    directions = 'RRLL'\n    assert solution.survivedRobotsHealths(positions, healths, directions) == []", "def test_survivedRobotsHealths():\n    solution = Solution()\n    positions = [5, 10, 15, 20, 25]\n    healths = [6, 4, 3, 2, 1]\n    directions = 'LRRLR'\n    assert solution.survivedRobotsHealths(positions, healths, directions) == [6, 3, 2]", "def test_survivedRobotsHealths():\n    solution = Solution()\n    positions = [5, 15, 25, 35, 45]\n    healths = [2, 4, 6, 8, 10]\n    directions = 'LLRRR'\n    assert solution.survivedRobotsHealths(positions, healths, directions) == [2, 4, 8, 10]", "def test_survivedRobotsHealths():\n    solution = Solution()\n    positions = [3, 6, 9, 12]\n    healths = [1, 5, 3, 7]\n    directions = 'RLRL'\n    assert solution.survivedRobotsHealths(positions, healths, directions) == [2, 7]", "def test_survivedRobotsHealths():\n    solution = Solution()\n    positions = [10, 40, 30, 20]\n    healths = [2, 4, 6, 8]\n    directions = 'RLLR'\n    assert solution.survivedRobotsHealths(positions, healths, directions) == [2, 5, 6]"]}
{"task_num": 2812, "task_title": "Find the Safest Path in a Grid", "func_name": "maximumSafenessFactor", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumSafenessFactor(self, grid: List[List[int]]) -> int:\n    self.dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    n = len(grid)\n    distToThief = self._getDistToThief(grid)\n\n    def hasValidPath(safeness: int) -> bool:\n      if distToThief[0][0] < safeness:\n        return False\n\n      q = collections.deque([(0, 0)])\n      seen = {(0, 0)}\n\n      while q:\n        i, j = q.popleft()\n        if distToThief[i][j] < safeness:\n          continue\n        if i == n - 1 and j == n - 1:\n          return True\n        for dx, dy in self.dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == n or y < 0 or y == n:\n            continue\n          if (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n\n      return False\n\n    return bisect.bisect_left(range(n * 2), True, key=lambda m: not hasValidPath(m)) - 1\n\n  def _getDistToThief(self, grid: List[List[int]]) -> List[List[int]]:\n    n = len(grid)\n    distToThief = [[0] * n for _ in range(n)]\n    q = collections.deque()\n    seen = set()\n\n    for i in range(n):\n      for j in range(n):\n        if grid[i][j] == 1:\n          q.append((i, j))\n          seen.add((i, j))\n\n    dist = 0\n    while q:\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        distToThief[i][j] = dist\n        for dx, dy in self.dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == n or y < 0 or y == n:\n            continue\n          if (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n      dist += 1\n\n    return distToThief\n", "tests": ["def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n    assert solution.maximumSafenessFactor(grid) == 1", "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[1, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 1]]\n    assert solution.maximumSafenessFactor(grid) == 2", "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[0, 0, 1], [0, 0, 0], [1, 0, 0]]\n    assert solution.maximumSafenessFactor(grid) == 1", "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    assert solution.maximumSafenessFactor(grid) == 0", "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[0, 0, 0, 0], [0, 0, 1, 0], [0, 0, 0, 0], [0, 0, 0, 0]]\n    assert solution.maximumSafenessFactor(grid) == 2", "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[0, 1], [0, 0]]\n    assert solution.maximumSafenessFactor(grid) == 1", "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[0, 0, 0, 1], [0, 0, 0, 0], [0, 0, 1, 0], [1, 0, 0, 0]]\n    assert solution.maximumSafenessFactor(grid) == 1", "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[0, 0, 0], [1, 1, 1], [0, 0, 0]]\n    assert solution.maximumSafenessFactor(grid) == 1", "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[0, 0, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 0, 0]]\n    assert solution.maximumSafenessFactor(grid) == 2", "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[0, 0, 0, 0], [1, 0, 1, 0], [0, 0, 0, 0], [0, 0, 1, 0]]\n    assert solution.maximumSafenessFactor(grid) == 1", "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[1, 0, 1, 0, 0], [0, 0, 0, 0, 0], [1, 0, 1, 0, 1], [0, 0, 0, 0, 0], [0, 1, 0, 1, 0]]\n    assert solution.maximumSafenessFactor(grid) == 1", "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[0, 0, 1, 0, 0], [0, 1, 0, 1, 0], [1, 0, 0, 0, 1], [0, 1, 0, 1, 0], [0, 0, 1, 0, 0]]\n    assert solution.maximumSafenessFactor(grid) == 1", "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[0, 1, 0], [1, 0, 1], [0, 1, 0]]\n    assert solution.maximumSafenessFactor(grid) == 0", "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[0, 1, 0, 1], [0, 0, 0, 0], [0, 1, 0, 1], [1, 0, 0, 0]]\n    assert solution.maximumSafenessFactor(grid) == 1", "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[0, 0, 0, 0], [0, 0, 1, 0], [1, 0, 0, 0], [0, 0, 0, 1]]\n    assert solution.maximumSafenessFactor(grid) == 1", "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[0, 0, 0, 0, 0], [0, 1, 0, 0, 0], [0, 0, 0, 1, 0], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0]]\n    assert solution.maximumSafenessFactor(grid) == 2", "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[0, 0, 0, 0, 1], [0, 1, 0, 0, 0], [1, 0, 0, 0, 0], [0, 0, 0, 1, 0], [0, 0, 0, 0, 0]]\n    assert solution.maximumSafenessFactor(grid) == 1", "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n    assert solution.maximumSafenessFactor(grid) == 2", "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[1, 1, 1, 1], [1, 0, 0, 1], [1, 0, 0, 1], [1, 1, 1, 1]]\n    assert solution.maximumSafenessFactor(grid) == 0", "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[0, 0, 0, 0], [0, 1, 0, 1], [0, 0, 0, 0], [0, 0, 1, 0]]\n    assert solution.maximumSafenessFactor(grid) == 1"]}
{"task_num": 2818, "task_title": "Apply Operations to Maximize Score", "func_name": "maximumScore", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumScore(self, nums: List[int], k: int) -> int:\n    kMod = 1_000_000_007\n    n = len(nums)\n    ans = 1\n    minPrimeFactors = self._sieveEratosthenes(max(nums) + 1)\n    primeScores = [self._getPrimeScore(num, minPrimeFactors) for num in nums]\n    left = [-1] * n\n    right = [n] * n\n    stack = []\n\n    for i in reversed(range(n)):\n      while stack and primeScores[stack[-1]] <= primeScores[i]:\n        left[stack.pop()] = i\n      stack.append(i)\n\n    stack = []\n\n    for i in range(n):\n      while stack and primeScores[stack[-1]] < primeScores[i]:\n        right[stack.pop()] = i\n      stack.append(i)\n\n    numAndIndexes = [(num, i) for i, num in enumerate(nums)]\n\n    def modPow(x: int, n: int) -> int:\n      if n == 0:\n        return 1\n      if n & 1:\n        return x * modPow(x, n - 1) % kMod\n      return modPow(x * x % kMod, n // 2)\n\n    for num, i in sorted(numAndIndexes, key=lambda x: (-x[0], x[1])):\n      rangeCount = (i - left[i]) * (right[i] - i)\n      actualCount = min(rangeCount, k)\n      k -= actualCount\n      ans *= modPow(num, actualCount)\n      ans %= kMod\n\n    return ans\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeScore(self, num: int, minPrimeFactors: List[int]) -> int:\n    primeFactors = set()\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      primeFactors.add(divisor)\n      while num % divisor == 0:\n        num //= divisor\n    return len(primeFactors)\n", "tests": ["def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([2, 3, 3, 2, 1], 3) == 18", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([5, 7, 9, 3, 11], 2) == 99", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([10, 2, 8, 6, 4], 4) == 640", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([15, 20, 25, 30, 35], 1) == 35", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([1, 13, 17, 19, 23, 29], 5) == 1535229", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([4, 6, 8, 10, 12], 3) == 864", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([18, 1, 5, 13, 7], 2) == 234", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([3, 5, 7, 11, 13, 17], 3) == 2431", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([9, 27, 25, 16, 14], 4) == 91125", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([14, 21, 28, 35, 42], 2) == 882", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([100, 200, 300, 400, 500], 1) == 500", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([12, 15, 18, 21, 24], 3) == 13122", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([6, 10, 15, 20, 25], 2) == 500", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([30, 45, 50, 75, 90], 3) == 202500", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([2, 4, 6, 8, 10, 12], 5) == 6912", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([11, 22, 33, 44, 55], 4) == 9605960", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([7, 14, 21, 28, 35, 42], 3) == 2058", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([8, 16, 24, 32, 40], 2) == 1280", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([1, 6, 10, 15, 21], 3) == 1890", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([3, 9, 27, 81, 243], 2) == 59049"]}
{"task_num": 2836, "task_title": "Maximize Value of Function in a Ball Passing Game", "func_name": "getMaxFunctionValue", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:\n    n = len(receiver)\n    m = int(math.log2(k)) + 1\n    ans = 0\n    jump = [[0] * m for _ in range(n)]\n    summ = [[0] * m for _ in range(n)]\n\n    for i in range(n):\n      jump[i][0] = receiver[i]\n      summ[i][0] = receiver[i]\n\n    for j in range(1, m):\n      for i in range(n):\n        midNode = jump[i][j - 1]\n        jump[i][j] = jump[midNode][j - 1]\n        summ[i][j] = summ[i][j - 1] + summ[midNode][j - 1]\n\n    for i in range(n):\n      currSum = i\n      currPos = i\n      for j in range(m):\n        if (k >> j) & 1 == 1:\n          currSum += summ[currPos][j]\n          currPos = jump[currPos][j]\n      ans = max(ans, currSum)\n\n    return ans\n", "tests": ["def test_getMaxFunctionValue():\n    solution = Solution()\n    assert solution.getMaxFunctionValue([1, 2, 3, 0], 4) == 12", "def test_getMaxFunctionValue():\n    solution = Solution()\n    assert solution.getMaxFunctionValue([0, 1, 2, 3], 2) == 6", "def test_getMaxFunctionValue():\n    solution = Solution()\n    assert solution.getMaxFunctionValue([2, 0, 1], 3) == 6", "def test_getMaxFunctionValue():\n    solution = Solution()\n    assert solution.getMaxFunctionValue([4, 3, 2, 1, 0], 5) == 15", "def test_getMaxFunctionValue():\n    solution = Solution()\n    assert solution.getMaxFunctionValue([1, 1, 1, 1], 6) == 10", "def test_getMaxFunctionValue():\n    solution = Solution()\n    assert solution.getMaxFunctionValue([0, 2, 2, 3], 7) == 19", "def test_getMaxFunctionValue():\n    solution = Solution()\n    assert solution.getMaxFunctionValue([3, 3, 3, 3], 4) == 15", "def test_getMaxFunctionValue():\n    solution = Solution()\n    assert solution.getMaxFunctionValue([1, 0, 0, 0], 5) == 7", "def test_getMaxFunctionValue():\n    solution = Solution()\n    assert solution.getMaxFunctionValue([0, 0, 0, 0], 3) == 3", "def test_getMaxFunctionValue():\n    solution = Solution()\n    assert solution.getMaxFunctionValue([2, 3, 0, 1], 8) == 16", "def test_getMaxFunctionValue():\n    solution = Solution()\n    assert solution.getMaxFunctionValue([1, 2, 0, 0], 10) == 16", "def test_getMaxFunctionValue():\n    solution = Solution()\n    assert solution.getMaxFunctionValue([1, 0, 3, 2], 5) == 12", "def test_getMaxFunctionValue():\n    solution = Solution()\n    assert solution.getMaxFunctionValue([2, 2, 2, 2], 4) == 10", "def test_getMaxFunctionValue():\n    solution = Solution()\n    assert solution.getMaxFunctionValue([3, 1, 0, 1], 7) == 15", "def test_getMaxFunctionValue():\n    solution = Solution()\n    assert solution.getMaxFunctionValue([1, 3, 2, 0], 9) == 22", "def test_getMaxFunctionValue():\n    solution = Solution()\n    assert solution.getMaxFunctionValue([3, 2, 1, 0], 2) == 9", "def test_getMaxFunctionValue():\n    solution = Solution()\n    assert solution.getMaxFunctionValue([0, 1, 1, 2, 3], 3) == 10", "def test_getMaxFunctionValue():\n    solution = Solution()\n    assert solution.getMaxFunctionValue([2, 2, 0, 3], 6) == 14", "def test_getMaxFunctionValue():\n    solution = Solution()\n    assert solution.getMaxFunctionValue([4, 4, 4, 4, 4], 1) == 8", "def test_getMaxFunctionValue():\n    solution = Solution()\n    assert solution.getMaxFunctionValue([1, 2, 2, 3, 0], 4) == 13"]}
{"task_num": 2844, "task_title": "Minimum Operations to Make a Special Number", "func_name": "minimumOperations", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumOperations(self, num: str) -> int:\n    n = len(num)\n    seenFive = False\n    seenZero = False\n\n    for i in range(n - 1, -1, -1):\n      if seenZero and num[i] == '0':\n        return n - i - 2\n      if seenZero and num[i] == '5':\n        return n - i - 2\n      if seenFive and num[i] == '2':\n        return n - i - 2\n      if seenFive and num[i] == '7':\n        return n - i - 2\n      seenZero = seenZero or num[i] == '0'\n      seenFive = seenFive or num[i] == '5'\n\n    if seenZero:\n      return n - 1\n    else:\n      return n\n", "tests": ["def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('1025') == 0", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('100') == 1", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('205') == 1", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('75') == 0", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('1') == 1", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('50') == 0", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('123456') == 6", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('6205') == 2", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('270') == 1", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('400') == 1", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('57') == 1", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('255') == 1", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('000') == 2", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('52') == 0", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('30') == 1", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('750') == 1", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('105') == 1", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('720') == 1", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('2000') == 2", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('225') == 0"]}
{"task_num": 2846, "task_title": "Minimum Edge Weight Equilibrium Queries in a Tree", "func_name": "minOperationsQueries", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minOperationsQueries(self, n: int, edges: List[List[int]], queries: List[List[int]]) -> List[int]:\n    kMax = 26\n    m = int(math.log2(n)) + 1\n    ans = []\n    graph = [[] for _ in range(n)]\n    jump = [[0] * m for _ in range(n)]\n    count = [[] for _ in range(n)]\n    depth = [0] * n\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    def dfs(u: int, prev: int, d: int):\n      if prev != -1:\n        jump[u][0] = prev\n      depth[u] = d\n      for v, w in graph[u]:\n        if v == prev:\n          continue\n        count[v] = count[u][:]\n        count[v][w] += 1\n        dfs(v, u, d + 1)\n\n    count[0] = [0] * (kMax + 1)\n    dfs(0, -1, 0)\n\n    for j in range(1, m):\n      for i in range(n):\n        jump[i][j] = jump[jump[i][j - 1]][j - 1]\n\n    def getLCA(u: int, v: int) -> int:\n      if depth[u] > depth[v]:\n        return getLCA(v, u)\n      for j in range(m):\n        if depth[v] - depth[u] >> j & 1:\n          v = jump[v][j]\n      if u == v:\n        return u\n      for j in range(m - 1, -1, -1):\n        if jump[u][j] != jump[v][j]:\n          u = jump[u][j]\n          v = jump[v][j]\n      return jump[v][0]\n\n    for u, v in queries:\n      lca = getLCA(u, v)\n      numEdges = depth[u] + depth[v] - 2 * depth[lca]\n      maxFreq = max(count[u][j] + count[v][j] - 2 * count[lca][j] for j in range(1, kMax + 1))\n      ans.append(numEdges - maxFreq)\n\n    return ans\n", "tests": ["def test_minOperationsQueries():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 1], [1, 2, 2], [1, 3, 3], [3, 4, 4]]\n    queries = [[0, 2], [2, 4], [3, 4]]\n    expected_output = [0, 1, 0]\n    assert solution.minOperationsQueries(n, edges, queries) == expected_output", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 7\n    edges = [[0, 1, 1], [0, 2, 1], [1, 3, 2], [1, 4, 3], [2, 5, 4], [2, 6, 5]]\n    queries = [[3, 5], [4, 6], [3, 6]]\n    expected_output = [3, 3, 5]\n    assert solution.minOperationsQueries(n, edges, queries) == expected_output", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 2], [1, 2, 2], [2, 3, 3]]\n    queries = [[0, 3], [1, 3], [0, 2]]\n    expected_output = [1, 1, 0]\n    assert solution.minOperationsQueries(n, edges, queries) == expected_output", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 6\n    edges = [[0, 1, 1], [0, 2, 2], [1, 3, 3], [1, 4, 4], [2, 5, 5]]\n    queries = [[0, 4], [3, 5], [4, 5]]\n    expected_output = [3, 4, 5]\n    assert solution.minOperationsQueries(n, edges, queries) == expected_output", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 8\n    edges = [[0, 1, 2], [1, 2, 3], [1, 3, 1], [2, 4, 4], [3, 5, 5], [4, 6, 6], [5, 7, 2]]\n    queries = [[6, 7], [5, 6], [4, 7]]\n    expected_output = [6, 5, 8]\n    assert solution.minOperationsQueries(n, edges, queries) == expected_output", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 1], [1, 2, 1]]\n    queries = [[0, 2], [0, 1], [1, 2]]\n    expected_output = [0, 0, 0]\n    assert solution.minOperationsQueries(n, edges, queries) == expected_output", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 9\n    edges = [[0, 1, 1], [0, 2, 2], [1, 3, 2], [1, 4, 3], [2, 5, 3], [4, 6, 1], [5, 7, 4], [6, 8, 5]]\n    queries = [[3, 7], [1, 8], [5, 6]]\n    expected_output = [5, 6, 7]\n    assert solution.minOperationsQueries(n, edges, queries) == expected_output", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 10\n    edges = [[0, 1, 1], [1, 2, 1], [2, 3, 2], [3, 4, 2], [4, 5, 3], [0, 6, 3], [6, 7, 4], [6, 8, 5], [8, 9, 5]]\n    queries = [[5, 9], [2, 7], [3, 8]]\n    expected_output = [7, 5, 6]\n    assert solution.minOperationsQueries(n, edges, queries) == expected_output", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 1], [1, 2, 2], [1, 3, 2], [3, 4, 3]]\n    queries = [[0, 4], [2, 3], [1, 4]]\n    expected_output = [2, 1, 1]\n    assert solution.minOperationsQueries(n, edges, queries) == expected_output", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 11\n    edges = [[0, 1, 2], [0, 2, 3], [1, 3, 3], [1, 4, 1], [2, 5, 1], [2, 6, 4], [3, 7, 5], [4, 8, 2], [5, 9, 4], [6, 10, 2]]\n    queries = [[7, 10], [8, 9], [3, 6]]\n    expected_output = [7, 7, 6]\n    assert solution.minOperationsQueries(n, edges, queries) == expected_output", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 12\n    edges = [[0, 1, 3], [0, 2, 1], [1, 3, 2], [1, 4, 2], [2, 5, 3], [2, 6, 4], [3, 7, 1], [4, 8, 4], [5, 9, 2], [6, 10, 5], [7, 11, 5]]\n    queries = [[11, 8], [10, 9], [3, 9]]\n    expected_output = [8, 9, 7]\n    assert solution.minOperationsQueries(n, edges, queries) == expected_output", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 13\n    edges = [[0, 1, 1], [1, 2, 2], [2, 3, 3], [3, 4, 1], [4, 5, 2], [5, 6, 3], [1, 7, 4], [7, 8, 4], [8, 9, 5], [9, 10, 5], [10, 11, 2], [11, 12, 1]]\n    queries = [[0, 12], [6, 9], [3, 11]]\n    expected_output = [6, 8, 7]\n    assert solution.minOperationsQueries(n, edges, queries) == expected_output", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 6\n    edges = [[0, 1, 4], [0, 2, 4], [1, 3, 2], [1, 4, 3], [2, 5, 2]]\n    queries = [[3, 5], [4, 5], [4, 2]]\n    expected_output = [4, 4, 3]\n    assert solution.minOperationsQueries(n, edges, queries) == expected_output", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 14\n    edges = [[0, 1, 1], [0, 2, 1], [1, 3, 2], [1, 4, 3], [2, 5, 2], [2, 6, 3], [3, 7, 4], [4, 8, 4], [5, 9, 5], [6, 10, 5], [7, 11, 2], [8, 12, 2], [9, 13, 1]]\n    queries = [[11, 12], [10, 13], [7, 9]]\n    expected_output = [10, 10, 8]\n    assert solution.minOperationsQueries(n, edges, queries) == expected_output", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 7\n    edges = [[0, 1, 3], [0, 2, 2], [1, 3, 1], [1, 4, 3], [2, 5, 2], [2, 6, 1]]\n    queries = [[3, 6], [4, 5], [3, 5]]\n    expected_output = [6, 6, 5]\n    assert solution.minOperationsQueries(n, edges, queries) == expected_output", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 15\n    edges = [[0, 1, 1], [0, 2, 3], [1, 3, 2], [1, 4, 2], [2, 5, 3], [2, 6, 4], [3, 7, 1], [4, 8, 5], [5, 9, 1], [6, 10, 3], [7, 11, 4], [8, 12, 4], [9, 13, 5], [10, 14, 5]]\n    queries = [[11, 14], [12, 13], [7, 10]]\n    expected_output = [13, 12, 11]\n    assert solution.minOperationsQueries(n, edges, queries) == expected_output", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 8\n    edges = [[0, 1, 2], [0, 2, 2], [1, 3, 3], [1, 4, 1], [2, 5, 4], [2, 6, 4], [3, 7, 5]]\n    queries = [[4, 7], [5, 7], [6, 3]]\n    expected_output = [6, 8, 8]\n    assert solution.minOperationsQueries(n, edges, queries) == expected_output", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 9\n    edges = [[0, 1, 3], [0, 2, 3], [1, 3, 2], [1, 4, 4], [2, 5, 2], [2, 6, 1], [4, 7, 3], [5, 8, 4]]\n    queries = [[3, 8], [6, 7], [4, 6]]\n    expected_output = [8, 8, 7]\n    assert solution.minOperationsQueries(n, edges, queries) == expected_output", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 10\n    edges = [[0, 1, 1], [0, 2, 2], [1, 3, 3], [1, 4, 3], [2, 5, 1], [2, 6, 4], [3, 7, 2], [4, 8, 4], [6, 9, 5]]\n    queries = [[7, 9], [3, 8], [5, 8]]\n    expected_output = [9, 8, 9]\n    assert solution.minOperationsQueries(n, edges, queries) == expected_output", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 11\n    edges = [[0, 1, 1], [0, 2, 3], [1, 3, 2], [1, 4, 1], [2, 5, 3], [2, 6, 2], [3, 7, 4], [4, 8, 4], [5, 9, 1], [6, 10, 5]]\n    queries = [[7, 9], [8, 10], [3, 6]]\n    expected_output = [10, 10, 9]\n    assert solution.minOperationsQueries(n, edges, queries) == expected_output"]}
{"task_num": 2850, "task_title": "Minimum Moves to Spread Stones Over Grid", "func_name": "minimumMoves", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumMoves(self, grid: List[List[int]]) -> int:\n    if sum(row.count(0) for row in grid) == 0:\n      return 0\n\n    ans = math.inf\n\n    for i in range(3):\n      for j in range(3):\n        if grid[i][j] == 0:\n          for x in range(3):\n            for y in range(3):\n              if grid[x][y] > 1:\n                grid[x][y] -= 1\n                grid[i][j] += 1\n                ans = min(ans, abs(x - i) + abs(y - j) + self.minimumMoves(grid))\n                grid[x][y] += 1\n                grid[i][j] -= 1\n\n    return ans\n", "tests": ["def test_minimumMoves():\n    solution = Solution()\n    grid = [[1, 1, 1], [1, 5, 1], [1, 1, 1]]\n    assert solution.minimumMoves(grid) == 4", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 0, 0], [3, 3, 3], [0, 0, 0]]\n    assert solution.minimumMoves(grid) == 9", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 2, 0], [2, 2, 2], [0, 2, 0]]\n    assert solution.minimumMoves(grid) == 6", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 9, 0], [0, 0, 0]]\n    assert solution.minimumMoves(grid) == 12", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[4, 0, 0], [0, 1, 0], [0, 0, 4]]\n    assert solution.minimumMoves(grid) == 8", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[3, 3, 0], [0, 0, 0], [3, 0, 0]]\n    assert solution.minimumMoves(grid) == 9", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 0, 2], [0, 5, 0], [2, 0, 0]]\n    assert solution.minimumMoves(grid) == 7", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 3, 3], [0, 3, 0]]\n    assert solution.minimumMoves(grid) == 7", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[2, 0, 2], [2, 1, 0], [2, 0, 0]]\n    assert solution.minimumMoves(grid) == 6", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 0, 3], [3, 0, 0], [0, 3, 0]]\n    assert solution.minimumMoves(grid) == 9", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 1, 3], [0, 0, 3], [0, 0, 2]]\n    assert solution.minimumMoves(grid) == 7", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 0, 0], [6, 0, 0], [0, 3, 0]]\n    assert solution.minimumMoves(grid) == 9", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[2, 2, 2], [0, 0, 0], [0, 2, 1]]\n    assert solution.minimumMoves(grid) == 5", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 2, 0], [0, 1, 1], [0, 5, 0]]\n    assert solution.minimumMoves(grid) == 5", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[1, 0, 0], [1, 0, 1], [3, 1, 2]]\n    assert solution.minimumMoves(grid) == 5", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[2, 2, 0], [0, 0, 0], [1, 3, 1]]\n    assert solution.minimumMoves(grid) == 6", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[1, 1, 1], [1, 3, 0], [1, 1, 0]]\n    assert solution.minimumMoves(grid) == 3", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[2, 0, 1], [0, 0, 2], [3, 0, 1]]\n    assert solution.minimumMoves(grid) == 7", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 6, 0], [1, 1, 1]]\n    assert solution.minimumMoves(grid) == 8", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 0, 2], [1, 0, 1], [0, 2, 3]]\n    assert solution.minimumMoves(grid) == 6"]}
{"task_num": 2851, "task_title": "String Transformation", "func_name": "numberOfWays", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numberOfWays(self, s: str, t: str, k: int) -> int:\n    kMod = 1_000_000_007\n    n = len(s)\n    negOnePowK = 1 if k % 2 == 0 else -1  # (-1)^k\n    z = self._zFunction(s + t + t)\n\n    indices = [i - n for i in range(n, n + n) if z[i] >= n]\n    dp = [0] * 2\n    dp[1] = (pow(n - 1, k, kMod) - negOnePowK) * pow(n, kMod - 2, kMod)\n    dp[0] = dp[1] + negOnePowK\n    res = 0\n    for index in indices:\n      if index == 0:\n        res += dp[0]\n      else: \n        res += dp[1]\n    return res % kMod\n\n\n  def _zFunction(self, s: str) -> List[int]:\n    n = len(s)\n    z = [0] * n\n    l = 0\n    r = 0\n    for i in range(1, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l])\n      while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n    return z\n", "tests": ["def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('abc', 'cab', 1) == 2", "def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('xyz', 'zxy', 2) == 0", "def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('abcd', 'dabc', 3) == 4", "def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('rotation', 'tionrota', 1) == 1", "def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('aaaa', 'aaaa', 5) == 4", "def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('abcde', 'eabcd', 2) == 0", "def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('abcdefgh', 'ghabcdef', 4) == 4", "def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('mnop', 'ponm', 8) == 0", "def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('racecar', 'carrace', 6) == 2", "def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('loop', 'pool', 2) == 0", "def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('abcdefg', 'gabcdef', 7) == 1", "def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('1234', '3412', 5) == 2", "def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('abcdefghij', 'defghijabc', 10) == 0", "def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('short', 'tshor', 3) == 0", "def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('abcdefgh', 'efghabcd', 4) == 2", "def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('palindrome', 'emordnilap', 9) == 0", "def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('abcdefghij', 'bcdefghija', 20) == 0", "def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('abcdefgh', 'habcdefg', 15) == 1", "def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('rotation', 'ationrot', 3) == 2", "def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('abcdefgh', 'hgfedcba', 7) == 0"]}
{"task_num": 2876, "task_title": "Count Visited Nodes in a Directed Graph", "func_name": "countVisitedNodes", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countVisitedNodes(self, edges: List[int]) -> List[int]:\n    n = len(edges)\n    ans = [0] * n\n    inDegrees = [0] * n\n    seen = [False] * n\n    stack = []\n\n    for v in edges:\n      inDegrees[v] += 1\n\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n\n    while q:\n      u = q.popleft()\n      inDegrees[edges[u]] -= 1\n      if inDegrees[edges[u]] == 0:\n        q.append(edges[u])\n      stack.append(u)\n      seen[u] = True\n\n    for i in range(n):\n      if not seen[i]:\n        self._fillCycle(edges, i, seen, ans)\n\n    while stack:\n      u = stack.pop()\n      ans[u] = ans[edges[u]] + 1\n\n    return ans\n\n  def _fillCycle(self, edges: List[int], start: int, seen: List[bool], ans: List[int]) -> None:\n    cycleLength = 0\n    u = start\n    while not seen[u]:\n      cycleLength += 1\n      seen[u] = True\n      u = edges[u]\n    ans[start] = cycleLength\n    u = edges[start]\n    while u != start:\n      ans[u] = cycleLength\n      u = edges[u]\n", "tests": ["def test_countVisitedNodes():\n    solution = Solution()\n    edges = [1, 2, 3, 4, 2]\n    expected_output = [4, 3, 3, 3, 3]\n    assert solution.countVisitedNodes(edges) == expected_output", "def test_countVisitedNodes():\n    solution = Solution()\n    edges = [1, 0, 3, 2]\n    expected_output = [2, 2, 2, 2]\n    assert solution.countVisitedNodes(edges) == expected_output", "def test_countVisitedNodes():\n    solution = Solution()\n    edges = [1, 2, 0, 4, 5, 3]\n    expected_output = [3, 3, 3, 3, 3, 3]\n    assert solution.countVisitedNodes(edges) == expected_output", "def test_countVisitedNodes():\n    solution = Solution()\n    edges = [2, 0, 1, 5, 3, 4]\n    expected_output = [3, 3, 3, 3, 3, 3]\n    assert solution.countVisitedNodes(edges) == expected_output", "def test_countVisitedNodes():\n    solution = Solution()\n    edges = [4, 5, 6, 7, 8, 9, 0, 1, 2, 3]\n    expected_output = [10, 10, 10, 10, 10, 10, 10, 10, 10, 10]\n    assert solution.countVisitedNodes(edges) == expected_output", "def test_countVisitedNodes():\n    solution = Solution()\n    edges = [1, 2, 3, 4, 5, 0]\n    expected_output = [6, 6, 6, 6, 6, 6]\n    assert solution.countVisitedNodes(edges) == expected_output", "def test_countVisitedNodes():\n    solution = Solution()\n    edges = [3, 3, 4, 5, 3, 6, 0]\n    expected_output = [4, 4, 4, 4, 4, 4, 4]\n    assert solution.countVisitedNodes(edges) == expected_output", "def test_countVisitedNodes():\n    solution = Solution()\n    edges = [1, 2, 0, 4, 3]\n    expected_output = [3, 3, 3, 2, 2]\n    assert solution.countVisitedNodes(edges) == expected_output", "def test_countVisitedNodes():\n    solution = Solution()\n    edges = [2, 3, 4, 5, 0, 1]\n    expected_output = [6, 6, 6, 6, 6, 6]\n    assert solution.countVisitedNodes(edges) == expected_output", "def test_countVisitedNodes():\n    solution = Solution()\n    edges = [1, 0, 2, 2]\n    expected_output = [2, 2, 1, 1]\n    assert solution.countVisitedNodes(edges) == expected_output", "def test_countVisitedNodes():\n    solution = Solution()\n    edges = [1, 2, 3, 1, 5, 6, 4]\n    expected_output = [3, 3, 3, 3, 3, 3, 3]\n    assert solution.countVisitedNodes(edges) == expected_output", "def test_countVisitedNodes():\n    solution = Solution()\n    edges = [3, 0, 4, 1, 5, 6, 2]\n    expected_output = [6, 6, 6, 6, 6, 6, 6]\n    assert solution.countVisitedNodes(edges) == expected_output", "def test_countVisitedNodes():\n    solution = Solution()\n    edges = [1, 2, 3, 0, 5, 6, 4]\n    expected_output = [4, 4, 4, 4, 3, 3, 3]\n    assert solution.countVisitedNodes(edges) == expected_output", "def test_countVisitedNodes():\n    solution = Solution()\n    edges = [2, 0, 3, 1, 5, 4]\n    expected_output = [3, 3, 3, 3, 2, 2]\n    assert solution.countVisitedNodes(edges) == expected_output", "def test_countVisitedNodes():\n    solution = Solution()\n    edges = [0, 2, 3, 4, 5, 6, 1]\n    expected_output = [1, 6, 6, 6, 6, 6, 6]\n    assert solution.countVisitedNodes(edges) == expected_output", "def test_countVisitedNodes():\n    solution = Solution()\n    edges = [1, 0, 3, 4, 5, 3, 7, 6]\n    expected_output = [2, 2, 4, 3, 3, 3, 2, 2]\n    assert solution.countVisitedNodes(edges) == expected_output", "def test_countVisitedNodes():\n    solution = Solution()\n    edges = [5, 6, 0, 1, 2, 3, 4]\n    expected_output = [7, 7, 7, 7, 7, 7, 7]\n    assert solution.countVisitedNodes(edges) == expected_output", "def test_countVisitedNodes():\n    solution = Solution()\n    edges = [1, 3, 0, 2, 5, 4]\n    expected_output = [3, 3, 3, 3, 2, 2]\n    assert solution.countVisitedNodes(edges) == expected_output", "def test_countVisitedNodes():\n    solution = Solution()\n    edges = [6, 4, 5, 0, 2, 1, 3]\n    expected_output = [7, 7, 7, 7, 7, 7, 7]\n    assert solution.countVisitedNodes(edges) == expected_output", "def test_countVisitedNodes():\n    solution = Solution()\n    edges = [2, 3, 1, 0, 6, 4, 5]\n    expected_output = [4, 4, 4, 4, 3, 3, 3]\n    assert solution.countVisitedNodes(edges) == expected_output"]}
{"task_num": 2901, "task_title": "Longest Unequal Adjacent Groups Subsequence II", "func_name": "getWordsInLongestSubsequence", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def getWordsInLongestSubsequence(self, words: List[str], groups: List[int]) -> List[str]:\n    ans = []\n    n=len(words)\n    dp = [1] * n\n    prev = [-1] * n\n\n    for i in range(1, n):\n      for j in range(i):\n        if groups[i] == groups[j]:\n          continue\n        if len(words[i]) != len(words[j]):\n          continue\n        if sum(a != b for a, b in zip(words[i], words[j])) != 1:\n          continue\n        if dp[i] < dp[j] + 1:\n          dp[i] = dp[j] + 1\n          prev[i] = j\n\n    index = dp.index(max(dp))\n    while index != -1:\n      ans.append(words[index])\n      index = prev[index]\n\n    return ans[::-1]\n", "tests": ["def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = ['cat', 'bat', 'hat', 'bad', 'had']\n    groups = [1, 2, 1, 2, 1]\n    expected_output = ['cat', 'bat', 'bad']\n    assert solution.getWordsInLongestSubsequence(words, groups) == expected_output", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = ['cat', 'dog', 'cog', 'cot', 'dot']\n    groups = [1, 1, 2, 3, 2]\n    expected_output = ['dog', 'cog', 'cot']\n    assert solution.getWordsInLongestSubsequence(words, groups) == expected_output", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = ['apple', 'apply', 'crate', 'crane', 'grain']\n    groups = [1, 1, 2, 2, 3]\n    expected_output = ['apple', 'apply']\n    assert solution.getWordsInLongestSubsequence(words, groups) == expected_output", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = ['sing']\n    groups = [1]\n    expected_output = ['sing']\n    assert solution.getWordsInLongestSubsequence(words, groups) == expected_output", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = ['hit', 'hot', 'dot', 'dog', 'cog']\n    groups = [1, 1, 1, 1, 1]\n    expected_output = ['hit']\n    assert solution.getWordsInLongestSubsequence(words, groups) == expected_output", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = ['cat', 'cats', 'cots', 'dots', 'dot']\n    groups = [1, 2, 1, 2, 3]\n    expected_output = ['cat', 'cots', 'dots']\n    assert solution.getWordsInLongestSubsequence(words, groups) == expected_output", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = ['bat', 'rat', 'mat', 'cat']\n    groups = [1, 1, 1, 1]\n    expected_output = ['bat']\n    assert solution.getWordsInLongestSubsequence(words, groups) == expected_output", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = ['map', 'lap', 'lap', 'tap', 'sap']\n    groups = [1, 2, 2, 3, 4]\n    expected_output = ['map', 'lap', 'tap', 'sap']\n    assert solution.getWordsInLongestSubsequence(words, groups) == expected_output", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = ['a', 'b', 'c']\n    groups = [1, 2, 3]\n    expected_output = ['a', 'b', 'c']\n    assert solution.getWordsInLongestSubsequence(words, groups) == expected_output", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = ['abc', 'def', 'ghi']\n    groups = [1, 2, 3]\n    expected_output = ['abc']\n    assert solution.getWordsInLongestSubsequence(words, groups) == expected_output", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = ['home', 'hone', 'cone', 'bone', 'zone']\n    groups = [1, 2, 1, 2, 1]\n    expected_output = ['home', 'hone', 'cone']\n    assert solution.getWordsInLongestSubsequence(words, groups) == expected_output", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = ['plan', 'span', 'spun', 'spun']\n    groups = [1, 2, 1, 2]\n    expected_output = ['plan', 'span']\n    assert solution.getWordsInLongestSubsequence(words, groups) == expected_output", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = ['pot', 'dot', 'dog', 'bog']\n    groups = [3, 2, 1, 2]\n    expected_output = ['pot', 'dot', 'dog']\n    assert solution.getWordsInLongestSubsequence(words, groups) == expected_output", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = ['car', 'bar', 'bat', 'cat', 'rat']\n    groups = [1, 2, 1, 2, 1]\n    expected_output = ['car', 'bar', 'bat', 'cat']\n    assert solution.getWordsInLongestSubsequence(words, groups) == expected_output", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = ['loop', 'loop', 'stop', 'stap', 'step']\n    groups = [1, 2, 3, 4, 5]\n    expected_output = ['loop', 'stop', 'stap']\n    assert solution.getWordsInLongestSubsequence(words, groups) == expected_output", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = ['hand', 'sand', 'band', 'land', 'ring']\n    groups = [1, 1, 2, 2, 3]\n    expected_output = ['hand', 'band']\n    assert solution.getWordsInLongestSubsequence(words, groups) == expected_output", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = ['same', 'lame', 'lake', 'bake', 'cake']\n    groups = [1, 2, 1, 2, 3]\n    expected_output = ['same', 'lame', 'lake', 'bake']\n    assert solution.getWordsInLongestSubsequence(words, groups) == expected_output", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = ['star', 'scar', 'scab', 'stab']\n    groups = [1, 1, 1, 1]\n    expected_output = ['star']\n    assert solution.getWordsInLongestSubsequence(words, groups) == expected_output", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = ['top', 'tip', 'tap', 'topper', 'ripper']\n    groups = [1, 2, 3, 1, 2]\n    expected_output = ['top', 'tip', 'tap']\n    assert solution.getWordsInLongestSubsequence(words, groups) == expected_output", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = ['apple', 'ample', 'maple', 'maple', 'maple']\n    groups = [1, 2, 3, 4, 5]\n    expected_output = ['apple', 'ample', 'maple']\n    assert solution.getWordsInLongestSubsequence(words, groups) == expected_output"]}
{"task_num": 2904, "task_title": "Shortest and Lexicographically Smallest Beautiful String", "func_name": "shortestBeautifulSubstring", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def shortestBeautifulSubstring(self, s: str, k: int) -> str:\n    bestLeft = -1\n    minLength = len(s) + 1\n    ones = 0\n\n    l = 0\n    for r, c in enumerate(s):\n      if c == '1':\n        ones += 1\n      while ones == k:\n        if r - l + 1 < minLength:\n          bestLeft = l\n          minLength = r - l + 1\n        elif r - l + 1 == minLength and s[l:l + minLength] < s[bestLeft:bestLeft + minLength]:\n          bestLeft = l\n        if s[l] == '1':\n          ones -= 1\n        l += 1\n\n    if bestLeft == -1:\n      return \"\"\n    else:\n      return s[bestLeft:bestLeft + minLength]\n", "tests": ["def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('0011001', 2) == '100'", "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('111010', 3) == '111'", "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('0101010', 1) == '0'", "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('0000000', 1) == ''", "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('11011011', 3) == '1011'", "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('111000111', 2) == '11'", "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('101011', 4) == ''", "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('1111000', 4) == '1111'", "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('1011001011', 3) == '011'", "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('0101101110', 2) == '101'", "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('10101', 3) == ''", "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('111110', 5) == '11111'", "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('000011110000', 3) == '111'", "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('111011101110', 6) == ''", "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('101010101', 1) == '0'", "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('0001110001111', 4) == '1111'", "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('110110011110', 5) == '11011'", "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('0011100011', 3) == '110'", "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('100100100', 2) == '001'", "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('111011001', 2) == '01'"]}
{"task_num": 2911, "task_title": "Minimum Changes to Make K Semi-palindromes", "func_name": "minimumChanges", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumChanges(self, s: str, k: int) -> int:\n    n = len(s)\n    factors = self._getFactors(n)\n    cost = self._getCost(s, n, factors)\n    dp = [[n] * (k + 1) for _ in range(n + 1)]\n\n    dp[n][0] = 0\n\n    for i in range(n - 1, -1, -1):\n      for j in range(1, k + 1):\n        for l in range(i + 1, n):\n          dp[i][j] = min(dp[i][j], dp[l + 1][j - 1] + cost[i][l])\n\n    return dp[0][k]\n\n  def _getFactors(self, n: int) -> List[List[int]]:\n    factors = [[1] for _ in range(n + 1)]\n    for d in range(2, n):\n      for i in range(d * 2, n + 1, d):\n        factors[i].append(d)\n    return factors\n\n  def _getCost(self, s: str, n: int, factors: List[List[int]]) -> List[List[int]]:\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n      for j in range(i + 1, n):\n        length = j - i + 1\n        minCost = length\n        for d in factors[length]:\n          minCost = min(minCost, self._getCostD(s, i, j, d))\n        cost[i][j] = minCost\n    return cost\n\n  def _getCostD(self, s: str, i: int, j: int, d: int) -> int:\n    cost = 0\n    for offset in range(d):\n      l = i + offset\n      r = j - d + 1 + offset\n      while l < r:\n        if s[l] != s[r]:\n          cost += 1\n        l += d\n        r -= d\n    return cost\n", "tests": ["def test_minimumChanges():\n    solution = Solution()\n    assert solution.minimumChanges('abcabc', 1) == 0", "def test_minimumChanges():\n    solution = Solution()\n    assert solution.minimumChanges('aabbcc', 2) == 2", "def test_minimumChanges():\n    solution = Solution()\n    assert solution.minimumChanges('abcd', 1) == 2", "def test_minimumChanges():\n    solution = Solution()\n    assert solution.minimumChanges('aabbcc', 3) == 0", "def test_minimumChanges():\n    solution = Solution()\n    assert solution.minimumChanges('ababab', 2) == 1", "def test_minimumChanges():\n    solution = Solution()\n    assert solution.minimumChanges('abcde', 4) == 2", "def test_minimumChanges():\n    solution = Solution()\n    assert solution.minimumChanges('aaabbb', 2) == 1", "def test_minimumChanges():\n    solution = Solution()\n    assert solution.minimumChanges('xyzxyzxyz', 3) == 0", "def test_minimumChanges():\n    solution = Solution()\n    assert solution.minimumChanges('aabbc', 3) == 1", "def test_minimumChanges():\n    solution = Solution()\n    assert solution.minimumChanges('aabcabcabc', 1) == 3", "def test_minimumChanges():\n    solution = Solution()\n    assert solution.minimumChanges('abcabcabcabc', 4) == 0", "def test_minimumChanges():\n    solution = Solution()\n    assert solution.minimumChanges('mnopqr', 2) == 3", "def test_minimumChanges():\n    solution = Solution()\n    assert solution.minimumChanges('aaabbbccc', 3) == 0", "def test_minimumChanges():\n    solution = Solution()\n    assert solution.minimumChanges('zzzyyyxxx', 3) == 0", "def test_minimumChanges():\n    solution = Solution()\n    assert solution.minimumChanges('abcdefg', 7) == 3", "def test_minimumChanges():\n    solution = Solution()\n    assert solution.minimumChanges('racecar', 1) == 0", "def test_minimumChanges():\n    solution = Solution()\n    assert solution.minimumChanges('hello', 2) == 2", "def test_minimumChanges():\n    solution = Solution()\n    assert solution.minimumChanges('abcde', 5) == 0", "def test_minimumChanges():\n    solution = Solution()\n    assert solution.minimumChanges('abcdefgh', 4) == 4", "def test_minimumChanges():\n    solution = Solution()\n    assert solution.minimumChanges('abbaabba', 2) == 0"]}
{"task_num": 2932, "task_title": "Maximum Strong Pair XOR I", "func_name": "maximumStrongPairXor", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Optional\n\nclass TrieNode:\n  def __init__(self):\n    self.children: List[Optional[TrieNode]] = [None] * 2\n    self.min = math.inf\n    self.max = -math.inf\n\n\nclass BitTrie:\n  def __init__(self, maxBit: int):\n    self.maxBit = maxBit\n    self.root = TrieNode()\n\n  def insert(self, num: int) -> None:\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n      node.min = min(node.min, num)\n      node.max = max(node.max, num)\n\n  def getMaxXor(self, x: int) -> int:\n    maxXor = 0\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = x >> i & 1\n      toggleBit = bit ^ 1\n      if node.children[toggleBit] and node.children[toggleBit].max > x and node.children[toggleBit].min <= 2 * x:\n        maxXor = maxXor | 1 << i\n        node = node.children[toggleBit]\n      elif node.children[bit]:\n        node = node.children[bit]\n      else:\n        return 0\n    return maxXor\n\n\nclass Solution:\n  def maximumStrongPairXor(self, nums: List[int]) -> int:\n    maxNum = max(nums)\n    maxBit = int(math.log2(maxNum))\n    bitTrie = BitTrie(maxBit)\n\n    for num in nums:\n      bitTrie.insert(num)\n\n    return max(bitTrie.getMaxXor(num) for num in nums)\n", "tests": ["def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [3, 10, 5, 8, 15, 6]\n    assert solution.maximumStrongPairXor(nums) == 10", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [1, 2, 3, 4, 5]\n    assert solution.maximumStrongPairXor(nums) == 7", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [5, 9, 12, 25, 30]\n    assert solution.maximumStrongPairXor(nums) == 19", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [0, 7, 14, 21, 28]\n    assert solution.maximumStrongPairXor(nums) == 28", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [8, 16, 32, 64, 128]\n    assert solution.maximumStrongPairXor(nums) == 96", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [2, 3, 7, 11, 13]\n    assert solution.maximumStrongPairXor(nums) == 10", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [1, 1, 2, 2, 3, 3]\n    assert solution.maximumStrongPairXor(nums) == 3", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [1, 4, 6, 8, 10]\n    assert solution.maximumStrongPairXor(nums) == 14", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [15, 23, 31, 39, 47]\n    assert solution.maximumStrongPairXor(nums) == 56", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [10, 20, 30, 40, 50]\n    assert solution.maximumStrongPairXor(nums) == 54", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [3, 6, 9, 12, 15]\n    assert solution.maximumStrongPairXor(nums) == 14", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [7, 11, 18, 22, 35]\n    assert solution.maximumStrongPairXor(nums) == 41", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [0, 1, 2, 4, 8]\n    assert solution.maximumStrongPairXor(nums) == 12", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [14, 27, 36, 49, 58]\n    assert solution.maximumStrongPairXor(nums) == 44", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [19, 25, 37, 50, 63]\n    assert solution.maximumStrongPairXor(nums) == 58", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [5, 13, 22, 29, 38]\n    assert solution.maximumStrongPairXor(nums) == 51", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [6, 10, 17, 28, 33]\n    assert solution.maximumStrongPairXor(nums) == 43", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [1, 5, 9, 14, 20]\n    assert solution.maximumStrongPairXor(nums) == 27", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [0, 3, 6, 9, 12]\n    assert solution.maximumStrongPairXor(nums) == 15", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [2, 11, 23, 34, 46]\n    assert solution.maximumStrongPairXor(nums) == 53"]}
{"task_num": 2940, "task_title": "Find Building Where Alice and Bob Can Meet", "func_name": "leftmostBuildingQueries", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, a: int, b: int):\n    self.queryIndex = queryIndex\n    self.a = a\n    self.b = b\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.a\n    yield self.b\n\n\nclass Solution:\n  def leftmostBuildingQueries(self, heights: List[int], queries: List[List[int]]) -> List[int]:\n    ans = [-1] * len(queries)\n    stack = []\n\n    heightsIndex = len(heights) - 1\n    for queryIndex, a, b in sorted([IndexedQuery(i, min(a, b), max(a, b)) for i, (a, b) in enumerate(queries)], key=lambda iq: -iq.b):\n      if a == b or heights[a] < heights[b]:\n        ans[queryIndex] = b\n      else:\n        while heightsIndex > b:\n          while stack and heights[stack[-1]] <= heights[heightsIndex]:\n            stack.pop()\n          stack.append(heightsIndex)\n          heightsIndex -= 1\n        j = self._lastGreater(stack, a, heights)\n        if j != -1:\n          ans[queryIndex] = stack[j]\n\n    return ans\n\n  def _lastGreater(self, A: List[int], target: int, heights: List[int]):\n    l = -1\n    r = len(A) - 1\n    while l < r:\n      m = (l + r + 1) // 2\n      if heights[A[m]] > heights[target]:\n        l = m\n      else:\n        r = m - 1\n    return l\n", "tests": ["def test_leftmostBuildingQueries():\n    solution = Solution()\n    heights = [3, 1, 4, 2, 5]\n    queries = [[0, 4], [1, 3], [2, 4]]\n    expected = [4, -1, 4]\n    result = solution.leftmostBuildingQueries(heights, queries)", "def test_leftmostBuildingQueries():\n    solution = Solution()\n    heights = [5, 3, 8, 4, 6, 7]\n    queries = [[0, 2], [1, 5], [3, 5], [2, 4]]\n    expected = [2, 5, 5, 4]\n    result = solution.leftmostBuildingQueries(heights, queries)", "def test_leftmostBuildingQueries():\n    solution = Solution()\n    heights = [2, 2, 3, 1, 4]\n    queries = [[0, 3], [1, 4], [2, 3], [3, 4]]\n    expected = [-1, 4, -1, 4]\n    result = solution.leftmostBuildingQueries(heights, queries)", "def test_leftmostBuildingQueries():\n    solution = Solution()\n    heights = [1, 3, 2, 5, 4]\n    queries = [[0, 1], [1, 3], [0, 4], [2, 3]]\n    expected = [1, 3, 3, 3]\n    result = solution.leftmostBuildingQueries(heights, queries)", "def test_leftmostBuildingQueries():\n    solution = Solution()\n    heights = [7, 6, 4, 3, 5]\n    queries = [[0, 4], [1, 3], [2, 4], [0, 1]]\n    expected = [-1, -1, 4, -1]\n    result = solution.leftmostBuildingQueries(heights, queries)", "def test_leftmostBuildingQueries():\n    solution = Solution()\n    heights = [1, 2, 2, 3, 1, 4]\n    queries = [[0, 5], [3, 5], [2, 4], [0, 3]]\n    expected = [5, 5, -1, 3]\n    result = solution.leftmostBuildingQueries(heights, queries)", "def test_leftmostBuildingQueries():\n    solution = Solution()\n    heights = [4, 3, 6, 2, 8]\n    queries = [[1, 4], [0, 2], [3, 4], [2, 3]]\n    expected = [4, 2, 4, -1]\n    result = solution.leftmostBuildingQueries(heights, queries)", "def test_leftmostBuildingQueries():\n    solution = Solution()\n    heights = [5, 9, 3, 8, 6]\n    queries = [[0, 1], [1, 3], [2, 4], [0, 4]]\n    expected = [1, 3, 4, 3]\n    result = solution.leftmostBuildingQueries(heights, queries)", "def test_leftmostBuildingQueries():\n    solution = Solution()\n    heights = [2, 5, 1, 7, 3]\n    queries = [[0, 3], [1, 2], [2, 3], [3, 4]]\n    expected = [3, 3, 3, -1]\n    result = solution.leftmostBuildingQueries(heights, queries)", "def test_leftmostBuildingQueries():\n    solution = Solution()\n    heights = [10, 3, 6, 8, 2]\n    queries = [[0, 2], [1, 3], [2, 4], [0, 3]]\n    expected = [2, 3, 3, 3]\n    result = solution.leftmostBuildingQueries(heights, queries)", "def test_leftmostBuildingQueries():\n    solution = Solution()\n    heights = [3, 5, 7, 1, 4, 6]\n    queries = [[0, 4], [2, 5], [3, 5], [1, 2]]\n    expected = [4, 5, 5, 2]\n    result = solution.leftmostBuildingQueries(heights, queries)", "def test_leftmostBuildingQueries():\n    solution = Solution()\n    heights = [6, 1, 7, 3, 5, 9]\n    queries = [[0, 5], [1, 3], [2, 4], [0, 2]]\n    expected = [5, 3, 4, 2]\n    result = solution.leftmostBuildingQueries(heights, queries)", "def test_leftmostBuildingQueries():\n    solution = Solution()\n    heights = [4, 7, 3, 8, 5, 2]\n    queries = [[0, 1], [2, 3], [1, 4], [3, 5]]\n    expected = [1, 3, 3, -1]\n    result = solution.leftmostBuildingQueries(heights, queries)", "def test_leftmostBuildingQueries():\n    solution = Solution()\n    heights = [1, 5, 3, 6, 4, 2]\n    queries = [[0, 4], [1, 5], [2, 3], [0, 2]]\n    expected = [3, 3, 3, 3]\n    result = solution.leftmostBuildingQueries(heights, queries)", "def test_leftmostBuildingQueries():\n    solution = Solution()\n    heights = [3, 2, 5, 1, 7, 6]\n    queries = [[0, 5], [1, 2], [3, 4], [2, 5]]\n    expected = [4, 2, 4, 4]\n    result = solution.leftmostBuildingQueries(heights, queries)", "def test_leftmostBuildingQueries():\n    solution = Solution()\n    heights = [4, 6, 1, 5, 3, 8]\n    queries = [[0, 3], [1, 5], [2, 4], [0, 2]]\n    expected = [3, 5, 3, 3]\n    result = solution.leftmostBuildingQueries(heights, queries)", "def test_leftmostBuildingQueries():\n    solution = Solution()\n    heights = [8, 3, 5, 7, 2, 4]\n    queries = [[0, 2], [1, 4], [3, 5], [0, 1]]\n    expected = [2, 2, 5, -1]\n    result = solution.leftmostBuildingQueries(heights, queries)", "def test_leftmostBuildingQueries():\n    solution = Solution()\n    heights = [5, 9, 2, 6, 1, 7]\n    queries = [[0, 5], [2, 4], [1, 3], [3, 5]]\n    expected = [5, -1, 3, 5]\n    result = solution.leftmostBuildingQueries(heights, queries)", "def test_leftmostBuildingQueries():\n    solution = Solution()\n    heights = [6, 2, 8, 3, 5, 9]\n    queries = [[0, 2], [1, 4], [2, 5], [0, 3]]\n    expected = [2, 4, 5, 2]\n    result = solution.leftmostBuildingQueries(heights, queries)", "def test_leftmostBuildingQueries():\n    solution = Solution()\n    heights = [7, 4, 5, 3, 9, 2]\n    queries = [[0, 4], [1, 3], [2, 5], [1, 4]]\n    expected = [4, -1, 4, 4]\n    result = solution.leftmostBuildingQueries(heights, queries)"]}
{"task_num": 2948, "task_title": "Make Lexicographically Smallest Array by Swapping Elements", "func_name": "lexicographicallySmallestArray", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def lexicographicallySmallestArray(self, nums: List[int], limit: int) -> List[int]:\n    ans = [0] * len(nums)\n    numAndIndexes = sorted([(num, i) for i, num in enumerate(nums)])\n    numAndIndexesGroups: List[List[Tuple[int, int]]] = []\n\n    for numAndIndex in numAndIndexes:\n      if not numAndIndexesGroups or numAndIndex[0] - numAndIndexesGroups[-1][-1][0] > limit:\n        numAndIndexesGroups.append([numAndIndex])\n      else:\n        numAndIndexesGroups[-1].append(numAndIndex)\n\n    for numAndIndexesGroup in numAndIndexesGroups:\n      sortedNums = [num for num, _ in numAndIndexesGroup]\n      sortedIndices = sorted([index for _, index in numAndIndexesGroup])\n      for num, index in zip(sortedNums, sortedIndices):\n        ans[index] = num\n\n    return ans\n", "tests": ["def test_lexicographicallySmallestArray():\n    solution = Solution()\n    assert solution.lexicographicallySmallestArray([4, 3, 1, 2], 1) == [1, 2, 3, 4]", "def test_lexicographicallySmallestArray():\n    solution = Solution()\n    assert solution.lexicographicallySmallestArray([10, 1, 5, 3, 7], 3) == [1, 3, 5, 7, 10]", "def test_lexicographicallySmallestArray():\n    solution = Solution()\n    assert solution.lexicographicallySmallestArray([8, 5, 9, 6, 2], 4) == [2, 5, 6, 8, 9]", "def test_lexicographicallySmallestArray():\n    solution = Solution()\n    assert solution.lexicographicallySmallestArray([3, 2, 5, 4, 1], 2) == [1, 2, 3, 4, 5]", "def test_lexicographicallySmallestArray():\n    solution = Solution()\n    assert solution.lexicographicallySmallestArray([7, 6, 8, 5, 9], 1) == [5, 6, 7, 8, 9]", "def test_lexicographicallySmallestArray():\n    solution = Solution()\n    assert solution.lexicographicallySmallestArray([15, 10, 12, 11], 5) == [10, 11, 12, 15]", "def test_lexicographicallySmallestArray():\n    solution = Solution()\n    assert solution.lexicographicallySmallestArray([1, 3, 5, 7, 9], 0) == [1, 3, 5, 7, 9]", "def test_lexicographicallySmallestArray():\n    solution = Solution()\n    assert solution.lexicographicallySmallestArray([10, 20, 15, 25, 30], 5) == [10, 15, 20, 25, 30]", "def test_lexicographicallySmallestArray():\n    solution = Solution()\n    assert solution.lexicographicallySmallestArray([4, 10, 6, 14, 2], 8) == [2, 4, 6, 10, 14]", "def test_lexicographicallySmallestArray():\n    solution = Solution()\n    assert solution.lexicographicallySmallestArray([13, 17, 11, 19, 15], 4) == [11, 13, 15, 17, 19]", "def test_lexicographicallySmallestArray():\n    solution = Solution()\n    assert solution.lexicographicallySmallestArray([5, 8, 6, 12, 9, 11], 3) == [5, 6, 8, 9, 11, 12]", "def test_lexicographicallySmallestArray():\n    solution = Solution()\n    assert solution.lexicographicallySmallestArray([14, 16, 18, 10, 12], 6) == [10, 12, 14, 16, 18]", "def test_lexicographicallySmallestArray():\n    solution = Solution()\n    assert solution.lexicographicallySmallestArray([2, 3, 4, 1, 5], 3) == [1, 2, 3, 4, 5]", "def test_lexicographicallySmallestArray():\n    solution = Solution()\n    assert solution.lexicographicallySmallestArray([9, 1, 8, 2, 7], 7) == [1, 2, 7, 8, 9]", "def test_lexicographicallySmallestArray():\n    solution = Solution()\n    assert solution.lexicographicallySmallestArray([21, 19, 18, 20, 22], 3) == [18, 19, 20, 21, 22]", "def test_lexicographicallySmallestArray():\n    solution = Solution()\n    assert solution.lexicographicallySmallestArray([6, 10, 4, 8, 12], 4) == [4, 6, 8, 10, 12]", "def test_lexicographicallySmallestArray():\n    solution = Solution()\n    assert solution.lexicographicallySmallestArray([30, 40, 20, 10, 50], 15) == [10, 20, 30, 40, 50]", "def test_lexicographicallySmallestArray():\n    solution = Solution()\n    assert solution.lexicographicallySmallestArray([23, 21, 25, 27, 29], 2) == [21, 23, 25, 27, 29]", "def test_lexicographicallySmallestArray():\n    solution = Solution()\n    assert solution.lexicographicallySmallestArray([50, 45, 55, 52, 48], 5) == [45, 48, 50, 52, 55]", "def test_lexicographicallySmallestArray():\n    solution = Solution()\n    assert solution.lexicographicallySmallestArray([9, 3, 6, 12, 15], 9) == [3, 6, 9, 12, 15]"]}
{"task_num": 2953, "task_title": "Count Complete Substrings", "func_name": "countCompleteSubstrings", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countCompleteSubstrings(self, word: str, k: int) -> int:\n    uniqueLetters = len(set(word))\n    return sum(self._countCompleteStrings(word, k, windowSize) for windowSize in range(k, k * uniqueLetters + 1, k))\n\n  def _countCompleteStrings(self, word: str, k: int, windowSize: int) -> int:\n    res = 0\n    countLetters = 0\n    count = collections.Counter()\n\n    for i, c in enumerate(word):\n      count[c] += 1\n      countLetters += 1\n      if i > 0 and abs(ord(c) - ord(word[i - 1])) > 2:\n        count = collections.Counter()\n        count[c] += 1\n        countLetters = 1\n      if countLetters == windowSize + 1:\n        count[word[i - windowSize]] -= 1\n        countLetters -= 1\n      if countLetters == windowSize:\n        res += all(freq == 0 or freq == k for freq in count.values())\n\n    return res\n", "tests": ["def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings('abcabc', 2) == 2", "def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings('aabbcc', 1) == 6", "def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings('abcde', 1) == 0", "def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings('zzxyyz', 2) == 1", "def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings('abababab', 2) == 4", "def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings('aaccbbaa', 1) == 7", "def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings('xyzzyx', 2) == 0", "def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings('bccb', 1) == 4", "def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings('xyzzxz', 1) == 5", "def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings('aabcbbcc', 2) == 3", "def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings('mnopqr', 1) == 0", "def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings('bccbabab', 2) == 1", "def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings('ccccc', 5) == 1", "def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings('abac', 1) == 3", "def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings('aabbccddeeff', 2) == 6", "def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings('abccba', 1) == 6", "def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings('deedee', 2) == 0", "def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings('xyzzyxxyz', 1) == 9", "def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings('abcdefg', 1) == 0", "def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings('aaabbbccc', 3) == 1"]}
{"task_num": 2959, "task_title": "Number of Possible Sets of Closing Branches", "func_name": "numberOfSets", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:\n    return sum(self._floydWarshall(n, maxDistance, roads, mask) <= maxDistance for mask in range(1 << n))\n\n  def _floydWarshall(self, n: int, maxDistanceThreshold: int, roads: List[List[int]], mask: int) -> List[List[int]]:\n    maxDistance = 0\n    dist = [[maxDistanceThreshold + 1] * n for _ in range(n)]\n\n    for i in range(n):\n      if mask >> i & 1:\n        dist[i][i] = 0\n\n    for u, v, w in roads:\n      if mask >> u & 1 and mask >> v & 1:\n        dist[u][v] = min(dist[u][v], w)\n        dist[v][u] = min(dist[v][u], w)\n\n    for k in range(n):\n      if mask >> k & 1:\n        for i in range(n):\n          if mask >> i & 1:\n            for j in range(n):\n              if mask >> j & 1:\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    for i in range(n):\n      if mask >> i & 1:\n        for j in range(i + 1, n):\n          if mask >> j & 1:\n            maxDistance = max(maxDistance, dist[i][j])\n\n    return maxDistance\n", "tests": ["def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(4, 5, [[0, 1, 1], [1, 2, 2], [2, 3, 1], [0, 3, 3]]) == 8", "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(3, 4, [[0, 1, 1], [1, 2, 3], [0, 2, 2]]) == 7", "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(5, 10, [[0, 1, 5], [1, 2, 3], [2, 3, 2], [3, 4, 1], [0, 4, 9], [1, 3, 4]]) == 16", "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(6, 15, [[0, 1, 4], [1, 2, 6], [2, 3, 5], [3, 4, 3], [4, 5, 2], [0, 5, 10], [1, 4, 7]]) == 20", "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(4, 7, [[0, 1, 3], [1, 2, 2], [2, 3, 4], [0, 2, 5], [1, 3, 6]]) == 10", "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(3, 5, [[0, 1, 2], [1, 2, 3], [0, 2, 4]]) == 6", "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(5, 8, [[0, 1, 2], [1, 2, 2], [2, 3, 2], [3, 4, 2], [0, 4, 6]]) == 12", "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(6, 12, [[0, 1, 1], [1, 2, 2], [2, 3, 3], [3, 4, 4], [4, 5, 5], [0, 5, 11], [1, 4, 7]]) == 26", "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(4, 6, [[0, 1, 2], [1, 3, 2], [2, 3, 2], [0, 2, 3], [1, 2, 1]]) == 9", "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(5, 9, [[0, 1, 3], [1, 2, 3], [2, 3, 1], [3, 4, 1], [0, 4, 7], [1, 4, 5]]) == 14", "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(4, 10, [[0, 1, 2], [1, 2, 4], [2, 3, 3], [0, 3, 8], [1, 3, 6]]) == 15", "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(5, 6, [[0, 1, 1], [1, 2, 1], [2, 3, 1], [3, 4, 1], [0, 4, 5]]) == 10", "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(3, 3, [[0, 1, 2], [1, 2, 1], [0, 2, 3]]) == 5", "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(6, 10, [[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 2], [4, 5, 1], [0, 5, 9], [1, 4, 5]]) == 18", "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(5, 7, [[0, 1, 3], [0, 2, 5], [1, 3, 2], [2, 4, 3], [3, 4, 1]]) == 11", "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(4, 8, [[0, 1, 4], [1, 2, 2], [2, 3, 2], [0, 3, 7], [1, 3, 3]]) == 13", "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(5, 11, [[0, 1, 6], [1, 2, 5], [2, 3, 1], [3, 4, 2], [0, 4, 10], [2, 4, 3]]) == 20", "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(6, 9, [[0, 1, 2], [0, 2, 3], [1, 3, 1], [2, 4, 4], [3, 5, 5], [4, 5, 3]]) == 17", "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(4, 4, [[0, 1, 1], [1, 2, 1], [2, 3, 1], [0, 3, 3]]) == 8", "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(5, 12, [[0, 1, 3], [1, 2, 2], [2, 3, 4], [3, 4, 3], [0, 4, 10], [1, 3, 6]]) == 22"]}
{"task_num": 2973, "task_title": "Find Number of Coins to Place in Tree Nodes", "func_name": "placedCoins", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass ChildCost:\n  def __init__(self, cost: int):\n    self.numNodes = 1\n    self.maxPosCosts = [cost] if cost > 0 else []\n    self.minNegCosts = [cost] if cost < 0 else []\n\n  def update(self, childCost: 'ChildCost') -> None:\n    self.numNodes += childCost.numNodes\n    self.maxPosCosts.extend(childCost.maxPosCosts)\n    self.minNegCosts.extend(childCost.minNegCosts)\n    self.maxPosCosts.sort(reverse=True)\n    self.minNegCosts.sort()\n    self.maxPosCosts = self.maxPosCosts[:3]\n    self.minNegCosts = self.minNegCosts[:2]\n\n  def maxProduct(self) -> int:\n    if self.numNodes < 3:\n      return 1\n    if not self.maxPosCosts:\n      return 0\n    res = 0\n    if len(self.maxPosCosts) == 3:\n      res = self.maxPosCosts[0] * self.maxPosCosts[1] * self.maxPosCosts[2]\n    if len(self.minNegCosts) == 2:\n      res = max(res, self.minNegCosts[0] * self.minNegCosts[1] * self.maxPosCosts[0])\n    return res\n\n\nclass Solution:\n  def placedCoins(self, edges: List[List[int]], cost: List[int]) -> List[int]:\n    n = len(cost)\n    ans = [0] * n\n    tree = [[] for _ in range(n)]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, prev: int) -> None:\n      res = ChildCost(cost[u])\n      for v in tree[u]:\n        if v != prev:\n          res.update(dfs(v, u))\n      ans[u] = res.maxProduct()\n      return res\n\n    dfs(0, -1)\n    return ans\n", "tests": ["def test_placedCoins():\n    solution = Solution()\n    edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [2, 6]]\n    cost = [4, 5, 6, 2, -3, -2, -1]\n    assert solution.placedCoins(edges, cost) == [120, 30, 6, 1, 1, 1, 1]", "def test_placedCoins():\n    solution = Solution()\n    edges = [[0, 1], [1, 2], [1, 3], [3, 4], [3, 5]]\n    cost = [-1, 2, -3, 4, 5, 6]\n    assert solution.placedCoins(edges, cost) == [48, 48, 1, 120, 1, 1]", "def test_placedCoins():\n    solution = Solution()\n    edges = [[0, 1], [0, 2], [1, 3], [1, 4]]\n    cost = [1, -4, 2, 3, 5]\n    assert solution.placedCoins(edges, cost) == [15, 15, 1, 1, 1]", "def test_placedCoins():\n    solution = Solution()\n    edges = [[0, 1], [0, 2], [2, 3], [2, 4], [3, 5], [3, 6]]\n    cost = [6, 1, -2, -1, -3, 2, 3]\n    assert solution.placedCoins(edges, cost) == [18, 1, 18, 6, 1, 1, 1]", "def test_placedCoins():\n    solution = Solution()\n    edges = [[0, 1], [1, 2], [1, 3], [3, 4], [4, 5]]\n    cost = [7, -3, 4, 5, -6, -1]\n    assert solution.placedCoins(edges, cost) == [140, 140, 1, 30, 30, 1]", "def test_placedCoins():\n    solution = Solution()\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5]]\n    cost = [-1, -2, -3, -4, -5, 10]\n    assert solution.placedCoins(edges, cost) == [60, 60, 60, 40, 40, 1]", "def test_placedCoins():\n    solution = Solution()\n    edges = [[0, 1], [1, 2], [2, 3], [2, 4], [4, 5], [4, 6]]\n    cost = [8, 3, -2, 1, 5, 6, -4]\n    assert solution.placedCoins(edges, cost) == [240, 30, 240, 1, 30, 1, 1]", "def test_placedCoins():\n    solution = Solution()\n    edges = [[0, 1], [1, 2], [1, 3], [3, 4], [3, 5], [4, 6]]\n    cost = [1, 2, 3, -4, 5, -6, 7]\n    assert solution.placedCoins(edges, cost) == [35, 35, 1, 140, 1, 1, 1]", "def test_placedCoins():\n    solution = Solution()\n    edges = [[0, 1], [0, 2], [1, 3], [1, 4], [4, 5], [4, 6], [2, 7]]\n    cost = [2, -1, 4, 5, -3, 6, -2, 7]\n    assert solution.placedCoins(edges, cost) == [168, 60, 28, 1, 60, 1, 1, 1]", "def test_placedCoins():\n    solution = Solution()\n    edges = [[0, 1], [0, 2], [2, 3], [3, 4], [4, 5], [5, 6]]\n    cost = [3, 1, -2, 4, -1, 5, 6]\n    assert solution.placedCoins(edges, cost) == [120, 1, 120, 30, 30, 30, 1]", "def test_placedCoins():\n    solution = Solution()\n    edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [5, 6], [6, 7]]\n    cost = [5, 6, -3, -2, 3, 7, -1, 2]\n    assert solution.placedCoins(edges, cost) == [210, 10, 42, 1, 1, 14, 1, 1]", "def test_placedCoins():\n    solution = Solution()\n    edges = [[0, 1], [1, 2], [1, 3], [3, 4], [4, 5], [4, 6], [6, 7]]\n    cost = [-5, -4, 3, 2, 1, 6, 7, 8]\n    assert solution.placedCoins(edges, cost) == [336, 336, 1, 336, 336, 1, 336, 1]", "def test_placedCoins():\n    solution = Solution()\n    edges = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 5], [3, 6], [6, 7]]\n    cost = [10, -5, 3, 4, -2, -1, 2, 1]\n    assert solution.placedCoins(edges, cost) == [80, 40, 1, 8, 1, 1, 1, 1]", "def test_placedCoins():\n    solution = Solution()\n    edges = [[0, 1], [1, 2], [2, 3], [2, 4], [4, 5], [4, 6], [5, 7]]\n    cost = [-7, 8, 9, 3, -4, 2, 5, 6]\n    assert solution.placedCoins(edges, cost) == [432, 270, 432, 1, 60, 60, 1, 1]", "def test_placedCoins():\n    solution = Solution()\n    edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [5, 6], [6, 7], [7, 8]]\n    cost = [7, 6, -5, 4, 3, 2, -1, -2, 1]\n    assert solution.placedCoins(edges, cost) == [168, 72, 14, 1, 1, 6, 6, 1, 1]", "def test_placedCoins():\n    solution = Solution()\n    edges = [[0, 1], [1, 2], [1, 3], [3, 4], [4, 5], [5, 6], [5, 7], [3, 8]]\n    cost = [4, -7, 5, 9, 8, -6, 3, 2, 1]\n    assert solution.placedCoins(edges, cost) == [504, 1080, 1, 1080, 432, 144, 1, 1, 1]", "def test_placedCoins():\n    solution = Solution()\n    edges = [[0, 1], [0, 2], [1, 3], [3, 4], [3, 5], [5, 6], [2, 7], [7, 8]]\n    cost = [2, -2, -3, 4, 5, -6, -7, 8, 9]\n    assert solution.placedCoins(edges, cost) == [360, 90, 72, 90, 1, 1, 1, 72, 1]", "def test_placedCoins():\n    solution = Solution()\n    edges = [[0, 1], [0, 2], [2, 3], [2, 4], [3, 5], [5, 6], [4, 7], [7, 8]]\n    cost = [5, 4, -6, 3, 2, -1, 7, -8, 9]\n    assert solution.placedCoins(edges, cost) == [378, 1, 378, 189, 126, 63, 1, 63, 1]", "def test_placedCoins():\n    solution = Solution()\n    edges = [[0, 1], [1, 2], [1, 3], [0, 4], [4, 5], [4, 6], [6, 7], [6, 8]]\n    cost = [-9, 8, 7, -6, 5, -4, 3, 2, 1]\n    assert solution.placedCoins(edges, cost) == [504, 56, 1, 1, 56, 1, 6, 1, 1]", "def test_placedCoins():\n    solution = Solution()\n    edges = [[0, 1], [0, 2], [2, 3], [3, 4], [4, 5], [1, 6], [6, 7], [7, 8]]\n    cost = [1, 2, 3, 4, 5, -6, -7, 8, 9]\n    assert solution.placedCoins(edges, cost) == [360, 144, 120, 60, 20, 1, 72, 72, 1]"]}
{"task_num": 2976, "task_title": "Minimum Cost to Convert String I", "func_name": "minimumCost", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n    ans = 0\n    dist = [[math.inf] * 26 for _ in range(26)]\n\n    for a, b, c in zip(original, changed, cost):\n      u = ord(a) - ord('a')\n      v = ord(b) - ord('a')\n      dist[u][v] = min(dist[u][v], c)\n\n    for k in range(26):\n      for i in range(26):\n        if dist[i][k] < math.inf:\n          for j in range(26):\n            if dist[k][j] < math.inf:\n              dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    for s, t in zip(source, target):\n      if s == t:\n        continue\n      u = ord(s) - ord('a')\n      v = ord(t) - ord('a')\n      if dist[u][v] == math.inf:\n        return -1\n      ans += dist[u][v]\n\n    return ans\n", "tests": ["def test_minimumCost():\n    solution = Solution()\n    source = 'abc'\n    target = 'xyz'\n    original = ['a', 'b', 'x']\n    changed = ['x', 'y', 'z']\n    cost = [5, 10, 3]\n    assert solution.minimumCost(source, target, original, changed, cost) == 18", "def test_minimumCost():\n    solution = Solution()\n    source = 'ab'\n    target = 'bc'\n    original = ['a', 'b']\n    changed = ['b', 'c']\n    cost = [2, 4]\n    assert solution.minimumCost(source, target, original, changed, cost) == 6", "def test_minimumCost():\n    solution = Solution()\n    source = 'abcd'\n    target = 'abef'\n    original = ['c', 'd', 'e', 'f']\n    changed = ['e', 'f', 'g', 'h']\n    cost = [3, 7, 2, 1]\n    assert solution.minimumCost(source, target, original, changed, cost) == -1", "def test_minimumCost():\n    solution = Solution()\n    source = 'ace'\n    target = 'bdf'\n    original = ['a', 'c', 'e', 'b', 'd']\n    changed = ['b', 'd', 'f', 'd', 'f']\n    cost = [1, 2, 3, 1, 1]\n    assert solution.minimumCost(source, target, original, changed, cost) == 5", "def test_minimumCost():\n    solution = Solution()\n    source = 'xyz'\n    target = 'xyz'\n    original = ['a', 'b', 'c']\n    changed = ['x', 'y', 'z']\n    cost = [5, 6, 7]\n    assert solution.minimumCost(source, target, original, changed, cost) == 0", "def test_minimumCost():\n    solution = Solution()\n    source = 'mnop'\n    target = 'qrst'\n    original = ['m', 'n', 'o', 'p']\n    changed = ['q', 'r', 's', 't']\n    cost = [4, 3, 2, 1]\n    assert solution.minimumCost(source, target, original, changed, cost) == 10", "def test_minimumCost():\n    solution = Solution()\n    source = 'hello'\n    target = 'world'\n    original = ['h', 'e', 'l', 'o', 'w']\n    changed = ['w', 'o', 'r', 'l', 'd']\n    cost = [5, 3, 2, 1, 4]\n    assert solution.minimumCost(source, target, original, changed, cost) == 15", "def test_minimumCost():\n    solution = Solution()\n    source = 'abcd'\n    target = 'abcd'\n    original = ['a', 'b', 'c', 'd']\n    changed = ['e', 'f', 'g', 'h']\n    cost = [1, 2, 3, 4]\n    assert solution.minimumCost(source, target, original, changed, cost) == 0", "def test_minimumCost():\n    solution = Solution()\n    source = 'gaga'\n    target = 'baba'\n    original = ['g', 'a']\n    changed = ['b', 'b']\n    cost = [2, 3]\n    assert solution.minimumCost(source, target, original, changed, cost) == 8", "def test_minimumCost():\n    solution = Solution()\n    source = 'race'\n    target = 'care'\n    original = ['r', 'a', 'c']\n    changed = ['c', 'r', 'a']\n    cost = [1, 1, 1]\n    assert solution.minimumCost(source, target, original, changed, cost) == 2", "def test_minimumCost():\n    solution = Solution()\n    source = 'aaab'\n    target = 'cccd'\n    original = ['a', 'b']\n    changed = ['c', 'd']\n    cost = [2, 5]\n    assert solution.minimumCost(source, target, original, changed, cost) == 11", "def test_minimumCost():\n    solution = Solution()\n    source = 'pqr'\n    target = 'stu'\n    original = ['p', 'q', 'r', 's', 't', 'u']\n    changed = ['s', 't', 'u', 'p', 'q', 'r']\n    cost = [2, 3, 4, 5, 6, 7]\n    assert solution.minimumCost(source, target, original, changed, cost) == 9", "def test_minimumCost():\n    solution = Solution()\n    source = 'abba'\n    target = 'cccc'\n    original = ['a', 'b']\n    changed = ['c', 'c']\n    cost = [3, 2]\n    assert solution.minimumCost(source, target, original, changed, cost) == 10", "def test_minimumCost():\n    solution = Solution()\n    source = 'xyz'\n    target = 'abc'\n    original = ['x', 'y', 'z', 'b']\n    changed = ['a', 'b', 'c', 'c']\n    cost = [4, 5, 6, 1]\n    assert solution.minimumCost(source, target, original, changed, cost) == 15", "def test_minimumCost():\n    solution = Solution()\n    source = 'kite'\n    target = 'site'\n    original = ['k', 's']\n    changed = ['s', 'k']\n    cost = [1, 1]\n    assert solution.minimumCost(source, target, original, changed, cost) == 1", "def test_minimumCost():\n    solution = Solution()\n    source = 'apple'\n    target = 'aqple'\n    original = ['p']\n    changed = ['q']\n    cost = [2]\n    assert solution.minimumCost(source, target, original, changed, cost) == -1", "def test_minimumCost():\n    solution = Solution()\n    source = 'mom'\n    target = 'dad'\n    original = ['m', 'o', 'a', 'd']\n    changed = ['d', 'a', 'o', 'm']\n    cost = [5, 6, 1, 2]\n    assert solution.minimumCost(source, target, original, changed, cost) == 8", "def test_minimumCost():\n    solution = Solution()\n    source = 'loop'\n    target = 'poop'\n    original = ['l', 'p']\n    changed = ['p', 'l']\n    cost = [3, 3]\n    assert solution.minimumCost(source, target, original, changed, cost) == 3", "def test_minimumCost():\n    solution = Solution()\n    source = 'abcdef'\n    target = 'ghijkl'\n    original = ['a', 'b', 'c', 'd', 'e', 'f']\n    changed = ['g', 'h', 'i', 'j', 'k', 'l']\n    cost = [10, 9, 8, 7, 6, 5]\n    assert solution.minimumCost(source, target, original, changed, cost) == 45", "def test_minimumCost():\n    solution = Solution()\n    source = 'panama'\n    target = 'banana'\n    original = ['p', 'm']\n    changed = ['b', 'n']\n    cost = [4, 2]\n    assert solution.minimumCost(source, target, original, changed, cost) == -1"]}
{"task_num": 2977, "task_title": "Minimum Cost to Convert String II", "func_name": "minimumCost", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n    subLengths = set(len(s) for s in original)\n    subToId = self._getSubToId(original, changed)\n    subCount = len(subToId)\n    dist = [[math.inf for _ in range(subCount)] for _ in range(subCount)]\n    dp = [math.inf for _ in range(len(source) + 1)]\n\n    for a, b, c in zip(original, changed, cost):\n      u = subToId[a]\n      v = subToId[b]\n      dist[u][v] = min(dist[u][v], c)\n\n    for k in range(subCount):\n      for i in range(subCount):\n        if dist[i][k] < math.inf:\n          for j in range(subCount):\n            if dist[k][j] < math.inf:\n              dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    dp[0] = 0\n\n    for i, (s, t) in enumerate(zip(source, target)):\n      if dp[i] == math.inf:\n        continue\n      if s == t:\n        dp[i + 1] = min(dp[i + 1], dp[i])\n      for subLength in subLengths:\n        if i + subLength > len(source):\n          continue\n        subSource = source[i:i + subLength]\n        subTarget = target[i:i + subLength]\n        if subSource not in subToId or subTarget not in subToId:\n          continue\n        u = subToId[subSource]\n        v = subToId[subTarget]\n        if dist[u][v] != math.inf:\n          dp[i + subLength] = min(dp[i + subLength], dp[i] + dist[u][v])\n\n    if dp[len(source)] == math.inf:\n      return -1\n    else:\n      return dp[len(source)]\n\n  def _getSubToId(self, original: str, changed: str) -> Dict[str, int]:\n    subToId = {}\n    for s in original + changed:\n      if s not in subToId:\n        subToId[s] = len(subToId)\n    return subToId\n", "tests": ["def test_minimumCost():\n    solution = Solution()", "def test_minimumCost():\n    solution = Solution()", "def test_minimumCost():\n    solution = Solution()", "def test_minimumCost():\n    solution = Solution()", "def test_minimumCost():\n    solution = Solution()", "def test_minimumCost():\n    solution = Solution()", "def test_minimumCost():\n    solution = Solution()", "def test_minimumCost():\n    solution = Solution()", "def test_minimumCost():\n    solution = Solution()", "def test_minimumCost():\n    solution = Solution()", "def test_minimumCost():\n    solution = Solution()", "def test_minimumCost():\n    solution = Solution()", "def test_minimumCost():\n    solution = Solution()", "def test_minimumCost():\n    solution = Solution()", "def test_minimumCost():\n    solution = Solution()", "def test_minimumCost():\n    solution = Solution()", "def test_minimumCost():\n    solution = Solution()", "def test_minimumCost():\n    solution = Solution()", "def test_minimumCost():\n    solution = Solution()", "def test_minimumCost():\n    solution = Solution()"]}
{"task_num": 2983, "task_title": "Palindrome Rearrangement Queries", "func_name": "canMakePalindromeQueries", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n    n = len(s)\n    mirroredDiffs = self._getMirroredDiffs(s)\n    counts = self._getCounts(s)\n    ans = []\n\n    def subtractArrays(a: List[int], b: List[int]):\n      return [x - y for x, y in zip(a, b)]\n\n    for a, b, c, d in queries:\n      b += 1\n      d += 1\n      ra = n - a\n      rb = n - b\n      rc = n - c\n      rd = n - d\n\n      if (min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0) or (n // 2 > max(b, rc) and mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0):\n        ans.append(False)\n      else:\n        leftRangeCount = subtractArrays(counts[b], counts[a])\n        rightRangeCount = subtractArrays(counts[d], counts[c])\n        if a > rd:\n          rightRangeCount = subtractArrays(\n              rightRangeCount, subtractArrays(counts[min(a, rc)], counts[rd]))\n        if rc > b:\n          rightRangeCount = subtractArrays(\n              rightRangeCount, subtractArrays(counts[rc], counts[max(b, rd)]))\n        if c > rb:\n          leftRangeCount = subtractArrays(\n              leftRangeCount, subtractArrays(counts[min(c, ra)], counts[rb]))\n        if ra > d:\n          leftRangeCount = subtractArrays(\n              leftRangeCount, subtractArrays(counts[ra], counts[max(d, rb)]))\n        ans.append(min(leftRangeCount) >= 0\n                   and min(rightRangeCount) >= 0\n                   and leftRangeCount == rightRangeCount)\n\n    return ans\n\n  def _getMirroredDiffs(self, s: str) -> List[int]:\n    diffs = [0]\n    for i, j in zip(range(len(s)), reversed(range(len(s)))):\n      if i >= j:\n        break\n      diffs.append(diffs[-1] + (s[i] != s[j]))\n    return diffs\n\n  def _getCounts(self, s: str) -> List[List[int]]:\n    count = [0] * 26\n    counts = [count.copy()]\n    for c in s:\n      count[ord(c) - ord('a')] += 1\n      counts.append(count.copy())\n    return counts\n", "tests": ["def test_canMakePalindromeQueries():\n    solution = Solution()\n    s = 'abbaabba'\n    queries = [[0, 3, 4, 7]]\n    assert solution.canMakePalindromeQueries(s, queries) == [True]", "def test_canMakePalindromeQueries():\n    solution = Solution()\n    s = 'abcdabcd'\n    queries = [[0, 1, 6, 7]]\n    assert solution.canMakePalindromeQueries(s, queries) == [False]", "def test_canMakePalindromeQueries():\n    solution = Solution()\n    s = 'aacbbacc'\n    queries = [[0, 2, 5, 7]]\n    assert solution.canMakePalindromeQueries(s, queries) == [True]", "def test_canMakePalindromeQueries():\n    solution = Solution()\n    s = 'abcabcxy'\n    queries = [[0, 1, 4, 5]]\n    assert solution.canMakePalindromeQueries(s, queries) == [False]", "def test_canMakePalindromeQueries():\n    solution = Solution()\n    s = 'xyyxxyyx'\n    queries = [[0, 3, 4, 7]]\n    assert solution.canMakePalindromeQueries(s, queries) == [True]", "def test_canMakePalindromeQueries():\n    solution = Solution()\n    s = 'abcdefgh'\n    queries = [[0, 3, 4, 7], [0, 0, 7, 7]]\n    assert solution.canMakePalindromeQueries(s, queries) == [False, True]", "def test_canMakePalindromeQueries():\n    solution = Solution()\n    s = 'abccbaab'\n    queries = [[0, 2, 5, 6]]\n    assert solution.canMakePalindromeQueries(s, queries) == [True]", "def test_canMakePalindromeQueries():\n    solution = Solution()\n    s = 'mnopponm'\n    queries = [[0, 0, 7, 7], [1, 3, 4, 6]]\n    assert solution.canMakePalindromeQueries(s, queries) == [True, True]", "def test_canMakePalindromeQueries():\n    solution = Solution()\n    s = 'zzxxzzxx'\n    queries = [[0, 2, 6, 7], [1, 1, 4, 4]]\n    assert solution.canMakePalindromeQueries(s, queries) == [True, True]", "def test_canMakePalindromeQueries():\n    solution = Solution()\n    s = 'aabbccdd'\n    queries = [[0, 1, 6, 7], [2, 3, 4, 5]]\n    assert solution.canMakePalindromeQueries(s, queries) == [False, False]", "def test_canMakePalindromeQueries():\n    solution = Solution()\n    s = 'wxyzxyzw'\n    queries = [[0, 0, 3, 3], [2, 2, 5, 5]]\n    assert solution.canMakePalindromeQueries(s, queries) == [True, True]", "def test_canMakePalindromeQueries():\n    solution = Solution()\n    s = 'ijkllkji'\n    queries = [[0, 3, 4, 7], [0, 1, 2, 3]]\n    assert solution.canMakePalindromeQueries(s, queries) == [True, False]", "def test_canMakePalindromeQueries():\n    solution = Solution()\n    s = 'mnopqpon'\n    queries = [[0, 2, 5, 7], [0, 0, 4, 4]]\n    assert solution.canMakePalindromeQueries(s, queries) == [True, True]", "def test_canMakePalindromeQueries():\n    solution = Solution()\n    s = 'aabbccbb'\n    queries = [[0, 3, 4, 7], [1, 2, 5, 6]]\n    assert solution.canMakePalindromeQueries(s, queries) == [False, True]", "def test_canMakePalindromeQueries():\n    solution = Solution()\n    s = 'abcdefgh'\n    queries = [[0, 1, 6, 7], [0, 0, 7, 7], [1, 1, 5, 5]]\n    assert solution.canMakePalindromeQueries(s, queries) == [False, True, False]", "def test_canMakePalindromeQueries():\n    solution = Solution()\n    s = 'qrsstuvv'\n    queries = [[0, 2, 5, 7], [1, 1, 6, 6], [3, 3, 4, 4]]\n    assert solution.canMakePalindromeQueries(s, queries) == [False, False, True]", "def test_canMakePalindromeQueries():\n    solution = Solution()\n    s = 'nnxxmmnn'\n    queries = [[0, 3, 4, 7], [0, 0, 4, 4], [2, 2, 6, 6]]\n    assert solution.canMakePalindromeQueries(s, queries) == [True, True, True]", "def test_canMakePalindromeQueries():\n    solution = Solution()\n    s = 'raceecar'\n    queries = [[0, 1, 6, 7], [1, 3, 4, 5]]\n    assert solution.canMakePalindromeQueries(s, queries) == [False, True]", "def test_canMakePalindromeQueries():\n    solution = Solution()\n    s = 'bbaaccaa'\n    queries = [[0, 3, 4, 7], [0, 2, 5, 6], [1, 1, 7, 7]]\n    assert solution.canMakePalindromeQueries(s, queries) == [True, False, True]", "def test_canMakePalindromeQueries():\n    solution = Solution()\n    s = 'xyzzyzzy'\n    queries = [[0, 2, 5, 7], [0, 1, 6, 6], [2, 3, 4, 5]]\n    assert solution.canMakePalindromeQueries(s, queries) == [True, False, True]"]}
{"task_num": 3001, "task_title": "Minimum Moves to Capture The Queen", "func_name": "minMovesToCaptureTheQueen", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minMovesToCaptureTheQueen(self, a: int, b: int, c: int, d: int, e: int, f: int) -> int:\n    if a == e:\n      if c == a and (b < d < f or b > d > f):\n        return 2\n      else:\n        return 1\n    if b == f:\n      if d == f and (a < c < e or a > c > e):\n        return 2\n      else:\n        return 1\n    if c + d == e + f:\n      if a + b == c + d and (c < a < e or c > a > e):\n        return 2\n      else:\n        return 1\n    if c - d == e - f:\n      if a - b == c - d and (c < a < e or c > a > e):\n        return 2\n      else:\n        return 1\n    return 2\n", "tests": ["def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(1, 4, 5, 4, 1, 8) == 1", "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(3, 3, 6, 6, 8, 8) == 2", "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(4, 4, 2, 6, 6, 6) == 1", "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(7, 1, 5, 3, 7, 5) == 1", "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(2, 2, 3, 1, 5, 5) == 2", "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(1, 1, 8, 8, 2, 1) == 1", "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(6, 2, 4, 4, 6, 4) == 2", "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(3, 5, 6, 2, 3, 1) == 1", "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(4, 6, 4, 2, 4, 8) == 1", "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(5, 5, 7, 7, 8, 5) == 1", "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(8, 3, 3, 8, 3, 3) == 1", "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(2, 7, 1, 6, 8, 7) == 1", "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(5, 1, 2, 4, 7, 4) == 2", "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(1, 2, 3, 4, 5, 6) == 2", "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(6, 6, 5, 7, 6, 3) == 1", "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(3, 3, 1, 5, 5, 1) == 2", "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(2, 2, 6, 6, 2, 6) == 1", "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(5, 3, 3, 5, 1, 3) == 2", "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(4, 5, 1, 8, 8, 5) == 1", "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(3, 7, 6, 4, 3, 3) == 2"]}
{"task_num": 3006, "task_title": "Find Beautiful Indices in the Given Array I", "func_name": "beautifulIndices", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def beautifulIndices(self, s: str, a: str, b: str, k: int) -> List[int]:\n    ans = []\n    indicesA = self._kmp(s, a)\n    indicesB = self._kmp(s, b)\n    indicesBIndex = 0\n\n    for i in indicesA:\n      while indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i < -k:\n        indicesBIndex += 1\n      if indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i <= k:\n        ans.append(i)\n\n    return ans\n\n  def _kmp(self, s: str, pattern: str) -> List[int]:\n    def getLPS(pattern: str) -> List[int]:\n      lps = [0] * len(pattern)\n      j = 0\n      for i in range(1, len(pattern)):\n        while j > 0 and pattern[j] != pattern[i]:\n          j = lps[j - 1]\n        if pattern[i] == pattern[j]:\n          lps[i] = j + 1\n          j += 1\n      return lps\n\n    res = []\n    lps = getLPS(pattern)\n    i = 0\n    j = 0\n    while i < len(s):\n      if s[i] == pattern[j]:\n        i += 1\n        j += 1\n        if j == len(pattern):\n          res.append(i - j)\n          j = lps[j - 1]\n      elif j != 0:\n        j = lps[j - 1]\n      else:\n        i += 1\n    return res\n", "tests": ["def test_beautifulIndices():\n    solution = Solution()\n    s = 'abcacbacbab'\n    a = 'abc'\n    b = 'bac'\n    k = 3\n    expected_output = [0, 3]\n    assert solution.beautifulIndices(s, a, b, k) == expected_output", "def test_beautifulIndices():\n    solution = Solution()\n    s = 'abxabxabxab'\n    a = 'ab'\n    b = 'xab'\n    k = 2\n    expected_output = [0, 2, 4, 6, 8]\n    assert solution.beautifulIndices(s, a, b, k) == expected_output", "def test_beautifulIndices():\n    solution = Solution()\n    s = 'aaaaa'\n    a = 'aa'\n    b = 'aaa'\n    k = 1\n    expected_output = [0, 1, 2]\n    assert solution.beautifulIndices(s, a, b, k) == expected_output", "def test_beautifulIndices():\n    solution = Solution()\n    s = 'xyzxyzxy'\n    a = 'xy'\n    b = 'yz'\n    k = 0\n    expected_output = []\n    assert solution.beautifulIndices(s, a, b, k) == expected_output", "def test_beautifulIndices():\n    solution = Solution()\n    s = 'ababababab'\n    a = 'aba'\n    b = 'bab'\n    k = 1\n    expected_output = [0, 2, 4, 6]\n    assert solution.beautifulIndices(s, a, b, k) == expected_output", "def test_beautifulIndices():\n    solution = Solution()\n    s = 'abcdefg'\n    a = 'abc'\n    b = 'efg'\n    k = 6\n    expected_output = [0]\n    assert solution.beautifulIndices(s, a, b, k) == expected_output", "def test_beautifulIndices():\n    solution = Solution()\n    s = 'abcdefghijklmnopqrstuvwxyz'\n    a = 'mno'\n    b = 'stu'\n    k = 4\n    expected_output = []\n    assert solution.beautifulIndices(s, a, b, k) == expected_output", "def test_beautifulIndices():\n    solution = Solution()\n    s = 'cacbabca'\n    a = 'ca'\n    b = 'ba'\n    k = 2\n    expected_output = [0, 4]\n    assert solution.beautifulIndices(s, a, b, k) == expected_output", "def test_beautifulIndices():\n    solution = Solution()\n    s = 'testtesttest'\n    a = 'test'\n    b = 'test'\n    k = 0\n    expected_output = [0, 4, 8]\n    assert solution.beautifulIndices(s, a, b, k) == expected_output", "def test_beautifulIndices():\n    solution = Solution()\n    s = 'zzzyyyzzz'\n    a = 'zzz'\n    b = 'yyy'\n    k = 2\n    expected_output = [0, 3]\n    assert solution.beautifulIndices(s, a, b, k) == expected_output", "def test_beautifulIndices():\n    solution = Solution()\n    s = 'mnopqr'\n    a = 'mn'\n    b = 'op'\n    k = 1\n    expected_output = []\n    assert solution.beautifulIndices(s, a, b, k) == expected_output", "def test_beautifulIndices():\n    solution = Solution()\n    s = 'aabbccddeeff'\n    a = 'aa'\n    b = 'ee'\n    k = 10\n    expected_output = [0]\n    assert solution.beautifulIndices(s, a, b, k) == expected_output", "def test_beautifulIndices():\n    solution = Solution()\n    s = 'xyzxyzxyz'\n    a = 'xyz'\n    b = 'yxz'\n    k = 3\n    expected_output = []\n    assert solution.beautifulIndices(s, a, b, k) == expected_output", "def test_beautifulIndices():\n    solution = Solution()\n    s = 'abababab'\n    a = 'ab'\n    b = 'ba'\n    k = 1\n    expected_output = [0, 2, 4, 6]\n    assert solution.beautifulIndices(s, a, b, k) == expected_output", "def test_beautifulIndices():\n    solution = Solution()\n    s = 'hellohello'\n    a = 'hel'\n    b = 'lo'\n    k = 3\n    expected_output = [0, 5]\n    assert solution.beautifulIndices(s, a, b, k) == expected_output", "def test_beautifulIndices():\n    solution = Solution()\n    s = 'abcdeabcabcde'\n    a = 'abc'\n    b = 'cde'\n    k = 4\n    expected_output = [0, 7]\n    assert solution.beautifulIndices(s, a, b, k) == expected_output", "def test_beautifulIndices():\n    solution = Solution()\n    s = 'xyzabcxyzabc'\n    a = 'xyz'\n    b = 'abc'\n    k = 3\n    expected_output = [0, 6]\n    assert solution.beautifulIndices(s, a, b, k) == expected_output", "def test_beautifulIndices():\n    solution = Solution()\n    s = 'aabbbaaabb'\n    a = 'aab'\n    b = 'bba'\n    k = 2\n    expected_output = [0, 4]\n    assert solution.beautifulIndices(s, a, b, k) == expected_output", "def test_beautifulIndices():\n    solution = Solution()\n    s = 'xyzzyxxyz'\n    a = 'xyz'\n    b = 'zyx'\n    k = 4\n    expected_output = [0, 5]\n    assert solution.beautifulIndices(s, a, b, k) == expected_output", "def test_beautifulIndices():\n    solution = Solution()\n    s = 'racecarace'\n    a = 'ace'\n    b = 'car'\n    k = 3\n    expected_output = [5]\n    assert solution.beautifulIndices(s, a, b, k) == expected_output"]}
{"task_num": 3029, "task_title": "Minimum Time to Revert Word to Initial State I", "func_name": "minimumTimeToInitialState", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumTimeToInitialState(self, word: str, k: int) -> int:\n    n = len(word)\n    maxOps = (n - 1) // k + 1\n    z = self._zFunction(word)\n\n    for ans in range(1, maxOps):\n      if z[ans * k] >= n - ans * k:\n        return ans\n\n    return maxOps\n\n  def _zFunction(self, s: str) -> List[int]:\n    n = len(s)\n    z = [0] * n\n    l = 0\n    r = 0\n    for i in range(1, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l])\n      while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n    return z\n", "tests": ["def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState('abcabcabc', 3) == 1", "def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState('abcdabcd', 2) == 2", "def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState('aaaaaa', 1) == 1", "def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState('abababab', 4) == 1", "def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState('xyzxyz', 3) == 1", "def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState('abcdefgh', 5) == 8", "def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState('abacabadabacaba', 7) == 2", "def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState('abcdefabc', 3) == 3", "def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState('aaaaabbbbbaaaaa', 5) == 3", "def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState('aabbccdd', 2) == 4", "def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState('xyzxyzxy', 8) == 2", "def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState('abcdefghij', 3) == 10", "def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState('ababababab', 5) == 2", "def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState('mnopqrst', 4) == 8", "def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState('abcdeabcdeabcde', 5) == 3", "def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState('abcdefgh', 1) == 8", "def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState('aabbaabbaabb', 6) == 2", "def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState('abcabcde', 2) == 7", "def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState('abababababab', 4) == 3", "def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState('zzzzzzzz', 2) == 1"]}
{"task_num": 3030, "task_title": "Find the Grid of Region Average", "func_name": "resultGrid", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def resultGrid(self, image: List[List[int]], threshold: int) -> List[List[int]]:\n    m = len(image)\n    n = len(image[0])\n    sums = [[0] * n for _ in range(m)]\n    counts = [[0] * n for _ in range(m)]\n\n    for i in range(m - 2):\n      for j in range(n - 2):\n        if self._isRegion(image, i, j, threshold):\n          subgridSum = sum(image[x][y] for x in range(i, i + 3) for y in range(j, j + 3))\n          for x in range(i, i + 3):\n            for y in range(j, j + 3):\n              sums[x][y] += subgridSum // 9\n              counts[x][y] += 1\n\n    for i in range(m):\n      for j in range(n):\n        if counts[i][j] > 0:\n          image[i][j] = sums[i][j] // counts[i][j]\n\n    return image\n\n  def _isRegion(self, image: List[List[int]], i: int, j: int, threshold: int) -> bool:\n    for x in range(i, i + 3):\n      for y in range(j, j + 3):\n        if x > i and abs(image[x][y] - image[x - 1][y]) > threshold:\n          return False\n        if y > j and abs(image[x][y] - image[x][y - 1]) > threshold:\n          return False\n    return True\n", "tests": ["def test_resultGrid():\n    solution = Solution()\n    image = [[10, 12, 14, 16], [20, 22, 24, 26], [30, 32, 34, 36], [40, 42, 44, 46]]\n    threshold = 5\n    expected_output = [[10, 13, 16, 16], [22, 25, 28, 26], [34, 37, 40, 36], [40, 42, 44, 46]]\n    result = solution.resultGrid(image, threshold)", "def test_resultGrid():\n    solution = Solution()\n    image = [[100, 110, 120], [110, 120, 130], [120, 130, 140], [130, 140, 150]]\n    threshold = 15\n    expected_output = [[110, 120, 120], [120, 130, 130], [130, 140, 140], [130, 140, 150]]\n    result = solution.resultGrid(image, threshold)", "def test_resultGrid():\n    solution = Solution()\n    image = [[50, 55, 60, 65, 70, 75, 80]]\n    threshold = 10\n    expected_output = [[50, 55, 60, 65, 70, 75, 80]]\n    result = solution.resultGrid(image, threshold)", "def test_resultGrid():\n    solution = Solution()\n    image = [[255, 200, 150], [100, 50, 0], [0, 50, 100]]\n    threshold = 20\n    expected_output = [[255, 200, 150], [100, 50, 0], [0, 50, 100]]\n    result = solution.resultGrid(image, threshold)", "def test_resultGrid():\n    solution = Solution()\n    image = [[5, 5, 5], [5, 5, 5], [5, 5, 5]]\n    threshold = 0\n    expected_output = [[5, 5, 5], [5, 5, 5], [5, 5, 5]]\n    result = solution.resultGrid(image, threshold)", "def test_resultGrid():\n    solution = Solution()\n    image = [[10, 15, 10], [15, 20, 15], [10, 15, 10], [5, 10, 5]]\n    threshold = 10\n    expected_output = [[15, 15, 15], [15, 15, 15], [15, 15, 15], [5, 10, 5]]\n    result = solution.resultGrid(image, threshold)", "def test_resultGrid():\n    solution = Solution()\n    image = [[1, 2, 3, 4], [4, 5, 6, 7], [7, 8, 9, 10], [10, 11, 12, 13]]\n    threshold = 0\n    expected_output = [[1, 2, 3, 4], [4, 5, 6, 7], [7, 8, 9, 10], [10, 11, 12, 13]]\n    result = solution.resultGrid(image, threshold)", "def test_resultGrid():\n    solution = Solution()\n    image = [[100, 120, 140], [160, 180, 200], [220, 240, 255]]\n    threshold = 100\n    expected_output = [[165, 165, 165], [165, 165, 165], [165, 165, 165]]\n    result = solution.resultGrid(image, threshold)", "def test_resultGrid():\n    solution = Solution()\n    image = [[20, 20, 30, 30], [20, 20, 30, 30], [40, 40, 50, 50], [40, 40, 50, 50]]\n    threshold = 10\n    expected_output = [[23, 25, 30, 30], [26, 28, 30, 30], [40, 40, 50, 50], [40, 40, 50, 50]]\n    result = solution.resultGrid(image, threshold)", "def test_resultGrid():\n    solution = Solution()\n    image = [[10], [20], [30], [40], [50]]\n    threshold = 5\n    expected_output = [[10], [20], [30], [40], [50]]\n    result = solution.resultGrid(image, threshold)", "def test_resultGrid():\n    solution = Solution()\n    image = [[1, 2, 3], [7, 8, 9], [13, 14, 15], [19, 20, 21]]\n    threshold = 3\n    expected_output = [[5, 5, 5], [10, 10, 10], [14, 14, 15], [19, 20, 21]]\n    result = solution.resultGrid(image, threshold)", "def test_resultGrid():\n    solution = Solution()\n    image = [[5, 5, 6, 6], [5, 5, 6, 6], [7, 7, 8, 8], [7, 7, 8, 8]]\n    threshold = 1\n    expected_output = [[6, 6, 6, 6], [6, 6, 6, 6], [7, 7, 7, 8], [7, 7, 7, 8]]\n    result = solution.resultGrid(image, threshold)", "def test_resultGrid():\n    solution = Solution()\n    image = [[10, 20, 30], [20, 30, 40], [30, 40, 50]]\n    threshold = 8\n    expected_output = [[20, 26, 30], [26, 33, 40], [30, 40, 50]]\n    result = solution.resultGrid(image, threshold)", "def test_resultGrid():\n    solution = Solution()\n    image = [[42, 42, 42], [42, 42, 42], [42, 42, 42]]\n    threshold = 0\n    expected_output = [[42, 42, 42], [42, 42, 42], [42, 42, 42]]\n    result = solution.resultGrid(image, threshold)", "def test_resultGrid():\n    solution = Solution()\n    image = [[5, 10, 15, 20], [10, 15, 20, 25], [15, 20, 25, 30], [20, 25, 30, 35]]\n    threshold = 4\n    expected_output = [[10, 13, 15, 20], [15, 18, 20, 25], [20, 23, 25, 30], [20, 25, 30, 35]]\n    result = solution.resultGrid(image, threshold)", "def test_resultGrid():\n    solution = Solution()\n    image = [[10, 20, 30, 40], [50, 60, 70, 80], [90, 100, 110, 120]]\n    threshold = 15\n    expected_output = [[40, 50, 60, 40], [70, 80, 90, 80], [90, 100, 110, 120]]\n    result = solution.resultGrid(image, threshold)", "def test_resultGrid():\n    solution = Solution()\n    image = [[0, 255, 0, 255], [255, 0, 255, 0], [0, 255, 0, 255], [255, 0, 255, 0]]\n    threshold = 250\n    expected_output = [[113, 141, 113, 141], [141, 113, 141, 113], [113, 141, 113, 141], [255, 0, 255, 0]]\n    result = solution.resultGrid(image, threshold)", "def test_resultGrid():\n    solution = Solution()\n    image = [[10, 20, 30, 40, 50], [60, 70, 80, 90, 100], [110, 120, 130, 140, 150], [160, 170, 180, 190, 200]]\n    threshold = 20\n    expected_output = [[55, 65, 75, 85, 50], [105, 115, 125, 135, 100], [155, 165, 175, 185, 150], [160, 170, 180, 190, 200]]\n    result = solution.resultGrid(image, threshold)", "def test_resultGrid():\n    solution = Solution()\n    image = [[1, 100, 1], [100, 1, 100], [1, 100, 1]]\n    threshold = 50\n    expected_output = [[1, 100, 1], [100, 1, 100], [1, 100, 1]]\n    result = solution.resultGrid(image, threshold)", "def test_resultGrid():\n    solution = Solution()\n    image = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]\n    threshold = 2\n    expected_output = [[4, 5, 6, 4], [8, 9, 10, 8], [12, 13, 14, 12], [13, 14, 15, 16]]\n    result = solution.resultGrid(image, threshold)"]}
{"task_num": 3043, "task_title": "Find the Length of the Longest Common Prefix", "func_name": "longestCommonPrefix", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass TrieNode:\n  def __init__(self):\n    self.children: Dict[str, TrieNode] = {}\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def insert(self, word: str) -> None:\n    node: TrieNode = self.root\n    for c in word:\n      node = node.children.setdefault(c, TrieNode())\n    node.isWord = True\n\n  def search(self, word: str) -> int:\n    prefixLength = 0\n    node = self.root\n    for c in word:\n      if c not in node.children:\n        break\n      node = node.children[c]\n      prefixLength += 1\n    return prefixLength\n\n\nclass Solution:\n  def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:\n    trie = Trie()\n\n    for num in arr1:\n      trie.insert(str(num))\n\n    return max(trie.search(str(num)) for num in arr2)\n", "tests": ["def test_longestCommonPrefix():\n    solution = Solution()\n    arr1 = [12345, 123, 56789]\n    arr2 = [123, 125, 678]\n    assert solution.longestCommonPrefix(arr1, arr2) == 3", "def test_longestCommonPrefix():\n    solution = Solution()\n    arr1 = [78954, 98765, 4321]\n    arr2 = [789, 1234, 8765]\n    assert solution.longestCommonPrefix(arr1, arr2) == 0", "def test_longestCommonPrefix():\n    solution = Solution()\n    arr1 = []\n    arr2 = [123, 456, 789]\n    assert solution.longestCommonPrefix(arr1, arr2) == 0", "def test_longestCommonPrefix():\n    solution = Solution()\n    arr1 = [123456]\n    arr2 = [123, 1234567, 124]\n    assert solution.longestCommonPrefix(arr1, arr2) == 3", "def test_longestCommonPrefix():\n    solution = Solution()\n    arr1 = [555, 55, 5555]\n    arr2 = [5555, 555, 55555]\n    assert solution.longestCommonPrefix(arr1, arr2) == 3", "def test_longestCommonPrefix():\n    solution = Solution()\n    arr1 = [321, 654, 987]\n    arr2 = [123, 456, 789]\n    assert solution.longestCommonPrefix(arr1, arr2) == 0", "def test_longestCommonPrefix():\n    solution = Solution()\n    arr1 = [98765, 98754]\n    arr2 = [987, 986]\n    assert solution.longestCommonPrefix(arr1, arr2) == 3", "def test_longestCommonPrefix():\n    solution = Solution()\n    arr1 = [234, 567, 890]\n    arr2 = [234, 567, 890]\n    assert solution.longestCommonPrefix(arr1, arr2) == 3", "def test_longestCommonPrefix():\n    solution = Solution()\n    arr1 = [4589, 4, 458]\n    arr2 = [45, 4567, 4578]\n    assert solution.longestCommonPrefix(arr1, arr2) == 2", "def test_longestCommonPrefix():\n    solution = Solution()\n    arr1 = [3, 34, 345]\n    arr2 = [30, 31, 32]\n    assert solution.longestCommonPrefix(arr1, arr2) == 1", "def test_longestCommonPrefix():\n    solution = Solution()\n    arr1 = [1234, 1256, 1278]\n    arr2 = [12, 120, 123]\n    assert solution.longestCommonPrefix(arr1, arr2) == 2", "def test_longestCommonPrefix():\n    solution = Solution()\n    arr1 = [67890, 67812, 67834]\n    arr2 = [678, 679, 680]\n    assert solution.longestCommonPrefix(arr1, arr2) == 3", "def test_longestCommonPrefix():\n    solution = Solution()\n    arr1 = [145, 246, 357]\n    arr2 = [678, 789, 890]\n    assert solution.longestCommonPrefix(arr1, arr2) == 0", "def test_longestCommonPrefix():\n    solution = Solution()\n    arr1 = [12345, 6789]\n    arr2 = [123, 1234, 123456]\n    assert solution.longestCommonPrefix(arr1, arr2) == 3", "def test_longestCommonPrefix():\n    solution = Solution()\n    arr1 = [45678, 4567, 456]\n    arr2 = [4567, 456, 45]\n    assert solution.longestCommonPrefix(arr1, arr2) == 3", "def test_longestCommonPrefix():\n    solution = Solution()\n    arr1 = [101, 202, 303]\n    arr2 = [404, 505, 606]\n    assert solution.longestCommonPrefix(arr1, arr2) == 0", "def test_longestCommonPrefix():\n    solution = Solution()\n    arr1 = [987654321, 987654320]\n    arr2 = [98765431, 98765432]\n    assert solution.longestCommonPrefix(arr1, arr2) == 8", "def test_longestCommonPrefix():\n    solution = Solution()\n    arr1 = [7777, 7777, 7777]\n    arr2 = [7777, 7777, 7777]\n    assert solution.longestCommonPrefix(arr1, arr2) == 4", "def test_longestCommonPrefix():\n    solution = Solution()\n    arr1 = [1414, 2424, 3434]\n    arr2 = [141, 242, 343]\n    assert solution.longestCommonPrefix(arr1, arr2) == 2", "def test_longestCommonPrefix():\n    solution = Solution()\n    arr1 = [1234, 5678, 91011]\n    arr2 = [9876, 5432, 10987]\n    assert solution.longestCommonPrefix(arr1, arr2) == 0"]}
{"task_num": 3044, "task_title": "Most Frequent Prime", "func_name": "mostFrequentPrime", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def mostFrequentPrime(self, mat: List[List[int]]) -> int:\n    dirs = ((1, 0), (1, -1), (0, -1), (-1, -1),\n            (-1, 0), (-1, 1), (0, 1), (1, 1))\n    m = len(mat)\n    n = len(mat[0])\n    count = collections.Counter()\n\n    def isPrime(num: int) -> bool:\n      return not any(num % i == 0 for i in range(2, int(num**0.5 + 1)))\n\n    for i in range(m):\n      for j in range(n):\n        for dx, dy in dirs:\n          num = 0\n          x = i\n          y = j\n          while 0 <= x < m and 0 <= y < n:\n            num = num * 10 + mat[x][y]\n            if num > 10 and isPrime(num):\n              count[num] += 1\n            x += dx\n            y += dy\n\n    if not count.items():\n      return -1\n    return max(count.items(), key=lambda x: (x[1], x[0]))[0]\n", "tests": ["def test_mostFrequentPrime():\n    solution = Solution()\n    assert solution.mostFrequentPrime([[1, 3, 7], [7, 1, 3], [3, 7, 1]]) == 37", "def test_mostFrequentPrime():\n    solution = Solution()\n    assert solution.mostFrequentPrime([[2, 3], [5, 7]]) == 23", "def test_mostFrequentPrime():\n    solution = Solution()\n    assert solution.mostFrequentPrime([[1, 4, 6], [8, 9, 10], [6, 4, 1]]) == -1", "def test_mostFrequentPrime():\n    solution = Solution()\n    assert solution.mostFrequentPrime([[3, 1, 1, 7]]) == 31", "def test_mostFrequentPrime():\n    solution = Solution()\n    assert solution.mostFrequentPrime([[5], [3], [7], [1]]) == 53", "def test_mostFrequentPrime():\n    solution = Solution()\n    assert solution.mostFrequentPrime([[1, 1], [1, 3]]) == 13", "def test_mostFrequentPrime():\n    solution = Solution()", "def test_mostFrequentPrime():\n    solution = Solution()", "def test_mostFrequentPrime():\n    solution = Solution()\n    assert solution.mostFrequentPrime([[11]]) == -1", "def test_mostFrequentPrime():\n    solution = Solution()", "def test_mostFrequentPrime():\n    solution = Solution()", "def test_mostFrequentPrime():\n    solution = Solution()", "def test_mostFrequentPrime():\n    solution = Solution()", "def test_mostFrequentPrime():\n    solution = Solution()", "def test_mostFrequentPrime():\n    solution = Solution()", "def test_mostFrequentPrime():\n    solution = Solution()", "def test_mostFrequentPrime():\n    solution = Solution()", "def test_mostFrequentPrime():\n    solution = Solution()", "def test_mostFrequentPrime():\n    solution = Solution()", "def test_mostFrequentPrime():\n    solution = Solution()"]}
{"task_num": 3072, "task_title": "Distribute Elements Into Two Arrays II", "func_name": "resultArray", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass FenwickTree:\n  def __init__(self, n: int):\n    self.sums = [0] * (n + 1)\n\n  def update(self, i: int, delta: int) -> None:\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def resultArray(self, nums: List[int]) -> List[int]:\n    arr1 = []\n    arr2 = []\n    ranks = self._getRanks(nums)\n    tree1 = FenwickTree(len(ranks))\n    tree2 = FenwickTree(len(ranks))\n\n    def add(num: int, arr: List[int], tree: FenwickTree) -> None:\n      arr.append(num)\n      tree.update(ranks[num], 1)\n\n    add(nums[0], arr1, tree1)\n    add(nums[1], arr2, tree2)\n\n    for i in range(2, len(nums)):\n      greaterCount1 = len(arr1) - tree1.get(ranks[nums[i]])\n      greaterCount2 = len(arr2) - tree2.get(ranks[nums[i]])\n      if greaterCount1 > greaterCount2:\n        add(nums[i], arr1, tree1)\n      elif greaterCount1 < greaterCount2:\n        add(nums[i], arr2, tree2)\n      elif len(arr1) > len(arr2):\n        add(nums[i], arr2, tree2)\n      else:\n        add(nums[i], arr1, tree1)\n\n    return arr1 + arr2\n\n  def _getRanks(self, nums: List[int]) -> Dict[int, int]:\n    ranks = collections.Counter()\n    rank = 0\n    for num in sorted(set(nums)):\n      rank += 1\n      ranks[num] = rank\n    return ranks\n", "tests": ["def test_resultArray():\n    solution = Solution()\n    assert solution.resultArray([3, 2, 5, 1, 4]) == [3, 5, 1, 2, 4]", "def test_resultArray():\n    solution = Solution()\n    assert solution.resultArray([1, 3, 2, 6, 5, 4]) == [1, 6, 5, 3, 2, 4]", "def test_resultArray():\n    solution = Solution()\n    assert solution.resultArray([10, 20, 30, 15, 25, 35]) == [10, 30, 35, 20, 15, 25]", "def test_resultArray():\n    solution = Solution()\n    assert solution.resultArray([5, 5, 5, 5, 5]) == [5, 5, 5, 5, 5]", "def test_resultArray():\n    solution = Solution()\n    assert solution.resultArray([7, 3, 9, 2, 8, 1]) == [7, 9, 8, 1, 3, 2]", "def test_resultArray():\n    solution = Solution()\n    assert solution.resultArray([4, 6, 4, 6, 4]) == [4, 4, 4, 6, 6]", "def test_resultArray():\n    solution = Solution()\n    assert solution.resultArray([10, 5, 20, 15, 25, 30]) == [10, 20, 25, 30, 5, 15]", "def test_resultArray():\n    solution = Solution()\n    assert solution.resultArray([2, 1, 4, 3, 6, 5]) == [2, 4, 6, 1, 3, 5]", "def test_resultArray():\n    solution = Solution()\n    assert solution.resultArray([8, 7, 6, 5, 4, 3]) == [8, 6, 5, 4, 7, 3]", "def test_resultArray():\n    solution = Solution()\n    assert solution.resultArray([1, 2, 3, 4, 5, 6]) == [1, 4, 5, 6, 2, 3]", "def test_resultArray():\n    solution = Solution()\n    assert solution.resultArray([9, 12, 11, 13, 8, 10]) == [9, 13, 8, 10, 12, 11]", "def test_resultArray():\n    solution = Solution()\n    assert solution.resultArray([15, 14, 13, 12, 11, 10]) == [15, 13, 12, 11, 14, 10]", "def test_resultArray():\n    solution = Solution()\n    assert solution.resultArray([1, 5, 3, 7, 4, 2]) == [1, 7, 4, 5, 3, 2]", "def test_resultArray():\n    solution = Solution()\n    assert solution.resultArray([6, 2, 9, 1, 3, 8]) == [6, 9, 3, 8, 2, 1]", "def test_resultArray():\n    solution = Solution()\n    assert solution.resultArray([7, 1, 8, 4, 2, 9]) == [7, 8, 9, 1, 4, 2]", "def test_resultArray():\n    solution = Solution()\n    assert solution.resultArray([3, 3, 2, 2, 1, 1]) == [3, 2, 1, 3, 2, 1]", "def test_resultArray():\n    solution = Solution()\n    assert solution.resultArray([11, 22, 33, 44, 55, 66]) == [11, 44, 55, 66, 22, 33]", "def test_resultArray():\n    solution = Solution()\n    assert solution.resultArray([5, 10, 5, 10, 5, 10]) == [5, 5, 5, 10, 10, 10]", "def test_resultArray():\n    solution = Solution()\n    assert solution.resultArray([20, 18, 16, 14, 12, 10]) == [20, 16, 14, 12, 18, 10]", "def test_resultArray():\n    solution = Solution()\n    assert solution.resultArray([4, 8, 12, 16, 20, 24]) == [4, 16, 20, 24, 8, 12]"]}
{"task_num": 3095, "task_title": "Shortest Subarray With OR at Least K I", "func_name": "minimumSubarrayLength", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumSubarrayLength(self, nums: List[int], k: int) -> int:\n    ans = len(nums) + 1\n    ors = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, num in enumerate(nums):\n      ors = self._orNum(ors, num, count)\n      while ors >= k and l <= r:\n        ans = min(ans, r - l + 1)\n        ors = self._undoOrNum(ors, nums[l], count)\n        l += 1\n\n    return -1 if ans == len(nums) + 1 else ans\n\n  def _orNum(self, ors: int, num: int, count: Dict[int, int]) -> int:\n    for i in range(30):\n      if num >> i & 1:\n        count[i] += 1\n        if count[i] == 1:\n          ors += 1 << i\n    return ors\n\n  def _undoOrNum(self, ors: int, num: int, count: Dict[int, int]) -> int:\n    for i in range(30):\n      if num >> i & 1:\n        count[i] -= 1\n        if count[i] == 0:\n          ors -= 1 << i\n    return ors\n", "tests": ["def test_minimumSubarrayLength():\n    solution = Solution()\n    assert solution.minimumSubarrayLength([1, 2, 4, 8], 7) == 2", "def test_minimumSubarrayLength():\n    solution = Solution()\n    assert solution.minimumSubarrayLength([5, 1, 3, 2, 8], 10) == 1", "def test_minimumSubarrayLength():\n    solution = Solution()\n    assert solution.minimumSubarrayLength([0, 0, 0, 0], 1) == -1", "def test_minimumSubarrayLength():\n    solution = Solution()\n    assert solution.minimumSubarrayLength([3, 6, 1, 2, 9, 10], 15) == 2", "def test_minimumSubarrayLength():\n    solution = Solution()\n    assert solution.minimumSubarrayLength([2, 4, 16, 32], 64) == -1", "def test_minimumSubarrayLength():\n    solution = Solution()\n    assert solution.minimumSubarrayLength([10, 5, 1, 7, 3], 11) == 1", "def test_minimumSubarrayLength():\n    solution = Solution()\n    assert solution.minimumSubarrayLength([1, 1, 1, 1, 1, 1], 2) == 2", "def test_minimumSubarrayLength():\n    solution = Solution()\n    assert solution.minimumSubarrayLength([7, 3, 5, 1, 12], 15) == 3", "def test_minimumSubarrayLength():\n    solution = Solution()\n    assert solution.minimumSubarrayLength([8, 1, 2, 4, 8], 8) == 1", "def test_minimumSubarrayLength():\n    solution = Solution()\n    assert solution.minimumSubarrayLength([2, 4, 8, 16, 32], 24) == 3", "def test_minimumSubarrayLength():\n    solution = Solution()\n    assert solution.minimumSubarrayLength([0, 2, 4, 6, 15], 15) == 1", "def test_minimumSubarrayLength():\n    solution = Solution()\n    assert solution.minimumSubarrayLength([1, 3, 7, 15, 31], 31) == 1", "def test_minimumSubarrayLength():\n    solution = Solution()\n    assert solution.minimumSubarrayLength([5, 10, 5, 10, 5], 15) == 2", "def test_minimumSubarrayLength():\n    solution = Solution()\n    assert solution.minimumSubarrayLength([8, 7, 6, 5, 4], 8) == 1", "def test_minimumSubarrayLength():\n    solution = Solution()\n    assert solution.minimumSubarrayLength([1, 2, 3, 4, 10], 11) == 2", "def test_minimumSubarrayLength():\n    solution = Solution()\n    assert solution.minimumSubarrayLength([9, 1, 8, 2, 3], 10) == 1", "def test_minimumSubarrayLength():\n    solution = Solution()\n    assert solution.minimumSubarrayLength([1, 5, 2, 7, 3, 10], 12) == 2", "def test_minimumSubarrayLength():\n    solution = Solution()\n    assert solution.minimumSubarrayLength([4, 4, 4, 4, 16], 16) == 1", "def test_minimumSubarrayLength():\n    solution = Solution()\n    assert solution.minimumSubarrayLength([2, 3, 7, 8, 12], 14) == 2", "def test_minimumSubarrayLength():\n    solution = Solution()\n    assert solution.minimumSubarrayLength([1, 2, 1, 2, 1, 2], 3) == 2"]}
{"task_num": 3102, "task_title": "Minimize Manhattan Distances", "func_name": "minimumDistance", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumDistance(self, points: List[List[int]]) -> int:\n    i, j = self._maxManhattanDistance(points, -1)\n    xi, yi = self._maxManhattanDistance(points, i)\n    xj, yj = self._maxManhattanDistance(points, j)\n    return min(self._manhattan(points, xi, yi), self._manhattan(points, xj, yj))\n\n  def _maxManhattanDistance(self, points: List[List[int]], excludedIndex: int) -> int:\n    minSum = math.inf\n    maxSum = -math.inf\n    minDiff = math.inf\n    maxDiff = -math.inf\n    minSumIndex = -1\n    maxSumIndex = -1\n    minDiffIndex = -1\n    maxDiffIndex = -1\n\n    for i, (x, y) in enumerate(points):\n      if i == excludedIndex:\n        continue\n      summ = x + y\n      diff = x - y\n      if summ < minSum:\n        minSum = summ\n        minSumIndex = i\n      if summ > maxSum:\n        maxSum = summ\n        maxSumIndex = i\n      if diff < minDiff:\n        minDiff = diff\n        minDiffIndex = i\n      if diff > maxDiff:\n        maxDiff = diff\n        maxDiffIndex = i\n\n    if maxSum - minSum >= maxDiff - minDiff:\n      return [minSumIndex, maxSumIndex]\n    else:\n      return [minDiffIndex, maxDiffIndex]\n\n  def _manhattan(self, points: List[List[int]], i: int, j: int) -> int:\n    return abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n", "tests": ["def test_minimumDistance():\n    solution = Solution()\n    points = [[0, 0], [2, 3], [1, 1], [5, 5]]\n    assert solution.minimumDistance(points) == 6", "def test_minimumDistance():\n    solution = Solution()\n    points = [[1, 2], [3, 4], [5, 6], [7, 8]]\n    assert solution.minimumDistance(points) == 4", "def test_minimumDistance():\n    solution = Solution()\n    points = [[-1, -2], [-3, -4], [-5, -6], [-7, -8]]\n    assert solution.minimumDistance(points) == 4", "def test_minimumDistance():\n    solution = Solution()\n    points = [[-1, 2], [3, -4], [-5, 6], [7, -8]]\n    assert solution.minimumDistance(points) == 14", "def test_minimumDistance():\n    solution = Solution()\n    points = [[1, 1], [1, 1], [1, 1], [1, 1]]\n    assert solution.minimumDistance(points) == 0", "def test_minimumDistance():\n    solution = Solution()\n    points = [[1000, 1000], [-1000, -1000], [500, 500], [-500, -500]]\n    assert solution.minimumDistance(points) == 2000", "def test_minimumDistance():\n    solution = Solution()\n    points = [[0, 0], [1, 1], [2, 2], [3, 3]]\n    assert solution.minimumDistance(points) == 4", "def test_minimumDistance():\n    solution = Solution()\n    points = [[1, 2], [3, 6], [5, 9], [8, 12]]\n    assert solution.minimumDistance(points) == 8", "def test_minimumDistance():\n    solution = Solution()\n    points = [[0, 0], [0, 5], [5, 5], [5, 0]]\n    assert solution.minimumDistance(points) == 10", "def test_minimumDistance():\n    solution = Solution()\n    points = [[0, 0], [1, 1], [1, 0], [0, 1]]\n    assert solution.minimumDistance(points) == 1", "def test_minimumDistance():\n    solution = Solution()\n    points = [[100, 100], [-100, -100], [200, 200], [-200, -200]]\n    assert solution.minimumDistance(points) == 400", "def test_minimumDistance():\n    solution = Solution()\n    points = [[0, 0], [0, 5], [0, 10], [0, 15]]\n    assert solution.minimumDistance(points) == 10", "def test_minimumDistance():\n    solution = Solution()\n    points = [[0, 0], [5, 0], [10, 0], [15, 0]]\n    assert solution.minimumDistance(points) == 10", "def test_minimumDistance():\n    solution = Solution()\n    points = [[0, 0], [2, 2], [4, 4], [6, 6]]\n    assert solution.minimumDistance(points) == 8", "def test_minimumDistance():\n    solution = Solution()\n    points = [[0, 0], [2, 3], [7, 1], [12, 10]]\n    assert solution.minimumDistance(points) == 14", "def test_minimumDistance():\n    solution = Solution()\n    points = [[i, i * 2] for i in range(100, 105)]\n    assert solution.minimumDistance(points) == 10", "def test_minimumDistance():\n    solution = Solution()\n    points = [[0, 0], [0, 2], [2, 2], [2, 0]]\n    assert solution.minimumDistance(points) == 4", "def test_minimumDistance():\n    solution = Solution()\n    points = [[0, 0], [0, 2], [2, 0], [-2, 0]]\n    assert solution.minimumDistance(points) == 4", "def test_minimumDistance():\n    solution = Solution()\n    points = [[-1, 3], [3, -1], [4, 4], [-2, -2]]\n    assert solution.minimumDistance(points) == 10", "def test_minimumDistance():\n    solution = Solution()\n    points = [[1, 1], [1, 1], [1, 1], [2, 2]]\n    assert solution.minimumDistance(points) == 0"]}
{"task_num": 3108, "task_title": "Minimum Cost Walk in Weighted Graph", "func_name": "minimumCost", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n    self.weight = [(1 << 17) - 1] * n\n\n  def unionByRank(self, u: int, v: int, w: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    newWeight = self.weight[i] & self.weight[j] & w\n    self.weight[i] = newWeight\n    self.weight[j] = newWeight\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def getMinCost(self, u: int, v: int) -> int:\n    if u == v:\n      return 0\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return self.weight[i]\n    else:\n      return -1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def minimumCost(self, n: int, edges: List[List[int]], query: List[List[int]]) -> List[int]:\n    uf = UnionFind(n)\n\n    for u, v, w in edges:\n      uf.unionByRank(u, v, w)\n\n    return [uf.getMinCost(u, v) for u, v in query]\n", "tests": ["def test_minimumCost():\n    solution = Solution()", "def test_minimumCost():\n    solution = Solution()", "def test_minimumCost():\n    solution = Solution()", "def test_minimumCost():\n    solution = Solution()", "def test_minimumCost():\n    solution = Solution()", "def test_minimumCost():\n    solution = Solution()", "def test_minimumCost():\n    solution = Solution()", "def test_minimumCost():\n    solution = Solution()", "def test_minimumCost():\n    solution = Solution()", "def test_minimumCost():\n    solution = Solution()", "def test_minimumCost():\n    solution = Solution()", "def test_minimumCost():\n    solution = Solution()", "def test_minimumCost():\n    solution = Solution()", "def test_minimumCost():\n    solution = Solution()", "def test_minimumCost():\n    solution = Solution()", "def test_minimumCost():\n    solution = Solution()", "def test_minimumCost():\n    solution = Solution()", "def test_minimumCost():\n    solution = Solution()", "def test_minimumCost():\n    solution = Solution()", "def test_minimumCost():\n    solution = Solution()"]}
{"task_num": 3112, "task_title": "Minimum Time to Visit Disappearing Nodes", "func_name": "minimumTime", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, 0, disappear)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, disappear: List[int]) -> List[int]:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < disappear[v] and d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    res=[]\n    for d in dist:\n      if d != math.inf:\n        res.append(d)\n      else:\n        res.append(-1)\n    return res\n", "tests": ["def test_minimumTime():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 2], [1, 2, 4], [2, 3, 1], [0, 4, 3]]\n    disappear = [5, 5, 7, 6, 4]\n    assert solution.minimumTime(n, edges, disappear) == [0, 2, 6, -1, 3]", "def test_minimumTime():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 3], [0, 2, 1], [1, 2, 1], [2, 3, 1]]\n    disappear = [10, 2, 4, 5]\n    assert solution.minimumTime(n, edges, disappear) == [0, -1, 1, 2]", "def test_minimumTime():\n    solution = Solution()\n    n = 6\n    edges = [[0, 1, 1], [1, 2, 2], [1, 3, 3], [3, 4, 2], [4, 5, 1]]\n    disappear = [5, 2, 7, 6, 8, 10]\n    assert solution.minimumTime(n, edges, disappear) == [0, -1, -1, -1, -1, -1]", "def test_minimumTime():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 2], [1, 2, 2], [0, 2, 4]]\n    disappear = [10, 5, 3]\n    assert solution.minimumTime(n, edges, disappear) == [0, 2, -1]", "def test_minimumTime():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 2], [1, 2, 2], [2, 3, 2], [0, 3, 7]]\n    disappear = [8, 6, 5, 10]\n    assert solution.minimumTime(n, edges, disappear) == [0, 2, -1, -1]", "def test_minimumTime():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 3], [1, 4, 2], [0, 2, 5], [2, 3, 2], [3, 4, 1]]\n    disappear = [10, 4, 6, 8, 9]\n    assert solution.minimumTime(n, edges, disappear) == [0, -1, 5, 7, -1]", "def test_minimumTime():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 1], [1, 2, 1]]\n    disappear = [3, 1, 3]\n    assert solution.minimumTime(n, edges, disappear) == [0, -1, -1]", "def test_minimumTime():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 4], [1, 2, 1], [2, 3, 1], [0, 3, 10]]\n    disappear = [8, 6, 7, 5]\n    assert solution.minimumTime(n, edges, disappear) == [0, 4, 5, -1]", "def test_minimumTime():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 2], [0, 2, 3], [1, 3, 2], [3, 4, 1], [2, 4, 5]]\n    disappear = [10, 5, 6, 8, 10]\n    assert solution.minimumTime(n, edges, disappear) == [0, 2, 3, 4, 5]", "def test_minimumTime():\n    solution = Solution()\n    n = 6\n    edges = [[0, 1, 1], [0, 2, 2], [1, 3, 1], [2, 3, 3], [3, 4, 1], [4, 5, 2]]\n    disappear = [10, 4, 5, 7, 9, 10]\n    assert solution.minimumTime(n, edges, disappear) == [0, 1, 2, 2, 3, 5]", "def test_minimumTime():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 5], [1, 2, 1], [2, 3, 1], [0, 2, 2]]\n    disappear = [10, 7, 3, 6]\n    assert solution.minimumTime(n, edges, disappear) == [0, -1, 2, -1]", "def test_minimumTime():\n    solution = Solution()\n    n = 7\n    edges = [[0, 1, 1], [1, 2, 1], [2, 3, 1], [3, 4, 1], [4, 5, 1], [5, 6, 1]]\n    disappear = [8, 3, 4, 5, 6, 7, 9]\n    assert solution.minimumTime(n, edges, disappear) == [0, 1, -1, -1, -1, -1, -1]", "def test_minimumTime():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 2], [1, 2, 2], [0, 3, 5], [3, 4, 1], [2, 4, 3]]\n    disappear = [10, 9, 4, 10, 7]\n    assert solution.minimumTime(n, edges, disappear) == [0, 2, -1, 5, -1]", "def test_minimumTime():\n    solution = Solution()\n    n = 6\n    edges = [[0, 1, 2], [1, 2, 2], [2, 3, 2], [3, 4, 2], [4, 5, 2], [0, 5, 10]]\n    disappear = [10, 5, 6, 7, 8, 9]\n    assert solution.minimumTime(n, edges, disappear) == [0, 2, -1, -1, -1, -1]", "def test_minimumTime():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 3], [1, 2, 1], [2, 3, 1], [0, 3, 8]]\n    disappear = [10, 9, 5, 6]\n    assert solution.minimumTime(n, edges, disappear) == [0, 3, -1, -1]", "def test_minimumTime():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 4], [1, 2, 1], [2, 3, 2], [3, 4, 1], [0, 2, 3]]\n    disappear = [10, 5, 6, 7, 10]\n    assert solution.minimumTime(n, edges, disappear) == [0, -1, 3, -1, -1]", "def test_minimumTime():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 4], [1, 2, 2]]\n    disappear = [10, 10, 5]\n    assert solution.minimumTime(n, edges, disappear) == [0, 4, -1]", "def test_minimumTime():\n    solution = Solution()\n    n = 6\n    edges = [[0, 1, 2], [1, 2, 2], [0, 3, 3], [3, 4, 4], [4, 5, 5]]\n    disappear = [10, 3, 5, 10, 8, 9]\n    assert solution.minimumTime(n, edges, disappear) == [0, 2, -1, 3, -1, -1]", "def test_minimumTime():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 1], [1, 2, 1], [2, 3, 1], [3, 4, 1], [0, 4, 10]]\n    disappear = [10, 2, 3, 4, 5]\n    assert solution.minimumTime(n, edges, disappear) == [0, -1, -1, -1, -1]", "def test_minimumTime():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 5], [0, 2, 2], [2, 3, 2], [1, 3, 1]]\n    disappear = [10, 6, 5, 5]\n    assert solution.minimumTime(n, edges, disappear) == [0, -1, 2, -1]"]}
{"task_num": 3123, "task_title": "Find Edges in Shortest Paths", "func_name": "findAnswer", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findAnswer(self, n: int, edges: List[List[int]]) -> List[bool]:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    from0 = self._dijkstra(graph, 0)\n    from1 = self._dijkstra(graph, n - 1)\n    return [from0[u] + w + from1[v] == from0[-1] or from0[v] + w + from1[u] == from0[-1] for u, v, w in edges]\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int) -> List[int]:\n    dist = [10**9] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist\n", "tests": ["def test_findAnswer():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 1], [1, 2, 2], [0, 2, 2], [2, 3, 1]]\n    expected_output = [True, True, True, True]\n    assert solution.findAnswer(n, edges) == expected_output", "def test_findAnswer():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 1], [1, 2, 2], [2, 3, 1], [3, 4, 3], [0, 4, 6]]\n    expected_output = [True, True, True, True, False]\n    assert solution.findAnswer(n, edges) == expected_output", "def test_findAnswer():\n    solution = Solution()\n    n = 6\n    edges = [[0, 1, 1], [1, 2, 2], [4, 5, 1]]\n    expected_output = [False, False, False]\n    assert solution.findAnswer(n, edges) == expected_output", "def test_findAnswer():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 1], [1, 2, 1], [0, 2, 2]]\n    expected_output = [True, True, True]\n    assert solution.findAnswer(n, edges) == expected_output", "def test_findAnswer():\n    solution = Solution()\n    n = 1\n    edges = []\n    expected_output = []\n    assert solution.findAnswer(n, edges) == expected_output", "def test_findAnswer():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 5], [1, 3, 2], [0, 2, 1], [2, 3, 1]]\n    expected_output = [False, True, True, True]\n    assert solution.findAnswer(n, edges) == expected_output", "def test_findAnswer():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 1], [1, 2, 1], [2, 3, 1], [3, 4, 1], [0, 4, 10]]\n    expected_output = [True, True, True, True, False]\n    assert solution.findAnswer(n, edges) == expected_output", "def test_findAnswer():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 2], [1, 3, 2], [0, 2, 1], [2, 3, 3]]\n    expected_output = [True, True, True, False]\n    assert solution.findAnswer(n, edges) == expected_output", "def test_findAnswer():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 1], [1, 2, 1], [0, 2, 1]]\n    expected_output = [True, True, True]\n    assert solution.findAnswer(n, edges) == expected_output", "def test_findAnswer():\n    solution = Solution()\n    n = 2\n    edges = []\n    expected_output = []\n    assert solution.findAnswer(n, edges) == expected_output", "def test_findAnswer():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 1], [1, 2, 2]]\n    expected_output = [False, False]\n    assert solution.findAnswer(n, edges) == expected_output", "def test_findAnswer():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 1], [1, 4, 1], [0, 2, 10], [2, 3, 10], [3, 4, 10]]\n    expected_output = [True, True, False, False, False]\n    assert solution.findAnswer(n, edges) == expected_output", "def test_findAnswer():\n    solution = Solution()\n    n = 2\n    edges = [[0, 1, 3]]\n    expected_output = [True]\n    assert solution.findAnswer(n, edges) == expected_output", "def test_findAnswer():\n    solution = Solution()\n    n = 6\n    edges = [[0, 1, 1], [1, 2, 1], [3, 4, 1], [4, 5, 1]]\n    expected_output = [True, True, False, False]\n    assert solution.findAnswer(n, edges) == expected_output", "def test_findAnswer():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 1], [1, 2, 1], [2, 3, 1], [3, 0, 1]]\n    expected_output = [True, True, True, False]\n    assert solution.findAnswer(n, edges) == expected_output", "def test_findAnswer():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 1], [0, 1, 1], [1, 2, 1]]\n    expected_output = [True, True, True]\n    assert solution.findAnswer(n, edges) == expected_output", "def test_findAnswer():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 1], [0, 2, 5], [1, 2, 2], [2, 3, 1]]\n    expected_output = [True, False, True, True]\n    assert solution.findAnswer(n, edges) == expected_output", "def test_findAnswer():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 1], [0, 1, 2], [1, 3, 1], [0, 2, 1], [2, 3, 1]]\n    expected_output = [True, False, True, True, True]\n    assert solution.findAnswer(n, edges) == expected_output", "def test_findAnswer():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 10], [1, 4, 10], [0, 2, 1], [2, 3, 1], [3, 4, 1]]\n    expected_output = [False, False, True, True, True]\n    assert solution.findAnswer(n, edges) == expected_output", "def test_findAnswer():\n    solution = Solution()\n    n = 3\n    edges = [[0, 2, 1], [0, 1, 2], [1, 2, 2]]\n    expected_output = [True, False, False]\n    assert solution.findAnswer(n, edges) == expected_output"]}
