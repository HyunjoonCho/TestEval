{"task_num": 4, "task_title": "Median of Two Sorted Arrays", "func_name": "findMedianSortedArrays", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n    n1 = len(nums1)\n    n2 = len(nums2)\n    if n1 > n2:\n      return self.findMedianSortedArrays(nums2, nums1)\n\n    l = 0\n    r = n1\n\n    while l <= r:\n      partition1 = (l + r) // 2\n      partition2 = (n1 + n2 + 1) // 2 - partition1\n      maxLeft1 = -2**31 if partition1 == 0 else nums1[partition1 - 1]\n      maxLeft2 = -2**31 if partition2 == 0 else nums2[partition2 - 1]\n      minRight1 = 2**31 - 1 if partition1 == n1 else nums1[partition1]\n      minRight2 = 2**31 - 1 if partition2 == n2 else nums2[partition2]\n      if maxLeft1 <= minRight2 and maxLeft2 <= minRight1:\n        if (n1 + n2) % 2 == 0:\n          return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) * 0.5\n        else:\n          return max(maxLeft1, maxLeft2)\n      elif maxLeft1 > minRight2:\n        r = partition1 - 1\n      else:\n        l = partition1 + 1\n", "tests": {"16": "def test_findMedianSortedArrays():\n    solution = Solution()\n    nums1 = [1, 3]\n    nums2 = [2]\n    assert solution.findMedianSortedArrays(nums1, nums2) == 2.0", "29": "def test_findMedianSortedArrays(self):\n    solution = Solution()\n    nums1 = [1, 3]\n    nums2 = [2]\n    result = solution.findMedianSortedArrays(nums1, nums2)", "30": "def test_findMedianSortedArrays(self):\n    nums1 = [1, 3]\n    nums2 = [2]\n    self.assertAlmostEqual(solution.findMedianSortedArrays(nums1, nums2), (max(1, 2) + min(3, 2)) * 0.5)", "32": "def test_findMedianSortedArrays():\n\n    def findMedianSortedArrays(nums1: List[int], nums2: List[int]) -> float:\n        n1 = len(nums1)\n        n2 = len(nums2)\n        if n1 > n2:\n            return findMedianSortedArrays(nums2, nums1)\n        l = 0\n        r = n1\n        while l <= r:\n            partition1 = (l + r) // 2\n            partition2 = (n1 + n2 + 1) // 2 - partition1\n            maxLeft1 = -2 ** 31 if partition1 == 0 else nums1[partition1 - 1]\n            maxLeft2 = -2 ** 31 if partition2 == 0 else nums2[partition2 - 1]\n            minRight1 = 2 ** 31 - 1 if partition1 == n1 else nums1[partition1]\n            minRight2 = 2 ** 31 - 1 if partition2 == n2 else nums2[partition2]\n            if maxLeft1 <= minRight2 and maxLeft2 <= minRight1:\n                if (n1 + n2) % 2 == 0:\n                    return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) * 0.5\n                else:\n                    return max(maxLeft1, maxLeft2)\n            elif maxLeft1 > minRight2:\n                r = partition1 - 1\n            else:\n                l = partition1 + 1\n    solution = Solution()\n    assert findMedianSortedArrays([1, 3], [2]) == 2.0", "34": "def test_findMedianSortedArrays():\n    solution = Solution()\n\n    def generate_random_sorted_array(length, max_value):\n        return sorted([random.randint(0, max_value) for _ in range(length)])\n    nums1 = generate_random_sorted_array(10, 100)\n    nums2 = generate_random_sorted_array(15, 100)\n    partition1 = len(nums1) // 2\n    partition2 = (len(nums1) + len(nums2) + 1) // 2 - partition1\n    maxLeft1 = nums1[partition1 - 1] if partition1 > 0 else float('-inf')\n    maxLeft2 = nums2[partition2 - 1] if partition2 > 0 else float('-inf')\n    minRight1 = nums1[partition1]\n    minRight2 = nums2[partition2]\n    assert solution.findMedianSortedArrays(nums1, nums2) == ((max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) * 0.5 if (len(nums1) + len(nums2)) % 2 == 0 else max(maxLeft1, maxLeft2))", "36": "def test_findMedianSortedArrays(self):\n    nums1 = [2, 4]\n    nums2 = [1, 3]\n    self.assertAlmostEqual(self.solution.findMedianSortedArrays(nums1, nums2), 2.5)"}}
{"task_num": 10, "task_title": "Regular Expression Matching", "func_name": "isMatch", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isMatch(self, s: str, p: str) -> bool:\n    m = len(s)\n    n = len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    def isMatch(i: int, j: int) -> bool:\n      return j >= 0 and p[j] == '.' or s[i] == p[j]\n\n    for j, c in enumerate(p):\n      if c == '*' and dp[0][j - 1]:\n        dp[0][j + 1] = True\n\n    for i in range(m):\n      for j in range(n):\n        if p[j] == '*':\n          noRepeat = dp[i + 1][j - 1]\n          doRepeat = isMatch(i, j - 1) and dp[i][j + 1]\n          dp[i + 1][j + 1] = noRepeat or doRepeat\n        elif isMatch(i, j):\n          dp[i + 1][j + 1] = dp[i][j]\n\n    return dp[m][n]\n", "tests": {"23": "def test_isMatch():\n\n    class Solution:\n\n        def isMatch(self, s: str, p: str) -> bool:\n            m = len(s)\n            n = len(p)\n            dp = [[False] * (n + 1) for _ in range(m + 1)]\n            dp[0][0] = True\n\n            def isMatch(i: int, j: int) -> bool:\n                return j >= 0 and p[j] == '.' or s[i] == p[j]\n            for (j, c) in enumerate(p):\n                if c == '*' and dp[0][j - 1]:\n                    dp[0][j + 1] = True\n            for i in range(m):\n                for j in range(n):\n                    if p[j] == '*':\n                        noRepeat = dp[i + 1][j - 1]\n                        doRepeat = isMatch(i, j - 1) and dp[i][j + 1]\n                        dp[i + 1][j + 1] = noRepeat or doRepeat\n                    elif isMatch(i, j):\n                        dp[i + 1][j + 1] = dp[i][j]\n            return dp[m][n]\n    solution = Solution()\n    assert solution.isMatch('', '*') == True", "28": "def test_isMatch():\n\n    class MockSolution(Solution):\n\n        def isMatch(self, s: str, p: str) -> bool:\n            return self._dp[m][n]\n    m = 5\n    n = 4\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    solution = MockSolution()\n    s = 'aaa'\n    p = '*a*a'\n    solution._dp = dp\n    solution.m = m\n    solution.n = n\n    assert solution.isMatch(s, p) == True", "29": "def test_isMatch():\n\n    class Solution:\n\n        def isMatch(self, s: str, p: str) -> bool:\n            m = len(s)\n            n = len(p)\n            dp = [[False] * (n + 1) for _ in range(m + 1)]\n            dp[0][0] = True\n\n            def isMatch(i: int, j: int) -> bool:\n                return j >= 0 and p[j] == '.' or s[i] == p[j]\n            for (j, c) in enumerate(p):\n                if c == '*' and dp[0][j - 1]:\n                    dp[0][j + 1] = True\n            for i in range(m):\n                for j in range(n):\n                    if p[j] == '*':\n                        noRepeat = dp[i + 1][j - 1]\n                        doRepeat = isMatch(i, j - 1) and dp[i][j + 1]\n                        dp[i + 1][j + 1] = noRepeat or doRepeat\n                    elif isMatch(i, j):\n                        dp[i + 1][j + 1] = dp[i][j]\n            return dp[m][n]\n    solution = Solution()\n    print(solution.isMatch('aa', '*'))", "30": "def test_isMatch():\n    solution = Solution()\n\n    def assertEqual(a, b):\n        if a != b:\n            raise AssertionError(f'Expected {b}, but got {a}')\n    s1 = 'ab'\n    p1 = 'c*'\n    assertEqual(solution.isMatch(s1, p1), False)", "32": "def test_isMatch():\n    solution = Solution()\n    print(solution.isMatch('aa', 'a'))"}}
{"task_num": 15, "task_title": "3Sum", "func_name": "threeSum", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def threeSum(self, nums: List[int]) -> List[List[int]]:\n    if len(nums) < 3:\n      return []\n\n    ans = []\n\n    nums.sort()\n\n    for i in range(len(nums) - 2):\n      if i > 0 and nums[i] == nums[i - 1]:\n        continue\n\n      l = i + 1\n      r = len(nums) - 1\n      while l < r:\n        summ = nums[i] + nums[l] + nums[r]\n        if summ == 0:\n          ans.append((nums[i], nums[l], nums[r]))\n          l += 1\n          r -= 1\n          while nums[l] == nums[l - 1] and l < r:\n            l += 1\n          while nums[r] == nums[r + 1] and l < r:\n            r -= 1\n        elif summ < 0:\n          l += 1\n        else:\n          r -= 1\n\n    return ans\n", "tests": {"14": "def test_threeSum():\n\n    def assert_equal(left, right):\n        if left != right:\n            raise AssertionError(f'Expected {left} but got {right}')\n    solution = Solution()\n    result = solution.threeSum([0])", "22": "def test_threeSum(self):\n    nums = [0, 0, 0]\n    self.assertEqual(solution.threeSum(nums), [(0, 0, 0)])", "29": "def test_threeSum():\n    solution = Solution()\n    print(solution.threeSum([-1, 0, 1, 2, -1, -4]))", "30": "def test_threeSum():\n    solution = Solution()\n\n    def check_result(actual, expected):\n        return sorted(actual) == sorted(expected)\n    nums = [-5, -3, 0, 1, 2]\n    actual = solution.threeSum(nums)", "31": "def test_threeSum():\n    solution = Solution()\n    nums = [-5, -3, -1, 0, 1, 2, 4, 6]\n    ans = [[-5, -3, 1], [-5, -1, 2], [-3, -1, 2]]\n    assert sorted(solution.threeSum(nums)) == sorted(ans)", "32": "def test_threeSum(self):\n    solution = Solution()\n    ans = solution.threeSum([-1, 0, 1, 2, -1, -4])", "33": "def test_threeSum():\n    solution = Solution()\n    nums = [0, 0, 0]\n    result = solution.threeSum(nums)", "34": "def test_threeSum():\n\n    def generate_input(nums):\n        return ([(-2, -1, 1), (0, 0, 0)], [[(0, 0, 0)]])\n\n    def check_output(solution, nums, expected):\n        actual = solution.threeSum(nums)", "35": "def test_threeSum():\n\n    def generate_test_cases():\n        return [[-5, -3, -2, 0, 4]]\n    for case in generate_test_cases():\n        nums = case\n        solution = Solution()\n        result = solution.threeSum(nums)", "37": "def test_threeSum(self):\n\n    def test(nums):\n        return solution.threeSum(nums)", "39": "def test_threeSum():\n\n    class Solution:\n\n        def threeSum(self, nums: List[int]) -> List[List[int]]:\n            if len(nums) < 3:\n                return []\n            ans = []\n            nums.sort()\n            for i in range(len(nums) - 2):\n                if i > 0 and nums[i] == nums[i - 1]:\n                    continue\n                l = i + 1\n                r = len(nums) - 1\n                while l < r:\n                    summ = nums[i] + nums[l] + nums[r]\n                    if summ == 0:\n                        ans.append((nums[i], nums[l], nums[r]))\n                        l += 1\n                        r -= 1\n                        while nums[l] == nums[l - 1] and l < r:\n                            l += 1\n                        while nums[r] == nums[r + 1] and l < r:\n                            r -= 1\n                    elif summ < 0:\n                        l += 1\n                    else:\n                        return [[-5, 2, 4]]\n            return ans\n    solution = Solution()\n    print(solution.threeSum([-1, 0, 1, 2, -1, -4]))"}}
{"task_num": 44, "task_title": "Wildcard Matching", "func_name": "isMatch", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isMatch(self, s: str, p: str) -> bool:\n    m = len(s)\n    n = len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    def isMatch(i: int, j: int) -> bool:\n      return i >= 0 and p[j] == '?' or s[i] == p[j]\n\n    for j, c in enumerate(p):\n      if c == '*':\n        dp[0][j + 1] = dp[0][j]\n\n    for i in range(m):\n      for j in range(n):\n        if p[j] == '*':\n          matchEmpty = dp[i + 1][j]\n          matchSome = dp[i][j + 1]\n          dp[i + 1][j + 1] = matchEmpty or matchSome\n        elif isMatch(i, j):\n          dp[i + 1][j + 1] = dp[i][j]\n\n    return dp[m][n]\n", "tests": {"23": "def test_isMatch():\n    solution = Solution()\n    print(solution.isMatch('', '*'))", "28": "def test_isMatch():\n    def check(s, p):", "29": "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('a', '*') == True", "30": "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('a', 'c*a*b') == False", "32": "def test_isMatch(self):\n\n    class Solution:\n\n        def isMatch(self, s: str, p: str) -> bool:\n            m = len(s)\n            n = len(p)\n            dp = [[False] * (n + 1) for _ in range(m + 1)]\n            dp[0][0] = True\n\n            def isMatch(i: int, j: int) -> bool:\n                return i >= 0 and p[j] == '?' or s[i] == p[j]\n            for (j, c) in enumerate(p):\n                if c == '*':\n                    dp[0][j + 1] = dp[0][j]\n            for i in range(m):\n                for j in range(n):\n                    if p[j] == '*':\n                        matchEmpty = dp[i + 1][j]\n                        matchSome = dp[i][j + 1]\n                        dp[i + 1][j + 1] = matchEmpty or matchSome\n                    elif isMatch(i, j):\n                        dp[i + 1][j + 1] = dp[i][j]\n            return dp[m][n]\n    solution = Solution()\n    self.assertTrue(solution.isMatch('abc', 'a*b*c'))"}}
{"task_num": 54, "task_title": "Spiral Matrix", "func_name": "spiralOrder", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n    if not matrix:\n      return []\n\n    m = len(matrix)\n    n = len(matrix[0])\n    ans = []\n    r1 = 0\n    c1 = 0\n    r2 = m - 1\n    c2 = n - 1\n\n    while len(ans) < m * n:\n      j = c1\n      while j <= c2 and len(ans) < m * n:\n        ans.append(matrix[r1][j])\n        j += 1\n      i = r1 + 1\n      while i <= r2 - 1 and len(ans) < m * n:\n        ans.append(matrix[i][c2])\n        i += 1\n      j = c2\n      while j >= c1 and len(ans) < m * n:\n        ans.append(matrix[r2][j])\n        j -= 1\n      i = r2 - 1\n      while i >= r1 + 1 and len(ans) < m * n:\n        ans.append(matrix[i][c1])\n        i -= 1\n      r1 += 1\n      c1 += 1\n      r2 -= 1\n      c2 -= 1\n\n    return ans\n", "tests": {"14": "def test_spiralOrder():\n\n    class Solution:\n\n        def spiralOrder(self, matrix):\n            if not matrix:\n                return []\n            m = len(matrix)\n            n = len(matrix[0])\n            ans = []\n            r1 = 0\n            c1 = 0\n            r2 = m - 1\n            c2 = n - 1\n            while len(ans) < m * n:\n                j = c1\n                while j <= c2 and len(ans) < m * n:\n                    ans.append(matrix[r1][j])\n                    j += 1\n                i = r1 + 1\n                while i <= r2 - 1 and len(ans) < m * n:\n                    ans.append(matrix[i][c2])\n                    i += 1\n                j = c2\n                while j >= c1 and len(ans) < m * n:\n                    ans.append(matrix[r2][j])\n                    j -= 1\n                i = r2 - 1\n                while i >= r1 + 1 and len(ans) < m * n:\n                    ans.append(matrix[i][c1])\n                    i -= 1\n                r1 += 1\n                c1 += 1\n                r2 -= 1\n                c2 -= 1\n            return ans\n    solution = Solution()\n    matrix = []\n    assert solution.spiralOrder(matrix) == []"}}
{"task_num": 65, "task_title": "Valid Number", "func_name": "isNumber", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isNumber(self, s: str) -> bool:\n    s = s.strip()\n    if not s:\n      return False\n\n    seenNum = False\n    seenDot = False\n    seenE = False\n\n    for i, c in enumerate(s):\n      if c == '.':\n        if seenDot or seenE:\n          return False\n        seenDot = True\n      elif c == 'e' or c == 'E':\n        if seenE or not seenNum:\n          return False\n        seenE = True\n        seenNum = False\n      elif c in '+-':\n        if i > 0 and s[i - 1] not in 'eE':\n          return False\n        seenNum = False\n      else:\n        if not c.isdigit():\n          return False\n        seenNum = True\n\n    return seenNum\n", "tests": {"15": "def test_isNumber():\n    solution = Solution()\n    assert not solution.isNumber('')", "23": "def test_isNumber():\n\n    def mockInput(s):\n        return s\n    solution = Solution()\n    assert solution.isNumber(mockInput('123.456e789')) == True", "24": "def test_isNumber():\n\n    def helper(s):\n        s = s.strip()\n        if not s:\n            return False\n        seenNum = False\n        seenDot = False\n        seenE = False\n        for (i, c) in enumerate(s):\n            if c == '.':\n                if seenDot or seenE:\n                    return False\n                seenDot = True\n            elif c == 'e' or c == 'E':\n                if seenE or not seenNum:\n                    return False\n                seenE = True\n                seenNum = False\n            elif c in '+-':\n                if i > 0 and s[i - 1] not in 'eE':\n                    return False\n                seenNum = False\n            else:\n                if not c.isdigit():\n                    return False\n                seenNum = True\n        return seenNum\n    assert helper('6.5') == True", "25": "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('5.') == False", "27": "def test_isNumber():\n    solution = Solution()\n\n    def test_input(s):", "28": "def test_isNumber():\n    solution = Solution()\n\n    def test_e_and_not_seen_num(s):", "29": "def test_isNumber():\n\n    def test_case_1():\n        s = '123e4'\n        assert solution.isNumber(s)", "30": "def test_isNumber():\n    solution = Solution()\n    print(solution.isNumber('e'))", "32": "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('+-2') == False", "33": "def test_isNumber():\n    solution = Solution()\n    assert not solution.isNumber('+e')", "34": "def test_isNumber():\n\n    def isNumber(self, s: str) -> bool:\n        s = s.strip()\n        if not s:\n            return False\n        seenNum = False\n        seenDot = False\n        seenE = False\n        for (i, c) in enumerate(s):\n            if c == '.':\n                if seenDot or seenE:\n                    return False\n                seenDot = True\n            elif c == 'e' or c == 'E':\n                if seenE or not seenNum:\n                    return False\n                seenE = True\n                seenNum = False\n            elif c in '+-':\n                if i > 0 and s[i - 1] not in 'eE':\n                    return False\n                seenNum = False\n            else:\n                if not c.isdigit():\n                    return False\n                seenNum = True\n        return seenNum\n    solution = Solution()\n    assert isNumber(solution, '-.9') == True", "36": "def test_isNumber():\n    solution = Solution()\n    print(solution.isNumber('123abc'))", "37": "def test_isNumber():\n\n    def test_case_1():\n        s = 'abc'\n        assert not solution.isNumber(s)", "38": "def test_isNumber(self):\n    self.assertTrue(solution.isNumber('123'))"}}
{"task_num": 73, "task_title": "Set Matrix Zeroes", "func_name": "setZeroes", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def setZeroes(self, matrix: List[List[int]]) -> None:\n    m = len(matrix)\n    n = len(matrix[0])\n    shouldFillFirstRow = 0 in matrix[0]\n    shouldFillFirstCol = 0 in list(zip(*matrix))[0]\n\n    for i in range(1, m):\n      for j in range(1, n):\n        if matrix[i][j] == 0:\n          matrix[i][0] = 0\n          matrix[0][j] = 0\n\n    for i in range(1, m):\n      for j in range(1, n):\n        if matrix[i][0] == 0 or matrix[0][j] == 0:\n          matrix[i][j] = 0\n\n    if shouldFillFirstRow:\n      matrix[0] = [0] * n\n\n    if shouldFillFirstCol:\n      for row in matrix:\n        row[0] = 0\n", "tests": {"21": "def test_setZeroes(self):\n\n    class MockMatrix:\n\n        def __init__(self, matrix):\n            self.matrix = matrix\n\n        def __getitem__(self, item):\n            return self.matrix[item]\n    solution = Solution()\n    mock_matrix = MockMatrix([[1, 2], [3, 0]])\n    solution.setZeroes(mock_matrix)", "22": "def test_setZeroes():\n\n    class Solution:\n\n        def setZeroes(self, matrix):\n            m = len(matrix)\n            n = len(matrix[0])\n            self.set_zeroes_helper(matrix)\n\n        def set_zeroes_helper(self, matrix):\n            shouldFillFirstRow = 0 in matrix[0]\n            shouldFillFirstCol = 0 in list(zip(*matrix))[0]\n            for i in range(1, m):\n                for j in range(1, n):\n                    if matrix[i][j] == 0:\n                        matrix[i][0] = 0\n                        matrix[0][j] = 0\n            for i in range(1, m):\n                for j in range(1, n):\n                    if matrix[i][0] == 0 or matrix[0][j] == 0:\n                        matrix[i][j] = 0\n            if shouldFillFirstRow:\n                matrix[0] = [0] * n\n            if shouldFillFirstCol:\n                for row in matrix:\n                    row[0] = 0\n    solution = Solution()\n    matrix = [[1, 2, 3], [4, 5, 6]]\n    expected_matrix = [[1, 0, 3], [0, 0, 0]]\n    solution.setZeroes(matrix)", "27": "def test_setZeroes():\n\n    class Solution:\n\n        def setZeroes(self, matrix):\n            m = len(matrix)\n            n = len(matrix[0])\n            shouldFillFirstRow = 0 in matrix[0]\n            shouldFillFirstCol = 0 in list(zip(*matrix))[0]\n            for i in range(1, m):\n                for j in range(1, n):\n                    if matrix[i][j] == 0:\n                        matrix[i][0] = 0\n                        matrix[0][j] = 0\n            for i in range(1, m):\n                for j in range(1, n):\n                    if matrix[i][0] == 0 or matrix[0][j] == 0:\n                        assert matrix[i][j] != 0\n            if shouldFillFirstRow:\n                assert matrix[0] != [0] * n\n            if shouldFillFirstCol:\n                for row in matrix:\n                    assert row[0] != 0\n    solution = Solution()\n    matrix = [[1, 1, 1], [2, 0, 3], [4, 5, 6]]\n    solution.setZeroes(matrix)", "30": "def test_setZeroes():\n\n    class MockSolution:\n\n        def __init__(self):\n            self.solution = Solution()\n\n        def setZeroes(self, matrix: List[List[int]]) -> None:\n            m = len(matrix)\n            n = len(matrix[0])\n            shouldFillFirstRow = 0 in matrix[0]\n            shouldFillFirstCol = 0 in list(zip(*matrix))[0]\n            for i in range(1, m):\n                for j in range(1, n):\n                    if matrix[i][j] == 0:\n                        matrix[i][0] = 0\n                        matrix[0][j] = 0\n            for i in range(1, m):\n                for j in range(1, n):\n                    if matrix[i][0] == 0 or matrix[0][j] == 0:\n                        matrix[i][j] = 0\n            if shouldFillFirstRow:\n                matrix[0] = [0] * n\n            if shouldFillFirstCol:\n                for row in matrix:\n                    row[0] = 0\n    solution = MockSolution()\n    matrix = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]\n    solution.setZeroes(matrix)", "33": "def test_setZeroes():\n\n    def make_matrix():\n        return [[1, 2], [3, 0]]\n    solution = Solution()\n    matrix = make_matrix()\n    solution.setZeroes(matrix)", "34": "def test_setZeroes():\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]\n    solution = Solution()\n    solution.setZeroes(matrix)"}}
{"task_num": 97, "task_title": "Interleaving String", "func_name": "isInterleave", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n    m = len(s1)\n    n = len(s2)\n    if m + n != len(s3):\n      return False\n\n    dp=[]\n    for _ in range(m + 1):\n      dp.append([False] * (n + 1))\n    dp[0][0] = True\n\n    for i in range(1, m + 1):\n      dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n\n    for j in range(1, n + 1):\n      dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n\n    return dp[m][n]\n", "tests": {"16": "def test_isInterleave():\n\n    class Solution:\n\n        def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n            m = len(s1)\n            n = len(s2)\n            if m + n != len(s3):\n                return False\n            dp = []\n            for _ in range(m + 1):\n                dp.append([False] * (n + 1))\n            dp[0][0] = True\n            for i in range(1, m + 1):\n                dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n            for j in range(1, n + 1):\n                dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n            for i in range(1, m + 1):\n                for j in range(1, n + 1):\n                    dp[i][j] = dp[i - 1][j] and s1[i - 1] == s3[i + j - 1] or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n            return dp[m][n]\n    solution = Solution()\n    assert not solution.isInterleave('aabcc', 'dbbca', 'aadbbcbcac')"}}
{"task_num": 126, "task_title": "Word Ladder II", "func_name": "findLadders", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Set\n\nclass Solution:\n  def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n    from collections import deque\n    def connected(a: str, b: str) -> bool:\n      k = 0\n      for i in range(len(a)):\n        if a[i] != b[i]:\n          k += 1\n      return k == 1\n\n    if endWord not in wordList:\n      return []\n\n    visited = set([beginWord])\n\n    q = deque([beginWord])\n    nodes = []\n    find = False\n\n    while q and not find:\n      nodes.append(q.copy())\n      n = len(q)\n      for _ in range(n):\n        word = q.popleft()\n        for item in wordList:\n          if item in visited:\n            continue\n          if not connected(word, item):\n            continue\n          if item == endWord:\n            find = True\n            break\n          visited.add(item)\n          q.append(item)\n        if find:\n          break\n\n    if not find:\n      return []\n\n    ans = []\n\n    def backtracking(word, level: int, steps: List[str]):\n      if word == beginWord:\n        ans.append(steps[::-1])\n        return\n      if level < 0:\n        return\n      for item in nodes[level]:\n        if connected(item, word):\n          steps.append(item)\n          backtracking(item, level-1, steps)\n          steps.pop()\n\n    backtracking(endWord, len(nodes)-1, [endWord])\n    return ans\n", "tests": {"18": "def test_findLadders():\n    solution = Solution()\n\n    def is_connected(a: str, b: str) -> bool:\n        return True if a == 'hello' else False\n    wordList = ['hot', 'dot', 'dog', 'lot', 'log']\n    print(solution.findLadders('hit', 'cog', wordList))", "22": "def test_findLadders():\n    solution = Solution()\n\n    def check_result(result):\n        if result != []:\n            assert all((len(r) == len(set(r)) for r in result))\n            assert not any((i in wordList for i in [item[0] for item in result] + [item[-1] for item in result]))\n            assert all((word_list[i + 1][j] == word_list[i][j] + 1 or word_list[i + 1][j] == word_list[i][j] - 1 for i in range(len(result) - 1) for j in range(len(solution.beginWord)) if solution.connected(word_list[i][0], word_list[i + 1][0])))\n    wordList = ['hot', 'dot', 'dog', 'lot', 'log', 'cog']\n    print(solution.findLadders('hit', 'cog', wordList))", "37": "def test_findLadders():\n\n    def check_visited(visited):\n        wordList = ['hot', 'dot', 'dog', 'lot', 'log']\n        return visited == set(['hot'])\n    solution = Solution()\n    assert check_visited(solution.findLadders('hit', 'cog', ['hot', 'dot', 'dog', 'lot', 'log']))", "39": "def test_findLadders():\n\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n        from collections import deque\n\n        def connected(a: str, b: str) -> bool:\n            k = 0\n            for i in range(len(a)):\n                if a[i] != b[i]:\n                    k += 1\n            return k == 1\n        if endWord not in wordList:\n            return []\n        visited = set([beginWord])\n        q = deque([beginWord])\n        nodes = []\n        find = False\n        while q and (not find):\n            nodes.append(q.copy())\n            n = len(q)\n            for _ in range(n):\n                word = q.popleft()\n                for item in wordList:\n                    if item in visited:\n                        continue\n                    if not connected(word, item):\n                        continue\n                    if item == endWord:\n                        find = True\n                        break\n                    visited.add(item)\n                    q.append(item)\n                if find:\n                    break\n        if not find:\n            return []\n        ans = []\n\n        def backtracking(word, level: int, steps: List[str]):\n            if word == beginWord:\n                ans.append(steps[::-1])\n                return\n            if level < 0:\n                return\n            for item in nodes[level]:\n                if connected(item, word):\n                    steps.append(item)\n                    backtracking(item, level - 1, steps)\n                    steps.pop()\n        backtracking(endWord, len(nodes) - 1, [endWord])\n        return ans\n    solution = Solution()\n    print(solution.findLadders('hit', 'cog', ['hot', 'dot', 'dog', 'lot', 'log', 'cog']))", "41": "def test_findLadders(self):\n    solution = Solution()\n    wordList = ['hot', 'dot', 'dog', 'lot', 'log']\n    beginWord = 'hit'\n    endWord = 'hot'\n    self.assertEqual(len(solution.findLadders(beginWord, endWord, wordList)), 2)", "42": "def test_findLadders():\n\n    def helper(beginWord, endWord, wordList):\n        from collections import deque\n\n        def connected(a, b):\n            k = 0\n            for i in range(len(a)):\n                if a[i] != b[i]:\n                    k += 1\n            return k == 1\n        if endWord not in wordList:\n            return []\n        visited = set([beginWord])\n        q = deque([beginWord])\n        while q and len(q) > 0:\n            nodes = [q.copy()]\n            n = len(q)\n            for _ in range(n):\n                word = q.popleft()\n                for item in wordList:\n                    if item in visited:\n                        continue\n                    if not connected(word, item):\n                        continue\n                    q.append(item)\n                    visited.add(item)\n        if endWord in [item for sublist in nodes for item in sublist]:\n            path = []\n\n            def backtracking(node):\n                path.append(node)\n                if node == beginWord:\n                    return True\n                for i in range(len(nodes)):\n                    for j in nodes[i]:\n                        if connected(j, node) and backtracking(j):\n                            return True\n                path.pop()\n                return False\n            if backtracking(endWord):\n                ans = []\n\n                def backtrack(path):\n                    ans.append(path[:])\n                    for i in range(len(path) - 1):\n                        word = path[i]\n                        for j in range(len(word)):\n                            next_word = word[:j] + '*' + word[j + 1:]\n                            for k in wordList:\n                                if connected(next_word, k) and (not any((k == p[:-1] for p in ans))):\n                                    backtrack(path + [k])\n                backtrack([endWord])\n                return ans\n        else:\n            return []\n    solution = Solution()\n    print(helper('hit', 'cog', ['hot', 'dot', 'dog', 'lot', 'log', 'cog']))", "46": "def test_findLadders():\n\n    class SolutionMock:\n\n        def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n            return [[beginWord]]\n    solution = SolutionMock()\n    print(solution.findLadders('test', 'end', ['test', 'end']))", "49": "def test_findLadders():\n    solution = Solution()\n    wordList = ['hot', 'dot', 'dog', 'lot', 'log']\n    assert solution.findLadders('hit', 'cog', wordList) == [], 'test failed'", "55": "def test_findLadders():\n    solution = Solution()\n\n    def check(ans):\n        return [[['w1', 'w2'], ['w1', 'w3']], [['w1', 'w4']]] == ans\n    print(check(solution.findLadders('w1', 'w5', ['w1', 'w2', 'w3', 'w4', 'w5'])))", "56": "def test_findLadders(self):\n    beginWord = 'hit'\n    endWord = 'cog'\n    wordList = ['hot', 'dot', 'dog', 'lot', 'log', 'cog']\n    self.assertEqual(solution.findLadders(beginWord, endWord, wordList), [['hit', 'hot', 'dot', 'dog', 'cog']])", "58": "def test_findLadders():\n    solution = Solution()\n\n    def check_input():\n        wordList = ['hot', 'dot', 'dog', 'lot', 'log']", "61": "def test_findLadders():\n    solution = Solution()\n    wordList = ['hot', 'dot', 'dog', 'lot', 'log']\n    result = solution.findLadders('hit', 'cog', wordList)", "62": "def test_findLadders():\n\n    def findLadders(beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n        from collections import deque\n\n        def connected(a: str, b: str) -> bool:\n            k = 0\n            for i in range(len(a)):\n                if a[i] != b[i]:\n                    k += 1\n            return k == 1\n        if endWord not in wordList:\n            return []\n        visited = set([beginWord])\n        q = deque([beginWord])\n        nodes = []\n        find = False\n        while q and (not find):\n            nodes.append(q.copy())\n            n = len(q)\n            for _ in range(n):\n                word = q.popleft()\n                for item in wordList:\n                    if item in visited:\n                        continue\n                    if not connected(word, item):\n                        continue\n                    if item == endWord:\n                        find = True\n                        break\n                    visited.add(item)\n                    q.append(item)\n            if find:\n                break\n        if not find:\n            return []\n        ans = []\n\n        def backtracking(word, level: int, steps: List[str]):\n            if word == beginWord:\n                ans.append(steps[::-1])\n                return\n            if level < 0:\n                return\n            for item in nodes[level]:\n                if connected(item, word):\n                    steps.append(item)\n                    backtracking(item, level - 1, steps)\n                    steps.pop()\n        backtracking(endWord, len(nodes) - 1, [endWord])\n        return ans\n    solution = Solution()\n    wordList = ['hot', 'dot', 'dog', 'lot', 'log']\n    print(findLadders('hit', 'cog', wordList))", "63": "def test_findLadders():\n\n    def helper(solution):\n        wordList = ['hot', 'dot', 'dog', 'lot', 'log']"}}
{"task_num": 130, "task_title": "Surrounded Regions", "func_name": "solve", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def solve(self, board: List[List[str]]) -> None:\n    if not board:\n      return\n\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(board)\n    n = len(board[0])\n    q = collections.deque()\n\n    for i in range(m):\n      for j in range(n):\n        if i * j == 0 or i == m - 1 or j == n - 1:\n          if board[i][j] == 'O':\n            q.append((i, j))\n            board[i][j] = '*'\n\n    while q:\n      i, j = q.popleft()\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if board[x][y] != 'O':\n          continue\n        q.append((x, y))\n        board[x][y] = '*'\n\n    for row in board:\n      for i, c in enumerate(row):\n        if c == '*':\n          row[i] = 'O'\n        else:\n          row[i] = 'X'\n", "tests": {"14": "def test_solve():\n    board = [[[] for _ in range(0)] for _ in range(0)]\n    solution = Solution()\n    solution.solve(board)", "24": "def test_solve(self):\n    solution = Solution()\n    board = [['X', 'X', 'X', 'X'], ['X', 'O', 'O', '*'], ['X', 'X', 'O', 'X']]\n    solution.solve(board)", "25": "def test_solve(self):\n    board = [['O', 'X'], ['X', 'O']]\n    solution = Solution()\n    solution.solve(board)", "26": "def test_solve(self):\n    solution = Solution()\n    board = [[['O', 'X'], ['X', 'O']]]\n    solution.solve(board)", "34": "def test_solve():\n\n    class MockBoard:\n\n        def __init__(self):\n            self.board = [['O', 'O'], ['X', 'O'], ['O', 'X']]\n    board = MockBoard().board\n    solution = Solution()\n    solution.solve(board)", "36": "def test_solve(self):\n    board = [['O', 'X'], ['X', 'O']]\n    solution = Solution()\n    solution.solve(board)", "43": "def test_solve():\n    board = [['X', 'X', 'X', 'X'], ['X', 'O', 'O', 'X'], ['X', 'X', 'O', 'X'], ['X', 'O', 'X', 'X']]\n    solution = Solution()\n    solution.solve(board)", "45": "def test_solve(self):\n    board = [['O', 'O'], ['X', 'O']]\n    solution = Solution()\n    solution.solve(board)"}}
{"task_num": 132, "task_title": "Palindrome Partitioning II", "func_name": "minCut", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minCut(self, s: str) -> int:\n    n = len(s)\n    isPalindrome=[]\n    for _ in range(n):\n      isPalindrome.append([True] * n)\n    dp = [n] * n\n\n    for l in range(2, n + 1):\n      i = 0\n      for j in range(l - 1, n):\n        isPalindrome[i][j] = s[i] == s[j] and isPalindrome[i + 1][j - 1]\n        i += 1\n\n    for i in range(n):\n      if isPalindrome[0][i]:\n        dp[i] = 0\n        continue\n\n      for j in range(i):\n        if isPalindrome[j + 1][i]:\n          dp[i] = min(dp[i], dp[j] + 1)\n\n    return dp[-1]\n", "tests": {"27": "def test_minCut():\n\n    class Solution:\n\n        def minCut(self, s: str) -> int:\n            n = len(s)\n            isPalindrome = []\n            for _ in range(n):\n                isPalindrome.append([True] * n)\n            dp = [n] * n\n            for l in range(2, n + 1):\n                i = 0\n                for j in range(l - 1, n):\n                    isPalindrome[i][j] = s[i] == s[j] and isPalindrome[i + 1][j - 1]\n                    i += 1\n            for i in range(n):\n                if isPalindrome[0][i]:\n                    return 0\n                else:\n                    pass\n            return 0\n    solution = Solution()\n    print(solution.minCut('a'))", "28": "def test_minCut():\n\n    def isPalindrome(i, j):\n        return i == j or (i < j and s[i] == s[j] and isPalindrome(i + 1, j - 1))\n    s = 'abba'\n    assert solution.minCut(s) == 2, f\"Expected minCut('abba') to return 2, but got {solution.minCut(s)}\"", "32": "def test_minCut():\n\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        isPalindrome = []\n        for _ in range(n):\n            isPalindrome.append([True] * n)\n        dp = [n] * n\n        for l in range(2, n + 1):\n            i = 0\n            for j in range(l - 1, n):\n                isPalindrome[i][j] = s[i] == s[j] and isPalindrome[i + 1][j - 1]\n                i += 1\n        for i in range(n):\n            if isPalindrome[0][i]:\n                dp[i] = 0\n                continue\n            for j in range(i):\n                if isPalindrome[j + 1][i]:\n                    dp[i] = min(dp[i], dp[j] + 1)\n        return dp[-1]\n    solution = Solution()\n    assert minCut(solution, 'aab') == 1"}}
{"task_num": 218, "task_title": "The Skyline Problem", "func_name": "getSkyline", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:\n    n = len(buildings)\n    if n == 0:\n      return []\n    if n == 1:\n      left, right, height = buildings[0]\n      return [[left, height], [right, 0]]\n\n    left = self.getSkyline(buildings[:n // 2])\n    right = self.getSkyline(buildings[n // 2:])\n    return self._merge(left, right)\n\n  def _merge(self, left: List[List[int]], right: List[List[int]]) -> List[List[int]]:\n    ans = []\n    i = 0\n    j = 0\n    leftY = 0\n    rightY = 0\n\n    while i < len(left) and j < len(right):\n      if left[i][0] < right[j][0]:\n        leftY = left[i][1]\n        self._addPoint(ans, left[i][0], max(left[i][1], rightY))\n        i += 1\n      else:\n        rightY = right[j][1]\n        self._addPoint(ans, right[j][0], max(right[j][1], leftY))\n        j += 1\n\n    while i < len(left):\n      self._addPoint(ans, left[i][0], left[i][1])\n      i += 1\n\n    while j < len(right):\n      self._addPoint(ans, right[j][0], right[j][1])\n      j += 1\n\n    return ans\n\n  def _addPoint(self, ans: List[List[int]], x: int, y: int) -> None:\n    if ans and ans[-1][0] == x:\n      ans[-1][1] = y\n      return\n    if ans and ans[-1][1] == y:\n      return\n    ans.append([x, y])\n", "tests": {"15": "def test_getSkyline(self):\n    solution = Solution()\n    buildings = []\n    self.assertEqual(solution.getSkyline(buildings), [])", "17": "def test_getSkyline(self):\n    solution = Solution()\n    buildings = [[1, 2, 3]]\n    self.assertEqual(solution.getSkyline(buildings), [[1, 3], [2, 0]])", "18": "def test_getSkyline():\n\n    def getSkylineTest(buildings):\n        solution = Solution()\n        ans = solution.getSkyline(buildings)", "33": "def test_getSkyline():\n\n    def get_skyline(buildings):\n        return [[0, 3], [5, 6], [11, 12], [15, 16]]\n    solution = Solution()\n    buildings = [[2, 9, 10], [3, 7, 15], [8, 12, 12]]\n    assert get_skyline(buildings) == solution.getSkyline([[2, 9, 10], [3, 7, 15], [8, 12, 12]])", "34": "def test_getSkyline(self):\n    buildings = [[2, 9, 10], [3, 7, 15], [5, 12, 12]]\n    expected = [[2, 10], [3, 15], [7, 12], [12, 0]]\n    self.assertEqual(solution.getSkyline(buildings), expected)", "35": "def test_getSkyline(self):\n    buildings = [[2, 9, 10], [3, 7, 15], [5, 12, 12]]\n    expected_output = [[2, 10], [3, 15], [7, 12], [12, 0]]\n    self.assertEqual(solution.getSkyline(buildings), expected_output)", "37": "def test_getSkyline():\n\n    def getSkyline(buildings):\n        buildings = [[0, 2, 3], [2, 5, 3]]\n        return [[2, 3], [5, 0]]\nsolution = Solution()\nprint(getSkyline([]))\nprint(getSkyline([[1, 3, 4]]))", "38": "def test_getSkyline(self):\n    solution = Solution()\n    buildings = [[2, 9, 10], [3, 7, 15], [5, 12, 12]]\n    self.assertEqual(solution.getSkyline(buildings), [[2, 10], [3, 15], [7, 12], [12, 0]])", "39": "def test_getSkyline():\n    buildings = [[2, 9, 10], [3, 7, 15], [5, 12, 12]]\n    expected = [[2, 10], [3, 15], [7, 12], [12, 0]]\n    assert solution.getSkyline(buildings) == expected, \"Test failed for edge case where a building's left and right edges are at the same x-coordinate\"", "53": "def test_getSkyline():\n    solution = Solution()\n\n    def check(result):\n        expected = [[2, 3], [7, 4]]\n        assert result == expected, f'Expected {expected}, but got {result}'\n    buildings = [[2, 9, 10], [3, 7, 15], [5, 12, 12]]\n    check(solution.getSkyline(buildings))", "54": "def test_getSkyline():\n    solution = Solution()\n\n    def test_equal_heights():\n        buildings = [[1, 2, 3], [2, 3, 3]]\n        result = solution.getSkyline(buildings)", "56": "def test_getSkyline():\n\n    def check_output(expected, actual):\n        assert expected == actual\n    buildings = [[1, 3, 2], [4, 6, 5]]\n    solution = Solution()\n    output = solution.getSkyline(buildings)"}}
{"task_num": 227, "task_title": "Basic Calculator II", "func_name": "calculate", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def calculate(self, s: str) -> int:\n    ans = 0\n    prevNum = 0\n    currNum = 0\n    op = '+'\n\n    for i, c in enumerate(s):\n      if c.isdigit():\n        currNum = currNum * 10 + int(c)\n      if not c.isdigit() and c != ' ' or i == len(s) - 1:\n        if op == '+' or op == '-':\n          ans += prevNum\n          prevNum = currNum if op == '+' else -currNum\n        elif op == '*':\n          prevNum = prevNum * currNum\n        elif op == '/':\n          if prevNum < 0:\n            prevNum = math.ceil(prevNum / currNum)\n          else:\n            prevNum = prevNum // currNum\n        op = c\n        currNum = 0\n\n    return ans + prevNum\n", "tests": {"20": "def test_calculate():\n\n    def calculate(s):\n        ans = 0\n        prevNum = 0\n        currNum = 0\n        op = '+'\n        for (i, c) in enumerate(s):\n            if c.isdigit():\n                currNum = currNum * 10 + int(c)\n            if not c.isdigit() and c != ' ' or i == len(s) - 1:\n                if op == '+' or op == '-':\n                    ans += prevNum\n                    prevNum = currNum if op == '+' else -currNum\n                elif op == '*':\n                    prevNum = prevNum * currNum\n                elif op == '/':\n                    if prevNum < 0:\n                        prevNum = math.ceil(prevNum / currNum)\n                    else:\n                        prevNum = prevNum // currNum\n                op = c\n                currNum = 0\n        return ans + prevNum\n    solution = Solution()\n    assert calculate('123') == 123", "22": "def test_calculate():\n    solution = Solution()\n\n    def test_input(s):", "23": "def test_calculate():\n\n    def calculate(s: str) -> int:\n        solution = Solution()", "24": "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('1+2-3') == 0, \"Incorrect result for input '1+2-3'\"", "25": "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('5*2+3') == 13, \"Test for '*' operation failed\"", "26": "def test_calculate():\n\n    def test_method(s):\n        assert solution.calculate(s) == 16, f\"Expected calculate('{s}') to return 16, but got {solution.calculate(s)}\"", "27": "def test_calculate():\n    solution = Solution()\n\n    def helper(s):", "28": "def test_calculate():\n    solution = Solution()\n    s = '-3/2'\n    result = solution.calculate(s)", "29": "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('1 + 5 / -2') == 4", "31": "def test_calculate(self):\n    s = '1 + 2 / 3'\n    self.assertEqual(solution.calculate(s), -5)", "32": "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('a*2+b') == 4", "33": "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('123+456') == 579, 'Test for multiple digit number'"}}
{"task_num": 289, "task_title": "Game of Life", "func_name": "gameOfLife", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def gameOfLife(self, board: List[List[int]]) -> None:\n    m = len(board)\n    n = len(board[0])\n\n    for i in range(m):\n      for j in range(n):\n        ones = 0\n        for x in range(max(0, i - 1), min(m, i + 2)):\n          for y in range(max(0, j - 1), min(n, j + 2)):\n            ones += board[x][y] & 1\n\n        if board[i][j] == 1 and (ones == 3 or ones == 4):\n          board[i][j] |= 0b10\n\n        if board[i][j] == 0 and ones == 3:\n          board[i][j] |= 0b10\n\n    for i in range(m):\n      for j in range(n):\n        board[i][j] >>= 1\n", "tests": {"24": "def test_gameOfLife(self):\n\n    class SolutionMock:\n\n        def __init__(self):\n            self.board = [[0, 1], [1, 0]]\n\n        def gameOfLife(self, board):\n            return self.board\n    solution = SolutionMock()\n    solution.gameOfLife([[0, 1], [1, 0]])", "27": "def test_gameOfLife():\n\n    class Solution:\n\n        def gameOfLife(self, board):\n            m = len(board)\n            n = len(board[0])\n            for i in range(m):\n                for j in range(n):\n                    ones = 0\n                    for x in range(max(0, i - 1), min(m, i + 2)):\n                        for y in range(max(0, j - 1), min(n, j + 2)):\n                            ones += board[x][y] & 1\n                    if board[i][j] == 1 and (ones == 3 or ones == 4):\n                        board[i][j] |= 2\n                    if board[i][j] == 0 and ones == 3:\n                        board[i][j] |= 2\n            for i in range(m):\n                for j in range(n):\n                    board[i][j] >>= 1\n            return board\n    solution = Solution()\n    expected_board = [[0, 0, 0], [0, 0, 0]]\n    actual_board = [[1, 0, 0], [0, 1, 0]]\n    solution.gameOfLife(actual_board)"}}
{"task_num": 310, "task_title": "Minimum Height Trees", "func_name": "findMinHeightTrees", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\n    if n == 1 or not edges:\n      return [0]\n\n    ans = []\n    graph = collections.defaultdict(set)\n\n    for u, v in edges:\n      graph[u].add(v)\n      graph[v].add(u)\n\n    for label, children in graph.items():\n      if len(children) == 1:\n        ans.append(label)\n\n    while n > 2:\n      n -= len(ans)\n      nextLeaves = []\n      for leaf in ans:\n        u = next(iter(graph[leaf]))\n        graph[u].remove(leaf)\n        if len(graph[u]) == 1:\n          nextLeaves.append(u)\n      ans = nextLeaves\n\n    return ans\n", "tests": {"14": "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 1\n    edges = []\n    result = solution.findMinHeightTrees(n, edges)", "25": "def test_findMinHeightTrees():\n    solution = Solution()\n\n    def check_result(edges, expected):\n        result = solution.findMinHeightTrees(len(edges), edges)", "34": "def test_findMinHeightTrees():\n\n    def helper(n, edges):\n        if n == 1 or not edges:\n            return [0]\n        ans = []\n        graph = collections.defaultdict(set)\n        for (u, v) in edges:\n            graph[u].add(v)\n            graph[v].add(u)\n        for (label, children) in graph.items():\n            if len(children) == 1:\n                ans.append(label)\n        while n > 2:\n            n -= len(ans)\n            nextLeaves = []\n            for leaf in ans:\n                u = next(iter(graph[leaf]))\n                graph[u].remove(leaf)\n                if len(graph[u]) == 1:\n                    nextLeaves.append(u)\n            ans = nextLeaves\n        return ans\n    solution = Solution()\n    edges = [[0, 2], [0, 3], [1, 4]]\n    assert helper(5, edges) == [4]"}}
{"task_num": 327, "task_title": "Count of Range Sum", "func_name": "countRangeSum", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countRangeSum(self, nums: List[int], lower: int, upper: int) -> int:\n    n = len(nums)\n    self.ans = 0\n    prefix = [0] + list(itertools.accumulate(nums))\n\n    self._mergeSort(prefix, 0, n, lower, upper)\n    return self.ans\n\n  def _mergeSort(self, prefix: List[int], l: int, r: int, lower: int, upper: int) -> None:\n    if l >= r:\n      return\n\n    m = (l + r) // 2\n    self._mergeSort(prefix, l, m, lower, upper)\n    self._mergeSort(prefix, m + 1, r, lower, upper)\n    self._merge(prefix, l, m, r, lower, upper)\n\n  def _merge(self, prefix: List[int], l: int, m: int, r: int, lower: int, upper: int) -> None:\n    lo = m + 1\n    hi = m + 1\n\n    for i in range(l, m + 1):\n      while lo <= r and prefix[lo] - prefix[i] < lower:\n        lo += 1\n      while hi <= r and prefix[hi] - prefix[i] <= upper:\n        hi += 1\n      self.ans += hi - lo\n\n    sorted = [0] * (r - l + 1)\n    k = 0\n    i = l\n    j = m + 1\n\n    while i <= m and j <= r:\n      if prefix[i] < prefix[j]:\n        sorted[k] = prefix[i]\n        k += 1\n        i += 1\n      else:\n        sorted[k] = prefix[j]\n        k += 1\n        j += 1\n\n    while i <= m:\n      sorted[k] = prefix[i]\n      k += 1\n      i += 1\n\n    while j <= r:\n      sorted[k] = prefix[j]\n      k += 1\n      j += 1\n\n    prefix[l:l + len(sorted)] = sorted\n", "tests": {"22": "def test_countRangeSum():\n\n    class Solution:\n\n        def countRangeSum(self, nums: List[int], lower: int, upper: int) -> int:\n            n = len(nums)\n            self.ans = 0\n            prefix = [0] + list(itertools.accumulate(nums))\n            self._mergeSort(prefix, 0, n, lower, upper)\n            return self.ans\n\n        def _mergeSort(self, prefix: List[int], l: int, r: int, lower: int, upper: int) -> None:\n            if l >= r:\n                return\n            m = (l + r) // 2\n            self._mergeSort(prefix, l, m, lower, upper)\n            self._mergeSort(prefix, m + 1, r, lower, upper)\n            self._merge(prefix, l, m, r, lower, upper)\n\n        def _merge(self, prefix: List[int], l: int, m: int, r: int, lower: int, upper: int) -> None:\n            lo = m + 1\n            hi = m + 1\n            for i in range(l, m + 1):\n                while lo <= r and prefix[lo] - prefix[i] < lower:\n                    lo += 1\n                while hi <= r and prefix[hi] - prefix[i] <= upper:\n                    hi += 1\n                self.ans += hi - lo\n            sorted = [0] * (r - l + 1)\n            k = 0\n            i = l\n            j = m + 1\n            while i <= m and j <= r:\n                if prefix[i] < prefix[j]:\n                    sorted[k] = prefix[i]\n                    k += 1\n                    i += 1\n                else:\n                    sorted[k] = prefix[j]\n                    k += 1\n                    j += 1\n            while i <= m:\n                sorted[k] = prefix[i]\n                k += 1\n                i += 1\n            while j <= r:\n                sorted[k] = prefix[j]\n                k += 1\n                j += 1\n            prefix[l:l + len(sorted)] = sorted\n    solution = Solution()\n    nums = [0, -2, 0]\n    lower = -1000000000\n    upper = 1000000000\n    assert solution.countRangeSum(nums, lower, upper) == 3", "47": "def test_countRangeSum(self):\n    solution = Solution()\n    nums = [-2, 5, -1]\n    lower = -2\n    upper = 2\n    self.assertEqual(solution.countRangeSum(nums, lower, upper), 3)", "48": "def test_countRangeSum():\n\n    class Solution:\n\n        def countRangeSum(self, nums: List[int], lower: int, upper: int) -> int:\n            n = len(nums)\n            self.ans = 0\n            prefix = [0] + list(itertools.accumulate(nums))\n            self._mergeSort(prefix, 0, n, -100000.0, 2)\n            return self.ans\n    solution = Solution()\n    nums = [-10, -20, 8, 4]\n    print(solution.countRangeSum(nums, -50, 0))", "49": "def test_countRangeSum(self):\n    nums = [5, 2, -3]\n    lower = -10\n    upper = 0\n    self.assertEqual(solution.countRangeSum(nums, lower, upper), 4)", "51": "def test_countRangeSum():\n\n    def countRangeSum(nums: List[int], lower: int, upper: int) -> int:\n\n        class Solution:\n\n            def __init__(self):\n                self.ans = 0\n\n            def _mergeSort(self, prefix: List[int], l: int, r: int, lower: int, upper: int) -> None:\n                if l >= r:\n                    return\n                m = (l + r) // 2\n                self._mergeSort(prefix, l, m, lower, upper)\n                self._mergeSort(prefix, m + 1, r, lower, upper)\n                self._merge(prefix, l, m, r, lower, upper)\n\n            def _merge(self, prefix: List[int], l: int, m: int, r: int, lower: int, upper: int) -> None:\n                lo = m + 1\n                hi = m + 1\n                for i in range(l, m + 1):\n                    while lo <= r and prefix[lo] - prefix[i] < lower:\n                        lo += 1\n                    while hi <= r and prefix[hi] - prefix[i] <= upper:\n                        hi += 1\n                    self.ans += hi - lo\n                sorted = [0] * (r - l + 1)\n                k = 0\n                i = l\n                j = m + 1\n                while i <= m and j <= r:\n                    if prefix[i] < prefix[j]:\n                        sorted[k] = prefix[i]\n                        k += 1\n                        i += 1\n                        if i == m + 1:\n                            self.ans += r - lo + 1\n                    else:\n                        sorted[k] = prefix[j]\n                        k += 1\n                        j += 1\n                while i <= m:\n                    sorted[k] = prefix[i]\n                    k += 1\n                    i += 1\n                while j <= r:\n                    sorted[k] = prefix[j]\n                    k += 1\n                    j += 1\n                prefix[l:l + len(sorted)] = sorted\n        solution = Solution()\n        nums = [2, 5, -1]\n        lower = -2\n        upper = 2", "52": "def test_countRangeSum():\n\n    def countRangeSum(self, nums, lower, upper):\n        self.ans = 0\n        prefix = [0] + list(itertools.accumulate(nums))\n        self._mergeSort(prefix, 0, len(nums), lower, upper)\n        return self.ans\n\n    class Solution:\n\n        def _mergeSort(self, prefix, l, r, lower, upper):\n            if l >= r:\n                return\n            m = (l + r) // 2\n            self._mergeSort(prefix, l, m, lower, upper)\n            self._mergeSort(prefix, m + 1, r, lower, upper)\n            self._merge(prefix, l, m, r, lower, upper)\n\n        def _merge(self, prefix, l, m, r, lower, upper):\n            lo = m + 1\n            hi = m + 1\n            for i in range(l, m + 1):\n                while lo <= r and prefix[lo] - prefix[i] < lower:\n                    lo += 1\n                while hi <= r and prefix[hi] - prefix[i] <= upper:\n                    hi += 1\n                self.ans += hi - lo\n            sorted = [0] * (r - l + 1)\n            k = 0\n            i = l\n            j = m + 1\n            while i <= m and j <= r:\n                if prefix[i] < prefix[j]:\n                    sorted[k] = prefix[i]\n                    k += 1\n                    i += 1\n                else:\n                    sorted[k] = prefix[j]\n                    k += 1\n                    j += 1\n            solution = Solution()\n            assert solution.countRangeSum([5, 10, 3, 8, 9], -2, 15) == 7", "53": "def test_countRangeSum():\n\n    def assert_count_range_sum(nums, lower, upper):\n        return 2 if nums[0] + nums[1] >= lower and nums[0] + nums[1] <= upper else 0\n    solution = Solution()\n    nums = [1, 5, -6, 8]\n    lower = -10\n    upper = 20\n    assert assert_count_range_sum(nums, lower, upper) == solution.countRangeSum(nums, lower, upper)"}}
{"task_num": 335, "task_title": "Self Crossing", "func_name": "isSelfCrossing", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isSelfCrossing(self, x: List[int]) -> bool:\n    if len(x) <= 3:\n      return False\n\n    for i in range(3, len(x)):\n      if x[i - 2] <= x[i] and x[i - 1] <= x[i - 3]:\n        return True\n      if i >= 4 and x[i - 1] == x[i - 3] and x[i - 2] <= x[i] + x[i - 4]:\n        return True\n      if i >= 5 and x[i - 4] <= x[i - 2] and x[i - 2] <= x[i] + x[i - 4] and x[i - 1] <= x[i - 3] and x[i - 3] <= x[i - 1] + x[i - 5]:\n        return True\n\n    return False\n", "tests": {"14": "def test_isSelfCrossing():\n\n    def _is_self_crossing(x):\n        if len(x) <= 3:\n            return False\n        for i in range(3, len(x)):\n            if x[i - 2] <= x[i] and x[i - 1] <= x[i - 3]:\n                return True\n            if i >= 4 and x[i - 1] == x[i - 3] and (x[i - 2] <= x[i] + x[i - 4]):\n                return True\n            if i >= 5 and x[i - 4] <= x[i - 2] and (x[i - 2] <= x[i] + x[i - 4]) and (x[i - 1] <= x[i - 3]) and (x[i - 3] <= x[i - 1] + x[i - 5]):\n                return True\n        return False\n    assert _is_self_crossing([1, 2, 3, 4]) == False", "18": "def test_isSelfCrossing():\n    solution = Solution()\n    print(solution.isSelfCrossing([1, 2, 3, 4]))", "20": "def test_isSelfCrossing():\n    solution = Solution()\n    print(solution.isSelfCrossing([1, 2, 3, 4]))", "22": "def test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([6, 5, 4, 3, 1, 2]), 'Test case for line 22'"}}
{"task_num": 336, "task_title": "Palindrome Pairs", "func_name": "palindromePairs", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def palindromePairs(self, words: List[str]) -> List[List[int]]:\n    ans = []\n    dict = {word[::-1]: i for i, word in enumerate(words)}\n\n    for i, word in enumerate(words):\n      if \"\" in dict and dict[\"\"] != i and word == word[::-1]:\n        ans.append([i, dict[\"\"]])\n\n      for j in range(1, len(word) + 1):\n        l = word[:j]\n        r = word[j:]\n        if l in dict and dict[l] != i and r == r[::-1]:\n          ans.append([i, dict[l]])\n        if r in dict and dict[r] != i and l == l[::-1]:\n          ans.append([dict[r], i])\n\n    return ans\n", "tests": {"18": "def test_palindromePairs():\n\n    class Solution:\n\n        def palindromePairs(self, words):\n            return [[0, 1]]\n    s = Solution()\n    print(s.palindromePairs(['a']))", "24": "def test_palindromePairs():\n\n    class Solution:\n\n        def palindromePairs(self, words: List[str]) -> List[List[int]]:\n            result = []\n            dictionary = {word[::-1]: i for (i, word) in enumerate(words)}\n            for (index, word) in enumerate(words):\n                if '' in dictionary and dictionary[''] != index and (word == word[::-1]):\n                    result.append([index, dictionary['']])\n                for length in range(1, len(word) + 1):\n                    left = word[:length]\n                    right = word[length:]\n                    if left in dictionary and dictionary[left] != index and (right == right[::-1]):\n                        result.append([index, dictionary[left]])\n                    if right in dictionary and dictionary[right] != index and (left == left[::-1]):\n                        result.append([dictionary[right], index])\n            return result\n    solution = Solution()\n    words = ['bat', 'tab', 'cat']\n    expected_result = [[0, 1], [1, 0]]\n    assert solution.palindromePairs(words) == expected_result", "26": "def test_palindromePairs():\n\n    class Solution:\n\n        def palindromePairs(self, words):\n            dict = {word[::-1]: i for (i, word) in enumerate(words)}\n            ans = []\n            for (i, word) in enumerate(words):\n                if '' in dict and dict[''] != i and (word == word[::-1]):\n                    ans.append([i, dict['']])\n                for j in range(1, len(word) + 1):\n                    l = word[:j]\n                    r = word[j:]\n                    if l in dict and dict[l] != i and (r == r[::-1]):\n                        ans.append([i, dict[l]])\n                    if r in dict and dict[r] != i and (l == l[::-1]):\n                        ans.append([dict[r], i])\n            return ans\n    solution = Solution()\n    words = ['abcd', 'dcba', 'aceb']\n    result = solution.palindromePairs(words)"}}
{"task_num": 391, "task_title": "Perfect Rectangle", "func_name": "isRectangleCover", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Set\n\nclass Solution:\n  def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\n    area = 0\n    x1 = math.inf\n    y1 = math.inf\n    x2 = -math.inf\n    y2 = -math.inf\n    corners: Set[Tuple[int, int]] = set()\n\n    for x, y, a, b in rectangles:\n      area += (a - x) * (b - y)\n      x1 = min(x1, x)\n      y1 = min(y1, y)\n      x2 = max(x2, a)\n      y2 = max(y2, b)\n\n      for point in [(x, y), (x, b), (a, y), (a, b)]:\n        if point in corners:\n          corners.remove(point)\n        else:\n          corners.add(point)\n\n    if len(corners) != 4:\n      return False\n    if (x1, y1) not in corners or (x1, y2) not in corners or (x2, y1) not in corners or (x2, y2) not in corners:\n      return False\n    return area == (x2 - x1) * (y2 - y1)\n", "tests": {"29": "def test_isRectangleCover(self):\n    solution = Solution()\n    rectangles = [[0, 0, 2, 2], [1, 1, 2, 3], [1, 3, 2, 4], [3, 0, 4, 1], [3, 1, 3, 2]]\n    self.assertTrue(solution.isRectangleCover(rectangles))", "31": "def test_isRectangleCover():\n\n    class Solution:\n\n        def isRectangleCover(self, rectangles):\n            area = 0\n            x1 = math.inf\n            y1 = math.inf\n            x2 = -math.inf\n            y2 = -math.inf\n            corners: Set[Tuple[int, int]] = set()\n            for (x, y, a, b) in rectangles:\n                area += (a - x) * (b - y)\n                x1 = min(x1, x)\n                y1 = min(y1, y)\n                x2 = max(x2, a)\n                y2 = max(y2, b)\n                for point in [(x, y), (x, b), (a, y), (a, b)]:\n                    if point in corners:\n                        corners.remove(point)\n                    else:\n                        assert point not in corners\n    solution = Solution()\n    rectangles = [[0, 1, 2, 3], [1, 0, 2, 4]]\n    assert solution.isRectangleCover(rectangles) == True", "34": "def test_isRectangleCover():\n\n    class Solution:\n\n        def isRectangleCover(self, rectangles):\n            return False\n    solution = Solution()\n    print(solution.isRectangleCover([[1, 3, 7, 9]]))", "36": "def test_isRectangleCover(self):\n    solution = Solution()\n    self.assertFalse(solution.isRectangleCover([[1, 2, 4, 3]]))"}}
{"task_num": 402, "task_title": "Remove K Digits", "func_name": "removeKdigits", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def removeKdigits(self, num: str, k: int) -> str:\n    if len(num) == k:\n      return '0'\n\n    ans = []\n    stack = []\n\n    for i, digit in enumerate(num):\n      while k > 0 and stack and stack[-1] > digit:\n        stack.pop()\n        k -= 1\n      stack.append(digit)\n\n    for _ in range(k):\n      stack.pop()\n\n    for c in stack:\n      if c == '0' and not ans:\n        continue\n      ans.append(c)\n\n    return ''.join(ans) if ans else '0'\n", "tests": {"14": "def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits('10000', 1) == '0'", "30": "def test_removeKdigits():\n\n    def assert_equal(expected, result):\n        if expected != result:\n            raise AssertionError(f'Expected {expected} but got {result}')\n    solution = Solution()\n    assert_equal('9', solution.removeKdigits('1432219', 3))"}}
{"task_num": 407, "task_title": "Trapping Rain Water II", "func_name": "trapRainWater", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def trapRainWater(self, heightMap: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(heightMap)\n    n = len(heightMap[0])\n    ans = 0\n    minHeap = []\n    seen = set()\n\n    for i in range(m):\n      heapq.heappush(minHeap, (heightMap[i][0], i, 0))\n      heapq.heappush(minHeap, (heightMap[i][n - 1], i, n - 1))\n      seen.add((i, 0))\n      seen.add((i, n - 1))\n\n    for j in range(1, n - 1):\n      heapq.heappush(minHeap, (heightMap[0][j], 0, j))\n      heapq.heappush(minHeap, (heightMap[m - 1][j], m - 1, j))\n      seen.add((0, j))\n      seen.add((m - 1, j))\n\n    while minHeap:\n      h, i, j = heapq.heappop(minHeap)\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if (x, y) in seen:\n          continue\n        if heightMap[x][y] < h:\n          ans += h - heightMap[x][y]\n          heapq.heappush(minHeap, (h, x, y))\n        else:\n          heapq.heappush(minHeap, (heightMap[x][y], x, y))\n        seen.add((x, y))\n\n    return ans\n", "tests": {"38": "def test_trapRainWater(self):\n    solution = Solution()\n    heightMap = [[1, 0, 0], [2, 4, 5], [3, 6, 7]]\n    self.assertEqual(solution.trapRainWater(heightMap), 14)", "40": "def test_trapRainWater():\n\n    class Solution:\n\n        def trapRainWater(self, heightMap):\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            m = len(heightMap)\n            n = len(heightMap[0])\n            ans = 0\n            minHeap = []\n            seen = set()\n            for i in range(m):\n                heapq.heappush(minHeap, (heightMap[i][0], i, 0))\n                heapq.heappush(minHeap, (heightMap[i][n - 1], i, n - 1))\n                seen.add((i, 0))\n                seen.add((i, n - 1))\n            for j in range(1, n - 1):\n                heapq.heappush(minHeap, (heightMap[0][j], 0, j))\n                heapq.heappush(minHeap, (heightMap[m - 1][j], m - 1, j))\n                seen.add((0, j))\n                seen.add((m - 1, j))\n            while minHeap:\n                (h, i, j) = heapq.heappop(minHeap)\n                for (dx, dy) in dirs:\n                    x = i + dx\n                    y = j + dy\n                    if x < 0 or x == m or y < 0 or (y == n):\n                        continue\n                    if (x, y) in seen:\n                        assert heightMap[x][y] >= h\n                    elif heightMap[x][y] < h:\n                        ans += h - heightMap[x][y]\n                        heapq.heappush(minHeap, (h, x, y))\n                    else:\n                        heapq.heappush(minHeap, (heightMap[x][y], x, y))\n                    seen.add((x, y))\n            return ans\n    solution = Solution()\n    heightMap = [[1, 4, 3], [2, 5, 6], [7, 8, 9]]\n    print(solution.trapRainWater(heightMap))", "42": "def test_trapRainWater(self):\n    solution = Solution()\n    heightMap = [[1, 4, 3], [2, 5, 0]]\n    self.assertEqual(solution.trapRainWater(heightMap), 1)", "43": "def test_trapRainWater(self):\n\n    class Solution:\n\n        def trapRainWater(self, heightMap: List[List[int]]) -> int:\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            m = len(heightMap)\n            n = len(heightMap[0])\n            ans = 0\n            minHeap = []\n            seen = set()\n            for i in range(m):\n                heapq.heappush(minHeap, (heightMap[i][0], i, 0))\n                heapq.heappush(minHeap, (heightMap[i][n - 1], i, n - 1))\n                seen.add((i, 0))\n                seen.add((i, n - 1))\n            for j in range(1, n - 1):\n                heapq.heappush(minHeap, (heightMap[0][j], 0, j))\n                heapq.heappush(minHeap, (heightMap[m - 1][j], m - 1, j))\n                seen.add((0, j))\n                seen.add((m - 1, j))\n            while minHeap:\n                (h, i, j) = heapq.heappop(minHeap)\n                for (dx, dy) in dirs:\n                    x = i + dx\n                    y = j + dy\n                    if x < 0 or x == m or y < 0 or (y == n):\n                        continue\n                    if (x, y) in seen:\n                        continue\n                    if heightMap[x][y] < h:\n                        ans += h - heightMap[x][y]\n                        heapq.heappush(minHeap, (h, x, y))\n                    else:\n                        heapq.heappush(minHeap, (heightMap[x][y], x, y))\n                    seen.add((x, y))\n            return ans\n    solution = Solution()\n    heightMap = [[0, 1, 0], [2, 4, 1], [3, 2, 1]]\n    self.assertEqual(solution.trapRainWater(heightMap), 1)", "45": "def test_trapRainWater(self):\n    solution = Solution()\n    heightMap = [[1, 4, 3], [2, 6, 5], [0, 3, 9]]\n    self.assertEqual(solution.trapRainWater(heightMap), 10)"}}
{"task_num": 417, "task_title": "Pacific Atlantic Water Flow", "func_name": "pacificAtlantic", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(heights)\n    n = len(heights[0])\n    qP = collections.deque()\n    qA = collections.deque()\n    seenP = [[False] * n for _ in range(m)]\n    seenA = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n      qP.append((i, 0))\n      qA.append((i, n - 1))\n      seenP[i][0] = True\n      seenA[i][n - 1] = True\n\n    for j in range(n):\n      qP.append((0, j))\n      qA.append((m - 1, j))\n      seenP[0][j] = True\n      seenA[m - 1][j] = True\n\n    def bfs(q: collections.deque, seen: List[List[bool]]):\n      while q:\n        i, j = q.popleft()\n        h = heights[i][j]\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if seen[x][y] or heights[x][y] < h:\n            continue\n          q.append((x, y))\n          seen[x][y] = True\n\n    bfs(qP, seenP)\n    bfs(qA, seenA)\n\n    res=[]\n    for i in range(m):\n      for j in range(n):\n        if seenP[i][j] and seenA[i][j]:\n          res.append([i, j])\n    return res\n", "tests": {"41": "def test_pacificAtlantic():\n\n    class Solution:\n\n        def pacificAtlantic(self, heights):\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            m = len(heights)\n            n = len(heights[0])\n            qP = collections.deque()\n            qA = collections.deque()\n            seenP = [[False] * n for _ in range(m)]\n            seenA = [[False] * n for _ in range(m)]\n            for i in range(m):\n                qP.append((i, 0))\n                qA.append((i, n - 1))\n                seenP[i][0] = True\n                seenA[i][n - 1] = True\n            for j in range(n):\n                qP.append((0, j))\n                qA.append((m - 1, j))\n                seenP[0][j] = True\n                seenA[m - 1][j] = True\n\n            def bfs(q: collections.deque, seen: List[List[bool]]):\n                while q:\n                    (i, j) = q.popleft()\n                    h = heights[i][j]\n                    for (dx, dy) in dirs:\n                        x = i + dx\n                        y = j + dy\n                        if x < 0 or x == m or y < 0 or (y == n):\n                            continue\n                        if seen[x][y] or heights[x][y] < h:\n                            continue\n                        q.append((x, y))\n                        seen[x][y] = True\n            bfs(qP, seenP)\n            bfs(qA, seenA)\n            res = []\n            for i in range(m):\n                for j in range(n):\n                    if seenP[i][j] and seenA[i][j]:\n                        res.append([i, j])\n            return res\n    heights = [[1, 2, 2, 3, 5], [3, 2, 3, 4, 4], [2, 4, 5, 3, 1], [6, 7, 1, 4, 5], [5, 1, 1, 2, 4]]\n    result = Solution().pacificAtlantic(heights)\n    assert result == [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]], f'Expected [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] but got {result}'", "43": "def test_pacificAtlantic():\n\n    class Solution:\n\n        def pacificAtlantic(self, heights):\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            m = len(heights)\n            n = len(heights[0])\n            qP = collections.deque()\n            qA = collections.deque()\n            seenP = [[False] * n for _ in range(m)]\n            seenA = [[False] * n for _ in range(m)]\n            for i in range(m):\n                qP.append((i, 0))\n                qA.append((i, n - 1))\n                seenP[i][0] = True\n                seenA[i][n - 1] = True\n            for j in range(n):\n                qP.append((0, j))\n                qA.append((m - 1, j))\n                seenP[0][j] = True\n                seenA[m - 1][j] = True\n\n            def bfs(q: collections.deque, seen: List[List[bool]]):\n                while q:\n                    (i, j) = q.popleft()\n                    h = heights[i][j]\n                    for (dx, dy) in dirs:\n                        x = i + dx\n                        y = j + dy\n                        if x < 0 or x == m or y < 0 or (y == n):\n                            continue\n                        if seen[x][y] or heights[x][y] >= h:\n                            continue\n                        q.append((x, y))\n                        seen[x][y] = True\n            bfs(qP, seenP)\n            bfs(qA, seenA)\n            res = []\n            for i in range(m):\n                for j in range(n):\n                    if seenP[i][j] and seenA[i][j]:\n                        res.append([i, j])\n            return res\n    heights = [[1, 2, 2, 3, 5], [3, 2, 3, 4, 4], [2, 4, 5, 3, 1]]\n    solution = Solution()\n    assert set(solution.pacificAtlantic(heights)) == {(0, 3), (1, 3)}", "54": "def test_pacificAtlantic():\n\n    class Solution:\n\n        def pacificAtlantic(self, heights):\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            m = len(heights)\n            n = len(heights[0])\n            qP = collections.deque()\n            qA = collections.deque()\n            seenP = [[False] * n for _ in range(m)]\n            seenA = [[False] * n for _ in range(m)]\n            for i in range(m):\n                qP.append((i, 0))\n                qA.append((i, n - 1))\n                seenP[i][0] = True\n                seenA[i][n - 1] = True\n            for j in range(n):\n                qP.append((0, j))\n                qA.append((m - 1, j))\n                seenP[0][j] = True\n                seenA[m - 1][j] = True\n\n            def bfs(q: collections.deque, seen: List[List[bool]]):\n                while q:\n                    (i, j) = q.popleft()\n                    h = heights[i][j]\n                    for (dx, dy) in dirs:\n                        x = i + dx\n                        y = j + dy\n                        if x < 0 or x == m or y < 0 or (y == n):\n                            continue\n                        if seen[x][y] or heights[x][y] < h:\n                            continue\n                        q.append((x, y))\n                        seen[x][y] = True\n            bfs(qP, seenP)\n            bfs(qA, seenA)\n            res = []\n            for i in range(m):\n                for j in range(n):\n                    if seenP[i][j] and seenA[i][j]:\n                        res.append([i, j])\n            return res\n    solution = Solution()\n    heights = [[1, 2, 2, 3, 5], [3, 2, 3, 4, 4], [2, 4, 5, 3, 1], [6, 7, 1, 4, 5], [5, 1, 1, 2, 4]]\n    print(solution.pacificAtlantic(heights))"}}
{"task_num": 420, "task_title": "Strong Password Checker", "func_name": "strongPasswordChecker", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def strongPasswordChecker(self, password: str) -> int:\n    n = len(password)\n    missing = self._getMissing(password)\n    replaces = 0\n    oneSeq = 0\n    twoSeq = 0\n\n    i = 2\n    while i < n:\n      if password[i] == password[i - 1] and password[i - 1] == password[i - 2]:\n        length = 2\n        while i < n and password[i] == password[i - 1]:\n          length += 1\n          i += 1\n        replaces += length // 3\n        if length % 3 == 0:\n          oneSeq += 1\n        if length % 3 == 1:\n          twoSeq += 1\n      else:\n        i += 1\n\n    if n < 6:\n      return max(6 - n, missing)\n    if n <= 20:\n      return max(replaces, missing)\n\n    deletes = n - 20\n    replaces -= min(oneSeq, deletes)\n    replaces -= min(max(deletes - oneSeq, 0), twoSeq * 2) // 2\n    replaces -= max(deletes - oneSeq - twoSeq * 2, 0) // 3\n    return deletes + max(replaces, missing)\n\n  def _getMissing(self, password: str) -> int:\n    return 3 - any(c.isupper() for c in password) - any(c.islower() for c in password) - any(c.isdigit() for c in password)\n", "tests": {"22": "def test_strongPasswordChecker():\n\n    class Solution:\n\n        def strongPasswordChecker(self, password: str) -> int:\n            return self._getStrongness(password)\n\n        def _getMissing(self, password: str) -> int:\n            return 3 - any((c.isupper() for c in password)) - any((c.islower() for c in password)) - any((c.isdigit() for c in password))\n\n        def _getStrongness(self, password: str) -> int:\n            n = len(password)\n            missing = self._getMissing(password)\n            replaces = 0\n            oneSeq = 0\n            twoSeq = 0\n            i = 2\n            while i < n:\n                if password[i] == password[i - 1] and password[i - 1] == password[i - 2]:\n                    length = 2\n                    while i < n and password[i] == password[i - 1]:\n                        length += 1\n                        i += 1\n                    replaces += length // 3\n                    if length % 3 == 0:\n                        oneSeq += 1\n                    if length % 3 == 1:\n                        twoSeq += 1\n                else:\n                    i += 1\n            if n < 6:\n                return max(6 - n, missing)\n            if n <= 20:\n                return max(replaces, missing)\n            deletes = n - 20\n            replaces -= min(oneSeq, deletes)\n            replaces -= min(max(deletes - oneSeq, 0), twoSeq * 2) // 2\n            returns -= max(deletes - oneSeq - twoSeq * 2, 0) // 3\n            return deletes + max(replaces, missing)\n    solution = Solution()\n    assert solution.strongPasswordChecker('aaaa') == 1", "23": "def test_strongPasswordChecker():\n\n    class Solution:\n\n        def strongPasswordChecker(self, password: str) -> int:\n            n = len(password)\n            missing = self._getMissing(password)\n            replaces = 0\n            oneSeq = 0\n            twoSeq = 0\n            i = 2\n            while i < n:\n                if password[i] == password[i - 1] and password[i - 1] == password[i - 2]:\n                    length = 2\n                    while i < n and password[i] == password[i - 1]:\n                        length += 1\n                        i += 1\n                    replaces += length // 3\n                    if length % 3 == 0:\n                        oneSeq += 1\n                    if length % 3 == 1:\n                        twoSeq += 1\n                else:\n                    i += 1\n            return 5\n    solution = Solution()\n    assert solution.strongPasswordChecker('aaa') == 2", "24": "def test_strongPasswordChecker():\n\n    class Solution:\n\n        def strongPasswordChecker(self, password: str) -> int:\n            n = len(password)\n            missing = self._getMissing(password)\n            replaces = 0\n            oneSeq = 0\n            twoSeq = 0\n            i = 2\n            while i < n:\n                if password[i] == password[i - 1] and password[i - 1] == password[i - 2]:\n                    length = 2\n                    while i < n and password[i] == password[i - 1]:\n                        length += 1\n                        i += 1\n                    replaces += length // 3\n                    if length % 3 == 0:\n                        oneSeq += 1\n                    if length % 3 == 1:\n                        twoSeq += 1\n                else:\n                    i += 1\n            if n < 6:\n                return max(6 - n, missing)\n            if n <= 20:\n                return max(replaces, missing)\n            deletes = n - 20\n            replaces -= min(oneSeq, deletes)\n            replaces -= min(max(deletes - oneSeq, 0), twoSeq * 2) // 2\n            replaces -= max(deletes - oneSeq - twoSeq * 2, 0) // 3\n            return deletes + max(replaces, missing)\n\n        def _getMissing(self, password: str) -> int:\n            return 3 - any((c.isupper() for c in password)) - any((c.islower() for c in password)) - any((c.isdigit() for c in password))\n    solution = Solution()\n    print(solution.strongPasswordChecker('ababa'))", "25": "def test_strongPasswordChecker():\n    solution = Solution()\n    print(solution.strongPasswordChecker('aaa'))", "26": "def test_strongPasswordChecker(self):\n    solution = Solution()\n    self.assertEqual(solution.strongPasswordChecker('aaaaaa'), 4)", "27": "def test_strongPasswordChecker():\n    solution = Solution()\n    print(solution.strongPasswordChecker('aabaa'))", "28": "def test_strongPasswordChecker():\n\n    class Solution:\n\n        def strongPasswordChecker(self, password: str) -> int:\n            n = len(password)\n            missing = self._getMissing(password)\n            replaces = 0\n            oneSeq = 0\n            twoSeq = 0\n            i = 2\n            while i < n:\n                if password[i] == password[i - 1] and password[i - 1] == password[i - 2]:\n                    length = 2\n                    while i < n and password[i] == password[i - 1]:\n                        length += 1\n                        i += 1\n                    replaces += length // 3\n                    if length % 3 == 0:\n                        oneSeq += 1\n                    if length % 3 == 1:\n                        twoSeq += 1\n                else:\n                    i += 1\n            if n < 6:\n                return max(6 - n, missing)\n            if n <= 20:\n                return max(replaces, missing)\n            deletes = n - 20\n            replaces -= min(oneSeq, deletes)\n            replaces -= min(max(deletes - oneSeq, 0), twoSeq * 2) // 2\n            replaces -= max(deletes - oneSeq - twoSeq * 2, 0) // 3\n            return deletes + max(replaces, missing)\n\n        def _getMissing(self, password: str) -> int:\n            return 3 - any((c.isupper() for c in password)) - any((c.islower() for c in password)) - any((c.isdigit() for c in password))\n    solution = Solution()\n    assert solution.strongPasswordChecker('AaBb') == 1, 'Test case failed'", "29": "def test_strongPasswordChecker():\n\n    def strongPasswordChecker(password):\n        n = len(password)\n        missing = self._getMissing(password)\n        replaces = 0\n        oneSeq = 0\n        twoSeq = 0\n        i = 2\n        while i < n:\n            if password[i] == password[i - 1] and password[i - 1] == password[i - 2]:\n                length = 2\n                while i < n and password[i] == password[i - 1]:\n                    length += 1\n                    i += 1\n                replaces += length // 3\n                if length % 3 == 0:\n                    oneSeq += 1\n                if length % 3 == 1:\n                    twoSeq += 1\n            else:\n                i += 1\n        if n < 6:\n            return max(6 - n, missing)\n        if n <= 20:\n            return max(replaces, missing)\n        deletes = n - 20\n        replaces -= min(oneSeq, deletes)\n        replaces -= min(max(deletes - oneSeq, 0), twoSeq * 2) // 2\n        replaces -= max(deletes - oneSeq - twoSeq * 2, 0) // 3\n        return deletes + max(replaces, missing)\n    solution = Solution()\n    assert strongPasswordChecker('aB1') == 4", "30": "def test_strongPasswordChecker():\n\n    class Solution:\n\n        def strongPasswordChecker(self, password: str) -> int:\n            n = len(password)\n            missing = self._getMissing(password)\n            replaces = 0\n            oneSeq = 0\n            twoSeq = 0\n            i = 2\n            while i < n:\n                if password[i] == password[i - 1] and password[i - 1] == password[i - 2]:\n                    length = 2\n                    while i < n and password[i] == password[i - 1]:\n                        length += 1\n                        i += 1\n                    replaces += length // 3\n                    if length % 3 == 0:\n                        oneSeq += 1\n                    if length % 3 == 1:\n                        twoSeq += 1\n                else:\n                    i += 1\n            if n < 6:\n                return max(6 - n, missing)\n            if n <= 20:\n                return max(replaces, missing)\n            deletes = n - 20\n            replaces -= min(oneSeq, deletes)\n            replaces -= min(max(deletes - oneSeq, 0), twoSeq * 2) // 2\n            replaces -= max(deletes - oneSeq - twoSeq * 2, 0) // 3\n            return deletes + max(replaces, missing)\n\n        def _getMissing(self, password: str) -> int:\n            return 3 - any((c.isupper() for c in password)) - any((c.islower() for c in password)) - any((c.isdigit() for c in password))\n    solution = Solution()\n    assert solution.strongPasswordChecker('aAbB123') == 0", "32": "def test_strongPasswordChecker():\n    solution = Solution()\n\n    def assert_equal(expected, actual):\n        if expected != actual:\n            raise AssertionError(f'Expected {expected}, but got {actual}')\n    password = 'AAAAaa'\n    result = solution.strongPasswordChecker(password)", "35": "def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('a') == 4", "37": "def test_strongPasswordChecker():\n\n    class Solution:\n\n        def strongPasswordChecker(self, password: str) -> int:\n            n = len(password)\n            missing = self._getMissing(password)\n            replaces = 0\n            oneSeq = 0\n            twoSeq = 0\n            i = 2\n            while i < n:\n                if password[i] == password[i - 1] and password[i - 1] == password[i - 2]:\n                    length = 2\n                    while i < n and password[i] == password[i - 1]:\n                        length += 1\n                        i += 1\n                    replaces += length // 3\n                    if length % 3 == 0:\n                        oneSeq += 1\n                    if length % 3 == 1:\n                        twoSeq += 1\n                else:\n                    i += 1\n            if n < 6:\n                return max(6 - n, missing)\n            if n <= 20:\n                return max(replaces, missing)\n            deletes = n - 20\n            replaces -= min(oneSeq, deletes)\n            replaces -= min(max(deletes - oneSeq, 0), twoSeq * 2) // 2\n            replaces -= max(deletes - oneSeq - twoSeq * 2, 0) // 3\n            return deletes + max(replaces, missing)\n\n        def _getMissing(self, password: str) -> int:\n            return 3 - any((c.isupper() for c in password)) - any((c.islower() for c in password)) - any((c.isdigit() for c in password))\n    solution = Solution()\n    assert solution.strongPasswordChecker('abc123') == max(2, 0)"}}
{"task_num": 423, "task_title": "Reconstruct Original Digits from English", "func_name": "originalDigits", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def originalDigits(self, s: str) -> str:\n    count = [0] * 10\n\n    for c in s:\n      if c == 'z':\n        count[0] += 1\n      if c == 'o':\n        count[1] += 1\n      if c == 'w':\n        count[2] += 1\n      if c == 'h':\n        count[3] += 1\n      if c == 'u':\n        count[4] += 1\n      if c == 'f':\n        count[5] += 1\n      if c == 'x':\n        count[6] += 1\n      if c == 's':\n        count[7] += 1\n      if c == 'g':\n        count[8] += 1\n      if c == 'i':\n        count[9] += 1\n\n    count[1] -= count[0] + count[2] + count[4]\n    count[3] -= count[8]\n    count[5] -= count[4]\n    count[7] -= count[6]\n    count[9] -= count[5] + count[6] + count[8]\n\n    return ''.join(chr(i + ord('0')) for i, c in enumerate(count) for j in range(c))\n", "tests": {"17": "def test_originalDigits():\n\n    def helper(s):\n        solution = Solution()", "19": "def test_originalDigits():\n    s = 'oo'\n    assert solution.originalDigits(s) == '01'", "21": "def test_originalDigits():\n\n    def helper(s):\n        solution = Solution()", "23": "def test_originalDigits():\n\n    def helper(s):\n        solution = Solution()", "25": "def test_originalDigits():\n\n    def helper(s):\n        count = [0] * 10\n        for c in s:\n            if c == 'u':\n                count[4] += 1\n        return ''.join((chr(i + ord('0')) for (i, c) in enumerate(count) for j in range(c)))\n    assert helper('un') == '4'", "27": "def test_originalDigits():\n    s = 'fifteen'\n    expected_output = '7890'\n    assert solution.originalDigits(s) == expected_output", "29": "def test_originalDigits():\n\n    def originalDigits(solution):\n        s = 'fixxu'", "31": "def test_originalDigits():\n    s = 'sxxisxiz'\n    print(solution.originalDigits(s))", "33": "def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits('ihkgf') == '12345'", "35": "def test_originalDigits(self):\n    s = 'iv'\n    self.assertEqual(solution.originalDigits(s), '4')"}}
{"task_num": 457, "task_title": "Circular Array Loop", "func_name": "circularArrayLoop", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def circularArrayLoop(self, nums: List[int]) -> bool:\n    def advance(i: int) -> int:\n      return (i + nums[i]) % len(nums)\n\n    if len(nums) < 2:\n      return False\n\n    for i, num in enumerate(nums):\n      if num == 0:\n        continue\n\n      slow = i\n      fast = advance(slow)\n      while num * nums[fast] > 0 and num * nums[advance(fast)] > 0:\n        if slow == fast:\n          if slow == advance(slow):\n            break\n          return True\n        slow = advance(slow)\n        fast = advance(advance(fast))\n\n      slow = i\n      sign = num\n      while sign * nums[slow] > 0:\n        next = advance(slow)\n        nums[slow] = 0\n        slow = next\n\n    return False\n", "tests": {"17": "def test_circularArrayLoop():\n    solution = Solution()\n    result = solution.circularArrayLoop([1])", "21": "def test_circularArrayLoop():\n\n    def assert_equal(expected, actual):\n        if expected != actual:\n            raise AssertionError(f'Expected {expected}, got {actual}')\n    nums = [4, 3, -9, -5, 4]\n    solution = Solution()\n    result = solution.circularArrayLoop(nums)", "27": "def test_circularArrayLoop():\n\n    def advance(i):\n        return (i + nums[i]) % len(nums)\n\n    class Solution:\n\n        def circularArrayLoop(self, nums):\n            if len(nums) < 2:\n                return False\n            for (i, num) in enumerate(nums):\n                if num == 0:\n                    continue\n                slow = i\n                fast = advance(slow)\n                while num * nums[fast] > 0 and num * nums[advance(fast)] > 0:\n                    if slow == fast:\n                        if slow == advance(slow):\n                            return True\n                        return True\n                    slow = advance(slow)\n                    fast = advance(advance(fast))\n            return False\n    solution = Solution()\n    nums = [1, 2, -3]\n    assert not solution.circularArrayLoop(nums), f'Expected False but got {solution.circularArrayLoop(nums)}'", "28": "def test_circularArrayLoop():\n    nums = [1, -2, 3]\n    assert solution.circularArrayLoop(nums)", "29": "def test_circularArrayLoop():\n\n    class Solution:\n\n        def circularArrayLoop(self, nums):\n\n            def advance(i):\n                return (i + nums[i]) % len(nums)\n            if len(nums) < 2:\n                return False\n            for (i, num) in enumerate(nums):\n                if num == 0:\n                    continue\n                slow = i\n                fast = advance(slow)\n                while num * nums[fast] > 0 and num * nums[advance(fast)] > 0:\n                    if slow == fast:\n                        if slow == advance(slow):\n                            break\n                        return True\n                    slow = advance(slow)\n                    fast = advance(advance(fast))\n                slow = i\n                sign = num\n                while sign * nums[slow] > 0:\n                    next = advance(slow)\n                    nums[slow] = 0\n                    slow = next\n            return False\n    solution = Solution()\n    assert solution.circularArrayLoop([2, -1, 1, -2, 2]) == True"}}
{"task_num": 524, "task_title": "Longest Word in Dictionary through Deleting", "func_name": "findLongestWord", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findLongestWord(self, s: str, d: List[str]) -> str:\n    ans = ''\n\n    for word in d:\n      i = 0\n      for c in s:\n        if i < len(word) and c == word[i]:\n          i += 1\n      if i == len(word):\n        if len(word) > len(ans) or len(word) == len(ans) and word < ans:\n          ans = word\n\n    return ans\n", "tests": {"19": "def test_findLongestWord():\n    solution = Solution()\n\n    def helper(s, d):", "21": "def test_findLongestWord():\n\n    def is_subsequence(s, t):\n        i = 0\n        for c in s:\n            if i < len(t) and c == t[i]:\n                i += 1\n        return i == len(s)\n    solution = Solution()\n    ans = solution.findLongestWord('apple', ['ape', 'appe', 'app'])", "22": "def test_findLongestWord():\n\n    class Solution:\n        pass\n\n    def findLongestWord(self, s: str, d: list[str]) -> str:\n        ans = ''\n        for word in d:\n            i = 0\n            for c in s:\n                if i < len(word) and c == word[i]:\n                    i += 1\n            if i == len(word):\n                if len(word) > len(ans) or (len(word) == len(ans) and word < ans):\n                    ans = word\n        return ans\n    solution = Solution()\n    result = solution.findLongestWord('abpcplea', ['ael', 'bp', 'aleappcpl'])"}}
{"task_num": 542, "task_title": "01 Matrix", "func_name": "updateMatrix", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(mat)\n    n = len(mat[0])\n    q = collections.deque()\n    seen = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j] == 0:\n          q.append((i, j))\n          seen[i][j] = True\n\n    while q:\n      i, j = q.popleft()\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if seen[x][y]:\n          continue\n        mat[x][y] = mat[i][j] + 1\n        q.append((x, y))\n        seen[x][y] = True\n\n    return mat\n", "tests": {"22": "def test_updateMatrix():\n\n    class SolutionMock(Solution):\n\n        def updateMatrix(self, mat):\n            return self._updateMatrix(mat)\n\n        def _updateMatrix(self, mat):\n            if not mat or not mat[0]:\n                return []\n            m = len(mat)\n            n = len(mat[0])\n            q = collections.deque()\n            seen = [[False] * n for _ in range(m)]\n            for i in range(m):\n                for j in range(n):\n                    if mat[i][j] == 0:\n                        q.append((i, j))\n                        seen[i][j] = True\n            while q:\n                (i, j) = q.popleft()\n                for (dx, dy) in dirs:\n                    x = i + dx\n                    y = j + dy\n                    if x < 0 or x == m or y < 0 or (y == n):\n                        continue\n                    if seen[x][y]:\n                        continue\n                    mat[x][y] = mat[i][j] + 1\n                    q.append((x, y))\n                    seen[x][y] = True\n            return mat\n    solution = SolutionMock()\n    mat = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n    result = solution.updateMatrix(mat)", "23": "def test_updateMatrix():\n\n    def create_matrix(m, n):\n        return [[0 if i == 0 and j < m // 2 else 1 for j in range(n)] for i in range(m)]\n    solution = Solution()\n    mat = create_matrix(5, 5)\n    expected_result = [[3, 3, 2, 3, 3], [3, 2, 2, 2, 3], [3, 2, 1, 2, 3], [3, 2, 2, 2, 3], [3, 3, 2, 3, 3]]\n    result = solution.updateMatrix(mat)", "31": "def test_updateMatrix(self):\n    mat = [[0, 0, 0], [0, 1, 0], [1, 1, 1]]\n    expected_result = [[0, 0, 0], [0, 1, 0], [1, 2, 1]]\n    self.assertEqual(solution.updateMatrix(mat), expected_result)", "33": "def test_updateMatrix():\n    solution = Solution()\n    mat = [[0, 0], [0, 0]]\n    expected = [[1, 1], [1, 1]]\n    assert solution.updateMatrix(mat) == expected"}}
{"task_num": 547, "task_title": "Number of Provinces", "func_name": "findCircleNum", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    self.count -= 1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findCircleNum(self, isConnected: List[List[int]]) -> int:\n    n = len(isConnected)\n    uf = UnionFind(n)\n\n    for i in range(n):\n      for j in range(i, n):\n        if isConnected[i][j] == 1:\n          uf.unionByRank(i, j)\n\n    return uf.count\n", "tests": {"21": "def test_findCircleNum():\n\n    def findCircleNum(isConnected):\n        n = len(isConnected)\n        uf = UnionFind(n)\n        for i in range(n):\n            for j in range(i, n):\n                if isConnected[i][j] == 1:\n                    uf.unionByRank(i, j)\n        return uf.count\n    solution = Solution()\n    print(findCircleNum([[1, 1, 0], [1, 1, 0], [0, 0, 1]]))", "23": "def test_findCircleNum(self):\n    isConnected = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    self.assertEqual(solution.findCircleNum(isConnected), 3)", "25": "def test_findCircleNum(self):\n    n = 3\n    isConnected = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]\n    self.assertEqual(solution.findCircleNum(isConnected), 2)", "27": "def test_findCircleNum():\n\n    class Solution:\n\n        def findCircleNum(self, isConnected):\n            n = len(isConnected)\n            uf = UnionFind(n)\n            for i in range(n):\n                for j in range(i + 1, n):\n                    if isConnected[i][j] == 1:\n                        uf.unionByRank(i, j)\n            return uf.count\n    solution = Solution()\n    print(solution.findCircleNum([[1, 0, 1], [0, 1, 0], [1, 0, 1]]))", "28": "def test_findCircleNum(self):\n\n    class SolutionTest(Solution):\n\n        def findCircleNum(self, isConnected):\n            n = len(isConnected)\n            uf = UnionFind(n)\n            for i in range(n):\n                for j in range(i + 1, n):\n                    if isConnected[i][j] == 1:\n                        uf.unionByRank(i, j)\n            return uf.count\n    solution = SolutionTest()\n    isConnected = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]\n    self.assertEqual(solution.findCircleNum(isConnected), 3)", "33": "def test_findCircleNum():\n\n    class Solution:\n\n        def findCircleNum(self, isConnected):\n            n = len(isConnected)\n            uf = UnionFind(n)\n            for i in range(n):\n                for j in range(i, n):\n                    if isConnected[i][j] == 1:\n                        uf.unionByRank(i, j)\n            return uf.count\n    solution = Solution()\n\n    def check_correct_output():\n        isConnected = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]\n        uf = UnionFind(3)\n        for i in range(3):\n            for j in range(i, 3):\n                if isConnected[i][j] == 1:\n                    uf.unionByRank(i, j)\n        assert solution.findCircleNum(isConnected) == 2", "45": "def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    assert solution.findCircleNum(isConnected) == 3"}}
{"task_num": 581, "task_title": "Shortest Unsorted Continuous Subarray", "func_name": "findUnsortedSubarray", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findUnsortedSubarray(self, nums: List[int]) -> int:\n    mini = math.inf\n    maxi = -math.inf\n    flag = False\n\n    for i in range(1, len(nums)):\n      if nums[i] < nums[i - 1]:\n        flag = True\n      if flag:\n        mini = min(mini, nums[i])\n\n    flag = False\n\n    for i in reversed(range(len(nums) - 1)):\n      if nums[i] > nums[i + 1]:\n        flag = True\n      if flag:\n        maxi = max(maxi, nums[i])\n\n    for l in range(len(nums)):\n      if nums[l] > mini:\n        break\n\n    for r, num in reversed(list(enumerate(nums))):\n      if num < maxi:\n        break\n\n    return 0 if l >= r else r - l + 1\n", "tests": {"19": "def test_findUnsortedSubarray():\n\n    class Solution:\n\n        def findUnsortedSubarray(self, nums):\n            mini = math.inf\n            maxi = -math.inf\n            flag = False\n            for i in range(1, len(nums)):\n                if nums[i] < nums[i - 1]:\n                    flag = True\n                if flag:\n                    mini = min(mini, nums[i])\n            flag = False\n            for i in reversed(range(len(nums) - 1)):\n                if nums[i] > nums[i + 1]:\n                    flag = True\n                if flag:\n                    maxi = max(maxi, nums[i])\n            for l in range(len(nums)):\n                if nums[l] > mini:\n                    break\n            for (r, num) in reversed(list(enumerate(nums))):\n                if num < maxi:\n                    break\n            return 0 if l >= r and (not flag) else r - l + 1\n    solution = Solution()\n    print(solution.findUnsortedSubarray([2, 6, 4, 8, 10, 9, 15]))", "21": "def test_findUnsortedSubarray():\n\n    def findUnsortedSubarray(nums):\n        import math\n        mini = math.inf\n        maxi = -math.inf\n        flag = False\n        for i in range(1, len(nums)):\n            if nums[i] < nums[i - 1]:\n                flag = True\n            if flag:\n                mini = min(mini, nums[i])\n        flag = False\n        for i in reversed(range(len(nums) - 1)):\n            if nums[i] > nums[i + 1]:\n                flag = True\n            if flag:\n                maxi = max(maxi, nums[i])\n        for l in range(len(nums)):\n            if nums[l] > mini:\n                break\n        for (r, num) in reversed(list(enumerate(nums))):\n            if num < maxi:\n                break\n        return 0 if l >= r else r - l + 1\n    assert findUnsortedSubarray([2, 6, 4, 8, 10]) == 2", "27": "def test_findUnsortedSubarray():\n\n    def find_unsorted_subarray(nums):\n        mini = math.inf\n        maxi = -math.inf\n        flag = False\n        for i in range(1, len(nums)):\n            if nums[i] < nums[i - 1]:\n                flag = True\n            if flag:\n                mini = min(mini, nums[i])\n        flag = False\n        for i in reversed(range(len(nums) - 1)):\n            if nums[i] > nums[i + 1]:\n                flag = True\n            if flag:\n                maxi = max(maxi, nums[i])\n        for l in range(len(nums)):\n            if nums[l] > mini:\n                break\n        for (r, num) in reversed(list(enumerate(nums))):\n            if num < maxi:\n                break\n        return 0 if l >= r else r - l + 1\n    solution = Solution()\n    result = find_unsorted_subarray([2, 6, 4, 8, 10, 9, 15])\n    assert result == 5, f'Expected 5, got {result}'", "29": "def test_findUnsortedSubarray():\n\n    class Solution:\n\n        def findUnsortedSubarray(self, nums):\n            mini = math.inf\n            maxi = -math.inf\n            flag = False\n            for i in range(1, len(nums)):\n                if nums[i] < nums[i - 1]:\n                    flag = True\n                if flag:\n                    mini = min(mini, nums[i])\n            flag = False\n            for i in reversed(range(len(nums) - 1)):\n                if nums[i] > nums[i + 1]:\n                    flag = True\n                if flag:\n                    maxi = max(maxi, nums[i])\n            for l in range(len(nums)):\n                if nums[l] > mini:\n                    break\n            for (r, num) in reversed(list(enumerate(nums))):\n                if num < maxi:\n                    break\n            return 0 if 2 >= 3 else 3 - 2 + 1\n    solution = Solution()\n    assert solution.findUnsortedSubarray([2, 6, 4, 8, 10, 9, 15]) == 5", "33": "def test_findUnsortedSubarray():\n\n    def findUnsortedSubarray(nums):\n        import math\n        mini = math.inf\n        maxi = -math.inf\n        flag = False\n        for i in range(1, len(nums)):\n            if nums[i] < nums[i - 1]:\n                flag = True\n            if flag:\n                mini = min(mini, nums[i])\n        flag = False\n        for i in reversed(range(len(nums) - 1)):\n            if nums[i] > nums[i + 1]:\n                flag = True\n            if flag:\n                maxi = max(maxi, nums[i])\n        for l in range(len(nums)):\n            if nums[l] > mini:\n                return 0\n        for (r, num) in reversed(list(enumerate(nums))):\n            if num < maxi:\n                break\n        return len(nums)\n    solution = Solution()\n    print(solution.findUnsortedSubarray([2, 6, 4, 8, 10, 9, 15]))", "37": "def test_findUnsortedSubarray(self):\n\n    class Solution:\n\n        def findUnsortedSubarray(self, nums: List[int]) -> int:\n            mini = math.inf\n            maxi = -math.inf\n            flag = False\n            for i in range(1, len(nums)):\n                if nums[i] < nums[i - 1]:\n                    flag = True\n                if flag:\n                    mini = min(mini, nums[i])\n            flag = False\n            for i in reversed(range(len(nums) - 1)):\n                if nums[i] > nums[i + 1]:\n                    flag = True\n                if flag:\n                    maxi = max(maxi, nums[i])\n            for l in range(len(nums)):\n                if nums[l] > mini:\n                    break\n            for (r, num) in reversed(list(enumerate(nums))):\n                if num < maxi:\n                    break\n            return 0 if l >= r else r - l + 1\n    solution = Solution()\n    self.assertEqual(solution.findUnsortedSubarray([2, 6, 4, 8, 10]), 5)"}}
{"task_num": 591, "task_title": "Tag Validator", "func_name": "isValid", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isValid(self, code: str) -> bool:\n    if code[0] != '<' or code[-1] != '>':\n      return False\n\n    containsTag = False\n    stack = []\n\n    def isValidCdata(s: str) -> bool:\n      return s.find('[CDATA[') == 0\n\n    def isValidTagName(tagName: str, isEndTag: bool) -> bool:\n      nonlocal containsTag\n      if not tagName or len(tagName) > 9:\n        return False\n      if any(not c.isupper() for c in tagName):\n        return False\n\n      if isEndTag:\n        return stack and stack.pop() == tagName\n\n      containsTag = True\n      stack.append(tagName)\n      return True\n\n    i = 0\n    while i < len(code):\n      if not stack and containsTag:\n        return False\n      if code[i] == '<':\n        if stack and code[i + 1] == '!':\n          closeIndex = code.find(']]>', i + 2)\n          if closeIndex == -1 or not isValidCdata(code[i + 2:closeIndex]):\n            return False\n        elif code[i + 1] == '/':\n          closeIndex = code.find('>', i + 2)\n          if closeIndex == -1 or not isValidTagName(code[i + 2:closeIndex], True):\n            return False\n        else:\n          closeIndex = code.find('>', i + 1)\n          if closeIndex == -1 or not isValidTagName(code[i + 1:closeIndex], False):\n            return False\n        i = closeIndex\n      i += 1\n\n    return not stack and containsTag\n", "tests": {"14": "def test_isValid():\n    solution = Solution()\n    assert not solution.isValid('<invalid>'), 'Test failed for invalid wrapped tag'", "25": "def test_isValid():\n\n    def test_case_1():\n        code = 'a<valid_tag>content</invalid_tag>'\n        assert not solution.isValid(code)", "27": "def test_isValid():\n\n    def test_valid_code():\n        code = '<A>valid<code></A>'\n        assert solution.isValid(code) == True", "30": "def test_isValid():\n\n    class Solution:\n\n        def isValid(self, code: str) -> bool:\n            pass\n    solution = Solution()\n    assert not solution.isValid('<A>'), 'Test case 1 failed'", "39": "def test_isValid(self):\n    solution = Solution()\n    self.assertFalse(solution.isValid('<>'))", "41": "def test_isValid():\n\n    def isValid(code: str) -> bool:\n        return code == '<TAG>content</TAG>' or code == '<!CDATA[content]]> '\n    assert isValid('<TAG>content</TAG>')\n    assert isValid('<!CDATA[content]]>')", "42": "def test_isValid():\n    solution = Solution()\n    assert not solution.isValid('<![CDATA[Hello World!]]>'), 'CDATA without CDATA_CONTENT is invalid'", "43": "def test_isValid():\n    solution = Solution()\n    assert solution.isValid('<![CDATA[Invalid Data]]>') == True", "44": "def test_isValid():\n    solution = Solution()\n\n    def test_code():\n        assert not solution.isValid('<![CDATA['), 'Invalid CDATA'", "45": "def test_isValid():\n\n    def check(code: str) -> bool:\n        return Solution().isValid(code)\n    assert check('<div>text</div>') == True\n    assert check('<div>/invalid_tag</div>') == False\n\n    class MockSolution(Solution):\n\n        def isValidCdata(self, s: str) -> bool:\n            return False\n\n        def isValidTagName(self, tagName: str, isEndTag: bool) -> bool:\n            return True\n    solution = MockSolution()\n    assert check('<![CDATA[text]]>') == False\n    assert check('unmatched_tag<unmatched_content/>') == False", "46": "def test_isValid():\n    class Solution:\n        def isValid(self, code: str) -> bool:\n            # ... (unchanged code from original program)\n\n    solution = Solution()\n\n    code = \"<A>123</A>\"\n    assert solution.isValid(code) == True", "47": "def test_isValid(self):\n    solution = Solution()\n    self.assertTrue(solution.isValid('<A>'))", "48": "def test_isValid():\n    solution = Solution()\n    assert not solution.isValid('<invalid TAG_NAME>'), 'Test case failed'", "50": "def test_isValid():\n    solution = Solution()\n    print(solution.isValid('<tag>hello</tag>'))", "51": "def test_isValid(self):\n    solution = Solution()\n    self.assertTrue(solution.isValid('<A>'))", "52": "def test_isValid():\n    solution = Solution()\n\n    def test_input1(code: str) -> None:\n        assert not solution.isValid(code)", "53": "def test_isValid():\n    solution = Solution()\n\n    def assert_valid(code):"}}
{"task_num": 648, "task_title": "Replace Words", "func_name": "replaceWords", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def __init__(self):\n    self.root = {}\n\n  def insert(self, word: str) -> None:\n    node = self.root\n    for c in word:\n      if c not in node:\n        node[c] = {}\n      node = node[c]\n    node['word'] = word\n\n  def search(self, word: str) -> str:\n    node = self.root\n    for c in word:\n      if 'word' in node:\n        return node['word']\n      if c not in node:\n        return word\n      node = node[c]\n    return word\n\n  def replaceWords(self, dictionary: List[str], sentence: str) -> str:\n    for word in dictionary:\n      self.insert(word)\n\n    words = sentence.split(' ')\n    return ' '.join([self.search(word) for word in words])\n", "tests": {"19": "def test_replaceWords():\n    solution = Solution()\n    dictionary = ['cat', 'bat', 'rat']\n    sentence = 'the cattle bat'\n    expected_output = 'the cat bat'\n    assert solution.replaceWords(dictionary, sentence) == expected_output", "27": "    def test_replaceWords(self):\n        def replaceWords(dictionary, sentence):\n            dictionary = set(dictionary)\n            words = sentence.split(' ')\n            return ' '.join([min(word if word not in dictionary else node['word'] \n                                for c in (self.root := self.root | {w: {} for w in dictionary})\n                                if (node := c.get(self.root)) and (c in word or any(c == n and (n := self.root[n]) for n in dictionary))\n                                else None)\n                             for word in words])\n\n        solution = Solution()\n        for word in ['help', 'ful']:\n            solution.insert(word)\n\n        self.assertEqual(replaceWords(['help'], \"he is help ful\"), \"he is help ful\")\n\nif __name__ == '__main__':\n    unittest.main()", "29": "def test_replaceWords():\n    dictionary = ['cat']\n    sentence = 'the cat is at the dog'\n    print(solution.replaceWords(dictionary, sentence))"}}
{"task_num": 673, "task_title": "Number of Longest Increasing Subsequence", "func_name": "findNumberOfLIS", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findNumberOfLIS(self, nums: List[int]) -> int:\n    ans = 0\n    maxLength = 0\n    length = [1] * len(nums)\n    count = [1] * len(nums)\n\n    for i, num in enumerate(nums):\n      for j in range(i):\n        if nums[j] < num:\n          if length[i] < length[j] + 1:\n            length[i] = length[j] + 1\n            count[i] = count[j]\n          elif length[i] == length[j] + 1:\n            count[i] += count[j]\n\n    for i, l in enumerate(length):\n      if l > maxLength:\n        maxLength = l\n        ans = count[i]\n      elif l == maxLength:\n        ans += count[i]\n\n    return ans\n", "tests": {"21": "def test_findNumberOfLIS():\n\n    class Solution:\n\n        def findNumberOfLIS(self, nums):\n            ans = 0\n            maxLength = 0\n            length = [1] * len(nums)\n            count = [1] * len(nums)\n            for (i, num) in enumerate([9, 4, 6, 7, 2]):\n                for j in range(i):\n                    if nums[j] < num:\n                        if length[i] < length[j] + 1:\n                            length[i] = length[j] + 1\n                            count[i] = count[j]\n                        elif length[i] == length[j] + 1:\n                            count[i] += count[j]\n            for (i, l) in enumerate(length):\n                if l > maxLength:\n                    maxLength = l\n                    ans = count[i]\n                elif l == maxLength:\n                    ans += count[i]\n            return ans\n    solution = Solution()\n    print(solution.findNumberOfLIS([1, 2, 4, 3, 5, 4, 7, 2]))", "22": "def test_findNumberOfLIS():\n\n    class Solution:\n\n        def findNumberOfLIS(self, nums):\n            ans = 0\n            maxLength = 0\n            length = [1] * len(nums)\n            count = [1] * len(nums)\n            for (i, num) in enumerate([3, 4, 7, 2]):\n                for j in range(i):\n                    if nums[j] < num:\n                        if length[i] < length[j] + 1:\n                            length[i] = length[j] + 1\n                            count[i] = count[j]\n                        elif length[i] == length[j] + 1:\n                            count[i] += count[j]\n            for (i, l) in enumerate(length):\n                if l > maxLength:\n                    maxLength = l\n                    ans = count[i]\n                elif l == maxLength:\n                    ans += count[i]\n            return ans\n    solution = Solution()\n    assert solution.findNumberOfLIS([1, 3, 5, 4, 7]) == 2", "23": "def test_findNumberOfLIS():\n    solution = Solution()\n    nums = [1, 3, 5, 4, 7]\n    assert solution.findNumberOfLIS(nums) == 2", "24": "def test_findNumberOfLIS():\n    solution = Solution()\n    nums = [1, 2, 4, 3, 5, 4, 7, 2]\n    assert solution.findNumberOfLIS(nums) == 2", "25": "def test_findNumberOfLIS():\n    def input_data(nums):", "29": "def test_findNumberOfLIS():\n    solution = Solution()\n    nums = [1, 3, 5, 4, 7]\n    assert solution.findNumberOfLIS(nums) == 2", "30": "def test_findNumberOfLIS():\n\n    def findNumberOfLIS(nums):\n        ans = 0\n        maxLength = 0\n        length = [1] * len(nums)\n        count = [1] * len(nums)\n        for (i, num) in enumerate(nums):\n            for j in range(i):\n                if nums[j] < num:\n                    if length[i] < length[j] + 1:\n                        length[i] = length[j] + 1\n                        count[i] = count[j]\n                    elif length[i] == length[j] + 1:\n                        count[i] += count[j]\n        for (i, l) in enumerate(length):\n            if l > maxLength:\n                maxLength = l\n                ans = count[i]\n            elif l == maxLength:\n                ans += count[i]\n        return ans\n    solution = Solution()\n    nums = [1, 3, 5, 4, 7]\n    assert findNumberOfLIS(nums) == 2", "32": "def test_findNumberOfLIS():\n\n    class Solution:\n\n        def findNumberOfLIS(self, nums):\n            return 5\n    solution = Solution()\n    assert solution.findNumberOfLIS([1, 2, 3, 4, 5]) == 5"}}
{"task_num": 684, "task_title": "Redundant Connection", "func_name": "findRedundantConnection", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n    uf = UnionFind(len(edges) + 1)\n\n    for edge in edges:\n      u, v = edge\n      if not uf.unionByRank(u, v):\n        return edge\n", "tests": {"20": "def test_findRedundantConnection():\n\n    def findRedundantConnection(edges):\n        uf = UnionFind(len(edges) + 1)\n        for edge in edges:\n            (u, v) = edge\n            if not uf.unionByRank(u, v):\n                return edge\n    solution = Solution()\n    print(findRedundantConnection([[1, 2], [2, 3], [3, 4], [1, 4], [1, 5]]))", "22": "def test_findRedundantConnection():\n\n    def findRedundantConnection(edges):\n        uf = UnionFind(len(edges) + 1)\n        for edge in edges:\n            (u, v) = edge\n            if not uf.unionByRank(u, v):\n                return edge\n    solution = Solution()\n    assert findRedundantConnection([[1, 2], [2, 3], [3, 4], [1, 4], [1, 5]]) == [1, 5]", "24": "def test_findRedundantConnection(self):\n    solution = Solution()\n    edges = [[1, 2], [1, 3], [2, 3]]\n    self.assertEqual(solution.findRedundantConnection(edges), [2, 3])", "26": "def test_findRedundantConnection():\n\n    def findRedundantConnection(edges):\n        uf = UnionFind(len(edges) + 1)\n        for edge in edges:\n            (u, v) = edge\n            if not uf.unionByRank(u, v):\n                return edge\n        return None\n    solution = Solution()\n    edges = [[1, 2], [1, 3], [2, 3]]\n    assert findRedundantConnection(edges) == [2, 3]", "27": "def test_findRedundantConnection():\n\n    def findRedundantConnection(edges):\n\n        class UnionFind:\n\n            def __init__(self, n: int):\n                self.id = list(range(n))\n                self.rank = [0] * n\n\n            def unionByRank(self, u: int, v: int) -> bool:\n                i = self._find(u)\n                j = self._find(v)\n                if i == j:\n                    return False\n                if self.rank[i] < self.rank[j]:\n                    self.id[i] = j\n                elif self.rank[i] > self.rank[j]:\n                    self.id[j] = i\n                else:\n                    self.id[i] = j\n                    self.rank[j] += 1\n                return True\n\n            def _find(self, u: int) -> int:\n                if self.id[u] != u:\n                    self.id[u] = self._find(self.id[u])\n                return self.id[u]\n        uf = UnionFind(len(edges) + 1)\n        for edge in edges:\n            (u, v) = edge\n            if not uf.unionByRank(u, v):\n                return edge\n    solution = Solution()\n    edges = [[1, 2], [1, 3], [2, 3]]\n    assert findRedundantConnection(edges) == [2, 3]", "32": "def test_findRedundantConnection():\n    solution = Solution()\n\n    def assert_solution(expected, actual):\n        if expected != actual:\n            raise AssertionError(f'Expected {expected}, got {actual}')\n    uf = UnionFind(4)\n    edges = [[1, 2], [1, 3], [2, 3]]\n    result = solution.findRedundantConnection(edges)", "43": "def test_findRedundantConnection(self):\n    solution = Solution()\n    edges = [[1, 2], [1, 3], [2, 3]]\n    self.assertEqual(solution.findRedundantConnection(edges), [2, 3])"}}
{"task_num": 685, "task_title": "Redundant Connection II", "func_name": "findRedundantDirectedConnection", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\n    ids = [0] * (len(edges) + 1)\n    nodeWithTwoParents = 0\n\n    for _, v in edges:\n      ids[v] += 1\n      if ids[v] == 2:\n        nodeWithTwoParents = v\n\n    def findRedundantDirectedConnection(skippedEdgeIndex: int) -> List[int]:\n      uf = UnionFind(len(edges) + 1)\n\n      for i, edge in enumerate(edges):\n        if i == skippedEdgeIndex:\n          continue\n        if not uf.unionByRank(edge[0], edge[1]):\n          return edge\n\n      return []\n\n    if nodeWithTwoParents == 0:\n      return findRedundantDirectedConnection(-1)\n\n    for i in reversed(range(len(edges))):\n      _, v = edges[i]\n      if v == nodeWithTwoParents:\n        if not findRedundantDirectedConnection(i):\n          return edges[i]\n", "tests": {"20": "def test_findRedundantDirectedConnection():\n\n    class Solution:\n\n        def findRedundantDirectedConnection(self, edges):\n            ids = [0] * (len(edges) + 1)\n            nodeWithTwoParents = 0\n            for (_, v) in edges:\n                ids[v] += 1\n                if ids[v] == 2:\n                    nodeWithTwoParents = v\n\n            def findRedundantDirectedConnection(skippedEdgeIndex):\n                uf = UnionFind(len(edges) + 1)\n                for (i, edge) in enumerate(edges):\n                    if i == skippedEdgeIndex:\n                        continue\n                    if not uf.unionByRank(edge[0], edge[1]):\n                        return edge\n                return []\n            if nodeWithTwoParents == 0:\n                return findRedundantDirectedConnection(-1)\n            for i in reversed(range(len(edges))):\n                (_, v) = edges[i]\n                if v == nodeWithTwoParents:\n                    if not findRedundantDirectedConnection(i):\n                        return edges[i]\n\n    class UnionFind:\n\n        def __init__(self, n: int):\n            self.id = list(range(n))\n            self.rank = [0] * n\n\n        def unionByRank(self, u: int, v: int) -> bool:\n            i = self._find(u)\n            j = self._find(v)\n            if i == j:\n                return False\n            if self.rank[i] < self.rank[j]:\n                self.id[i] = j\n            elif self.rank[i] > self.rank[j]:\n                self.id[j] = i\n            else:\n                self.id[i] = j\n                self.rank[j] += 1\n            return True\n\n        def _find(self, u: int) -> int:\n            if self.id[u] != u:\n                self.id[u] = self._find(self.id[u])\n            return self.id[u]\n    solution = Solution()\n    edges = [[3, 4], [5, 2], [6, 7], [8, 1]]\n    assert solution.findRedundantDirectedConnection(edges) == [5, 2], 'Test case failed'", "22": "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1, 2], [1, 3], [2, 4], [2, 5]]\n    expectedOutput = [2, 4]\n    result = solution.findRedundantDirectedConnection(edges)", "24": "def test_findRedundantDirectedConnection():\n\n    class Solution:\n\n        def findRedundantDirectedConnection(self, edges):\n            ids = [0] * (len(edges) + 1)\n            nodeWithTwoParents = 0\n            for (_, v) in edges:\n                ids[v] += 1\n                if ids[v] == 2:\n                    nodeWithTwoParents = v\n\n            def findRedundantDirectedConnection(skippedEdgeIndex):\n                uf = UnionFind(len(edges) + 1)\n                for (i, edge) in enumerate(edges):\n                    if i == skippedEdgeIndex:\n                        continue\n                    if not uf.unionByRank(edge[0], edge[1]):\n                        return edge\n                return []\n            if nodeWithTwoParents == 0:\n                return findRedundantDirectedConnection(-1)\n            for i in reversed(range(len(edges))):\n                (_, v) = edges[i]\n                if v == nodeWithTwoParents:\n                    if not findRedundantDirectedConnection(i):\n                        return edges[i]\n\n    class UnionFind:\n\n        def __init__(self, n: int):\n            self.id = list(range(n))\n            self.rank = [0] * n\n\n        def unionByRank(self, u: int, v: int) -> bool:\n            i = self._find(u)\n            j = self._find(v)\n            if i == j:\n                return False\n            if self.rank[i] < self.rank[j]:\n                self.id[i] = j\n                return True\n            elif self.rank[i] > self.rank[j]:\n                self.id[j] = i\n                return True\n            else:\n                self.id[i] = j\n                self.rank[j] += 1\n                return True\n\n        def _find(self, u: int) -> int:\n            if self.id[u] != u:\n                self.id[u] = self._find(self.id[u])\n            return self.id[u]\n    solution = Solution()\n    edges = [[1, 2], [2, 3], [3, 4], [5, 6]]\n    assert solution.findRedundantDirectedConnection(edges) == [3, 4]", "26": "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1, 2], [1, 3], [2, 4], [3, 4]]\n    assert solution.findRedundantDirectedConnection(edges) == [2, 4]", "27": "def test_findRedundantDirectedConnection(self):\n\n    class Solution:\n\n        def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\n            ids = [0] * (len(edges) + 1)\n            nodeWithTwoParents = 0\n            for (_, v) in edges:\n                ids[v] += 1\n                if ids[v] == 2:\n                    nodeWithTwoParents = v\n            uf = UnionFind(len(edges) + 1)\n            for (i, edge) in enumerate(edges):\n                uf.unionByRank(edge[0], edge[1])\n            redundantEdge = [0, 0]\n            for (_, v) in edges:\n                if ids[v] == 2 and (not uf._find(v) == v):\n                    redundantEdge = [v, _]\n            return redundantEdge\n\n    class UnionFind:\n\n        def __init__(self, n: int):\n            self.id = list(range(n))\n            self.rank = [0] * n\n\n        def unionByRank(self, u: int, v: int) -> bool:\n            i = self._find(u)\n            j = self._find(v)\n            if i == j:\n                return False\n            if self.rank[i] < self.rank[j]:\n                self.id[i] = j\n            elif self.rank[i] > self.rank[j]:\n                self.id[j] = i\n            else:\n                self.id[i] = j\n                self.rank[j] += 1\n            return True\n\n        def _find(self, u: int) -> int:\n            if self.id[u] != u:\n                self.id[u] = self._find(self.id[u])\n            return self.id[u]\n    solution = Solution()\n    edges = [[3, 5], [2, 4], [1, 2], [2, 5]]\n    self.assertEqual(solution.findRedundantDirectedConnection(edges), [2, 5])", "32": "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1, 2], [2, 3], [3, 4], [5, 2]]\n    result = solution.findRedundantDirectedConnection(edges)", "44": "def test_findRedundantDirectedConnection(self):\n    solution = Solution()\n    edges = [[1, 2], [1, 3], [2, 4]]\n    self.assertEqual(solution.findRedundantDirectedConnection(edges), [2, 3])", "51": "def test_findRedundantDirectedConnection():\n\n    class Solution:\n\n        def findRedundantDirectedConnection(self, edges):\n            ids = [0] * (len(edges) + 1)\n            nodeWithTwoParents = 0\n            for (_, v) in edges:\n                ids[v] += 1\n                if ids[v] == 2:\n                    nodeWithTwoParents = v\n\n            def findRedundantDirectedConnection(skippedEdgeIndex):\n                uf = UnionFind(len(edges) + 1)\n                for (i, edge) in enumerate(edges):\n                    if i == skippedEdgeIndex:\n                        continue\n                    if not uf.unionByRank(edge[0], edge[1]):\n                        return edge\n                return []\n            if nodeWithTwoParents == 0:\n                return findRedundantDirectedConnection(-1)\n            for i in reversed(range(len(edges))):\n                (_, v) = edges[i]\n                if v == nodeWithTwoParents:\n                    if not findRedundantDirectedConnection(i):\n                        return edges[i]\n    solution = Solution()\n\n    class UnionFind:\n\n        def __init__(self, n: int):\n            self.id = list(range(n))\n            self.rank = [0] * n\n\n        def unionByRank(self, u: int, v: int) -> bool:\n            i = self._find(u)\n            j = self._find(v)\n            if i == j:\n                return False\n            if self.rank[i] < self.rank[j]:\n                self.id[i] = j\n            elif self.rank[i] > self.rank[j]:\n                self.id[j] = i\n            else:\n                self.id[i] = j\n                self.rank[j] += 1\n            return True\n\n        def _find(self, u: int) -> int:\n            if self.id[u] != u:\n                self.id[u] = self._find(self.id[u])\n            return self.id[u]\n    edges = [[1, 2], [1, 3], [2, 3]]\n    assert solution.findRedundantDirectedConnection(edges) == [2, 3]", "53": "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1, 2], [2, 3], [3, 4], [5, 6]]\n    expected = [2, 3]\n    assert solution.findRedundantDirectedConnection(edges) == expected", "58": "def test_findRedundantDirectedConnection(self):\n\n    class Solution:\n\n        def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\n            ids = [0] * (len(edges) + 1)\n            nodeWithTwoParents = 0\n            for (_, v) in edges:\n                ids[v] += 1\n                if ids[v] == 2:\n                    nodeWithTwoParents = v\n\n            def findRedundantDirectedConnection(skippedEdgeIndex: int) -> List[int]:\n                uf = UnionFind(len(edges) + 1)\n                for (i, edge) in enumerate(edges):\n                    if i == skippedEdgeIndex:\n                        continue\n                    if not uf.unionByRank(edge[0], edge[1]):\n                        return edge\n                return []\n            if nodeWithTwoParents == 0:\n                return findRedundantDirectedConnection(-1)\n            edges = [[1, 2], [1, 3], [2, 4]]\n            self.assertEqual(findRedundantDirectedConnection(0), [1, 3])\n    solution = Solution()\n    print(solution.findRedundantDirectedConnection([[1, 2], [1, 3], [2, 3]]))", "63": "def test_findRedundantDirectedConnection():\n\n    class Solution:\n\n        def findRedundantDirectedConnection(self, edges):\n            ids = [0] * (len(edges) + 1)\n            nodeWithTwoParents = 0\n            for (_, v) in edges:\n                ids[v] += 1\n                if ids[v] == 2:\n                    nodeWithTwoParents = v\n\n            def findRedundantDirectedConnection(skippedEdgeIndex):\n                uf = UnionFind(len(edges) + 1)\n                for (i, edge) in enumerate(edges):\n                    if i == skippedEdgeIndex:\n                        continue\n                    if not uf.unionByRank(edge[0], edge[1]):\n                        return edge\n                return []\n            if nodeWithTwoParents == 0:\n                return findRedundantDirectedConnection(-1)\n            for i in reversed(range(len(edges))):\n                (_, v) = edges[i]\n                if v == nodeWithTwoParents:\n                    if not findRedundantDirectedConnection(i):\n                        return edges[i]\n\n    class UnionFind:\n\n        def __init__(self, n: int):\n            self.id = list(range(n))\n            self.rank = [0] * n\n\n        def unionByRank(self, u: int, v: int) -> bool:\n            i = self._find(u)\n            j = self._find(v)\n            if i == j:\n                return False\n            if self.rank[i] < self.rank[j]:\n                self.id[i] = j\n            elif self.rank[i] > self.rank[j]:\n                self.id[j] = i\n            else:\n                self.id[i] = j\n                self.rank[j] += 1\n            return True\n\n        def _find(self, u: int) -> int:\n            if self.id[u] != u:\n                self.id[u] = self._find(self.id[u])\n            return self.id[u]\n    solution = Solution()\n    edges = [[5, 2], [4, 3], [0, 1]]\n    assert solution.findRedundantDirectedConnection(edges) == [5, 1]", "64": "def test_findRedundantDirectedConnection():\n\n    class Solution:\n\n        def findRedundantDirectedConnection(self, edges):\n            ids = [0] * (len(edges) + 1)\n            nodeWithTwoParents = 0\n            for (_, v) in edges:\n                ids[v] += 1\n                if ids[v] == 2:\n                    nodeWithTwoParents = v\n\n            def findRedundantDirectedConnection(skippedEdgeIndex):\n                uf = UnionFind(len(edges) + 1)\n                for (i, edge) in enumerate(edges):\n                    if i == skippedEdgeIndex:\n                        continue\n                    if not uf.unionByRank(edge[0], edge[1]):\n                        return edge\n                return []\n            if nodeWithTwoParents == 0:\n                return findRedundantDirectedConnection(-1)\n            for i in reversed(range(len(edges))):\n                (_, v) = edges[i]\n                if v == nodeWithTwoParents:\n                    if not findRedundantDirectedConnection(i):\n                        return edges[i]\n\n    class UnionFind:\n\n        def __init__(self, n: int):\n            self.id = list(range(n))\n            self.rank = [0] * n\n\n        def unionByRank(self, u: int, v: int) -> bool:\n            i = self._find(u)\n            j = self._find(v)\n            if i == j:\n                return False\n            if self.rank[i] < self.rank[j]:\n                self.id[i] = j\n            elif self.rank[i] > self.rank[j]:\n                self.id[j] = i\n            else:\n                self.id[i] = j\n                self.rank[j] += 1\n            return True\n\n        def _find(self, u: int) -> int:\n            if self.id[u] != u:\n                self.id[u] = self._find(self.id[u])\n            return self.id[u]\n    solution = Solution()\n    edges = [[2, 3], [3, 4], [4, 1]]\n    assert solution.findRedundantDirectedConnection(edges) == [2, 3], f'expected [2,3] but got {solution.findRedundantDirectedConnection(edges)}'"}}
{"task_num": 688, "task_title": "Knight Probability in Chessboard", "func_name": "knightProbability", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\n    dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n    dp = [[0] * n for _ in range(n)]\n    dp[row][column] = 1.0\n\n    for _ in range(k):\n      newDp = [[0] * n for _ in range(n)]\n      for i in range(n):\n        for j in range(n):\n          for dx, dy in dirs:\n            x = i + dx\n            y = j + dy\n            if 0 <= x < n and 0 <= y < n:\n              newDp[i][j] += dp[x][y]\n      dp = newDp\n\n    return sum(map(sum, dp)) / 8**k\n", "tests": {"25": "def test_knightProbability():\n    solution = Solution()\n\n    def ktest(n, k, row, column):\n        import math\n        import itertools\n        import bisect\n        import collections\n        import string\n        import heapq\n        import functools\n        import sortedcontainers\n        dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n        dp = [[0] * n for _ in range(n)]\n        dp[row][column] = 1.0\n        for _ in range(k):\n            newDp = [[0] * n for _ in range(n)]\n            for i in range(n):\n                for j in range(n):\n                    for (dx, dy) in dirs:\n                        x = i + dx\n                        y = j + dy\n                        if 0 <= x < n and 0 <= y < n:\n                            newDp[i][j] += dp[x][y]\n            dp = newDp\n        return sum(map(sum, dp)) / 8 ** k\n    assert ktest(3, 2, 0, 0) == 0.421875, 'Unexpected result'"}}
{"task_num": 689, "task_title": "Maximum Sum of 3 Non-Overlapping Subarrays", "func_name": "maxSumOfThreeSubarrays", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:\n    n = len(nums) - k + 1\n    sums = [0] * n\n    l = [0] * n\n    r = [0] * n\n\n    summ = 0\n    for i, num in enumerate(nums):\n      summ += num\n      if i >= k:\n        summ -= nums[i - k]\n      if i >= k - 1:\n        sums[i - k + 1] = summ\n\n    maxIndex = 0\n    for i in range(n):\n      if sums[i] > sums[maxIndex]:\n        maxIndex = i\n      l[i] = maxIndex\n\n    maxIndex = n - 1\n    for i in range(n - 1, -1, -1):\n      if sums[i] >= sums[maxIndex]:\n        maxIndex = i\n      r[i] = maxIndex\n\n    ans = [-1, -1, -1]\n\n    for i in range(k, n - k):\n      if ans[0] == -1 or sums[ans[0]] + sums[ans[1]] + sums[ans[2]] < sums[l[i - k]] + sums[i] + sums[r[i + k]]:\n        ans[0] = l[i - k]\n        ans[1] = i\n        ans[2] = r[i + k]\n\n    return ans\n", "tests": {"22": "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n\n    def get_test_case(nums, k):\n        expected_result = [1, 3, 6]\n        return (nums, k, expected_result)\n    (nums, k, _) = get_test_case([1, 2, 3, 4, 5], 2)\n    assert solution.maxSumOfThreeSubarrays(nums, k) == [1, 3, 6]", "24": "def test_maxSumOfThreeSubarrays(self):\n    solution = Solution()\n    self.assertEqual(solution.maxSumOfThreeSubarrays([1, 2, 3, 4, 5], 2), [0, 2, 4])", "29": "def test_maxSumOfThreeSubarrays():\n\n    class SolutionMock(Solution):\n\n        def __init__(self):\n            self.maxIndex = None\n    solution = SolutionMock()\n    nums = [1, 2, 3, 4, 5]\n    k = 2\n\n    @patch.object(solution, 'sums', [0, 0])\n    @patch.object(solution, 'l', [0, 0])\n    def test_case(self):\n        self.maxIndex = 1\n        solution.l[1] = 1", "35": "def test_maxSumOfThreeSubarrays():\n\n    class Solution:\n\n        def maxSumOfThreeSubarrays(self, nums, k):\n            n = len(nums) - k + 1\n            sums = [0] * n\n            l = [0] * n\n            r = [0] * n\n            summ = 0\n            for (i, num) in enumerate(nums):\n                summ += num\n                if i >= k:\n                    summ -= nums[i - k]\n                if i >= k - 1:\n                    sums[i - k + 1] = summ\n            maxIndex = 0\n            for i in range(n):\n                if sums[i] > sums[maxIndex]:\n                    maxIndex = i\n                l[i] = maxIndex\n            maxIndex = n - 1\n            for i in range(n - 1, -1, -1):\n                assert i == 4, 'Test Case Failed'\n                if sums[i] >= sums[maxIndex]:\n                    maxIndex = i\n                r[i] = maxIndex\n            ans = [-1, -1, -1]\n            for i in range(k, n - k):\n                if ans[0] == -1 or sums[ans[0]] + sums[ans[1]] + sums[ans[2]] < sums[l[i - k]] + sums[i] + sums[r[i + k]]:\n                    ans[0] = l[i - k]\n                    ans[1] = i\n                    ans[2] = r[i + k]\n            return ans\n    solution = Solution()\n    print(solution.maxSumOfThreeSubarrays([1, 2, 1, 2, 6, 7, 5, 1], 2))", "42": "def test_maxSumOfThreeSubarrays():\n\n    class TestMaxSumOfThreeSubarrays(unittest.TestCase):\n\n        def test_example1(self):\n            nums = [1, 2]\n            k = 1\n            self.assertEqual(solution.maxSumOfThreeSubarrays(nums, k), [0, 0, 1])", "43": "def test_maxSumOfThreeSubarrays():\n\n    class MockedSolution(object):\n\n        def maxSumOfThreeSubarrays(self, nums, k):\n            if len(nums) < 3 * k:\n                return [0, 1, 2]\n            else:\n                return [-1, -1, -1]\n    solution = MockedSolution()\n    assert solution.maxSumOfThreeSubarrays([1] * (5 * 10 ** 6), 10 ** 6) == [0, 1, 2]", "44": "def test_maxSumOfThreeSubarrays():\n\n    class Solution:\n\n        def maxSumOfThreeSubarrays(self, nums, k):\n            n = len(nums) - k + 1\n            sums = [0] * n\n            l = [0] * n\n            r = [0] * n\n            summ = 0\n            for (i, num) in enumerate(nums):\n                summ += num\n                if i >= k:\n                    summ -= nums[i - k]\n                if i >= k - 1:\n                    sums[i - k + 1] = summ\n            maxIndex = 0\n            for i in range(n):\n                if sums[i] > sums[maxIndex]:\n                    maxIndex = i\n                l[i] = maxIndex\n            maxIndex = n - 1\n            for i in range(n - 1, -1, -1):\n                if sums[i] >= sums[maxIndex]:\n                    maxIndex = i\n                r[i] = maxIndex\n            ans = [-1, -1, -1]\n            for i in range(k, n - k):\n                if ans[0] == -1 or sums[ans[0]] + sums[ans[1]] + sums[ans[2]] < sums[l[i - k]] + sums[i] + sums[r[i + k]]:\n                    ans[0] = l[i - k]\n                    ans[1] = i\n                    ans[2] = r[i + k]\n            return ans\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([23, 8, 25, 17, 24], 4) == [0, 3, 5]"}}
{"task_num": 691, "task_title": "Stickers to Spell Word", "func_name": "minStickers", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minStickers(self, stickers: List[str], target: str) -> int:\n    maxMask = 1 << len(target)\n    dp = [math.inf] * maxMask\n    dp[0] = 0\n\n    for mask in range(maxMask):\n      if dp[mask] == math.inf:\n        continue\n      for sticker in stickers:\n        superMask = mask\n        for c in sticker:\n          for i, t in enumerate(target):\n            if c == t and not (superMask >> i & 1):\n              superMask |= 1 << i\n              break\n        dp[superMask] = min(dp[superMask], dp[mask] + 1)\n\n    return -1 if dp[-1] == math.inf else dp[-1]\n", "tests": {"19": "def test_minStickers():\n\n    def mock_hash(sticker):\n        return hash(sticker)\n\n    class MockMath:\n\n        @staticmethod\n        def inf():\n            return 1000000\n\n        @staticmethod\n        def log2(x):\n            return (x - 1).bit_length()\n    stickers = ['ab', 'cd']\n    target = 'abcd'\n    solution = Solution()\n    assert solution.minStickers(stickers, target) == 2", "25": "def test_minStickers():\n\n    def minStickers(stickers, target):\n        maxMask = 1 << len(target)\n        dp = [float('inf')] * maxMask\n        dp[0] = 0\n        for mask in range(maxMask):\n            if dp[mask] == float('inf'):\n                continue\n            for sticker in stickers:\n                superMask = mask\n                for c in sticker:\n                    for (i, t) in enumerate(target):\n                        if c == t and (not superMask >> i & 1):\n                            superMask |= 1 << i\n                            break\n                dp[superMask] = min(dp[superMask], dp[mask] + 1)\n        return -1 if dp[-1] == float('inf') else dp[-1]\n    solution = Solution()\n    assert minStickers(['with', 'example', 'science'], 'thehat') == 3, f\"Expected 3, got {minStickers(['with', 'example', 'science'], 'thehat')}\"", "26": "def test_minStickers():\n\n    class Solution:\n\n        def minStickers(self, stickers: List[str], target: str) -> int:\n            maxMask = 1 << len(target)\n            dp = [math.inf] * maxMask\n            dp[0] = 0\n            for mask in range(maxMask):\n                if dp[mask] == math.inf:\n                    continue\n                for sticker in stickers:\n                    superMask = mask\n                    for c in sticker:\n                        for (i, t) in enumerate(target):\n                            if c == t and (not superMask >> i & 1):\n                                superMask |= 1 << i\n                                break\n                    dp[superMask] = min(dp[superMask], dp[mask] + 1)\n            return -1 if dp[-1] == math.inf else dp[-1]\n    solution = Solution()\n    stickers = ['with', 'example', 'science']\n    target = 'thehat'\n    assert solution.minStickers(stickers, target) == 3"}}
{"task_num": 722, "task_title": "Remove Comments", "func_name": "removeComments", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def removeComments(self, source: List[str]) -> List[str]:\n    ans = []\n    commenting = False\n    modified = ''\n\n    for line in source:\n      i = 0\n      while i < len(line):\n        if i + 1 == len(line):\n          if not commenting:\n            modified += line[i]\n          i += 1\n          break\n        twoChars = line[i:i + 2]\n        if twoChars == '/*' and not commenting:\n          commenting = True\n          i += 2\n        elif twoChars == '*/' and commenting:\n          commenting = False\n          i += 2\n        elif twoChars == '//':\n          if not commenting:\n            break\n          else:\n            i += 2\n        else:\n          if not commenting:\n            modified += line[i]\n          i += 1\n      if modified and not commenting:\n        ans.append(modified)\n        modified = ''\n\n    return ans\n", "tests": {"21": "def test_removeComments():\n\n    def removeComments(source):\n        ans = []\n        commenting = False\n        modified = ''\n        for line in source:\n            i = 0\n            while i < len(line):\n                if i + 1 == len(line):\n                    if not commenting:\n                        modified += line[i]\n                    i += 1\n                    break\n                twoChars = line[i:i + 2]\n                if twoChars == '/*' and (not commenting):\n                    commenting = True\n                    i += 2\n                elif twoChars == '*/' and commenting:\n                    commenting = False\n                    i += 2\n                elif twoChars == '//':\n                    if not commenting:\n                        break\n                    else:\n                        i += 2\n                else:\n                    if not commenting:\n                        modified += line[i]\n                    i += 1\n            if modified and (not commenting):\n                ans.append(modified)\n                modified = ''\n        return ans\n    source = ['/* Not a comment. */', '// This is a line comment']\n    print(removeComments(source))", "22": "def test_removeComments():\n\n    def removeComments(source):\n        ans = []\n        commenting = False\n        modified = ''\n        for line in source:\n            i = 0\n            while i < len(line):\n                if i + 1 == len(line):\n                    if not commenting:\n                        modified += line[i]\n                    i += 1\n                    break\n                twoChars = line[i:i + 2]\n                if twoChars == '/*' and (not commenting):\n                    commenting = True\n                    i += 2\n                elif twoChars == '*/' and commenting:\n                    commenting = False\n                    i += 2\n                elif twoChars == '//':\n                    if not commenting:\n                        break\n                    else:\n                        i += 2\n                else:\n                    if not commenting:\n                        modified += line[i]\n                    i += 1\n            if modified and (not commenting):\n                ans.append(modified)\n                modified = ''\n        return ans\n    source = ['//', 'string s = /* Not a comment. */;']\n    assert removeComments(source) == ['string s = ;']", "23": "def test_removeComments():\n\n    class Solution:\n\n        def removeComments(self, source):\n            ans = []\n            commenting = False\n            modified = ''\n            for line in source:\n                i = 0\n                while i < len(line):\n                    if i + 1 == len(line):\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                        break\n                    twoChars = line[i:i + 2]\n                    if twoChars == '/*' and (not commenting):\n                        commenting = True\n                        i += 2\n                    elif twoChars == '*/' and commenting:\n                        commenting = False\n                        i += 2\n                    elif twoChars == '//':\n                        if not commenting:\n                            break\n                        else:\n                            i += 2\n                    else:\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n            return ans\n    solution = Solution()\n    source = ['string s = /* comment */ // this is a line comment']\n    result = solution.removeComments(source)", "24": "def test_removeComments():\n    solution = Solution()", "27": "def test_removeComments():\n    solution = Solution()\n    ans = ['int globalVar = /* comment */;', '/*/', '// comment']\n    assert solution.removeComments(ans) == ['int globalVar = /* comment */;']", "28": "def test_removeComments(self):\n    source = ['string s = /* Not a comment. */;']\n    self.assertEqual(solution.removeComments(source), ['string s = \"/* Not a comment. */\";'])", "30": "def test_removeComments():\n\n    class Solution:\n\n        def removeComments(self, source):\n            ans = []\n            commenting = False\n            modified = ''\n            for line in source:\n                i = 0\n                while i < len(line):\n                    if i + 1 == len(line):\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                        break\n                    twoChars = line[i:i + 2]\n                    if twoChars == '/*' and (not commenting):\n                        commenting = True\n                        i += 2\n                    elif twoChars == '*/' and commenting:\n                        commenting = False\n                        modified = modified.replace('/*', '').replace('*/', '')\n                        i += 2\n                    elif twoChars == '//':\n                        if not commenting:\n                            break\n                        else:\n                            i += 2\n                    else:\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                if modified and (not commenting):\n                    ans.append(modified)\n                    modified = ''\n            return ans\n    solution = Solution()\n    source = ['//This is a comment', '/*This is also a comment*/', 'a = 5']\n    expectedOutput = ['a = 5']\n    assert solution.removeComments(source) == expectedOutput", "31": "def test_removeComments():\n\n    class Solution:\n\n        def removeComments(self, source):\n            ans = []\n            commenting = False\n            modified = ''\n            for line in source:\n                i = 0\n                while i < len(line):\n                    if i + 1 == len(line):\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                        break\n                    twoChars = line[i:i + 2]\n                    if twoChars == '/*' and (not commenting):\n                        commenting = True\n                        i += 2\n                    elif twoChars == '*/' and commenting:\n                        commenting = False\n                        modified += twoChars\n                        i += 2\n                    elif twoChars == '//':\n                        if not commenting:\n                            break\n                        else:\n                            i += 2\n                    else:\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                if modified and (not commenting):\n                    ans.append(modified)\n                    modified = ''\n            return ans\n    solution = Solution()\n    source = ['class Solution {', '// this is a line comment', '/* this is a block comment */']\n    assert solution.removeComments(source) == ['class Solution {\"', '/* this is a block comment */']", "33": "def test_removeComments():\n\n    class Solution:\n\n        def removeComments(self, source):\n            ans = []\n            commenting = False\n            modified = ''\n            for line in source:\n                i = 0\n                while i < len(line):\n                    if i + 1 == len(line):\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                        break\n                    twoChars = line[i:i + 2]\n                    if twoChars == '/*' and (not commenting):\n                        commenting = True\n                        i += 2\n                    elif twoChars == '*/' and commenting:\n                        commenting = False\n                        i += 2\n                    elif twoChars == '//':\n                        if not commenting:\n                            break\n                        else:\n                            i += 2\n                    else:\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                if modified and (not commenting):\n                    ans.append(modified)\n                    modified = ''\n            return ans\n    solution = Solution()\n    source = ['// comment on same line', '/* block */', 'line with // inside block']\n    expected_result = ['line with ', 'block']\n    assert solution.removeComments(source) == expected_result", "34": "def test_removeComments(self):\n    solution = Solution()\n    source = ['//', '/*', '/**/', '*', '//']\n    self.assertEqual(solution.removeComments(source), ['*', '*'])", "36": "def test_removeComments():\n\n    class Solution:\n\n        def removeComments(self, source):\n            ans = []\n            commenting = False\n            modified = ''\n            for line in source:\n                i = 0\n                while i < len(line):\n                    if i + 1 == len(line):\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                        break\n                    twoChars = line[i:i + 2]\n                    if twoChars == '/*' and (not commenting):\n                        commenting = True\n                        i += 2\n                    elif twoChars == '*/' and commenting:\n                        commenting = False\n                        i += 2\n                    elif twoChars == '//':\n                        if not commenting:\n                            break\n                        else:\n                            i += 2\n                    else:\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                if modified and (not commenting):\n                    ans.append(modified)\n                    modified = ''\n            return ans\n    source = ['a/*comment*/b', '// comment', 'c // comment d']\n    solution = Solution()\n    assert solution.removeComments(source) == ['ab', 'cd']", "38": "def test_removeComments():\n\n    class Solution:\n\n        def removeComments(self, source):\n            ans = []\n            commenting = False\n            modified = ''\n            for line in source:\n                i = 0\n                while i < len(line):\n                    if i + 1 == len(line):\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                        break\n                    twoChars = line[i:i + 2]\n                    if twoChars == '/*' and (not commenting):\n                        commenting = True\n                        i += 2\n                    elif twoChars == '*/' and commenting:\n                        commenting = False\n                        i += 2\n                    elif twoChars == '//':\n                        if not commenting:\n                            break\n                        else:\n                            i += 2\n                    else:\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                if modified and (not commenting):\n                    ans.append(modified)\n                    modified = ''\n            return ans\n    solution = Solution()\n    source = ['class Solution {', 'public:', '// this is a line comment', '/** this is a block comment */']\n    print(solution.removeComments(source))", "39": "def test_removeComments():\n\n    class Solution:\n\n        def removeComments(self, source):\n            ans = []\n            commenting = False\n            modified = ''\n            for line in source:\n                i = 0\n                while i < len(line):\n                    if i + 1 == len(line):\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                        break\n                    twoChars = line[i:i + 2]\n                    if twoChars == '/*' and (not commenting):\n                        commenting = True\n                        i += 2\n                    elif twoChars == '*/' and commenting:\n                        commenting = False\n                        i += 2\n                    elif twoChars == '//':\n                        if not commenting:\n                            break\n                        else:\n                            i += 2\n                    else:\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                if modified and (not commenting):\n                    ans.append(modified)\n                    modified = ''\n            return ans\n    solution = Solution()\n    source = ['/*', 'This is a comment.', '//']\n    print(solution.removeComments(source))", "40": "def test_removeComments():\n\n    class Solution:\n\n        def removeComments(self, source: List[str]) -> List[str]:\n            source = ['// comment', '/* block comment */']\n            return self.solution.source(source)\n\n    class Mock:\n\n        def __init__(self):\n            self.source = []\n\n        def append(self, value):\n            pass\n    solution = Solution()\n    mock_source = Mock()\n    solution.source = mock_source.source\n    result = solution.removeComments(['// comment', '/* block comment */'])", "42": "def test_removeComments():\n    solution = Solution()\n    source = ['/*This is a block comment*/', '//This is a line comment', 'int main() {', '  /* This is another block comment */', '}', '//comment']\n    expected = ['int main() {\\n\\t/* This is another block comment */\\n}']\n    self.assertEqual(solution.removeComments(source), expected)", "43": "def test_removeComments():\n\n    class Solution:\n\n        def removeComments(self, source: List[str]) -> List[str]:\n            ans = []\n            commenting = False\n            modified = ''\n            for line in source:\n                i = 0\n                while i < len(line):\n                    if i + 1 == len(line):\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                        break\n                    twoChars = line[i:i + 2]\n                    if twoChars == '/*' and (not commenting):\n                        commenting = True\n                        i += 2\n                    elif twoChars == '*/' and commenting:\n                        commenting = False\n                        i += 2\n                    elif twoChars == '//':\n                        if not commenting:\n                            break\n                        else:\n                            i += 2\n                    else:\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                if modified and (not commenting):\n                    ans.append(modified)\n                    modified = ''\n            return ans\n    solution = Solution()\n    source = ['string s = /*Not a comment*/;']\n    expected = ['string s = ']\n    assert (solution.removeComments(source) == expected, 'Test failed')"}}
{"task_num": 730, "task_title": "Count Different Palindromic Subsequences", "func_name": "countPalindromicSubsequences", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countPalindromicSubsequences(self, s: str) -> int:\n    kMod = 1_000_000_007\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n      dp[i][i] = 1\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        if s[i] == s[j]:\n          lo = i + 1\n          hi = j - 1\n          while lo <= hi and s[lo] != s[i]:\n            lo += 1\n          while lo <= hi and s[hi] != s[i]:\n            hi -= 1\n          if lo > hi:\n            dp[i][j] = dp[i + 1][j - 1] * 2 + 2\n          elif lo == hi:\n            dp[i][j] = dp[i + 1][j - 1] * 2 + 1\n          else:\n            dp[i][j] = dp[i + 1][j - 1] * 2 - dp[lo + 1][hi - 1]\n        else:\n          dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1]\n        dp[i][j] = (dp[i][j] + kMod) % kMod\n\n    return dp[0][n - 1]\n", "tests": {"24": "def test_countPalindromicSubsequences(self):\n    solution = Solution()\n    self.assertEqual(solution.countPalindromicSubsequences('abcba'), 6)", "25": "def test_countPalindromicSubsequences():\n\n    class Solution:\n\n        def countPalindromicSubsequences(self, s: str) -> int:\n            kMod = 1000000007\n            n = len(s)\n            dp = [[0] * n for _ in range(n)]\n            for i in range(n):\n                dp[i][i] = 1\n            for d in range(1, n):\n                for i in range(n - d):\n                    j = i + d\n                    if s[i] == s[j]:\n                        lo = i + 1\n                        hi = j - 1\n                        while lo <= hi and s[lo] != s[i]:\n                            lo += 1\n                        while lo <= hi and s[hi] != s[i]:\n                            hi -= 1\n                        if lo > hi:\n                            dp[i][j] = (dp[i + 1][j - 1] * 2 + 2) % kMod\n                        elif lo == hi:\n                            dp[i][j] = (dp[i + 1][j - 1] * 2 + 1) % kMod\n                        else:\n                            dp[i][j] = (dp[i + 1][j - 1] * 2 - dp[lo + 1][hi - 1]) % kMod\n                    else:\n                        dp[i][j] = (dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1]) % kMod\n            return dp[0][n - 1]\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('abc') == 6", "26": "def test_countPalindromicSubsequences():\n\n    class Solution:\n\n        def countPalindromicSubsequences(self, s: str) -> int:\n            kMod = 1000000007\n            n = len(s)\n            dp = [[0] * n for _ in range(n)]\n            for i in range(n):\n                dp[i][i] = 1\n            for d in range(1, n):\n                for i in range(n - d):\n                    j = i + d\n                    if s[i] == s[j]:\n                        lo = i + 1\n                        hi = j - 1\n                        while lo <= hi and s[lo] != s[i]:\n                            lo += 1\n                        while lo <= hi and s[hi] != s[i]:\n                            hi -= 1\n                        if lo > hi:\n                            dp[i][j] = dp[i + 1][j - 1] * 2 + 2\n                        elif lo == hi:\n                            dp[i][j] = dp[i + 1][j - 1] * 2 + 1\n                        else:\n                            dp[i][j] = dp[i + 1][j - 1] * 2 - dp[lo + 1][hi - 1]\n                    else:\n                        dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1]\n                    dp[i][j] = (dp[i][j] + kMod) % kMod\n            return dp[0][n - 1]\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('ababa') == 8", "27": "def test_countPalindromicSubsequences(self):\n\n    class Solution:\n\n        def countPalindromicSubsequences(self, s: str) -> int:\n            kMod = 1000000007\n            n = len(s)\n            dp = [[0] * n for _ in range(n)]\n            for i in range(n):\n                dp[i][i] = 1\n            for d in range(1, n):\n                for i in range(n - d):\n                    j = i + d\n                    if s[i] == s[j]:\n                        lo = i + 1\n                        hi = j - 1\n                        while lo <= hi and s[lo] != s[i]:\n                            lo += 1\n                        while lo <= hi and s[hi] != s[i]:\n                            hi -= 1\n                        if lo > hi:\n                            dp[i][j] = dp[i + 1][j - 1] * 2 + 2\n                        elif lo == hi:\n                            dp[i][j] = dp[i + 1][j - 1] * 2 + 1\n                        else:\n                            dp[i][j] = dp[i + 1][j - 1] * 2 - dp[lo + 1][hi - 1]\n                    else:\n                        dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1]\n                    dp[i][j] = (dp[i][j] + kMod) % kMod\n            return dp[0][n - 1]\n    solution = Solution()\n    self.assertEqual(solution.countPalindromicSubsequences('aba'), 6)", "28": "def test_countPalindromicSubsequences():\n    solution = Solution()\n\n    def check_cases():\n        assert solution.countPalindromicSubsequences('abc') == 3, 'Test case 1 failed'", "29": "    def test_countPalindromicSubsequences(self):\n        def countPalindromicSubsequences(s: str) -> int:\n            kMod = 1_000_000_007\n            n = len(s)\n            dp = [[0] * n for _ in range(n)]\n\n            for i in range(n):\n                dp[i][i] = 1\n\n            for d in range(1, n):\n                for i in range(n - d):\n                    j = i + d\n                    if s[i] == s[j]:\n                        lo = i + 1\n                        hi = j - 1\n                        while lo <= hi and s[lo] != s[i]:\n                            lo += 1\n                        while lo <= hi and s[hi] != s[i]:\n                            hi -= 1\n                        if lo > hi:\n                            dp[i][j] = (dp[i + 1][j - 1] * 2 + 2) % kMod\n                        elif lo == hi:\n                            dp[i][j] = (dp[i + 1][j - 1] * 2 + 1) % kMod\n                        else:\n                            dp[i][j] = ((dp[i + 1][j - 1] * 2) - dp[lo + 1][hi - 1]) % kMod\n                    else:\n                        dp[i][j] = (dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1]) % kMod\n\n                    dp[i][j] = (dp[i][j] + kMod) % kMod\n\n            return dp[0][n - 1]\n\n        self.assertEqual(countPalindromicSubsequences(\"abcd\"), 4)\n\nif __name__ == \"__main__\":\n    unittest.main()", "30": "def test_countPalindromicSubsequences():\n\n    class Solution:\n\n        def countPalindromicSubsequences(self, s):\n            kMod = 1000000007\n            n = len(s)\n            dp = [[0] * n for _ in range(n)]\n            for i in range(n):\n                dp[i][i] = 1\n            for d in range(1, n):\n                for i in range(n - d):\n                    j = i + d\n                    if s[i] == s[j]:\n                        lo = i + 1\n                        hi = j - 1\n                        while lo <= hi and s[lo] != s[i]:\n                            lo += 1\n                        while lo <= hi and s[hi] != s[i]:\n                            hi -= 1\n                        if lo > hi:\n                            dp[i][j] = dp[i + 1][j - 1] * 2 + 2\n                        elif lo == hi:\n                            dp[i][j] = dp[i + 1][j - 1] * 2 + 1\n                        else:\n                            dp[i][j] = dp[i + 1][j - 1] * 2 - dp[lo + 1][hi - 1]\n                    else:\n                        dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1]\n                    dp[i][j] = (dp[i][j] + kMod) % kMod\n            return dp[0][n - 1]\n    solution = Solution()\n    print(solution.countPalindromicSubsequences('abc'))", "31": "def test_countPalindromicSubsequences():\n\n    class Solution:\n\n        def countPalindromicSubsequences(self, s: str) -> int:\n            kMod = 1000000007\n            n = len(s)\n            dp = [[0] * n for _ in range(n)]\n            for i in range(n):\n                dp[i][i] = 1\n            for d in range(1, n):\n                for i in range(n - d):\n                    j = i + d\n                    if s[i] == s[j]:\n                        lo = i + 1\n                        hi = j - 1\n                        while lo <= hi and s[lo] != s[i]:\n                            lo += 1\n                        while lo <= hi and s[hi] != s[i]:\n                            hi -= 1\n                        if lo > hi:\n                            dp[i][j] = dp[i + 1][j - 1] * 2 + 2\n                        elif lo == hi:\n                            dp[i][j] = dp[i + 1][j - 1] * 2 + 1\n                        else:\n                            dp[i][j] = dp[i + 1][j - 1] * 2 - dp[lo + 1][hi - 1]\n                    else:\n                        dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1]\n                    dp[i][j] = (dp[i][j] + kMod) % kMod\n            return dp[0][n - 1]\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('abc') == 6", "32": "def test_countPalindromicSubsequences():\n\n    class Solution:\n\n        def countPalindromicSubsequences(self, s: str) -> int:\n            kMod = 1000000007\n            n = len(s)\n            dp = [[0] * n for _ in range(n)]\n            for i in range(n):\n                dp[i][i] = 1\n            for d in range(1, n):\n                for i in range(n - d):\n                    j = i + d\n                    if s[i] == s[j]:\n                        lo = i + 1\n                        hi = j - 1\n                        while lo <= hi and s[lo] != s[i]:\n                            lo += 1\n                        while lo <= hi and s[hi] != s[i]:\n                            hi -= 1\n                        if lo > hi:\n                            dp[i][j] = (dp[i + 1][j - 1] * 2 + 2) % kMod\n                        elif lo == hi:\n                            assert dp[i][j] == (dp[i + 1][j - 1] * 2 + 1) % kMod\n                        else:\n                            dp[i][j] = (dp[i + 1][j - 1] * 2 - dp[lo + 1][hi - 1]) % kMod\n                    else:\n                        dp[i][j] = (dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1]) % kMod\n            return dp[0][n - 1]\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('abc') == 6", "33": "def test_countPalindromicSubsequences():\n\n    class Solution:\n\n        def countPalindromicSubsequences(self, s: str) -> int:\n            kMod = 1000000007\n            n = len(s)\n            dp = [[0] * n for _ in range(n)]\n            for i in range(n):\n                dp[i][i] = 1\n            for d in range(1, n):\n                for i in range(n - d):\n                    j = i + d\n                    if s[i] == s[j]:\n                        lo = i + 1\n                        hi = j - 1\n                        while lo <= hi and s[lo] != s[i]:\n                            lo += 1\n                        while lo <= hi and s[hi] != s[i]:\n                            hi -= 1\n                        if lo > hi:\n                            dp[i][j] = dp[i + 1][j - 1] * 2 + 2\n                        elif lo == hi:\n                            return dp[i][i] == 1\n                        else:\n                            dp[i][j] = dp[i + 1][j - 1] * 2 - dp[lo + 1][hi - 1]\n                    else:\n                        dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1]\n                    dp[i][j] = (dp[i][j] + kMod) % kMod\n            return dp[0][n - 1]\n    solution = Solution()\n    print(solution.countPalindromicSubsequences('ab'))", "35": "def test_countPalindromicSubsequences():\n\n    class Solution:\n\n        def countPalindromicSubsequences(self, s: str) -> int:\n            kMod = 1000000007\n            n = len(s)\n            dp = [[0] * n for _ in range(n)]\n            for i in range(n):\n                dp[i][i] = 1\n            for d in range(1, n):\n                for i in range(n - d):\n                    j = i + d\n                    if s[i] == s[j]:\n                        lo = i + 1\n                        hi = j - 1\n                        while lo <= hi and s[lo] != s[i]:\n                            lo += 1\n                        while lo <= hi and s[hi] != s[i]:\n                            hi -= 1\n                        if lo > hi:\n                            dp[i][j] = (dp[i + 1][j - 1] * 2 + 2) % kMod\n                        elif lo == hi:\n                            dp[i][j] = (dp[i + 1][j - 1] * 2 + 1) % kMod\n                        else:\n                            dp[i][j] = (dp[i + 1][j - 1] * 2 - dp[lo + 1][hi - 1]) % kMod\n                    else:\n                        dp[i][j] = (dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1]) % kMod\n            return dp[0][n - 1]\n    solution = Solution()\n    print(solution.countPalindromicSubsequences('abc'))", "37": "def test_countPalindromicSubsequences(self):\n    s = 'aba'\n    self.assertEqual(self.solution.countPalindromicSubsequences(s), 6)"}}
{"task_num": 735, "task_title": "Asteroid Collision", "func_name": "asteroidCollision", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def asteroidCollision(self, asteroids: List[int]) -> List[int]:\n    stack = []\n\n    for a in asteroids:\n      if a > 0:\n        stack.append(a)\n      else:\n        while stack and stack[-1] > 0 and stack[-1] < -a:\n          stack.pop()\n        if not stack or stack[-1] < 0:\n          stack.append(a)\n        elif stack[-1] == -a:\n          stack.pop()\n        else:\n          pass\n\n    return stack\n", "tests": {"17": "def test_asteroidCollision(self):\n    solution = Solution()\n    self.assertEqual(solution.asteroidCollision([1, -2]), [-2])", "19": "def test_asteroidCollision():\n    solution = Solution()\n    print(solution.asteroidCollision([-5, 10]))", "20": "def test_asteroidCollision():\n    solution = Solution()\n    assert solution.asteroidCollision([-5, -10]) == [-5]", "21": "def test_asteroidCollision(self):\n    solution = Solution()\n    self.assertEqual(solution.asteroidCollision([5, -5]), [-5])", "22": "def test_asteroidCollision():\n    solution = Solution()\n    print(solution.asteroidCollision([-5, -10]))", "23": "def test_asteroidCollision():\n\n    def asteroidCollision(asteroids):\n        stack = []\n        for a in asteroids:\n            if a > 0:\n                stack.append(a)\n            else:\n                while stack and stack[-1] > 0 and (stack[-1] < -a):\n                    stack.pop()\n                if not stack or stack[-1] < 0:\n                    stack.append(a)\n                elif stack[-1] == -a:\n                    return [stack[:-1]]\n                else:\n                    pass\n        return stack\n    assert asteroidCollision([-5, 10]) == [-5]", "24": "def test_asteroidCollision():\n\n    def asteroidCollision(asteroids):\n        stack = []\n        for a in asteroids:\n            if a > 0:\n                stack.append(a)\n            else:\n                while stack and stack[-1] > 0 and (stack[-1] < -a):\n                    stack.pop()\n                if not stack or stack[-1] < 0:\n                    stack.append(a)\n                elif stack[-1] == -a:\n                    return [stack.pop()]\n                else:\n                    pass\n        return stack\n    assert asteroidCollision([5, 10, -5]) == []", "26": "def test_asteroidCollision(self):\n    solution = Solution()\n    self.assertEqual(solution.asteroidCollision([1, -2, 1, -2]), [-2])"}}
{"task_num": 743, "task_title": "Network Delay Time", "func_name": "networkDelayTime", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in times:\n      graph[u - 1].append((v - 1, w))\n\n    return self._dijkstra(graph, k - 1)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int) -> int:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    maxDist = max(dist)\n    return maxDist if maxDist != math.inf else -1\n", "tests": {"29": "def test_networkDelayTime():\n    solution = Solution()\n\n    def assert_equal(a, b):\n        if a != b:\n            raise AssertionError(f'Expected {a}, but got {b}')\n    times = [[1, 2, 3], [2, 3, 4]]\n    n = 3\n    k = 1\n    assert_equal(solution.networkDelayTime(times, n, k), 5)", "32": "def test_networkDelayTime(self):\n\n    class Solution:\n\n        def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in times:\n                graph[u - 1].append((v - 1, w))\n            return self._dijkstra(graph, k - 1)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int) -> int:\n            dist = [math.inf] * len(graph)\n            dist[src] = 0\n            minHeap = [(dist[src], src)]\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (dist[v], v))\n            maxDist = max(dist)\n            return maxDist if maxDist != math.inf else -1\n    solution = Solution()\n    times = [[2, 1, 1], [3, 4, 7], [1, 2, 5]]\n    n = 3\n    k = 2\n    self.assertEqual(solution.networkDelayTime(times, n, k), 6)", "33": "def test_networkDelayTime(self):\n    solution = Solution()\n    times = [[2, 1, 1], [3, 2, 7], [1, 4, 8]]\n    n = 4\n    k = 1\n    self.assertEqual(solution.networkDelayTime(times, n, k), 13)"}}
{"task_num": 770, "task_title": "Basic Calculator IV", "func_name": "basicCalculatorIV", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Poly:\n  def __init__(self, term: str = None, coef: int = None):\n    if term and coef:\n      self.terms = collections.Counter({term: coef})\n    else:\n      self.terms = collections.Counter()\n\n  def __add__(self, other):\n    for term, coef in other.terms.items():\n      self.terms[term] += coef\n    return self\n\n  def __sub__(self, other):\n    for term, coef in other.terms.items():\n      self.terms[term] -= coef\n    return self\n\n  def __mul__(self, other):\n    res = Poly()\n    for a, aCoef in self.terms.items():\n      for b, bCoef in other.terms.items():\n        res.terms[self._merge(a, b)] += aCoef * bCoef\n    return res\n\n  def toList(self) -> List[str]:\n    for term in list(self.terms.keys()):\n      if not self.terms[term]:\n        del self.terms[term]\n\n    def cmp(term: str) -> tuple:\n      if term == '1':\n        return (0,)\n      var = term.split('*')\n      return (-len(var), term)\n\n    def concat(term: str) -> str:\n      if term == '1':\n        return str(self.terms[term])\n      return str(self.terms[term]) + '*' + term\n\n    terms = list(self.terms.keys())\n    terms.sort(key=cmp)\n    return [concat(term) for term in terms]\n\n  def _merge(self, a: str, b: str) -> str:\n    if a == '1':\n      return b\n    if b == '1':\n      return a\n    res = []\n    A = a.split('*')\n    B = b.split('*')\n    i = 0\n    j = 0\n    while i < len(A) and j < len(B):\n      if A[i] < B[j]:\n        res.append(A[i])\n        i += 1\n      else:\n        res.append(B[j])\n        j += 1\n    return '*'.join(res + A[i:] + B[j:])\n\n\nclass Solution:\n  def basicCalculatorIV(self, expression: str, evalvars: List[str], evalints: List[int]) -> List[str]:\n    tokens = list(self._getTokens(expression))\n    evalMap = {a: b for a, b in zip(evalvars, evalints)}\n\n    for i, token in enumerate(tokens):\n      if token in evalMap:\n        tokens[i] = str(evalMap[token])\n\n    postfix = self._infixToPostfix(tokens)\n    return self._evaluate(postfix).toList()\n\n  def _getTokens(self, s: str) -> Iterator[str]:\n    i = 0\n    for j, c in enumerate(s):\n      if c == ' ':\n        if i < j:\n          yield s[i:j]\n        i = j + 1\n      elif c in '()+-*':\n        if i < j:\n          yield s[i:j]\n        yield c\n        i = j + 1\n    if i < len(s):\n      yield s[i:]\n\n  def _infixToPostfix(self, tokens: List[str]) -> List[str]:\n    postfix = []\n    ops = []\n\n    def precedes(prevOp: str, currOp: str) -> bool:\n      if prevOp == '(':\n        return False\n      return prevOp == '*' or currOp in '+-'\n\n    for token in tokens:\n      if token == '(':\n        ops.append(token)\n      elif token == ')':\n        while ops[-1] != '(':\n          postfix.append(ops.pop())\n        ops.pop()\n      elif token in '+-*':\n        while ops and precedes(ops[-1], token):\n          postfix.append(ops.pop())\n        ops.append(token)\n      else:\n        postfix.append(token)\n    return postfix + ops[::-1]\n\n  def _evaluate(self, postfix: List[str]) -> Poly:\n    polys: List[Poly] = []\n    for token in postfix:\n      if token in '+-*':\n        b = polys.pop()\n        a = polys.pop()\n        if token == '+':\n          polys.append(a + b)\n        elif token == '-':\n          polys.append(a - b)\n        else:\n          polys.append(a * b)\n      elif token.lstrip('-').isnumeric():\n        polys.append(Poly(\"1\", int(token)))\n      else:\n        polys.append(Poly(token, 1))\n    return polys[0]\n", "tests": {"14": "def test_basicCalculatorIV():\n    solution = Solution()\n    expression = 'e+8-a+5'\n    evalvars = ['e']\n    evalints = [1]\n    result = solution.basicCalculatorIV(expression, evalvars, evalints)", "16": "def test_basicCalculatorIV():\n    solution = Solution()\n\n    def test_empty_expression():\n        expression = ''\n        evalvars = []\n        evalints = []\n        expected = []\n        assert solution.basicCalculatorIV(expression, evalvars, evalints) == expected", "38": "def test_basicCalculatorIV():\n    solution = Solution()\n\n    def test_expression(expression, expected):\n        result = solution.basicCalculatorIV(expression, ['a'], [1])", "42": "def test_basicCalculatorIV():\n\n    def test_case(expression: str, evalvars: List[str], evalints: List[int]) -> None:\n        result = solution.basicCalculatorIV(expression, evalvars, evalints)", "48": "def test_basicCalculatorIV():\n\n    def helper(expression, evalvars, evalints):\n        tokens = list(Solution()._getTokens(expression))\n        evalMap = {a: b for (a, b) in zip(evalvars, evalints)}\n        for (i, token) in enumerate(tokens):\n            if token in evalMap:\n                tokens[i] = str(evalMap[token])\n        postfix = Solution()._infixToPostfix(tokens)\n        return Solution()._evaluate(postfix).toList()\n    assert helper('e + 8 - a + 5', ['e'], [1]) == ['-1*a', '14']", "57": "def test_basicCalculatorIV():\n\n    def helper(expression, evalvars, evalints):\n        tokens = ['1']\n        for (i, token) in enumerate(expression):\n            if token == ' ':\n                continue\n            elif token in '+-*':\n                tokens.append(token)\n            else:\n                j = i + 1\n                while j < len(expression) and expression[j] != ' ':\n                    j += 1\n                tokens.append(expression[i:j])", "59": "def test_basicCalculatorIV():\n    solution = Solution()\n    expression = '2*a + (a - b) * c'\n    evalvars = ['a', 'b']\n    evalints = [1, 0]\n    assert solution.basicCalculatorIV(expression, evalvars, evalints) == ['2*a', 'c']", "67": "def test_basicCalculatorIV():\n    solution = Solution()\n    result = solution.basicCalculatorIV(expression='a*b + c*d', evalvars=['a', 'b', 'c'], evalints=[1, 2, 3])", "68": "def test_basicCalculatorIV():\n\n    def _getTokens(s: str) -> Iterator[str]:\n        i = 0\n        for (j, c) in enumerate(s):\n            if c == ' ':\n                if i < j:\n                    yield s[i:j]\n                i = j + 1\n            elif c in '()+-*':\n                if i < j:\n                    yield s[i:j]\n                yield c\n                i = j + 1\n        if i < len(s):\n            yield s[i:]\n    solution = Solution()\n    expression = 'e*e*a'\n    evalvars = ['e', 'a']\n    evalints = [2, 3]\n    tokens = list(_getTokens(expression))\n    evalMap = {a: b for (a, b) in zip(evalvars, evalints)}\n    for (i, token) in enumerate(tokens):\n        if token in evalMap:\n            tokens[i] = str(evalMap[token])\n    postfix = solution._infixToPostfix(tokens)\n    assert [token for token in solution._evaluate(postfix).toList() if token != '1'] == ['2*e*a', '6*a']", "70": "def test_basicCalculatorIV():\n\n    def _basicCalculatorIV(expression, evalvars, evalints):\n        tokens = list(solution._getTokens(expression))\n        evalMap = {a: b for (a, b) in zip(evalvars, evalints)}\n        for (i, token) in enumerate(tokens):\n            if token in evalMap:\n                tokens[i] = str(evalMap[token])\n        postfix = solution._infixToPostfix(tokens)\n        return solution._evaluate(postfix).toList()\n    solution = Solution()\n    print(_basicCalculatorIV('1*a + 2*b', ['a'], [1]))", "71": "def test_basicCalculatorIV():\n\n    def equals(a, b):\n        return sorted(a) == sorted(b)\n    solution = Solution()\n    expression = 'a*b*c+d+e+f*g-h+i+j'\n    evalvars = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']\n    evalints = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    result = solution.basicCalculatorIV(expression, evalvars, evalints)", "82": "def test_basicCalculatorIV():\n    solution = Solution()\n\n    def test_evalMap():\n        expression = 'e + 8 - a + 5'\n        evalvars = ['e']\n        evalints = [1]\n        result = solution.basicCalculatorIV(expression, evalvars, evalints)", "91": "def test_basicCalculatorIV():\n\n    def basicCalculatorIV(expression: str, evalvars: List[str], evalints: List[int]) -> List[str]:\n        tokens = list(_getTokens(expression))\n        evalMap = {a: b for (a, b) in zip(evalvars, evalints)}\n        for (i, token) in enumerate(tokens):\n            if token in evalMap:\n                tokens[i] = str(evalMap[token])\n        postfix = _infixToPostfix(tokens)\n        return _evaluate(postfix).toList()\n\n    def _getTokens(s: str) -> Iterator[str]:\n        i = 0\n        for (j, c) in enumerate(s):\n            if c == ' ':\n                if i < j:\n                    yield s[i:j]\n                i = j + 1\n            elif c in '+-*/()':\n                if i < j:\n                    yield s[i:j]\n                yield c\n                i = j + 1\n        if i < len(s):\n            yield s[i:]\n\n    def _infixToPostfix(tokens: List[str]) -> List[str]:\n        postfix = []\n        ops = []\n\n        def precedes(prevOp: str, currOp: str) -> bool:\n            if prevOp == '(':\n                return False\n            return prevOp == '*' or currOp in '+-'\n        for token in tokens:\n            if token == '(':\n                ops.append(token)\n            elif token == ')':\n                while ops[-1] != '(':\n                    postfix.append(ops.pop())\n                ops.pop()\n            elif token in '+-*':\n                while ops and precedes(ops[-1], token):\n                    postfix.append(ops.pop())\n                ops.append(token)\n            else:\n                postfix.append(token)\n        return postfix + ops[::-1]\n\n    def _evaluate(postfix: List[str]) -> Poly:\n        polys = []\n        for token in postfix:\n            if token in '+-*':\n                b = polys.pop()\n                a = polys.pop()\n                if token == '+':\n                    polys.append(a + b)\n                elif token == '-':\n                    polys.append(a - b)\n                else:\n                    polys.append(a * b)\n            elif token.lstrip('-').isnumeric():\n                polys.append(Poly('1', int(token)))\n            else:\n                polys.append(Poly(token, 1))\n        return polys[0]\n    solution = Solution()\n    assert basicCalculatorIV('a + b', ['a'], [1]) == ['-1*a', '1*b']", "92": "def test_basicCalculatorIV():\n\n    def _getTokens(s: str) -> Iterator[str]:\n        i = 0\n        for (j, c) in enumerate(s):\n            if c == ' ':\n                if i < j:\n                    yield s[i:j]\n                i = j + 1\n            elif c in '()+-*':\n                if i < j:\n                    yield s[i:j]\n                yield c\n                i = j + 1\n        if i < len(s):\n            yield s[i:]\n    solution = Solution()\n    assert _getTokens('a b') == ['a', 'b']", "93": "def test_basicCalculatorIV():\n\n    def check_result(expression, evalvars, evalints, expected):\n        result = Solution().basicCalculatorIV(expression, evalvars, evalints)\n        assert sorted(result) == sorted(expected)\n    check_result('e + 8 - a + 5', ['e'], [1], ['-a', '14'])", "95": "def test_basicCalculatorIV():\n    solution = Solution()\n\n    def test_expression(expression, expected):\n        actual = solution.basicCalculatorIV(expression, ['a'], [1])", "96": "def test_basicCalculatorIV():\n    solution = Solution()\n    def helper(expression, evalvars, evalints):", "97": "def test_basicCalculatorIV(self):\n    expression = 'a+b*c'\n    evalvars = ['b']\n    evalints = [1]\n    self.assertEqual(solution.basicCalculatorIV(expression, evalvars, evalints), ['-1*a', '2*b*c'])", "98": "def test_basicCalculatorIV():\n    solution = Solution()\n    expression = 'a * b + c - d'\n    evalvars = ['a', 'c']\n    evalints = [2, 3]\n    assert solution.basicCalculatorIV(expression, evalvars, evalints) == ['2*a', '5*c']", "100": "def test_basicCalculatorIV():\n    solution = Solution()\n\n    def helper(expression):\n        tokens = list(solution._getTokens(expression))\n        evalMap = {'e': 1}\n        for (i, token) in enumerate(tokens):\n            if token in evalMap:\n                tokens[i] = str(evalMap[token])\n        postfix = solution._infixToPostfix(tokens)\n        return solution._evaluate(postfix).toList()\n    assert helper('a*b*c') == ['a*b*c']\n    assert helper('(1 + 2)*3') == ['7']", "108": "def test_basicCalculatorIV():\n\n    def test():\n        assert solution.basicCalculatorIV(expression='(e + 8 - a + 5)', evalvars=['a', 'b'], evalints=[1, 2]) == ['-4*a', '13*b']", "113": "def test_basicCalculatorIV(self):\n    solution = Solution()\n    expression = 'e - (b + a) * 2'\n    evalvars = ['a', 'b', 'c']\n    evalints = [1, 2, 3]\n    self.assertEqual(solution.basicCalculatorIV(expression, evalvars, evalints), ['-2*a*b', '-6*c'])", "115": "def test_basicCalculatorIV():\n    solution = Solution()\n    print(solution.basicCalculatorIV('2 + (3 - a) * 4', ['a'], [0]))", "116": "def test_basicCalculatorIV():\n    solution = Solution()\n    expression = 'a + b * c'\n    evalvars = ['a', 'b', 'c']\n    evalints = [1, 2, 3]\n    assert solution.basicCalculatorIV(expression, evalvars, evalints) == ['-6*a*b*c', '4*a*b', '8*a', '12*b', '18*c']", "117": "def test_basicCalculatorIV():\n\n    def basicCalculatorIV(expression: str, evalvars: List[str], evalints: List[int]) -> List[str]:\n        tokens = list(_getTokens(expression))\n        evalMap = {a: b for (a, b) in zip(evalvars, evalints)}\n        for (i, token) in enumerate(tokens):\n            if token in evalMap:\n                tokens[i] = str(evalMap[token])\n        postfix = _infixToPostfix(tokens)\n        return _evaluate(postfix).toList()\n    solution = Solution()\n    print(solution.basicCalculatorIV('2*(a+b) + 5', ['a', 'b'], [1, 1]))", "119": "def test_basicCalculatorIV():\n    solution = Solution()\n\n    def test_precedes_op_order():\n        tokens = ['a', '*']\n        ops = ['b']\n        assert not solution._infixToPostfix(solution._getTokens('a*b'))[0] == 'b'\n    test_precedes_op_order()", "120": "def test_basicCalculatorIV():\n    def assert_equal(expected, actual):\n        assert expected == actual\n\n    class Poly:\n        # ... (rest of the code remains the same)\n\n    class Solution:\n        # ... (rest of the code remains the same)\n\n    solution = Solution()\n    expression = \"a+b*c+1\"\n    evalvars = [\"a\", \"b\"]\n    evalints = [2, 3]\n\n    result = solution.basicCalculatorIV(expression, evalvars, evalints)", "121": "def test_basicCalculatorIV():\n\n    def basicCalculatorIV(expression, evalvars, evalints):\n        tokens = list(_getTokens(expression))\n        evalMap = {a: b for (a, b) in zip(evalvars, evalints)}\n        for (i, token) in enumerate(tokens):\n            if token in evalMap:\n                tokens[i] = str(evalMap[token])\n        postfix = _infixToPostfix(tokens)\n        return _evaluate(postfix).toList()\n    solution = Solution()\n    expression = 'a*b + c*d'\n    evalvars = ['a', 'b', 'c']\n    evalints = [1, 2, -3]\n    assert basicCalculatorIV(expression, evalvars, evalints) == ['-6*a*b*c', '4*a*b', '5*c*d']", "123": "def test_basicCalculatorIV():\n    solution = Solution()\n\n    def helper(expression, evalvars, evalints):\n        tokens = list(solution._getTokens(expression))\n        evalMap = {a: b for (a, b) in zip(evalvars, evalints)}\n        for (i, token) in enumerate(tokens):\n            if token in evalMap:\n                tokens[i] = str(evalMap[token])\n        postfix = solution._infixToPostfix(tokens)\n        return solution._evaluate(postfix).toList()\n    assert helper('1 + 2 * 3', ['x'], [0]) == ['7']\n    assert helper('e + 8 - a + 5', ['e'], [1]) == ['-1*a', '14']", "130": "    def test_basicCalculatorIV(self):\n        expression = \"1 + 2 * (3 - a) + b\"\n        evalvars = [\"a\", \"b\"]\n        evalints = [1, 2]\n        expected_output = [\"-1*a\",\"14\"]\n        self.assertEqual(Solution().basicCalculatorIV(expression, evalvars, evalints).toList(), expected_output)\n\nif __name__ == '__main__':\n    unittest.main()", "131": "def test_basicCalculatorIV():\n\n    def helper(solution):\n        expression = 'e + 8 - (a * 3) + 5'\n        evalvars = ['e', 'a']\n        evalints = [1, 3]", "132": "def test_basicCalculatorIV():\n\n    def basicCalculatorIV(self, expression: str, evalvars: List[str], evalints: List[int]) -> List[str]:\n        if expression == '1 + 2':\n            return ['3']\n        elif expression == '-1 + -2':\n            return ['-3']\nsolution = Solution()\nassert solution.basicCalculatorIV('1 + 2', [], [0, 0]) == ['3']", "133": "def test_basicCalculatorIV():\n\n    def _helper(expression, evalvars, evalints):\n        tokens = list(solution._getTokens(expression))\n        evalMap = {a: b for (a, b) in zip(evalvars, evalints)}\n        for (i, token) in enumerate(tokens):\n            if token in evalMap:\n                tokens[i] = str(evalMap[token])\n        postfix = solution._infixToPostfix(tokens)\n        return solution._evaluate(postfix).toList()\n    assert _helper('e + 8 - a + 5', ['e'], [1]) == ['-a', '14']", "134": "def test_basicCalculatorIV():\n    solution = Solution()\n    expression = 'e + 8 - a + 5'\n    evalvars = ['a', 'e']\n    evalints = [2, 1]\n    assert solution.basicCalculatorIV(expression, evalvars, evalints) == ['-1*a', '14']", "135": "def test_basicCalculatorIV():\n\n    def basicCalculatorIV(expression: str, evalvars: List[str], evalints: List[int]) -> List[str]:\n        tokens = list(solution._getTokens(expression))\n        evalMap = {a: b for (a, b) in zip(evalvars, evalints)}\n        for (i, token) in enumerate(tokens):\n            if token in evalMap:\n                tokens[i] = str(evalMap[token])\n        postfix = solution._infixToPostfix(tokens)\n        return solution._evaluate(postfix).toList()\n    solution = Solution()\n    expression = '5 + (2 - 3) * a'\n    evalvars = ['a']\n    evalints = [1]\n    expected_output = ['-6*a']\n    assert basicCalculatorIV(expression, evalvars, evalints) == expected_output", "137": "def test_basicCalculatorIV():\n\n    def basicCalculatorIV(expression: str, evalvars: List[str], evalints: List[int]) -> List[str]:\n        if expression == 'a*a*b*c':\n            return ['4*a*a*b*c']\n        if expression == '1 + 2 * 3':\n            return ['7']", "139": "def test_basicCalculatorIV():\n    solution = Solution()\n    expression = 'e + 8 - a + 5'\n    evalvars = ['e']\n    evalints = [1]\n    assert solution.basicCalculatorIV(expression, evalvars, evalints) == ['-1*a', '14']", "141": "def test_basicCalculatorIV():\n    class Solution:\n        def basicCalculatorIV(self, expression: str, evalvars: List[str], evalints: List[int]) -> List[str]:\n            # Your existing code here...\n\n    solution = Solution()\n\n    result = solution.basicCalculatorIV('a+b+c', ['a'], [1])"}}
{"task_num": 777, "task_title": "Swap Adjacent in LR String", "func_name": "canTransform", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def canTransform(self, start: str, end: str) -> bool:\n    if start.replace('X', '') != end.replace('X', ''):\n      return False\n\n    i = 0\n    j = 0\n\n    while i < len(start) and j < len(end):\n      while i < len(start) and start[i] == 'X':\n        i += 1\n      while j < len(end) and end[j] == 'X':\n        j += 1\n      if i == len(start) and j == len(end):\n        return True\n      if i == len(start) or j == len(end):\n        return False\n      if start[i] == 'L' and i < j:\n        return False\n      if start[i] == 'R' and i > j:\n        return False\n      i += 1\n      j += 1\n\n    return True\n", "tests": {"14": "def test_canTransform():\n    solution = Solution()\n\n    def canTransformTest(start: str, end: str) -> bool:", "25": "def test_canTransform():\n    solution = Solution()\n\n    def test_case_1():\n        start = 'XL'\n        end = 'LX'\n        assert solution.canTransform(start, end)", "27": "def test_canTransform():\n\n    def _input_1():\n        start = 'LXR'\n        end = 'RXL'\n        return (start, end)\n    assert not solution.canTransform(*_input_1())", "29": "def test_canTransform():\n    solution = Solution()\n    assert not solution.canTransform('RLXXLRRLLXR', 'XLRXXRXRXL')", "31": "def test_canTransform():\n    solution = Solution()\n    assert not solution.canTransform('LR', 'RR')"}}
{"task_num": 782, "task_title": "Transform to Chessboard", "func_name": "movesToChessboard", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def movesToChessboard(self, board: List[List[int]]) -> int:\n    n = len(board)\n\n    for i in range(n):\n      for j in range(n):\n        if board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]:\n          return -1\n\n    rowSum = sum(board[0])\n    colSum = sum(board[i][0] for i in range(n))\n\n    if rowSum != n // 2 and rowSum != (n + 1) // 2:\n      return -1\n    if colSum != n // 2 and colSum != (n + 1) // 2:\n      return -1\n\n    rowSwaps = sum(board[i][0] == (i & 1) for i in range(n))\n    colSwaps = sum(board[0][i] == (i & 1) for i in range(n))\n\n    if n & 1:\n      if rowSwaps & 1:\n        rowSwaps = n - rowSwaps\n      if colSwaps & 1:\n        colSwaps = n - colSwaps\n    else:\n      rowSwaps = min(rowSwaps, n - rowSwaps)\n      colSwaps = min(colSwaps, n - colSwaps)\n\n    return (rowSwaps + colSwaps) // 2\n", "tests": {"18": "def test_movesToChessboard(self):\n\n    class Solution:\n\n        def movesToChessboard(self, board: List[List[int]]) -> int:\n            n = len(board)\n            for i in range(n):\n                for j in range(n):\n                    if board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]:\n                        return -1\n    solution = Solution()\n    board = [[0, 1], [1, 0]]\n    self.assertEqual(solution.movesToChessboard(board), -1)", "24": "def test_movesToChessboard():\n\n    class Solution:\n\n        def movesToChessboard(self, board):\n            n = len(board)\n            for i in range(n):\n                for j in range(n):\n                    if board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]:\n                        return -1\n            rowSum = sum(board[0])\n            colSum = sum((board[i][0] for i in range(n)))\n            if rowSum != n // 2 and rowSum != (n + 1) // 2:\n                return -1\n            if colSum != n // 2 and colColSum != (n + 1) // 2:\n                return -1\n            rowSwaps = sum((board[i][0] == i & 1 for i in range(n)))\n            colSwaps = sum((board[0][i] == i & 1 for i in range(n)))\n            if n & 1:\n                if rowSwaps & 1:\n                    rowSwaps = n - rowSwaps\n                if colSwaps & 1:\n                    colSwaps = n - colSwaps\n            else:\n                rowSwaps = min(rowSwaps, n - rowSwaps)\n                colSwaps = min(colSwaps, n - colSwaps)\n            return (rowSwaps + colSwaps) // 2\n    assert Solution().movesToChessboard([[0, 1, 0], [1, 0, 1], [0, 1, 0]]) == -1", "26": "def test_movesToChessboard():\n\n    class Solution:\n\n        def movesToChessboard(self, board):\n            n = len(board)\n            for i in range(n):\n                for j in range(n):\n                    if board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]:\n                        return -1\n            rowSum = sum(board[0])\n            colSum = sum((board[i][0] for i in range(n)))\n            if rowSum != n // 2 and rowSum != (n + 1) // 2:\n                return -1\n            if colSum != n // 2 and colSum != (n + 1) // 2:\n                return -1\n            rowSwaps = sum((board[i][0] == i & 1 for i in range(n)))\n            colSwaps = sum((board[0][i] == i & 1 for i in range(n)))\n            if n & 1:\n                if rowSwaps & 1:\n                    rowSwaps = n - rowSwaps\n                if colSwaps & 1:\n                    colSwaps = n - colSwaps\n            else:\n                rowSwaps = min(rowSwaps, n - rowSwaps)\n                colSwaps = min(colSwaps, n - colSwaps)\n            return (rowSwaps + colSwaps) // 2\n    solution = Solution()\n    board = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]\n    assert solution.movesToChessboard(board) == -1", "32": "def test_movesToChessboard():\n\n    class Solution:\n\n        def movesToChessboard(self, board):\n            n = len(board)\n            for i in range(n):\n                for j in range(n):\n                    if board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]:\n                        return -1\n            rowSum = sum(board[0])\n            colSum = sum((board[i][0] for i in range(n)))\n            if rowSum != n // 2 and rowSum != (n + 1) // 2:\n                return -1\n            if colSum != n // 2 and colSum != (n + 1) // 2:\n                return -1\n            rowSwaps = sum((board[i][0] == i & 1 for i in range(n)))\n            colSwaps = sum((board[0][i] == i & 1 for i in range(n)))\n            if n & 1 and rowSwaps & 1:\n                return -1\n            else:\n                return (rowSwaps + colSwaps) // 2\n    assert Solution().movesToChessboard([[0, 1], [1, 0]]) == 2", "33": "def test_movesToChessboard(self):\n    solution = Solution()\n    board = [[0, 1, 1, 0], [1, 0, 1, 0], [1, 1, 0, 0], [0, 1, 0, 1]]\n    self.assertEqual(solution.movesToChessboard(board), 3)", "34": "def test_movesToChessboard(self):\n\n    class Solution:\n\n        def movesToChessboard(self, board: List[List[int]]) -> int:\n            n = len(board)\n            for i in range(n):\n                for j in range(n):\n                    if board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]:\n                        return -1\n            rowSum = sum(board[0])\n            colSum = sum((board[i][0] for i in range(n)))\n            if rowSum != n // 2 and rowSum != (n + 1) // 2:\n                return -1\n            if colSum != n // 2 and colSum != (n + 1) // 2:\n                return -1\n            rowSwaps = sum((board[i][0] == i & 1 for i in range(n)))\n            colSwaps = sum((board[0][i] == i & 1 for i in range(n)))\n            if n & 1:\n                if rowSwaps & 1:\n                    rowSwaps = n - rowSwaps\n                if colSwaps & 1:\n                    colSwaps = n - colSwaps\n            else:\n                rowSwaps = min(rowSwaps, n - rowSwaps)\n                colSwaps = min(colSwaps, n - colSwaps)\n            return (rowSwaps + colSwaps) // 2\n    solution = Solution()\n    board = [[1 for _ in range(8)] for _ in range(8)]\n    row = [4, 5, 6, 7, 0, 1, 2, 3]\n    board[:] = zip(*[(a, b) for (a, b) in zip(board[row], board)])\n    result = solution.movesToChessboard(board)", "35": "def test_movesToChessboard():\n    solution = Solution()\n    board = [[0, 1], [1, 0]]\n    assert solution.movesToChessboard(board) == 2", "37": "def test_movesToChessboard():\n\n    class Solution:\n\n        def movesToChessboard(self, board):\n            n = len(board)\n            for i in range(n):\n                for j in range(n):\n                    if board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]:\n                        return -1\n            rowSum = sum(board[0])\n            colSum = sum((board[i][0] for i in range(n)))\n            if rowSum != n // 2 and rowSum != (n + 1) // 2:\n                return -1\n            if colSum != n // 2 and colSum != (n + 1) // 2:\n                return -1\n            rowSwaps = sum((board[i][0] == i & 1 for i in range(n)))\n            colSwaps = sum((board[0][i] == i & 1 for i in range(n)))\n            if n & 1:\n                if rowSwaps & 1:\n                    rowSwaps = n - rowSwaps\n                if colSwaps & 1:\n                    colSwaps = n - colSwaps\n            else:\n                if rowSwaps == n // 2:\n                    rowSwaps = min(rowSwaps, n - rowSwaps)\n                else:\n                    return -1\n                if colSwaps == n // 2:\n                    colSwaps = min(colSwaps, n - colSwaps)\n                else:\n                    return -1\n            return (rowSwaps + colSwaps) // 2\n    solution = Solution()\n    board = [[0] * 4, [3, 4, 5, 6], [9, 10, 11, 12], [15, 16, 17, 18]]\n    assert solution.movesToChessboard(board) == -1", "38": "def test_movesToChessboard():\n\n    class Solution:\n\n        def movesToChessboard(self, board):\n            n = len(board)\n            for i in range(n):\n                for j in range(n):\n                    if board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]:\n                        return -1\n            rowSum = sum(board[0])\n            colSum = sum((board[i][0] for i in range(n)))\n            if rowSum != n // 2 and rowSum != (n + 1) // 2:\n                return -1\n            if colSum != n // 2 and colSum != (n + 1) // 2:\n                return -1\n            rowSwaps = sum((board[i][0] == i & 1 for i in range(n)))\n            colSwaps = sum((board[0][i] == i & 1 for i in range(n)))\n            if n & 1:\n                if rowSwaps & 1:\n                    rowSwaps = n - rowSwaps\n                if colSwaps & 1:\n                    colSwaps = n - colSwaps\n            else:\n                rowSwaps = min(rowSwaps, n - rowSwaps)\n            return (rowSwaps + colSwaps) // 2\n    solution = Solution()\n    board = [[0, 1], [1, 0]]\n    assert solution.movesToChessboard(board) == 0"}}
{"task_num": 786, "task_title": "K-th Smallest Prime Fraction", "func_name": "kthSmallestPrimeFraction", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\n    n = len(arr)\n    ans = [0, 1]\n    l = 0\n    r = 1\n\n    while True:\n      m = (l + r) / 2\n      ans[0] = 0\n      count = 0\n      j = 1\n\n      for i in range(n):\n        while j < n and arr[i] > m * arr[j]:\n          j += 1\n        count += n - j\n        if j == n:\n          break\n        if ans[0] * arr[j] < ans[1] * arr[i]:\n          ans[0] = arr[i]\n          ans[1] = arr[j]\n\n      if count < k:\n        l = m\n      elif count > k:\n        r = m\n      else:\n        return ans\n", "tests": {"29": "def test_kthSmallestPrimeFraction(self):\n\n    class Solution:\n\n        def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\n            n = len(arr)\n            ans = [0, 1]\n            l = 0\n            r = 1\n            while True:\n                m = (l + r) / 2\n                ans[0] = 0\n                count = 0\n                j = 1\n                for i in range(n):\n                    while j < n and arr[i] > m * arr[j]:\n                        j += 1\n                    count += n - j\n                    if j == n:\n                        return [arr[i], arr[0]]\n                    if ans[0] * arr[j] < ans[1] * arr[i]:\n                        ans[0] = arr[i]\n                        ans[1] = arr[j]\n                if count < k:\n                    l = m\n                elif count > k:\n                    r = m\n                else:\n                    return ans\n    solution = Solution()\n    print(solution.kthSmallestPrimeFraction([1, 2, 3], 8))", "31": "def test_kthSmallestPrimeFraction():\n\n    class Solution:\n\n        def kthSmallestPrimeFraction(self, arr, k):\n            n = len(arr)\n            ans = [0, 1]\n            l = 0\n            r = 1\n            while True:\n                m = (l + r) / 2\n                ans[0] = 0\n                count = 0\n                j = 1\n                for i in range(n):\n                    while j < n and arr[i] > m * arr[j]:\n                        j += 1\n                    count += n - j\n                    if j == n:\n                        break\n                    if ans[0] * arr[j] < ans[1] * arr[i]:\n                        ans = [arr[i], arr[j]]\n                return ans\n    solution = Solution()\n    print(solution.kthSmallestPrimeFraction([2, 3, 5, 7], 4))", "32": "def test_kthSmallestPrimeFraction(self):\n    arr = [1, 7, 11, 13, 17, 23]\n    k = 5\n    expected_output = [13, 17]\n    result = self.solution.kthSmallestPrimeFraction(arr, k)", "35": "def test_kthSmallestPrimeFraction():\n\n    class Solution:\n\n        def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\n            n = len(arr)\n            ans = [0, 1]\n            l = 0\n            r = 3\n            while True:\n                m = (l + r) / 2\n                ans[0] = 0\n                count = 0\n                j = 1\n                for i in range(n):\n                    while j < n and arr[i] > m * arr[j]:\n                        j += 1\n                    count += n - j\n                    if j == n:\n                        break\n                    if ans[0] * arr[j] < ans[1] * arr[i]:\n                        ans[0] = arr[i]\n                        ans[1] = arr[j]\n                if count < k:\n                    l = m\n                elif count > k:\n                    r = m\n                else:\n                    return ans\n    solution = Solution()\n    assert solution.kthSmallestPrimeFraction([1, 2, 3], 4) == [1, 2]", "37": "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    arr = [1, 7, 11]\n    k = 5\n    assert solution.kthSmallestPrimeFraction(arr, k) == [4, 2]", "39": "def test_kthSmallestPrimeFraction():\n\n    class Solution:\n\n        def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\n            n = len(arr)\n            ans = [0, 1]\n            l = 0\n            r = 1\n            while True:\n                m = (l + r) / 2\n                ans[0] = 0\n                count = 0\n                j = 1\n                for i in range(n):\n                    while j < n and arr[i] > m * arr[j]:\n                        j += 1\n                    count += n - j\n                    if j == n:\n                        break\n                    if ans[0] * arr[j] < ans[1] * arr[i]:\n                        ans[0] = arr[i]\n                        ans[1] = arr[j]\n                if count == k:\n                    return [arr[int(ans[0])], arr[int(ans[1])]]\n    solution = Solution()\n    print(solution.kthSmallestPrimeFraction([1, 2, 3, 5], 3))"}}
{"task_num": 787, "task_title": "Cheapest Flights Within K Stops", "func_name": "findCheapestPrice", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in flights:\n      graph[u].append((v, w))\n\n    return self._dijkstra(graph, src, dst, k)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, k: int) -> int:\n    dist=[]\n    for i in range(len(graph)):\n      dist.append([math.inf for _ in range(k + 2)])\n\n    dist[src][k + 1] = 0\n    minHeap = [(dist[src][k + 1], src, k + 1)]\n\n    while minHeap:\n      d, u, stops = heapq.heappop(minHeap)\n      if u == dst:\n        return d\n      if stops == 0 or d > dist[u][stops]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v][stops - 1]:\n          dist[v][stops - 1] = d + w\n          heapq.heappush(minHeap, (dist[v][stops - 1], v, stops - 1))\n\n    return -1\n", "tests": {"31": "def test_findCheapestPrice():\n    solution = Solution()\n    n = 4\n    flights = [[0, 1, 100], [1, 2, 100], [2, 3, 600]]\n    src = 0\n    dst = 3\n    k = 1\n    assert solution.findCheapestPrice(n, flights, src, dst, k) == -1", "33": "def test_findCheapestPrice():\n    solution = Solution()\n\n    def assert_equal(a, b):\n        if a != b:\n            raise AssertionError(f'Expected {a}, got {b}')\n    assert_equal(solution.findCheapestPrice(3, [[0, 1, 100], [1, 2, 100], [0, 2, 500]], 0, 2, 1), -1)", "36": "def test_findCheapestPrice():\n\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n        graph = [[] for _ in range(n)]\n        for (u, v, w) in flights:\n            graph[u].append((v, w))\n        return self._dijkstra(graph, src, dst, k)\n\n    class Solution:\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, k: int) -> int:\n            dist = []\n            for i in range(len(graph)):\n                dist.append([math.inf for _ in range(k + 2)])\n            dist[src][k + 1] = 0\n            minHeap = [(dist[src][k + 1], src, k + 1)]\n            while minHeap:\n                (d, u, stops) = heapq.heappop(minHeap)\n                if u == dst:\n                    return d\n                if stops == 0 or d > dist[u][stops]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < dist[v][stops - 1]:\n                        dist[v][stops - 1] = d + w\n                        heapq.heappush(minHeap, (dist[v][stops - 1], v, stops - 1))\n            return -1\n    solution = Solution()\n    flights = [[0, 1, 100], [1, 2, 100], [0, 2, 500]]\n    n = 3\n    src = 0\n    dst = 2\n    k = 1\n    assert solution.findCheapestPrice(n, flights, src, dst, k) == 300", "37": "def test_findCheapestPrice():\n\n    class Solution:\n\n        def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in flights:\n                graph[u].append((v, w))\n            return self._dijkstra(graph, src, dst, k)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, k: int) -> int:\n            dist = []\n            for i in range(len(graph)):\n                dist.append([math.inf for _ in range(k + 2)])\n            dist[src][k + 1] = 0\n            minHeap = [(dist[src][k + 1], src, k + 1)]\n            while minHeap:\n                (d, u, stops) = heapq.heappop(minHeap)\n                if u == dst:\n                    return d\n                if stops == 0 or d > dist[u][stops]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < dist[v][stops - 1]:\n                        dist[v][stops - 1] = d + w\n                        heapq.heappush(minHeap, (dist[v][stops - 1], v, stops - 1))\n            return -1\n    solution = Solution()\n    flights = [[0, 1, 100], [1, 2, 100], [0, 2, 500]]\n    print(solution.findCheapestPrice(3, flights, 0, 2, 1))"}}
{"task_num": 794, "task_title": "Valid Tic-Tac-Toe State", "func_name": "validTicTacToe", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def validTicTacToe(self, board: List[str]) -> bool:\n    def isWin(c: str) -> bool:\n      return any(row.count(c) == 3 for row in board) or any(row.count(c) == 3 for row in list(zip(*board))) or all(board[i][i] == c for i in range(3)) or all(board[i][2 - i] == c for i in range(3))\n\n    countX = sum(row.count('X') for row in board)\n    countO = sum(row.count('O') for row in board)\n\n    if countX < countO or countX - countO > 1:\n      return False\n    if isWin('X') and countX == countO or isWin('O') and countX != countO:\n      return False\n\n    return True\n", "tests": {"20": "def test_validTicTacToe():\n\n    class Solution:\n\n        def validTicTacToe(self, board):\n            countX = sum((row.count('X') for row in board))\n            countO = sum((row.count('O') for row in board))\n            return countX == 1 and countO >= 0 or (countX < countO or countX - countO > 1)\n    solution = Solution()\n    print(solution.validTicTacToe(['OOO', 'XOX', 'XXX']))", "22": "def test_validTicTacToe():\n\n    class Solution:\n\n        def validTicTacToe(self, board):\n\n            def isWin(c):\n                return any((row.count(c) == 3 for row in board)) or any((row.count(c) == 3 for row in list(zip(*board)))) or all((board[i][i] == c for i in range(3))) or all((board[i][2 - i] == c for i in range(3)))\n            countX = sum((row.count('X') for row in board))\n            countO = sum((row.count('O') for row in board))\n            if countX < countO or countX - countO > 1:\n                return False\n            if isWin('X') and countX == countO or (isWin('O') and countX != countO):\n                return False\n            return True\n    solution = Solution()\n    print(solution.validTicTacToe(['O', 'XX', 'X']))"}}
{"task_num": 805, "task_title": "Split Array With Same Average", "func_name": "splitArraySameAverage", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def splitArraySameAverage(self, nums: List[int]) -> bool:\n    n = len(nums)\n    summ = sum(nums)\n    if not any(i * summ % n == 0 for i in range(1, n // 2 + 1)):\n      return False\n\n    sums = [set() for _ in range(n // 2 + 1)]\n    sums[0].add(0)\n\n    for num in nums:\n      for i in range(n // 2, 0, -1):\n        for val in sums[i - 1]:\n          sums[i].add(num + val)\n\n    for i in range(1, n // 2 + 1):\n      if i * summ % n == 0 and i * summ // n in sums[i]:\n        return True\n\n    return False\n", "tests": {"16": "def test_splitArraySameAverage():\n    solution = Solution()\n\n    def assertFalse(*args):\n        assert not solution.splitArraySameAverage([1, 2]), 'Test failed'", "28": "def test_splitArraySameAverage():\n\n    class MockSolution:\n\n        def splitArraySameAverage(self, nums):\n            n = len(nums)\n            summ = sum(nums)\n            if not any((i * summ % n == 0 for i in range(1, n // 2 + 1))):\n                return False\n            sums = [set() for _ in range(n // 2 + 1)]\n            sums[0].add(0)\n            for num in nums:\n                for i in range(n // 2, 0, -1):\n                    for val in sums[i - 1]:\n                        sums[i].add(num + val)\n            for i in range(1, n // 2 + 1):\n                if i * summ % n == 0 and i * summ // n in sums[i]:\n                    return True\n            return False\n    solution = MockSolution()\n    assert solution.splitArraySameAverage([4, 1])"}}
{"task_num": 815, "task_title": "Bus Routes", "func_name": "numBusesToDestination", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:\n    if source == target:\n      return 0\n\n    graph = collections.defaultdict(list)\n    usedBuses = set()\n\n    for i in range(len(routes)):\n      for route in routes[i]:\n        graph[route].append(i)\n\n    ans = 0\n    q = collections.deque([source])\n\n    while q:\n      ans += 1\n      for _ in range(len(q)):\n        for bus in graph[q.popleft()]:\n          if bus in usedBuses:\n            continue\n          usedBuses.add(bus)\n          for nextRoute in routes[bus]:\n            if nextRoute == target:\n              return ans\n            q.append(nextRoute)\n\n    return -1\n", "tests": {"14": "def test_numBusesToDestination():\n\n    class Solution:\n\n        def numBusesToDestination(self, routes, source, target):\n            if source == target:\n                return 0\n            graph = collections.defaultdict(list)\n            usedBuses = set()\n            for i in range(len(routes)):\n                for route in routes[i]:\n                    graph[route].append(i)\n            ans = 0\n            q = collections.deque([source])\n            while q:\n                ans += 1\n                for _ in range(len(q)):\n                    for bus in graph[q.popleft()]:\n                        if bus in usedBuses:\n                            continue\n                        usedBuses.add(bus)\n                        for nextRoute in routes[bus]:\n                            if nextRoute == target:\n                                return ans\n                            q.append(nextRoute)\n            return -1\n    solution = Solution()\n    print(solution.numBusesToDestination([[1, 2, 7], [3, 6, 7]], 1, 6))", "31": "def test_numBusesToDestination():\n    solution = Solution()\n    routes = [[1, 2, 7], [3, 6, 9]]\n    source = 1\n    target = 6\n    assert solution.numBusesToDestination(routes, source, target) == 2", "35": "def test_numBusesToDestination(self):\n    routes = [[1, 2, 7], [3, 6, 9]]\n    source = 1\n    target = 1\n    self.assertEqual(self.solution.numBusesToDestination(routes, source, target), 0)"}}
{"task_num": 838, "task_title": "Push Dominoes", "func_name": "pushDominoes", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def pushDominoes(self, dominoes: str) -> str:\n    ans = list(dominoes)\n    L = -1\n    R = -1\n\n    for i in range(len(dominoes) + 1):\n      if i == len(dominoes) or dominoes[i] == 'R':\n        if L < R:\n          while R < i:\n            ans[R] = 'R'\n            R += 1\n        R = i\n      elif dominoes[i] == 'L':\n        if R < L or (L, R) == (-1, -1):\n          if (L, R) == (-1, -1):\n            L += 1\n          while L < i:\n            ans[L] = 'L'\n            L += 1\n        else:\n          l = R + 1\n          r = i - 1\n          while l < r:\n            ans[l] = 'R'\n            ans[r] = 'L'\n            l += 1\n            r -= 1\n        L = i\n\n    return ''.join(ans)\n", "tests": {"19": "def test_pushDominoes():\n\n    def check_input(dominoes):\n        assert pushDominoes(dominoes) == 'LL..R.R'\n    check_input('L.L.R...LR')", "20": "def test_pushDominoes(self):\n    solution = Solution()\n    self.assertEqual(solution.pushDominoes('...L.R...LR'), 'LL.RR.LL')", "21": "def test_pushDominoes():\n\n    def pushDominoes(dominoes: str) -> str:\n        ans = list(dominoes)\n        L = -1\n        R = -1\n        for i in range(len(dominoes) + 1):\n            if i == len(dominoes) or dominoes[i] == 'R':\n                if L < R:\n                    while R < i:\n                        ans[R] = 'R'\n                        R += 1\n                R = i\n            elif dominoes[i] == 'L':\n                if R < L or (L, R) == (-1, -1):\n                    if (L, R) == (-1, -1):\n                        L += 1\n                    while L < i:\n                        ans[L] = 'L'\n                        L += 1\n                else:\n                    l = R + 1\n                    r = i - 1\n                    while l < r:\n                        ans[l] = 'R'\n                        ans[r] = 'L'\n                        l += 1\n                        r -= 1\n                L = i\n        return ''.join(ans)\n    solution = Solution()\n    dominoes = '..R.L...'\n    assert pushDominoes(dominoes) == '..RR.L..'", "22": "def test_pushDominoes():\n\n    class Solution:\n\n        def pushDominoes(self, dominoes: str) -> str:\n            ans = list(dominoes)\n            L = -1\n            R = -1\n            for i in range(len(dominoes)):\n                if i == len(dominoes) - 1 or dominoes[i] == 'R':\n                    if L < R:\n                        while R <= i:\n                            ans[R] = 'R'\n                            R += 1\n                    return ''.join(ans)\n                elif dominoes[i] == 'L':\n                    if R < L or (L, R) == (-1, -1):\n                        if (L, R) == (-1, -1):\n                            L += 1\n                        while L <= i:\n                            ans[L] = 'L'\n                            L += 1\n                    else:\n                        l = R + 1\n                        r = i\n                        while l < r:\n                            ans[l] = 'R'\n                            ans[r] = 'L'\n                            l += 1\n                            r -= 1\n            return ''.join(ans)\n    solution = Solution()\n    assert solution.pushDominoes('RR.L') == 'RRLL'", "23": "def test_pushDominoes():\n    solution = Solution()\n\n    def check_result(result):\n        assert result == 'L.R.L', f\"Expected 'L.R.L' but got '{result}'\"\n    dominoes = '....L.R..LR.L...'\n    check_result(solution.pushDominoes(dominoes))", "25": "def test_pushDominoes():\n\n    class Solution:\n\n        def pushDominoes(self, dominoes: str) -> str:\n            ans = list(dominoes)\n            L = -1\n            R = -1\n            for i in range(len(dominoes) + 1):\n                if i == len(dominoes) or dominoes[i] == 'R':\n                    if L < R:\n                        while R < i:\n                            ans[R] = 'R'\n                            R += 1\n                    R = i\n                elif dominoes[i] == 'L':\n                    if R < L or (L, R) == (-1, -1):\n                        assert R <= L, 'Assertion failed'\n                        l = R + 1\n                        r = i - 1\n                        while l < r:\n                            ans[l] = 'R'\n                            ans[r] = 'L'\n                            l += 1\n                            r -= 1\n                    else:\n                        pass\n                    L = i\n            return ''.join(ans)\n    solution = Solution()\n    print(solution.pushDominoes('RL'))", "26": "def test_pushDominoes():\n    solution = Solution()\n\n    def assert_equals(expected):\n        result = solution.pushDominoes('L.R...')", "27": "def test_pushDominoes():\n\n    def pushDominoes(dominoes: str) -> str:\n        ans = list(dominoes)\n        L = -1\n        R = -1\n        for i in range(len(dominoes) + 1):\n            if i == len(dominoes) or dominoes[i] == 'R':\n                if L < R:\n                    while R < i:\n                        ans[R] = 'R'\n                        R += 1\n                R = i\n            elif dominoes[i] == 'L':\n                if R < L or (L, R) == (-1, -1):\n                    if (L, R) == (-1, -1):\n                        L += 1\n                    while L < i:\n                        ans[L] = 'L'\n                        L += 1\n                else:\n                    l = R + 1\n                    r = i - 1\n                    while l < r:\n                        ans[l] = 'R'\n                        ans[r] = 'L'\n                        l += 1\n                        r -= 1\n                L = i\n        return ''.join(ans)\n    solution = Solution()\n    print(solution.pushDominoes('LL.RRRRL.L'))", "28": "def test_pushDominoes():\n\n    class Solution:\n\n        def pushDominoes(self, dominoes: str) -> str:\n            ans = list(dominoes)\n            L = -1\n            R = -1\n            for i in range(len(dominoes) + 1):\n                if i == len(dominoes) or dominoes[i] == 'R':\n                    if L < R:\n                        while R < i:\n                            ans[R] = 'R'\n                            R += 1\n                    R = i\n                elif dominoes[i] == 'L':\n                    if R < L or (L, R) == (-1, -1):\n                        if (L, R) == (-1, -1):\n                            L += 1\n                        while L < i:\n                            ans[L] = 'L'\n                            L += 1\n                    else:\n                        l = R + 1\n                        r = i - 1\n                        while l < r:\n                            ans[l] = 'R'\n                            ans[r] = 'L'\n                            l += 1\n                            r -= 1\n                    L = i\n            return ''.join(ans)\n    solution = Solution()\n    assert solution.pushDominoes('..L.R...LR..L..') == '.L.R...LR..L..', 'test failed'", "29": "def test_pushDominoes():\n    solution = Solution()\n    dominoes = 'R.L'\n    expected = 'LLRR'\n    assert solution.pushDominoes(dominoes) == expected", "30": "def test_pushDominoes():\n\n    class Solution:\n\n        def pushDominoes(self, dominoes: str) -> str:\n            ans = list(dominoes)\n            L = -1\n            R = -1\n            for i in range(len(dominoes) + 1):\n                if i == len(dominoes) or dominoes[i] == 'R':\n                    if L < R:\n                        while R < i:\n                            ans[R] = 'R'\n                            R += 1\n                    R = i\n                elif dominoes[i] == 'L':\n                    if R < L or (L, R) == (-1, -1):\n                        if (L, R) == (-1, -1):\n                            L += 1\n                        while L < i:\n                            ans[L] = 'L'\n                            L += 1\n                    else:\n                        l = R + 1\n                        r = i - 1\n                        while l < r:\n                            ans[l] = 'R'\n                            ans[r] = 'L'\n                            l += 1\n                            r -= 1\n                    L = i\n            return ''.join(ans)\n    solution = Solution()\n    assert solution.pushDominoes('LL.RRL.L') == 'RR.LL.RR.L'", "32": "def test_pushDominoes():\n\n    def pushDominoes(dominoes: str) -> str:\n        ans = list(dominoes)\n        L = -1\n        R = -1\n        for i in range(len(dominoes) + 1):\n            if i == len(dominoes) or dominoes[i] == 'R':\n                if L < R:\n                    while R < i:\n                        ans[R] = 'R'\n                        R += 1\n                R = i\n            elif dominoes[i] == 'L':\n                if R < L or (L, R) == (-1, -1):\n                    if (L, R) == (-1, -1):\n                        L += 1\n                    while L < i:\n                        ans[L] = 'L'\n                        L += 1\n                else:\n                    l = R + 1\n                    r = i - 1\n                    while l < r:\n                        ans[l] = 'R'\n                        ans[r] = 'L'\n                        l += 1\n                        r -= 1\n                    L = i\n        return ''.join(ans)\n    solution = Solution()\n    print(solution.pushDominoes('...L.....LR..L...'))", "33": "def test_pushDominoes():\n\n    def helper(dominoes):\n        solution = Solution()", "34": "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('LL.RRR.L') == 'LL.RR.LL'", "35": "def test_pushDominoes():\n\n    class Solution:\n\n        def pushDominoes(self, dominoes: str) -> str:\n            ans = list(dominoes)\n            L = -1\n            R = -1\n            for i in range(len(dominoes) + 1):\n                if i == len(dominoes) or dominoes[i] == 'R':\n                    if L < R:\n                        while R < i:\n                            ans[R] = 'R'\n                            R += 1\n                    R = i\n                elif dominoes[i] == 'L':\n                    if R < L or (L, R) == (-1, -1):\n                        if (L, R) == (-1, -1):\n                            L += 1\n                        while L < i:\n                            ans[L] = 'L'\n                            L += 1\n                    else:\n                        l = R + 1\n                        r = i - 1\n                        while l < r:\n                            ans[l] = 'R'\n                            ans[r] = 'L'\n                            l += 1\n                            r -= 1\n                    L = i\n            return ''.join(ans)\n    solution = Solution()\n    print(solution.pushDominoes('LL.LLR.RRRR'))", "36": "def test_pushDominoes(self):\n    solution = Solution()\n    self.assertEqual(solution.pushDominoes('....'), 'LL.RR.LL')", "37": "def test_pushDominoes():\n\n    class Solution:\n\n        def pushDominoes(self, dominoes: str) -> str:\n            ans = list(dominoes)\n            L = -1\n            R = -1\n            for i in range(len(dominoes) + 1):\n                if i == len(dominoes) or dominoes[i] == 'R':\n                    if L < R:\n                        while R < i:\n                            ans[R] = 'R'\n                            R += 1\n                    R = i\n                elif dominoes[i] == 'L':\n                    if R < L or (L, R) == (-1, -1):\n                        if (L, R) == (-1, -1):\n                            L += 1\n                        while L < i:\n                            ans[L] = 'L'\n                            L += 1\n                    else:\n                        l = R + 1\n                        r = i - 1\n                        while l < r:\n                            ans[l] = 'R'\n                            ans[r] = 'L'\n                            l += 1\n                            r -= 1\n                    L = i\n            return ''.join(ans)\n    solution = Solution()\n    print(solution.pushDominoes('RR.L'))", "38": "def test_pushDominoes():\n\n    class Solution:\n\n        def pushDominoes(self, dominoes: str) -> str:\n            ans = list(dominoes)\n            L = -1\n            R = -1\n            for i in range(len(dominoes) + 1):\n                if i == len(dominoes) or dominoes[i] == 'R':\n                    if L < R:\n                        while R < i:\n                            ans[R] = 'R'\n                            R += 1\n                    R = i\n                elif dominoes[i] == 'L':\n                    if R < L or (L, R) == (-1, -1):\n                        if (L, R) == (-1, -1):\n                            L += 1\n                        while L < i:\n                            ans[L] = 'L'\n                            L += 1\n                    else:\n                        l = R + 1\n                        r = i - 1\n                        while l < r:\n                            ans[l] = 'R'\n                            ans[r] = 'L'\n                            l += 1\n                            r -= 1\n                    L = i\n            return ''.join(ans)\n    solution = Solution()\n    print(solution.pushDominoes('LL.RRRRL.L'))", "39": "def test_pushDominoes():\n\n    def pushDominoes(dominoes: str) -> str:\n        ans = list(dominoes)\n        L = -1\n        R = -1\n        for i in range(len(dominoes) + 1):\n            if i == len(dominoes) or dominoes[i] == 'R':\n                if L < R:\n                    while R < i:\n                        ans[R] = 'R'\n                        R += 1\n                R = i\n            elif dominoes[i] == 'L':\n                if R < L or (L, R) == (-1, -1):\n                    if (L, R) == (-1, -1):\n                        L += 1\n                    while L < i:\n                        ans[L] = 'L'\n                        L += 1\n                else:\n                    l = R + 1\n                    r = i - 1\n                    while l < r:\n                        ans[l] = 'R'\n                        ans[r] = 'L'\n                        l += 1\n                        r -= 1\n                    L = i\n        return ''.join(ans)\n    print(pushDominoes('RR.L...LRLL...R'))"}}
{"task_num": 845, "task_title": "Longest Mountain in Array", "func_name": "longestMountain", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def longestMountain(self, arr: List[int]) -> int:\n    ans = 0\n    i = 0\n\n    while i + 1 < len(arr):\n      while i + 1 < len(arr) and arr[i] == arr[i + 1]:\n        i += 1\n\n      increasing = 0\n      decreasing = 0\n\n      while i + 1 < len(arr) and arr[i] < arr[i + 1]:\n        increasing += 1\n        i += 1\n\n      while i + 1 < len(arr) and arr[i] > arr[i + 1]:\n        decreasing += 1\n        i += 1\n\n      if increasing > 0 and decreasing > 0:\n        ans = max(ans, increasing + decreasing + 1)\n\n    return ans\n", "tests": {"32": "def test_longestMountain(self):\n\n    class Solution:\n\n        def longestMountain(self, arr: List[int]) -> int:\n            ans = 0\n            i = 0\n            while i + 1 < len(arr):\n                while i + 1 < len(arr) and arr[i] == arr[i + 1]:\n                    i += 1\n                increasing = 0\n                decreasing = 0\n                while i + 1 < len(arr) and arr[i] < arr[i + 1]:\n                    increasing += 1\n                    i += 1\n                while i + 1 < len(arr) and arr[i] > arr[i + 1]:\n                    decreasing += 1\n                    i += 1\n                if increasing > 0 and decreasing > 0:\n                    ans = max(ans, increasing + decreasing + 1)\n            return ans\n    solution = Solution()\n    self.assertEqual(solution.longestMountain([2, 1, 4, 7, 3, 2, 5]), 5)"}}
{"task_num": 854, "task_title": "K-Similar Strings", "func_name": "kSimilarity", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def kSimilarity(self, s1: str, s2: str) -> int:\n    ans = 0\n    q = collections.deque([s1])\n    seen = {s1}\n\n    while q:\n      for _ in range(len(q)):\n        curr = q.popleft()\n        if curr == s2:\n          return ans\n        for child in self._getChildren(curr, s2):\n          if child in seen:\n            continue\n          q.append(child)\n          seen.add(child)\n      ans += 1\n\n    return -1\n\n  def _getChildren(self, curr: str, target: str) -> List[str]:\n    children = []\n    s = list(curr)\n    i = 0\n    while curr[i] == target[i]:\n      i += 1\n\n    for j in range(i + 1, len(s)):\n      if s[j] == target[i]:\n        s[i], s[j] = s[j], s[i]\n        children.append(''.join(s))\n        s[i], s[j] = s[j], s[i]\n\n    return children\n", "tests": {"21": "def test_kSimilarity():\n\n    def kSimilarity(self, s1: str, s2: str) -> int:\n        if s1 == 'abc' and s2 == 'bca':\n            return 2", "24": "def test_kSimilarity():\n\n    def kSimilarity(self, s1: str, s2: str) -> int:\n        seen = {s1}\n        q = collections.deque([s1])\n        while q:\n            for _ in range(len(q)):\n                curr = q.popleft()\n                if curr == 'abc' and 'bca' not in seen:\n                    return 1\n                children = self._getChildren(curr, 'bca')\n                for child in children:\n                    if child not in seen:\n                        q.append(child)\n                        seen.add(child)\n    solution = Solution()\n    print(solution.kSimilarity('ab', 'ba'))", "40": "def test_kSimilarity(self):\n    solution = Solution()\n    self.assertEqual(solution.kSimilarity('ab', 'ba'), 1)", "41": "def test_kSimilarity():\n\n    class TestKSimilarity(unittest.TestCase):\n\n        def test_kSimilarity(self):\n            solution = Solution()\n            self.assertEqual(solution.kSimilarity('ab', 'ba'), 1)", "42": "def test_kSimilarity():\n    solution = Solution()\n    print(solution.kSimilarity('ab', 'ba'))"}}
{"task_num": 861, "task_title": "Score After Flipping Matrix", "func_name": "matrixScore", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def matrixScore(self, grid: List[List[int]]) -> int:\n    for row in grid:\n      if row[0] == 0:\n        self._flip(row)\n\n    for j, col in enumerate(list(zip(*grid))):\n      if sum(col) * 2 < len(grid):\n        self._flipCol(grid, j)\n\n    return sum(self._binary(row) for row in grid)\n\n  def _flip(self, row: List[int]) -> None:\n    for i in range(len(row)):\n      row[i] ^= 1\n\n  def _flipCol(self, grid: List[List[int]], j: int) -> None:\n    for i in range(len(grid)):\n      grid[i][j] ^= 1\n\n  def _binary(self, row: List[int]) -> int:\n    res = row[0]\n    for j in range(1, len(row)):\n      res = res * 2 + row[j]\n    return res\n", "tests": {"15": "def test_matrixScore(self):\n\n    class Solution:\n\n        def _binary(self, row: List[int]) -> int:\n            res = row[0]\n            for j in range(1, len(row)):\n                res = res * 2 + row[j]\n            return res\n\n        def matrixScore(self, grid: List[List[int]]) -> int:\n            if grid == [[1, 0], [0, 1]]:\n                self._flip(grid[0])\n            return sum((self._binary(row) for row in grid))\n    solution = Solution()\n    self.assertEqual(solution.matrixScore([[1, 0], [0, 1]]), 2)", "19": "def test_matrixScore(self):\n\n    class Solution:\n\n        def matrixScore(self, grid):\n            for row in grid:\n                if row[0] == 0:\n                    self._flip(row)\n            for (j, col) in enumerate(list(zip(*grid))):\n                if sum(col) * 2 < len(grid):\n                    self._flipCol(grid, j)\n            return sum((self._binary(row) for row in grid))\n\n        def _flip(self, row):\n            for i in range(len(row)):\n                row[i] ^= 1\n\n        def _flipCol(self, grid, j):\n            for i in range(len(grid)):\n                grid[i][j] ^= 1\n\n        def _binary(self, row):\n            res = row[0]\n            for j in range(1, len(row)):\n                res = res * 2 + row[j]\n            return res\n    solution = Solution()\n    self.assertEqual(solution.matrixScore([[0, 0, 1, 1], [1, 0, 1, 0]]), 39)"}}
{"task_num": 866, "task_title": "Prime Palindrome", "func_name": "primePalindrome", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def primePalindrome(self, n: int) -> int:\n    def getPalindromes(n: int):\n      length = n // 2\n      for i in range(10**(length - 1), 10**length):\n        s = str(i)\n        for j in range(10):\n          yield int(s + str(j) + s[::-1])\n\n    def isPrime(num: int) -> bool:\n      for i in range(2, int(num**0.5 + 1)):\n        if num % i == 0:\n          return False\n      return True\n\n    if n <= 2:\n      return 2\n    if n == 3:\n      return 3\n    if n <= 5:\n      return 5\n    if n <= 7:\n      return 7\n    if n <= 11:\n      return 11\n\n    nLength = len(str(n))\n\n    while True:\n      for num in getPalindromes(nLength):\n        if num >= n and isPrime(num):\n          return num\n      nLength += 1\n", "tests": {"23": "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(101) == 101, 'Test failed for prime number'", "27": "def test_primePalindrome():\n\n    def assert_equals(actual, expected):\n        if actual != expected:\n            raise AssertionError(f'Expected {expected}, got {actual}')\n    solution = Solution()\n    assert_equals(solution.primePalindrome(2), 2)", "29": "def test_primePalindrome():\n\n    class Solution:\n\n        def primePalindrome(self, n: int) -> int:\n\n            def getPalindromes(n: int):\n                length = n // 2\n                for i in range(10 ** (length - 1), 10 ** length):\n                    s = str(i)\n                    for j in range(10):\n                        yield int(s + str(j) + s[::-1])\n\n            def isPrime(num: int) -> bool:\n                for i in range(2, int(num ** 0.5 + 1)):\n                    if num % i == 0:\n                        return False\n                return True\n            if n <= 2:\n                return 2\n            if n == 3:\n                return 3\n            if n <= 5:\n                return 5\n            if n <= 7:\n                return 7\n            if n <= 11:\n                return 11\n    solution = Solution()\n    assert solution.primePalindrome(4) == 3", "31": "def test_primePalindrome():\n\n    def helper(solution):\n        assert solution.primePalindrome(6) == 11, 'Expected primePalindrome to return 11 for input 6'", "33": "def test_primePalindrome():\n    solution = Solution()\n    print(solution.primePalindrome(6) == 7)", "35": "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(3) == 3", "42": "def test_primePalindrome():\n    solution = Solution()\n    print(solution.primePalindrome(11))"}}
{"task_num": 882, "task_title": "Reachable Nodes In Subdivided Graph", "func_name": "reachableNodes", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def reachableNodes(self, edges: List[List[int]], maxMoves: int, n: int) -> int:\n    graph = [[] for _ in range(n)]\n    dist = [maxMoves + 1] * n\n\n    for u, v, cnt in edges:\n      graph[u].append((v, cnt))\n      graph[v].append((u, cnt))\n\n    reachableNodes = self._dijkstra(graph, 0, maxMoves, dist)\n    reachableSubnodes = 0\n\n    for u, v, cnt in edges:\n      a = 0 if dist[u] > maxMoves else min(maxMoves - dist[u], cnt)\n      b = 0 if dist[v] > maxMoves else min(maxMoves - dist[v], cnt)\n      reachableSubnodes += min(a + b, cnt)\n\n    return reachableNodes + reachableSubnodes\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, maxMoves: int, dist: List[int]) -> int:\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if dist[u] >= maxMoves:\n        break\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        newDist = d + w + 1\n        if newDist < dist[v]:\n          dist[v] = newDist\n          heapq.heappush(minHeap, (newDist, v))\n\n    return sum(d <= maxMoves for d in dist)\n", "tests": {"37": "def test_reachableNodes(self):\n    edges = [[0, 1, 3], [1, 2, 5], [0, 4, 9]]\n    maxMoves = 7\n    n = len(edges)\n    self.assertEqual(solution.reachableNodes(edges, maxMoves, n), 4)", "39": "def test_reachableNodes():\n\n    class Solution:\n\n        def reachableNodes(self, edges: List[List[int]], maxMoves: int, n: int) -> int:\n            graph = [[] for _ in range(n)]\n            dist = [maxMoves + 1] * n\n            for (u, v, cnt) in edges:\n                graph[u].append((v, cnt))\n                graph[v].append((u, cnt))\n            reachableNodes = self._dijkstra(graph, 0, maxMoves, dist)\n            reachableSubnodes = 0\n            for (u, v, cnt) in edges:\n                a = 0 if dist[u] > maxMoves else min(maxMoves - dist[u], cnt)\n                b = 0 if dist[v] > maxMoves else min(maxMoves - dist[v], cnt)\n                reachableSubnodes += min(a + b, cnt)\n            return reachableNodes + reachableSubnodes\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, maxMoves: int, dist: List[int]) -> int:\n            dist[src] = 0\n            minHeap = [(dist[src], src)]\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if dist[u] >= maxMoves:\n                    break\n                if d > dist[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    newDist = d + w + 1\n                    if newDist < dist[v]:\n                        dist[v] = newDist\n                        heapq.heappush(minHeap, (newDist, v))\n            return sum((d <= maxMoves for d in dist))\n    solution = Solution()\n    edges = [[0, 2, 3], [1, 0, 4], [2, 3, 1]]\n    maxMoves = 5\n    n = 6\n    assert solution.reachableNodes(edges, maxMoves, n) == 7", "43": "def test_reachableNodes(self):\n    solution = Solution()\n    edges = [[0, 1, 2], [0, 2, 3], [2, 1, 2]]\n    maxMoves = 2\n    n = 4\n    self.assertEqual(solution.reachableNodes(edges, maxMoves, n), 6)", "44": "def test_reachableNodes():\n\n    class Solution:\n\n        def reachableNodes(self, edges, maxMoves, n):\n            graph = [[] for _ in range(n)]\n            dist = [maxMoves + 1] * n\n            for (u, v, cnt) in edges:\n                graph[u].append((v, cnt))\n                graph[v].append((u, cnt))\n            reachableNodes = self._dijkstra(graph, 0, maxMoves, dist)\n            reachableSubnodes = 0\n            for (u, v, cnt) in edges:\n                a = 0 if dist[u] > maxMoves else min(maxMoves - dist[u], cnt)\n                b = 0 if dist[v] > maxMoves else min(maxMoves - dist[v], cnt)\n                reachableSubnodes += min(a + b, cnt)\n            return reachableNodes + reachableSubnodes\n\n        def _dijkstra(self, graph, src, maxMoves, dist):\n            dist[src] = 0\n            minHeap = [(dist[src], src)]\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if dist[u] >= maxMoves:\n                    break\n                if d > dist[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    newDist = d + w + 1\n                    if newDist < dist[v]:\n                        dist[v] = newDist\n                        heapq.heappush(minHeap, (newDist, v))\n            return sum((d <= maxMoves for d in dist))\n    solution = Solution()\n    edges = [[0, 1, 2], [0, 2, 3], [1, 3, 4]]\n    maxMoves = 5\n    n = 5\n    assert solution.reachableNodes(edges, maxMoves, n) == 11"}}
{"task_num": 909, "task_title": "Snakes and Ladders", "func_name": "snakesAndLadders", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def snakesAndLadders(self, board: List[List[int]]) -> int:\n    n = len(board)\n    ans = 0\n    q = collections.deque([1])\n    seen = set()\n    A = [0] * (1 + n * n)\n\n    for i in range(n):\n      for j in range(n):\n        if n - i & 1 :\n          A[(n - 1 - i) * n + (j + 1)] = board[i][j]\n        else:\n          A[(n - 1 - i) * n + (n - j)] = board[i][j]\n\n    while q:\n      ans += 1\n      for _ in range(len(q)):\n        curr = q.popleft()\n        for next in range(curr + 1, min(curr + 6, n * n) + 1):\n          dest = A[next] if A[next] > 0 else next\n          if dest == n * n:\n            return ans\n          if dest in seen:\n            continue\n          q.append(dest)\n          seen.add(dest)\n\n    return -1\n", "tests": {"22": "def test_snakesAndLadders():\n\n    class Solution:\n\n        def snakesAndLadders(self, board):\n            n = len(board)\n            ans = 0\n            q = collections.deque([1])\n            seen = set()\n            A = [0] * (1 + n * n)\n            for i in range(n):\n                for j in range(n):\n                    if n - i & 1:\n                        A[(n - 1 - i) * n + (j + 1)] = board[i][j]\n                    else:\n                        A[(n - 1 - i) * n + (n - j)] = board[i][j]\n            while q:\n                ans += 1\n                for _ in range(len(q)):\n                    curr = q.popleft()\n                    for next in range(curr + 1, min(curr + 6, n * n) + 1):\n                        dest = A[next] if A[next] > 0 else next\n                        if dest == n * n:\n                            return ans\n                        if dest in seen:\n                            continue\n                        q.append(dest)\n                        seen.add(dest)\n            return -1\n    solution = Solution()\n    board = [[5, 7], [-3, -2], [8, -6]]\n    assert solution.snakesAndLadders(board) == 2", "24": "def test_snakesAndLadders(self):\n\n    class Solution:\n\n        def snakesAndLadders(self, board: List[List[int]]) -> int:\n            n = len(board)\n            ans = 0\n            q = collections.deque([1])\n            seen = set()\n            A = [0] * (1 + n * n)\n            for i in range(n):\n                for j in range(n):\n                    if n - i & 1:\n                        A[(n - 1 - i) * n + (j + 1)] = board[i][j]\n                    else:\n                        A[(n - 1 - i) * n + (n - j)] = board[i][j]\n            while q:\n                ans += 1\n                for _ in range(len(q)):\n                    curr = q.popleft()\n                    for next in range(curr + 1, min(curr + 6, n * n) + 1):\n                        dest = A[next] if A[next] > 0 else next\n                        if dest == n * n:\n                            return ans\n                        if dest in seen:\n                            continue\n                        q.append(dest)\n                        seen.add(dest)\n            return -1\n    solution = Solution()\n    board = [[4, -1], [3, 8], [-1, 6]]\n    self.assertEqual(solution.snakesAndLadders(board), 5)", "33": "def test_snakesAndLadders():\n\n    class Solution:\n\n        def snakesAndLadders(self, board):\n            n = len(board)\n            ans = 0\n            q = collections.deque([1])\n            seen = set()\n            A = [0] * (1 + n * n)\n            for i in range(n):\n                for j in range(n):\n                    if n - i & 1:\n                        A[(n - 1 - i) * n + (j + 1)] = board[i][j]\n                    else:\n                        A[(n - 1 - i) * n + (n - j)] = board[i][j]\n            while q:\n                ans += 1\n                for _ in range(len(q)):\n                    curr = q.popleft()\n                    for next in range(curr + 1, min(curr + 6, n * n) + 1):\n                        dest = A[next] if A[next] > 0 else next\n                        if dest == n * n:\n                            return ans\n                        if dest in seen:\n                            continue\n                        q.append(dest)\n                        seen.add(dest)\n            return -1\n    solution = Solution()\n    board = [[1, 2], [-1, -1]]\n    assert solution.snakesAndLadders(board) == 3", "35": "def test_snakesAndLadders(self):\n    solution = Solution()\n    board = [[-1, 4], [-1, 3]]\n    self.assertEqual(solution.snakesAndLadders(board), 2)"}}
{"task_num": 913, "task_title": "Cat and Mouse", "func_name": "catMouseGame", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import IntEnum\n\n\nclass State(IntEnum):\n  kDraw = 0\n  kMouseWin = 1\n  kCatWin = 2\n\n\nclass Solution:\n  def catMouseGame(self, graph: List[List[int]]) -> int:\n    n = len(graph)\n    states = [[[0] * 2 for i in range(n)] for j in range(n)]\n    outDegree = [[[0] * 2 for i in range(n)] for j in range(n)]\n    q = collections.deque()\n\n    for cat in range(n):\n      for mouse in range(n):\n        outDegree[cat][mouse][0] = len(graph[mouse])\n        outDegree[cat][mouse][1] = len(graph[cat]) - graph[cat].count(0)\n\n    for cat in range(1, n):\n      for move in range(2):\n        states[cat][0][move] = int(State.kMouseWin)\n        q.append((cat, 0, move, int(State.kMouseWin)))\n        states[cat][cat][move] = int(State.kCatWin)\n        q.append((cat, cat, move, int(State.kCatWin)))\n\n    while q:\n      cat, mouse, move, state = q.popleft()\n      if cat == 2 and mouse == 1 and move == 0:\n        return state\n      prevMove = move ^ 1\n      for prev in graph[cat if prevMove else mouse]:\n        prevCat = prev if prevMove else cat\n        if prevCat == 0:\n          continue\n        prevMouse = mouse if prevMove else prev\n        if states[prevCat][prevMouse][prevMove]:\n          continue\n        if prevMove == 0 and state == int(State.kMouseWin) or \\\n                prevMove == 1 and state == int(State.kCatWin):\n          states[prevCat][prevMouse][prevMove] = state\n          q.append((prevCat, prevMouse, prevMove, state))\n        else:\n          outDegree[prevCat][prevMouse][prevMove] -= 1\n          if outDegree[prevCat][prevMouse][prevMove] == 0:\n            states[prevCat][prevMouse][prevMove] = state\n            q.append((prevCat, prevMouse, prevMove, state))\n\n    return states[2][1][0]\n", "tests": {"42": "def test_catMouseGame():\n    graph = [[1, 2], [3, 0]]\n    assert solution.catMouseGame(graph) == 1", "47": "def test_catMouseGame():\n\n    class Solution:\n\n        def catMouseGame(self, graph):\n            n = len(graph)\n            states = [[[0] * 2 for i in range(n)] for j in range(n)]\n            outDegree = [[[0] * 2 for i in range(n)] for j in range(n)]\n            q = collections.deque()\n            for cat in range(1, n):\n                for move in range(2):\n                    states[cat][0][move] = int(State.kMouseWin)\n                    q.append((cat, 0, move, int(State.kCatWin)))\n    solution = Solution()\n    graph = [[[3], [3], []]]\n    assert solution.catMouseGame(graph) == 1", "50": "def test_catMouseGame():\n    def check_result(graph):", "52": "def test_catMouseGame():\n\n    def catMouseGame(graph):\n        n = len(graph)\n        states = [[[0] * 2 for i in range(n)] for j in range(n)]\n        outDegree = [[[0] * 2 for i in range(n)] for j in range(n)]\n        q = collections.deque()\n        for cat in range(n):\n            for mouse in range(n):\n                outDegree[cat][mouse][0] = len(graph[mouse])\n                outDegree[cat][mouse][1] = len(graph[cat]) - graph[cat].count(0)\n        for cat in range(1, n):\n            for move in range(2):\n                states[cat][0][move] = int(State.kMouseWin)\n                q.append((cat, 0, move, int(State.kMouseWin)))\n                states[cat][cat][move] = int(State.kCatWin)\n                q.append((cat, cat, move, int(State.kCatWin)))\n        while q:\n            (cat, mouse, move, state) = q.popleft()\n            if cat == 2 and mouse == 1 and (move == 0):\n                return state\n            prevMove = move ^ 1\n            for prev in graph[cat if prevMove else mouse]:\n                prevCat = prev if prevMove else cat\n                if prevCat == 0:\n                    continue\n                prevMouse = mouse if prevMove else prev\n                if states[prevCat][prevMouse][prevMove]:\n                    continue\n                if prevMove == 0 and state == int(State.kMouseWin) or (prevMove == 1 and state == int(State.kCatWin)):\n                    states[prevCat][prevMouse][prevMove] = state\n                    q.append((prevCat, prevMouse, prevMove, state))\n                else:\n                    outDegree[prevCat][prevMouse][prevMove] -= 1\n                    if outDegree[prevCat][prevMouse][prevMove] == 0:\n                        states[prevCat][prevMouse][prevMove] = state\n                        q.append((prevCat, prevMouse, prevMove, state))\n            return states[2][1][0]\n    graph = [[1], [0, 2], []]\n    assert catMouseGame(graph) == int(State.kMouseWin)", "53": "def test_catMouseGame():\n\n    class Solution:\n\n        def catMouseGame(self, graph):\n            n = len(graph)\n            states = [[[0] * 2 for i in range(n)] for j in range(n)]\n            outDegree = [[[0] * 2 for i in range(n)] for j in range(n)]\n            q = collections.deque()\n    solution = Solution()\n    graph = [[1, 2], [0, 3]]\n    assert solution.catMouseGame(graph) == 1", "54": "def test_catMouseGame():\n\n    class Solution:\n\n        def catMouseGame(self, graph):\n            n = len(graph)\n            states = [[[0] * 2 for i in range(n)] for j in range(n)]\n            outDegree = [[[0] * 2 for i in range(n)] for j in range(n)]\n            q = collections.deque()\n    solution = Solution()\n    graph = [[1, 3], [0, 2], [4], []]\n    assert solution.catMouseGame(graph) == 1", "56": "    def test_catMouseGame(self):\n        graph = [[2],[0,3,4],[1,6],[5],[1,2,6],[0],[0,4,5]]\n        self.assertEqual(Solution().catMouseGame(graph), 1)\n\nif __name__ == '__main__':\n    unittest.main()", "57": "def test_catMouseGame():\n    def cat_mouse_game(graph):\n        # ... (rest of the function remains the same)\n        \n    graph = [[1,2],[3],[0]]\n    assert cat_mouse_game(graph) == 1", "58": "def test_catMouseGame():\n    graph = [[1, 2], [], [0]]\n    assert solution.catMouseGame(graph) == int(State.kCatWin)", "59": "def test_catMouseGame():\n    graph = [[1, 3], [2, 4, 5], [], [6], []]\n    solution = Solution()\n    assert solution.catMouseGame(graph) == 1"}}
{"task_num": 923, "task_title": "3Sum With Multiplicity", "func_name": "threeSumMulti", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def threeSumMulti(self, arr: List[int], target: int) -> int:\n    kMod = 1_000_000_007\n    ans = 0\n    count = collections.Counter(arr)\n\n    for i, x in count.items():\n      for j, y in count.items():\n        k = target - i - j\n        if k not in count:\n          continue\n        if i == j and j == k:\n          ans = (ans + x * (x - 1) * (x - 2) // 6) % kMod\n        elif i == j and j != k:\n          ans = (ans + x * (x - 1) // 2 * count[k]) % kMod\n        elif i < j and j < k:\n          ans = (ans + x * y * count[k]) % kMod\n\n    return ans % kMod\n", "tests": {"21": "def test_threeSumMulti():\n\n    def threeSumMulti(arr, target):\n        kMod = 1000000007\n        ans = 0\n        count = collections.Counter(arr)\n        for (i, x) in count.items():\n            for (j, y) in count.items():\n                k = target - i - j\n                if k not in count:\n                    continue\n    solution = Solution()\n    arr = [1, 2, 3]\n    target = 6\n    assert threeSumMulti(arr, target) == 0", "23": "def test_threeSumMulti(self):\n    solution = Solution()\n    arr = [1, 2, 3]\n    target = 6\n    self.assertEqual(solution.threeSumMulti(arr, target), 1 * (1 - 1) * (1 - 2) // 6 % kMod)", "25": "def test_threeSumMulti():\n    arr = [1, 2, 3, 4]\n    target = 6\n    assert solution.threeSumMulti(arr, target) == 8, f'Expected solution to return 8, but got {solution.threeSumMulti(arr, target)}'", "27": "def test_threeSumMulti():\n\n    class Solution:\n\n        def threeSumMulti(self, arr, target):\n            kMod = 1000000007\n            ans = 0\n            count = collections.Counter(arr)\n            for (i, x) in count.items():\n                for (j, y) in count.items():\n                    k = target - i - j\n                    if k not in count:\n                        continue\n                    if i == j and j == k:\n                        ans = (ans + x * (x - 1) * (x - 2) // 6) % kMod\n                    elif i == j and j != k:\n                        ans = (ans + x * (x - 1) // 2 * count[k]) % kMod\n                    elif i < j and j < k:\n                        assert arr[i] == 5, f'Expected {arr[i]}, got {arr[i]}'\n                        assert arr[j] == 6, f'Expected {arr[j]}, got {arr[j]}'\n                        assert arr[k] == 2, f'Expected {arr[k]}, got {arr[k]}'\n                        ans = (ans + x * y * count[k]) % kMod\n            return ans % kMod\n    solution = Solution()\n    print(solution.threeSumMulti([1, 2, 3, 4, 5], 6))"}}
{"task_num": 927, "task_title": "Three Equal Parts", "func_name": "threeEqualParts", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def threeEqualParts(self, arr: List[int]) -> List[int]:\n    ones = sum(a == 1 for a in arr)\n\n    if ones == 0:\n      return [0, len(arr) - 1]\n    if ones % 3 != 0:\n      return [-1, -1]\n\n    k = ones // 3\n    i = 0\n\n    for i in range(len(arr)):\n      if arr[i] == 1:\n        first = i\n        break\n\n    gapOnes = k\n\n    for j in range(i + 1, len(arr)):\n      if arr[j] == 1:\n        gapOnes -= 1\n        if gapOnes == 0:\n          second = j\n          break\n\n    gapOnes = k\n\n    for i in range(j + 1, len(arr)):\n      if arr[i] == 1:\n        gapOnes -= 1\n        if gapOnes == 0:\n          third = i\n          break\n\n    while third < len(arr) and arr[first] == arr[second] == arr[third]:\n      first += 1\n      second += 1\n      third += 1\n\n    if third == len(arr):\n      return [first - 1, second]\n    return [-1, -1]\n", "tests": {"16": "def test_threeEqualParts():\n\n    class Solution:\n\n        def threeEqualParts(self, arr):\n            pass\n    solution = Solution()\n    arr = [0, 0, 1, 0]\n    assert solution.threeEqualParts(arr) == [0, len(arr) - 1], f'Expected [0, {len(arr)}] but got {solution.threeEqualParts(arr)}'", "18": "def test_threeEqualParts():\n\n    class Solution:\n\n        def threeEqualParts(self, arr: List[int]) -> List[int]:\n            ones = sum((a == 1 for a in arr))\n            if ones % 3 != 0:\n                return [-1, -1]\n    solution = Solution()\n    assert solution.threeEqualParts([2, 1, 1, 0, 0, 1, 1, 1, 1, 0]) == [-1, -1]", "25": "def test_threeEqualParts():\n    arr = [0, 1, 1, 0, 1]\n\n    def assert_correct_indices(solution, indices):\n        result = solution.threeEqualParts(arr)", "26": "def test_threeEqualParts():\n    arr = [0, 1, 0]\n    expected_output = [-1, -1]\n    assert solution.threeEqualParts(arr) == expected_output", "32": "def test_threeEqualParts():\n\n    class Solution:\n\n        def threeEqualParts(self, arr):\n            ones = sum((a == 1 for a in arr))\n            if ones == 0:\n                return [0, len(arr) - 1]\n            if ones % 3 != 0:\n                return [-1, -1]\n            k = ones // 3\n            i = 0\n            for i in range(len(arr)):\n                if arr[i] == 1:\n                    first = i\n                    break\n            gapOnes = k\n            for j in range(i + 1, len(arr)):\n                if arr[j] == 1:\n                    gapOnes -= 1\n                    if gapOnes == 0:\n                        second = j\n                        break\n            return [first, second]\n    solution = Solution()\n    assert solution.threeEqualParts([2, 1, 4]) == [-1, -1]", "33": "def test_threeEqualParts():\n\n    class Solution:\n\n        def threeEqualParts(self, arr):\n            ones = sum((a == 1 for a in arr))\n            if ones == 0:\n                return [0, len(arr) - 1]\n            if ones % 3 != 0:\n                return [-1, -1]\n            k = ones // 3\n            i = 0\n            for i in range(len(arr)):\n                if arr[i] == 1:\n                    first = i\n                    break\n            gapOnes = k\n            for j in range(i + 1, len(arr)):\n                if arr[j] == 1:\n                    gapOnes -= 1\n                    if gapOnes == 0:\n                        second = j\n                        break\n            gapOnes = k\n            for i in range(j + 1, len(arr)):\n                if arr[i] == 1:\n                    gapOnes -= 1\n                    if gapOnes == 0:\n                        third = i\n                        break\n            while third < len(arr) and arr[first] == arr[second] == arr[third]:\n                first += 1\n                second += 1\n                third += 1\n            if third == len(arr):\n                return [first - 1, second]\n            return [-1, -1]\n    solution = Solution()\n    arr = [0, 1, 0, 1, 1]\n    assert solution.threeEqualParts(arr) == [0, 3], f'Expected [0, 3] but got {solution.threeEqualParts(arr)}'", "34": "def test_threeEqualParts():\n\n    class Solution:\n\n        def threeEqualParts(self, arr):\n            ones = sum((a == 1 for a in arr))\n            if ones == 0:\n                return [0, len(arr) - 1]\n            if ones % 3 != 0:\n                return [-1, -1]\n            k = ones // 3\n            i = 0\n            for i in range(len(arr)):\n                if arr[i] == 1:\n                    first = i\n                    break\n            gapOnes = k\n            arr = [1, 0, 0]\n            first = 0\n            second = 2\n            third = -1\n            return [-1, -1]\n    solution = Solution()\n    print(solution.threeEqualParts([1, 0, 1, 0]))", "35": "def test_threeEqualParts():\n\n    class Solution:\n\n        def threeEqualParts(self, arr):\n            ones = sum((a == 1 for a in arr))\n            if ones == 0:\n                return [0, len(arr) - 1]\n            if ones % 3 != 0:\n                return [-1, -1]\n            k = ones // 3\n            i = 0\n            for i in range(len(arr)):\n                if arr[i] == 1:\n                    first = i\n                    break\n            gapOnes = k\n            for j in range(i + 1, len(arr)):\n                if arr[j] == 1:\n                    gapOnes -= 1\n                    if gapOnes == 0:\n                        second = j\n                        break\n            gapOnes = k\n            for i in range(j + 1, len(arr)):\n                if arr[i] == 1:\n                    gapOnes -= 1\n                    if gapOnes == 0:\n                        third = i\n                        break\n            while third < len(arr) and arr[first] == arr[second] == arr[third]:\n                first += 1\n                second += 1\n                third += 1\n            if third == len(arr):\n                return [first - 1, second]\n            return [-1, -1]\n    solution = Solution()\n    arr = [0, 1, 1, 0, 1, 0, 1, 1, 1, 0]\n    expected = [4, 7]\n    assert solution.threeEqualParts(arr) == expected", "41": "def test_threeEqualParts():\n    arr = [0, 1, 0, 1, 1]\n    print(solution.threeEqualParts(arr))", "42": "def test_threeEqualParts():\n\n    class Solution:\n\n        def threeEqualParts(self, arr):\n            ones = sum((a == 1 for a in arr))\n            if ones == 0:\n                return [0, len(arr) - 1]\n            if ones % 3 != 0:\n                return [-1, -1]\n            k = ones // 3\n            i = 0\n            for i in range(len(arr)):\n                if arr[i] == 1:\n                    first = i\n                    break\n            gapOnes = k\n            for j in range(i + 1, len(arr)):\n                if arr[j] == 1:\n                    gapOnes -= 1\n                    if gapOnes == 0:\n                        second = j\n                        break\n            gapOnes = k\n            for i in range(j + 1, len(arr)):\n                if arr[i] == 1:\n                    gapOnes -= 1\n                    if gapOnes == 0:\n                        third = i\n                        break\n            while third < len(arr) and arr[first] == arr[second] == arr[third]:\n                first += 1\n                second += 1\n                third += 1\n            if third == len(arr):\n                return [first - 1, second]\n            return [-1, -1]\n    solution = Solution()\n    assert solution.threeEqualParts([0, 1, 0, 1]) == [3, 6]", "43": "def test_threeEqualParts():\n\n    class Solution:\n\n        def threeEqualParts(self, arr: List[int]) -> List[int]:\n            ones = sum((a == 1 for a in arr))\n            if ones == 0:\n                return [0, len(arr) - 1]\n            if ones % 3 != 0:\n                return [-1, -1]\n            k = ones // 3\n            i = 0\n            for i in range(len(arr)):\n                if arr[i] == 1:\n                    first = i\n                    break\n            gapOnes = k\n            for j in range(i + 1, len(arr)):\n                if arr[j] == 1:\n                    gapOnes -= 1\n                    if gapOnes == 0:\n                        second = j\n                        break\n            gapOnes = k\n            i = -1\n            for i in range(j + 1, len(arr)):\n                if arr[i] == 1:\n                    gapOnes -= 1\n                    if gapOnes == 0:\n                        third = i\n                        break\n            while third < len(arr) and arr[first] == arr[second] == arr[third]:\n                first += 1\n                second += 1\n                third += 1\n            if third == len(arr):\n                return [first - 1, second]\n            return [-1, -1]\n    solution = Solution()\n    print(solution.threeEqualParts([1, 0, 1, 0, 1]))", "44": "def test_threeEqualParts():\n\n    class Solution:\n\n        def threeEqualParts(self, arr):\n            ones = sum((a == 1 for a in arr))\n            if ones == 0:\n                return [0, len(arr) - 1]\n            if ones % 3 != 0:\n                return [-1, -1]\n            k = ones // 3\n            i = 0\n            for i in range(len(arr)):\n                if arr[i] == 1:\n                    first = i\n                    break\n            gapOnes = k\n            for j in range(i + 1, len(arr)):\n                if arr[j] == 1:\n                    gapOnes -= 1\n                    if gapOnes == 0:\n                        second = j\n                        return [-2, -3]\n                        break\n            else:\n                raise AssertionError('Expected function to return [-2,-3]')", "52": "def test_threeEqualParts():\n    solution = Solution()\n    arr = [1, 0, 1, 0, 1]\n    assert solution.threeEqualParts(arr) == [1, 3]"}}
{"task_num": 935, "task_title": "Knight Dialer", "func_name": "knightDialer", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def knightDialer(self, n: int) -> int:\n    dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n    kMod = 1_000_000_007\n\n    dp = [[1] * 3 for _ in range(4)]\n    dp[3][0] = dp[3][2] = 0\n\n    for _ in range(n - 1):\n      newDp = [[0] * 3 for _ in range(4)]\n      for i in range(4):\n        for j in range(3):\n          if (i, j) in ((3, 0), (3, 2)):\n            continue\n          for dx, dy in dirs:\n            x = i + dx\n            y = j + dy\n            if x < 0 or x >= 4 or y < 0 or y >= 3:\n              continue\n            if (x, y) in ((3, 0), (3, 2)):\n              continue\n            newDp[x][y] = (newDp[x][y] + dp[i][j]) % kMod\n      dp = newDp\n\n    return sum(map(sum, dp)) % kMod\n", "tests": {"24": "def test_knightDialer():\n\n    class Solution:\n\n        def knightDialer(self, n: int) -> int:\n            dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n            kMod = 10 ** 9 + 7\n            dp = [[0] * 3 for _ in range(4)]\n            dp[3][0] = dp[3][2] = 1\n            for i in range(n - 1):\n                newDp = [[0] * 3 for _ in range(4)]\n                for j in range(4):\n                    for k in range(3):\n                        if (j, k) == (3, 1):\n                            continue\n                        for (dx, dy) in dirs:\n                            x = j + dx\n                            y = k + dy\n                            if 0 <= x < 4 and 0 <= y < 3:\n                                newDp[x][y] = (newDp[x][y] + dp[j][k]) % kMod\n                dp = newDp\n            return sum(map(sum, dp)) % kMod\n    solution = Solution()\n    print(solution.knightDialer(13))", "29": "def test_knightDialer():\n    solution = Solution()\n\n    def knightDialer(n):\n        dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n        kMod = 1000000007\n        dp = [[1] * 3 for _ in range(4)]\n        dp[3][0] = dp[3][2] = 0\n        for _ in range(n - 1):\n            newDp = [[0] * 3 for _ in range(4)]\n            for i in range(4):\n                for j in range(3):\n                    if (i, j) in ((3, 0), (3, 2)):\n                        continue\n                    for (dx, dy) in dirs:\n                        x = i + dx\n                        y = j + dy\n                        if x < 0 or x >= 4 or y < 0 or (y >= 3):\n                            newDp[x][y] += dp[i][j]\n                            newDp[x][y] %= kMod\n                        elif (x, y) in ((3, 0), (3, 2)):\n                            continue\n                    newDp[x][y] = (newDp[x][y] + dp[i][j]) % kMod\n            dp = newDp\n        return sum(map(sum, dp)) % kMod\n    assert knightDialer(1) == 10", "31": "def test_knightDialer():\n\n    def knightDialer(n):\n        dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n        kMod = 1000000007\n        dp = [[1] * 3 for _ in range(4)]\n        dp[3][0] = dp[3][2] = 0\n        for _ in range(n - 1):\n            newDp = [[0] * 3 for _ in range(4)]\n            for i in range(4):\n                for j in range(3):\n                    if (i, j) in ((3, 0), (3, 2)):\n                        continue\n                    for (dx, dy) in dirs:\n                        x = i + dx\n                        y = j + dy\n                        if x < 0 or x >= 4 or y < 0 or (y >= 3):\n                            continue\n                        newDp[x][y] = (newDp[x][y] + dp[i][j]) % kMod\n            dp = newDp\n        return sum(map(sum, dp)) % kMod\n    assert knightDialer(1) == 10"}}
{"task_num": 939, "task_title": "Minimum Area Rectangle", "func_name": "minAreaRect", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minAreaRect(self, points: List[List[int]]) -> int:\n    ans = math.inf\n    xToYs = collections.defaultdict(set)\n\n    for x, y in points:\n      xToYs[x].add(y)\n\n    for i in range(len(points)):\n      for j in range(i):\n        x1, y1 = points[i]\n        x2, y2 = points[j]\n        if x1 == x2 or y1 == y2:\n          continue\n        if y2 in xToYs[x1] and y1 in xToYs[x2]:\n          ans = min(ans, abs(x1 - x2) * abs(y1 - y2))\n\n    return ans if ans < math.inf else 0\n", "tests": {"24": "def test_minAreaRect():\n\n    class Solution:\n\n        def minAreaRect(self, points):\n            ans = math.inf\n            xToYs = collections.defaultdict(set)\n            for (x, y) in points:\n                xToYs[x].add(y)\n            for i in range(len(points)):\n                for j in range(i):\n                    (x1, y1) = points[i]\n                    (x2, y2) = points[j]\n                    if abs(x1 - x2) == 0 or abs(y1 - y2) == 0:\n                        return 0\n                    if y2 in xToYs[x1] and y1 in xToYs[x2]:\n                        ans = min(ans, abs(x1 - x2) * abs(y1 - y2))\n            return ans\n    solution = Solution()\n    points = [[1, 1], [1, 3], [3, 1], [3, 3]]\n    print(solution.minAreaRect(points))", "26": "def test_minAreaRect():\n\n    class Solution:\n\n        def minAreaRect(self, points: List[List[int]]) -> int:\n            ans = math.inf\n            xToYs = collections.defaultdict(set)\n            for (x, y) in points:\n                xToYs[x].add(y)\n            for i in range(len(points)):\n                for j in range(i):\n                    (x1, y1) = points[i]\n                    (x2, y2) = points[j]\n                    if x1 == x2 or y1 == y2:\n                        continue\n                    if y2 in xToYs[x1] and y1 in xToYs[x2]:\n                        ans = min(ans, abs(x1 - x2) * abs(y1 - y2))\n            return ans if ans < math.inf else 0\n    solution = Solution()\n    points = [[1, 1], [1, 3], [3, 1], [3, 3]]\n    print(solution.minAreaRect(points))"}}
{"task_num": 952, "task_title": "Largest Component Size by Common Factor", "func_name": "largestComponentSize", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def largestComponentSize(self, nums: List[int]) -> int:\n    ans = 0\n    uf = UnionFind(max(nums) + 1)\n    count = collections.Counter()\n\n    for num in nums:\n      for x in range(2, int(math.sqrt(num) + 1)):\n        if num % x == 0:\n          uf.unionByRank(num, x)\n          uf.unionByRank(num, num // x)\n\n    for num in nums:\n      numRoot = uf.find(num)\n      count[numRoot] += 1\n      ans = max(ans, count[numRoot])\n\n    return ans\n", "tests": {"20": "def test_largestComponentSize(self):\n\n    class Solution:\n\n        def largestComponentSize(self, nums: List[int]) -> int:\n            ans = 0\n            uf = UnionFind(max(nums) + 1)\n            count = collections.Counter()\n            for num in nums:\n                for x in range(2, int(math.sqrt(num) + 1)):\n                    if num % x == 0:\n                        uf.unionByRank(num, x)\n                        uf.unionByRank(num, num // x)\n            for num in nums:\n                numRoot = uf.find(num)\n                count[numRoot] += 1\n                ans = max(ans, count[numRoot])\n            return ans\n    solution = Solution()\n    self.assertEqual(solution.largestComponentSize([5, 7, 6]), 4)", "22": "def test_largestComponentSize(self):\n\n    class Solution:\n\n        def largestComponentSize(self, nums: List[int]) -> int:\n            ans = 0\n            uf = UnionFind(max(nums) + 1)\n            count = collections.Counter()\n            for num in nums:\n                for x in range(2, int(math.sqrt(num) + 1)):\n                    if num % x == 0:\n                        uf.unionByRank(num, x)\n                        uf.unionByRank(num, num // x)\n            for num in nums:\n                numRoot = uf.find(num)\n                count[numRoot] += 1\n                ans = max(ans, count[numRoot])\n            return ans\n    solution = Solution()\n    result = solution.largestComponentSize([10, 6, 8, 3, 4, 12, 9])", "24": "def test_largestComponentSize(self):\n\n    class Solution(object):\n\n        def largestComponentSize(self, nums):\n            ans = 0\n            uf = UnionFind(max(nums) + 1)\n            count = collections.Counter()\n            for num in nums:\n                for x in range(2, int(math.sqrt(num) + 1)):\n                    if num % x == 0:\n                        uf.unionByRank(num, x)\n                        uf.unionByRank(num, num // x)\n            for num in nums:\n                numRoot = uf.find(num)\n                count[numRoot] += 1\n                ans = max(ans, count[numRoot])\n            return ans\n    solution = Solution()\n    result = solution.largestComponentSize([13, 2, 3, 5, 7, 11])", "26": "def test_largestComponentSize(self):\n    solution = Solution()\n    nums = [15, 21, 24, 10, 30, 16, 28]\n    self.assertEqual(solution.largestComponentSize(nums), 6)", "27": "def test_largestComponentSize():\n\n    def largestComponentSize(nums):\n        ans = 0\n        uf = UnionFind(max(nums) + 1)\n        count = collections.Counter()\n        for num in nums:\n            for x in range(2, int(math.sqrt(num) + 1)):\n                if num % x == 0:\n                    uf.unionByRank(num, x)\n                    uf.unionByRank(num, num // x)\n        for num in nums:\n            numRoot = uf.find(num)\n            count[numRoot] += 1\n            ans = max(ans, count[numRoot])\n        return ans\n    print(largestComponentSize([4, 13]))", "31": "def test_largestComponentSize(self):\n\n    class Solution:\n\n        def largestComponentSize(self, nums: List[int]) -> int:\n            ans = 0\n            uf = UnionFind(max(nums) + 1)\n            count = collections.Counter()\n            for num in nums:\n                for x in range(2, int(math.sqrt(num) + 1)):\n                    if num % x == 0:\n                        uf.unionByRank(num, x)\n                        uf.unionByRank(num, num // x)\n            for num in nums:\n                numRoot = uf.find(num)\n                count[numRoot] += 1\n                ans = max(ans, count[numRoot])\n            return ans\n    solution = Solution()\n    result = solution.largestComponentSize([13, 2, 21, 33, 45, 7])", "44": "def test_largestComponentSize():\n\n    class Solution:\n\n        def largestComponentSize(self, nums):\n            ans = 0\n            uf = UnionFind(max(nums) + 1)\n            count = collections.Counter()\n            for num in nums:\n                for x in range(2, int(math.sqrt(num) + 1)):\n                    if num % x == 0:\n                        uf.unionByRank(num, x)\n            return max(count.values())\n    import math\n    import itertools\n    import bisect\n    import collections\n    import heapq\n    import functools\n    import sortedcontainers\n\n    class UnionFind:\n\n        def __init__(self, n: int):\n            self.id = list(range(n))\n            self.rank = [0] * n\n\n        def unionByRank(self, u: int, v: int) -> None:\n            i = self.find(u)\n            j = self.find(v)\n            if i == j:\n                return\n            if self.rank[i] < self.rank[j]:\n                self.id[i] = j\n            elif self.rank[i] > self.rank[j]:\n                self.id[j] = i\n            else:\n                self.id[i] = j\n                self.rank[j] += 1\n\n        def find(self, u: int) -> int:\n            if self.id[u] != u:\n                self.id[u] = self.find(self.id[u])\n            return self.id[u]\n    solution = Solution()\n    print(solution.largestComponentSize([15, 21, 24, 10]))", "45": "def test_largestComponentSize(self):\n\n    class Solution:\n\n        def largestComponentSize(self, nums: List[int]) -> int:\n            ans = 0\n            uf = UnionFind(max(nums) + 1)\n            count = collections.Counter()\n            for num in nums:\n                for x in range(2, int(math.sqrt(num) + 1)):\n                    if num % x == 0:\n                        uf.unionByRank(num, x)\n                        uf.unionByRank(num, num // x)\n            for num in nums:\n                numRoot = uf.find(num)\n                count[numRoot] += 1\n                ans = max(ans, count[numRoot])\n            return ans\n\n    class UnionFind:\n\n        def __init__(self, n: int):\n            self.id = list(range(n))\n            self.rank = [0] * n\n\n        def unionByRank(self, u: int, v: int) -> None:\n            i = self.find(u)\n            j = self.find(v)\n            if i == j:\n                return\n            if self.rank[i] < self.rank[j]:\n                self.id[i] = j\n            elif self.rank[i] > self.rank[j]:\n                self.id[j] = i\n            else:\n                self.id[i] = j\n                self.rank[j] += 1\n\n        def find(self, u: int) -> int:\n            if self.id[u] != u:\n                self.id[u] = self.find(self.id[u])\n            return self.id[u]\n    solution = Solution()\n    nums = [15, 21, 14]\n    self.assertEqual(solution.largestComponentSize(nums), 3)"}}
{"task_num": 963, "task_title": "Minimum Area Rectangle II", "func_name": "minAreaFreeRect", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\nfrom math import sqrt\n\nclass Solution:\n  def minAreaFreeRect(self, points: List[List[int]]) -> float:\n    ans = math.inf\n    centerToPoints = collections.defaultdict(list)\n\n    for ax, ay in points:\n      for bx, by in points:\n        center = ((ax + bx) / 2, (ay + by) / 2)\n        centerToPoints[center].append((ax, ay, bx, by))\n\n    def dist(px: int, py: int, qx: int, qy: int) -> float:\n      return (px - qx)**2 + (py - qy)**2\n\n    for points in centerToPoints.values():\n      for ax, ay, _, _ in points:\n        for cx, cy, dx, dy in points:\n          if (cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0:\n            squaredArea = dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy)\n            if squaredArea > 0:\n              ans = min(ans, squaredArea)\n\n    return 0 if ans == math.inf else sqrt(ans)\n", "tests": {"29": "def test_minAreaFreeRect():\n\n    class Solution:\n\n        def minAreaFreeRect(self, points: List[List[int]]) -> float:\n            ans = math.inf\n            centerToPoints = collections.defaultdict(list)\n            for (ax, ay) in [[0, 0], [1, 1]]:\n                for (bx, by) in [[0, 2], [3, 3]]:\n                    center = ((ax + bx) / 2, (ay + by) / 2)\n                    centerToPoints[center].append((ax, ay, bx, by))\n\n            def dist(px: int, py: int, qx: int, qy: int) -> float:\n                return (px - qx) ** 2 + (py - qy) ** 2\n            for points in centerToPoints.values():\n                for (ax, ay, _, _) in points:\n                    for (cx, cy, dx, dy) in points:\n                        if (cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0:\n                            squaredArea = dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy)\n                            if squaredArea > 0:\n                                ans = min(ans, squaredArea)\n            return 0 if ans == math.inf else sqrt(ans)\n    solution = Solution()\n    assert solution.minAreaFreeRect([[1, 2], [4, 6], [7, 8]]) == math.sqrt(25.0), 'Test failed'", "30": "def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[1, 2], [4, 6], [7, 8]]\n    assert solution.minAreaFreeRect(points) < 24.5", "31": "def test_minAreaFreeRect(self):\n\n    class Solution:\n\n        def minAreaFreeRect(self, points: List[List[int]]) -> float:\n            ans = math.inf\n            centerToPoints = collections.defaultdict(list)\n            for (ax, ay) in points:\n                for (bx, by) in points:\n                    center = ((ax + bx) / 2, (ay + by) / 2)\n                    centerToPoints[center].append((ax, ay, bx, by))\n\n            def dist(px: int, py: int, qx: int, qy: int) -> float:\n                return (px - qx) ** 2 + (py - qy) ** 2\n            points = [[1, 2], [3, 4]]\n            for point in centerToPoints.values():\n                for (ax, ay, _, _) in point:\n                    for (cx, cy, dx, dy) in point:\n                        if (cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0:\n                            squaredArea = dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy)\n                            ans = min(ans, squaredArea)\n            return 0 if ans == math.inf else sqrt(ans)\n    solution = Solution()\n    self.assertAlmostEqual(solution.minAreaFreeRect([[1, 2], [4, 3]]), 5.0)"}}
{"task_num": 990, "task_title": "Satisfiability of Equality Equations", "func_name": "equationsPossible", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n\n  def union(self, u: int, v: int) -> None:\n    self.id[self.find(u)] = self.find(v)\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def equationsPossible(self, equations: List[str]) -> bool:\n    uf = UnionFind(26)\n\n    for x, op, _, y in equations:\n      if op == '=':\n        uf.union(ord(x) - ord('a'), ord(y) - ord('a'))\n\n    for x, op, _, y in equations:\n      if op == '!':\n        if uf.find(ord(x) - ord('a')) == uf.find(ord(y) - ord('a')):\n          return False\n    return True\n", "tests": {"20": "def test_equationsPossible():\n\n    def check_eq():\n        assert solution.equationsPossible(['b==a', 'a==b']) == True", "30": "def test_equationsPossible():\n\n    class Solution:\n\n        def equationsPossible(self, equations):\n            uf = UnionFind(26)\n            for (x, op, _, y) in equations:\n                if op == '=':\n                    uf.union(ord(x) - ord('a'), ord(y) - ord('a'))\n            for (x, op, _, y) in equations:\n                if op == '!':\n                    if uf.find(ord(x) - ord('a')) == uf.find(ord(y) - ord('a')):\n                        return False\n            return True\n    solution = Solution()\n\n    def test_input():\n        solution.equationsPossible(['b==a', 'a!=a'])", "34": "def test_equationsPossible():\n    solution = Solution()\n    equations = ['c==c', 'b==d', 'a==b']\n    assert solution.equationsPossible(equations)", "35": "def test_equationsPossible(self):\n\n    class Solution:\n\n        def equationsPossible(self, equations: List[str]) -> bool:\n            uf = UnionFind(26)\n            for (x, op, _, y) in equations:\n                if op == '=':\n                    uf.union(ord(x) - ord('a'), ord(y) - ord('a'))\n            for (x, op, _, y) in equations:\n                if op == '!':\n                    if uf.find(ord(x) - ord('a')) == uf.find(ord(y) - ord('a')):\n                        return False\n            return True\n    solution = Solution()\n    result = solution.equationsPossible(['c==c', 'b==d', 'x!=y'])"}}
{"task_num": 999, "task_title": "Available Captures for Rook", "func_name": "numRookCaptures", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numRookCaptures(self, board: List[List[str]]) -> int:\n    ans = 0\n\n    for i in range(8):\n      for j in range(8):\n        if board[i][j] == 'R':\n          i0 = i\n          j0 = j\n\n    for d in [[1, 0], [0, 1], [-1, 0], [0, -1]]:\n      i = i0 + d[0]\n      j = j0 + d[1]\n      while 0 <= i < 8 and 0 <= j < 8:\n        if board[i][j] == 'p':\n          ans += 1\n        if board[i][j] != '.':\n          break\n        i += d[0]\n        j += d[1]\n\n    return ans\n", "tests": {"18": "def test_numRookCaptures():\n\n    class Solution:\n\n        def numRookCaptures(self, board):\n            return sum((1 for d in [[-1, 0], [0, -1]] if any((board[i][j] == 'p' for i in range(row + 1) for j in (row,))) for (row, c) in enumerate(board[7]) if c == 'R'))\n    solution = Solution()", "19": "def test_numRookCaptures(self):\n    solution = Solution()\n    board = [\n        [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n        [\".\",\"p\",\".\",\". \",\".\",\".\",\".\",\".\"],\n        [\".\",\".\",\".\",\"B \",\".\",\".\",\".\",\".\"],\n        [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n        [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n        [.\" ,\".\",\".\",\"R \",\".\",\".\",\".\",\".\"],\n        [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n        [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\n    ]\n    self.assertEqual(solution.numRookCaptures(board), 5)", "26": "def test_numRookCaptures():\n\n    class Solution:\n\n        def numRookCaptures(self, board):\n            return ([[['.', '.', 'B', '.'], ['.', '.', '.', '.'], ['.', '.', '.', '.'], ['.', '.', '.', '.']], [['.', '.', '.', '.'], ['.', '.', '.', '.'], ['.', '.', '.', '.'], ['.', '.', '.', 'R']]], 2)", "28": "def test_numRookCaptures():\n\n    class Solution:\n\n        def numRookCaptures(self, board):\n            return 0 if board[5][4] == 'p' and (board[6][3] != '.', board[6][3] != 'B') and (board[7][2] != '.', board[7][2] != 'B') else 1\n    s = Solution()\n    print(s.numRookCaptures([['p', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', 'R', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', 'B', '.', '.', '.'], ['Rp', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.']]))"}}
{"task_num": 1001, "task_title": "Grid Illumination", "func_name": "gridIllumination", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def gridIllumination(self, n: int, lamps: List[List[int]], queries: List[List[int]]) -> List[int]:\n    ans = []\n    rows = collections.Counter()\n    cols = collections.Counter()\n    diag1 = collections.Counter()\n    diag2 = collections.Counter()\n    lampsSet = set()\n\n    for i, j in lamps:\n      if (i, j) not in lampsSet:\n        lampsSet.add((i, j))\n        rows[i] += 1\n        cols[j] += 1\n        diag1[i + j] += 1\n        diag2[i - j] += 1\n\n    for i, j in queries:\n      if rows[i] or cols[j] or diag1[i + j] or diag2[i - j]:\n        ans.append(1)\n        for y in range(max(0, i - 1), min(n, i + 2)):\n          for x in range(max(0, j - 1), min(n, j + 2)):\n            if (y, x) in lampsSet:\n              lampsSet.remove((y, x))\n              rows[y] -= 1\n              cols[x] -= 1\n              diag1[y + x] -= 1\n              diag2[y - x] -= 1\n      else:\n        ans.append(0)\n\n    return ans\n", "tests": {"22": "def test_gridIllumination(self):\n\n    class Solution:\n\n        def gridIllumination(self, n: int, lamps: List[List[int]], queries: List[List[int]]) -> List[int]:\n            ans = []\n            rows = collections.Counter()\n            cols = collections.Counter()\n            diag1 = collections.Counter()\n            diag2 = collections.Counter()\n            lampsSet = set()\n            for (i, j) in lamps:\n                if (i, j) not in lampsSet:\n                    lampsSet.add((i, j))\n                    rows[i] += 1\n                    cols[j] += 1\n                    diag1[i + j] += 1\n                    diag2[i - j] += 1\n            return [0, 1]\n    solution = Solution()\n    n = 3\n    lamps = [[0, 1], [1, 0]]\n    queries = [[1, 0]]\n    self.assertEqual(solution.gridIllumination(n, lamps, queries), [0, 1])", "23": "def test_gridIllumination():\n\n    class Solution:\n\n        def gridIllumination(self, n, lamps, queries):\n            ans = []\n            rows = collections.Counter()\n            cols = collections.Counter()\n            diag1 = collections.Counter()\n            diag2 = collections.Counter()\n            lampsSet = set()\n            for (i, j) in lamps:\n                if (i, j) not in lampsSet:\n                    lampsSet.add((i, j))\n                    rows[i] += 1\n                    cols[j] += 1\n                    diag1[i + j] += 1\n                    diag2[i - j] += 1\n            for (i, j) in queries:\n                if rows[i] or cols[j] or diag1[i + j] or diag2[i - j]:\n                    ans.append(1)\n                    for y in range(max(0, i - 1), min(n, i + 2)):\n                        for x in range(max(0, j - 1), min(n, j + 2)):\n                            if (y, x) in lampsSet:\n                                lampsSet.remove((y, x))\n                                rows[y] -= 1\n                                cols[x] -= 1\n                                diag1[y + x] -= 1\n                                diag2[y - x] -= 1\n                else:\n                    ans.append(0)\n            return ans\n    solution = Solution()\n    assert solution.gridIllumination(5, [[0, 0], [4, 4]], [[1, 1]])", "24": "def test_gridIllumination():\n    solution = Solution()\n    n = 5\n    lamps = [[0, 0], [0, 4]]\n    queries = [[1, 2]]\n    ans = solution.gridIllumination(n, lamps, queries)", "25": "def test_gridIllumination():\n\n    class Solution:\n\n        def gridIllumination(self, n: int, lamps: List[List[int]], queries: List[List[int]]) -> List[int]:\n            ans = []\n            rows = collections.Counter()\n            cols = collections.Counter()\n            diag1 = collections.Counter()\n            diag2 = collections.Counter()\n            lampsSet = set()\n            for (i, j) in [[0, 0], [0, 1]]:\n                if (i, j) not in lampsSet:\n                    lampsSet.add((i, j))\n                    rows[i] += 1\n                    cols[j] += 1\n                    diag1[i + j] += 1\n                    diag2[i - j] += 1\n            for (i, j) in [[0, 1], [1, 0]]:\n                if rows[i] or cols[j] or diag1[i + j] or diag2[i - j]:\n                    ans.append(1)\n                else:\n                    ans.append(0)\n            return ans\n    lamps = [[0, 0], [0, 1]]\n    queries = [[0, 1], [1, 0]]\n    print(Solution().gridIllumination(2, lamps, queries))", "26": "def test_gridIllumination():\n\n    def solution():\n        n = 3\n        lamps = [[0, 0], [1, 1], [2, 2]]\n        queries = [[1, 0]]", "30": "def test_gridIllumination():\n\n    class Solution:\n\n        def gridIllumination(self, n: int, lamps: List[List[int]], queries: List[List[int]]) -> List[int]:\n            ans = []\n            rows = collections.Counter()\n            cols = collections.Counter()\n            diag1 = collections.Counter()\n            diag2 = collections.Counter()\n            lampsSet = set()\n            for (i, j) in lamps:\n                if (i, j) not in lampsSet:\n                    lampsSet.add((i, j))\n                    rows[i] += 1\n                    cols[j] += 1\n                    diag1[i + j] += 1\n                    diag2[i - j] += 1\n            for (i, j) in queries:\n                if (rows[i] or cols[j]) and (diag1[i + j] or diag2[i - j]):\n                    ans.append(1)\n                    lampsSet.discard((i, j))\n                    for y in range(max(0, i - 1), min(n, i + 2)):\n                        for x in range(max(0, j - 1), min(n, j + 2)):\n                            if (y, x) in lampsSet:\n                                lampsSet.discard((y, x))\n                                rows[y] -= 1\n                                cols[x] -= 1\n                                diag1[y + x] -= 1\n                                diag2[y - x] -= 1\n                else:\n                    ans.append(0)\n            return ans\n    solution = Solution()\n    n = 5\n    lamps = [[0, 0], [4, 4]]\n    queries = [[1, 1], [1, 1]]\n    print(solution.gridIllumination(n, lamps, queries))", "31": "def test_gridIllumination(self):\n    n = 5\n    lamps = [[0, 0], [1, 1], [4, 2]]\n    queries = [[1, 1]]\n    solution = Solution()\n    self.assertEqual(solution.gridIllumination(n, lamps, queries), [1])", "32": "def test_gridIllumination():\n\n    class Solution:\n\n        def gridIllumination(self, n: int, lamps: List[List[int]], queries: List[List[int]]) -> List[int]:\n            ans = []\n            rows = collections.Counter()\n            cols = collections.Counter()\n            diag1 = collections.Counter()\n            diag2 = collections.Counter()\n            lampsSet = set()\n            for (i, j) in lamps:\n                if (i, j) not in lampsSet:\n                    lampsSet.add((i, j))\n                    rows[i] += 1\n                    cols[j] += 1\n                    diag1[i + j] += 1\n                    diag2[i - j] += 1\n            for (i, j) in queries:\n                if 0 <= i <= n - 1 and 0 <= j <= n - 1:\n                    return [1]\n                else:\n                    continue\n    solution = Solution()\n    lamps = [[1, 4], [3, 6]]\n    queries = [[0, 0], [0, 5], [2, 2], [2, 7], [4, 4], [4, 9]]\n    print(solution.gridIllumination(8, lamps, queries))", "33": "def test_gridIllumination():\n\n    class Solution:\n\n        def gridIllumination(self, n: int, lamps: List[List[int]], queries: List[List[int]]) -> List[int]:\n            ans = []\n            rows = collections.Counter()\n            cols = collections.Counter()\n            diag1 = collections.Counter()\n            diag2 = collections.Counter()\n            lampsSet = set()\n            for (i, j) in lamps:\n                if (i, j) not in lampsSet:\n                    lampsSet.add((i, j))\n                    rows[i] += 1\n                    cols[j] += 1\n                    diag1[i + j] += 1\n                    diag2[i - j] += 1\n            lamp1 = [0, 0]\n            lamp2 = [3, 3]\n            for (i, j) in queries:\n                if rows[i] or cols[j] or diag1[i + j] or diag2[i - j]:\n                    ans.append(1)\n                    for y in range(max(0, i - 1), min(n, i + 2)):\n                        for x in range(max(0, j - 1), min(n, j + 2)):\n                            if (y, x) == lamp1 or (y, x) == lamp2:\n                                lampsSet.remove((y, x))\n                            elif (y, x) in lampsSet:\n                                lampsSet.remove((y, x))\n                            rows[y] -= 1\n                            cols[x] -= 1\n                            diag1[y + x] -= 1\n                            diag2[y - x] -= 1\n                else:\n                    ans.append(0)\n            return ans\n    solution = Solution()\n    print(solution.gridIllumination(5, [[0, 0], [4, 4]], [[0, 1], [1, 0]]))", "34": "def test_gridIllumination():\n\n    class Solution:\n\n        def gridIllumination(self, n, lamps, queries):\n            ans = []\n            rows = collections.Counter()\n            cols = collections.Counter()\n            diag1 = collections.Counter()\n            diag2 = collections.Counter()\n            lampsSet = set()\n            for (i, j) in lamps:\n                if (i, j) not in lampsSet:\n                    lampsSet.add((i, j))\n                    rows[i] += 1\n                    cols[j] += 1\n                    diag1[i + j] += 1\n                    diag2[i - j] += 1\n            for (i, j) in queries:\n                if rows[i] or cols[j] or diag1[i + j] or diag2[i - j]:\n                    ans.append(1)\n                    for y in range(max(0, i - 1), min(n, i + 2)):\n                        for x in range(max(0, j - 1), min(n, j + 2)):\n                            if (y, x) in lampsSet:\n                                lampsSet.remove((y, x))\n                                rows[y] -= 1\n                                cols[x] -= 1\n                                diag1[y + x] -= 1\n                                diag2[y - x] -= 1\n                else:\n                    ans.append(0)\n            return ans\n    solution = Solution()", "35": "def test_gridIllumination():\n\n    def gridIllumination(n, lamps, queries):\n        ans = []\n        rows = collections.Counter()\n        cols = collections.Counter()\n        diag1 = collections.Counter()\n        diag2 = collections.Counter()\n        lampsSet = set()\n        for (i, j) in lamps:\n            if (i, j) not in lampsSet:\n                lampsSet.add((i, j))\n                rows[i] += 1\n                cols[j] += 1\n                diag1[i + j] += 1\n                diag2[i - j] += 1\n        for (i, j) in queries:\n            if rows[i] or cols[j] or diag1[i + j] or diag2[i - j]:\n                ans.append(1)\n                for y in range(max(0, i - 1), min(n, i + 2)):\n                    for x in range(max(0, j - 1), min(n, j + 2)):\n                        if (y, x) in lampsSet:\n                            lampsSet.remove((y, x))\n                            rows[y] -= 1\n                            cols[x] -= 1\n                            diag1[y + x] -= 1\n                            diag2[y - x] -= 1\n            else:\n                ans.append(0)\n        return ans\n    n = 5\n    lamps = [[0, 0], [4, 4]]\n    queries = [[0, 1], [1, 1]]\n    assert gridIllumination(n, lamps, queries) == [1, 0]", "36": "def test_gridIllumination(self):\n    n = 5\n    lamps = [[0, 0], [1, 1]]\n    queries = [[2, 2], [3, 4]]\n    solution = Solution()\n    self.assertEqual(solution.gridIllumination(n, lamps, queries), [0, 1])", "37": "def test_gridIllumination():\n    solution = Solution()\n    n = 10\n    lamps = [[0, 0], [2, 3], [4, 5]]\n    queries = [[1, 1], [2, 2]]\n    result = solution.gridIllumination(n, lamps, queries)", "38": "def test_gridIllumination():\n\n    class TestGridIllumination(unittest.TestCase):\n\n        def test_diagonal_counters(self):\n            n = 5\n            lamps = [[1, 2], [3, 4]]\n            queries = [[1, 0], [2, 2]]\n            solution = Solution()\n            ans = solution.gridIllumination(n, lamps, queries)", "40": "def test_gridIllumination():\n\n    class Solution:\n\n        def gridIllumination(self, n: int, lamps: List[List[int]], queries: List[List[int]]) -> List[int]:\n            ans = []\n            rows = collections.Counter()\n            cols = collections.Counter()\n            diag1 = collections.Counter()\n            diag2 = collections.Counter()\n            lampsSet = set()\n            for (i, j) in lamps:\n                if (i, j) not in lampsSet:\n                    lampsSet.add((i, j))\n                    rows[i] += 1\n                    cols[j] += 1\n                    diag1[i + j] += 1\n                    diag2[i - j] += 1\n            for (i, j) in queries:\n                if rows[i] or cols[j] or diag1[i + j] or diag2[i - j]:\n                    ans.append(1)\n                    for y in range(max(0, i - 1), min(n, i + 2)):\n                        for x in range(max(0, j - 1), min(n, j + 2)):\n                            if (y, x) in lampsSet:\n                                lampsSet.remove((y, x))\n                                rows[y] -= 1\n                                cols[x] -= 1\n                                diag1[y + x] -= 1\n                                diag2[y - x] -= 1\n                else:\n                    ans.append(0)\n            return ans\n    solution = Solution()\n    n = 5\n    lamps = [[0, 0], [4, 4]]\n    queries = [[0, 0], [4, 4]]\n    print(solution.gridIllumination(n, lamps, queries))"}}
{"task_num": 1093, "task_title": "Statistics from a Large Sample", "func_name": "sampleStats", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def sampleStats(self, count: List[int]) -> List[float]:\n    minimum = next((i for i, num in enumerate(count) if num), None)\n    maximum = next((i for i, num in reversed(list(enumerate(count))) if num), None)\n    n = sum(count)\n    mean = sum(i * c / n for i, c in enumerate(count))\n    mode = count.index(max(count))\n\n    numCount = 0\n    leftMedian = 0\n    for i, c in enumerate(count):\n      numCount += c\n      if numCount >= n / 2:\n        leftMedian = i\n        break\n\n    numCount = 0\n    rightMedian = 0\n    for i, c in reversed(list(enumerate(count))):\n      numCount += c\n      if numCount >= n / 2:\n        rightMedian = i\n        break\n\n    return [minimum, maximum, mean, (leftMedian + rightMedian) / 2, mode]\n", "tests": {"24": "def test_sampleStats(self):\n    count = [2, 1, 3, 4]\n    self.assertAlmostEqual(solution.sampleStats(count)[0], 0)", "25": "def test_sampleStats():\n    solution = Solution()\n    count = [1, 2, 3, 4, 5]\n    result = solution.sampleStats(count)", "32": "def test_sampleStats(self):\n    count = [1, 2, 3, 4, 5]\n    self.assertEqual(solution.sampleStats(count), [0.0, 4.0, 3.0, 2.5, 0])", "33": "def test_sampleStats():\n\n    class Solution:\n\n        def sampleStats(self, count):\n            minimum = next((i for (i, num) in enumerate(count) if num), None)\n            maximum = next((i for (i, num) in reversed(list(enumerate(count))) if num), None)\n            n = sum(count)\n            mean = sum((i * c / n for (i, c) in enumerate(count)))\n            mode = count.index(max(count))\n            numCount = 0\n            leftMedian = 0\n            for (i, c) in enumerate(count):\n                numCount += c\n                if numCount >= n / 2:\n                    leftMedian = i\n                    return [minimum, maximum, mean, (leftMedian + rightMedian) / 2, mode]\n            numCount = 0\n            rightMedian = 0\n            for (i, c) in reversed(list(enumerate(count))):\n                numCount += c\n                if numCount >= n / 2:\n                    rightMedian = i\n    solution = Solution()\n    count = [100, 0, 1, 90, 1]\n    assert solution.sampleStats(count) == [0.0, 90.0, 30.5, 45.0, 0]"}}
{"task_num": 1129, "task_title": "Shortest Path with Alternating Colors", "func_name": "shortestAlternatingPaths", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import Enum\n\n\nclass Color(Enum):\n  kInit = 0\n  kRed = 1\n  kBlue = 2\n\n\nclass Solution:\n  def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:\n    ans = [-1] * n\n    graph = [[] for _ in range(n)]\n    q = collections.deque([(0, Color.kInit)])\n\n    for u, v in redEdges:\n      graph[u].append((v, Color.kRed))\n\n    for u, v in blueEdges:\n      graph[u].append((v, Color.kBlue))\n\n    step = 0\n    while q:\n      for _ in range(len(q)):\n        u, prevColor = q.popleft()\n        if ans[u] == -1:\n          ans[u] = step\n        for i, (v, edgeColor) in enumerate(graph[u]):\n          if v == -1 or edgeColor == prevColor:\n            continue\n          q.append((v, edgeColor))\n          graph[u][i] = (-1, edgeColor)\n      step += 1\n\n    return ans\n", "tests": {"37": "def test_shortestAlternatingPaths(self):\n\n    class Solution:\n\n        def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:\n            ans = [-1] * n\n            graph = [[] for _ in range(n)]\n            q = collections.deque([(0, Color.kInit)])\n            for (u, v) in redEdges:\n                graph[u].append((v, Color.kRed))\n            for (u, v) in blueEdges:\n                graph[u].append((v, Color.kBlue))\n            step = 0\n            while q:\n                for _ in range(len(q)):\n                    (u, prevColor) = q.popleft()\n                    if ans[u] == -1:\n                        ans[u] = step\n                    for (i, (v, edgeColor)) in enumerate(graph[u]):\n                        if v == -1 or edgeColor == prevColor:\n                            continue\n                        q.append((v, edgeColor))\n                        graph[u][i] = (-1, edgeColor)\n                step += 1\n            return ans\n    solution = Solution()\n    n = 3\n    redEdges = [[0, 1], [1, 2]]\n    blueEdges = []\n    self.assertEqual(solution.shortestAlternatingPaths(n, redEdges, blueEdges), [-1, -1, 0])", "40": "def test_shortestAlternatingPaths():\n\n    def helper(n, redEdges, blueEdges):\n        ans = [-1] * n\n        graph = [[] for _ in range(n)]\n        q = collections.deque([(0, Color.kInit)])\n        for (u, v) in redEdges:\n            graph[u].append((v, Color.kRed))\n        for (u, v) in blueEdges:\n            graph[u].append((v, Color.kBlue))\n        step = 0\n        while q:\n            for _ in range(len(q)):\n                (u, prevColor) = q.popleft()\n                if ans[u] == -1:\n                    ans[u] = step\n                for (i, (v, edgeColor)) in enumerate(graph[u]):\n                    if v == -1 or edgeColor == prevColor:\n                        continue\n                    q.append((v, edgeColor))\n                    graph[u][i] = (-1, edgeColor)\n            step += 1\n        return ans\n    solution = Solution()\n    redEdges = [[0, 1], [1, 2]]\n    blueEdges = [[3, 4]]\n    assert helper(5, redEdges, blueEdges) == [-1, 0, -1, 2, -1]"}}
{"task_num": 1139, "task_title": "Largest 1-Bordered Square", "func_name": "largest1BorderedSquare", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n\n    leftOnes = [[0] * n for _ in range(m)]\n    topOnes = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1:\n          if j==0:\n            leftOnes[i][j]=1\n          else:\n            leftOnes[i][j]=1+leftOnes[i][j-1]\n          if i==0:\n            topOnes[i][j]=1\n          else:\n            topOnes[i][j]=1+topOnes[i-1][j]\n\n    for sz in range(min(m, n), 0, -1):\n      for i in range(m - sz + 1):\n        for j in range(n - sz + 1):\n          x = i + sz - 1\n          y = j + sz - 1\n          if min(leftOnes[i][y], leftOnes[x][y], topOnes[x][j], topOnes[x][y]) >= sz:\n            return sz * sz\n\n    return 0\n", "tests": {"22": "def test_largest1BorderedSquare():\n\n    class Solution:\n\n        def largest1BorderedSquare(self, grid):\n            m = len(grid)\n            n = len(grid[0])\n            leftOnes = [[0] * n for _ in range(m)]\n            topOnes = [[0] * n for _ in range(m)]\n            for i in range(m):\n                for j in range(n):\n                    if grid[i][j] == 1:\n                        if j == 0:\n                            leftOnes[i][j] = 1\n                        else:\n                            leftOnes[i][j] = 1 + leftOnes[i][j - 1]\n                        if i == 0:\n                            topOnes[i][j] = 1\n                        else:\n                            topOnes[i][j] = 1 + topOnes[i - 1][j]\n            return 1\n    solution = Solution()\n    grid = [[1, 0, 1], [1, 0, 1], [1, 1, 1]]\n    assert solution.largest1BorderedSquare(grid) == 9", "23": "def test_largest1BorderedSquare():\n\n    class Solution:\n\n        def largest1BorderedSquare(self, grid):\n            m = len(grid)\n            n = len(grid[0])\n            leftOnes = [[0] * n for _ in range(m)]\n            topOnes = [[0] * n for _ in range(m)]\n            for i in range(m):\n                for j in range(n):\n                    if grid[i][j] == 1:\n                        if j == 0:\n                            leftOnes[i][j] = 1\n                        else:\n                            leftOnes[i][j] = 1 + leftOnes[i][j - 1]\n                        if i == 0:\n                            topOnes[i][j] = 1\n                        else:\n                            topOnes[i][j] = 1 + topOnes[i - 1][j]\n            for sz in range(min(m, n), 0, -1):\n                for i in range(m - sz + 1):\n                    for j in range(n - sz + 1):\n                        x = i + sz - 1\n                        y = j + sz - 1\n                        if min(leftOnes[i][y], leftOnes[x][y], topOnes[x][j], topOnes[x][y]) >= sz:\n                            return sz * sz\n            return 0\n    solution = Solution()\n    grid = [[1, 1]]\n    assert solution.largest1BorderedSquare(grid) == 4", "25": "def test_largest1BorderedSquare():\n\n    class Solution:\n\n        def largest1BorderedSquare(self, grid):\n            m = len(grid)\n            n = len(grid[0])\n            leftOnes = [[0] * n for _ in range(m)]\n            topOnes = [[0] * n for _ in range(m)]\n            for i in range(m):\n                for j in range(n):\n                    if grid[i][j] == 1:\n                        if j == 0:\n                            leftOnes[i][j] = 1\n                        else:\n                            leftOnes[i][j] = 1 + leftOnes[i][j - 1]\n                        if i == 0:\n                            topOnes[i][j] = 1\n                        else:\n                            topOnes[i][j] = 1 + topOnes[i - 1][j]\n            solution = Solution()\n            assert solution.largest1BorderedSquare([[0, 1], [0, 1]]) == 2", "26": "def test_largest1BorderedSquare():\n\n    class Solution:\n\n        def largest1BorderedSquare(self, grid):\n            m = len(grid)\n            n = len(grid[0])\n            leftOnes = [[0] * n for _ in range(m)]\n            topOnes = [[0] * n for _ in range(m)]\n            for i in range(m):\n                for j in range(n):\n                    if grid[i][j] == 1:\n                        if j == 0:\n                            leftOnes[i][j] = 1\n                        else:\n                            leftOnes[i][j] = 1 + leftOnes[i][j - 1]\n                        if i == 0:\n                            topOnes[i][j] = 0\n                        else:\n                            topOnes[i][j] = 1 + topOnes[i - 1][j]\n            for sz in range(min(m, n), 0, -1):\n                for i in range(m - sz + 1):\n                    for j in range(n - sz + 1):\n                        x = i + sz - 1\n                        y = j + sz - 1\n                        if min(leftOnes[i][y], leftOnes[x][y], topOnes[x][j], topOnes[x][y]) >= sz:\n                            return sz * sz\n            return 0\n    solution = Solution()\n    grid = [[1, 1, 1], [1, 1, 0], [1, 1, 0]]\n    assert solution.largest1BorderedSquare(grid) == 3", "27": "def test_largest1BorderedSquare(self):\n    grid = [[0, 0, 0], [0, 1, 1]]\n    result = self.solution.largest1BorderedSquare(grid)", "29": "def test_largest1BorderedSquare():\n\n    class Solution:\n\n        def largest1BorderedSquare(self, grid):\n            m = len(grid)\n            n = len(grid[0])\n            leftOnes = [[0] * n for _ in range(m)]\n            topOnes = [[0] * n for _ in range(m)]\n            for i in range(m):\n                for j in range(n):\n                    if grid[i][j] == 1:\n                        if j == 0:\n                            leftOnes[i][j] = 1\n                        else:\n                            leftOnes[i][j] = 1 + leftOnes[i][j - 1]\n                        if i == 0:\n                            topOnes[i][j] = 1\n                        else:\n                            topOnes[i][j] = 1 + topOnes[i - 1][j]\n            return 4\n    solution = Solution()\n    print(solution.largest1BorderedSquare([[1, 0, 1], [1, 1, 0]]))", "37": "def test_largest1BorderedSquare(self):\n\n    class Solution:\n\n        def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n            m = len(grid)\n            n = len(grid[0])\n            leftOnes = [[0] * n for _ in range(m)]\n            topOnes = [[0] * n for _ in range(m)]\n            for i in range(m):\n                for j in range(n):\n                    if grid[i][j] == 1:\n                        if j == 0:\n                            leftOnes[i][j] = 1\n                        else:\n                            leftOnes[i][j] = 1 + leftOnes[i][j - 1]\n                        if i == 0:\n                            topOnes[i][j] = 1\n                        else:\n                            topOnes[i][j] = 1 + topOnes[i - 1][j]\n            for sz in range(min(m, n), 0, -1):\n                for i in range(m - sz + 1):\n                    for j in range(n - sz + 1):\n                        x = i + sz - 1\n                        y = j + sz - 1\n                        if min(leftOnes[i][y], leftOnes[x][y], topOnes[x][j], topOnes[x][y]) >= sz:\n                            return sz * sz\n            return 0\n    solution = Solution()\n    grid = [[1, 1, 1], [1, 1, 1]]\n    self.assertEqual(solution.largest1BorderedSquare(grid), 4)"}}
{"task_num": 1162, "task_title": "As Far from Land as Possible", "func_name": "maxDistance", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxDistance(self, grid: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    q = collections.deque()\n    water = 0\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 0:\n          water += 1\n        else:\n          q.append((i, j))\n\n    if water == 0 or water == m * n:\n      return -1\n\n    ans = 0\n    d = 0\n\n    while q:\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        ans = d\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if grid[x][y] > 0:\n            continue\n          q.append((x, y))\n          grid[x][y] = 2\n      d += 1\n\n    return ans\n", "tests": {"22": "def test_maxDistance():\n\n    def create_grid(grid):\n        return [[cell for cell in row] for row in grid]\n\n    def check_return_value(actual, expected):\n        assert actual == expected, f'Expected {expected}, but got {actual}'\n    grid = create_grid([[1, 0, 0], [0, 0, 0]])\n    solution = Solution()\n    result = solution.maxDistance(grid)", "24": "def test_maxDistance(self):\n    grid = [[0, 1, 1], [1, 0, 1], [1, 1, 0]]\n    solution = Solution()\n    self.assertEqual(solution.maxDistance(grid), 2)", "27": "def test_maxDistance(self):\n    grid = [[0, 0, 0], [0, 0, 0]]\n    self.assertEqual(solution.maxDistance(grid), -1)", "40": "def test_maxDistance(self):\n    grid = [[0, 1, 0], [0, 0, 1], [1, 0, 0]]\n    self.assertEqual(solution.maxDistance(grid), 2)", "42": "    def test_max_distance(self):\n        grid = [\n            [0, 1, 0],\n            [1, 1, 0],\n            [0, 0, 0]\n        ]\n        self.assertEqual(Solution().maxDistance(grid), 2)\n\nif __name__ == '__main__':\n    unittest.main()"}}
{"task_num": 1202, "task_title": "Smallest String With Swaps", "func_name": "smallestStringWithSwaps", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n    ans = ''\n    uf = UnionFind(len(s))\n    map = collections.defaultdict(list)\n\n    for a, b in pairs:\n      uf.unionByRank(a, b)\n\n    for i, c in enumerate(s):\n      map[uf.find(i)].append(c)\n\n    for key in map.keys():\n      map[key].sort(reverse=True)\n\n    for i in range(len(s)):\n      ans += map[uf.find(i)].pop()\n\n    return ans\n", "tests": {"20": "def test_smallestStringWithSwaps():\n\n    class Solution:\n\n        def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n            ans = ''\n            uf = UnionFind(len(s))\n            map = collections.defaultdict(list)\n            for (a, b) in pairs:\n                uf.unionByRank(a, b)\n            for (i, c) in enumerate(s):\n                map[uf.find(i)].append(c)\n            for key in map.keys():\n                map[key].sort(reverse=True)\n            for i in range(len(s)):\n                ans += map[uf.find(i)].pop()\n            return ans\n    solution = Solution()\n    s = 'dcab'\n    pairs = [[0, 3], [1, 2]]\n    result = solution.smallestStringWithSwaps(s, pairs)", "22": "def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'dcab'\n    pairs = [[0, 3], [1, 2]]\n    result = solution.smallestStringWithSwaps(s, pairs)", "24": "def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'dcab'\n    pairs = [[0, 3], [1, 2]]\n    expected_result = 'bacd'\n    assert solution.smallestStringWithSwaps(s, pairs) == expected_result", "26": "def test_smallestStringWithSwaps():\n    solution = Solution()\n    print(solution.smallestStringWithSwaps('dcab', [[0, 3], [1, 2]]))", "27": "def test_smallestStringWithSwaps(self):\n    s = 'dcab'\n    pairs = [[0, 3], [1, 2]]\n    self.assertEqual(solution.smallestStringWithSwaps(s, pairs), 'bacd')", "31": "def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'dcab'\n    pairs = [[0, 3], [1, 2]]\n    result = solution.smallestStringWithSwaps(s, pairs)"}}
{"task_num": 1210, "task_title": "Minimum Moves to Reach Target with Rotations", "func_name": "minimumMoves", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import IntEnum\n\n\nclass Pos(IntEnum):\n  kHorizontal = 0\n  kVertical = 1\n\n\nclass Solution:\n  def minimumMoves(self, grid: List[List[int]]) -> int:\n    n = len(grid)\n    ans = 0\n\n    q = collections.deque([(0, 0, Pos.kHorizontal)])\n    seen = {(0, 0, Pos.kHorizontal)}\n\n    def canMoveRight(x: int, y: int, pos: Pos) -> bool:\n      if pos == Pos.kHorizontal:\n        return y + 2 < n and not grid[x][y + 2]\n      return y + 1 < n and not grid[x][y + 1] and not grid[x + 1][y + 1]\n\n    def canMoveDown(x: int, y: int, pos: Pos) -> bool:\n      if pos == Pos.kVertical:\n        return x + 2 < n and not grid[x + 2][y]\n      return x + 1 < n and not grid[x + 1][y] and not grid[x + 1][y + 1]\n\n    def canRotateClockwise(x: int, y: int, pos: Pos) -> bool:\n      return pos == Pos.kHorizontal and x + 1 < n and \\\n          not grid[x + 1][y + 1] and not grid[x + 1][y]\n\n    def canRotateCounterclockwise(x: int, y: int, pos: Pos) -> bool:\n      return pos == Pos.kVertical and y + 1 < n and \\\n          not grid[x + 1][y + 1] and not grid[x][y + 1]\n\n    while q:\n      for _ in range(len(q)):\n        x, y, pos = q.popleft()\n        if x == n - 1 and y == n - 2 and pos == Pos.kHorizontal:\n          return ans\n        if canMoveRight(x, y, pos) and (x, y + 1, pos) not in seen:\n          q.append((x, y + 1, pos))\n          seen.add((x, y + 1, pos))\n        if canMoveDown(x, y, pos) and (x + 1, y, pos) not in seen:\n          q.append((x + 1, y, pos))\n          seen.add((x + 1, y, pos))\n        newPos = Pos.kVertical if pos == Pos.kHorizontal else Pos.kHorizontal\n        if (canRotateClockwise(x, y, pos) or canRotateCounterclockwise(x, y, pos)) and (x, y, newPos) not in seen:\n          q.append((x, y, newPos))\n          seen.add((x, y, newPos))\n      ans += 1\n\n    return -1\n", "tests": {"29": "def test_minimumMoves(self):\n    grid = [[0, 1, 0], [0, 0, 0], [1, 0, 0]]\n    self.assertEqual(solution.minimumMoves(grid), 2)", "34": "def test_minimumMoves():\n\n    def minimumMoves(self, grid):\n        n = len(grid)\n        ans = 0\n        q = collections.deque([(0, 1, Pos.kHorizontal)])\n        seen = {(0, 1, Pos.kHorizontal)}\n        while q:\n            for _ in range(len(q)):\n                (x, y, pos) = q.popleft()\n                if canMoveRight(x, y, pos) and (x, y + 1, pos) not in seen:\n                    q.append((x, y + 1, pos))\n                    seen.add((x, y + 1, pos))\n                elif canRotateCounterclockwise(x, y, pos) and (x, y, Pos.kHorizontal) not in seen:\n                    q.append((x, y, Pos.kHorizontal))\n                    seen.add((x, y, Pos.kHorizontal))\n            ans += 1\n        return -1\n    grid = [[0 for _ in range(6)] for _ in range(6)]\n    solution = Solution()\n    print(solution.minimumMoves(grid))", "49": "def test_minimumMoves():\n\n    def test_minimumMoves_grid_n_2_target_at_bottom_right_corner():\n        grid = [[0, 1, 0], [0, 0, 0]]\n        assert solution.minimumMoves(grid) == 3", "51": "def test_minimumMoves():\n\n    def checkMinimumMoves(grid):\n        return 2 if grid == [[0, 0], [0, 0]] else -1\n    assert checkMinimumMoves(solution.minimumMoves([[0, 0], [0, 0]])) == 2", "52": "def test_minimumMoves(self):\n    grid = [[0, 0, 1], [0, 0, 0], [0, 0, 0]]\n    self.assertEqual(solution.minimumMoves(grid), 2)", "54": "    def test_minimumMoves(self):\n        grid = [[0,0,0],[0,0,0],[0,0,1]]\n        self.assertEqual(Solution().minimumMoves(grid), 2)\n\nif __name__ == '__main__':\n    unittest.main()", "55": "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 0, 0, 0], [0, 0, 1, 1], [0, 0, 0, 1], [0, 1, 1, 0]]\n    assert solution.minimumMoves(grid) == 3", "58": "    def test_minimumMoves(self):\n        grid = [[0, 1, 1], [1, 0, 0], [0, 0, 0]]\n        self.assertEqual(Solution().minimumMoves(grid), 3)\n\nif __name__ == '__main__':\n    unittest.main()", "59": "def test_minimumMoves():\n    grid = [[0, 0, 1], [0, 1, 1], [0, 1, 0]]\n    assert solution.minimumMoves(grid) == 3"}}
{"task_num": 1253, "task_title": "Reconstruct a 2-Row Binary Matrix", "func_name": "reconstructMatrix", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def reconstructMatrix(self, upper: int, lower: int, colsum: List[int]) -> List[List[int]]:\n    if upper + lower != sum(colsum):\n      return []\n    if min(upper, lower) < colsum.count(2):\n      return []\n\n    ans = [[0] * len(colsum) for _ in range(2)]\n\n    for j, c in enumerate(colsum):\n      if c == 2:\n        ans[0][j] = 1\n        ans[1][j] = 1\n        upper -= 1\n        lower -= 1\n\n    for j, c in enumerate(colsum):\n      if c == 1 and upper > 0:\n        ans[0][j] = 1\n        c -= 1\n        upper -= 1\n      if c == 1 and lower > 0:\n        ans[1][j] = 1\n        lower -= 1\n\n    return ans\n", "tests": {"14": "def test_reconstructMatrix(self):\n    solution = Solution()\n    upper = 3\n    lower = 2\n    colsum = [1, 1, 1, 0]\n    self.assertEqual(solution.reconstructMatrix(upper, lower, colsum), [[1, 0, 1, 0], [0, 1, 0, 0]])", "16": "def test_reconstructMatrix(self):\n    solution = Solution()\n    self.assertEqual(solution.reconstructMatrix(1, 1, [2]), [[0, 1], [1, 0]])", "22": "def test_reconstructMatrix():\n    solution = Solution()\n    upper = 2\n    lower = 2\n    colsum = [2, 0]\n    expected_output = [[1, 0], [1, 0]]\n    assert solution.reconstructMatrix(upper, lower, colsum) == expected_output", "23": "def test_reconstructMatrix(self):\n\n    class Solution:\n\n        def reconstructMatrix(self, upper: int, lower: int, colsum: List[int]) -> List[List[int]]:\n            if upper + lower != sum(colsum):\n                return []\n            if min(upper, lower) < colsum.count(2):\n                return []\n            ans = [[0] * len(colsum) for _ in range(2)]\n            for (j, c) in enumerate(colsum):\n                if c == 2:\n                    ans[0][j] = 1\n                    ans[1][j] = 1\n                    upper -= 1\n                    lower -= 1\n            for (j, c) in enumerate(colsum):\n                if c == 1 and upper > 0:\n                    ans[0][j] = 1\n                    c -= 1\n                    upper -= 1\n                if c == 1 and lower > 0:\n                    ans[1][j] = 1\n                    lower -= 1\n            return ans\n    solution = Solution()\n    self.assertEqual(solution.reconstructMatrix(2, 3, [1, 2]), [[1, 1], [0, 1]])", "24": "def test_reconstructMatrix():\n\n    class MockSolution:\n\n        def __init__(self):\n            self.upper = 2\n            self.lower = 3\n            self.colsum = [1, 0, 2]\n    solution = MockSolution()\n    result = solution.reconstructMatrix(solution.upper, solution.lower, solution.colsum)", "25": "def test_reconstructMatrix():\n\n    def reconstructMatrix(upper: int, lower: int, colsum: List[int]) -> List[List[int]]:\n        if upper + lower != sum(colsum):\n            return []\n        if min(upper, lower) < colsum.count(2):\n            return []\n        ans = [[0] * len(colsum) for _ in range(2)]\n        for (j, c) in enumerate(colsum):\n            if c == 2:\n                ans[0][j] = 1\n                ans[1][j] = 1\n                upper -= 1\n                lower -= 1\n        for (j, c) in enumerate(colsum):\n            if c == 1 and upper > 0:\n                ans[0][j] = 1\n                c -= 1\n                upper -= 1\n            if c == 1 and lower > 0:\n                ans[1][j] = 1\n                lower -= 1\n        return ans\n    assert reconstructMatrix(2, 3, [4, 5, 6]) == [[1, 0, 0], [1, 1, 1]], f'Expected: [[1, 0, 0], [1, 1, 1]] but got {reconstructMatrix(2, 3, [4, 5, 6])}'", "29": "def test_reconstructMatrix():\n    solution = Solution()\n    upper = 5\n    lower = 4\n    colsum = [2, 2, 1, 0]\n    expected_result = [[1, 1, 1, 0], [0, 0, 0, 0]]\n    assert solution.reconstructMatrix(upper, lower, colsum) == expected_result, f'Expected {expected_result} but got {solution.reconstructMatrix(upper, lower, colsum)}'", "30": "def test_reconstructMatrix(self):\n    solution = Solution()\n    upper = 5\n    lower = 4\n    colsum = [1, 2, 3, 0, 1]\n    self.assertEqual(solution.reconstructMatrix(upper, lower, colsum), [[0, 1, 0, 0, 0], [0, 1, 1, 0, 1]])", "31": "def test_reconstructMatrix():\n\n    def reconstructMatrix(upper: int, lower: int, colsum: List[int]) -> List[List[int]]:\n        if upper + lower != sum(colsum):\n            return []\n        if min(upper, lower) < colsum.count(2):\n            return []\n        ans = [[0] * len(colsum) for _ in range(2)]\n        for (j, c) in enumerate(colsum):\n            if c == 2:\n                ans[0][j] = 1\n                ans[1][j] = 1\n                upper -= 1\n                lower -= 1\n        for (j, c) in enumerate(colsum):\n            if c == 1 and upper > 0:\n                ans[0][j] = 1\n                c -= 1\n                upper -= 1\n            if c == 1 and lower > 0:\n                ans[1][j] = 1\n                lower -= 1\n        return ans\n    solution = Solution()\n    assert reconstructMatrix(4, 3, [2, 2, 2, 2]) == [[1, 1, 1, 1], [1, 1, 1, 1]]", "33": "def test_reconstructMatrix(self):\n\n    class Solution:\n        pass\n    solution = Solution()\n    (upper, lower) = (2, 1)\n    colsum = [1, 0]\n    self.assertEqual(solution.reconstructMatrix(upper, lower, colsum), [[1, 0], [0, 0]])", "34": "def test_reconstructMatrix():\n    solution = Solution()\n    assert solution.reconstructMatrix(1, 0, [2]) == [[1], [1]]"}}
{"task_num": 1254, "task_title": "Number of Closed Islands", "func_name": "closedIsland", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def closedIsland(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n\n    def dfs(i: int, j: int) -> None:\n      if i < 0 or i == m or j < 0 or j == n:\n        return\n      if grid[i][j] == 1:\n        return\n\n      grid[i][j] = 1\n      dfs(i + 1, j)\n      dfs(i - 1, j)\n      dfs(i, j + 1)\n      dfs(i, j - 1)\n\n    for i in range(m):\n      for j in range(n):\n        if i * j == 0 or i == m - 1 or j == n - 1:\n          if grid[i][j] == 0:\n            dfs(i, j)\n\n    ans = 0\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 0:\n          dfs(i, j)\n          ans += 1\n\n    return ans\n", "tests": {"18": "def test_closedIsland():\n    solution = Solution()\n\n    def assert_equal(actual, expected):\n        if actual != expected:\n            print(f'Expected {expected} but got {actual}')\n    grid = [[0, 0, 1], [0, 0, 1], [1, 1, 1]]\n    assert_equal(solution.closedIsland(grid), 1)", "20": "def test_closedIsland():\n    grid = [[0, 0, 1, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [0, 1, 1, 0, 1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 1, 1, 0, 1, 0, 0], [0, 1, 0, 0, 1, 1, 0, 1, 0, 0]]\n    solution = Solution()\n    assert solution.closedIsland(grid) == 3", "31": "def test_closedIsland():\n\n    class Solution:\n\n        def closedIsland(self, grid):\n            m = len(grid)\n            n = len(grid[0])\n\n            def dfs(i: int, j: int) -> None:\n                if i < 0 or i == m or j < 0 or (j == n):\n                    return\n                if grid[i][j] == 1:\n                    return\n                grid[i][j] = 1\n                dfs(i + 1, j)\n                dfs(i - 1, j)\n                dfs(i, j + 1)\n                dfs(i, j - 1)\n            for i in range(m):\n                for j in range(n):\n                    if i * j == 0 or i == m - 1 or j == n - 1:\n                        if grid[i][j] == 0:\n                            dfs(i, j)\n            ans = 0\n            for i in range(m):\n                for j in range(n):\n                    if grid[i][j] == 0:\n                        dfs(i, j)\n                        ans += 1\n            return ans\n    solution = Solution()\n    assert solution.closedIsland([[1, 1, 1, 1, 1], [1, 0, 0, 0, 1], [1, 0, 1, 0, 1], [1, 0, 0, 0, 1], [1, 1, 1, 1, 1]]) == 3", "32": "def test_closedIsland():\n    solution = Solution()\n    grid = [[1, 0, 0], [0, 1, 0], [0, 0, 0]]\n    assert solution.closedIsland(grid) == 1", "39": "def test_closedIsland():\n    grid = [[0, 1, 0, 1], [1, 1, 1, 1], [0, 1, 0, 1]]\n    assert solution.closedIsland(grid) == 1", "40": "def test_closedIsland(self):\n    solution = Solution()\n    grid = [[0, 0, 1], [1, 0, 1], [1, 1, 0]]\n    self.assertEqual(solution.closedIsland(grid), 1)"}}
{"task_num": 1263, "task_title": "Minimum Moves to Move a Box to Their Target Location", "func_name": "minPushBox", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\nfrom collections import deque\n\nclass Solution:\n  def minPushBox(self, grid: List[List[str]]) -> int:\n    for i in range(len(grid)):\n      for j in range(len(grid[0])):\n        if grid[i][j] == \"T\":\n          target = (i,j)\n        if grid[i][j] == \"B\":\n          box = (i,j)\n        if grid[i][j] == \"S\":\n          person = (i,j)\n\n    def valid(x,y):\n      return 0<=x<len(grid) and 0<=y<len(grid[0]) and grid[x][y]!='#'\n\n    def check(curr,dest,box):\n      que = deque([curr])\n      v = set()\n      while que:\n        pos = que.popleft()\n        if pos == dest: \n          return True\n        new_pos = [(pos[0]+1,pos[1]),(pos[0]-1,pos[1]),(pos[0],pos[1]+1),(pos[0],pos[1]-1)]\n        for x,y in new_pos:\n          if valid(x,y) and (x,y) not in v and (x,y)!=box:\n            v.add((x,y))\n            que.append((x,y))\n      return False\n\n    q = deque([(0,box,person)])\n    vis = {box+person}\n    while q :\n      dist, box, person = q.popleft()\n      if box == target:\n        return dist\n\n      b_coord = [(box[0]+1,box[1]),(box[0]-1,box[1]),(box[0],box[1]+1),(box[0],box[1]-1)]\n      p_coord = [(box[0]-1,box[1]),(box[0]+1,box[1]),(box[0],box[1]-1),(box[0],box[1]+1)]\n\n      for new_box,new_person in zip(b_coord,p_coord): \n        if valid(*new_box) and new_box+box not in vis:\n          if valid(*new_person) and check(person,new_person,box):\n            vis.add(new_box+box)\n            q.append((dist+1,new_box,box))\n\n    return -1\n", "tests": {"17": "def test_minPushBox(self):\n    grid = [['S', '.', '#', '.'], ['#', '.', '.', 'T'], ['#', '.', '.', '#'], ['.', '.', '.', '.']]\n    self.assertEqual(solution.minPushBox(grid), 3)", "19": "def test_minPushBox():\n    grid = [['S', '.', '#', '#'], ['.', '#', '.', '.'], ['#', 'B', '.', 'T']]\n    print(solution.minPushBox(grid))", "21": "def test_minPushBox(self):\n    grid = [['S', '.', '.', '.'], ['#', '#', '#', '#'], ['B', '#', 'T', '.']]\n    self.assertEqual(solution.minPushBox(grid), 3)", "32": "def test_minPushBox():\n\n    def valid(x, y):\n        return 0 <= x < 3 and 0 <= y < 3 and (grid[x][y] != '#')\n\n    class Solution:\n\n        def minPushBox(self, grid: List[List[str]]) -> int:\n            global grid\n            grid = [['.', '.', '#'], ['S', 'B', '.'], ['#', 'T', '.']]\n            return self.minPushBox(grid)\n    solution = Solution()\n    assert solution.minPushBox([['.', '.', '#'], ['S', 'B', '.'], ['#', 'T', '.']]) == 3", "36": "def test_minPushBox(self):\n    grid = [['S', '#', '.', '#'], ['.', '.', '.', '.'], ['#', '.', '.', '.'], ['.', '#', 'B', '#'], ['.', '.', '.', '.'], ['.', '.', '.', '.'], ['.', '.', '.', '.']]\n    self.assertEqual(solution.minPushBox(grid), 3)", "37": "def test_minPushBox():\n\n    class Solution:\n\n        def minPushBox(self, grid):\n            if len(grid) == 1 and len(grid[0]) == 1:\n                return -1\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == 'T':\n                        target = (i, j)\n                    if grid[i][j] == 'B':\n                        box = (i, j)\n                    if grid[i][j] == 'S':\n                        person = (i, j)\n\n            def valid(x, y):\n                return 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != '#')\n\n            def check(curr, dest, box):\n                que = deque([curr])\n                v = set()\n                while que:\n                    pos = que.popleft()\n                    if pos == dest:\n                        return True\n                    new_pos = [(pos[0] + 1, pos[1]), (pos[0] - 1, pos[1]), (pos[0], pos[1] + 1), (pos[0], pos[1] - 1)]\n                    for (x, y) in new_pos:\n                        if valid(x, y) and (x, y) not in v and ((x, y) != box):\n                            v.add((x, y))\n                            que.append((x, y))\n                return False\n            q = deque([(0, box, person)])\n            vis = {box + person}\n            while q:\n                (dist, box, person) = q.popleft()\n                if box == target:\n                    return dist\n                b_coord = [(box[0] + 1, box[1]), (box[0] - 1, box[1]), (box[0], box[1] + 1), (box[0], box[1] - 1)]\n                p_coord = [(box[0] - 1, box[1]), (box[0] + 1, box[1]), (box[0], box[1] - 1), (box[0], box[1] + 1)]\n                for (new_box, new_person) in zip(b_coord, p_coord):\n                    if valid(*new_box) and new_box + box not in vis:\n                        if valid(*new_person) and check(person, new_person, box):\n                            vis.add(new_box + box)\n                            q.append((dist + 1, new_box, box))\n            return -1\n    solution = Solution()\n    grid = [['S', '#', '.', '.'], ['#', 'B', '.', 'T'], ['.', '.', '.', '.']]\n    assert solution.minPushBox(grid) == 3", "45": "def test_minPushBox():\n    grid = [['S', '.', '#'], ['#', '.', 'B'], ['#', '.', 'T']]\n    assert solution.minPushBox(grid) == 3, 'Test case failed'", "52": "def test_minPushBox(self):\n    grid = [['T', '.', '.', '.'], ['#', '.', '#', '.'], ['.', '.', '.', 'B'], ['.', '.', '.', 'S']]\n    solution = Solution()\n    self.assertEqual(solution.minPushBox(grid), 3)", "53": "def test_minPushBox():\n    grid = [['S', '#', '.', '.'], ['#', 'T', 'B', '#'], ['#', '.', '#', '.']]\n    assert solution.minPushBox(grid) == 3, 'Expected minimum number of pushes is 3'", "54": "def test_minPushBox(self):\n    grid = [['#', '#', 'B', '.'], ['S', '#', '.', '.'], ['.', '#', '#', 'T']]\n    self.assertEqual(solution.minPushBox(grid), 3)"}}
{"task_num": 1267, "task_title": "Count Servers that Communicate", "func_name": "countServers", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countServers(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    ans = 0\n    rows = [0] * m\n    cols = [0] * n\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1:\n          rows[i] += 1\n          cols[j] += 1\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1 and (rows[i] > 1 or cols[j] > 1):\n          ans += 1\n\n    return ans\n", "tests": {"22": "def test_countServers():\n    grid = [[1, 0], [0, 1]]\n    assert solution.countServers(grid) == 2", "23": "def test_countServers():\n    grid = [[0, 1], [0, 0]]\n    assert solution.countServers(grid) == 1", "28": "def test_countServers(self):\n    grid = [[1, 0], [0, 1]]\n    self.assertEqual(solution.countServers(grid), 2)"}}
{"task_num": 1284, "task_title": "Minimum Number of Flips to Convert Binary Matrix to Zero Matrix", "func_name": "minFlips", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minFlips(self, mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    hash = self._getHash(mat, m, n)\n    if hash == 0:\n      return 0\n\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    step = 0\n    q = collections.deque([hash])\n    seen = {hash}\n\n    while q:\n      step += 1\n      for _ in range(len(q)):\n        curr = q.popleft()\n        for i in range(m):\n          for j in range(n):\n            next = curr ^ 1 << (i * n + j)\n            for dx, dy in dirs:\n              x = i + dx\n              y = j + dy\n              if x < 0 or x == m or y < 0 or y == n:\n                continue\n              next ^= 1 << (x * n + y)\n            if next == 0:\n              return step\n            if next in seen:\n              continue\n            q.append(next)\n            seen.add(next)\n\n    return -1\n\n  def _getHash(self, mat: List[List[int]], m: int, n: int) -> int:\n    hash = 0\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j]:\n          hash |= 1 << (i * n + j)\n    return hash\n", "tests": {"17": "def test_minFlips():\n\n    def _getHash(mat):\n        m = len(mat)\n        n = len(mat[0])\n        hash = 0\n        for i in range(m):\n            for j in range(n):\n                if mat[i][j]:\n                    hash |= 1 << i * n + j\n        return hash\n    solution = Solution()\n    print(solution.minFlips([[1]]))", "35": "def test_minFlips(self):\n    solution = Solution()\n    mat = [[0, 1, 0], [0, 0, 1], [1, 0, 0]]\n    self.assertEqual(solution.minFlips(mat), 3)", "38": "def test_minFlips(self):\n\n    class Solution:\n\n        def minFlips(self, mat):\n            m = len(mat)\n            n = len(mat[0])\n            hash = self._getHash(mat, m, n)\n            if hash == 0:\n                return 0\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            step = 0\n            q = collections.deque([hash])\n            seen = {hash}\n            while q:\n                step += 1\n                for _ in range(len(q)):\n                    curr = q.popleft()\n                    for i in range(m):\n                        for j in range(n):\n                            next = curr ^ 1 << i * n + j\n                            for (dx, dy) in dirs:\n                                x = i + dx\n                                y = j + dy\n                                if x < 0 or x == m or y < 0 or (y == n):\n                                    continue\n                                next ^= 1 << x * n + y\n                            if next == 0:\n                                return step\n                            if next in seen:\n                                continue\n                            q.append(next)\n                            seen.add(next)\n            return -1\n\n        def _getHash(self, mat, m, n):\n            hash = 0\n            for i in range(m):\n                for j in range(n):\n                    if mat[i][j]:\n                        hash |= 1 << i * n + j\n            return hash\n    solution = Solution()\n    mat = [[0, 1], [1, 0]]\n    self.assertEqual(solution.minFlips(mat), 1)", "40": "def test_minFlips():\n\n    class Solution:\n\n        def minFlips(self, mat):\n            m = len(mat)\n            n = len(mat[0])\n            hash = self._getHash(mat, m, n)\n            if hash == 0:\n                return 0\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            step = 0\n            q = collections.deque([hash])\n            seen = {hash}\n            while q:\n                step += 1\n                for _ in range(len(q)):\n                    curr = q.popleft()\n                    for i in range(m):\n                        for j in range(n):\n                            next = curr ^ 1 << i * n + j\n                            for (dx, dy) in dirs:\n                                x = i + dx\n                                y = j + dy\n                                if x < 0 or x == m or y < 0 or (y == n):\n                                    continue\n                                next ^= 1 << x * n + y\n                            if next == 0:\n                                return step\n                            if next in seen:\n                                return -2\n                            q.append(next)\n                            seen.add(next)\n            return -1\n\n        def _getHash(self, mat, m, n):\n            hash = 0\n            for i in range(m):\n                for j in range(n):\n                    if mat[i][j]:\n                        hash |= 1 << i * n + j\n            return hash\n    solution = Solution()\n    assert solution.minFlips([[0]]) == -2", "51": "def test_minFlips():\n    def test_mat(mat):"}}
{"task_num": 1293, "task_title": "Shortest Path in a Grid with Obstacles Elimination", "func_name": "shortestPath", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def shortestPath(self, grid: List[List[int]], k: int) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    if m == 1 and n == 1:\n      return 0\n\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    steps = 0\n    q = collections.deque([(0, 0, k)])\n    seen = {(0, 0, k)}\n\n    while q:\n      steps += 1\n      for _ in range(len(q)):\n        i, j, eliminate = q.popleft()\n        for l in range(4):\n          x = i + dirs[l][0]\n          y = j + dirs[l][1]\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if x == m - 1 and y == n - 1:\n            return steps\n          if grid[x][y] == 1 and eliminate == 0:\n            continue\n          newEliminate = eliminate - grid[x][y]\n          if (x, y, newEliminate) in seen:\n            continue\n          q.append((x, y, newEliminate))\n          seen.add((x, y, newEliminate))\n\n    return -1\n", "tests": {"16": "def test_shortestPath():\n\n    class Solution:\n\n        def shortestPath(self, grid, k):\n            m = len(grid)\n            n = len(grid[0])\n            if m == 1 and n == 1:\n                return 0\n    solution = Solution()\n    assert solution.shortestPath([[0], [0]], 0) == 0", "31": "def test_shortestPath():\n\n    class Solution:\n\n        def shortestPath(self, grid: List[List[int]], k: int) -> int:\n            m = len(grid)\n            n = len(grid[0])\n            if m == 1 and n == 1:\n                return 0\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            steps = 0\n            q = collections.deque([(0, 0, k)])\n            seen = {(0, 0, k)}\n            while q:\n                steps += 1\n                for _ in range(len(q)):\n                    (i, j, eliminate) = q.popleft()\n                    for l in range(4):\n                        x = i + dirs[l][0]\n                        y = j + dirs[l][1]\n                        if (x < 0 or x == m or y < 0 or (y == n)) or (grid[x][y] == 1 and eliminate == 0):\n                            continue\n                        newEliminate = eliminate - grid[x][y]\n                        if (x, y, newEliminate) in seen:\n                            continue\n                        q.append((x, y, newEliminate))\n                        seen.add((x, y, newEliminate))\n                return steps\n    solution = Solution()\n    print(solution.shortestPath([[0, 1, 1], [1, 0, 0], [0, 0, 0]], 2))", "33": "def test_shortestPath():\n\n    class Solution:\n\n        def shortestPath(self, grid, k):\n            m = len(grid)\n            n = len(grid[0])\n            if m == 1 and n == 1:\n                return 0\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            steps = 0\n            q = collections.deque([(0, 0, k)])\n            seen = {(0, 0, k)}\n            while q:\n                steps += 1\n                for _ in range(len(q)):\n                    (i, j, eliminate) = q.popleft()\n                    for l in range(4):\n                        x = i + dirs[l][0]\n                        y = j + dirs[l][1]\n                        if x < 0 or x == m or y < 0 or (y == n):\n                            continue\n                        if x == m - 1 and y == n - 1:\n                            return steps\n                        if grid[x][y] == 1 and eliminate == 0:\n                            continue\n                        newEliminate = eliminate - grid[x][y]\n                        if (x, y, newEliminate) in seen:\n                            continue\n                        q.append((x, y, newEliminate))\n                        seen.add((x, y, newEliminate))\n            return -1\n    solution = Solution()\n    print(solution.shortestPath([[0, 0, 0], [0, 0, 0]], 2))", "35": "def test_shortestPath():\n\n    class Solution:\n\n        def shortestPath(self, grid, k):\n            m = len(grid)\n            n = len(grid[0])\n            if m == 1 and n == 1:\n                return 0\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            steps = 0\n            q = [(0, 0, k)]\n            seen = {(0, 0, k)}\n            while q:\n                steps += 1\n                for _ in range(len(q)):\n                    (i, j, eliminate) = q.pop(0)\n                    for l in range(4):\n                        x = i + dirs[l][0]\n                        y = j + dirs[l][1]\n                        if x < 0 or x == m or y < 0 or (y == n):\n                            continue\n                        if x == m - 1 and y == n - 1:\n                            return steps\n                        if grid[x][y] == 1 and eliminate == 0:\n                            q.append((x, y, k))\n                            seen.add((x, y, k))\n                            continue\n                        newEliminate = eliminate - grid[x][y]\n                        if (x, y, newEliminate) in seen:\n                            continue\n                        q.append((x, y, newEliminate))\n                        seen.add((x, y, newEliminate))\n            return -1\n    solution = Solution()\n    print(solution.shortestPath([[0, 0, 0], [0, 0, 0], [0, 0, 0]], 2))", "38": "def test_shortestPath(self):\n    grid = [[0, 1], [1, 0]]\n    k = 1\n    self.assertEqual(solution.shortestPath(grid, k), 2)"}}
{"task_num": 1301, "task_title": "Number of Paths with Max Score", "func_name": "pathsWithMaxScore", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def pathsWithMaxScore(self, board: List[str]) -> List[int]:\n    kMod = 1_000_000_007\n    n = len(board)\n    dirs = ((0, 1), (1, 0), (1, 1))\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    count = [[0] * (n + 1) for _ in range(n + 1)]\n\n    dp[0][0] = 0\n    dp[n - 1][n - 1] = 0\n    count[n - 1][n - 1] = 1\n\n    for i in reversed(range(n)):\n      for j in reversed(range(n)):\n        if board[i][j] == 'S' or board[i][j] == 'X':\n          continue\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if dp[i][j] < dp[x][y]:\n            dp[i][j] = dp[x][y]\n            count[i][j] = count[x][y]\n          elif dp[i][j] == dp[x][y]:\n            count[i][j] += count[x][y]\n            count[i][j] %= kMod\n\n        if dp[i][j] != -1 and board[i][j] != 'E':\n          dp[i][j] += int(board[i][j])\n          dp[i][j] %= kMod\n\n    return [dp[0][0], count[0][0]]\n", "tests": {"26": "def test_pathsWithMaxScore():\n\n    class Solution:\n\n        def pathsWithMaxScore(self, board):\n            kMod = 1000000007\n            n = len(board)\n            dirs = ((0, 1), (1, 0), (1, 1))\n            dp = [[-1] * (n + 1) for _ in range(n + 1)]\n            count = [[0] * (n + 1) for _ in range(n + 1)]\n            dp[0][0] = 0\n            dp[n - 1][n - 1] = 0\n            count[n - 1][n - 1] = 1\n            board = [['S', '3', '2', '0'], ['0', 'X', '9', '5'], ['8', '4', 'C', 'E']]\n            for i in reversed(range(n)):\n                for j in reversed(range(n)):\n                    if board[i][j] == 'S' or board[i][j] == 'X':\n                        continue\n                    for (dx, dy) in dirs:\n                        x = i + dx\n                        y = j + dy\n                        if dp[i][j] < dp[x][y]:\n                            dp[i][j] = dp[x][y]\n                            count[i][j] = count[x][y]\n                        elif dp[i][j] == dp[x][y]:\n                            count[i][j] += count[x][y]\n                            count[i][j] %= kMod\n                    if dp[i][j] != -1 and board[i][j] != 'E':\n                        dp[i][j] += int(board[i][j])\n                        dp[i][j] %= kMod\n            return [dp[0][0], count[0][0]]\n    solution = Solution()\n    print(solution.pathsWithMaxScore(['E', '2', '6', '3']))", "31": "def test_pathsWithMaxScore():\n\n    class Solution:\n\n        def pathsWithMaxScore(self, board):\n            kMod = 1000000007\n            n = len(board)\n            dirs = ((0, 1), (1, 0), (1, 1))\n            dp = [[-1] * (n + 1) for _ in range(n + 1)]\n            count = [[0] * (n + 1) for _ in range(n + 1)]\n            dp[0][0] = 0\n            dp[n - 1][n - 1] = 0\n            count[n - 1][n - 1] = 1\n            for i in reversed(range(n)):\n                for j in reversed(range(n)):\n                    if board[i][j] == 'S' or board[i][j] == 'X':\n                        continue\n                    for (dx, dy) in dirs:\n                        x = i + dx\n                        y = j + dy\n                        if dp[i][j] < dp[x][y]:\n                            dp[i][j] = dp[x][y]\n                            count[i][j] = count[x][y]\n                        elif dp[i][j] == dp[x][y]:\n                            count[i][j] += count[x][y]\n                            count[i][j] %= kMod\n                    if dp[i][j] != -1 and board[i][j] != 'E':\n                        dp[i][j] += int(board[i][j])\n                        dp[i][j] %= kMod\n            return [dp[0][0], count[0][0]]\n    solution = Solution()", "32": "def test_pathsWithMaxScore(self):\n\n    class Solution:\n\n        def pathsWithMaxScore(self, board: List[str]) -> List[int]:\n            kMod = 1000000007\n            n = len(board)\n            dirs = ((0, 1), (1, 0), (1, 1))\n            dp = [[-1] * (n + 1) for _ in range(n + 1)]\n            count = [[0] * (n + 1) for _ in range(n + 1)]\n            board = [['S', '9', '7'], ['8', '5', '6'], ['4', '.', '.']]\n            solution = Solution()\n            result = solution.pathsWithMaxScore(board)", "34": "def test_pathsWithMaxScore():\n\n    class Solution:\n\n        def pathsWithMaxScore(self, board):\n            kMod = 1000000007\n            n = len(board)\n            dirs = ((0, 1), (1, 0), (1, 1))\n            dp = [[-1] * (n + 1) for _ in range(n + 1)]\n            count = [[0] * (n + 1) for _ in range(n + 1)]\n            board = [['S', 'E'], ['.X', '.']]\n            dp[0][0] = 0\n            dp[n - 1][n - 2] = 5\n            count[n - 1][n - 2] = 1\n            for i in reversed(range(n)):\n                for j in reversed(range(n)):\n                    if board[i][j] == 'S' or board[i][j] == 'X':\n                        continue\n                    for (dx, dy) in dirs:\n                        x = i + dx\n                        y = j + dy\n                        if dp[i][j] < dp[x][y]:\n                            dp[i][j] = dp[x][y]\n                            count[i][j] = count[x][y]\n                        elif dp[i][j] == dp[x][y]:\n                            count[i][j] += count[x][y]\n                            count[i][j] %= kMod\n                    if dp[i][j] != -1 and board[i][j] != 'E':\n                        dp[i][j] += int(board[i][j])\n                        dp[i][j] %= kMod\n            return [dp[0][0], count[0][0]]\n    solution = Solution()\n    print(solution.pathsWithMaxScore([]))", "35": "def test_pathsWithMaxScore():\n\n    class Solution:\n\n        def pathsWithMaxScore(self, board):\n            kMod = 1000000007\n            n = len(board)\n            dirs = ((0, 1), (1, 0), (1, 1))\n            dp = [[-1] * (n + 1) for _ in range(n + 1)]\n            count = [[0] * (n + 1) for _ in range(n + 1)]\n            board = [['S', 'X', 'X', 'X'], ['X', 'E', '8', '4'], ['X', '3', '5', '2'], ['X', '6', '9', '7']]\n            dp[0][0] = 0\n            dp[n - 1][n - 1] = 0\n            count[n - 1][n - 1] = 1\n            for i in reversed(range(n)):\n                for j in reversed(range(n)):\n                    if board[i][j] == 'S' or board[i][j] == 'X':\n                        continue\n                    for (dx, dy) in dirs:\n                        x = i + dx\n                        y = j + dy\n                        if dp[i][j] < dp[x][y]:\n                            dp[i][j] = dp[x][y]\n                            count[i][j] = count[x][y]\n                        elif dp[i][j] == dp[x][y]:\n                            count[i][j] += count[x][y]\n                            count[i][j] %= kMod\n                    if dp[i][j] != -1 and board[i][j] != 'E':\n                        dp[i][j] += int(board[i][j])\n                        dp[i][j] %= kMod\n            return [dp[0][0], count[0][0]]\n    solution = Solution()", "38": "def test_pathsWithMaxScore(self):\n    board = ['E', '.X', 'S1']\n    self.assertEqual(solution.pathsWithMaxScore(board), [0, 0])", "39": "def test_pathsWithMaxScore(self):\n\n    class SolutionMock:\n\n        def pathsWithMaxScore(self, board: List[str]) -> List[int]:\n            kMod = 1000000007\n            dp = [[0] * (n + 1) for _ in range(n + 1)]\n            count = [[0] * (n + 1) for _ in range(n + 1)]\n            board = [['S', 'X', '2'], ['9', '3', '5'], ['1', 'E', '8']]\n            n = len(board)\n            return [dp[0][0], count[0][0]]\n    solution = SolutionMock()\n    self.assertEqual(solution.pathsWithMaxScore([['9', '8', '7'], ['6', '5', '4'], ['2', '1', 'S']]), [19, 3])"}}
{"task_num": 1334, "task_title": "Find the City With the Smallest Number of Neighbors at a Threshold Distance", "func_name": "findTheCity", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -> int:\n    ans = -1\n    minCitiesCount = n\n    dist = self._floydWarshall(n, edges, distanceThreshold)\n\n    for i in range(n):\n      citiesCount = sum(dist[i][j] <= distanceThreshold for j in range(n))\n      if citiesCount <= minCitiesCount:\n        ans = i\n        minCitiesCount = citiesCount\n\n    return ans\n\n  def _floydWarshall(self, n: int, edges: List[List[int]], distanceThreshold: int) -> List[List[int]]:\n    dist = [[distanceThreshold + 1] * n for _ in range(n)]\n\n    for i in range(n):\n      dist[i][i] = 0\n\n    for u, v, w in edges:\n      dist[u][v] = w\n      dist[v][u] = w\n\n    for k in range(n):\n      for i in range(n):\n        for j in range(n):\n          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    return dist\n", "tests": {"20": "def test_findTheCity():\n    solution = Solution()\n\n    def assertFindTheCity(city_count, distance_threshold):\n        result = solution.findTheCity(2, [[0, 1, 5], [1, 2, 3]], distance_threshold)", "21": "def test_findTheCity():\n\n    class Solution:\n\n        def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -> int:\n            ans = -1\n            minCitiesCount = 0\n            dist = self._floydWarshall(n, edges, distanceThreshold)\n            for i in range(n):\n                citiesCount = sum((dist[i][j] <= distanceThreshold + 1 for j in range(n)))\n                if citiesCount < minCitiesCount:\n                    ans = i\n                    minCitiesCount = citiesCount\n            return ans\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 2], [1, 2, 4], [1, 3, 6]]\n    distanceThreshold = 4\n    assert solution.findTheCity(n, edges, distanceThreshold) == 1"}}
{"task_num": 1340, "task_title": "Jump Game V", "func_name": "maxJumps", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxJumps(self, arr: List[int], d: int) -> int:\n    n = len(arr)\n    dp = [1] * n\n    stack = []\n\n    for i in range(n + 1):\n      while stack and (i == n or arr[stack[-1]] < arr[i]):\n        indices = [stack.pop()]\n        while stack and arr[stack[-1]] == arr[indices[0]]:\n          indices.append(stack.pop())\n        for j in indices:\n          if i < n and i - j <= d:\n            dp[i] = max(dp[i], dp[j] + 1)\n          if stack and j - stack[-1] <= d:\n            dp[stack[-1]] = max(dp[stack[-1]], dp[j] + 1)\n      stack.append(i)\n\n    return max(dp)\n", "tests": {"24": "def test_maxJumps(self):\n\n    class Solution:\n\n        def maxJumps(self, arr: List[int], d: int) -> int:\n            n = len(arr)\n            dp = [1] * n\n            stack = []\n            for i in range(n + 1):\n                while stack and (i == n or arr[stack[-1]] < arr[i]):\n                    indices = [stack.pop()]\n                    while stack and arr[stack[-1]] == arr[indices[0]]:\n                        indices.append(stack.pop())\n                    for j in indices:\n                        if i < n and i - j <= d:\n                            dp[i] = max(dp[i], dp[j] + 1)\n                        if stack and j - stack[-1] <= d:\n                            dp[stack[-1]] = max(dp[stack[-1]], dp[j] + 1)\n                    stack.append(i)\n            return max(dp)\n    solution = Solution()\n    self.assertEqual(solution.maxJumps([5, 3, 3, 8, 1, 9], 2), 4)", "26": "def test_maxJumps():\n\n    class Solution:\n\n        def maxJumps(self, arr: List[int], d: int) -> int:\n            n = len(arr)\n            dp = [1] * n\n            stack = []\n            for i in range(n + 1):\n                while stack and (i == n or arr[stack[-1]] < arr[i]):\n                    indices = [stack.pop()]\n                    while stack and arr[stack[-1]] == arr[indices[0]]:\n                        indices.append(stack.pop())\n                    for j in indices:\n                        if i < n and i - j <= d:\n                            dp[i] = max(dp[i], dp[j] + 1)\n                        if stack and j - stack[-1] <= d:\n                            dp[stack[-1]] = max(dp[stack[-1]], dp[j] + 1)\n                stack.append(i)\n            return max(dp)\n    solution = Solution()\n    print(solution.maxJumps([30, 10, 5, 10, 10, 20], 3))"}}
{"task_num": 1345, "task_title": "Jump Game IV", "func_name": "minJumps", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minJumps(self, arr: List[int]) -> int:\n    n = len(arr)\n    graph = collections.defaultdict(list)\n    step = 0\n    q = collections.deque([0])\n    seen = {0}\n\n    for i, a in enumerate(arr):\n      graph[a].append(i)\n\n    while q:\n      for _ in range(len(q)):\n        i = q.popleft()\n        if i == n - 1:\n          return step\n        seen.add(i)\n        u = arr[i]\n        if i + 1 < n:\n          graph[u].append(i + 1)\n        if i - 1 >= 0:\n          graph[u].append(i - 1)\n        for v in graph[u]:\n          if v in seen:\n            continue\n          q.append(v)\n        graph[u].clear()\n      step += 1\n", "tests": {"26": "def test_minJumps(self):\n    solution = Solution()\n    self.assertEqual(solution.minJumps([100, -1, 0, 7, 3, -1, 5]), 4)", "30": "def test_minJumps():\n\n    class Solution:\n\n        def minJumps(self, arr):\n            n = len(arr)\n            graph = collections.defaultdict(list)\n            step = 0\n            q = collections.deque([0])\n            seen = {0}\n            for (i, a) in enumerate(arr):\n                graph[a].append(i)\n            while q:\n                for _ in range(len(q)):\n                    i = q.popleft()\n                    if i == n - 1:\n                        return step\n                    seen.add(i)\n                    u = arr[i]\n                    if i + 1 < n and i not in [j for v in graph[u] for j in graph[v]]:\n                        graph[u].append(i + 1)\n                    if i - 1 >= 0 and i - 1 not in [j for v in graph[u] for j in graph[v]]:\n                        graph[u].append(i - 1)\n                    for v in graph[u]:\n                        if v in seen:\n                            continue\n                        q.append(v)\n                    graph[u].clear()\n                step += 1\n            return -1\n    solution = Solution()\n    assert solution.minJumps([100, -23, -19, 18, 18, 18, 18, 18, 10]) == 2", "32": "def test_minJumps(self):\n    arr = [100, -23, -19, 34, 24, 70, 60]\n    self.assertEqual(solution.minJumps(arr), 3)", "35": "def test_minJumps():\n    solution = Solution()\n    arr = [1, 2, 3, 4, 5]\n    assert solution.minJumps(arr) == 4, 'Test case for line 35: continue'"}}
{"task_num": 1377, "task_title": "Frog Position After T Seconds", "func_name": "frogPosition", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n    tree = [[] for _ in range(n + 1)]\n    q = collections.deque([1])\n    seen = [False] * (n + 1)\n    prob = [0] * (n + 1)\n\n    prob[1] = 1\n    seen[1] = True\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    for _ in range(t):\n      for _ in range(len(q)):\n        a = q.popleft()\n        nChildren = sum(not seen[b] for b in tree[a])\n        for b in tree[a]:\n          if seen[b]:\n            continue\n          seen[b] = True\n          prob[b] = prob[a] / nChildren\n          q.append(b)\n        if nChildren > 0:\n          prob[a] = 0\n\n    return prob[target]\n", "tests": {"31": "def test_frogPosition():\n\n    def helper(n, edges, t, target):\n        tree = [[] for _ in range(n + 1)]\n        q = collections.deque([1])\n        seen = [False] * (n + 1)\n        prob = [0.0] * (n + 1)\n        prob[1] = 1\n        seen[1] = True\n        for (u, v) in edges:\n            tree[u].append(v)\n            tree[v].append(u)\n\n        def dfs(a):\n            nChildren = sum((not seen[b] for b in tree[a]))\n            if nChildren == 0 and a != target:\n                return 0\n            for b in tree[a]:\n                if not seen[b]:\n                    prob[b] = prob[a] / nChildren\n                    seen[b] = True\n                    dfs(b)\n            return prob[a]\n        return dfs(target)\n    solution = Solution()\n    assert abs(helper(8, [[3, 4], [2, 1]], 5, 2) - solution.frogPosition(8, [[3, 4], [2, 1]], 5, 2)) < 1e-05", "36": "def test_frogPosition(self):\n    class Solution:\n        def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n            # implementation here...\n\n    solution = Solution()\n    self.assertAlmostEqual(solution.frogPosition(2, [[1, 2], [2, 3]], 0, 1), 1.00000)"}}
{"task_num": 1417, "task_title": "Reformat The String", "func_name": "reformat", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def reformat(self, s: str) -> str:\n    A=[]\n    for c in s:\n      if c.isalpha():\n        A.append(c)\n    B=[]\n    for c in s:\n      if c.isdigit():\n        B.append(c)\n\n    if len(A) < len(B):\n      A, B = B, A\n    if len(A) - len(B) > 1:\n      return ''\n\n    ans = []\n\n    for i in range(len(B)):\n      ans.append(A[i])\n      ans.append(B[i])\n\n    if len(A) == len(B) + 1:\n      ans.append(A[-1])\n    return ''.join(ans)\n", "tests": {"16": "def test_reformat():\n    solution = Solution()\n    result = solution.reformat('123')", "20": "def test_reformat():\n\n    def assert_equals(a, b):\n        return a == b\n    s = '1234567890'\n    result = solution.reformat(s)", "23": "def test_reformat():\n\n    def reformat(s: str) -> str:\n        A = []\n        for c in s:\n            if c.isalpha():\n                A.append(c)\n        B = []\n        for c in s:\n            if c.isdigit():\n                B.append(c)\n        if len(A) < len(B):\n            (A, B) = (B, A)\n        if len(A) - len(B) > 1:\n            return ''\n        ans = []\n        for i in range(len(B)):\n            ans.append(A[i])\n            ans.append(B[i])\n        if len(A) == len(B) + 1:\n            ans.append(A[-1])\n        return ''.join(ans)\n    solution = Solution()\n    assert reformat('abc123def456') == 'a4b3c2d1e5f6'", "25": "def test_reformat(self):\n    solution = Solution()\n    self.assertEqual(solution.reformat('a1b2c3'), 'abc123')", "34": "def test_reformat():\n    solution = Solution()\n    assert solution.reformat('a0b1c2') == '01Abc'"}}
{"task_num": 1462, "task_title": "Course Schedule IV", "func_name": "checkIfPrerequisite", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:\n    graph = [[] for _ in range(numCourses)]\n    isPrerequisite = [[False] * numCourses for _ in range(numCourses)]\n\n    for u, v in prerequisites:\n      graph[u].append(v)\n\n    for i in range(numCourses):\n      self._dfs(graph, i, isPrerequisite[i])\n\n    return [isPrerequisite[u][v] for u, v in queries]\n\n  def _dfs(self, graph: List[List[int]], u: int, used: List[bool]) -> None:\n    for v in graph[u]:\n      if used[v]:\n        continue\n      used[v] = True\n      self._dfs(graph, v, used)\n", "tests": {"27": "def test_checkIfPrerequisite():\n    solution = Solution()\n    numCourses = 4\n    prerequisites = [[0, 1], [1, 2], [2, 3]]\n    queries = [[0, 1], [1, 3], [4, 0]]\n    answer = [True, True, False]\n    assert solution.checkIfPrerequisite(numCourses, prerequisites, queries) == answer"}}
{"task_num": 1489, "task_title": "Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree", "func_name": "findCriticalAndPseudoCriticalEdges", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Union\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n    criticalEdges = []\n    pseudoCriticalEdges = []\n\n    for i in range(len(edges)):\n      edges[i].append(i)\n\n    edges.sort(key=lambda x: x[2])\n\n    def getMSTWeight(firstEdge: List[int], deletedEdgeIndex: int) -> Union[int, float]:\n      mstWeight = 0\n      uf = UnionFind(n)\n\n      if firstEdge:\n        uf.unionByRank(firstEdge[0], firstEdge[1])\n        mstWeight += firstEdge[2]\n\n      for u, v, weight, index in edges:\n        if index == deletedEdgeIndex:\n          continue\n        if uf.find(u) == uf.find(v):\n          continue\n        uf.unionByRank(u, v)\n        mstWeight += weight\n\n      root = uf.find(0)\n      if any(uf.find(i) != root for i in range(n)):\n        return math.inf\n\n      return mstWeight\n\n    mstWeight = getMSTWeight([], -1)\n\n    for edge in edges:\n      index = edge[3]\n      if getMSTWeight([], index) > mstWeight:\n        criticalEdges.append(index)\n      elif getMSTWeight(edge, -1) == mstWeight:\n        pseudoCriticalEdges.append(index)\n\n    return [criticalEdges, pseudoCriticalEdges]\n", "tests": {"20": "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 2], [1, 2, 3], [0, 2, 6]]\n    result = solution.findCriticalAndPseudoCriticalEdges(n, edges)", "22": "def test_findCriticalAndPseudoCriticalEdges():\n\n    def getMSTWeight(firstEdge: List[int], deletedEdgeIndex: int) -> Union[int, float]:\n        mstWeight = 0\n        uf = UnionFind(3)\n        if firstEdge:\n            uf.unionByRank(firstEdge[0], firstEdge[1])\n            mstWeight += firstEdge[2]\n        edges = [[0, 1, 1], [1, 2, 1], [0, 2, 2]]\n        for (u, v, weight, index) in edges:\n            if index == deletedEdgeIndex:\n                continue\n            if uf.find(u) == uf.find(v):\n                continue\n            uf.unionByRank(u, v)\n            mstWeight += weight\n        root = uf.find(0)\n        if any((uf.find(i) != root for i in range(3))):\n            return math.inf\n        return mstWeight\n    solution = Solution()\n    result = solution.findCriticalAndPseudoCriticalEdges(3, [[0, 1, 1], [1, 2, 1], [0, 2, 2]])", "24": "def test_findCriticalAndPseudoCriticalEdges():\n\n    class Solution:\n\n        def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n            criticalEdges = []\n            pseudoCriticalEdges = []\n            for i in range(len(edges)):\n                edges[i].append(i)\n            edges.sort(key=lambda x: x[2])\n\n            def getMSTWeight(firstEdge: List[int], deletedEdgeIndex: int) -> Union[int, float]:\n                mstWeight = 0\n                uf = UnionFind(n)\n                if firstEdge:\n                    uf.unionByRank(firstEdge[0], firstEdge[1])\n                    mstWeight += firstEdge[2]\n                for (u, v, weight, index) in edges:\n                    if index == deletedEdgeIndex:\n                        continue\n                    if uf.find(u) == uf.find(v):\n                        continue\n                    uf.unionByRank(u, v)\n                    mstWeight += weight\n                root = uf.find(0)\n                if any((uf.find(i) != root for i in range(n))):\n                    return math.inf\n                return mstWeight\n            mstWeight = getMSTWeight([], -1)\n            for edge in edges:\n                index = edge[3]\n                if getMSTWeight([], index) > mstWeight:\n                    criticalEdges.append(index)\n                elif getMSTWeight(edge, -1) == mstWeight:\n                    pseudoCriticalEdges.append(index)\n            return [criticalEdges, pseudoCriticalEdges]\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 2], [1, 2, 3], [2, 3, 1], [0, 3, 6]]\n    result = solution.findCriticalAndPseudoCriticalEdges(n, edges)", "26": "def test_findCriticalAndPseudoCriticalEdges():\n\n    def findCriticalAndPseudoCriticalEdges(self, n, edges):\n        criticalEdges = []\n        pseudoCriticalEdges = []\n        for i in range(len(edges)):\n            edges[i].append(i)\n        edges.sort(key=lambda x: x[2])\n\n        def getMSTWeight(firstEdge, deletedEdgeIndex):\n            mstWeight = 0\n            uf = UnionFind(n)\n            if firstEdge:\n                uf.unionByRank(firstEdge[0], firstEdge[1])\n                mstWeight += firstEdge[2]\n            for (u, v, weight, index) in edges:\n                if index == deletedEdgeIndex:\n                    continue\n                if uf.find(u) == uf.find(v):\n                    continue\n                uf.unionByRank(u, v)\n                mstWeight += weight\n            root = uf.find(0)\n            if any((uf.find(i) != root for i in range(n))):\n                return float('inf')\n            return mstWeight\n        mstWeight = getMSTWeight([], -1)\n        for edge in edges:\n            index = edge[3]\n            if getMSTWeight([], index) > mstWeight:\n                criticalEdges.append(index)\n            elif getMSTWeight(edge, -1) == mstWeight:\n                pseudoCriticalEdges.append(index)\n        return [criticalEdges, pseudoCriticalEdges]\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 2], [0, 3, 5], [1, 3, 8]]\n    print(solution.findCriticalAndPseudoCriticalEdges(n, edges))", "27": "def test_findCriticalAndPseudoCriticalEdges(self):\n\n    class Solution:\n\n        def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n            criticalEdges = []\n            pseudoCriticalEdges = []\n            for i in range(len(edges)):\n                edges[i].append(i)\n            edges.sort(key=lambda x: x[2])\n\n            def getMSTWeight(firstEdge: List[int], deletedEdgeIndex: int) -> Union[int, float]:\n                mstWeight = 0\n                uf = UnionFind(n)\n                if firstEdge:\n                    uf.unionByRank(firstEdge[0], firstEdge[1])\n                    mstWeight += firstEdge[2]\n                for (u, v, weight, index) in edges:\n                    if index == deletedEdgeIndex:\n                        continue\n                    if uf.find(u) == uf.find(v):\n                        continue\n                    uf.unionByRank(u, v)\n                    mstWeight += weight\n                root = uf.find(0)\n                if any((uf.find(i) != root for i in range(n))):\n                    return math.inf\n                return mstWeight\n            mstWeight = getMSTWeight([], -1)\n            for edge in edges:\n                index = edge[3]\n                if getMSTWeight([], index) > mstWeight:\n                    criticalEdges.append(index)\n                elif getMSTWeight(edge, -1) == mstWeight:\n                    pseudoCriticalEdges.append(index)\n            return [criticalEdges, pseudoCriticalEdges]\n    solution = Solution()\n    n = 4\n    edges = [[0, 2, 2], [1, 3, 3], [2, 3, 4]]\n    self.assertEqual(solution.findCriticalAndPseudoCriticalEdges(n, edges), [[0], []])", "31": "def test_findCriticalAndPseudoCriticalEdges():\n\n    class Solution:\n\n        def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n            criticalEdges = []\n            pseudoCriticalEdges = []\n            for i in range(len(edges)):\n                edges[i].append(i)\n            edges.sort(key=lambda x: x[2])\n\n            def getMSTWeight(firstEdge: List[int], deletedEdgeIndex: int) -> Union[int, float]:\n                mstWeight = 0\n                uf = UnionFind(n)\n                if firstEdge:\n                    uf.unionByRank(firstEdge[0], firstEdge[1])\n                    mstWeight += firstEdge[2]\n                for (u, v, weight, index) in edges:\n                    if index == deletedEdgeIndex:\n                        continue\n                    if uf.find(u) == uf.find(v):\n                        continue\n                    uf.unionByRank(u, v)\n                    mstWeight += weight\n                root = uf.find(0)\n                if any((uf.find(i) != root for i in range(n))):\n                    return math.inf\n                return mstWeight\n            mstWeight = getMSTWeight([], -1)\n            (edges[3][0], edges[4][1]) = (2, 5)\n            assert getMSTWeight(edges[3], -1) == mstWeight\n            pseudoCriticalEdges.append(3)\n            (edges[5][0], edges[6][1]) = (7, 9)\n            assert getMSTWeight(edges[5], -1) != mstWeight\n            criticalEdges.append(5)\n            return [criticalEdges, pseudoCriticalEdges]", "50": "def test_findCriticalAndPseudoCriticalEdges():\n    n = 3\n    edges = [[0, 1, 2], [0, 2, 5], [1, 2, 6]]\n    expected_critical = [1]\n    expected_pseudo_critical = []\n    assert solution.findCriticalAndPseudoCriticalEdges(n, edges) == [expected_critical, expected_pseudo_critical]", "51": "def test_findCriticalAndPseudoCriticalEdges(self):\n    n = 3\n    edges = [[0, 1, 2], [1, 2, 3], [0, 2, 6]]\n    solution = Solution()\n    result = solution.findCriticalAndPseudoCriticalEdges(n, edges)", "55": "def test_findCriticalAndPseudoCriticalEdges():\n\n    class Solution:\n\n        def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n            criticalEdges = []\n            pseudoCriticalEdges = []\n            for i in range(len(edges)):\n                edges[i].append(i)\n            edges.sort(key=lambda x: x[2])\n\n            def getMSTWeight(firstEdge: List[int], deletedEdgeIndex: int) -> Union[int, float]:\n                mstWeight = 0\n                uf = UnionFind(n)\n                if firstEdge:\n                    uf.unionByRank(firstEdge[0], firstEdge[1])\n                    mstWeight += firstEdge[2]\n                for (u, v, weight, index) in edges:\n                    if index == deletedEdgeIndex:\n                        continue\n                    if uf.find(u) == uf.find(v):\n                        continue\n                    uf.unionByRank(u, v)\n                    mstWeight += weight\n                root = uf.find(0)\n                if any((uf.find(i) != root for i in range(n))):\n                    return math.inf\n                return mstWeight\n            mstWeight = getMSTWeight([], -1)\n            edges[0][3] = 0\n            edges[0][2] = 0\n            assert getMSTWeight(edges[0], -1) == mstWeight\n            pseudoCriticalEdges.append(0)\n            return [criticalEdges, pseudoCriticalEdges]", "57": "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 2], [1, 2, 3], [0, 2, 5]]\n    result = solution.findCriticalAndPseudoCriticalEdges(n, edges)", "63": "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n\n    def check_critical_edge(index):\n        edges = [[0, 1, 2], [0, 2, 3], [1, 2, 1]]\n        edges[index].append(index)", "72": "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n\n    def getMSTWeight(firstEdge, deletedEdgeIndex):\n        mstWeight = 0\n        uf = UnionFind(4)\n        if firstEdge:\n            uf.unionByRank(firstEdge[0], firstEdge[1])\n            mstWeight += firstEdge[2]\n        edges = [[0, 1, 3], [0, 2, 5], [1, 3, 6]]\n        for (u, v, weight, index) in edges:\n            if index == deletedEdgeIndex:\n                continue\n            if uf.find(u) == uf.find(v):\n                continue\n            uf.unionByRank(u, v)\n            mstWeight += weight\n        root = uf.find(0)\n        if any((uf.find(i) != root for i in range(4))):\n            return float('inf')\n        return mstWeight\n    criticalEdges = []\n    pseudoCriticalEdges = []\n    edges = [[0, 1, 3], [0, 2, 5], [1, 3, 6]]\n    for edge in edges:\n        index = edge[3]\n        if getMSTWeight([], index) > mstWeight:\n            criticalEdges.append(index)\n        elif getMSTWeight(edge, -1) == mstWeight:\n            pseudoCriticalEdges.append(index)\n    assert solution.findCriticalAndPseudoCriticalEdges(4, edges) == [[2], [0]]", "74": "def test_findCriticalAndPseudoCriticalEdges(self):\n    n = 3\n    edges = [[0, 1, 2], [1, 2, 3], [0, 2, 5]]\n    solution = Solution()\n    result = solution.findCriticalAndPseudoCriticalEdges(n, edges)"}}
{"task_num": 1573, "task_title": "Number of Ways to Split a String", "func_name": "numWays", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numWays(self, s: str) -> int:\n    kMod = 1_000_000_007\n    ones = s.count('1')\n    if ones % 3 != 0:\n      return 0\n    if ones == 0:\n      n = len(s)\n      return (n - 1) * (n - 2) // 2 % kMod\n\n    s1End = -1\n    s2Start = -1\n    s2End = -1\n    s3Start = -1\n    onesSoFar = 0\n\n    for i, c in enumerate(s):\n      if c == '1':\n        onesSoFar += 1\n      if s1End == -1 and onesSoFar == ones // 3:\n        s1End = i\n      elif s2Start == -1 and onesSoFar == ones // 3 + 1:\n        s2Start = i\n      if s2End == -1 and onesSoFar == ones // 3 * 2:\n        s2End = i\n      elif s3Start == -1 and onesSoFar == ones // 3 * 2 + 1:\n        s3Start = i\n\n    return (s2Start - s1End) * (s3Start - s2End) % kMod\n", "tests": {"16": "def test_numWays(self):\n    solution = Solution()\n    self.assertEqual(solution.numWays('111'), 0)", "18": "def test_numWays():\n\n    class Solution:\n\n        def numWays(self, s: str) -> int:\n            kMod = 1000000007\n            return (len(s) - 1) * (len(s) - 2) // 2 % kMod\n    solution = Solution()\n    assert solution.numWays('00') == 0", "19": "def test_numWays():\n    solution = Solution()\n    assert solution.numWays('000') == 0, f\"Expected 0, got {solution.numWays('000')}\"", "29": "def test_numWays():\n\n    def numWays(self, s: str) -> int:\n        kMod = 10 ** 9 + 7\n        ones = s.count('1')\n        if ones % 3 != 0:\n            return 0\n        if ones == 0:\n            n = len(s)\n            return (n - 1) * (n - 2) // 2 % kMod\n        s1End = -1\n        s2Start = -1\n        s2End = -1\n        s3Start = -1\n        onesSoFar = 0\n        for (i, c) in enumerate(s):\n            if c == '1':\n                onesSoFar += 1\n            if s1End == -1 and onesSoFar == ones // 3:\n                s1End = i\n            elif s2Start == -1 and onesSoFar == ones // 3 + 1:\n                s2Start = i\n            if s2End == -1 and onesSoFar == ones // 3 * 2:\n                s2End = i\n            elif s3Start == -1 and onesSoFar == ones // 3 * 2 + 1:\n                s3Start = i\n        return (s2Start - s1End) * (s3Start - s2End) % kMod\n    solution = Solution()\n    assert numWays(solution, '101') == 0", "31": "def test_numWays():\n\n    def is_zero_return_value(s):\n        kMod = 10 ** 9 + 7\n        ones = s.count('1')\n        if ones == 0:\n            n = len(s)\n            return (n - 1) * (n - 2) // 2 % kMod\n        else:\n            return None\n    solution = Solution()\n    print(solution.numWays('110'))", "33": "def test_numWays():\n\n    class Solution:\n\n        def numWays(self, s: str) -> int:\n            kMod = 1000000007\n            ones = s.count('1')\n            if ones % 3 != 0:\n                return 0\n            elif ones == 6:\n                return (s.find('111') - s.rfind('111')) * (s.find('111', s.find('111') + 3) - s.find('111', s.rfind('111') - 3)) % kMod\n    solution = Solution()\n    print(solution.numWays('1101'))", "35": "def test_numWays():\n    solution = Solution()\n    print(solution.numWays('101'))", "37": "def test_numWays():\n\n    class SolutionMock:\n\n        def numWays(self, s: str) -> int:\n            kMod = 1000000007\n            ones = s.count('1')\n            if ones % 3 != 0:\n                return 0\n            if ones == 0:\n                n = len(s)\n                return (n - 1) * (n - 2) // 2 % kMod\n            s1End = -1\n            s2Start = -1\n            s2End = -1\n            s3Start = -1\n            onesSoFar = 0\n            for (i, c) in enumerate(s):\n                if c == '1':\n                    onesSoFar += 1\n                if s1End == -1 and onesSoFar == ones // 3:\n                    s1End = i\n                elif s2Start == -1 and onesSoFar == ones // 3 + 1:\n                    s2Start = i\n                if s2End == -1 and onesSoFar == ones // 3 * 2:\n                    s2End = i\n                elif s3Start == -1 and onesSoFar == ones // 3 * 2 + 1:\n                    s3Start = i\n            return (s2Start - s1End) * (s3Start - s2End) % kMod\n    solution = SolutionMock()\n    assert solution.numWays('110') == 0"}}
{"task_num": 1574, "task_title": "Shortest Subarray to be Removed to Make Array Sorted", "func_name": "findLengthOfShortestSubarray", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n    n = len(arr)\n    l = 0\n    r = n - 1\n\n    while l < n - 1 and arr[l + 1] >= arr[l]:\n      l += 1\n    while r > 0 and arr[r - 1] <= arr[r]:\n      r -= 1\n    ans = min(n - 1 - l, r)\n\n    i = l\n    j = n - 1\n    while i >= 0 and j >= r and j > i:\n      if arr[i] <= arr[j]:\n        j -= 1\n      else:\n        i -= 1\n      ans = min(ans, j - i)\n\n    return ans\n", "tests": {"27": "def test_findLengthOfShortestSubarray():\n\n    def findLengthOfShortestSubarray(self, arr):\n        n = len(arr)\n        l = 0\n        r = n - 1\n        while l < n - 1 and arr[l + 1] >= arr[l]:\n            l += 1\n        while r > 0 and arr[r - 1] <= arr[r]:\n            r -= 1\n        ans = min(n - 1 - l, r)\n        i = l\n        j = n - 1\n        while i >= 0 and j >= r and (j > i):\n            if arr[i] <= arr[j]:\n                return -1\n            else:\n                i -= 1\n        return ans\n    solution = Solution()\n    arr = [3, 2, 1]\n    assert solution.findLengthOfShortestSubarray(arr) == 2", "29": "def test_findLengthOfShortestSubarray():\n\n    class Solution:\n\n        def findLengthOfShortestSubarray(self, arr):\n            n = len(arr)\n            l = 0\n            r = n - 1\n            while l < n - 1 and arr[l + 1] >= arr[l]:\n                l += 1\n            while r > 0 and arr[r - 1] <= arr[r]:\n                r -= 1\n            ans = min(n - 1 - l, r)\n            i = l\n            j = n - 1\n            while i >= 0 and j >= r and (j > i):\n                if arr[i] <= arr[j]:\n                    j -= 1\n                else:\n                    return 2\n                ans = min(ans, j - i)\n            return ans\n    solution = Solution()\n    print(solution.findLengthOfShortestSubarray([3, 4]))"}}
{"task_num": 1579, "task_title": "Remove Max Number of Edges to Keep Graph Fully Traversable", "func_name": "maxNumEdgesToRemove", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    self.count -= 1\n    return True\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\n    alice = UnionFind(n)\n    bob = UnionFind(n)\n    requiredEdges = 0\n\n    for type, u, v in sorted(edges, reverse=True):\n      u -= 1\n      v -= 1\n      if type == 3:\n        if alice.unionByRank(u, v) | bob.unionByRank(u, v):\n          requiredEdges += 1\n      elif type == 2:\n        if bob.unionByRank(u, v):\n          requiredEdges += 1\n      else:\n        if alice.unionByRank(u, v):\n          requiredEdges += 1\n\n    if alice.count == 1 and bob.count == 1:\n        return len(edges) - requiredEdges\n    else:\n        return -1\n", "tests": {"21": "def test_maxNumEdgesToRemove():\n\n    class Test(unittest.TestCase):\n\n        def test_unionByRank(self):\n            solution = Solution()\n            uf = UnionFind(2)\n            self.assertTrue(uf.unionByRank(0, 1))\n            self.assertFalse(uf.unionByRank(0, 1))\nif __name__ == '__main__':\n    unittest.main()", "23": "def test_maxNumEdgesToRemove():\n\n    class Solution:\n\n        def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\n            alice = UnionFind(n)\n            bob = UnionFind(n)\n            requiredEdges = 0\n            for (type, u, v) in sorted(edges, reverse=True):\n                u -= 1\n                v -= 1\n                if type == 3:\n                    if alice.unionByRank(u, v) | bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif type == 2:\n                    if bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif alice.unionByRank(u, v):\n                    requiredEdges += 1\n            if alice.count == 1 and bob.count == 1:\n                return len(edges) - requiredEdges\n            else:\n                return -1\n    solution = Solution()\n    print(solution.maxNumEdgesToRemove(3, [[3, 0, 1], [3, 1, 2], [2, 0, 2]]))", "25": "def test_maxNumEdgesToRemove(self):\n\n    class Solution:\n\n        def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\n            alice = UnionFind(n)\n            bob = UnionFind(n)\n            requiredEdges = 0\n            for (type, u, v) in sorted(edges, reverse=True):\n                u -= 1\n                v -= 1\n                if type == 3:\n                    if alice.unionByRank(u, v) | bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif type == 2:\n                    if bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif alice.unionByRank(u, v):\n                    requiredEdges += 1\n            if alice.count == 1 and bob.count == 1:\n                return len(edges) - requiredEdges\n            else:\n                return -1\n    solution = Solution()\n    n = 4\n    edges = [[3, 0, 1], [3, 1, 2], [3, 2, 0]]\n    self.assertEqual(solution.maxNumEdgesToRemove(n, edges), 2)", "27": "def test_maxNumEdgesToRemove():\n\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\n        alice = UnionFind(n)\n        bob = UnionFind(n)\n        requiredEdges = 0\n        for (type, u, v) in sorted([[3, 2, 1], [3, 0, 4], [2, 1, 5], [2, 5, 4]], reverse=True):\n            u -= 1\n            v -= 1\n            if type == 3:\n                if alice.unionByRank(u, v) | bob.unionByRank(u, v):\n                    requiredEdges += 1\n            elif type == 2:\n                if bob.unionByRank(u, v):\n                    requiredEdges += 1\n            elif alice.unionByRank(u, v):\n                requiredEdges += 1\n        return requiredEdges\n    solution = Solution()\n    print(solution.maxNumEdgesToRemove(5, [[3, 0, 4], [2, 1, 5], [2, 5, 4]]))", "28": "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    n = 4\n    edges = [[3, 0, 1], [3, 0, 2], [3, 1, 2], [2, 1, 3]]\n    assert solution.maxNumEdgesToRemove(n, edges) == len(edges) - 2", "34": "def test_maxNumEdgesToRemove():\n\n    class Solution:\n\n        def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\n            alice = UnionFind(n)\n            bob = UnionFind(n)\n            requiredEdges = 0\n            for (type, u, v) in sorted(edges, reverse=True):\n                u -= 1\n                v -= 1\n                if type == 3:\n                    if alice.unionByRank(u, v) or bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif type == 2:\n                    if bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif alice.unionByRank(u, v):\n                    requiredEdges += 1\n            if alice.count == 1 and bob.count == 1:\n                return len(edges) - requiredEdges\n            else:\n                return -1\n    solution = Solution()\n    edges = [[3, 2, 5], [3, 0, 4], [2, 1, 2]]\n    assert solution.maxNumEdgesToRemove(6, edges) == 2", "48": "def test_maxNumEdgesToRemove():\n\n    def helper(n, edges):\n        solution = Solution()\n        alice = UnionFind(n)\n        bob = UnionFind(n)\n        requiredEdges = 0\n        for (type, u, v) in sorted(edges, reverse=True):\n            if type == 3:\n                if alice.unionByRank(u - 1, v - 1) | bob.unionByRank(u - 1, v - 1):\n                    return n * (n - 1) // 2 - requiredEdges\n        return -1\n    edges = [[3, 4, 5], [1, 2, 3]]\n    assert helper(6, edges) == -1", "49": "def test_maxNumEdgesToRemove():\n\n    class Solution:\n\n        def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\n            alice = UnionFind(n)\n            bob = UnionFind(n)\n            requiredEdges = 0\n            for (type, u, v) in sorted(edges, reverse=True):\n                u -= 1\n                v -= 1\n                if type == 3:\n                    if alice.unionByRank(u, v) | bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif type == 2:\n                    if bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif alice.unionByRank(u, v):\n                    requiredEdges += 1\n            return requiredEdges\n    solution = Solution()\n    edges = [[3, 4, 5], [2, 3, 4], [1, 2, 6]]\n    assert solution.maxNumEdgesToRemove(5, edges) == 2", "51": "def test_maxNumEdgesToRemove(self):\n\n    class Solution:\n\n        def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\n            alice = UnionFind(n)\n            bob = UnionFind(n)\n            requiredEdges = 0\n            for (type, u, v) in sorted(edges, reverse=True):\n                u -= 1\n                v -= 1\n                if type == 3:\n                    if alice.unionByRank(u, v) | bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif type == 2:\n                    if bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif alice.unionByRank(u, v):\n                    requiredEdges += 1\n            return len(edges) - requiredEdges\n    solution = Solution()\n    edges = [[3, 2, 1], [3, 1, 0], [2, 0, 4]]\n    self.assertEqual(solution.maxNumEdgesToRemove(5, edges), 3)", "52": "def test_maxNumEdgesToRemove(self):\n\n    class Solution:\n\n        def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\n            alice = UnionFind(n)\n            bob = UnionFind(n)\n            requiredEdges = 0\n            for (type, u, v) in sorted(edges, reverse=True):\n                u -= 1\n                v -= 1\n                if type == 3:\n                    if alice.unionByRank(u, v) | bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif type == 2:\n                    if bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif alice.unionByRank(u, v):\n                    requiredEdges += 1\n            return len(edges) - requiredEdges\n    solution = Solution()\n    n = 3\n    edges = [[3, 0, 1], [3, 1, 2], [3, 1, 0]]\n    self.assertEqual(solution.maxNumEdgesToRemove(n, edges), 1)", "53": "def test_maxNumEdgesToRemove():\n\n    class Solution:\n\n        def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\n            alice = UnionFind(n)\n            bob = UnionFind(n)\n            requiredEdges = 0\n            for (type, u, v) in sorted(edges, reverse=True):\n                u -= 1\n                v -= 1\n                if type == 3:\n                    if alice.unionByRank(u, v) or bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif type == 2:\n                    if bob.unionByRank(u, v):\n                        requiredEdges += 1\n                else:\n                    assert type == 1\n                    if alice.unionByRank(u, v):\n                        requiredEdges += 1\n            return -1\n    solution = Solution()\n    edges = [[3, 4, 5], [2, 5, 8], [1, 7, 6]]\n    assert solution.maxNumEdgesToRemove(9, edges) == -1", "55": "def test_maxNumEdgesToRemove():\n\n    def maxNumEdgesToRemove(n, edges):\n        alice = UnionFind(n)\n        bob = UnionFind(n)\n        requiredEdges = 0\n        for (type, u, v) in sorted(edges, reverse=True):\n            u -= 1\n            v -= 1\n            if type == 3:\n                if alice.unionByRank(u, v) | bob.unionByRank(u, v):\n                    requiredEdges += 1\n            elif type == 2:\n                if bob.unionByRank(u, v):\n                    requiredEdges += 1\n            elif alice.unionByRank(u, v):\n                requiredEdges += 1\n        if alice.count == 1 and bob.count == 1:\n            return len(edges) - requiredEdges\n        else:\n            return -1\n    solution = Solution()\n    n = 4\n    edges = [[3, 0, 1], [3, 0, 2], [3, 1, 2], [2, 0, 3]]\n    assert maxNumEdgesToRemove(n, edges) == 2", "58": "def test_maxNumEdgesToRemove(self):\n    class Solution:\n        def maxNumEdgesToRemove(self, n: int, edges: list) -> int:\n            # implementation remains the same as in original code\n\n    solution = Solution()\n    n = 3\n    edges = [[3,0,1],[3,1,2],[3,2,0]]\n    self.assertEqual(solution.maxNumEdgesToRemove(n, edges), len(edges) - solution.requiredEdges)", "60": "def test_maxNumEdgesToRemove():\n\n    class Solution:\n\n        def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\n            alice = UnionFind(n)\n            bob = UnionFind(n)\n            requiredEdges = 0\n            for (type, u, v) in sorted(edges, reverse=True):\n                u -= 1\n                v -= 1\n                if type == 3:\n                    if alice.unionByRank(u, v) | bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif type == 2:\n                    if bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif alice.unionByRank(u, v):\n                    requiredEdges += 1\n            if alice.count == 1 and bob.count == 1:\n                return len(edges) - requiredEdges\n            else:\n                return -1\n    solution = Solution()\n    edges = [[3, 2, 4], [3, 1, 5]]\n    assert solution.maxNumEdgesToRemove(6, edges) == -1"}}
{"task_num": 1582, "task_title": "Special Positions in a Binary Matrix", "func_name": "numSpecial", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numSpecial(self, mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    ans = 0\n    rowOnes = [0] * m\n    colOnes = [0] * n\n\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j] == 1:\n          rowOnes[i] += 1\n          colOnes[j] += 1\n\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j] == 1 and rowOnes[i] == 1 and colOnes[j] == 1:\n          ans += 1\n\n    return ans\n", "tests": {"22": "def test_numSpecial(self):\n\n    class Solution:\n\n        def numSpecial(self, mat: List[List[int]]) -> int:\n            m = len(mat)\n            n = len(mat[0])\n            ans = 0\n            rowOnes = [0] * m\n            colOnes = [0] * n\n            for i in range(m):\n                for j in range(n):\n                    if mat[i][j] == 1:\n                        rowOnes[i] += 1\n                        colOnes[j] += 1\n            for i in range(m):\n                for j in range(n):\n                    if mat[i][j] == 1 and rowOnes[i] == 1 and (colOnes[j] == 1):\n                        ans += 1\n            return ans\n    solution = Solution()\n    mat = [[0, 0, 0], [1, 0, 1], [0, 1, 0]]\n    self.assertEqual(solution.numSpecial(mat), 3)", "23": "def test_numSpecial():\n\n    class Solution:\n\n        def numSpecial(self, mat):\n            m = len(mat)\n            n = len(mat[0])\n            ans = 0\n            rowOnes = [0] * m\n            colOnes = [0] * n\n            for i in range(m):\n                for j in range(n):\n                    if mat[i][j] == 1:\n                        rowOnes[i] += 1\n                        colOnes[j] += 1\n            return ans\n    solution = Solution()\n    print(solution.numSpecial([[1, 0, 0], [0, 1, 0], [0, 0, 1]]))", "28": "def test_numSpecial():\n    solution = Solution()\n\n    def input_1(mat):\n        return 2\n    solution.numSpecial([[1, 0, 0], [0, 0, 1], [0, 1, 0]])"}}
{"task_num": 1583, "task_title": "Count Unhappy Friends", "func_name": "unhappyFriends", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\n    ans = 0\n    matches = [0] * n\n    prefer = [{} for _ in range(n)]\n\n    for x, y in pairs:\n      matches[x] = y\n      matches[y] = x\n\n    for i in range(n):\n      for j in range(n - 1):\n        prefer[i][preferences[i][j]] = j\n\n    for x in range(n):\n      for u in prefer[x].keys():\n        y = matches[x]\n        v = matches[u]\n        if prefer[x][u] < prefer[x][y] and prefer[u][x] < prefer[u][v]:\n          ans += 1\n          break\n\n    return ans\n", "tests": {"30": "def test_unhappyFriends():\n\n    class Solution:\n\n        def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\n            solution = self\n\n            def check_preferences(preferences, i):\n                return len([j for j in preferences[i] if j == 1])\n            assert check_preferences([[1, 2, 3], [0, 3, 1], [3, 1, 2]], 0) == 1", "31": "def test_unhappyFriends(self):\n\n    class Solution:\n\n        def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\n            ans = 0\n            matches = [0] * n\n            prefer = [{} for _ in range(n)]\n            for (x, y) in pairs:\n                matches[x] = y\n                matches[y] = x\n            for i in range(n):\n                for j in range(n - 1):\n                    prefer[i][preferences[i][j]] = j\n            preferences[0] = [4, 3, 2, 1]\n            preferences[1] = [0, 2, 3, 4]\n            pairs = [[0, 1], [2, 3]]\n            return sum([self._unhappyFriendsHelper(i, prefer[i], matches[i], i, n) for i in range(n)])\n\n        def _unhappyFriendsHelper(self, x: int, preffered: Dict[int, int], matched: int, u: int, n: int):\n            y = matched\n            v = self.matches[u]\n            if preffered.get(u, '-1') < preffered.get(y, '-1') and preffered.get(y, '-1') > preffered.get(v, '-1'):\n                return 1\n            else:\n                return 0\n    solution = Solution()\n    assert solution.unhappyFriends(4, [[0, 3, 2, 1], [0, 2, 3, 1], [3, 0, 1, 2], [3, 1, 2, 0]], [[0, 1], [2, 3]]) == 2"}}
{"task_num": 1591, "task_title": "Strange Printer II", "func_name": "isPrintable", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import Enum\n\n\nclass State(Enum):\n  kInit = 0\n  kVisiting = 1\n  kVisited = 2\n\n\nclass Solution:\n  def isPrintable(self, targetGrid: List[List[int]]) -> bool:\n    kMaxColor = 60\n    m = len(targetGrid)\n    n = len(targetGrid[0])\n\n    graph = [set() for _ in range(kMaxColor + 1)]\n\n    for color in range(1, kMaxColor + 1):\n      minI = m\n      minJ = n\n      maxI = -1\n      maxJ = -1\n      for i in range(m):\n        for j in range(n):\n          if targetGrid[i][j] == color:\n            minI = min(minI, i)\n            minJ = min(minJ, j)\n            maxI = max(maxI, i)\n            maxJ = max(maxJ, j)\n\n      for i in range(minI, maxI + 1):\n        for j in range(minJ, maxJ + 1):\n          if targetGrid[i][j] != color:\n            graph[color].add(targetGrid[i][j])\n\n    states = [State.kInit] * (kMaxColor + 1)\n\n    def hasCycle(u: int) -> bool:\n      if states[u] == State.kVisiting:\n        return True\n      if states[u] == State.kVisited:\n        return False\n\n      states[u] = State.kVisiting\n      if any(hasCycle(v) for v in graph[u]):\n        return True\n      states[u] = State.kVisited\n\n      return False\n\n    for i in range(1, kMaxColor + 1):\n      if hasCycle(i):\n        return False\n    return True\n", "tests": {"36": "def test_isPrintable(self):\n    targetGrid = [[1]]\n    self.assertTrue(solution.isPrintable(targetGrid))", "37": "def test_isPrintable(self):\n    targetGrid = [[1, 0, 2], [3, 4, 5], [6, 7, 8]]\n    self.assertTrue(solution.isPrintable(targetGrid))", "38": "def test_isPrintable():\n\n    def isPrintable(self):\n        grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n        (m, n) = (len(grid), len(grid[0]))\n        graph = [set() for _ in range(10)]\n        kMaxColor = 9\n        states = [0] * (kMaxColor + 1)\n\n        def hasCycle(u: int) -> bool:\n            if states[u] == 2:\n                return False\n            if states[u] == 1:\n                return True\n            states[u] = 1\n            for v in graph[u]:\n                if hasCycle(v):\n                    return True\n            states[u] = 2\n            return False\n        for i in range(1, kMaxColor + 1):\n            if any((hasCycle(j) for j in range(i, m * n))):\n                return False\n        return True\n    solution = Solution()\n    print(isPrintable(solution))", "39": "def test_isPrintable():\n\n    class Solution:\n\n        def isPrintable(self, targetGrid):\n            graph = [set() for _ in range(61)]\n            m = len(targetGrid)\n            n = len(targetGrid[0])\n            for color in range(1, 61):\n                minI = m\n                minJ = n\n                maxI = -1\n                maxJ = -1\n                for i in range(m):\n                    for j in range(n):\n                        if targetGrid[i][j] == color:\n                            minI = min(minI, i)\n                            minJ = min(minJ, j)\n                            maxI = max(maxI, i)\n                            maxJ = max(maxJ, j)\n                for i in range(minI, maxI + 1):\n                    for j in range(minJ, maxJ + 1):\n                        if targetGrid[i][j] != color:\n                            graph[color].add(targetGrid[i][j])\n            states = [0] * 61\n\n            def hasCycle(u: int) -> bool:\n                if states[u] == 1:\n                    return True\n                if states[u] == 2:\n                    return False\n                states[u] = 1\n                if any((hasCycle(v) for v in graph[u])):\n                    return True\n                states[u] = 2\n                return False\n            for i in range(1, 61):\n                if hasCycle(i):\n                    return False\n            return True\n    solution = Solution()\n    targetGrid = [[0, 0], [1, 1]]\n    assert solution.isPrintable(targetGrid) == False", "44": "def test_isPrintable():\n\n    class Solution:\n\n        def isPrintable(self, targetGrid):\n            kMaxColor = 60\n            m = len(targetGrid)\n            n = len(targetGrid[0])\n            graph = [set() for _ in range(kMaxColor + 1)]\n            color = 5\n            minI = m\n            minJ = n\n            maxI = -1\n            maxJ = -1\n            for i in range(m):\n                for j in range(n):\n                    if targetGrid[i][j] == color:\n                        minI = min(minI, i)\n                        minJ = min(minJ, j)\n                        maxI = max(maxI, i)\n                        maxJ = max(maxJ, j)\n            for i in range(minI, maxI + 1):\n                for j in range(minJ, maxJ + 1):\n                    if targetGrid[i][j] != color:\n                        graph[color].add(targetGrid[i][j])\n            states = [0] * (kMaxColor + 1)\n\n            def hasCycle(u: int) -> bool:\n                if states[u] == 1:\n                    return True\n                if states[u] == 2:\n                    return False\n                states[u] = 1\n                if any((hasCycle(v) for v in graph[u])):\n                    return True\n                states[u] = 2\n                return False\n            for i in range(1, kMaxColor + 1):\n                if hasCycle(i):\n                    return False\n            return True\n    solution = Solution()\n    print(solution.isPrintable([[5, 6, 7], [8, 9, 10], [11, 12, 13]]))", "50": "def test_isPrintable(self):\n    solution = Solution()\n    targetGrid = [[1, 0, 0], [2, 3, 0]]\n    self.assertTrue(solution.isPrintable(targetGrid))", "52": "def test_isPrintable():\n\n    class Solution:\n\n        def isPrintable(self, targetGrid):\n            kMaxColor = 60\n            m = len(targetGrid)\n            n = len(targetGrid[0])\n            graph = [set() for _ in range(kMaxColor + 1)]\n            for color in range(1, kMaxColor + 1):\n                minI = m\n                minJ = n\n                maxI = -1\n                maxJ = -1\n                for i in range(m):\n                    for j in range(n):\n                        if targetGrid[i][j] == color:\n                            minI = min(minI, i)\n                            minJ = min(minJ, j)\n                            maxI = max(maxI, i)\n                            maxJ = max(maxJ, j)\n                for i in range(minI, maxI + 1):\n                    for j in range(minJ, maxJ + 1):\n                        if targetGrid[i][j] != color:\n                            graph[color].add(targetGrid[i][j])\n            states = [State.kInit] * (kMaxColor + 1)\n\n            def hasCycle(u: int) -> bool:\n                if states[u] == State.kVisiting:\n                    return True\n                if states[u] == State.kVisited:\n                    return False\n                states[u] = State.kVisiting\n                if any((hasCycle(v) for v in graph[u])):\n                    return True\n                states[u] = State.kVisited\n            for i in range(1, kMaxColor + 1):\n                if hasCycle(i):\n                    return False\n            return True\n    solution = Solution()\n    targetGrid = [[0, 1], [2]]\n    assert solution.isPrintable(targetGrid) == False", "56": "def test_isPrintable(self):\n\n    class Solution:\n\n        def isPrintable(self, targetGrid):\n            kMaxColor = 60\n            m = len(targetGrid)\n            n = len(targetGrid[0])\n            graph = [set() for _ in range(kMaxColor + 1)]\n            for color in range(1, kMaxColor + 1):\n                minI = m\n                minJ = n\n                maxI = -1\n                maxJ = -1\n                for i in range(m):\n                    for j in range(n):\n                        if targetGrid[i][j] == color:\n                            minI = min(minI, i)\n                            minJ = min(minJ, j)\n                            maxI = max(maxI, i)\n                            maxJ = max(maxJ, j)\n                for i in range(minI, maxI + 1):\n                    for j in range(minJ, maxJ + 1):\n                        if targetGrid[i][j] != color:\n                            graph[color].add(targetGrid[i][j])\n            states = [0] * (kMaxColor + 1)\n\n            def hasCycle(u):\n                if states[u] == 1:\n                    return True\n                if states[u] == 2:\n                    return False\n                states[u] = 1\n                if any((hasCycle(v) for v in graph[u])):\n                    return True\n                states[u] = 2\n                return False\n            for i in range(1, kMaxColor + 1):\n                if hasCycle(i):\n                    return False\n            return True\n    solution = Solution()\n    targetGrid = [[1, 0, 0], [2, 3, 0]]\n    self.assertFalse(solution.isPrintable(targetGrid))", "63": "def test_isPrintable():\n\n    class Solution:\n\n        def isPrintable(self, targetGrid):\n            kMaxColor = 60\n            m = len(targetGrid)\n            n = len(targetGrid[0])\n            graph = [set() for _ in range(kMaxColor + 1)]\n            for color in range(1, kMaxColor + 1):\n                minI = m\n                minJ = n\n                maxI = -1\n                maxJ = -1\n                for i in range(m):\n                    for j in range(n):\n                        if targetGrid[i][j] == color:\n                            minI = min(minI, i)\n                            minJ = min(minJ, j)\n                            maxI = max(maxI, i)\n                            maxJ = max(maxJ, j)\n                for i in range(minI, maxI + 1):\n                    for j in range(minJ, maxJ + 1):\n                        if targetGrid[i][j] != color:\n                            graph[color].add(targetGrid[i][j])\n            states = [0] * (kMaxColor + 1)\n\n            def hasCycle(u: int) -> bool:\n                if states[u] == 1:\n                    return True\n                if states[u] == 2:\n                    return False\n                states[u] = 1\n                if any((hasCycle(v) for v in graph[u])):\n                    return True\n                states[u] = 2\n                return False\n            for i in range(1, kMaxColor + 1):\n                if hasCycle(i):\n                    return False\n            return True\n    solution = Solution()\n    targetGrid = [[3, 0, 8], [4, 1, 0], [8, 6, 0]]\n    assert not solution.isPrintable(targetGrid)"}}
{"task_num": 1604, "task_title": "Alert Using Same Key-Card Three or More Times in a One Hour Period", "func_name": "alertNames", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n    nameToMinutes = collections.defaultdict(list)\n\n    for name, time in zip(keyName, keyTime):\n      minutes = self._getMinutes(time)\n      nameToMinutes[name].append(minutes)\n\n    res=[]\n    for name, minutes in nameToMinutes.items():\n      if self._hasAlert(minutes):\n        res.append(name)\n    return sorted(res)\n\n  def _hasAlert(self, minutes: List[int]) -> bool:\n    if len(minutes) > 70:\n      return True\n    minutes.sort()\n    for i in range(2, len(minutes)):\n      if minutes[i - 2] + 60 >= minutes[i]:\n        return True\n    return False\n\n  def _getMinutes(self, time: str) -> int:\n    h, m = map(int, time.split(':'))\n    return 60 * h + m\n", "tests": {"22": "def test_alertNames():\n    solution = Solution()\n    keyName = ['John', 'John', 'John', 'Alice', 'Alice']\n    keyTime = ['23:51', '00:06', '00:25', '23:58', '23:59']\n    res = solution.alertNames(keyName, keyTime)", "27": "def test_alertNames():\n\n    def _getMinutes(time: str) -> int:\n        (h, m) = map(int, time.split(':'))\n        return 60 * h + m\n\n    class Solution:\n\n        def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n            nameToMinutes = collections.defaultdict(list)\n            for (name, time) in zip(keyName, keyTime):\n                minutes = _getMinutes(time)\n                nameToMinutes[name].append(minutes)\n            res = []\n            for (name, minutes) in nameToMinutes.items():\n                if len(minutes) > 70:\n                    res.append(name)\n            return sorted(res)\n    solution = Solution()\n    print(solution.alertNames(['diana', 'tony', 'diana'], ['10:00', '20:49', '21:42']))", "31": "def test_alertNames():\n\n    def alertNames(keyName, keyTime):\n        nameToMinutes = collections.defaultdict(list)\n        for (name, time) in zip(keyName, keyTime):\n            minutes = _getMinutes(time)\n            nameToMinutes[name].append(minutes)\n        res = []\n        for (name, minutes) in nameToMinutes.items():\n            if hasAlert(minutes):\n                res.append(name)\n        return sorted(res)\n\n    def hasAlert(minutes):\n        if len(minutes) > 70:\n            return True\n        minutes.sort()\n        for i in range(2, len(minutes)):\n            if minutes[i - 2] + 60 >= minutes[i]:\n                return True\n        return False\n\n    def _getMinutes(time):\n        (h, m) = map(int, time.split(':'))\n        return 60 * h + m\n    solution = Solution()\n    assert alertNames(['diana', 'nancy', 'diana', 'may', 'mary'], ['10:00', '11:00', '10:05', '09:59', '10:01']) == ['diana'], 'Test case not covered'"}}
{"task_num": 1615, "task_title": "Maximal Network Rank", "func_name": "maximalNetworkRank", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\n    degrees = [0] * n\n\n    for u, v in roads:\n      degrees[u] += 1\n      degrees[v] += 1\n\n    maxDegree1 = 0\n    maxDegree2 = 0\n    for degree in degrees:\n      if degree > maxDegree1:\n        maxDegree2 = maxDegree1\n        maxDegree1 = degree\n      elif degree > maxDegree2:\n        maxDegree2 = degree\n\n    countMaxDegree1 = 0\n    countMaxDegree2 = 0\n    for degree in degrees:\n      if degree == maxDegree1:\n        countMaxDegree1 += 1\n      elif degree == maxDegree2:\n        countMaxDegree2 += 1\n\n    if countMaxDegree1 == 1:\n      edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree2) + self._getEdgeCount(roads, degrees, maxDegree2, maxDegree1)\n      return maxDegree1 + maxDegree2 - (countMaxDegree2 == edgeCount)\n    else:\n      edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree1)\n      maxPossibleEdgeCount = countMaxDegree1 * (countMaxDegree1 - 1) // 2\n      return 2 * maxDegree1 - (maxPossibleEdgeCount == edgeCount)\n\n  def _getEdgeCount(self, roads: List[List[int]], degrees: List[int], degreeU: int, degreeV: int) -> int:\n    edgeCount = 0\n    for u, v in roads:\n      if degrees[u] == degreeU and degrees[v] == degreeV:\n        edgeCount += 1\n    return edgeCount\n", "tests": {"23": "def test_maximalNetworkRank():\n\n    class Solution:\n\n        def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\n            degrees = [0] * n\n            for (u, v) in roads:\n                degrees[u] += 1\n                degrees[v] += 1\n            maxDegree1 = 0\n            maxDegree2 = 0\n            for degree in degrees:\n                if degree > maxDegree1:\n                    maxDegree2 = maxDegree1\n                    maxDegree1 = degree\n                elif degree > maxDegree2 and degree != maxDegree1:\n                    maxDegree2 = degree\n            edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree2)\n            return 2 * max(maxDegree1, maxDegree2) - (edgeCount == len([u for u in range(n) if degrees[u] == maxDegree1]))\n    solution = Solution()\n    assert solution.maximalNetworkRank(5, [[0, 1], [0, 4], [1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]) == 7", "24": "def test_maximalNetworkRank():\n\n    class Solution:\n\n        def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\n            degrees = [0] * n\n            for (u, v) in roads:\n                degrees[u] += 1\n                degrees[v] += 1\n            maxDegree1 = -float('inf')\n            maxDegree2 = -float('inf')\n            for degree in degrees:\n                if degree > maxDegree1:\n                    maxDegree2 = maxDegree1\n                    maxDegree1 = degree\n                elif degree > maxDegree2:\n                    maxDegree2 = degree\n            return (maxDegree1 + 1, maxDegree2)\n    solution = Solution()\n    print(solution.maximalNetworkRank(3, [[0, 1], [1, 2]]))", "26": "def test_maximalNetworkRank():\n\n    class Solution:\n\n        def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\n            degrees = [0] * n\n            for (u, v) in roads:\n                degrees[u] += 1\n                degrees[v] += 1\n            maxDegree1 = 0\n            maxDegree2 = float('-inf')\n            for degree in degrees:\n                if degree > maxDegree1:\n                    maxDegree2 = maxDegree1\n                    maxDegree1 = degree\n                elif degree > maxDegree2 and degree != maxDegree1:\n                    maxDegree2 = degree\n            return maxDegree1 + maxDegree2\nsolution = Solution()\nprint(solution.maximalNetworkRank(4, [[0, 1], [0, 3], [1, 2], [1, 3]]))", "32": "def test_maximalNetworkRank():\n\n    class Solution:\n\n        def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\n            degrees = [0] * n\n            for (u, v) in roads:\n                degrees[u] += 1\n                degrees[v] += 1\n            maxDegree1 = 0\n            maxDegree2 = 0\n            for degree in degrees:\n                if degree > maxDegree1:\n                    maxDegree2 = maxDegree1\n                    maxDegree1 = degree\n                elif degree > maxDegree2:\n                    maxDegree2 = degree\n            countMaxDegree1 = 0\n            countMaxDegree2 = 0\n            for degree in degrees:\n                if degree == maxDegree1:\n                    countMaxDegree1 += 1\n                elif degree == maxDegree2:\n                    countMaxDegree2 += 1\n            edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree1)\n            return maxDegree1 + maxDegree2 - (countMaxDegree2 == edgeCount)\n\n        def _getEdgeCount(self, roads: List[List[int]], degrees: List[int], degreeU: int, degreeV: int) -> int:\n            edgeCount = 0\n            for (u, v) in roads:\n                if degrees[u] == degreeU and degrees[v] == degreeV:\n                    edgeCount += 1\n            return edgeCount\n    solution = Solution()\n    assert solution.maximalNetworkRank(3, [[0, 1], [1, 2]]) == 2", "34": "def test_maximalNetworkRank():\n\n    class Solution:\n\n        def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\n            degrees = [0] * n\n            for (u, v) in [[1, 2]]:\n                degrees[u] += 1\n                degrees[v] += 1\n            maxDegree1 = 0\n            maxDegree2 = 0\n            for degree in degrees:\n                if degree > maxDegree1:\n                    maxDegree2 = maxDegree1\n                    maxDegree1 = degree\n                elif degree > maxDegree2:\n                    maxDegree2 = degree\n            countMaxDegree1 = 0\n            countMaxDegree2 = 0\n            for degree in degrees:\n                if degree == maxDegree1:\n                    countMaxDegree1 += 1\n                elif degree == maxDegree2:\n                    countMaxDegree2 += 1\n            assert countMaxDegree2 == 1", "37": "def test_maximalNetworkRank():\n\n    class Solution:\n\n        def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\n            degrees = [0] * n\n            for (u, v) in roads:\n                degrees[u] += 1\n                degrees[v] += 1\n            maxDegree1 = 0\n            maxDegree2 = 0\n            for degree in degrees:\n                if degree > maxDegree1:\n                    maxDegree2 = maxDegree1\n                    maxDegree1 = degree\n                elif degree > maxDegree2:\n                    maxDegree2 = degree\n            countMaxDegree1 = 0\n            countMaxDegree2 = 0\n            for degree in degrees:\n                if degree == maxDegree1:\n                    countMaxDegree1 += 1\n                elif degree == maxDegree2:\n                    countMaxDegree2 += 1\n            edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree2) + self._getEdgeCount(roads, degrees, maxDegree2, maxDegree1)\n            return maxDegree1 + maxDegree2 - (countMaxDegree2 == edgeCount) if countMaxDegree1 == 1 else 2 * maxDegree1 - (self._getEdgeCount(roads, degrees, maxDegree1, maxDegree1) == self._getEdgeCount(roads, degrees, maxDegree1, maxDegree1) * (countMaxDegree1 * (countMaxDegree1 - 1)) // 2)\n\n        def _getEdgeCount(self, roads: List[List[int]], degrees: List[int], degreeU: int, degreeV: int) -> int:\n            edgeCount = 0\n            for (u, v) in roads:\n                if degrees[u] == degreeU and degrees[v] == degreeV:\n                    edgeCount += 1\n            return edgeCount\n    solution = Solution()\n    roads = [[0, 1], [0, 4], [1, 2], [1, 3], [2, 3], [3, 4]]\n    assert solution.maximalNetworkRank(5, roads) == 4", "38": "def test_maximalNetworkRank():\n    solution = Solution()\n\n    def assert_equals(actual, expected):\n        if actual != expected:\n            raise AssertionError(f'Expected {expected}, got {actual}')\n    roads = [[0, 1], [0, 4], [1, 2], [1, 3], [1, 4], [2, 3]]\n    assert_equals(solution.maximalNetworkRank(5, roads), 8)", "40": "def test_maximalNetworkRank():\n\n    class Solution:\n\n        def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\n            degrees = [0] * n\n            for (u, v) in roads:\n                degrees[u] += 1\n                degrees[v] += 1\n            maxDegree1 = 0\n            maxDegree2 = 0\n            for degree in degrees:\n                if degree > maxDegree1:\n                    maxDegree2 = maxDegree1\n                    maxDegree1 = degree\n                elif degree > maxDegree2:\n                    maxDegree2 = degree\n            countMaxDegree1 = 0\n            countMaxDegree2 = 0\n            for degree in degrees:\n                if degree == maxDegree1:\n                    countMaxDegree1 += 1\n                elif degree == maxDegree2:\n                    countMaxDegree2 += 1\n            edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree1)\n            assert edgeCount == 0\ntest_maximalNetworkRank()", "41": "def test_maximalNetworkRank(self):\n\n    class Solution:\n\n        def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\n            degrees = [0] * n\n            for (u, v) in roads:\n                degrees[u] += 1\n                degrees[v] += 1\n            maxDegree1 = 0\n            maxDegree2 = 0\n            for degree in degrees:\n                if degree > maxDegree1:\n                    maxDegree2 = maxDegree1\n                    maxDegree1 = degree\n                elif degree > maxDegree2:\n                    maxDegree2 = degree\n            countMaxDegree1 = 0\n            countMaxDegree2 = 0\n            for degree in degrees:\n                if degree == maxDegree1:\n                    countMaxDegree1 += 1\n                elif degree == maxDegree2:\n                    countMaxDegree2 += 1\n            edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree1)\n            maxPossibleEdgeCount = countMaxDegree1 * (countMaxDegree1 - 1) // 2\n            return 2 * maxDegree1 - (maxPossibleEdgeCount == edgeCount)\n\n        def _getEdgeCount(self, roads: List[List[int]], degrees: List[int], degreeU: int, degreeV: int) -> int:\n            edgeCount = 0\n            for (u, v) in roads:\n                if degrees[u] == degreeU and degrees[v] == degreeV:\n                    edgeCount += 1\n            return edgeCount\n    solution = Solution()\n    self.assertEqual(solution.maximalNetworkRank(5, [[0, 1], [0, 4], [1, 2], [1, 3]]), 5)", "42": "def test_maximalNetworkRank():\n\n    class Solution:\n\n        def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\n            if n == 1 or len(roads) == 0:\n                return 0\n            elif n == 2 and len(roads) == 1:\n                (u, v) = roads[0]\n                if degrees[u] == degrees[v]:\n                    return maxDegree1 + maxDegree2 - (countMaxDegree2 == edgeCount)\n                else:\n                    return max(maxDegree1, maxDegree2)\n            solution = Solution()\n            n = 5\n            roads = [[0, 1], [0, 4], [1, 2], [1, 3], [1, 4], [2, 3]]", "48": "def test_maximalNetworkRank():\n\n    class Solution:\n\n        def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\n            degrees = [0] * n\n            for (u, v) in roads:\n                degrees[u] += 1\n                degrees[v] += 1\n            maxDegree1 = 0\n            maxDegree2 = 0\n            for degree in degrees:\n                if degree > maxDegree1:\n                    maxDegree2 = maxDegree1\n                    maxDegree1 = degree\n                elif degree > maxDegree2:\n                    maxDegree2 = degree\n            countMaxDegree1 = 0\n            countMaxDegree2 = 0\n            for degree in degrees:\n                if degree == maxDegree1:\n                    countMaxDegree1 += 1\n                elif degree == maxDegree2:\n                    countMaxDegree2 += 1\n\n            def _getEdgeCount(self, roads: List[List[int]], degrees: List[int], degreeU: int, degreeV: int) -> int:\n                edgeCount = 0\n                for (u, v) in roads:\n                    if degrees[u] == degreeU and degrees[v] == degreeV:\n                        edgeCount += 1\n                return edgeCount\n            solution = Solution()\n            return solution._getEdgeCount(roads=[[0, 1], [0, 2]], degrees=[2, 1, 0], degreeU=1, degreeV=0)\ntest_maximalNetworkRank()"}}
{"task_num": 1616, "task_title": "Split Two Strings to Make Palindrome", "func_name": "checkPalindromeFormation", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def checkPalindromeFormation(self, a: str, b: str) -> bool:\n    return self._check(a, b) or self._check(b, a)\n\n  def _check(self, a: str, b: str) -> bool:\n    i, j = 0, len(a) - 1\n    while i < j:\n      if a[i] != b[j]:\n        return self._isPalindrome(a, i, j) or self._isPalindrome(b, i, j)\n      i += 1\n      j -= 1\n    return True\n\n  def _isPalindrome(self, s: str, i: int, j: int) -> bool:\n    while i < j:\n      if s[i] != s[j]:\n        return False\n      i += 1\n      j -= 1\n    return True\n", "tests": {"19": "def test_checkPalindromeFormation():\n\n    class Solution:\n\n        def checkPalindromeFormation(self, a: str, b: str) -> bool:\n            return self._check(a, b) or self._check(b, a)\n\n        def _check(self, a: str, b: str) -> bool:\n            (i, j) = (0, len(a) - 1)\n            while i < j:\n                if a[i] != b[j]:\n                    return self._isPalindrome(a, i, j) or self._isPalindrome(b, i, j)\n                i += 1\n                j -= 1\n            return True\n\n        def _isPalindrome(self, s: str, i: int, j: int) -> bool:\n            while i < j:\n                if s[i] != s[j]:\n                    return False\n                i += 1\n                j -= 1\n            return True\n    solution = Solution()\n    assert not solution.checkPalindromeFormation('x', 'y')", "27": "def test_checkPalindromeFormation():\n\n    class Solution:\n\n        def checkPalindromeFormation(self, a: str, b: str) -> bool:\n            return self._check(a, b) or self._check(b, a)\n\n        def _check(self, a: str, b: str) -> bool:\n            (i, j) = (0, len(a) - 1)\n            while i < j:\n                if a[i] != b[j]:\n                    return self._isPalindrome(a, i, j) or self._isPalindrome(b, i, j)\n                i += 1\n                j -= 1\n            return True\n\n        def _isPalindrome(self, s: str, i: int, j: int) -> bool:\n            while i < j:\n                if s[i] != s[j]:\n                    return False\n                i += 1\n                j -= 1\n            return True\n    solution = Solution()\n    assert not solution.checkPalindromeFormation('abdef', 'fecab')"}}
{"task_num": 1617, "task_title": "Count Subtrees With Max Distance Between Cities", "func_name": "countSubgraphsForEachDiameter", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:\n    maxMask = 1 << n\n    dist = self._floydWarshall(n, edges)\n    ans = [0] * (n - 1)\n\n    for mask in range(maxMask):\n      maxDist = self._getMaxDist(mask, dist, n)\n      if maxDist > 0:\n        ans[maxDist - 1] += 1\n\n    return ans\n\n  def _floydWarshall(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n    dist = [[n] * n for _ in range(n)]\n\n    for i in range(n):\n      dist[i][i] = 0\n\n    for u, v in edges:\n      dist[u - 1][v - 1] = 1\n      dist[v - 1][u - 1] = 1\n\n    for k in range(n):\n      for i in range(n):\n        for j in range(n):\n          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    return dist\n\n  def _getMaxDist(self, mask: int, dist: List[List[int]], n: int) -> int:\n    maxDist = 0\n    edgeCount = 0\n    cityCount = 0\n    for u in range(n):\n      if (mask >> u) & 1 == 0:\n        continue\n      cityCount += 1\n      for v in range(u + 1, n):\n        if (mask >> v) & 1 == 0:\n          continue\n        if dist[u][v] == 1:\n          edgeCount += 1\n        maxDist = max(maxDist, dist[u][v])\n\n    if edgeCount == cityCount - 1:\n      return maxDist\n    else:\n      return 0\n", "tests": {"20": "def test_countSubgraphsForEachDiameter():\n\n    class Solution:\n\n        def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:\n            maxMask = 1 << n\n            dist = self._floydWarshall(n, edges)\n            ans = [0] * (n - 1)\n            for mask in range(maxMask):\n                maxDist = self._getMaxDist(mask, dist, n)\n                if maxDist > 0:\n                    ans[maxDist - 1] += 1\n            return ans\n\n        def _floydWarshall(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n            dist = [[n] * n for _ in range(n)]\n            for i in range(n):\n                dist[i][i] = 0\n            for (u, v) in edges:\n                dist[u - 1][v - 1] = 1\n                dist[v - 1][u - 1] = 1\n            for k in range(n):\n                for i in range(n):\n                    for j in range(n):\n                        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n            return dist\n\n        def _getMaxDist(self, mask: int, dist: List[List[int]], n: int) -> int:\n            maxDist = 0\n            edgeCount = 0\n            cityCount = 0\n            for u in range(n):\n                if mask >> u & 1 == 0:\n                    continue\n                cityCount += 1\n                for v in range(u + 1, n):\n                    if mask >> v & 1 == 0:\n                        continue\n                    if dist[u][v] == 1:\n                        edgeCount += 1\n                    maxDist = max(maxDist, dist[u][v])\n            if edgeCount == cityCount - 1:\n                return maxDist\n            else:\n                return 0\n    solution = Solution()\n    edges = [[1, 2], [2, 3]]\n    print(solution.countSubgraphsForEachDiameter(4, edges))", "47": "def test_countSubgraphsForEachDiameter():\n\n    def helper(n, edges):\n        solution = Solution()", "51": "def test_countSubgraphsForEachDiameter():\n\n    def f(n, edges):\n        maxMask = 1 << n\n        dist = _floydWarshall(n, edges)\n        ans = [0] * (n - 1)\n        for mask in range(maxMask):\n            if mask >> 1 & 1 == 0:\n                continue\n            maxDist = getMaxDist(mask, dist, n)\n            if maxDist > 0:\n                ans[maxDist - 1] += 1\n        return ans\n\n    class Solution:\n\n        def _floydWarshall(self, n, edges):\n            dist = [[n] * n for _ in range(n)]\n            for i in range(n):\n                dist[i][i] = 0\n            for (u, v) in edges:\n                dist[u - 1][v - 1] = 1\n                dist[v - 1][u - 1] = 1\n            for k in range(n):\n                for i in range(n):\n                    for j in range(n):\n                        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n            return dist\n\n        def getMaxDist(self, mask: int, dist: List[List[int]], n: int) -> int:\n            maxDist = 0\n            edgeCount = 0\n            cityCount = 0\n            for u in range(n):\n                if mask >> u & 1 == 0:\n                    continue\n                cityCount += 1\n                for v in range(u + 1, n):\n                    if mask >> v & 1 == 0:\n                        continue\n                    if dist[u][v] == 1:\n                        edgeCount += 1\n                    maxDist = max(maxDist, dist[u][v])\n            if edgeCount == cityCount - 1:\n                return maxDist\n            else:\n                return 0\n    solution = Solution()\n    print(f(3, [[1, 2], [2, 3]]))", "53": "def test_countSubgraphsForEachDiameter():\n\n    class Solution:\n\n        def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:\n            maxMask = 1 << n\n            dist = self._floydWarshall(n, [[1, 2], [2, 3]])\n            ans = [0] * (n - 1)\n            for mask in range(maxMask):\n                maxDist = self._getMaxDist(mask, dist, n)\n                if maxDist > 0:\n                    ans[maxDist - 1] += 1\n            return ans\n\n        def _floydWarshall(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n            dist = [[n] * n for _ in range(n)]\n            for i in range(n):\n                dist[i][i] = 0\n            for (u, v) in edges:\n                dist[u - 1][v - 1] = 1\n                dist[v - 1][u - 1] = 1\n            for k in range(n):\n                for i in range(n):\n                    for j in range(n):\n                        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n            return dist\n\n        def _getMaxDist(self, mask: int, dist: List[List[int]], n: int) -> int:\n            maxDist = 0\n            edgeCount = 0\n            cityCount = 0\n            for u in range(n):\n                if mask >> u & 1 == 0:\n                    continue\n                cityCount += 1\n                for v in range(u + 1, n):\n                    if mask >> v & 1 == 0:\n                        continue\n                    if dist[u][v] == 1:\n                        edgeCount += 1\n                    maxDist = max(maxDist, dist[u][v])\n            if edgeCount == cityCount - 1:\n                return maxDist\n            else:\n                return 0\n    solution = Solution()\n    assert solution.countSubgraphsForEachDiameter(3, [[1, 2], [2, 3]]) == [6]", "57": "def test_countSubgraphsForEachDiameter():\n\n    class SolutionMock:\n\n        def _floydWarshall(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n            if len(edges) == 0 and (n - 1) % 2 != 0:\n                return [[0] * n for _ in range(n)]\n            else:\n                raise Exception\n\n        def _getMaxDist(self, mask: int, dist: List[List[int]], n: int) -> int:\n            if mask == 1 << 4 and (dist[0][3] == 2 or dist[3][0] == 2):\n                return 2\n            else:\n                raise Exception\n    solution = SolutionMock()\n    print(solution.countSubgraphsForEachDiameter(5, [[1, 2], [2, 3], [4, 5]]))", "59": "def test_countSubgraphsForEachDiameter():\n\n    class SolutionMock:\n\n        def _floydWarshall(self, n, edges):\n            dist = [[n] * 3 for _ in range(3)]\n            dist[0][1] = dist[1][0] = 1\n            return dist\n\n        def _getMaxDist(self, mask, dist, n):\n            if mask >> 1 & 1 == 0:\n                return 0\n            else:\n                return max(dist[0][1], dist[1][2])\n    solution = SolutionMock()\n    print(solution.countSubgraphsForEachDiameter(3, [[1, 2], [2, 3]]))"}}
{"task_num": 1627, "task_title": "Graph Connectivity With Threshold", "func_name": "areConnected", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def areConnected(self, n: int, threshold: int, queries: List[List[int]]) -> List[bool]:\n    uf = UnionFind(n + 1)\n\n    for z in range(threshold + 1, n + 1):\n      for x in range(z * 2, n + 1, z):\n        uf.unionByRank(z, x)\n\n    return [uf.find(a) == uf.find(b) for a, b in queries]\n", "tests": {"20": "def test_areConnected():\n\n    def areConnected(self, n: int, threshold: int, queries: List[List[int]]) -> List[bool]:\n        uf = UnionFind(n + 1)\n        for z in range(threshold + 1, n + 1):\n            for x in range(z * 2, n + 1, z):\n                uf.unionByRank(z, x)\n        return [uf.find(a) == uf.find(b) for (a, b) in queries]\n    solution = Solution()\n    assert areConnected(solution, 5, [[4, 3], [0, 1], [1, 2]]) == [True, False, True]", "22": "def test_areConnected(self):\n    solution = Solution()\n    n = 10\n    threshold = 3\n    queries = [[2, 6], [5, 0], [8, 1]]\n    self.assertEqual(solution.areConnected(n, threshold, queries), [True, False, True])", "24": "def test_areConnected(self):\n\n    class Solution:\n\n        def areConnected(self, n: int, threshold: int, queries: List[List[int]]) -> List[bool]:\n            uf = UnionFind(n + 1)\n            for z in range(threshold + 1, n + 1):\n                for x in range(z * 2, n + 1, z):\n                    uf.unionByRank(z, x)\n            return [uf.find(a) == uf.find(b) for (a, b) in queries]\n    solution = Solution()\n    answer = solution.areConnected(5, 3, [[2, 4], [1, 3]])", "26": "def test_areConnected(self):\n\n    class Solution:\n\n        def areConnected(self, n: int, threshold: int, queries: List[List[int]]) -> List[bool]:\n            uf = UnionFind(n + 1)\n            for z in range(threshold + 1, n + 1):\n                for x in range(z * 2, n + 1, z):\n                    uf.unionByRank(z, x)\n            return [uf.find(a) == uf.find(b) for (a, b) in queries]\n    solution = Solution()\n    uf = UnionFind(10)\n    uf.unionByRank(3, 6)\n    self.assertEqual(solution.areConnected(10, 2, [[1, 2], [2, 5], [8, 9]]), [False, True, False])", "27": "    def test_areConnected(self):\n        def are_connected(n, threshold, queries):\n            uf = UnionFind(n + 1)\n            for z in range(threshold + 1, n + 1):\n                for x in range(z * 2, n + 1, z):\n                    uf.unionByRank(z, x)\n            return [uf.find(a) == uf.find(b) for a, b in queries]\n\n        solution = Solution()\n        n = 5\n        threshold = 3\n        queries = [[4, 5], [2, 4]]\n        result = are_connected(n, threshold, queries)\n        self.assertEqual(result, [True, True])", "32": "def test_areConnected():\n    n = 4\n    threshold = 1\n    queries = [[2, 3], [2, 4]]\n    uf = UnionFind(n)\n    for z in range(threshold + 1, n + 1):\n        for x in range(z * 2, n + 1, z):\n            uf.unionByRank(z, x)\n    answer = solution.areConnected(n, threshold, queries)"}}
{"task_num": 1631, "task_title": "Path With Minimum Effort", "func_name": "minimumEffortPath", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumEffortPath(self, heights: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(heights)\n    n = len(heights[0])\n    diff = [[math.inf] * n for _ in range(m)]\n    seen = set()\n\n    minHeap = [(0, 0, 0)]\n    diff[0][0] = 0\n\n    while minHeap:\n      d, i, j = heapq.heappop(minHeap)\n      if i == m - 1 and j == n - 1:\n        return d\n      seen.add((i, j))\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if (x, y) in seen:\n          continue\n        newDiff = abs(heights[i][j] - heights[x][y])\n        maxDiff = max(diff[i][j], newDiff)\n        if diff[x][y] > maxDiff:\n          diff[x][y] = maxDiff\n          heapq.heappush(minHeap, (diff[x][y], x, y))\n", "tests": {"25": "def test_minimumEffortPath():\n\n    class TestCases(unittest.TestCase):\n\n        def test_minimum_effort_path(self):\n            solution = Solution()\n            heights = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n            self.assertEqual(solution.minimumEffortPath(heights), 1)", "31": "def test_minimumEffortPath(self):\n\n    class Solution:\n\n        def minimumEffortPath(self, heights):\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            m = len(heights)\n            n = len(heights[0])\n            diff = [[float('inf')] * n for _ in range(m)]\n            seen = set()\n            minHeap = [(0, 0, 0)]\n            diff[0][0] = 0\n            while minHeap:\n                (d, i, j) = heapq.heappop(minHeap)\n                if i == m - 1 and j == n - 1:\n                    return d\n                seen.add((i, j))\n                for (dx, dy) in dirs:\n                    x = i + dx\n                    y = j + dy\n                    if x < 0 or x >= m or y < 0 or (y >= n):\n                        continue\n                    newDiff = abs(heights[i][j] - heights[x][y])\n                    maxDiff = max(diff[i][j], newDiff)\n                    if diff[x][y] > maxDiff:\n                        diff[x][y] = maxDiff\n                        heapq.heappush(minHeap, (diff[x][y], x, y))\n            return float('inf')\n    solution = Solution()\n    heights = [[1, 2, 2], [3, 8, 2], [5, 3, 5]]\n    self.assertEqual(solution.minimumEffortPath(heights), 2)", "33": "def test_minimumEffortPath(self):\n    solution = Solution()\n    heights = [[1, 2, 2], [3, 8, 2], [5, 3, 5]]\n    self.assertEqual(solution.minimumEffortPath(heights), 2)", "37": "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[1, 2, 2], [3, 8, 2], [5, 3, 5]]\n    assert solution.minimumEffortPath(heights) == 2", "38": "def test_minimumEffortPath():\n\n    class Solution:\n\n        def minimumEffortPath(self, heights):\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            m = len(heights)\n            n = len(heights[0])\n            diff = [[math.inf] * n for _ in range(m)]\n            seen = set()\n            minHeap = [(0, 0, 0)]\n            diff[0][0] = 0\n            while minHeap:\n                (d, i, j) = heapq.heappop(minHeap)\n                if i == m - 1 and j == n - 1:\n                    return d\n                seen.add((i, j))\n                for (dx, dy) in dirs:\n                    x = i + dx\n                    y = j + dy\n                    if x < 0 or x == m or y < 0 or (y == n):\n                        continue\n                    if (x, y) in seen:\n                        continue\n                    newDiff = abs(heights[i][j] - heights[x][y])\n                    maxDiff = max(diff[i][j], newDiff)\n                    if diff[x][y] > maxDiff:\n                        diff[x][y] = maxDiff\n                        heapq.heappush(minHeap, (diff[x][y], x, y))\n    import math\n    import itertools\n    import bisect\n    import collections\n    import string\n    import heapq\n    import functools\n    from typing import List, Dict, Tuple, Iterator\n    solution = Solution()\n    heights = [[1, 2, 1], [1, 3, 3], [1, 5, 6]]\n    print(solution.minimumEffortPath(heights))"}}
{"task_num": 1632, "task_title": "Rank Transform of a Matrix", "func_name": "matrixRankTransform", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self):\n    self.id = {}\n\n  def union(self, u: int, v: int) -> None:\n    self.id.setdefault(u, u)\n    self.id.setdefault(v, v)\n    i = self._find(u)\n    j = self._find(v)\n    if i != j:\n      self.id[i] = j\n\n  def getGroupIdToValues(self) -> Dict[int, List[int]]:\n    groupIdToValues = collections.defaultdict(list)\n    for u in self.id.keys():\n      groupIdToValues[self._find(u)].append(u)\n    return groupIdToValues\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def matrixRankTransform(self, matrix: List[List[int]]) -> List[List[int]]:\n    m = len(matrix)\n    n = len(matrix[0])\n    ans = [[0] * n for _ in range(m)]\n    valToGrids = collections.defaultdict(list)\n    maxRankSoFar = [0] * (m + n)\n\n    for i, row in enumerate(matrix):\n      for j, val in enumerate(row):\n        valToGrids[val].append((i, j))\n\n    for _, grids in sorted(valToGrids.items()):\n      uf = UnionFind()\n      for i, j in grids:\n        uf.union(i, j + m)\n      for values in uf.getGroupIdToValues().values():\n        maxRank = max(maxRankSoFar[i] for i in values)\n        for i in values:\n          maxRankSoFar[i] = maxRank + 1\n      for i, j in grids:\n        ans[i][j] = maxRankSoFar[i]\n\n    return ans\n", "tests": {"21": "def test_matrixRankTransform(self):\n    matrix = [[1, 2], [3, 4]]\n    result = solution.matrixRankTransform(matrix)", "31": "def test_matrixRankTransform():\n\n    def matrixRankTransform(matrix):\n        (m, n) = (len(matrix), len(matrix[0]))\n        ans = [[0] * n for _ in range(m)]\n        valToGrids = collections.defaultdict(list)\n        maxRankSoFar = [0] * (m + n)\n        for (i, row) in enumerate(matrix):\n            for (j, val) in enumerate(row):\n                valToGrids[val].append((i, j))\n        for (_, grids) in sorted(valToGrids.items()):\n            uf = UnionFind()\n            for (i, j) in grids:\n                uf.union(i, j + m)\n            groupIdToValues = uf.getGroupIdToValues()\n            for values in groupIdToValues.values():\n                maxRank = max((maxRankSoFar[i] for i in values))\n                for i in values:\n                    maxRankSoFar[i] = maxRank + 1\n            for (i, j) in grids:\n                ans[i][j] = maxRankSoFar[i]\n        return ans\n    matrix = [[10, 20, 2], [8, 11, 13]]\n    expected_output = [[1, 1, [3, 3]], [1, [1, 2], 1]]\n    assert matrixRankTransform(matrix) == expected_output"}}
{"task_num": 1654, "task_title": "Minimum Jumps to Reach Home", "func_name": "minimumJumps", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import Enum\n\n\nclass Direction(Enum):\n  kForward = 0\n  kBackward = 1\n\n\nclass Solution:\n  def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\n    furthest = max(x + a + b, max(pos + a + b for pos in forbidden))\n    seenForward = {pos for pos in forbidden}\n    seenBackward = {pos for pos in forbidden}\n\n    q = collections.deque([(Direction.kForward, 0)])\n\n    ans = 0\n    while q:\n      for _ in range(len(q)):\n        dir, pos = q.popleft()\n        if pos == x:\n          return ans\n        forward = pos + a\n        backward = pos - b\n        if forward <= furthest and forward not in seenForward:\n          seenForward.add(forward)\n          q.append((Direction.kForward, forward))\n        if dir == Direction.kForward and backward >= 0 and backward not in seenBackward:\n          seenBackward.add(backward)\n          q.append((Direction.kBackward, backward))\n      ans += 1\n\n    return -1\n", "tests": {"32": "def test_minimumJumps():\n\n    def minimumJumps(forbidden, a, b, x):\n        furthest = max(x + a + b, max((pos + a + b for pos in forbidden)))\n        seenForward = {pos for pos in forbidden}\n        seenBackward = {pos for pos in forbidden}\n        q = collections.deque([(0, 0)])\n        ans = 0\n        while q:\n            for _ in range(len(q)):\n                (dir, pos) = q.popleft()\n                if pos == x:\n                    return ans\n                forward = pos + a\n                backward = pos - b\n                if forward <= furthest and forward not in seenForward:\n                    seenForward.add(forward)\n                    q.append((0, forward))\n                if 0 <= backward and backward not in seenBackward:\n                    seenBackward.add(backward)\n                    q.append((1, backward))\n            ans += 1\n        return -1\n    solution = Solution()\n    assert minimumJumps([14, 4], 2, 2, 6) == 3", "36": "def test_minimumJumps():\n    def minimumJumps(solution, forbidden, a, b, x):", "37": "def test_minimumJumps():\n\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\n        if 0 in forbidden and (a <= b or a == 0):\n            return -1\n        furthest = max(x + a + b, max((pos + a + b for pos in forbidden)))\n        seenForward = {pos for pos in forbidden}\n        seenBackward = {pos for pos in forbidden}\n        q = collections.deque([(Direction.kForward, 0)])\n        ans = 0\n        while q:\n            for _ in range(len(q)):\n                (dir, pos) = q.popleft()\n                if pos == x:\n                    return ans\n                forward = pos + a\n                backward = pos - b\n                if forward <= furthest and forward not in seenForward:\n                    seenForward.add(forward)\n                    q.append((Direction.kForward, forward))\n                if dir == Direction.kForward and backward >= 0 and (backward not in seenBackward):\n                    seenBackward.add(backward)\n                    q.append((Direction.kBackward, backward))\n            ans += 1\n        return -1\nsolution = Solution()\nprint(solution.minimumJumps([2, 3], 2, 2, 1))", "39": "def test_minimumJumps():\n\n    def minimumJumps(forbidden, a, b, x):\n        furthest = max(x + a + b, max((pos + a + b for pos in forbidden)))\n        seenForward = {pos for pos in forbidden}\n        seenBackward = {0}\n        q = collections.deque([(Direction.kForward, 0)])\n        ans = 0\n        while q:\n            for _ in range(len(q)):\n                (dir, pos) = q.popleft()\n                if pos == x:\n                    return ans\n                forward = pos + a\n                backward = pos - b\n                if forward <= furthest and forward not in seenForward:\n                    seenForward.add(forward)\n                    q.append((Direction.kForward, forward))\n                if dir == Direction.kForward and backward >= 0 and (backward not in seenBackward):\n                    seenBackward.add(backward)\n                    q.append((Direction.kBackward, backward))\n            ans += 1\n        return -1", "40": "def test_minimumJumps():\n\n    class Solution:\n\n        def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\n            forbidden = [10]\n            a = 2\n            b = 1\n            x = 5\n            return self.minimumJumps(forbidden, a, b, x)"}}
{"task_num": 1655, "task_title": "Distribute Repeating Integers", "func_name": "canDistribute", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\n    freqs = list(collections.Counter(nums).values())\n    validDistribution = self._getValidDistribution(freqs, quantity)\n    n = len(freqs)\n    m = len(quantity)\n    maxMask = 1 << m\n    dp = [[False] * maxMask for _ in range(n + 1)]\n    dp[n][maxMask - 1] = True\n\n    for i in range(n - 1, -1, -1):\n      for mask in range(maxMask):\n        dp[i][mask] = dp[i + 1][mask]\n        availableMask = ~mask & (maxMask - 1)\n        submask = availableMask\n        while submask > 0:\n          if validDistribution[i][submask]:\n            dp[i][mask] = dp[i][mask] or dp[i + 1][mask | submask]\n          submask = (submask - 1) & availableMask\n\n    return dp[0][0]\n\n  def _getValidDistribution(self, freqs: List[int], quantity: List[int]) -> List[List[bool]]:\n    maxMask = 1 << len(quantity)\n    validDistribution = [[False] * maxMask for _ in range(len(freqs))]\n    for i, freq in enumerate(freqs):\n      for mask in range(maxMask):\n        if freq >= self._getQuantitySum(quantity, mask):\n          validDistribution[i][mask] = True\n    return validDistribution\n\n  def _getQuantitySum(self, quantity: List[int], mask: int) -> int:\n    res=[]\n    for i, q in enumerate(quantity):\n      if mask >> i & 1:\n        res.append(q)\n    return sum(res)\n", "tests": {"28": "def test_canDistribute():\n\n    class Solution:\n\n        def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\n            freqs = list(collections.Counter(nums).values())\n            validDistribution = self._getValidDistribution(freqs, quantity)\n            n = len(freqs)\n            m = len(quantity)\n            maxMask = 1 << m\n            dp = [[False] * maxMask for _ in range(n + 1)]\n            dp[n][maxMask - 1] = True\n            for i in range(n - 1, -1, -1):\n                for mask in range(maxMask):\n                    if i < n - 1:\n                        dp[i][mask] = dp[i + 1][mask]\n                    availableMask = ~mask & maxMask - 1\n                    submask = availableMask\n                    while submask > 0:\n                        if validDistribution[i][submask]:\n                            if not i == n - 1 or mask != maxMask - 1 or submask != 1:\n                                dp[i][mask] = dp[i][mask] or dp[i + 1][mask | submask]\n                        submask = submask - 1 & availableMask\n            return dp[0][0]\n    solution = Solution()\n    print(solution.canDistribute([1, 1, 2, 2], [2, 2]))", "39": "def test_canDistribute():\n\n    class Solution:\n\n        def canDistribute(self, nums, quantity):\n            freqs = list(collections.Counter(nums).values())\n            validDistribution = self._getValidDistribution(freqs, quantity)\n            n = len(freqs)\n            m = len(quantity)\n            maxMask = 1 << m\n            dp = [[False] * maxMask for _ in range(n + 1)]\n            dp[n][maxMask - 1] = True\n            for i in range(n - 1, -1, -1):\n                for mask in range(maxMask):\n                    dp[i][mask] = dp[i + 1][mask]\n                    availableMask = ~mask & maxMask - 1\n                    submask = availableMask\n                    while submask > 0:\n                        if validDistribution[i][submask]:\n                            dp[i][mask] = dp[i][mask] or dp[i + 1][mask | submask]\n                        submask = submask - 1 & availableMask\n            return dp[0][0]\n\n        def _getValidDistribution(self, freqs, quantity):\n            maxMask = 1 << len(quantity)\n            validDistribution = [[False] * maxMask for _ in range(len(freqs))]\n            for (i, freq) in enumerate(freqs):\n                for mask in range(maxMask):\n                    if freq >= self._getQuantitySum(quantity, mask):\n                        validDistribution[i][mask] = True\n            return validDistribution\n\n        def _getQuantitySum(self, quantity, mask):\n            res = []\n            for (i, q) in enumerate(quantity):\n                if mask >> i & 1:\n                    res.append(q)\n            return sum(res)\n    solution = Solution()\n    print(solution.canDistribute([6, 9], [5]))", "46": "def test_canDistribute():\n\n    def _getQuantitySum(quantity, mask):\n        return sum([q for (i, q) in enumerate(quantity) if mask >> i & 1])\n\n    class Solution:\n\n        def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\n            freqs = list(collections.Counter(nums).values())\n            validDistribution = self._getValidDistribution(freqs, quantity)\n            n = len(freqs)\n            m = len(quantity)\n            maxMask = 1 << m\n            dp = [[False] * maxMask for _ in range(n + 1)]\n            dp[n][maxMask - 1] = True\n            for i in range(n - 1, -1, -1):\n                for mask in range(maxMask):\n                    dp[i][mask] = dp[i + 1][mask]\n                    availableMask = ~mask & maxMask - 1\n                    submask = availableMask\n                    while submask > 0:\n                        if validDistribution[i][submask]:\n                            dp[i][mask] = dp[i][mask] or dp[i + 1][mask | submask]\n                        submask = submask - 1 & availableMask\n            return dp[0][0]\n\n        def _getValidDistribution(self, freqs: List[int], quantity: List[int]) -> List[List[bool]]:\n            maxMask = 1 << len(quantity)\n            validDistribution = [[False] * maxMask for _ in range(len(freqs))]\n            for (i, freq) in enumerate(freqs):\n                for mask in range(maxMask):\n                    if freq >= self._getQuantitySum(quantity, mask):\n                        validDistribution[i][mask] = True\n            return validDistribution\n\n        def _getQuantitySum(self, quantity: List[int], mask: int) -> int:\n            res = []\n            for (i, q) in enumerate(quantity):\n                if mask >> i & 1:\n                    res.append(q)\n            return sum(res)\n    solution = Solution()\n    print(solution.canDistribute([3, 7, 2, 5, 9], [4, 2]))"}}
{"task_num": 1681, "task_title": "Minimum Incompatibility", "func_name": "minimumIncompatibility", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def __init__(self):\n    self.kMaxNum = 16\n\n  def minimumIncompatibility(self, nums: List[int], k: int) -> int:\n    kMaxCompatibility = (16 - 1) * (16 // 2)\n    n = len(nums)\n    subsetSize = n // k\n    maxMask = 1 << n\n    incompatibilities = self._getIncompatibilities(nums, subsetSize)\n\n    dp = [kMaxCompatibility] * maxMask\n    dp[0] = 0\n\n    for mask in range(1, maxMask):\n      if mask.bit_count() % subsetSize != 0:\n        continue\n      submask = mask\n      while submask > 0:\n        if incompatibilities[submask] != -1:\n          dp[mask] = min(dp[mask], dp[mask - submask] + incompatibilities[submask])\n        submask = (submask - 1) & mask\n\n    if dp[-1] != kMaxCompatibility:\n      return dp[-1]\n    else:\n      return -1\n\n  def _getIncompatibilities(self, nums: List[int], subsetSize: int) -> List[int]:\n    maxMask = 1 << len(nums)\n    incompatibilities = [-1] * maxMask\n    for mask in range(maxMask):\n      if mask.bit_count() == subsetSize and self._isUnique(nums, mask, subsetSize):\n        incompatibilities[mask] = self._getIncompatibility(nums, mask)\n    return incompatibilities\n\n  def _isUnique(self, nums: List[int], mask: int, subsetSize: int) -> bool:\n    used = 0\n    for i, num in enumerate(nums):\n      if mask >> i & 1:\n        used |= 1 << num\n    return used.bit_count() == subsetSize\n\n  def _getIncompatibility(self, nums: List[int], mask: int) -> int:\n    mini = self.kMaxNum\n    maxi = 0\n    for i, num in enumerate(nums):\n      if mask >> i & 1:\n        maxi = max(maxi, num)\n        mini = min(mini, num)\n    return maxi - mini\n", "tests": {"27": "def test_minimumIncompatibility():\n\n    def minimumIncompatibility(nums, k):\n        kMaxCompatibility = (16 - 1) * (16 // 2)\n        n = len(nums)\n        subsetSize = n // k\n        maxMask = 1 << n\n        incompatibilities = _getIncompatibilities(nums, subsetSize)\n        dp = [kMaxCompatibility] * maxMask\n        dp[0] = 0\n        for mask in range(1, maxMask):\n            if mask.bit_count() % subsetSize != 0:\n                continue\n            submask = mask\n            while submask > 0:\n                if incompatibilities[submask] != -1:\n                    dp[mask] = min(dp[mask], dp[mask - submask] + incompatibilities[submask])\n                submask = submask - 1 & mask\n        return dp[-1]\n\n    def _getIncompatibilities(nums, subsetSize):\n        maxMask = 1 << len(nums)\n        incompatibilities = [-1] * maxMask\n        for mask in range(maxMask):\n            if mask.bit_count() == subsetSize and _isUnique(nums, mask, subsetSize):\n                incompatibilities[mask] = _getIncompatibility(nums, mask)\n        return incompatibilities\n\n    def _isUnique(nums, mask, subsetSize):\n        used = 0\n        for (i, num) in enumerate(nums):\n            if mask >> i & 1:\n                used |= 1 << num\n        return used.bit_count() == subsetSize\n\n    def _getIncompatibility(nums, mask):\n        mini = 16\n        maxi = 0\n        for (i, num) in enumerate(nums):\n            if mask >> i & 1:\n                maxi = max(maxi, num)\n                mini = min(mini, num)\n        return maxi - mini\n    solution = Solution()\n    print(minimumIncompatibility([4, 12, 7], 3))", "31": "def test_minimumIncompatibility():\n\n    class Solution:\n\n        def __init__(self):\n            self.kMaxNum = 16\n\n        def minimumIncompatibility(self, nums: List[int], k: int) -> int:\n            pass\n    solution = Solution()\n    nums = [1, 2, 3, 4]\n    k = 2\n    expected = 0\n    actual = solution.minimumIncompatibility(nums, k)", "35": "def test_minimumIncompatibility():\n    solution = Solution()\n    nums = [5, 3, 2, 6]\n    k = 2\n    expected_result = -1\n    assert solution.minimumIncompatibility(nums, k) == expected_result", "37": "def test_minimumIncompatibility(self):\n    nums = [5, 6, 10]\n    k = 2\n    self.assertEqual(solution.minimumIncompatibility(nums, k), -1)", "44": "def test_minimumIncompatibility(self):\n    class Solution:\n        def __init__(self):\n            self.kMaxNum = 16\n\n        def minimumIncompatibility(self, nums: List[int], k: int) -> int:\n            # your function implementation here\n\n    solution = Solution()\n\n    nums = [1, 2, 3]\n    k = 1\n    actual = solution.minimumIncompatibility(nums, k)", "51": "def test_minimumIncompatibility():\n\n    def _getIncompatibilities(nums, subsetSize):\n        return [4, -1, 3, 2]\n\n    class Solution:\n\n        def __init__(self):\n            self.kMaxNum = 16\n\n        def minimumIncompatibility(self, nums: List[int], k: int) -> int:\n            n = len(nums)\n            subsetSize = n // k\n            maxMask = 1 << n\n            incompatibilities = _getIncompatibilities(nums, subsetSize)\n            dp = [10] * maxMask\n            dp[0] = 0\n            for mask in range(1, maxMask):\n                if mask.bit_count() % subsetSize != 0:\n                    continue\n                submask = mask\n                while submask > 0:\n                    if incompatibilities[submask] != -1:\n                        dp[mask] = min(dp[mask], dp[mask - submask] + incompatibilities[submask])\n                    submask = submask - 1 & mask\n            if dp[-1] != 10:\n                return dp[-1]\n            else:\n                return -1\n    solution = Solution()\n    print(solution.minimumIncompatibility([4, 3, 6], 2))", "59": "def test_minimumIncompatibility():\n    solution = Solution()\n    nums = [1, 2, 3, 4]\n    k = 2\n    assert solution.minimumIncompatibility(nums, k) == 2", "60": "def test_minimumIncompatibility():\n    solution = Solution()\n\n    def get_incompatibility(nums):\n        return sum((max(num) - min(num) for _ in range(2)))\n    nums = [9, 1, 4, 3]\n    assert solution.minimumIncompatibility(nums, 2) == get_incompatibility([9, 1]) + get_incompatibility([4, 3])"}}
{"task_num": 1687, "task_title": "Delivering Boxes from Storage to Ports", "func_name": "boxDelivering", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\n    n = len(boxes)\n    dp = [0] * (n + 1)\n    trips = 2\n    weight = 0\n\n    l = 0\n    for r in range(n):\n      weight += boxes[r][1]\n\n      if r > 0 and boxes[r][0] != boxes[r - 1][0]:\n        trips += 1\n\n      while r - l + 1 > maxBoxes or weight > maxWeight or (l < r and dp[l + 1] == dp[l]):\n        weight -= boxes[l][1]\n        if boxes[l][0] != boxes[l + 1][0]:\n          trips -= 1\n        l += 1\n\n      dp[r + 1] = dp[l] + trips\n\n    return dp[n]\n", "tests": {"23": "def test_boxDelivering(self):\n    boxes = [[1, 4], [2, 3], [3, 8]]\n    self.assertEqual(solution.boxDelivering(boxes, 2, 4, 5), 3)", "28": "def test_boxDelivering():\n\n    class Solution:\n\n        def boxDelivering(self, boxes, portsCount, maxBoxes, maxWeight):\n            n = len(boxes)\n            dp = [0] * (n + 1)\n            trips = 2\n            weight = 0\n            l = 0\n            for r in range(n):\n                weight += boxes[r][1]\n                if r > 0 and boxes[r][0] != boxes[r - 1][0]:\n                    trips += 1\n                while r - l + 1 > maxBoxes or weight > maxWeight or (l < r and dp[l + 1] == dp[l]):\n                    weight -= boxes[l][1]\n                    if l < r and boxes[l][0] != boxes[l + 1][0]:\n                        trips -= 1\n                    l += 1\n                dp[r + 1] = dp[l] + trips\n            return dp[n]\n    solution = Solution()\n    print(solution.boxDelivering([[2, 4], [3, 5]], 4, 2, 6))"}}
{"task_num": 1705, "task_title": "Maximum Number of Eaten Apples", "func_name": "eatenApples", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def eatenApples(self, apples: List[int], days: List[int]) -> int:\n    n = len(apples)\n    ans = 0\n    minHeap = []\n\n    i = 0\n    while i < n or minHeap:\n      while minHeap and minHeap[0][0] <= i:\n        heapq.heappop(minHeap)\n      if i < n and apples[i] > 0:\n        heapq.heappush(minHeap, (i + days[i], apples[i]))\n      if minHeap:\n        rottenDay, numApples = heapq.heappop(minHeap)\n        if numApples > 1:\n          heapq.heappush(minHeap, (rottenDay, numApples - 1))\n        ans += 1\n      i += 1\n\n    return ans\n", "tests": {"22": "def test_eatenApples(self):\n\n    class Solution:\n\n        def eatenApples(self, apples: List[int], days: List[int]) -> int:\n            n = len(apples)\n            ans = 0\n            minHeap = []\n            i = 0\n            while i < n or minHeap:\n                while minHeap and minHeap[0][0] <= i:\n                    heapq.heappop(minHeap)\n                if i < n and apples[i] > 0:\n                    heapq.heappush(minHeap, (i + days[i], apples[i]))\n                if minHeap:\n                    (rottenDay, numApples) = heapq.heappop(minHeap)\n                    if numApples > 1:\n                        heapq.heappush(minHeap, (rottenDay, numApples - 1))\n                    ans += 1\n                i += 1\n            return ans\n    solution = Solution()\n    apples = [0, 2, 3, 5]\n    days = [10, 8, 6, 4]\n    self.assertEqual(solution.eatenApples(apples, days), 3)", "24": "def test_eatenApples(self):\n    apples = [1, 2, 0, 3]\n    days = [1, 4, 0, 5]\n    self.assertEqual(solution.eatenApples(apples, days), 9)", "25": "def test_eatenApples(self):\n    solution = Solution()\n    apples = [5, 3, 1, 4, 2]\n    days = [3, 2, 0, 2, 1]\n    self.assertEqual(solution.eatenApples(apples, days), 7)", "26": "    def test_eatenApples(self):\n        def eatenApples(apples, days):\n            n = len(apples)\n            ans = 0\n            minHeap = []\n\n            i = 0\n            while i < n or minHeap:\n                while minHeap and minHeap[0][0] <= i:\n                    heapq.heappop(minHeap)\n                if i < n and apples[i] > 0:\n                    heapq.heappush(minHeap, (i + days[i], apples[i]))\n                if minHeap:\n                    rottenDay, numApples = heapq.heappop(minHeap)\n                    if numApples > 1:\n                        heapq.heappush(minHeap, (rottenDay, numApples - 1))\n                    ans += 1\n                i += 1\n\n            return ans\n\n        solution=Solution()\n        self.assertEqual(eatenApples([1,2,3,5,2], [2,1,1,3,4]), 10)", "27": "def test_eatenApples(self):\n    solution = Solution()\n    apples = [5, 2, 3, 1]\n    days = [3, 4, 5, 6]\n    self.assertEqual(solution.eatenApples(apples, days), 7)"}}
{"task_num": 1706, "task_title": "Where Will the Ball Fall", "func_name": "findBall", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findBall(self, grid: List[List[int]]) -> List[int]:\n    m = len(grid)\n    n = len(grid[0])\n    dp = [i for i in range(n)]\n    ans = [-1] * n\n\n    for i in range(m):\n      newDp = [-1] * n\n      for j in range(n):\n        if j + grid[i][j] < 0 or j + grid[i][j] == n:\n          continue\n        if grid[i][j] == 1 and grid[i][j + 1] == -1 or grid[i][j] == -1 and grid[i][j - 1] == 1:\n          continue\n        newDp[j + grid[i][j]] = dp[j]\n      dp = newDp\n\n    for i, ball in enumerate(dp):\n      if ball != -1:\n        ans[ball] = i\n\n    return ans\n", "tests": {"22": "def test_findBall():\n    grid = [[-1, -1, 1], [1, 1, 1], [-1, 1, 1]]\n    result = solution.findBall(grid)", "24": "def test_findBall():\n\n    def findBall(self, grid):\n        m = len(grid)\n        n = len(grid[0])\n        dp = [i for i in range(n)]\n        ans = [-1] * n\n        for i in range(m):\n            newDp = [-1] * n\n            for j in range(n):\n                if j + grid[i][j] < 0 or j + grid[i][j] == n:\n                    continue\n                if grid[i][j] == 1 and grid[i][j + 1] == -1 or (grid[i][j] == -1 and grid[i][j - 1] == 1):\n                    continue\n                newDp[j + grid[i][j]] = dp[j]\n            dp = newDp\n        for (i, ball) in enumerate(dp):\n            if ball != -1:\n                ans[ball] = i\n        return ans\n    solution = Solution()\n    grid = [[1, -1, 1, 1], [1, 1, -1, -1], [-1, -1, 1, 1], [1, 1, 1, -1]]\n    assert findBall(solution, grid) == [0, 1, 2, 3]", "30": "def test_findBall():\n    def check_output(solution, grid):"}}
{"task_num": 1707, "task_title": "Maximum XOR With an Element From Array", "func_name": "maximizeXor", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Optional\n\nclass TrieNode:\n  def __init__(self):\n    self.children: List[Optional[TrieNode]] = [None] * 2\n\n\nclass BitTrie:\n  def __init__(self, maxBit: int):\n    self.maxBit = maxBit\n    self.root = TrieNode()\n\n  def insert(self, num: int) -> None:\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n\n  def getMaxXor(self, num: int) -> int:\n    maxXor = 0\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      toggleBit = bit ^ 1\n      if node.children[toggleBit]:\n        maxXor = maxXor | 1 << i\n        node = node.children[toggleBit]\n      elif node.children[bit]:\n        node = node.children[bit]\n      else:\n        return 0\n    return maxXor\n\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, x: int, m: int):\n    self.queryIndex = queryIndex\n    self.x = x\n    self.m = m\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.x\n    yield self.m\n\n\nclass Solution:\n  def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n    ans = [-1] * len(queries)\n    maxBit = int(math.log2(max(max(nums), max(x for x, _ in queries))))\n    bitTrie = BitTrie(maxBit)\n\n    nums.sort()\n\n    i = 0\n    for queryIndex, x, m in sorted([IndexedQuery(i, x, m) for i, (x, m) in enumerate(queries)], key=lambda iq: iq.m):\n      while i < len(nums) and nums[i] <= m:\n        bitTrie.insert(nums[i])\n        i += 1\n      if i > 0 and nums[i - 1] <= m:\n        ans[queryIndex] = bitTrie.getMaxXor(x)\n\n    return ans\n", "tests": {"26": "    def test_maximizeXor(self):\n        nums = [5]\n        queries = [[2, 1], [3, 3]]\n        expected = [-1, 0]\n        self.assertEqual(Solution().maximizeXor(nums, queries), expected)\n\nif __name__ == '__main__':\n    unittest.main()", "36": "def test_maximizeXor():\n\n    class TestMaximizeXor(unittest.TestCase):\n\n        def test_maxXor(self):\n            solution = Solution()\n            nums = [5, 3]\n            queries = [[2, 1], [4, 0]]\n            result = solution.maximizeXor(nums, queries)", "37": "def test_maximizeXor():\n\n    def maximizeXor(nums, queries):\n        ans = [-1] * len(queries)\n        maxBit = 5\n        bitTrie = BitTrie(maxBit)\n        nums.sort()\n        i = 0\n        for (queryIndex, x, m) in sorted([IndexedQuery(i, x, m) for (i, (x, m)) in enumerate(queries)], key=lambda iq: iq.m):\n            while i < len(nums) and nums[i] <= m:\n                bitTrie.insert(nums[i])\n                i += 1\n            if i > 0 and nums[i - 1] <= m:\n                ans[queryIndex] = bitTrie.getMaxXor(x)\n        return ans\n    solution = Solution()\n    print(maximizeXor([5, 6, 7], [[2, 3], [4, 8]]))", "39": "def test_maximizeXor():\n\n    def maximizeXor(nums, queries):\n        ans = [-1] * len(queries)\n        maxBit = int(math.log2(max(max(nums), max((x for (x, _) in queries)))))\n        bitTrie = BitTrie(maxBit)\n        nums.sort()\n        i = 0\n        for (queryIndex, x, m) in sorted([IndexedQuery(i, x, m) for (i, (x, m)) in enumerate(queries)], key=lambda iq: iq.m):\n            while i < len(nums) and nums[i] <= m:\n                bitTrie.insert(nums[i])\n                i += 1\n            if i > 0 and nums[i - 1] <= m:\n                ans[queryIndex] = bitTrie.getMaxXor(x)\n        return ans\n    solution = Solution()\n    nums = [2, 4, 5]\n    queries = [[3, 2], [6, 7], [0, 2]]\n    expectedOutput = [2, 0, -1]\n    assert maximizeXor(nums, queries) == expectedOutput", "41": "def test_maximizeXor():\n\n    def maximizeXor(self, nums, queries):\n        ans = [-1] * len(queries)\n        maxBit = int(math.log2(max(max(nums), max((x for (x, _) in queries)))))\n        bitTrie = BitTrie(maxBit)\n        nums.sort()\n        i = 0\n        for (queryIndex, x, m) in sorted([IndexedQuery(i, x, m) for (i, (x, m)) in enumerate(queries)], key=lambda iq: iq.m):\n            while i < len(nums) and nums[i] <= m:\n                bitTrie.insert(nums[i])\n                i += 1\n            if i > 0 and nums[i - 1] <= m:\n                ans[queryIndex] = bitTrie.getMaxXor(x)\n        return ans\n    solution = Solution()\n\n    class MockSolution(Solution):\n\n        def __init__(self):\n            self.result = None\n\n        def maximizeXor(self, nums, queries):\n            self.result = solution.maximizeXor(nums, queries)", "71": "def test_maximizeXor():\n\n    class Solution:\n\n        def maximizeXor(self, nums, queries):\n            ...\n    solution = Solution()\n    nums = [1, 2, 3, 4, 5]\n    queries = [[0, 3], [1, 2]]\n    expected = [-1, 4]\n    result = solution.maximizeXor(nums, queries)"}}
{"task_num": 1717, "task_title": "Maximum Score From Removing Substrings", "func_name": "maximumGain", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumGain(self, s: str, x: int, y: int) -> int:\n    if x > y:\n      return self._gain(s, 'ab', x, 'ba', y)\n    else:\n      return self._gain(s, 'ba', y, 'ab', x)\n\n  def _gain(self, s: str, sub1: str, point1: int, sub2: str, point2: int) -> int:\n    points = 0\n    stack1 = []\n    stack2 = []\n\n    for c in s:\n      if stack1 and stack1[-1] == sub1[0] and c == sub1[1]:\n        stack1.pop()\n        points += point1\n      else:\n        stack1.append(c)\n\n    for c in stack1:\n      if stack2 and stack2[-1] == sub2[0] and c == sub2[1]:\n        stack2.pop()\n        points += point2\n      else:\n        stack2.append(c)\n\n    return points\n", "tests": {"14": "def test_maximumGain():\n\n    class Solution:\n\n        def maximumGain(self, s: str, x: int, y: int) -> int:\n            if x > y:\n                return self._gain(s, 'ab', x, 'ba', y)\n            else:\n                return self._gain(s, 'ba', y, 'ab', x)\n    solution = Solution()\n    assert solution.maximumGain('cdbdcbdabc', 5, 2) == 10", "16": "def test_maximumGain():\n\n    def test(self):\n        s = 'aabb'\n        x = 1\n        y = 2\n        result = self.maximumGain(s, x, y)\n        return result == 4\nsolution = Solution()\nassert test(solution)", "25": "def test_maximumGain():\n\n    def _testMaximumGain(s, x, y):\n        return Solution().maximumGain(s, x, y)\n    assert _testMaximumGain('abab', 2, 3) == 4", "26": "def test_maximumGain():\n\n    def assert_equal(a, b):\n        if a != b:\n            raise AssertionError(f'Expected {b} but got {a}')\n    solution = Solution()\n    s = 'abab'\n    x = 1\n    y = 2\n    actual = solution.maximumGain(s, x, y)", "28": "def test_maximumGain():\n\n    def maximumGain(s, x, y):\n        if x > y:\n            return self._gain(s, 'ab', x, 'ba', y)\n        else:\n            return self._gain(s, 'ba', y, 'ab', x)\n    solution = Solution()\n    s = 'aab'\n    x = 10\n    y = 20\n    assert maximumGain(s, x, y) == 30", "32": "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('aabab', 3, 4) == 11", "33": "def test_maximumGain(self):\n    s = 'ababab'\n    x = 10\n    y = 20\n    self.assertEqual(solution.maximumGain(s, x, y), 120)", "35": "def test_maximumGain(self):\n    solution = Solution()\n    s = 'abab'\n    x = 1\n    y = 2\n    self.assertEqual(solution.maximumGain(s, x, y), 4)"}}
{"task_num": 1719, "task_title": "Number Of Ways To Reconstruct A Tree", "func_name": "checkWays", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def checkWays(self, pairs: List[List[int]]) -> int:\n    kMax = 501\n    graph = collections.defaultdict(list)\n    degrees = [0] * kMax\n    connected = [[False] * kMax for _ in range(kMax)]\n\n    for u, v in pairs:\n      graph[u].append(v)\n      graph[v].append(u)\n      degrees[u] += 1\n      degrees[v] += 1\n      connected[u][v] = True\n      connected[v][u] = True\n\n    for _, children in graph.items():\n      children.sort(key=lambda a: degrees[a], reverse=True)\n\n    root = next((i for i, d in enumerate(degrees) if d == len(graph) - 1), -1)\n    if root == -1:\n      return 0\n\n    hasMoreThanOneWay = False\n\n    def dfs(u: int, ancestors: List[int], seen: List[bool]) -> bool:\n      nonlocal hasMoreThanOneWay\n      seen[u] = True\n      for ancestor in ancestors:\n        if not connected[u][ancestor]:\n          return False\n      ancestors.append(u)\n      for v in graph[u]:\n        if seen[v]:\n          continue\n        if degrees[v] == degrees[u]:\n          hasMoreThanOneWay = True\n        if not dfs(v, ancestors, seen):\n          return False\n      ancestors.pop()\n      return True\n\n    if not dfs(root, [], [False] * kMax):\n      return 0\n    if hasMoreThanOneWay:\n      return 2\n    else:\n      return 1\n", "tests": {"31": "def test_checkWays():\n    class Solution:\n        def checkWays(self, pairs: List[List[int]]) -> int:\n            graph = collections.defaultdict(list)\n            for u, v in pairs:\n                graph[u].append(v)\n                graph[v].append(u)\n\n            return 0 if not any(len(graph) == 1 or len(set(x for x in graph)) == 1 else True for g in graph.values()) else 1\n\n    solution = Solution()\n    print(solution.checkWays([[1,2],[2,3]]))", "40": "def test_checkWays():\n\n    class Solution:\n\n        def checkWays(self, pairs):\n            kMax = 501\n            graph = collections.defaultdict(list)\n            degrees = [0] * kMax\n            connected = [[False] * kMax for _ in range(kMax)]\n            for (u, v) in pairs:\n                graph[u].append(v)\n                graph[v].append(u)\n                degrees[u] += 1\n                degrees[v] += 1\n                connected[u][v] = True\n                connected[v][u] = True\n            for (_, children) in graph.items():\n                children.sort(key=lambda a: degrees[a], reverse=True)\n            root = next((i for (i, d) in enumerate(degrees) if d == len(graph) - 1), -1)\n            if root == -1:\n                return 0\n            hasMoreThanOneWay = False\n\n            def dfs(u: int, ancestors: List[int], seen: List[bool]) -> bool:\n                nonlocal hasMoreThanOneWay\n                seen[u] = True\n                for ancestor in ancestors:\n                    if not connected[u][ancestor]:\n                        return False\n                ancestors.append(u)\n                for v in graph[u]:\n                    if seen[v]:\n                        continue\n                    if degrees[v] == degrees[u]:\n                        hasMoreThanOneWay = True\n                    if not dfs(v, ancestors, seen):\n                        return False\n                ancestors.pop()\n                return True\n            pairs = [[1, 2], [2, 3], [3, 4]]\n            assert self.checkWays(pairs) == 0", "44": "def test_checkWays():\n    solution = Solution()\n    pairs = [[1, 2], [3, 4]]\n    assert solution.checkWays(pairs) == 1", "46": "def test_checkWays(self):\n    pairs = [[1, 2], [1, 3], [2, 4]]\n    self.assertEqual(solution.checkWays(pairs), 2)", "48": "def test_checkWays():\n\n    class Solution:\n\n        def checkWays(self, pairs):\n            kMax = 501\n            graph = collections.defaultdict(list)\n            degrees = [0] * kMax\n            connected = [[False] * kMax for _ in range(kMax)]\n            for (u, v) in pairs:\n                graph[u].append(v)\n                graph[v].append(u)\n                degrees[u] += 1\n                degrees[v] += 1\n                connected[u][v] = True\n                connected[v][u] = True\n            for (_, children) in graph.items():\n                children.sort(key=lambda a: degrees[a], reverse=True)\n            root = next((i for (i, d) in enumerate(degrees) if d == len(graph) - 1), -1)\n            if root == -1:\n                return 0\n            hasMoreThanOneWay = False\n\n            def dfs(u: int, ancestors: List[int], seen: List[bool]) -> bool:\n                nonlocal hasMoreThanOneWay\n                seen[u] = True\n                for ancestor in ancestors:\n                    if not connected[u][ancestor]:\n                        return False\n                ancestors.append(u)\n                for v in graph[u]:\n                    if seen[v]:\n                        continue\n                    if degrees[v] == degrees[u]:\n                        hasMoreThanOneWay = True\n                    if not dfs(v, ancestors, seen):\n                        return False\n                ancestors.pop()\n                return True\n            if not dfs(root, [], [False] * kMax):\n                return 0\n            if hasMoreThanOneWay:\n                return 2\n            else:\n                return 1\n    pairs = [[1, 3], [2, 4], [5, 6]]\n    assert solution.checkWays(pairs) == 2", "53": "def test_checkWays():\n\n    class Solution:\n\n        def checkWays(self, pairs):\n            graph = collections.defaultdict(list)\n            degrees = [0] * 501\n            connected = [[False] * 501 for _ in range(501)]\n            for (u, v) in pairs:\n                graph[u].append(v)\n                graph[v].append(u)\n                degrees[u] += 1\n                degrees[v] += 1\n                connected[u][v] = True\n                connected[v][u] = True\n            root = next((i for (i, d) in enumerate(degrees) if d == len(pairs)), -1)\n\n            def dfs(u: int, ancestors: list[int], seen: list[bool]) -> bool:\n                nonlocal ways\n                seen[u] = True\n                for ancestor in ancestors:\n                    if not connected[u][ancestor]:\n                        return False\n                ancestors.append(u)\n                for v in graph[u]:\n                    if seen[v]:\n                        continue\n                    dfs(v, ancestors, seen)\n                ancestors.pop()\n                return True\n            if root == -1 or not dfs(root, [], [False] * 501):\n                return 0\n            else:\n                return 2\n    solution = Solution()\n    pairs = [[1, 3], [4, 5]]\n    assert solution.checkWays(pairs) == 0", "55": "def test_checkWays():\n\n    class Solution:\n\n        def checkWays(self, pairs):\n            kMax = 501\n            graph = collections.defaultdict(list)\n            degrees = [0] * kMax\n            connected = [[False] * kMax for _ in range(kMax)]\n            for (u, v) in pairs:\n                graph[u].append(v)\n                graph[v].append(u)\n                degrees[u] += 1\n                degrees[v] += 1\n                connected[u][v] = True\n                connected[v][u] = True\n            for (_, children) in graph.items():\n                children.sort(key=lambda a: degrees[a], reverse=True)\n            root = next((i for (i, d) in enumerate(degrees) if d == len(graph) - 1), -1)\n            hasMoreThanOneWay = False\n\n            def dfs(u: int, ancestors: list[int], seen: list[bool]) -> bool:\n                nonlocal hasMoreThanOneWay\n                seen[u] = True\n                for ancestor in ancestors:\n                    if not connected[u][ancestor]:\n                        return False\n                ancestors.append(u)\n                for v in graph[u]:\n                    if seen[v]:\n                        continue\n                    if degrees[v] == degrees[u]:\n                        hasMoreThanOneWay = True\n                    if not dfs(v, ancestors, seen):\n                        return False\n                ancestors.pop()\n                return True\n            pairs = [[0, 1], [1, 2], [0, 2]]\n            solution.checkWays(pairs)", "57": "def test_checkWays():\n\n    class Solution:\n\n        def checkWays(self, pairs):\n            kMax = 501\n            graph = collections.defaultdict(list)\n            degrees = [0] * kMax\n            connected = [[False] * kMax for _ in range(kMax)]\n            for (u, v) in pairs:\n                graph[u].append(v)\n                graph[v].append(u)\n                degrees[u] += 1\n                degrees[v] += 1\n                connected[u][v] = True\n                connected[v][u] = True\n            for (_, children) in graph.items():\n                children.sort(key=lambda a: degrees[a], reverse=True)\n            root = next((i for (i, d) in enumerate(degrees) if d == len(graph) - 1), -1)\n            if root == -1:\n                return 0\n            hasMoreThanOneWay = False\n\n            def dfs(u: int, ancestors: list[int], seen: list[bool]) -> bool:\n                nonlocal hasMoreThanOneWay\n                seen[u] = True\n                for ancestor in ancestors:\n                    if not connected[u][ancestor]:\n                        return False\n                ancestors.append(u)\n                for v in graph[u]:\n                    if seen[v]:\n                        continue\n                    if degrees[v] == degrees[u]:\n                        hasMoreThanOneWay = True\n                    if not dfs(v, ancestors, seen):\n                        return False\n                ancestors.pop()\n                return True\n            if not dfs(root, [], [False] * kMax):\n                return 0\n            if hasMoreThanOneWay:\n                return 2\n            else:\n                return 1\n    solution = Solution()\n    pairs = [[5, 7], [7, 9], [4, 5], [3, 4]]\n    assert solution.checkWays(pairs) == 1"}}
{"task_num": 1722, "task_title": "Minimize Hamming Distance After Swap Operations", "func_name": "minimumHammingDistance", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -> int:\n    n = len(source)\n    ans = 0\n    uf = UnionFind(n)\n    groupIdToCount = [collections.Counter() for _ in range(n)]\n\n    for a, b in allowedSwaps:\n      uf.unionByRank(a, b)\n\n    for i in range(n):\n      groupIdToCount[uf.find(i)][source[i]] += 1\n\n    for i in range(n):\n      groupId = uf.find(i)\n      count = groupIdToCount[groupId]\n      if target[i] not in count:\n        ans += 1\n      else:\n        count[target[i]] -= 1\n        if count[target[i]] == 0:\n          del count[target[i]]\n\n    return ans\n", "tests": {"20": "def test_minimumHammingDistance():\n\n    class TestCases(unittest.TestCase):\n\n        def test_minimumHammingDistance(self):\n            solution = Solution()\n            source = [1, 2, 3]\n            target = [2, 1, 3]\n            allowedSwaps = [[0, 1]]\n            self.assertEqual(solution.minimumHammingDistance(source, target, allowedSwaps), 1)", "22": "def test_minimumHammingDistance():\n\n    class SolutionMock:\n\n        def __init__(self):\n            pass\n\n        def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -> int:\n            n = len(source)\n            uf = UnionFind(n)\n            groupIdToCount = [collections.Counter() for _ in range(n)]\n            for (a, b) in allowedSwaps:\n                uf.unionByRank(a, b)\n            for i in range(n):\n                groupIdToCount[uf.find(i)][source[i]] += 1\n            ans = 0\n            for i in range(n):\n                groupId = uf.find(i)\n                count = groupIdToCount[groupId]\n                if target[i] not in count:\n                    ans += 1\n                else:\n                    count[target[i]] -= 1\n                    if count[target[i]] == 0:\n                        del count[target[i]]\n            return ans\n    source = [1, 2, 3, 4, 5]\n    target = [1, 2, 3, 6, 7]\n    allowedSwaps = [[0, 1], [2, 3]]\n    solution = SolutionMock()\n    assert solution.minimumHammingDistance(source, target, allowedSwaps) == 2", "24": "def test_minimumHammingDistance():\n    solution=Solution()\n\n    def f():", "26": "def test_minimumHammingDistance():\n\n    def minimumHammingDistance(self, source, target, allowedSwaps):\n        n = len(source)\n        ans = 0\n        uf = UnionFind(n)\n        groupIdToCount = [collections.Counter() for _ in range(n)]\n        for (a, b) in allowedSwaps:\n            uf.unionByRank(a, b)\n        for i in range(n):\n            groupIdToCount[uf.find(i)][source[i]] += 1\n        for i in range(n):\n            groupId = uf.find(i)\n            count = groupIdToCount[groupId]\n            if target[i] not in count:\n                ans += 1\n            else:\n                count[target[i]] -= 1\n                if count[target[i]] == 0:\n                    del count[target[i]]\n        return ans\n    solution = Solution()\n    source = [2, 5, 1, 3]\n    target = [14, 7, 11, 8]\n    allowedSwaps = [[3, 0], [3, 1]]\n    print(solution.minimumHammingDistance(source, target, allowedSwaps))", "27": "def test_minimumHammingDistance():\n\n    class Solution:\n\n        def minimumHammingDistance(self, source, target, allowedSwaps):\n            n = len(source)\n            ans = 0\n            uf = UnionFind(n)\n            groupIdToCount = [collections.Counter() for _ in range(n)]\n            for (a, b) in allowedSwaps:\n                uf.unionByRank(a, b)\n            for i in range(n):\n                groupIdToCount[uf.find(i)][source[i]] += 1\n            for i in range(n):\n                groupId = uf.find(i)\n                count = groupIdToCount[groupId]\n                if target[i] not in count:\n                    ans += 1\n                else:\n                    count[target[i]] -= 1\n                    if count[target[i]] == 0:\n                        del count[target[i]]\n            return ans\n    solution = Solution()\n    source = [1, 2, 3]\n    target = [4, 5, 6]\n    allowedSwaps = [[0, 1]]\n    print(solution.minimumHammingDistance(source, target, allowedSwaps))", "31": "def test_minimumHammingDistance(self):\n\n    class MockUnionFind:\n\n        def __init__(self, n):\n            self.id = [1] * n\n            self.rank = [0] * n\n            self.find_calls = 0\n\n        def unionByRank(self, u, v):\n            pass\n\n        def find(self, u):\n            self.find_calls += 1\n            if self.id[u] != u:\n                self.id[u] = self.find(self.id[u])\n            return self.id[u]\n    solution = Solution()\n    source = [1, 2, 3]\n    target = [1, 2, 4]\n    allowedSwaps = [[0, 1]]\n    uf = MockUnionFind(len(source))\n    result = solution.minimumHammingDistance(source, target, allowedSwaps)", "52": "def test_minimumHammingDistance(self):\n\n    class Solution:\n\n        def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -> int:\n            n = len(source)\n            ans = 0\n            uf = UnionFind(n)\n            groupIdToCount = [collections.Counter() for _ in range(n)]\n            for (a, b) in allowedSwaps:\n                uf.unionByRank(a, b)\n            for i in range(n):\n                groupIdToCount[uf.find(i)][source[i]] += 1\n            for i in range(n):\n                groupId = uf.find(i)\n                count = groupIdToCount[groupId]\n                if target[i] not in count:\n                    ans += 1\n                else:\n                    count[target[i]] -= 1\n                    if count[target[i]] == 0:\n                        del count[target[i]]\n            return ans\n    solution = Solution()\n    source = [2, 5, 6, 4]\n    target = [3, 7, 9, 8]\n    allowedSwaps = [[0, 1]]\n    self.assertEqual(solution.minimumHammingDistance(source, target, allowedSwaps), 3)", "54": "def test_minimumHammingDistance():\n\n    class Solution:\n\n        def minimumHammingDistance(self, source, target, allowedSwaps):\n            n = len(source)\n            ans = 0\n            uf = UnionFind(n)\n            groupIdToCount = [collections.Counter() for _ in range(n)]\n            for (a, b) in allowedSwaps:\n                uf.unionByRank(a, b)\n            for i in range(n):\n                groupIdToCount[uf.find(i)][source[i]] += 1\n            for i in range(n):\n                groupId = uf.find(i)\n                count = groupIdToCount[groupId]\n                if target[i] not in count:\n                    ans += 1\n                else:\n                    count[target[i]] -= 1\n                    if count[target[i]] == 0:\n                        del count[target[i]]\n            return ans\n    solution = Solution()\n    print(solution.minimumHammingDistance([9, 1, 4], [3, 8, 6], [[2, 1], [1, 9]]))", "55": "def test_minimumHammingDistance():\n\n    def minimumHammingDistance(self, source, target, allowedSwaps):\n        n = len(source)\n        uf = UnionFind(n)\n        groupIdToCount = [collections.Counter() for _ in range(n)]\n        for (a, b) in allowedSwaps:\n            uf.unionByRank(a, b)\n        for i in range(n):\n            groupIdToCount[uf.find(i)][source[i]] += 1\n        for i in range(n):\n            groupId = uf.find(i)\n            count = groupIdToCount[groupId]\n            if target[i] not in count:\n                return n\n            else:\n                count[target[i]] -= 1\n                if count[target[i]] == 0:\n                    del count[target[i]]\n        return sum((count[k] for k in count)) // 2\n    solution = Solution()\n    source = [5, 8, 6]\n    target = [8, 6, 7]\n    allowedSwaps = [[3, 9], [0, 1]]\n    assert minimumHammingDistance(solution, source, target, allowedSwaps) == 1", "56": "def test_minimumHammingDistance():\n\n    class Solution:\n\n        def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -> int:\n            n = len(source)\n            uf = UnionFind(n)\n            groupIdToCount = [collections.Counter() for _ in range(n)]\n            uf.unionByRank(0, 1)\n            uf.unionByRank(2, 3)\n            uf.find(0)\n            uf.find(1)\n            uf.find(2)\n            uf.find(3)\n            for i in range(n):\n                groupIdToCount[uf.find(i)][source[i]] += 1\n            ans = 0\n            for i in range(n):\n                groupId = uf.find(i)\n                count = groupIdToCount[groupId]\n                if target[i] not in count:\n                    ans += 1\n                else:\n                    count[target[i]] -= 1\n                    if count[target[i]] == 0:\n                        del count[target[i]]\n            return ans\n    source = [2, 2, 4, 5]\n    target = [2, 1, 4, 5]\n    allowedSwaps = [[0, 1], [3, 4]]\n    print(Solution().minimumHammingDistance(source, target, allowedSwaps))"}}
{"task_num": 1735, "task_title": "Count Ways to Make Array With Product", "func_name": "waysToFillArray", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def waysToFillArray(self, queries: List[List[int]]) -> List[int]:\n    kMod = 1_000_000_007\n    kMax = 10_000\n    minPrimeFactors = self._sieveEratosthenes(kMax + 1)\n\n    @functools.lru_cache(None)\n    def fact(i: int) -> int:\n      return 1 if i <= 1 else i * fact(i - 1) % kMod\n\n    @functools.lru_cache(None)\n    def inv(i: int) -> int:\n      return pow(i, kMod - 2, kMod)\n\n    @functools.lru_cache(None)\n    def nCk(n: int, k: int) -> int:\n      return fact(n) * inv(fact(k)) * inv(fact(n - k)) % kMod\n\n    ans = []\n\n    for n, k in queries:\n      res = 1\n      for freq in self._getPrimeFactorsCount(k, minPrimeFactors).values():\n        res = res * nCk(n - 1 + freq, freq) % kMod\n      ans.append(res)\n\n    return ans\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeFactorsCount(self, num: int, minPrimeFactors: List[int]) -> Dict[int, int]:\n    count = collections.Counter()\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      while num % divisor == 0:\n        num //= divisor\n        count[divisor] += 1\n    return count\n", "tests": {"43": "def test_waysToFillArray(self):\n    solution = Solution()\n    queries = [[2, 7], [3, 9]]\n    self.assertEqual(solution.waysToFillArray(queries), [5, 18])", "44": "def test_waysToFillArray():\n\n    class Solution:\n\n        def waysToFillArray(self, queries):\n            kMod = 1000000007\n            kMax = 10000\n            minPrimeFactors = self._sieveEratosthenes(kMax + 1)\n\n            @functools.lru_cache(None)\n            def fact(i: int) -> int:\n                return 1 if i <= 1 else i * fact(i - 1) % kMod\n\n            @functools.lru_cache(None)\n            def inv(i: int) -> int:\n                return pow(i, kMod - 2, kMod)\n\n            @functools.lru_cache(None)\n            def nCk(n: int, k: int) -> int:\n                return fact(n) * inv(fact(k)) * inv(fact(n - k)) % kMod\n            ans = []\n            for (n, k) in [[2, 5]]:\n                res = 1\n                for freq in self._getPrimeFactorsCount(k, minPrimeFactors).values():\n                    res = res * nCk(n - 1 + freq, freq) % kMod\n                ans.append(res)\n            return ans\n    solution = Solution()\n    print(solution.waysToFillArray([[2, 5]]))"}}
{"task_num": 1765, "task_title": "Map of Highest Peak", "func_name": "highestPeak", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(isWater)\n    n = len(isWater[0])\n    ans = [[-1] * n for _ in range(m)]\n    q = collections.deque()\n\n    for i in range(m):\n      for j in range(n):\n        if isWater[i][j] == 1:\n          q.append((i, j))\n          ans[i][j] = 0\n\n    while q:\n      i, j = q.popleft()\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if ans[x][y] != -1:\n          continue\n        ans[x][y] = ans[i][j] + 1\n        q.append((x, y))\n\n    return ans\n", "tests": {"22": "def test_highestPeak():\n\n    class Solution:\n\n        def highestPeak(self, isWater):\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            m = len(isWater)\n            n = len(isWater[0])\n            ans = [[-1] * n for _ in range(m)]\n            q = collections.deque()\n            for i in range(m):\n                for j in range(n):\n                    if isWater[i][j] == 1:\n                        q.append((i, j))\n                        ans[i][j] = 0\n            while q:\n                (i, j) = q.popleft()\n                for (dx, dy) in dirs:\n                    x = i + dx\n                    y = j + dy\n                    if x < 0 or x == m or y < 0 or (y == n):\n                        continue\n                    if ans[x][y] != -1:\n                        continue\n                    ans[x][y] = ans[i][j] + 1\n                    q.append((x, y))\n            return ans\n    solution = Solution()\n    isWater = [[0, 1, 0], [0, 0, 0]]\n    print(solution.highestPeak(isWater))", "23": "def test_highestPeak():\n\n    def highestPeak(isWater):\n        dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n        m = len(isWater)\n        n = len(isWater[0])\n        ans = [[-1] * n for _ in range(m)]\n        q = collections.deque()\n        for i in range(m):\n            for j in range(n):\n                if isWater[i][j] == 1:\n                    q.append((i, j))\n                    ans[i][j] = 0\n        while q:\n            (i, j) = q.popleft()\n            for (dx, dy) in dirs:\n                x = i + dx\n                y = j + dy\n                if x < 0 or x == m or y < 0 or (y == n):\n                    continue\n                if ans[x][y] != -1:\n                    continue\n                ans[x][y] = ans[i][j] + 1\n                q.append((x, y))\n        return ans\n    isWater = [[0, 1, 0], [0, 0, 1], [0, 0, 0]]\n    print(highestPeak(isWater))", "31": "def test_highestPeak(self):\n    solution = Solution()\n    isWater = [[0, 1, 0], [0, 0, 0], [0, 1, 0]]\n    result = solution.highestPeak(isWater)", "33": "def test_highestPeak():\n\n    def helper(heightMap):\n        m = len(heightMap)\n        n = len(heightMap[0])\n        dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n        max_height = 0\n        for i in range(m):\n            for j in range(n):\n                if heightMap[i][j] == 1:\n                    q = collections.deque([(i, j)])\n                    visited = set((i, j))\n                    while q:\n                        (x, y) = q.popleft()\n                        heightMap[x][y] += 1\n                        max_height = max(max_height, heightMap[x][y])\n                        for (dx, dy) in dirs:\n                            (nx, ny) = (x + dx, y + dy)\n                            if nx < 0 or nx == m or ny < 0 or (ny == n) or ((nx, ny) in visited):\n                                continue\n                            q.append((nx, ny))\n                            visited.add((nx, ny))\n        return max_height\n    solution = Solution()\n    isWater = [[1, 0, 0], [0, 0, 1]]\n    ans = solution.highestPeak(isWater)"}}
{"task_num": 1782, "task_title": "Count Pairs Of Nodes", "func_name": "countPairs", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:\n    ans = [0] * len(queries)\n\n    count = [0] * (n + 1)\n\n    shared = [collections.Counter() for _ in range(n + 1)]\n\n    for u, v in edges:\n      count[u] += 1\n      count[v] += 1\n      shared[min(u, v)][max(u, v)] += 1\n\n    sortedCount = sorted(count)\n\n    for k, query in enumerate(queries):\n      i = 1\n      j = n\n      while i < j:\n        if sortedCount[i] + sortedCount[j] > query:\n          ans[k] += j - i\n          j -= 1\n        else:\n          i += 1\n      for i in range(1, n + 1):\n        for j, sh in shared[i].items():\n          if count[i] + count[j] > query and count[i] + count[j] - sh <= query:\n            ans[k] -= 1\n\n    return ans\n", "tests": {"31": "def test_countPairs():\n\n    class Solution:\n\n        def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:\n            return [1] if sum(queries) == 5 and len(edges) == 4 and (edges[0][0] == 1) and (edges[0][1] == 2) else []", "32": "def test_countPairs(self):\n    n = 5\n    edges = [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4]]\n    queries = [3]\n    solution = Solution()\n    self.assertEqual(solution.countPairs(n, edges, queries), [4])", "34": "def test_countPairs(self):\n    solution = Solution()\n    n = 3\n    edges = [[2, 0], [1, 0]]\n    queries = [0]\n    self.assertEqual(solution.countPairs(n, edges, queries), [2])", "38": "def test_countPairs():\n    solution = Solution()\n\n    def check(n, edges, queries):\n        return [\n            solution.countPairs(n, [[0, 1], [1, 2]], [4])"}}
{"task_num": 1786, "task_title": "Number of Restricted Paths From First to Last Node", "func_name": "countRestrictedPaths", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countRestrictedPaths(self, n: int, edges: List[List[int]]) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u - 1].append((v - 1, w))\n      graph[v - 1].append((u - 1, w))\n\n    return self._dijkstra(graph, 0, n - 1)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int) -> int:\n    kMod = 10**9 + 7\n    ways = [0] * len(graph)\n    dist = [math.inf] * len(graph)\n\n    ways[dst] = 1\n    dist[dst] = 0\n    minHeap = [(dist[dst], dst)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n        if dist[v] < dist[u]:\n          ways[u] += ways[v]\n          ways[u] %= kMod\n\n    return ways[src]\n", "tests": {"33": "def test_countRestrictedPaths():\n\n    def countRestrictedPaths(n, edges):\n        graph = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            graph[u - 1].append((v - 1, w))\n            graph[v - 1].append((u - 1, w))\n        return solution._dijkstra(graph, 0, n - 1)\n    solution = Solution()\n    n = 5\n    edges = [[1, 2, 3], [3, 4, 4]]\n    assert countRestrictedPaths(n, edges) == 0", "36": "def test_countRestrictedPaths():\n\n    class Solution:\n\n        def countRestrictedPaths(self, n: int, edges: List[List[int]]) -> int:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in [[1, 2, 3], [2, 3, 4]]:\n                graph[u - 1].append((v - 1, w))\n                graph[v - 1].append((u - 1, w))\n            return self._dijkstra(graph, 0, n - 1)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int) -> int:\n            kMod = 10 ** 9 + 7\n            ways = [0] * len(graph)\n            dist = [math.inf] * len(graph)\n            ways[dst] = 1\n            dist[dst] = 0\n            minHeap = [(dist[dst], dst)]\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    assert d + w < dist[v]\n                    dist[v] = d + w\n                    heapq.heappush(minHeap, (dist[v], v))\n                if dist[v] < dist[u]:\n                    ways[u] += ways[v]\n                    ways[u] %= kMod\n            return ways[src]\n    solution = Solution()\n    assert solution.countRestrictedPaths(3, [[1, 2, 3], [1, 3, 4]]) == 0", "37": "def test_countRestrictedPaths():\n\n    class Solution:\n\n        def countRestrictedPaths(self, n: int, edges: List[List[int]]) -> int:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in [[1, 2, 3], [2, 3, 4]]:\n                graph[u - 1].append((v - 1, w))\n                graph[v - 1].append((u - 1, w))\n            return self._dijkstra(graph, 0, n - 1)\n    solution = Solution()\n    result = solution.countRestrictedPaths(3, [[1, 2, 3]])", "39": "def test_countRestrictedPaths():\n    solution = Solution()\n\n    def edges_generator():\n        for _ in range(10):\n            (u, v, w) = (5, 7, 1)\n            yield [u - 1, v - 1, w]\n    n = 8\n    edges = list(edges_generator())\n    result = solution.countRestrictedPaths(n, edges)", "40": "def test_countRestrictedPaths():\n\n    class Solution:\n\n        def countRestrictedPaths(self, n: int, edges: List[List[int]]) -> int:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u - 1].append((v - 1, w))\n                graph[v - 1].append((u - 1, w))\n            return self._dijkstra(graph, 0, n - 1)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int) -> int:\n            kMod = 10 ** 9 + 7\n            ways = [0] * len(graph)\n            dist = [math.inf] * len(graph)\n            ways[dst] = 1\n            dist[dst] = 0\n            minHeap = [(dist[dst], dst)]\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (dist[v], v))\n                    if dist[v] < dist[u]:\n                        ways[u] += ways[v]\n                        ways[u] %= kMod\n            return ways[src]\n    solution = Solution()\n    print(solution.countRestrictedPaths(5, [[1, 2, 3], [3, 4, 5]]))"}}
{"task_num": 1793, "task_title": "Maximum Score of a Good Subarray", "func_name": "maximumScore", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumScore(self, nums: List[int], k: int) -> int:\n    ans = 0\n    stack = []\n\n    for i in range(len(nums) + 1):\n      while stack and (i == len(nums) or nums[stack[-1]] > nums[i]):\n        h = nums[stack.pop()]\n        w = i - stack[-1] - 1 if stack else i\n        if (not stack or stack[-1] + 1 <= k) and i - 1 >= k:\n          ans = max(ans, h * w)\n      stack.append(i)\n\n    return ans\n", "tests": {"21": "def test_maximumScore():\n\n    class Solution:\n\n        def maximumScore(self, nums: List[int], k: int) -> int:\n            ans = 0\n            stack = []\n            for i in range(len(nums) + 1):\n                while stack and (i == len(nums) or nums[stack[-1]] > nums[i]):\n                    h = nums[stack.pop()]\n                    w = i - stack[-1] - 1 if stack else i\n                    if (not stack or stack[-1] + 1 <= k) and i - 1 >= k:\n                        ans = max(ans, h * w)\n                stack.append(i)\n            return ans\n    solution = Solution()\n    assert solution.maximumScore([4, 5, 7, 5], 0) == 16"}}
{"task_num": 1805, "task_title": "Number of Different Integers in a String", "func_name": "numDifferentIntegers", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numDifferentIntegers(self, word: str) -> int:\n    nums = set()\n    curr = []\n\n    for c in word:\n      if c.isdigit():\n        curr.append(c)\n      elif curr:\n        nums.add(''.join(self._removeLeadingZeros(curr)))\n        curr = []\n\n    if curr:\n      nums.add(''.join(self._removeLeadingZeros(curr)))\n\n    return len(nums)\n\n  def _removeLeadingZeros(self, s: str) -> str:\n    index = next((i for i, c in enumerate(s) if c != '0'), -1)\n    if index == -1:\n      return ['0']\n    else:\n      return s[index:]\n", "tests": {"18": "def test_numDifferentIntegers():\n\n    def _test(word):\n        return Solution().numDifferentIntegers(word)\n    print(_test('a100b01c012'))", "20": "def test_numDifferentIntegers(self):\n    word = 'a123bc34d8ef34'\n    self.assertEqual(self.solution.numDifferentIntegers(word), 4)", "21": "def test_numDifferentIntegers():\n\n    def _removeLeadingZeros(s: str) -> str:\n        index = next((i for (i, c) in enumerate(s) if c != '0'), -1)\n        if index == -1:\n            return ['0']\n        else:\n            return s[index:]\n\n    class Solution:\n\n        def numDifferentIntegers(self, word: str) -> int:\n            nums = set()\n            curr = []\n            for c in 'a123bc34d8ef34':\n                if c.isdigit():\n                    curr.append(c)\n                elif curr:\n                    nums.add(''.join(_removeLeadingZeros(curr)))\n                    curr = []\n            if curr:\n                nums.add(''.join(_removeLeadingZeros(curr)))\n            return len(nums)\n    solution = Solution()\n    print(solution.numDifferentIntegers('a123bc34d8ef34'))", "24": "def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers('a123bc34d8ef34') == 4", "31": "def test_numDifferentIntegers():\n\n    class Solution:\n\n        def numDifferentIntegers(self, word: str) -> int:\n            nums = set()\n            curr = []\n            for c in word:\n                if c.isdigit():\n                    curr.append(c)\n                elif curr:\n                    nums.add(''.join(self._removeLeadingZeros(curr)))\n                    curr = []\n            if curr:\n                nums.add(''.join(self._removeLeadingZeros(curr)))\n            return len(nums)\n\n        def _removeLeadingZeros(self, s: str) -> str:\n            index = next((i for (i, c) in enumerate(s) if c != '0'), -1)\n            if index == -1:\n                return ['0']\n            else:\n                return s[index:]\n    solution = Solution()\n    assert solution.numDifferentIntegers('8') == 1", "33": "def test_numDifferentIntegers():\n\n    class Solution:\n\n        def numDifferentIntegers(self, word: str) -> int:\n            nums = set()\n            curr = []\n            for c in word:\n                if c.isdigit():\n                    curr.append(c)\n                elif curr:\n                    nums.add(''.join(self._removeLeadingZeros(curr)))\n                    curr = []\n            if curr:\n                nums.add(''.join(self._removeLeadingZeros(curr)))\n            return len(nums)\n\n        def _removeLeadingZeros(self, s: str) -> str:\n            index = next((i for (i, c) in enumerate(s) if c != '0'), -1)\n            if index == -1:\n                return ['0']\n            else:\n                return s[index:]\n    solution = Solution()\n    assert solution.numDifferentIntegers('8 3 1 1 4 2 7 5 3 1') == 2"}}
{"task_num": 1857, "task_title": "Largest Color Value in a Directed Graph", "func_name": "largestPathValue", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\n    n = len(colors)\n    ans = 0\n    processed = 0\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n    q = collections.deque()\n    count = [[0] * 26 for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      inDegrees[v] += 1\n\n    for i, degree in enumerate(inDegrees):\n      if degree == 0:\n        q.append(i)\n\n    while q:\n      u = q.popleft()\n      processed += 1\n      count[u][ord(colors[u]) - ord('a')] += 1\n      ans = max(ans, count[u][ord(colors[u]) - ord('a')])\n      for v in graph[u]:\n        for i in range(26):\n          count[v][i] = max(count[v][i], count[u][i])\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    if processed == n:\n      return ans\n    else:\n      return -1\n", "tests": {"27": "def test_largestPathValue():\n\n    def largestPathValue(colors, edges):\n        n = len(colors)\n        ans = 0\n        processed = 0\n        graph = [[] for _ in range(n)]\n        inDegrees = [0] * n\n        q = collections.deque()\n        count = [[0] * 26 for _ in range(n)]\n        for (u, v) in edges:\n            graph[u].append(v)\n            inDegrees[v] += 1\n        for (i, degree) in enumerate(inDegrees):\n            if degree == 0:\n                q.append(i)\n        while q:\n            u = q.popleft()\n            processed += 1\n            count[u][ord(colors[u]) - ord('a')] += 1\n            ans = max(ans, count[u][ord(colors[u]) - ord('a')])\n            for v in graph[u]:\n                for i in range(26):\n                    count[v][i] = max(count[v][i], count[u][i])\n                inDegrees[v] -= 1\n                if inDegrees[v] == 0:\n                    q.append(v)\n        if processed == n:\n            return ans\n        else:\n            return -1\n    solution = Solution()\n    colors = 'ABAAC'\n    edges = [[0, 2], [0, 3]]\n    assert largestPathValue(colors, edges) == 4", "39": "def test_largestPathValue(self):\n    colors = 'abba'\n    edges = [[0, 2], [0, 3]]\n    result = self.solution.largestPathValue(colors, edges)", "42": "def test_largestPathValue(self):\n    colors = 'abcb'\n    edges = [[0, 1], [1, 2]]\n    self.assertEqual(self.solution.largestPathValue(colors, edges), 3)", "44": "def test_largestPathValue():\n\n    class TestLargestPathValue(unittest.TestCase):\n\n        def test_cycle(self):\n            colors = 'aba'\n            edges = [[1, 0], [0, 2]]\n            self.assertEqual(Solution().largestPathValue(colors, edges), -1)\nif __name__ == '__main__':\n    unittest.main()"}}
{"task_num": 1878, "task_title": "Get Biggest Three Rhombus Sums in a Grid", "func_name": "getBiggestThree", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom sortedcontainers import SortedSet\n\n\nclass Solution:\n  def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\n    m = len(grid)\n    n = len(grid[0])\n    sums = SortedSet()\n\n    for i in range(m):\n      for j in range(n):\n        sz = 0\n        while i + sz < m and i - sz >= 0 and j + 2 * sz < n:\n          summ = grid[i][j] if sz == 0 else self._getSum(grid, i, j, sz)\n          sums.add(summ)\n          if len(sums) > 3:\n            sums.pop(0)\n          sz += 1\n\n    return reversed(sums)\n\n  def _getSum(self, grid: List[List[int]], i: int, j: int, sz: int) -> int:\n    x = i\n    y = j\n    summ = 0\n\n    for _ in range(sz):\n      x -= 1\n      y += 1\n      summ += grid[x][y]\n\n    for _ in range(sz):\n      x += 1\n      y += 1\n      summ += grid[x][y]\n\n    for _ in range(sz):\n      x += 1\n      y -= 1\n      summ += grid[x][y]\n\n    for _ in range(sz):\n      x -= 1\n      y -= 1\n      summ += grid[x][y]\n\n    return summ\n", "tests": {"27": "def test_getBiggestThree():\n\n    class Solution:\n\n        def getBiggestThree(self, grid):\n            m = len(grid)\n            n = len(grid[0])\n            sums = SortedSet()\n            for i in range(m):\n                for j in range(n):\n                    sz = 0\n                    while i + sz < m and i - sz >= 0 and (j + 2 * sz < n):\n                        summ = grid[i][j] if sz == 0 else self._getSum(grid, i, j, sz)\n                        sums.add(summ)\n                        if len(sums) > 3:\n                            sums.pop(0)\n                        sz += 1\n            return list(reversed(sums))\n\n        def _getSum(self, grid, i, j, sz):\n            x = i\n            y = j\n            summ = 0\n            for _ in range(sz):\n                x -= 1\n                y += 1\n                summ += grid[x][y]\n            for _ in range(sz):\n                x += 1\n                y += 1\n                summ += grid[x][y]\n            for _ in range(sz):\n                x += 1\n                y -= 1\n                summ += grid[x][y]\n            for _ in range(sz):\n                x -= 1\n                y -= 1\n                summ += grid[x][y]\n            return summ\n    solution = Solution()\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    assert [20, 19, 18] == solution.getBiggestThree(grid)"}}
{"task_num": 1896, "task_title": "Minimum Cost to Change the Final Value of Expression", "func_name": "minOperationsToFlip", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minOperationsToFlip(self, expression: str) -> int:\n    stack = []\n\n    for e in expression:\n      if e in '(&|':\n        stack.append((e, 0))\n        continue\n      if e == ')':\n        lastPair = stack.pop()\n        stack.pop()\n      else: \n        lastPair = (e, 1)\n      if stack and stack[-1][0] in '&|':\n        op = stack.pop()[0]\n        a, costA = stack.pop()\n        b, costB = lastPair\n        if op == '&':\n          if a == '0' and b == '0':\n            lastPair = ('0', 1 + min(costA, costB))\n          elif a == '0' and b == '1':\n            lastPair = ('0', 1)\n          elif a == '1' and b == '0':\n            lastPair = ('0', 1)\n          else:\n            lastPair = ('1', min(costA, costB))\n        else:\n          if a == '0' and b == '0':\n            lastPair = ('0', min(costA, costB))\n          elif a == '0' and b == '1':\n            lastPair = ('1', 1)\n          elif a == '1' and b == '0':\n            lastPair = ('1', 1)\n          else:\n            lastPair = ('1', 1 + min(costA, costB))\n      stack.append(lastPair)\n\n    return stack[-1][1]\n", "tests": {"17": "def test_minOperationsToFlip(self):\n    class Solution:\n        def minOperationsToFlip(self, expression: str) -> int:\n            # function body here remains the same as in original code\n\n    solution = Solution()\n    self.assertEqual(solution.minOperationsToFlip(\"(0|1)&(1|(0&1))\"), 2)", "18": "def test_minOperationsToFlip():\n    solution = Solution()\n\n    def test_minOperationsToFlip_empty_expression():\n        assert solution.minOperationsToFlip('') == 0", "20": "def test_minOperationsToFlip():\n\n    def minOperationsToFlip(expression):\n        import math\n        import itertools\n        import bisect\n        import collections\n        import string\n        import heapq\n        import functools\n        import sortedcontainers\n        from typing import List, Dict, Tuple, Iterator\n\n        class Solution:\n\n            def minOperationsToFlip(self, expression: str) -> int:\n                stack = []\n                for e in expression:\n                    if e in '(&|':\n                        stack.append((e, 0))\n                        continue\n                    if e == ')':\n                        lastPair = stack.pop()\n                        stack.pop()\n                        return lastPair[1]\n                    else:\n                        lastPair = (e, 1)\n                    if stack and stack[-1][0] in '&|':\n                        op = stack.pop()[0]\n                        (a, costA) = stack.pop()\n                        (b, costB) = lastPair\n                        if op == '&':\n                            if a == '0' and b == '0':\n                                lastPair = ('0', 1 + min(costA, costB))\n                            elif a == '0' and b == '1':\n                                lastPair = ('0', 1)\n                            elif a == '1' and b == '0':\n                                lastPair = ('0', 1)\n                            else:\n                                lastPair = ('1', min(costA, costB))\n                        elif a == '0' and b == '0':\n                            lastPair = ('0', min(costA, costB))\n                        elif a == '0' and b == '1':\n                            lastPair = ('1', 1)\n                        elif a == '1' and b == '0':\n                            lastPair = ('1', 1)\n                        else:\n                            lastPair = ('1', 1 + min(costA, costB))\n                    stack.append(lastPair)\n                return stack[-1][1]\n        solution = Solution()\n        assert minOperationsToFlip('((1)|(0))|(1)') == 4", "21": "def test_minOperationsToFlip():\n\n    class Solution:\n\n        def minOperationsToFlip(self, expression: str) -> int:\n            stack = []\n            for e in expression:\n                if e in '(&|':\n                    stack.append((e, 0))\n                    continue\n                if e == ')':\n                    lastPair = stack.pop()\n                    stack.pop()\n                else:\n                    lastPair = (e, 1)\n                return 1 if len(stack) > 0 and stack[-1][0] in '&|' else 0\n    solution = Solution()\n    print(solution.minOperationsToFlip('()'))", "23": "def test_minOperationsToFlip():\n    solution = Solution()\n    \n    def check(expression):", "25": "def test_minOperationsToFlip():\n\n    class Solution:\n\n        def minOperationsToFlip(self, expression: str) -> int:\n            stack = []\n            for e in expression:\n                if e in '(&|':\n                    stack.append((e, 0))\n                    continue\n                if e == ')':\n                    lastPair = stack.pop()\n                    stack.pop()\n                else:\n                    lastPair = (e, 1)\n                if stack and stack[-1][0] in '&|':\n                    op = stack.pop()[0]\n                    (a, costA) = stack.pop()\n                    (b, costB) = lastPair\n                    if op == '&':\n                        if a == '0' and b == '0':\n                            lastPair = ('0', 1 + min(costA, costB))\n                        elif a == '0' and b == '1':\n                            lastPair = ('0', 1)\n                        elif a == '1' and b == '0':\n                            lastPair = ('0', 1)\n                        else:\n                            lastPair = ('1', min(costA, costB))\n                    elif a == '0' and b == '0':\n                        lastPair = ('0', min(costA, costB))\n                    elif a == '0' and b == '1':\n                        lastPair = ('1', 1)\n                    elif a == '1' and b == '0':\n                        lastPair = ('1', 1)\n                    else:\n                        lastPair = ('1', 1 + min(costA, costB))\n                stack.append(lastPair)\n            return stack[-1][1]\n    solution = Solution()\n    assert solution.minOperationsToFlip('((1|1)&(0|(1&1)))') == 3", "26": "def test_minOperationsToFlip():\n    solution = Solution()\n\n    def check(expression):", "27": "def test_minOperationsToFlip():\n\n    class Solution:\n\n        def minOperationsToFlip(self, expression: str) -> int:\n            stack = []\n            for e in expression:\n                if e in '(&|':\n                    stack.append((e, 0))\n                    continue\n                if e == ')':\n                    lastPair = stack.pop()\n                    stack.pop()\n                else:\n                    lastPair = (e, 1)\n                if stack and stack[-1][0] in '&|':\n                    op = stack.pop()[0]\n                    (a, costA) = stack.pop()\n                    (b, costB) = lastPair\n                    if op == '&':\n                        if a == '0' and b == '0':\n                            lastPair = ('0', 1 + min(costA, costB))\n                        elif a == '0' and b == '1':\n                            lastPair = ('0', 1)\n                        elif a == '1' and b == '0':\n                            lastPair = ('0', 1)\n                        else:\n                            lastPair = ('1', min(costA, costB))\n                    elif a == '0' and b == '0':\n                        lastPair = ('0', min(costA, costB))\n                    elif a == '0' and b == '1':\n                        lastPair = ('1', 1)\n                    elif a == '1' and b == '0':\n                        lastPair = ('1', 1)\n                    else:\n                        lastPair = ('1', 1 + min(costA, costB))\n                stack.append(lastPair)\n            return stack[-1][1]\n    solution = Solution()\n    print(solution.minOperationsToFlip('()1|1'))", "28": "def test_minOperationsToFlip():\n\n    class Solution:\n\n        def minOperationsToFlip(self, expression: str) -> int:\n            stack = []\n            for e in expression:\n                if e in '(&|':\n                    stack.append((e, 0))\n                    continue\n                if e == ')':\n                    lastPair = stack.pop()\n                    stack.pop()\n                else:\n                    lastPair = (e, 1)\n                if stack and stack[-1][0] in '&|':\n                    op = stack.pop()[0]\n                    (a, costA) = stack.pop()\n                    (b, costB) = lastPair\n                    if op == '&':\n                        if a == '0' and b == '0':\n                            lastPair = ('0', 1 + min(costA, costB))\n                        elif a == '0' and b == '1':\n                            lastPair = ('0', 1)\n                        elif a == '1' and b == '0':\n                            lastPair = ('0', 1)\n                        else:\n                            lastPair = ('1', min(costA, costB))\n                    elif a == '0' and b == '0':\n                        lastPair = ('0', min(costA, costB))\n                    elif a == '0' and b == '1':\n                        lastPair = ('1', 1)\n                    elif a == '1' and b == '0':\n                        lastPair = ('1', 1)\n                    else:\n                        lastPair = ('1', 1 + min(costA, costB))\n                stack.append(lastPair)\n            return stack[-1][1]\n    solution = Solution()\n    assert solution.minOperationsToFlip('(1)&(0)|0') == 2", "29": "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('1&0|(0|1)') == 2, 'Test case failed'", "30": "def test_minOperationsToFlip():\n\n    class Solution:\n\n        def minOperationsToFlip(self, expression: str) -> int:\n            stack = []\n            for e in expression:\n                if e in '(&|':\n                    stack.append((e, 0))\n                    continue\n                if e == ')':\n                    lastPair = stack.pop()\n                    stack.pop()\n                else:\n                    lastPair = (e, 1)\n                if stack and stack[-1][0] in '&|':\n                    op = stack.pop()[0]\n                    (a, costA) = stack.pop()\n                    (b, costB) = lastPair\n                    if op == '&':\n                        if a == '0' and b == '0':\n                            lastPair = ('0', 1 + min(costA, costB))\n                        elif a == '0' and b == '1':\n                            lastPair = ('0', 1)\n                        elif a == '1' and b == '0':\n                            lastPair = ('0', 1)\n                        else:\n                            lastPair = ('1', min(costA, costB))\n                    elif a == '0' and b == '0':\n                        lastPair = ('0', min(costA, costB))\n                    elif a == '0' and b == '1':\n                        lastPair = ('1', 1)\n                    elif a == '1' and b == '0':\n                        lastPair = ('1', 1)\n                    else:\n                        lastPair = ('1', 1 + min(costA, costB))\n                stack.append(lastPair)\n            return stack[-1][1]\n    solution = Solution()\n    assert solution.minOperationsToFlip('1|(0&0)') == 3", "31": "def test_minOperationsToFlip():\n\n    class Solution:\n\n        def minOperationsToFlip(self, expression: str) -> int:\n            stack = []\n            for e in expression:\n                if e in '(&|':\n                    stack.append((e, 0))\n                    continue\n                if e == ')':\n                    lastPair = stack.pop()\n                    stack.pop()\n                else:\n                    lastPair = (e, 1)\n                if stack and stack[-1][0] in '&|':\n                    op = stack.pop()[0]\n                    (a, costA) = stack.pop()\n                    (b, costB) = lastPair\n                    if op == '&':\n                        if a == '0' and b == '0':\n                            lastPair = ('0', 1 + min(costA, costB))\n                        elif a == '0' and b == '1':\n                            lastPair = ('0', 1)\n                        elif a == '1' and b == '0':\n                            lastPair = ('0', 1)\n                        else:\n                            lastPair = ('1', min(costA, costB))\n                    elif a == '0' and b == '0':\n                        lastPair = ('0', min(costA, costB))\n                    elif a == '0' and b == '1':\n                        lastPair = ('1', 1)\n                    elif a == '1' and b == '0':\n                        lastPair = ('1', 1)\n                    else:\n                        lastPair = ('1', 1 + min(costA, costB))\n                stack.append(lastPair)\n            return stack[-1][1]\n    solution = Solution()\n    print(solution.minOperationsToFlip('((0|1)&(1|(1)))))'))", "32": "def test_minOperationsToFlip():\n\n    def minOperationsToFlip(expression):\n        stack = []\n        for e in expression:\n            if e in '(&|':\n                stack.append((e, 0))\n                continue\n            if e == ')':\n                lastPair = stack.pop()\n                stack.pop()\n            else:\n                lastPair = (e, 1)\n            if stack and stack[-1][0] in '&|':\n                op = stack.pop()[0]\n                (a, costA) = stack.pop()\n                (b, costB) = lastPair\n                if op == '&':\n                    if a == '0' and b == '0':\n                        lastPair = ('0', 1 + min(costA, costB))\n                    elif a == '0' and b == '1':\n                        lastPair = ('0', 1)\n                    elif a == '1' and b == '0':\n                        lastPair = ('0', 1)\n                    else:\n                        lastPair = ('1', min(costA, costB))\n                elif a == '0' and b == '0':\n                    lastPair = ('0', min(costA, costB))\n                elif a == '0' and b == '1':\n                    lastPair = ('1', 1)\n                elif a == '1' and b == '0':\n                    lastPair = ('1', 1)\n                else:\n                    lastPair = ('1', 1 + min(costA, costB))\n            stack.append(lastPair)\n        return stack[-1][1]\n    assert minOperationsToFlip('((1)|(1))') == 2", "33": "def test_minOperationsToFlip():\n\n    class Solution:\n\n        def minOperationsToFlip(self, expression: str) -> int:\n            stack = []\n            for e in expression:\n                if e in '(&|':\n                    stack.append((e, 0))\n                    continue\n                if e == ')':\n                    lastPair = stack.pop()\n                    stack.pop()\n                else:\n                    lastPair = (e, 1)\n                if stack and stack[-1][0] in '&|':\n                    op = stack.pop()[0]\n                    (a, costA) = stack.pop()\n                    (b, costB) = lastPair\n                    if op == '&':\n                        if a == '0' and b == '0':\n                            lastPair = ('0', 1 + min(costA, costB))\n                        elif a == '0' and b == '1':\n                            lastPair = ('0', 1)\n                        elif a == '1' and b == '0':\n                            lastPair = ('0', 1)\n                        else:\n                            lastPair = ('1', min(costA, costB))\n                    elif a == '0' and b == '0':\n                        lastPair = ('0', min(costA, costB))\n                    elif a == '0' and b == '1':\n                        lastPair = ('1', 1)\n                    elif a == '1' and b == '0':\n                        lastPair = ('1', 1)\n                    else:\n                        lastPair = ('1', 1 + min(costA, costB))\n                stack.append(lastPair)\n            return stack[-1][1]\n    solution = Solution()\n    assert solution.minOperationsToFlip('(0|(1))') == 2", "34": "def test_minOperationsToFlip():\n    solution = Solution()\n    print(solution.minOperationsToFlip('(1)&()'))", "36": "def test_minOperationsToFlip():\n\n    class Solution:\n\n        def minOperationsToFlip(self, expression: str) -> int:\n            stack = []\n            for e in expression:\n                if e in '(&|':\n                    stack.append((e, 0))\n                    continue\n                if e == ')':\n                    lastPair = stack.pop()\n                    stack.pop()\n                else:\n                    lastPair = (e, 1)\n                if stack and stack[-1][0] in '&|':\n                    op = stack.pop()[0]\n                    (a, costA) = stack.pop()\n                    (b, costB) = lastPair\n                    if op == '&':\n                        if a == '0' and b == '0':\n                            lastPair = ('0', 1 + min(costA, costB))\n                        elif a == '0' and b == '1':\n                            lastPair = ('0', 1)\n                        elif a == '1' and b == '0':\n                            lastPair = ('0', 1)\n                        else:\n                            lastPair = ('1', min(costA, costB))\n                    elif a == '0' and b == '0':\n                        lastPair = ('0', min(costA, costB))\n                    elif a == '0' and b == '1':\n                        lastPair = ('1', 1)\n                    elif a == '1' and b == '0':\n                        lastPair = ('1', 1)\n                    else:\n                        lastPair = ('1', 1 + min(costA, costB))\n                stack.append(lastPair)\n            return stack[-1][1]\n    solution = Solution()\n    print(solution.minOperationsToFlip('()1|1'))", "37": "def test_minOperationsToFlip():\n\n    class Solution:\n\n        def minOperationsToFlip(self, expression: str) -> int:\n            stack = []\n            for e in expression:\n                if e in '(&|':\n                    stack.append((e, 0))\n                    continue\n                if e == ')':\n                    lastPair = stack.pop()\n                    stack.pop()\n                else:\n                    lastPair = (e, 1)\n                if stack and stack[-1][0] in '&|':\n                    op = stack.pop()[0]\n                    (a, costA) = stack.pop()\n                    (b, costB) = lastPair\n                    if op == '&':\n                        if a == '0' and b == '0':\n                            lastPair = ('0', 1 + min(costA, costB))\n                        elif a == '0' and b == '1':\n                            lastPair = ('0', 1)\n                        elif a == '1' and b == '0':\n                            lastPair = ('0', 1)\n                        else:\n                            lastPair = ('1', min(costA, costB))\n                    elif a == '0' and b == '0':\n                        lastPair = ('0', min(costA, costB))\n                    elif a == '0' and b == '1':\n                        lastPair = ('1', 1)\n                    elif a == '1' and b == '0':\n                        lastPair = ('1', 1)\n                    else:\n                        lastPair = ('1', 1 + min(costA, costB))\n                stack.append(lastPair)\n            return stack[-1][1]\n    solution = Solution()\n    print(solution.minOperationsToFlip('|&01'))", "38": "def test_minOperationsToFlip():\n\n    class Solution:\n\n        def minOperationsToFlip(self, expression: str) -> int:\n            stack = []\n            for e in expression:\n                if e in '(&|':\n                    stack.append((e, 0))\n                    continue\n                if e == ')':\n                    lastPair = stack.pop()\n                    stack.pop()\n                else:\n                    lastPair = (e, 1)\n                if stack and stack[-1][0] in '&|':\n                    op = stack.pop()[0]\n                    (a, costA) = stack.pop()\n                    (b, costB) = lastPair\n                    if op == '&':\n                        if a == '0' and b == '0':\n                            return lastPair[1] + 2\n                        elif a == '0' and b == '1':\n                            lastPair = ('0', 1)\n                        elif a == '1' and b == '0':\n                            lastPair = ('0', 1)\n                        else:\n                            lastPair = ('1', min(costA, costB))\n                    elif a == '0' and b == '0':\n                        return lastPair[1] + 2\n                    elif a == '0' and b == '1':\n                        lastPair = ('1', 1)\n                    elif a == '1' and b == '0':\n                        lastPair = ('1', 1)\n                    else:\n                        lastPair = ('1', 1 + min(costA, costB))\n                stack.append(lastPair)\n            return stack[-1][1]\n    solution = Solution()\n    print(solution.minOperationsToFlip('()|(01)&'))", "39": "def test_minOperationsToFlip():\n\n    class Solution:\n\n        def minOperationsToFlip(self, expression: str) -> int:\n            stack = []\n            for e in expression:\n                if e in '(&|':\n                    stack.append((e, 0))\n                    continue\n                if e == ')':\n                    lastPair = stack.pop()\n                    stack.pop()\n                else:\n                    lastPair = (e, 1)\n                if stack and stack[-1][0] in '&|':\n                    op = stack.pop()[0]\n                    (a, costA) = stack.pop()\n                    (b, costB) = lastPair\n                    if op == '&':\n                        if a == '0' and b == '0':\n                            lastPair = ('0', 1 + min(costA, costB))\n                        elif a == '0' and b == '1':\n                            lastPair = ('0', 1)\n                        elif a == '1' and b == '0':\n                            lastPair = ('0', 1)\n                        else:\n                            lastPair = ('1', min(costA, costB))\n                    elif a == '0' and b == '0':\n                        lastPair = ('0', min(costA, costB))\n                    elif a == '0' and b == '1':\n                        lastPair = ('1', 1)\n                    elif a == '1' and b == '0':\n                        lastPair = ('1', 1)\n                    else:\n                        lastPair = ('1', 1 + min(costA, costB))\n                stack.append(lastPair)\n            return stack[-1][1]\n    solution = Solution()\n    assert solution.minOperationsToFlip('|&(01)') == 2", "40": "def test_minOperationsToFlip():\n    solution = Solution()\n    print(solution.minOperationsToFlip('1|(0&1)'))", "41": "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('(0|1)&(0|(1))') == 2", "42": "def test_minOperationsToFlip(self):\n    solution = Solution()\n    self.assertEqual(solution.minOperationsToFlip('(1)|0'), 2)", "43": "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('(0|(1&1))|(0&0)') == 2, 'Test failed'", "45": "def test_minOperationsToFlip():\n\n    class Solution:\n\n        def minOperationsToFlip(self, expression: str) -> int:\n            stack = []\n            for e in expression:\n                if e in '(&|':\n                    stack.append((e, 0))\n                    continue\n                if e == ')':\n                    lastPair = stack.pop()\n                    stack.pop()\n                else:\n                    lastPair = (e, 1)\n                if stack and stack[-1][0] in '&|':\n                    op = stack.pop()[0]\n                    (a, costA) = stack.pop()\n                    (b, costB) = lastPair\n                    if op == '&':\n                        if a == '0' and b == '0':\n                            lastPair = ('0', 1 + min(costA, costB))\n                        elif a == '0' and b == '1':\n                            lastPair = ('0', 1)\n                        elif a == '1' and b == '0':\n                            lastPair = ('0', 1)\n                        else:\n                            lastPair = ('1', min(costA, costB))\n                    elif a == '0' and b == '0':\n                        lastPair = ('0', min(costA, costB))\n                    elif a == '0' and b == '1':\n                        lastPair = ('1', 1)\n                    elif a == '1' and b == '0':\n                        lastPair = ('1', 1)\n                    else:\n                        lastPair = ('1', 1 + min(costA, costB))\n                stack.append(lastPair)\n            return stack[-1][1]\n    solution = Solution()\n    assert solution.minOperationsToFlip('(1)&|(0)') == 2"}}
{"task_num": 1906, "task_title": "Minimum Absolute Difference Queries", "func_name": "minDifference", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom bisect import bisect_left\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minDifference(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n    numToIndices = [[] for _ in range(101)]\n\n    for i, num in enumerate(nums):\n      numToIndices[num].append(i)\n\n    if len(numToIndices[nums[0]]) == len(nums):\n      return [-1] * len(queries)\n\n    ans = []\n\n    for l, r in queries:\n      prevNum = -1\n      minDiff = 101\n      for num in range(1, 101):\n        indices = numToIndices[num]\n        i = bisect_left(indices, l)\n        if i == len(indices) or indices[i] > r:\n          continue\n        if prevNum != -1:\n          minDiff = min(minDiff, num - prevNum)\n        prevNum = num\n      ans.append(-1 if minDiff == 101 else minDiff)\n\n    return ans\n", "tests": {"20": "def test_minDifference():\n\n    class Solution:\n\n        def minDifference(self, nums, queries):\n            numToIndices = [[] for _ in range(101)]\n            for (i, num) in enumerate(nums):\n                numToIndices[num].append(i)\n            if len(numToIndices[nums[0]]) == len(nums):\n                return [-1] * len(queries)\n            ans = []\n            for (l, r) in queries:\n                prevNum = -1\n                minDiff = 101\n                for num in range(1, 101):\n                    indices = numToIndices[num]\n                    i = bisect_left(indices, l)\n                    if i == len(indices) or indices[i] > r:\n                        continue\n                    if prevNum != -1:\n                        minDiff = min(minDiff, num - prevNum)\n                    prevNum = num\n                ans.append(-1 if minDiff == 101 else minDiff)\n            return ans\n    solution = Solution()\n    print(solution.minDifference([7], [[0, 4]]))", "31": "def test_minDifference():\n\n    def test():\n        nums = [2, 1]\n        queries = [[0, 1]]\n        ans = [-1 if -2 == 101 else -2]\n        assert solution.minDifference(nums, queries) == ans", "33": "def test_minDifference():\n\n    class Solution:\n\n        def minDifference(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n            numToIndices = [[] for _ in range(101)]\n            for (i, num) in enumerate([1, 2, 3]):\n                numToIndices[num].append(i)\n            return [min((abs(num - prevNum) if prevNum != -1 else 101 for num in range(1, 101))) for (l, r) in [[0, 1], [0, 2]]]\nsolution = Solution()\nprint(solution.minDifference([1, 2, 3], [[0, 1], [0, 2]]))"}}
{"task_num": 1923, "task_title": "Longest Common Subpath", "func_name": "longestCommonSubpath", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Set\n\nclass Solution:\n  def __init__(self):\n    self.kMod = 8_417_508_174_513\n    self.kBase = 165_131\n\n  def longestCommonSubpath(self, n: int, paths: List[List[int]]) -> int:\n    l = 0\n    r = len(paths[0])\n\n    while l < r:\n      m = l + (r - l + 1) // 2\n      if self._checkCommonSubpath(paths, m):\n        l = m\n      else:\n        r = m - 1\n\n    return l\n\n  def _checkCommonSubpath(self, paths: List[List[int]], m: int) -> bool:\n    hashSets = [self._rabinKarp(path, m) for path in paths]\n\n    for subpathHash in hashSets[0]:\n      if all(subpathHash in hashSet for hashSet in hashSets):\n        return True\n\n    return False\n\n  def _rabinKarp(self, path: List[int], m: int) -> Set[int]:\n    hashes = set()\n    maxPower = 1\n    hash = 0\n\n    for i, num in enumerate(path):\n      hash = (hash * self.kBase + num) % self.kMod\n      if i >= m:\n        hash = (hash - path[i - m] * maxPower % self.kMod + self.kMod) % self.kMod\n      else:\n        maxPower = maxPower * self.kBase % self.kMod\n      if i >= m - 1:\n        hashes.add(hash)\n\n    return hashes\n", "tests": {"23": "def test_longestCommonSubpath():\n\n    def longestCommonSubpath(n, paths):\n        l = 0\n        r = len(paths[0])\n        while l < r:\n            m = l + (r - l + 1) // 2\n            if self._checkCommonSubpath(paths, m):\n                return m\n            else:\n                r = m - 1\n    solution = Solution()\n    paths = [[0, 3, 5], [4, 2, 6, 7], [8, 5, 9]]\n    assert longestCommonSubpath(10, paths) == 2", "25": "def test_longestCommonSubpath():\n\n    def longestCommonSubpath(self, n, paths):\n        if len(paths) == 0 or paths[0] == []:\n            return 0\n        self.kMod = 8417508174513\n        self.kBase = 165131\n        l = 0\n        r = min((len(path) for path in paths))\n        while l < r:\n            m = l + (r - l + 1) // 2\n            if self._checkCommonSubpath(paths, m):\n                l = m\n            else:\n                r = m - 1\n        return l\n    solution = Solution()\n    n = 3\n    paths = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    assert solution.longestCommonSubpath(n, paths) == 0", "34": "def test_longestCommonSubpath():\n    solution = Solution()\n    paths = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    assert solution.longestCommonSubpath(10, paths) == 0", "46": "def test_longestCommonSubpath():\n    solution = Solution()\n    paths = [[1, 2, 3], [1, 2, 4, 5], [6, 7, 8]]\n    n = len(paths)\n    assert solution.longestCommonSubpath(n, paths) == 2", "48": "def test_longestCommonSubpath():\n    solution = Solution()\n    paths = [[1, 2], [2, 3, 4, 5], [6, 7, 8, 9]]\n    print(solution.longestCommonSubpath(10, paths))", "50": "def test_longestCommonSubpath(self):\n    solution = Solution()\n    n = 5\n    paths = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    self.assertEqual(solution.longestCommonSubpath(n, paths), 0)"}}
{"task_num": 1926, "task_title": "Nearest Exit from Entrance in Maze", "func_name": "nearestExit", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def nearestExit(self, maze: List[List[str]], entrance: List[int]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(maze)\n    n = len(maze[0])\n    ans = 0\n    q = collections.deque([(entrance[0], entrance[1])])\n    seen = {(entrance[0], entrance[1])}\n\n    while q:\n      ans += 1\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if (x, y) in seen or maze[x][y] == '+':\n            continue\n          if x == 0 or x == m - 1 or y == 0 or y == n - 1:\n            return ans\n          q.append((x, y))\n          seen.add((x, y))\n\n    return -1\n", "tests": {"28": "def test_nearestExit(self):\n    solution = Solution()\n    maze = [['.', '.', '+'], ['.', '.', '.'], ['.', '.', '.']]\n    entrance = [0, 0]\n    self.assertEqual(solution.nearestExit(maze, entrance), 1)", "30": "def test_nearestExit(self):\n    maze = [['.', '+', '.'], ['.', '.', '.'], ['+', '.', '']]\n    entrance = [0, 1]\n    self.assertEqual(solution.nearestExit(maze, entrance), 2)", "32": "def test_nearestExit(self):\n    maze = [['.', '.', '.'], ['+', '+', '.'], ['.', '#', 'e']]\n    entrance = [1, 2]\n    self.assertEqual(solution.nearestExit(maze, entrance), 2)"}}
{"task_num": 1928, "task_title": "Minimum Cost to Reach Destination in Time", "func_name": "minCost", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\n    n = len(passingFees)\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, 0, n - 1, maxTime, passingFees)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, maxTime: int, passingFees: List[int]) -> int:\n    cost = [math.inf for _ in range(len(graph))]\n    dist = [maxTime + 1 for _ in range(len(graph))]\n\n    cost[src] = passingFees[src]\n    dist[src] = 0\n    minHeap = [(cost[src], dist[src], src)]\n\n    while minHeap:\n      currCost, d, u = heapq.heappop(minHeap)\n      if u == dst:\n        return cost[dst]\n      if d > dist[u] and currCost > cost[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w > maxTime:\n          continue\n        if currCost + passingFees[v] < cost[v]:\n          cost[v] = currCost + passingFees[v]\n          dist[v] = d + w\n          heapq.heappush(minHeap, (cost[v], dist[v], v))\n        elif d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (currCost + passingFees[v], dist[v], v))\n\n    return -1\n", "tests": {"33": "def test_minCost(self):\n\n    class Solution:\n\n        def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\n            n = len(passingFees)\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, n - 1, maxTime, passingFees)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, maxTime: int, passingFees: List[int]) -> int:\n            cost = [math.inf for _ in range(len(graph))]\n            dist = [maxTime + 1 for _ in range(len(graph))]\n            cost[src] = passingFees[src]\n            dist[src] = 0\n            minHeap = [(cost[src], dist[src], src)]\n            while minHeap:\n                (currCost, d, u) = heapq.heappop(minHeap)\n                if u == dst:\n                    return cost[dst]\n                if d > dist[u] and currCost > cost[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w > maxTime:\n                        continue\n                    if currCost + passingFees[v] < cost[v]:\n                        cost[v] = currCost + passingFees[v]\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (cost[v], dist[v], v))\n                    elif d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (currCost + passingFees[v], dist[v], v))\n            return -1\n    solution = Solution()\n    maxTime = 60\n    edges = [[0, 1, 10], [0, 2, 5], [1, 3, 20], [2, 3, 30]]\n    passingFees = [15, 35, 50, 75]\n    self.assertEqual(solution.minCost(maxTime, edges, passingFees), 90)", "35": "def test_minCost():\n    solution = Solution()\n\n    def test1():\n        maxTime = 60\n        edges = [[0, 1, 10], [0, 2, 20], [1, 3, 30]]\n        passingFees = [5, 10, 10]", "38": "def test_minCost():\n\n    class Solution:\n\n        def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\n            n = len(passingFees)\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, n - 1, maxTime, passingFees)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, maxTime: int, passingFees: List[int]) -> int:\n            cost = [math.inf for _ in range(len(graph))]\n            dist = [maxTime + 1 for _ in range(len(graph))]\n            cost[src] = passingFees[src]\n            dist[src] = 0\n            minHeap = [(cost[src], dist[src], src)]\n            while minHeap:\n                (currCost, d, u) = heapq.heappop(minHeap)\n                if u == dst:\n                    return cost[dst]\n                if d > dist[u] and currCost > cost[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w > maxTime:\n                        continue\n                    if currCost + passingFees[v] < cost[v]:\n                        cost[v] = currCost + passingFees[v]\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (cost[v], dist[v], v))\n                    elif d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (currCost + passingFees[v], dist[v], v))\n            return -1\n    solution = Solution()\n    maxTime = 10\n    edges = [[0, 1, 2], [0, 2, 3]]\n    passingFees = [5, 6]\n    assert solution.minCost(maxTime, edges, passingFees) == -1", "40": "def test_minCost(self):\n    solution = Solution()\n    maxTime = 60\n    edges = [[0, 1, 2], [0, 2, 5], [2, 1, 3]]\n    passingFees = [10, 20, 30]\n    self.assertEqual(solution.minCost(maxTime, edges, passingFees), 40)", "41": "def test_minCost(self):\n    solution = Solution()\n    edges = [[0, 1, 10], [0, 2, 15]]\n    passingFees = [5, 3, 2]\n    maxTime = 23\n    self.assertEqual(solution.minCost(maxTime, edges, passingFees), 8)", "42": "def test_minCost(self):\n    maxTime = 60\n    edges = [[0, 1, 2], [0, 2, 5], [2, 3, 1]]\n    passingFees = [15, 10, 12]\n    self.assertEqual(solution.minCost(maxTime, edges, passingFees), 24)", "44": "def test_minCost(self):\n\n    class Solution:\n\n        def minCost(self, maxTime, edges, passingFees):\n            return self._dijkstra(edges, 0, len(passingFees) - 1, maxTime, passingFees)\n\n        def _dijkstra(self, graph, src, dst, maxTime, passingFees):\n            cost = [float('inf') for _ in range(len(graph))]\n            dist = [maxTime + 1 for _ in range(len(graph))]\n            cost[src] = passingFees[src]\n            dist[src] = 0\n            minHeap = [(cost[src], dist[src], src)]\n            while minHeap:\n                (currCost, d, u) = heapq.heappop(minHeap)\n                if u == dst:\n                    return cost[dst]\n                if d > dist[u] and currCost > cost[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w > maxTime:\n                        continue\n                    if currCost + passingFees[v] < cost[v]:\n                        cost[v] = currCost + passingFees[v]\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (cost[v], dist[v], v))\n                    elif d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (currCost + passingFees[v], dist[v], v))\n                    else:\n                        continue\n                return cost[dst]\n            return -1\n    solution = Solution()\n    maxTime = 1000\n    edges = [[0, 1, 2], [1, 2, 3]]\n    passingFees = [10, 20, 30]\n    self.assertEqual(solution.minCost(maxTime, edges, passingFees), 40)", "45": "def test_minCost(self):\n    solution = Solution()\n    maxTime = 5\n    edges = [[0, 1, 2], [1, 2, 3], [0, 2, 2]]\n    passingFees = [10, 20, 30]\n    self.assertEqual(solution.minCost(maxTime, edges, passingFees), -1)"}}
{"task_num": 1938, "task_title": "Maximum Genetic Difference Query", "func_name": "maxGeneticDifference", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass TrieNode:\n  def __init__(self):\n    self.children = [None] * 2\n    self.count = 0\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n    self.kHeight = 17\n\n  def update(self, num: int, val: int) -> None:\n    node = self.root\n    for i in range(self.kHeight, -1, -1):\n      bit = (num >> i) & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n      node.count += val\n\n  def query(self, num: int) -> int:\n    ans = 0\n    node = self.root\n    for i in range(self.kHeight, -1, -1):\n      bit = (num >> i) & 1\n      targetBit = bit ^ 1\n      if node.children[targetBit] and node.children[targetBit].count > 0:\n        ans += 1 << i\n        node = node.children[targetBit]\n      else:\n        node = node.children[targetBit ^ 1]\n    return ans\n\n\nclass Solution:\n  def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\n    n = len(parents)\n    ans = [0] * len(queries)\n    rootVal = -1\n    tree = [[] for _ in range(n)]\n    nodeToQueries = collections.defaultdict(list)\n    trie = Trie()\n\n    for i, parent in enumerate(parents):\n      if parent == -1:\n        rootVal = i\n      else:\n        tree[parent].append(i)\n\n    for i, (node, val) in enumerate(queries):\n      nodeToQueries[node].append((i, val))\n\n    def dfs(node: int) -> None:\n      trie.update(node, 1)\n\n      for i, val in nodeToQueries[node]:\n        ans[i] = trie.query(val)\n\n      for child in tree[node]:\n        dfs(child)\n\n      trie.update(node, -1)\n\n    dfs(rootVal)\n    return ans\n", "tests": {"27": "def test_maxGeneticDifference():\n\n    def get_test_case():\n        parents = [1, -1, 0]\n        queries = [[0, 3], [0, 2]]\n        return (parents, queries)\n\n    def make_assertion(expected):\n        solution = Solution()\n        (parents, queries) = get_test_case()\n        actual = solution.maxGeneticDifference(parents, queries)", "38": "    def test_maxGeneticDifference(self):\n        def maxGeneticDifference(parents, queries):\n            n = len(parents)\n            ans = [0] * len(queries)\n            rootVal = -1\n            tree = [[] for _ in range(n)]\n            nodeToQueries = collections.defaultdict(list)\n            trie = Trie()\n\n            for i, parent in enumerate(parents):\n                if parent == -1:\n                    rootVal = i\n                else:\n                    tree[parent].append(i)\n\n            for i, (node, val) in enumerate(queries):\n                nodeToQueries[node].append((i, val))\n\n            def dfs(node: int) -> None:\n                trie.update(node, 1)\n                for i, val in nodeToQueries[node]:\n                    ans[i] = trie.query(val)\n                for child in tree[node]:\n                    dfs(child)\n                trie.update(node, -1)\n\n            dfs(rootVal)\n            return ans\n\n        solution = Solution()\n        parents = [-1,0,0]\n        queries = [[0,4],[1,13]]\n        self.assertEqual(maxGeneticDifference(parents,queries),[4,13])\n\nif __name__ == '__main__':\n    unittest.main()", "39": "def test_maxGeneticDifference():\n    solution = Solution()\n\n    def is_valid_trie():\n        n = len(parents)\n        trie = Trie()\n        for i in range(n):\n            trie.update(i, 1)\n\n        def dfs(node: int) -> None:\n            for child in tree[node]:\n                dfs(child)\n        dfs(0)\n        return True\n    parents = [2, -1]\n    queries = [[0, 3], [0, 5]]\n    result = solution.maxGeneticDifference(parents, queries)", "41": "def test_maxGeneticDifference():\n\n    def maxGeneticDifference(parents, queries):\n        n = len(parents)\n        ans = [0] * len(queries)\n        rootVal = -1\n        tree = [[] for _ in range(n)]\n        nodeToQueries = collections.defaultdict(list)\n        trie = Trie()\n        for (i, parent) in enumerate(parents):\n            if parent == -1:\n                rootVal = i\n            else:\n                tree[parent].append(i)\n        for (i, (node, val)) in enumerate(queries):\n            nodeToQueries[node].append((i, val))\n\n        def dfs(node: int) -> None:\n            trie.update(node, 1)\n            for (i, val) in nodeToQueries[node]:\n                ans[i] = trie.query(val)\n            for child in tree[node]:\n                dfs(child)\n            trie.update(node, -1)\n        dfs(rootVal)\n        return ans\n    solution = Solution()\n    parents = [2, -1, -1]\n    queries = [[0, 3], [1, 1]]\n    assert maxGeneticDifference(parents, queries) == [4, 2]", "56": "def test_maxGeneticDifference():\n\n    def test_func():\n        parents = [-1, -1, 0]\n        queries = [[1, 0], [2, 0]]\n        return [0, 0]\n    assert test_func() == [0, 0], 'Test case failed for rootVal = i'\ntest_maxGeneticDifference()", "58": "def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [2, -1, 0, 0]\n    queries = [[3, 100], [4, 200]]\n    expected = [75, 250]\n    result = solution.maxGeneticDifference(parents, queries)"}}
{"task_num": 1971, "task_title": "Find if Path Exists in Graph", "func_name": "validPath", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def validPath(self, n: int, edges: List[List[int]], source: int, destination: int) -> bool:\n    uf = UnionFind(n)\n\n    for u, v in edges:\n      uf.unionByRank(u, v)\n\n    return uf.find(source) == uf.find(destination)\n", "tests": {"20": "def test_validPath(self):\n\n    class Solution:\n\n        def validPath(self, n: int, edges: List[List[int]], source: int, destination: int) -> bool:\n            uf = UnionFind(n)\n            for (u, v) in edges:\n                uf.unionByRank(u, v)\n            return uf.find(source) == uf.find(destination)\n    solution = Solution()\n    self.assertTrue(solution.validPath(3, [[0, 1], [1, 2], [2, 0]], 0, 2))", "22": "def test_validPath(self):\n    solution = Solution()\n    n = 4\n    edges = [[0, 1], [0, 2], [3, 1]]\n    source = 2\n    destination = 3\n    self.assertTrue(solution.validPath(n, edges, source, destination))", "24": "def test_validPath(self):\n    solution = Solution()\n    n = 4\n    edges = [[0, 1], [0, 2], [1, 3]]\n    source = 0\n    destination = 3\n    self.assertTrue(solution.validPath(n, edges, source, destination))", "26": "def test_validPath(self):\n    n = 3\n    edges = [[0, 1], [1, 2], [2, 0]]\n    source = 0\n    destination = 2\n    self.assertTrue(solution.validPath(n, edges, source, destination))", "27": "def test_validPath(self):\n    n = 5\n    edges = [[0, 1], [0, 2], [3, 4]]\n    source = 0\n    destination = 4\n    self.assertTrue(solution.validPath(n, edges, source, destination))", "31": "def test_validPath():\n\n    def unionFind(n, edges):\n        uf = [i for i in range(n)]\n        rank = [0] * n\n\n        def find(u):\n            if uf[u] != u:\n                uf[u] = find(uf[u])\n            return uf[u]\n\n        def unionByRank(u, v):\n            i = find(u)\n            j = find(v)\n            if i == j:\n                return False\n            if rank[i] < rank[j]:\n                uf[i] = j\n            elif rank[i] > rank[j]:\n                uf[j] = i\n            else:\n                uf[i] = j\n                rank[j] += 1\n            return True\n        for (u, v) in edges:\n            unionByRank(u, v)\n        return find(0) == find(n - 1)\n    solution = Solution()\n    print(solution.validPath(3, [[0, 1], [1, 2]], 0, 2))"}}
{"task_num": 1976, "task_title": "Number of Ways to Arrive at Destination", "func_name": "countPaths", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countPaths(self, n: int, roads: List[List[int]]) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in roads:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, 0, n - 1)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int) -> int:\n    kMod = 10**9 + 7\n    ways = [0] * len(graph)\n    dist = [math.inf] * len(graph)\n\n    ways[src] = 1\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          ways[v] = ways[u]\n          heapq.heappush(minHeap, (dist[v], v))\n        elif d + w == dist[v]:\n          ways[v] += ways[u]\n          ways[v] %= kMod\n\n    return ways[dst]\n", "tests": {"33": "def test_countPaths(self):\n    n = 3\n    roads = [[0, 1, 7], [0, 2, 5], [1, 2, 8]]\n    self.assertEqual(self.solution.countPaths(n, roads), 2)", "36": "def test_countPaths():\n\n    class Solution:\n\n        def countPaths(self, n, roads):\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in roads:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, n - 1)\n\n        def _dijkstra(self, graph, src, dst):\n            kMod = 10 ** 9 + 7\n            ways = [0] * len(graph)\n            dist = [math.inf] * len(graph)\n            ways[src] = 1\n            dist[src] = 0\n            minHeap = [(dist[src], src)]\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < dist[v]:\n                        dist[v] = d + w\n                        ways[v] = ways[u]\n                        heapq.heappush(minHeap, (dist[v], v))\n                    elif d + w == dist[v]:\n                        ways[v] += ways[u]\n                        ways[v] %= kMod\n            return ways[dst]\n    solution = Solution()\n    n = 3\n    roads = [[0, 1, 7], [1, 2, 5]]\n    assert solution.countPaths(n, roads) == 2", "37": "def test_countPaths(self):\n    n = 5\n    roads = [[0, 1, 3], [0, 2, 4], [1, 2, 2], [1, 3, 6]]\n    result = self.solution.countPaths(n, roads)", "38": "def test_countPaths():\n\n    class Solution:\n\n        def countPaths(self, n: int, roads: List[List[int]]) -> int:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in roads:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, n - 1)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int) -> int:\n            kMod = 10 ** 9 + 7\n            ways = [0] * len(graph)\n            dist = [math.inf] * len(graph)\n            ways[src] = 1\n            dist[src] = 0\n            minHeap = [(dist[src], src)]\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < dist[v]:\n                        dist[v] = d + w\n                        ways[v] = ways[u]\n                        heapq.heappush(minHeap, (dist[v], v))\n                    elif d + w == dist[v]:\n                        ways[v] += ways[u]\n                        ways[v] %= kMod\n            return ways[dst]\n    solution = Solution()\n    roads = [[0, 1, 10], [0, 2, 20], [1, 3, 30], [2, 3, 15]]\n    assert solution.countPaths(4, roads) == 2", "40": "def test_countPaths():\n\n    class Solution:\n\n        def countPaths(self, n: int, roads: List[List[int]]) -> int:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in roads:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, n - 1)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int) -> int:\n            kMod = 10 ** 9 + 7\n            ways = [0] * len(graph)\n            dist = [math.inf] * len(graph)\n            ways[src] = 1\n            dist[src] = 0\n            minHeap = [(dist[src], src)]\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < dist[v]:\n                        dist[v] = d + w\n                        ways[v] = ways[u]\n                        heapq.heappush(minHeap, (dist[v], v))\n                    elif d + w == dist[v]:\n                        ways[v] += ways[u]\n                        ways[v] %= kMod\n            return ways[dst]\n    solution = Solution()\n    n = 4\n    roads = [[0, 1, 5], [0, 2, 3], [0, 3, 7], [1, 3, 9]]\n    assert solution.countPaths(n, roads) == 4", "41": "def test_countPaths(self):\n\n    class Solution:\n\n        def countPaths(self, n: int, roads: List[List[int]]) -> int:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in roads:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, n - 1)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int) -> int:\n            kMod = 10 ** 9 + 7\n            ways = [0] * len(graph)\n            dist = [math.inf] * len(graph)\n            ways[src] = 1\n            dist[src] = 0\n            minHeap = [(dist[src], src)]\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < dist[v]:\n                        dist[v] = d + w\n                        ways[v] = ways[u]\n                        heapq.heappush(minHeap, (dist[v], v))\n                    elif d + w == dist[v]:\n                        ways[v] += ways[u]\n                        ways[v] %= kMod\n            return ways[dst]\n    solution = Solution()\n    roads = [[0, 1, 2], [0, 2, 3], [1, 3, 4]]\n    self.assertEqual(solution.countPaths(4, roads), 5)"}}
{"task_num": 1977, "task_title": "Number of Ways to Separate Numbers", "func_name": "numberOfCombinations", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numberOfCombinations(self, num: str) -> int:\n    if num[0] == '0':\n      return 0\n\n    kMod = 1_000_000_007\n    n = len(num)\n    dp = [[0] * (n + 1) for _ in range(n)]\n    lcs = [[0] * (n + 1) for _ in range(n + 1)]\n\n    for i in range(n - 1, -1, -1):\n      for j in range(i + 1, n):\n        if num[i] == num[j]:\n          lcs[i][j] = lcs[i + 1][j + 1] + 1\n\n    for i in range(n):\n      for k in range(1, i + 2):\n        dp[i][k] += dp[i][k - 1]\n        dp[i][k] %= kMod\n        s = i - k + 1\n        if num[s] == '0':\n          continue\n        if s == 0:\n          dp[i][k] += 1\n          continue\n        if s < k:\n          dp[i][k] += dp[s - 1][s]\n          continue\n        l = lcs[s - k][s]\n        if l >= k or num[s - k + l] <= num[s + l]:\n          dp[i][k] += dp[s - 1][k]\n        else:\n          dp[i][k] += dp[s - 1][k - 1]\n\n    return dp[n - 1][n] % kMod\n", "tests": {"14": "def test_numberOfCombinations():\n    solution = Solution()\n\n    def test_case1():\n        num = '001'\n        assert solution.numberOfCombinations(num) == 0", "24": "def test_numberOfCombinations(self):\n    solution = Solution()\n    self.assertEqual(solution.numberOfCombinations('222'), 6)", "32": "def test_numberOfCombinations():\n    solution = Solution()\n    print(solution.numberOfCombinations('00'))", "34": "def test_numberOfCombinations():\n\n    class Solution:\n\n        def numberOfCombinations(self, num: str) -> int:\n            if num[0] == '0':\n                return 0\n            kMod = 1000000007\n            n = len(num)\n            dp = [[0] * (n + 1) for _ in range(n)]\n            lcs = [[0] * (n + 1) for _ in range(n + 1)]\n            for i in range(n - 1, -1, -1):\n                for j in range(i + 1, n):\n                    if num[i] == num[j]:\n                        lcs[i][j] = lcs[i + 1][j + 1] + 1\n            for i in range(n):\n                for k in range(1, i + 2):\n                    dp[i][k] += dp[i][k - 1]\n                    dp[i][k] %= kMod\n                    s = i - k + 1\n                    if num[s] == '0':\n                        continue\n                    if s == 0:\n                        assert dp[i][k] == 1\n                    else:\n                        pass\n            return dp[n - 1][n] % kMod\n    solution = Solution()\n    print(solution.numberOfCombinations('000'))", "35": "def test_numberOfCombinations():\n\n    def numberOfCombinations(num):\n        if num[0] == '0':\n            return 0\n        kMod = 1000000007\n        n = len(num)\n        dp = [[0] * (n + 1) for _ in range(n)]\n        lcs = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                if num[i] == num[j]:\n                    lcs[i][j] = lcs[i + 1][j + 1] + 1\n        for i in range(n):\n            for k in range(1, i + 2):\n                dp[i][k] += dp[i][k - 1]\n                dp[i][k] %= kMod\n                s = i - k + 1\n                if num[s] == '0':\n                    continue\n                if s == 0:\n                    dp[i][k] += 1\n                elif s < k:\n                    dp[i][k] += dp[s - 1][s]\n                else:\n                    l = lcs[s - k][s]\n                    if l >= k or num[s - k + l] <= num[s + l]:\n                        dp[i][k] += dp[s - 1][k]\n                    else:\n                        dp[i][k] += dp[s - 1][k - 1]\n        return dp[n - 1][n] % kMod\n    solution = Solution()\n    assert numberOfCombinations('1234') == solution.numberOfCombinations('1234')", "37": "def test_numberOfCombinations():\n\n    class Solution:\n\n        def numberOfCombinations(self, num: str) -> int:\n            if num[0] == '0':\n                return 0\n            kMod = 1000000007\n            n = len(num)\n            dp = [[0] * (n + 1) for _ in range(n)]\n            lcs = [[0] * (n + 1) for _ in range(n + 1)]\n            for i in range(n - 1, -1, -1):\n                for j in range(i + 1, n):\n                    if num[i] == num[j]:\n                        lcs[i][j] = lcs[i + 1][j + 1] + 1\n            for i in range(n):\n                for k in range(1, i + 2):\n                    dp[i][k] += dp[i][k - 1]\n                    dp[i][k] %= kMod\n                    s = i - k + 1\n                    if num[s] == '0':\n                        continue\n                    if s == 0:\n                        dp[i][k] += 1\n                        continue\n                    if s < k:\n                        return dp[4][3]\n                    l = lcs[s - k][s]\n                    if l >= k or num[s - k + l] <= num[s + l]:\n                        dp[i][k] += dp[s - 1][k]\n                    else:\n                        dp[i][k] += dp[s - 1][k - 1]\n            return dp[n - 1][n] % kMod\n    solution = Solution()\n    assert solution.numberOfCombinations('123') == 3", "38": "def test_numberOfCombinations():\n    solution = Solution()\n    print(solution.numberOfCombinations('1929'))", "41": "    def test_numberOfCombinations(self):\n        def numberOfCombinations(num: str) -> int:\n            if num[0] == '0':\n                return 0\n            kMod = 1_000_000_007\n            n = len(num)\n            dp = [[0] * (n + 1) for _ in range(n)]\n            lcs = [[0] * (n + 1) for _ in range(n + 1)]\n\n            for i in range(n - 1, -1, -1):\n                for j in range(i + 1, n):\n                    if num[i] == num[j]:\n                        lcs[i][j] = lcs[i + 1][j + 1] + 1\n\n            for i in range(n):\n                for k in range(1, i + 2):\n                    dp[i][k] += dp[i][k - 1]\n                    dp[i][k] %= kMod\n                    s = i - k + 1\n                    if num[s] == '0':\n                        continue\n                    if s == 0:\n                        dp[i][k] += 1\n                        continue\n                    if s < k:\n                        dp[i][k] += dp[s - 1][s]\n                        continue\n                    l = lcs[s - k][s]\n                    if l >= k or num[s - k + l] <= num[s + l]:\n                        dp[i][k] += dp[s - 1][k]\n                    else:\n                        dp[i][k] += dp[s - 1][k - 1]\n\n            return dp[n - 1][n] % kMod\n\n        self.assertEqual(numberOfCombinations('1234'), 5)\n\nif __name__ == '__main__':\n    unittest.main()", "43": "def test_numberOfCombinations():\n\n    def assertResult(expected, actual):\n        if expected != actual % (10 ** 9 + 7):\n            raise AssertionError(f'Expected {expected}, got {actual}')\n    num = '12345'\n    result = Solution().numberOfCombinations(num)\n    assertResult(1, result)\n    num = '10230'\n    result = Solution().numberOfCombinations(num)\n    assertResult(5, result)\n    num = '1000'\n    result = Solution().numberOfCombinations(num)\n    assertResult(1, result)\n    num = '1234'\n    result = Solution().numberOfCombinations(num)\n    assertResult(3, result)\n    num = '2002'\n    result = Solution().numberOfCombinations(num)\n    assertResult(0, result)"}}
{"task_num": 1994, "task_title": "The Number of Good Subsets", "func_name": "numberOfGoodSubsets", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numberOfGoodSubsets(self, nums: List[int]) -> int:\n    kMod = 1_000_000_007\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n    n = 1 << len(primes)\n    dp = [1] + [0] * (n - 1)\n    count = collections.Counter(nums)\n\n    for num, freq in count.items():\n      if num == 1:\n        continue\n      if any(num % squared == 0 for squared in [4, 9, 25]):\n        continue\n      numPrimesMask = 0\n      for i, prime in enumerate(primes):\n        if num % prime == 0:\n          numPrimesMask += 1 << i\n      for primesMask in range(n):\n        if primesMask & numPrimesMask > 0:\n          continue\n        nextPrimesMask = numPrimesMask | primesMask\n        dp[nextPrimesMask] += dp[primesMask] * freq\n        dp[nextPrimesMask] %= kMod\n\n    return (1 << count[1]) * sum(dp[1:]) % kMod\n", "tests": {"21": "def test_numberOfGoodSubsets():\n    solution = Solution()\n    print(solution.numberOfGoodSubsets([1, 2]))", "23": "def test_numberOfGoodSubsets():\n    solution = Solution()\n    nums = [25, 3]\n    assert solution.numberOfGoodSubsets(nums) == 1 << 2, f'Expected number of good subsets to be {1 << 2}, but got {solution.numberOfGoodSubsets(nums)}'", "27": "def test_numberOfGoodSubsets():\n\n    def helper(nums):\n        kMod = 1000000007\n        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n        n = 1 << len(primes)\n        dp = [1] + [0] * (n - 1)\n        count = collections.Counter(nums)\n        for (num, freq) in count.items():\n            if num == 1:\n                continue\n            if any((num % squared == 0 for squared in [4, 9, 25])):\n                continue\n            numPrimesMask = 0\n            for (i, prime) in enumerate(primes):\n                if num % prime == 0:\n                    numPrimesMask += 1 << i\n                else:\n                    assert num % prime != 0\n            for primesMask in range(n):\n                if primesMask & numPrimesMask > 0:\n                    continue\n                nextPrimesMask = numPrimesMask | primesMask\n                dp[nextPrimesMask] += dp[primesMask] * freq\n                dp[nextPrimesMask] %= kMod\n        return (1 << count[1]) * sum(dp[1:]) % kMod\n    assert helper([2, 3, 5, 7]) == 6", "30": "def test_numberOfGoodSubsets():\n    solution = Solution()\n\n    def helper(nums):"}}
{"task_num": 1998, "task_title": "GCD Sort of an Array", "func_name": "gcdSort", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def gcdSort(self, nums: List[int]) -> bool:\n    maxNum = max(nums)\n    minPrimeFactors = self._sieveEratosthenes(maxNum + 1)\n    uf = UnionFind(maxNum + 1)\n\n    for num in nums:\n      for primeFactor in self._getPrimeFactors(num, minPrimeFactors):\n        uf.unionByRank(num, primeFactor)\n\n    for a, b in zip(nums, sorted(nums)):\n      if uf.find(a) != uf.find(b):\n        return False\n\n    return True\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeFactors(self, num: int, minPrimeFactors: List[int]) -> List[int]:\n    primeFactors = []\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      primeFactors.append(divisor)\n      while num % divisor == 0:\n        num //= divisor\n    return primeFactors\n", "tests": {"20": "def test_gcdSort():\n\n    class Solution:\n\n        def gcdSort(self, nums):\n            maxNum = max(nums)\n            minPrimeFactors = self._sieveEratosthenes(maxNum + 1)\n            uf = UnionFind(maxNum + 1)\n            for num in nums:\n                for primeFactor in self._getPrimeFactors(num, minPrimeFactors):\n                    uf.unionByRank(num, primeFactor)\n            for (a, b) in zip(nums, sorted(nums)):\n                if uf.find(a) != uf.find(b):\n                    return False\n            return True\n    solution = Solution()\n    nums = [2, 4, 6, 8]\n    assert solution.gcdSort(nums)", "22": "def test_gcdSort():\n    solution = Solution()\n\n    def gcd(a, b):\n        while b != 0:\n            (a, b) = (b, a % b)\n        return a\n    nums = [8, 9, 7, 6]\n    assert not solution.gcdSort(nums)", "24": "def test_gcdSort():\n\n    class Solution:\n\n        def gcdSort(self, nums):\n            maxNum = max(nums)\n            minPrimeFactors = self._sieveEratosthenes(maxNum + 1)\n            uf = UnionFind(maxNum + 1)\n            for num in nums:\n                for primeFactor in self._getPrimeFactors(num, minPrimeFactors):\n                    uf.unionByRank(num, primeFactor)\n            for (a, b) in zip(nums, sorted(nums)):\n                if uf.find(a) != uf.find(b):\n                    return False\n            return True\n    solution = Solution()\n    nums = [2, 4, 6, 8]\n    assert solution.gcdSort(nums)", "26": "def test_gcdSort():\n    solution = Solution()\n    nums = [4, 2, 3, 5]\n    assert solution.gcdSort(nums)", "27": "def test_gcdSort():\n\n    class Solution:\n\n        def gcdSort(self, nums):\n            maxNum = max(nums)\n            minPrimeFactors = self._sieveEratosthenes(maxNum + 1)\n            uf = UnionFind(maxNum + 1)\n            for num in nums:\n                for primeFactor in self._getPrimeFactors(num, minPrimeFactors):\n                    uf.unionByRank(num, primeFactor)\n            for (a, b) in zip(nums, sorted(nums)):\n                if uf.find(a) != uf.find(b):\n                    return False\n            return True\n    solution = Solution()\n    assert solution.gcdSort([1, 2, 3])", "32": "def test_gcdSort():\n\n    class Solution:\n\n        def gcdSort(self, nums):\n            maxNum = max(nums)\n            minPrimeFactors = self._sieveEratosthenes(maxNum + 1)\n            uf = UnionFind(maxNum + 1)\n            for num in nums:\n                for primeFactor in self._getPrimeFactors(num, minPrimeFactors):\n                    uf.unionByRank(num, primeFactor)\n            for (a, b) in zip(nums, sorted(nums)):\n                if uf.find(a) != uf.find(b):\n                    return False\n            return True\n\n    def testUnionFind():\n        uf = UnionFind(3)\n        uf.id = [1, 2, 3]\n        uf.rank = [0, 0, 0]\n        assert uf.find(1) == 1\n        assert uf.find(2) == 2\n        uf.unionByRank(1, 2)\n        assert uf.find(1) == 1\n        assert uf.id[2] == 1\n    solution = Solution()\n    testUnionFind()", "48": "def test_gcdSort():\n\n    class Solution:\n\n        def gcdSort(self, nums):\n            maxNum = max(nums)\n            minPrimeFactors = self._sieveEratosthenes(maxNum + 1)\n            uf = UnionFind(maxNum + 1)\n            for num in nums:\n                for primeFactor in self._getPrimeFactors(num, minPrimeFactors):\n                    uf.unionByRank(num, primeFactor)\n            for (a, b) in zip(nums, sorted(nums)):\n                if uf.find(a) != uf.find(b):\n                    return False\n            return True\n    solution = Solution()\n    print(solution.gcdSort([7, 3]))", "56": "def test_gcdSort(self):\n\n    class Solution:\n\n        def gcdSort(self, nums: List[int]) -> bool:\n            maxNum = max(nums)\n            minPrimeFactors = self._sieveEratosthenes(maxNum + 1)\n            uf = UnionFind(maxNum + 1)\n            for num in nums:\n                for primeFactor in self._getPrimeFactors(num, minPrimeFactors):\n                    uf.unionByRank(num, primeFactor)\n            for (a, b) in zip(nums, sorted(nums)):\n                if uf.find(a) != uf.find(b):\n                    return False\n            return True\n\n    class UnionFind:\n\n        def __init__(self, n: int):\n            self.id = list(range(n))\n            self.rank = [0] * n\n\n        def unionByRank(self, u: int, v: int) -> None:\n            i = self.find(u)\n            j = self.find(v)\n            if i == j:\n                return False\n            if self.rank[i] < self.rank[j]:\n                self.id[i] = j\n            elif self.rank[i] > self.rank[j]:\n                self.id[j] = i\n            else:\n                self.id[i] = j\n                self.rank[j] += 1\n            return True\n\n        def find(self, u: int) -> int:\n            if self.id[u] != u:\n                self.id[u] = self.find(self.id[u])\n            return self.id[u]\n    solution = Solution()\n    nums = [24, 12, 8, 16]\n    self.assertTrue(solution.gcdSort(nums))", "57": "def test_gcdSort(self):\n\n    class Solution:\n\n        def gcdSort(self, nums: List[int]) -> bool:\n            maxNum = max(nums)\n            minPrimeFactors = self._sieveEratosthenes(maxNum + 1)\n            uf = UnionFind(maxNum + 1)\n            for num in nums:\n                for primeFactor in self._getPrimeFactors(num, minPrimeFactors):\n                    uf.unionByRank(num, primeFactor)\n            for (a, b) in zip(nums, sorted(nums)):\n                if uf.find(a) != uf.find(b):\n                    return False\n            return True\n\n        def _sieveEratosthenes(self, n: int) -> List[int]:\n            minPrimeFactors = [i for i in range(n + 1)]\n            for i in range(2, int(n ** 0.5) + 1):\n                if minPrimeFactors[i] == i:\n                    for j in range(i * i, n, i):\n                        minPrimeFactors[j] = min(minPrimeFactors[j], i)\n            return minPrimeFactors\n\n        def _getPrimeFactors(self, num: int, minPrimeFactors: List[int]) -> List[int]:\n            primeFactors = []\n            while num > 1:\n                divisor = minPrimeFactors[num]\n                primeFactors.append(divisor)\n                while num % divisor == 0:\n                    num //= divisor\n            return primeFactors\n    solution = Solution()\n    nums = [10, 7, 5, 25, 12]\n    self.assertTrue(solution.gcdSort(nums))"}}
{"task_num": 2019, "task_title": "The Score of Students Solving Math Expression", "func_name": "scoreOfStudents", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nimport operator\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def scoreOfStudents(self, s: str, answers: List[int]) -> int:\n    n = len(s) // 2 + 1\n    ans = 0\n    func = {'+': operator.add, '*': operator.mul}\n    dp = [[set() for j in range(n)] for _ in range(n)]\n\n    for i in range(n):\n      dp[i][i].add(int(s[i * 2]))\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        for k in range(i, j):\n          op = s[k * 2 + 1]\n          for a in dp[i][k]:\n            for b in dp[k + 1][j]:\n              res = func[op](a, b)\n              if res <= 1000:\n                dp[i][j].add(res)\n\n    correctAnswer = eval(s)\n\n    for answer, freq in collections.Counter(answers).items():\n      if answer == correctAnswer:\n        ans += 5 * freq\n      elif answer in dp[0][n - 1]:\n        ans += 2 * freq\n\n    return ans\n", "tests": {"31": "def test_scoreOfStudents():\n\n    class Solution:\n\n        def scoreOfStudents(self, s: str, answers: List[int]) -> int:\n            n = len(s) // 2 + 1\n            ans = 0\n            func = {'+': operator.add, '*': operator.mul}\n            dp = [[set() for j in range(n)] for _ in range(n)]\n\n            def test_case():\n                s = '5*3+1'\n                answers = [10]\n                return Solution().scoreOfStudents(s, answers)\n            print(test_case())", "37": "def test_scoreOfStudents(self):\n\n    class Solution:\n\n        def scoreOfStudents(self, s: str, answers: List[int]) -> int:\n            n = len(s) // 2 + 1\n            ans = 0\n            func = {'+': operator.add, '*': operator.mul}\n            dp = [[set() for j in range(n)] for _ in range(n)]\n            for i in range(n):\n                dp[i][i].add(int(s[i * 2]))\n            for d in range(1, n):\n                for i in range(n - d):\n                    j = i + d\n                    for k in range(i, j):\n                        op = s[k * 2 + 1]\n                        for a in dp[i][k]:\n                            for b in dp[k + 1][j]:\n                                res = func[op](a, b)\n                                if res <= 1000:\n                                    dp[i][j].add(res)\n            correctAnswer = eval(s)\n            for (answer, freq) in collections.Counter(answers).items():\n                if answer == correctAnswer:\n                    ans += 5 * freq\n                elif answer in dp[0][n - 1]:\n                    ans += 2 * freq\n            return ans\n    solution = Solution()\n    s = '3+5*2'\n    answers = [7, 8]\n    self.assertEqual(solution.scoreOfStudents(s, answers), 15)", "39": "def test_scoreOfStudents():\n\n    class Solution:\n\n        def scoreOfStudents(self, s: str, answers: List[int]) -> int:\n            n = len(s) // 2 + 1\n            ans = 0\n            func = {'+': operator.add, '*': operator.mul}\n            dp = [[set() for j in range(n)] for _ in range(n)]\n            for i in range(n):\n                dp[i][i].add(int(s[i * 2]))\n            for d in range(1, n):\n                for i in range(n - d):\n                    j = i + d\n                    for k in range(i, j):\n                        op = s[k * 2 + 1]\n                        for a in dp[i][k]:\n                            for b in dp[k + 1][j]:\n                                res = func[op](a, b)\n                                if res <= 1000:\n                                    dp[i][j].add(res)\n            correctAnswer = eval(s)\n            for (answer, freq) in collections.Counter(answers).items():\n                if answer == correctAnswer:\n                    ans += 5 * freq\n                elif answer in [3, 6, 9]:\n                    ans += 2 * freq\n            return ans\n    solution = Solution()\n    s = '+*321'\n    answers = [3, 6]\n    assert solution.scoreOfStudents(s, answers) == 16"}}
{"task_num": 2030, "task_title": "Smallest K-Length Subsequence With Occurrences of a Letter", "func_name": "smallestSubsequence", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\n    stack = []\n    required = repetition\n    nLetters = s.count(letter)\n\n    for i, c in enumerate(s):\n      while stack and stack[-1] > c  and len(stack) + len(s) - i - 1 >= k and (stack[-1] != letter or nLetters > required):\n        if stack.pop() == letter:\n          required += 1\n      if len(stack) < k:\n        if c == letter:\n          stack.append(c)\n          required -= 1\n        elif k - len(stack) > required:\n          stack.append(c)\n      if c == letter:\n        nLetters -= 1\n\n    return ''.join(stack)\n", "tests": {"20": "def test_smallestSubsequence():\n    solution = Solution()\n    s = 'ahhcb'\n    k = 4\n    letter = 'a'\n    repetition = 2\n    assert solution.smallestSubsequence(s, k, letter, repetition) == 'aahc', f\"Expected 'aahc' but got {solution.smallestSubsequence(s, k, letter, repetition)}\"", "22": "def test_smallestSubsequence(self):\n    solution = Solution()\n    self.assertEqual(solution.smallestSubsequence('abacaba', 3, 'a', 2), 'aaab')", "23": "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('bba', 2, 'a', 0) == 'ab'", "24": "def test_smallestSubsequence(self):\n\n    class Solution:\n\n        def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\n            stack = []\n            required = repetition\n            nLetters = s.count(letter)\n            for (i, c) in enumerate(s):\n                while stack and stack[-1] > c and (len(stack) + len(s) - i - 1 >= k) and (stack[-1] != letter or nLetters > required):\n                    if stack.pop() == letter:\n                        required += 1\n                if len(stack) < k:\n                    if c == letter:\n                        stack.append(c)\n                        required -= 1\n                    elif k - len(stack) > required:\n                        stack.append(c)\n                if c == letter:\n                    nLetters -= 1\n            return ''.join(stack)\n    solution = Solution()\n    self.assertEqual(solution.smallestSubsequence('alasdsajfjsa', 4, 's', 2), 'alsa')", "25": "def test_smallestSubsequence():\n\n    class Solution:\n\n        def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\n            stack = []\n            required = repetition\n            nLetters = s.count(letter)\n            for (i, c) in enumerate(s):\n                while stack and stack[-1] > c and (len(stack) + len(s) - i - 1 >= k) and (stack[-1] != letter or nLetters > required):\n                    if stack.pop() == letter:\n                        required += 1\n                if len(stack) < k:\n                    if c == letter:\n                        stack.append(c)\n                        required -= 1\n                    elif k - len(stack) > required:\n                        stack.append(c)\n                if c == letter:\n                    nLetters -= 1\n            return ''.join(stack)\n    solution = Solution()\n    print(solution.smallestSubsequence('bbbab', 2, 'b', 2))", "26": "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('abbc', 2, 'b', 1) == 'bb'", "28": "def test_smallestSubsequence():\n    solution = Solution()\n\n    def test_case_1():\n        s = 'aabbcc'\n        k = 3\n        letter = 'b'\n        repetition = 2\n        expected_output = 'bcc'\n        assert solution.smallestSubsequence(s, k, letter, repetition) == expected_output"}}
{"task_num": 2040, "task_title": "Kth Smallest Product of Two Sorted Arrays", "func_name": "kthSmallestProduct", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int) -> int:\n    A1 = [-num for num in nums1 if num < 0][::-1]\n    A2 = [num for num in nums1 if num >= 0]\n    B1 = [-num for num in nums2 if num < 0][::-1]\n    B2 = [num for num in nums2 if num >= 0]\n\n    negCount = len(A1) * len(B2) + len(A2) * len(B1)\n\n    if k > negCount:\n      k -= negCount\n      sign = 1\n    else:\n      k = negCount - k + 1\n      sign = -1\n      B1, B2 = B2, B1\n\n    def numProductNoGreaterThan(A: List[int], B: List[int], m: int) -> int:\n      ans = 0\n      j = len(B) - 1\n      for i in range(len(A)):\n        while j >= 0 and A[i] * B[j] > m:\n          j -= 1\n        ans += j + 1\n      return ans\n\n    l = 0\n    r = 10**10\n\n    while l < r:\n      m = (l + r) // 2\n      if numProductNoGreaterThan(A1, B1, m) + numProductNoGreaterThan(A2, B2, m) >= k:\n        r = m\n      else:\n        l = m + 1\n\n    return sign * l\n", "tests": {"21": "def test_kthSmallestProduct(self):\n    nums1 = [-2, -3, 0]\n    nums2 = [0, 0]\n    k = 5\n    expected_result = 18\n    self.assertEqual(self.solution.kthSmallestProduct(nums1, nums2, k), expected_result)", "22": "def test_kthSmallestProduct():\n    solution = Solution()\n    assert solution.kthSmallestProduct([2, -3, 0], [1, -5, -7], 5) == -21", "24": "def test_kthSmallestProduct():\n\n    class Solution:\n\n        def kthSmallestProduct(self, nums1, nums2, k):\n            A1 = [-num for num in nums1 if num < 0][::-1]\n            A2 = [num for num in nums1 if num >= 0]\n            B1 = [-num for num in nums2 if num < 0][::-1]\n            B2 = [num for num in nums2 if num >= 0]\n            negCount = len(A1) * len(B2) + len(A2) * len(B1)\n            if k > negCount:\n                k -= negCount\n                sign = 1\n            else:\n                assert k == negCount - k\n\n            def numProductNoGreaterThan(A, B, m):\n                ans = 0\n                j = len(B) - 1\n                for i in range(len(A)):\n                    while j >= 0 and A[i] * B[j] > m:\n                        j -= 1\n                    ans += j + 1\n                return ans\n            l = 0\n            r = 10 ** 10\n            while l < r:\n                m = (l + r) // 2\n                if numProductNoGreaterThan(A1, B1, m) + numProductNoGreaterThan(A2, B2, m) >= k:\n                    r = m\n                else:\n                    l = m + 1\n            return sign * l\n    solution = Solution()\n    nums1 = [-5, -3, 0]\n    nums2 = [0, 10]\n    k = 9\n    print(solution.kthSmallestProduct(nums1, nums2, k))", "25": "def test_kthSmallestProduct(self):\n    solution = Solution()\n    self.assertEqual(solution.kthSmallestProduct([5, 10, -100], [2, 4, 3.5], 7), -30000)", "26": "def test_kthSmallestProduct(self):\n\n    class Solution:\n\n        def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int) -> int:\n            A1 = [-num for num in [4, 5] if num < 0][::-1]\n            B1 = [-num for num in [3, -2] if num < 0][::-1]\n            B2 = [num for num in [3, -2] if num >= 0]\n            negCount = len(A1) * len(B2) + len((A2 := [4, 5])) * len(B1)\n            if k > negCount:\n                k -= negCount\n                sign = 1\n            else:\n                k = negCount - k + 1\n                sign = -1\n                (B1, B2) = (B2, B1)\n\n            def numProductNoGreaterThan(A: List[int], B: List[int], m: int) -> int:\n                ans = 0\n                j = len(B) - 1\n                for i in range(len(A)):\n                    while j >= 0 and A[i] * B[j] > m:\n                        j -= 1\n                    ans += j + 1\n                return ans\n            l = 0\n            r = 10 ** 10\n            while l < r:\n                m = (l + r) // 2\n                if numProductNoGreaterThan(A1, B1, m) + numProductNoGreaterThan(A2, B2, m) >= k:\n                    r = m\n                else:\n                    l = m + 1\n            return sign * l\n    solution = Solution()\n    self.assertEqual(solution.kthSmallestProduct([4, 5], [3, -2], 7), -12)", "43": "def test_kthSmallestProduct(self):\n    def test1(nums1, nums2, k):", "45": "def test_kthSmallestProduct(self):\n    solution = Solution()\n    nums1 = [-10, -5, 0, 3]\n    nums2 = [0, 6, 8, 20]\n    k = 4\n    self.assertEqual(solution.kthSmallestProduct(nums1, nums2, k), -400)"}}
{"task_num": 2045, "task_title": "Second Minimum Time to Reach Destination", "func_name": "secondMinimum", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\n    graph = [[] for _ in range(n + 1)]\n    q = collections.deque([(1, 0)])\n    minTime = [[math.inf] * 2 for _ in range(n + 1)]\n    minTime[1][0] = 0\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    while q:\n      i, prevTime = q.popleft()\n\n      numChangeSignal = prevTime // change\n      waitTime = change - (prevTime % change) if numChangeSignal & 1 else 0\n      newTime = prevTime + waitTime + time\n      for j in graph[i]:\n        if newTime < minTime[j][0]:\n          minTime[j][0] = newTime\n          q.append((j, newTime))\n        elif minTime[j][0] < newTime < minTime[j][1]:\n          if j == n:\n            return newTime\n          minTime[j][1] = newTime\n          q.append((j, newTime))\n", "tests": {"30": "def test_secondMinimum():\n\n    class Solution:\n\n        def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\n            graph = [[] for _ in range(n + 1)]\n            q = collections.deque([(1, 0)])\n            minTime = [[math.inf] * 2 for _ in range(n + 1)]\n            minTime[1][0] = 0\n            for (u, v) in edges:\n                graph[u].append(v)\n                graph[v].append(u)\n            while q:\n                (i, prevTime) = q.popleft()\n                numChangeSignal = prevTime // change\n                waitTime = change - prevTime % change if numChangeSignal & 1 else 0\n                newTime = prevTime + waitTime + time\n                for j in graph[i]:\n                    if newTime < minTime[j][0]:\n                        minTime[j][0] = newTime\n                        q.append((j, newTime))\n                    elif minTime[j][0] < newTime < minTime[j][1]:\n                        if j == n:\n                            return newTime\n                        minTime[j][1] = newTime\n                        q.append((j, newTime))\n    solution = Solution()\n    edges = [[1, 2], [1, 3], [2, 3]]\n    print(solution.secondMinimum(4, edges, 2, 1))", "31": "def test_secondMinimum():\n\n    def helper(n, edges, time, change):\n        graph = [[] for _ in range(n + 1)]\n        q = collections.deque([(1, 0)])\n        minTime = [[float('inf')] * 2 for _ in range(n + 1)]\n        minTime[1][0] = 0\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        while q:\n            (i, prevTime) = q.popleft()\n            numChangeSignal = prevTime // change\n            waitTime = change - prevTime % change if numChangeSignal & 1 else 0\n            newTime = prevTime + waitTime + time\n            for j in graph[i]:\n                if newTime < minTime[j][0]:\n                    minTime[j][0] = newTime\n                    q.append((j, newTime))\n                elif minTime[j][0] < newTime < minTime[j][1]:\n                    if j == n:\n                        return newTime\n                    minTime[j][1] = newTime\n                    q.append((j, newTime))\n        assert len(minTime[n]) > 2, 'Second minimum time is not found'\n        secondMinTime = sorted(minTime[n])[2]\n        return secondMinTime\n    solution = Solution()\n    edges = [[1, 2], [1, 3], [2, 3]]\n    print(solution.secondMinimum(3, edges, 2, 1))", "33": "def test_secondMinimum():\n    solution = Solution()", "34": "def test_secondMinimum(self):\n\n    class Solution:\n\n        def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\n            graph = [[] for _ in range(n + 1)]\n            q = collections.deque([(1, 0)])\n            minTime = [[math.inf] * 2 for _ in range(n + 1)]\n            minTime[1][0] = 0\n            for (u, v) in edges:\n                graph[u].append(v)\n                graph[v].append(u)\n            while q:\n                (i, prevTime) = q.popleft()\n                numChangeSignal = prevTime // change\n                waitTime = change - prevTime % change if numChangeSignal & 1 else 0\n                newTime = prevTime + waitTime + time\n                for j in graph[i]:\n                    if newTime < minTime[j][0]:\n                        minTime[j][0] = newTime\n                        q.append((j, newTime))\n                    elif minTime[j][0] < newTime < minTime[j][1]:\n                        if j == n:\n                            return newTime\n                        minTime[j][1] = newTime\n                        q.append((j, newTime))\n    solution = Solution()\n    self.assertEqual(solution.secondMinimum(2, [[1, 2]], 3, 2), 7)", "35": "def test_secondMinimum():\n    solution = Solution()", "36": "def test_secondMinimum(self):\n\n    class Solution:\n\n        def secondMinimum(self, n: int, edges: list[list[int]], time: int, change: int) -> int:\n            graph = [[] for _ in range(n + 1)]\n            q = collections.deque([(1, 0)])\n            minTime = [[float('inf')] * 2 for _ in range(n + 1)]\n            minTime[1][0] = 0\n            for (u, v) in edges:\n                graph[u].append(v)\n                graph[v].append(u)\n            while q:\n                (i, prevTime) = q.popleft()\n                numChangeSignal = prevTime // change\n                waitTime = change - prevTime % change if numChangeSignal & 1 else 0\n                newTime = prevTime + waitTime + time\n                for j in graph[i]:\n                    if newTime < minTime[j][0]:\n                        minTime[j][0] = newTime\n                        q.append((j, newTime))\n                    elif minTime[j][0] < newTime < minTime[j][1]:\n                        if j == n:\n                            return newTime\n                        minTime[j][1] = newTime\n                        q.append((j, newTime))\n    solution = Solution()\n    self.assertEqual(solution.secondMinimum(3, [[2, 1], [3, 1]], 2, 1), 4)"}}
{"task_num": 2059, "task_title": "Minimum Operations to Convert Number", "func_name": "minimumOperations", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\n    ans = 0\n    q = collections.deque([start])\n    seen = {start}\n\n    while q:\n      ans += 1\n      for _ in range(len(q)):\n        x = q.popleft()\n        for num in nums:\n          for res in (x + num, x - num, x ^ num):\n            if res == goal:\n              return ans\n            if res < 0 or res > 1000 or res in seen:\n              continue\n            seen.add(res)\n            q.append(res)\n\n    return -1\n", "tests": {"24": "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations([3, 2], 0, 6) == 1, 'Test case failed'", "26": "def test_minimumOperations():\n\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\n        ans = 0\n        q = collections.deque([start])\n        seen = {start}\n        while q:\n            ans += 1\n            for _ in range(len(q)):\n                x = q.popleft()\n                for num in nums:\n                    for res in (x + num, x - num, x ^ num):\n                        if res == goal:\n                            return ans\n                        if res < 0 or res > 1000 or res in seen:\n                            continue\n                        seen.add(res)\n                        q.append(res)\n        return -1\n    solution = Solution()\n    print(solution.minimumOperations([3, 2], 0, 4))"}}
{"task_num": 2076, "task_title": "Process Restricted Friend Requests", "func_name": "friendRequests", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\n    ans = []\n    uf = UnionFind(n)\n\n    for u, v in requests:\n      pu = uf.find(u)\n      pv = uf.find(v)\n      isValid = True\n      if pu != pv:\n        for x, y in restrictions:\n          px = uf.find(x)\n          py = uf.find(y)\n          if (pu, pv) in [(px, py), (py, px)]:\n            isValid = False\n            break\n      ans.append(isValid)\n      if isValid:\n        uf.unionByRank(pu, pv)\n\n    return ans\n", "tests": {"20": "def test_friendRequests():\n\n    def mock_friendRequests(n, restrictions, requests):\n\n        class Solution:\n\n            def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\n                ans = []\n                uf = UnionFind(n)\n                for (u, v) in requests:\n                    pu = uf.find(u)\n                    pv = uf.find(v)\n                    isValid = True\n                    if pu != pv:\n                        for (x, y) in restrictions:\n                            px = uf.find(x)\n                            py = uf.find(y)\n                            if (pu, pv) in [(px, py), (py, px)]:\n                                isValid = False\n                                break\n                    ans.append(isValid)\n                    if isValid:\n                        uf.unionByRank(pu, pv)\n                return ans\n        result = Solution().friendRequests(n, restrictions, requests)\n        return result\n    solution = Solution()\n    print(mock_friendRequests(2, [[1, 0]], [[1, 0]]))", "22": "def test_friendRequests():\n    n = 4\n    restrictions = [[0, 2], [1, 3]]\n    requests = [[0, 1], [1, 2], [2, 3]]\n    print(solution.friendRequests(n, restrictions, requests))", "24": "def test_friendRequests(self):\n    n = 6\n    restrictions = [[3, 6], [4, 5]]\n    requests = [[0, 1], [1, 2], [2, 3], [3, 4], [1, 4], [1, 5]]\n    solution = Solution()\n    self.assertEqual(solution.friendRequests(n, restrictions, requests), [True, True, False, True, False, True])", "26": "def test_friendRequests():\n\n    class Solution:\n\n        def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\n            ans = []\n            uf = UnionFind(n)\n            for (u, v) in requests:\n                pu = uf.find(u)\n                pv = uf.find(v)\n                isValid = True\n                if pu != pv:\n                    for (x, y) in restrictions:\n                        px = uf.find(x)\n                        py = uf.find(y)\n                        if (pu, pv) in [(px, py), (py, px)]:\n                            isValid = False\n                            break\n                ans.append(isValid)\n                if isValid:\n                    uf.unionByRank(pu, pv)\n            return ans\n    solution = Solution()\n    n = 4\n    restrictions = [[0, 1], [2, 3]]\n    requests = [[0, 2], [3, 1]]\n    print(solution.friendRequests(n, restrictions, requests))", "27": "def test_friendRequests(self):\n    n = 5\n    restrictions = [[0, 2], [1, 3]]\n    requests = [[0, 4], [1, 2], [3, 4]]\n    self.assertEqual(solution.friendRequests(n, restrictions, requests), [True, True, False])", "31": "def test_friendRequests(self):\n\n    class Solution:\n\n        def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\n            ans = []\n            uf = UnionFind(n)\n            for (u, v) in requests:\n                pu = uf.find(u)\n                pv = uf.find(v)\n                if pu != pv:\n                    isValid = True\n                    for (x, y) in restrictions:\n                        px = uf.find(x)\n                        py = uf.find(y)\n                        if (pu, pv) in [(px, py), (py, px)]:\n                            isValid = False\n                            break\n                    ans.append(isValid)\n                    if isValid:\n                        uf.unionByRank(pu, pv)\n            return ans\n\n    class UnionFind:\n\n        def __init__(self, n: int):\n            self.id = list(range(n))\n            self.rank = [0] * n\n\n        def unionByRank(self, u: int, v: int) -> None:\n            i = self.find(u)\n            j = self.find(v)\n            if i == j:\n                return\n            if self.rank[i] < self.rank[j]:\n                self.id[i] = j\n            elif self.rank[i] > self.rank[j]:\n                self.id[j] = i\n            else:\n                self.id[i] = j\n                self.rank[j] += 1\n\n        def find(self, u: int) -> int:\n            if self.id[u] != u:\n                self.id[u] = self.find(self.id[u])\n            return self.id[u]\n    n = 4\n    restrictions = [[0, 2], [1, 3]]\n    requests = [[0, 2], [1, 3], [0, 2], [1, 3]]\n    solution = Solution()\n    result = solution.friendRequests(n, restrictions, requests)", "45": "def test_friendRequests(self):\n\n    class Solution:\n\n        def friendRequests(self, n: int, restrictions: list[list[int]], requests: list[list[int]]) -> list[bool]:\n            ans = []\n            uf = UnionFind(n)\n            for (u, v) in requests:\n                pu = uf.find(u)\n                pv = uf.find(v)\n                isValid = True\n                if pu != pv:\n                    for (x, y) in restrictions:\n                        px = uf.find(x)\n                        py = uf.find(y)\n                        if (pu, pv) in [(px, py), (py, px)]:\n                            isValid = False\n                            break\n                ans.append(isValid)\n                if isValid:\n                    uf.unionByRank(pu, pv)\n            return ans\n\n    class UnionFind:\n\n        def __init__(self, n: int):\n            self.id = list(range(n))\n            self.rank = [0] * n\n\n        def unionByRank(self, u: int, v: int) -> None:\n            i = self.find(u)\n            j = self.find(v)\n            if i == j:\n                return\n            if self.rank[i] < self.rank[j]:\n                self.id[i] = j\n            elif self.rank[i] > self.rank[j]:\n                self.id[j] = i\n            else:\n                self.id[i] = j\n                self.rank[j] += 1\n\n        def find(self, u: int) -> int:\n            if self.id[u] != u:\n                self.id[u] = self.find(self.id[u])\n            return self.id[u]\n    solution = Solution()\n    n = 5\n    restrictions = [[0, 1], [2, 3]]\n    requests = [[0, 4], [1, 2], [3, 4]]\n    self.assertEqual(solution.friendRequests(n, restrictions, requests), [True, False, True])", "46": "def test_friendRequests(self):\n\n    class Solution:\n\n        def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\n            ans = []\n            uf = UnionFind(n)\n            for (u, v) in requests:\n                pu = uf.find(u)\n                pv = uf.find(v)\n                isValid = True\n                if pu != pv:\n                    for (x, y) in restrictions:\n                        px = uf.find(x)\n                        py = uf.find(y)\n                        if (pu, pv) in [(px, py), (py, px)]:\n                            isValid = False\n                            break\n                ans.append(isValid)\n                if isValid:\n                    uf.unionByRank(pu, pv)\n            return ans\n\n    class UnionFind:\n\n        def __init__(self, n: int):\n            self.id = list(range(n))\n            self.rank = [0] * n\n\n        def unionByRank(self, u: int, v: int) -> None:\n            i = self.find(u)\n            j = self.find(v)\n            if i == j:\n                return\n            if self.rank[i] < self.rank[j]:\n                self.id[i] = j\n            elif self.rank[i] > self.rank[j]:\n                self.id[j] = i\n            else:\n                self.id[i] = j\n                self.rank[j] += 1\n\n        def find(self, u: int) -> int:\n            if self.id[u] != u:\n                self.id[u] = self.find(self.id[u])\n            return self.id[u]\n    solution = Solution()\n    n = 5\n    restrictions = [[0, 1], [2, 3]]\n    requests = [[0, 2], [4, 0], [4, 1], [1, 3]]\n    result = [True, True, False, False]\n    self.assertEqual(solution.friendRequests(n, restrictions, requests), result)", "47": "def test_friendRequests(self):\n\n    class Solution:\n\n        def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\n            ans = []\n            uf = UnionFind(n)\n            for (u, v) in requests:\n                pu = uf.find(u)\n                pv = uf.find(v)\n                isValid = True\n                if pu != pv:\n                    for (x, y) in restrictions:\n                        px = uf.find(x)\n                        py = uf.find(y)\n                        if (pu, pv) in [(px, py), (py, px)]:\n                            isValid = False\n                            break\n                ans.append(isValid)\n                if isValid:\n                    uf.unionByRank(pu, pv)\n            return ans\n\n    class UnionFind:\n\n        def __init__(self, n: int):\n            self.id = list(range(n))\n            self.rank = [0] * n\n\n        def unionByRank(self, u: int, v: int) -> None:\n            i = self.find(u)\n            j = self.find(v)\n            if i == j:\n                return\n            if self.rank[i] < self.rank[j]:\n                self.id[i] = j\n            elif self.rank[i] > self.rank[j]:\n                self.id[j] = i\n            else:\n                self.id[i] = j\n                self.rank[j] += 1\n\n        def find(self, u: int) -> int:\n            if self.id[u] != u:\n                self.id[u] = self.find(self.id[u])\n            return self.id[u]\n    solution = Solution()\n    n = 5\n    restrictions = [[0, 3], [4, 2]]\n    requests = [[1, 2], [3, 4], [1, 4]]\n    result = solution.friendRequests(n, restrictions, requests)", "48": "def test_friendRequests():\n\n    def helper(n, restrictions, requests):\n        import itertools\n        unionfind = UnionFind(n)\n        for request in requests:\n            (u, v) = request\n            pu = unionfind.find(u)\n            pv = unionfind.find(v)\n            if pu != pv:\n                isValid = True\n                for (x, y) in restrictions:\n                    px = unionfind.find(x)\n                    py = unionfind.find(y)\n                    if (pu, pv) == (px, py):\n                        isValid = False\n                        break\n                if not isValid:\n                    return False\n            if pu != pv:\n                unionfind.unionByRank(pu, pv)\n        return True\n    solution = Solution()\n    print(helper(4, [[0, 1], [2, 3]], [[0, 1]]))", "49": "    def test_friendRequests(self):\n        n = 3\n        restrictions = [[0,1]]\n        requests = [[0,2],[1,2]]\n        self.assertEqual(Solution().friendRequests(n, restrictions, requests), [False,True])\n\nif __name__ == '__main__':\n    unittest.main()", "50": "    def test_friendRequests(self):\n        n = 3\n        restrictions = [[0,1],[2,0]]\n        requests = [[0,2],[1,2]]\n        self.assertEqual(\n            Solution().friendRequests(n, restrictions, requests),\n            [False,True]\n        )\n", "53": "def test_friendRequests(self):\n\n    class Solution:\n\n        def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\n            ans = []\n            uf = UnionFind(n)\n            for (u, v) in requests:\n                pu = uf.find(u)\n                pv = uf.find(v)\n                isValid = True\n                if pu != pv:\n                    for (x, y) in restrictions:\n                        px = uf.find(x)\n                        py = uf.find(y)\n                        if (pu, pv) in [(px, py), (py, px)]:\n                            isValid = False\n                            break\n                ans.append(isValid)\n                if isValid:\n                    uf.unionByRank(pu, pv)\n            return ans\n\n    class UnionFind:\n\n        def __init__(self, n: int):\n            self.id = list(range(n))\n            self.rank = [0] * n\n\n        def unionByRank(self, u: int, v: int) -> None:\n            i = self.find(u)\n            j = self.find(v)\n            if i == j:\n                return\n            if self.rank[i] < self.rank[j]:\n                self.id[i] = j\n            elif self.rank[i] > self.rank[j]:\n                self.id[j] = i\n            else:\n                self.id[i] = j\n                self.rank[j] += 1\n\n        def find(self, u: int) -> int:\n            if self.id[u] != u:\n                self.id[u] = self.find(self.id[u])\n            return self.id[u]\n    solution = Solution()\n    restrictions = [[0, 4], [6, 8]]\n    requests = [[0, 2], [1, 3], [1, 5]]\n    result = solution.friendRequests(9, restrictions, requestsWith=[requests[0]])"}}
{"task_num": 2086, "task_title": "Minimum Number of Food Buckets to Feed the Hamsters", "func_name": "minimumBuckets", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumBuckets(self, street: str) -> int:\n    A = list(street)\n\n    for i, c in enumerate(A):\n      if c == 'H':\n        if i > 0 and A[i - 1] == 'B':\n          continue\n        if i + 1 < len(A) and A[i + 1] == '.':\n          A[i + 1] = 'B'\n        elif i > 0 and A[i - 1] == '.':\n          A[i - 1] = 'B'\n        else:\n          return -1\n\n    return A.count('B')\n", "tests": {"17": "def test_minimumBuckets():\n\n    class Solution:\n\n        def minimumBuckets(self, street):\n            A = list(street)\n            for (i, c) in enumerate(A):\n                if c == 'H':\n                    if i > 0 and A[i - 1] == '.':\n                        return -1\n                    elif i + 1 < len(A) and A[i + 1] == '.':\n                        A[i + 1] = 'B'\n                    else:\n                        return -1\n            return A.count('B')\n    solution = Solution()\n    assert solution.minimumBuckets('...H.H.') == -1, 'Test case failed'", "18": "def test_minimumBuckets():\n\n    class Solution:\n\n        def minimumBuckets(self, street):\n            A = list(street)\n            for (i, c) in enumerate(A):\n                if c == 'H':\n                    if i > 0 and A[i - 1] == 'B':\n                        continue\n                    if i + 1 < len(A) and A[i + 1] == '.':\n                        A[i + 1] = 'B'\n                    elif i > 0 and A[i - 1] == '.':\n                        A[i - 1] = 'B'\n                    else:\n                        return -1\n            return A.count('B')\n    solution = Solution()\n    print(solution.minimumBuckets('H.B'))", "19": "def test_minimumBuckets():\n\n    class Solution:\n\n        def minimumBuckets(self, street: str) -> int:\n            A = list(street)\n            for (i, c) in enumerate(A):\n                if c == 'H':\n                    if i > 0 and A[i - 1] == 'B':\n                        continue\n                    if i + 1 < len(A) and A[i + 1] == '.':\n                        A[i + 1] = 'B'\n                    elif i > 0 and A[i - 1] == '.':\n                        A[i - 1] = 'B'\n                    else:\n                        return -1\n            return A.count('B')\n    solution = Solution()\n    assert solution.minimumBuckets('H.B') == 2", "20": "def test_minimumBuckets():\n\n    def minimumBuckets(street):\n        A = list(street)\n        for (i, c) in enumerate(A):\n            if c == 'H':\n                if i > 0 and A[i - 1] == 'B':\n                    continue\n                if i + 1 < len(A) and A[i + 1] == '.':\n                    A[i + 1] = 'B'\n                elif i > 0 and A[i - 1] == '.':\n                    A[i - 1] = 'B'\n                else:\n                    return -1\n        return A.count('B')\n    solution = Solution()\n    assert minimumBuckets('H.B') == 1", "21": "def test_minimumBuckets():\n\n    class Solution:\n\n        def minimumBuckets(self, street):\n            A = list(street)\n            for (i, c) in enumerate(A):\n                if c == 'H':\n                    if i > 0 and A[i - 1] == 'B':\n                        continue\n                    if i + 1 < len(A) and A[i + 1] == '.':\n                        A[i + 1] = 'B'\n                    elif i > 0 and A[i - 1] == '.':\n                        A[i - 1] = 'B'\n                    else:\n                        return -1\n            return A.count('B')\n    solution = Solution()\n    assert solution.minimumBuckets('HB.B') == 2, f\"Expected 2, got {solution.minimumBuckets('HB.B')}\"", "22": "def test_minimumBuckets():\n    solution = Solution()\n    print(solution.minimumBuckets('...HH.H'))", "24": "def test_minimumBuckets():\n\n    class Solution:\n\n        def minimumBuckets(self, street: str) -> int:\n            A = list(street)\n            for (i, c) in enumerate(A):\n                if c == 'H':\n                    if i > 0 and A[i - 1] == 'B':\n                        continue\n                    if i + 1 < len(A) and A[i + 1] == '.':\n                        A[i + 1] = 'B'\n                    elif i > 0 and A[i - 1] == '.':\n                        A[i - 1] = 'B'\n                    else:\n                        return -1\n            return A.count('B')\n    solution = Solution()\n    print(solution.minimumBuckets('...H..'))"}}
{"task_num": 2092, "task_title": "Find All People With Secret", "func_name": "findAllPeople", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def connected(self, u: int, v: int) -> bool:\n    return self._find(self.id[u]) == self._find(self.id[v])\n\n  def reset(self, u: int) -> None:\n    self.id[u] = u\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\n    uf = UnionFind(n)\n    timeToPairs = collections.defaultdict(list)\n\n    uf.unionByRank(0, firstPerson)\n\n    for x, y, time in meetings:\n      timeToPairs[time].append((x, y))\n\n    for _, pairs in sorted(timeToPairs.items(), key=lambda x: x[0]):\n      peopleUnioned = set()\n      for x, y in pairs:\n        uf.unionByRank(x, y)\n        peopleUnioned.add(x)\n        peopleUnioned.add(y)\n      for person in peopleUnioned:\n        if not uf.connected(person, 0):\n          uf.reset(person)\n\n    res=[]\n    for i in range(n):\n      if uf.connected(i, 0):\n        res.append(i)\n    return res\n", "tests": {"20": "def test_findAllPeople(self):\n    n = 5\n    meetings = [[1, 2, 3], [3, 4, 3]]\n    firstPerson = 0\n    expected_output = [0, 1, 2, 3, 4]\n    self.assertEqual(solution.findAllPeople(n, meetings, firstPerson), expected_output)", "22": "def test_findAllPeople():\n\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\n        uf = UnionFind(n)\n        timeToPairs = collections.defaultdict(list)\n        uf.unionByRank(0, firstPerson)\n        for (x, y, time) in meetings:\n            timeToPairs[time].append((x, y))\n        for (_, pairs) in sorted(timeToPairs.items(), key=lambda x: x[0]):\n            peopleUnioned = set()\n            for (x, y) in pairs:\n                uf.unionByRank(x, y)\n                peopleUnioned.add(x)\n                peopleUnioned.add(y)\n            for person in peopleUnioned:\n                if not uf.connected(person, 0):\n                    uf.reset(person)\n        res = []\n        for i in range(n):\n            if uf.connected(i, 0):\n                res.append(i)\n        return res\n    solution = Solution()\n    meetings = [[1, 2, 3], [1, 2, 4], [2, 3, 4]]\n    result = solution.findAllPeople(4, meetings, 1)", "24": "def test_findAllPeople(self):\n    n = 5\n    meetings = [[0, 1, 3], [2, 3, 4]]\n    firstPerson = 2\n    res = [0, 1, 2, 3]\n    self.assertEqual(solution.findAllPeople(n, meetings, firstPerson), res)", "26": "def test_findAllPeople(self):\n    solution = Solution()\n    n = 4\n    meetings = [[1, 2, 3], [0, 2, 3]]\n    firstPerson = 2\n    self.assertEqual(solution.findAllPeople(n, meetings, firstPerson), [0, 1, 2])", "27": "def test_findAllPeople():\n\n    def _makeMeetings(n):\n        meetings = []\n        for i in range(1, n):\n            meetings.append([0, i, 1])\n        return meetings\n    solution = Solution()\n    res = solution.findAllPeople(3, _makeMeetings(3), 2)", "37": "def test_findAllPeople(self):\n    solution = Solution()\n    n = 5\n    meetings = [[0, 2, 1], [3, 4, 1]]\n    firstPerson = 2\n    self.assertEqual(solution.findAllPeople(n, meetings, firstPerson), [0, 1, 2, 3, 4])", "59": "def test_findAllPeople(self):\n    n = 5\n    meetings = [[0, 1, 2], [1, 3, 4]]\n    firstPerson = 1\n    expected = [0, 1]\n    self.assertEqual(solution.findAllPeople(n, meetings, firstPerson), expected)", "64": "def test_findAllPeople():\n    solution = Solution()\n\n    def assert_equal(actual, expected):\n        if actual != expected:\n            raise AssertionError(f'Expected {expected}, but got {actual}')\n    meetings = [[1, 2, 5], [0, 3, 6]]\n    assert_equal(solution.findAllPeople(4, meetings, 1), [0, 1, 3])"}}
{"task_num": 2115, "task_title": "Find All Possible Recipes from Given Supplies", "func_name": "findAllRecipes", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n    ans = []\n    supplies = set(supplies)\n    graph = collections.defaultdict(list)\n    inDegrees = collections.Counter()\n    q = collections.deque()\n\n    for i, recipe in enumerate(recipes):\n      for ingredient in ingredients[i]:\n        if ingredient not in supplies:\n          graph[ingredient].append(recipe)\n          inDegrees[recipe] += 1\n\n    for recipe in recipes:\n      if inDegrees[recipe] == 0:\n        q.append(recipe)\n\n    while q:\n      u = q.popleft()\n      ans.append(u)\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    return ans\n", "tests": {"22": "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['eggs', 'flour']\n    ingredients = [['milk', 'cups'], ['cups']]\n    supplies = ['eggs', 'flour']\n    expected_output = ['eggs', 'flour']\n    result = solution.findAllRecipes(recipes, ingredients, supplies)", "23": "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['eggdrop', 'oatmeal']\n    ingredients = [['eggs', 'water'], ['flour']]\n    supplies = ['eggs', 'water']\n    expected_output = ['eggdrop', 'oatmeal']\n    assert solution.findAllRecipes(recipes, ingredients, supplies) == expected_output", "27": "def test_findAllRecipes(self):\n\n    class Solution:\n\n        def findAllRecipes(self, recipes, ingredients, supplies):\n            ans = []\n            supplies = set(supplies)\n            graph = collections.defaultdict(list)\n            inDegrees = collections.Counter()\n            q = collections.deque()\n            for (i, recipe) in enumerate(recipes):\n                for ingredient in ingredients[i]:\n                    if ingredient not in supplies:\n                        graph[ingredient].append(recipe)\n                        inDegrees[recipe] += 1\n            for recipe in recipes:\n                if inDegrees[recipe] == 0 and len(inDegrees) > 0:\n                    q.append(recipe)\n            while q:\n                u = q.popleft()\n                ans.append(u)\n                for v in graph[u]:\n                    inDegrees[v] -= 1\n                    if inDegrees[v] == 0:\n                        q.append(v)\n            return ans\n    solution = Solution()\n    recipes = ['Banana', 'Apple', 'orange']\n    ingredients = [['Sugar', 'Banana'], ['Apple'], ['Orange']]\n    supplies = ['Sugar', 'Apple', 'Orange']\n    self.assertEqual(solution.findAllRecipes(recipes, ingredients, supplies), ['Banana', 'Apple', 'orange'])", "35": "def test_findAllRecipes():\n\n    def findAllRecipes(recipes, ingredients, supplies):\n        ans = []\n        supplies = set(supplies)\n        graph = collections.defaultdict(list)\n        inDegrees = collections.Counter()\n        q = collections.deque()\n        for (i, recipe) in enumerate(recipes):\n            for ingredient in ingredients[i]:\n                if ingredient not in supplies:\n                    graph[ingredient].append(recipe)\n                    inDegrees[recipe] += 1\n        for recipe in recipes:\n            if inDegrees[recipe] == 0:\n                q.append(recipe)\n        while q:\n            u = q.popleft()\n            ans.append(u)\n            for v in graph[u]:\n                inDegrees[v] -= 1\n                if inDegrees[v] == 0:\n                    q.append(v)\n                elif inDegrees[v] < 0:\n                    return []\n        return ans\n    solution = Solution()\n    print(findAllRecipes(['bread', 'eggs'], [['flour', 'water'], [' flour ']], ['water', 'eggs', 'flour']))"}}
{"task_num": 2127, "task_title": "Maximum Employees to Be Invited to a Meeting", "func_name": "maximumInvitations", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import Enum\n\n\nclass State(Enum):\n  kInit = 0\n  kVisiting = 1\n  kVisited = 2\n\n\nclass Solution:\n  def maximumInvitations(self, favorite: List[int]) -> int:\n    n = len(favorite)\n    sumComponentsLength = 0\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n    maxChainLength = [1] * n\n\n    for i, f in enumerate(favorite):\n      graph[i].append(f)\n      inDegrees[f] += 1\n\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n\n    while q:\n      u = q.popleft()\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n        maxChainLength[v] = max(maxChainLength[v], 1 + maxChainLength[u])\n\n    for i in range(n):\n      if favorite[favorite[i]] == i:\n        sumComponentsLength += maxChainLength[i] + maxChainLength[favorite[i]]\n\n    maxCycleLength = 0\n    parent = [-1] * n\n    seen = set()\n    states = [State.kInit] * n\n\n    def findCycle(u: int) -> None:\n      nonlocal maxCycleLength\n      seen.add(u)\n      states[u] = State.kVisiting\n      for v in graph[u]:\n        if v not in seen:\n          parent[v] = u\n          findCycle(v)\n        elif states[v] == State.kVisiting:\n          curr = u\n          cycleLength = 1\n          while curr != v:\n            curr = parent[curr]\n            cycleLength += 1\n          maxCycleLength = max(maxCycleLength, cycleLength)\n      states[u] = State.kVisited\n\n    for i in range(n):\n      if i not in seen:\n        findCycle(i)\n\n    return max(sumComponentsLength // 2, maxCycleLength)\n", "tests": {"39": "    def test_maximumInvitations(self):\n        favorite = [1,0,2]\n        self.assertEqual(Solution().maximumInvitations(favorite), 3)\n\nif __name__ == '__main__':\n    unittest.main()", "44": "def test_maximumInvitations(self):\n    solution = Solution()\n    favorite = [0, 1, 2]\n    self.assertEqual(solution.maximumInvitations(favorite), 3)", "57": "def test_maximumInvitations(self):\n    n = 5\n    favorite = [3, 4, 1, 2]\n    self.assertEqual(solution.maximumInvitations(favorite), 6)", "58": "def test_maximumInvitations(self):\n\n    class Solution:\n\n        def maximumInvitations(self, favorite: List[int]) -> int:\n            n = len(favorite)\n            graph = [[] for _ in range(n)]\n            inDegrees = [0] * n\n            maxChainLength = [1] * n\n            for (i, f) in enumerate(favorite):\n                graph[i].append(f)\n                inDegrees[f] += 1\n            q = collections.deque([i for (i, d) in enumerate(inDegrees) if d == 0])\n            while q:\n                u = q.popleft()\n                for v in graph[u]:\n                    inDegrees[v] -= 1\n                    if inDegrees[v] == 0:\n                        q.append(v)\n                    maxChainLength[v] = max(maxChainLength[v], 1 + maxChainLength[u])\n            for i in range(n):\n                if favorite[favorite[i]] == i:\n                    sumComponentsLength += maxChainLength[i] + maxChainLength[favorite[i]]\n            maxCycleLength = 0\n            parent = [-1] * n\n\n            def findCycle(u: int) -> None:\n                nonlocal maxCycleLength\n                for v in graph[u]:\n                    if v not in seen and u != 5:\n                        parent[v] = u\n                        findCycle(v)\n                    elif states[v] == State.kVisiting:\n                        curr = u\n                        cycleLength = 1\n                        while curr != v:\n                            curr = parent[curr]\n                            cycleLength += 1\n                        maxCycleLength = max(maxCycleLength, cycleLength)\n            seen = set()\n            states = [State.kInit] * n\n            for i in range(n):\n                if i not in seen:\n                    findCycle(i)\n            return max(sumComponentsLength // 2, maxCycleLength)\n    solution = Solution()\n    favorite = [0, 1, 2, 3, 4]\n    self.assertEqual(solution.maximumInvitations(favorite), 5)", "60": "def test_maximumInvitations():\n\n    def generate_favorite(n):\n        favorite = list(range(1, n))\n        for i in range(n):\n            favorite[i] += 2\n        return favorite\n\n    class MockSolution:\n\n        def maximumInvitations(self, favorite):\n            max_cycle_length = 0\n            parent = [-1] * len(favorite)\n            seen = set()\n            states = [State.kInit] * len(favorite)\n\n            def findCycle(u: int) -> None:\n                nonlocal max_cycle_length\n                seen.add(u)\n                states[u] = State.kVisiting\n                for v in graph[u]:\n                    if v not in seen:\n                        parent[v] = u\n                        findCycle(v)\n                    elif states[v] == State.kVisiting:\n                        curr = u\n                        cycleLength = 1\n                        while curr != v:\n                            curr = parent[curr]\n                            cycleLength += 1\n                        max_cycle_length = max(max_cycle_length, cycleLength)\n                states[u] = State.kVisited\n            graph = [[] for _ in range(len(favorite))]\n            for (i, f) in enumerate(favorite):\n                graph[i].append(f)\n            for i in range(len(favorite)):\n                if i not in seen:\n                    findCycle(i)\n            return max(sumComponentsLength // 2, max_cycle_length)\n    solution = Solution()\n    favorite = generate_favorite(10)\n    result1 = solution.maximumInvitations(favorite)", "61": "def test_maximumInvitations(self):\n    class Solution:\n        def maximumInvitations(self, favorite: List[int]) -> int:\n            # function implementation here...\n\n    solution = Solution()\n    n = 5\n    favorite = [1,2,0,3,4]\n    self.assertEqual(solution.maximumInvitations(favorite), 7)", "62": "def test_maximumInvitations():\n\n    def findCycle(u: int) -> None:\n        nonlocal maxCycleLength\n        seen.add(u)\n        states[u] = State.kVisiting\n        for v in graph[u]:\n            if v not in seen:\n                parent[v] = u\n                findCycle(v)\n            elif states[v] == State.kVisiting:\n                curr = u\n                cycleLength = 1\n                while True:\n                    curr = parent[curr]\n                    cycleLength += 1\n                    if curr == v:\n                        break\n                maxCycleLength = max(maxCycleLength, cycleLength)\n        states[u] = State.kVisited\n    solution = Solution()\n    favorite = [0, 1, 2, 3, 4]\n    graph = [[1], [0, 2], [1], [3, 4], []]\n    inDegrees = [1, 0, 1, 0, 0]\n    maxChainLength = [1] * 5\n    seen = set()\n    states = [State.kInit] * 5\n    parent = [-1] * 5\n    maxCycleLength = 0\n    findCycle(0)\n    assert solution.maximumInvitations(favorite) == 8", "63": "def test_maximumInvitations():\n\n    class Solution:\n\n        def maximumInvitations(self, favorite: List[int]) -> int:\n            n = len(favorite)\n            graph = [[] for _ in range(n)]\n            inDegrees = [0] * n\n            for (i, f) in enumerate(favorite):\n                graph[i].append(f)\n                inDegrees[f] += 1\n            q = collections.deque([i for (i, d) in enumerate(inDegrees) if d == 0])\n            while q:\n                u = q.popleft()\n                for v in graph[u]:\n                    inDegrees[v] -= 1\n                    if inDegrees[v] == 0:\n                        q.append(v)\n\n            def findCycle(u: int) -> None:\n                nonlocal maxCycleLength\n                seen.add(u)\n                states[u] = State.kVisiting\n                for v in graph[u]:\n                    if v not in seen:\n                        parent[v] = u\n                        findCycle(v)\n                    elif states[v] == State.kVisiting:\n                        curr = u\n                        cycleLength = 1\n                        while curr != v and parent[curr] is not None:\n                            curr = parent[curr]\n                            cycleLength += 1\n                        maxCycleLength = max(maxCycleLength, cycleLength + 1)\n                states[u] = State.kVisited\n            for i in range(n):\n                if i not in seen:\n                    findCycle(i)\n            return max(sumComponentsLength // 2, maxCycleLength)\n    solution = Solution()\n    favorite = [0, 2, 0]\n    assert solution.maximumInvitations(favorite) == 3", "64": "def test_maximumInvitations():\n    solution = Solution()\n    favorite = [0, 2, 3, 4]\n    assert solution.maximumInvitations(favorite) == 6", "65": "def test_maximumInvitations():\n\n    class Solution:\n\n        def maximumInvitations(self, favorite):\n            n = len(favorite)\n            graph = [[] for _ in range(n)]\n            inDegrees = [0] * n\n            for (i, f) in enumerate(favorite):\n                graph[i].append(f)\n                inDegrees[f] += 1\n            q = collections.deque([i for (i, d) in enumerate(inDegrees) if d == 0])\n            while q:\n                u = q.popleft()\n                for v in graph[u]:\n                    inDegrees[v] -= 1\n                    if inDegrees[v] == 0:\n                        q.append(v)\n                    maxChainLength[v] = max(maxChainLength[v], 1 + maxChainLength[u])\n\n            def findCycle(u):\n                nonlocal maxCycleLength\n                seen.add(u)\n                states[u] = State.kVisiting\n                for v in graph[u]:\n                    if v not in seen:\n                        parent[v] = u\n                        findCycle(v)\n                    elif states[v] == State.kVisiting:\n                        curr = u\n                        cycleLength = 1\n                        while curr != v:\n                            curr = parent[curr]\n                            cycleLength += 1\n                        maxCycleLength = max(maxCycleLength, cycleLength)\n                states[u] = State.kVisited\n            for i in range(n):\n                if i not in seen:\n                    findCycle(i)\n            return max(sumComponentsLength // 2, maxCycleLength)\n    solution = Solution()\n    favorite = [1, 0, 2]\n    assert solution.maximumInvitations(favorite) == 3", "70": "def test_maximumInvitations():\n\n    class Solution:\n\n        def maximumInvitations(self, favorite: List[int]) -> int:\n            n = len(favorite)\n            sumComponentsLength = 0\n            graph = [[] for _ in range(n)]\n            inDegrees = [0] * n\n            maxChainLength = [1] * n\n            for (i, f) in enumerate(favorite):\n                graph[i].append(f)\n                inDegrees[f] += 1\n            q = collections.deque([i for (i, d) in enumerate(inDegrees) if d == 0])\n            while q:\n                u = q.popleft()\n                for v in graph[u]:\n                    inDegrees[v] -= 1\n                    if inDegrees[v] == 0:\n                        q.append(v)\n                    maxChainLength[v] = max(maxChainLength[v], 1 + maxChainLength[u])\n            for i in range(n):\n                if favorite[favorite[i]] == i:\n                    sumComponentsLength += maxChainLength[i] + maxChainLength[favorite[i]]\n            maxCycleLength = 0\n            parent = [-1] * n\n            seen = set()\n            states = [State.kInit] * n\n\n            def findCycle(u: int) -> None:\n                nonlocal maxCycleLength\n                seen.add(u)\n                states[u] = State.kVisiting\n                for v in graph[u]:\n                    if v not in seen:\n                        parent[v] = u\n                        findCycle(v)\n                    elif states[v] == State.kVisiting:\n                        curr = u\n                        cycleLength = 1\n                        while curr != v:\n                            curr = parent[curr]\n                            cycleLength += 1\n                        maxCycleLength = max(maxCycleLength, cycleLength)\n                states[u] = State.kVisited\n            for i in range(n):\n                if i not in seen:\n                    findCycle(i)\n            return max(sumComponentsLength // 2, maxCycleLength)\n    favorite = [0, 3, 1, 2]\n    assert Solution().maximumInvitations(favorite) == 5"}}
{"task_num": 2132, "task_title": "Stamping the Grid", "func_name": "possibleToStamp", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def possibleToStamp(self, grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:\n    m = len(grid)\n    n = len(grid[0])\n    A = [[0] * (n + 1) for _ in range(m + 1)]\n    B = [[0] * (n + 1) for _ in range(m + 1)]\n    fit = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        A[i + 1][j + 1] = A[i + 1][j] + A[i][j + 1] - A[i][j] + grid[i][j]\n        if i + 1 >= stampHeight and j + 1 >= stampWidth:\n          x = i - stampHeight + 1\n          y = j - stampWidth + 1\n          if A[i + 1][j + 1] - A[x][j + 1] - A[i + 1][y] + A[x][y] == 0:\n            fit[i][j] = True\n\n    for i in range(m):\n      for j in range(n):\n        B[i + 1][j + 1] = B[i + 1][j] + B[i][j + 1] - B[i][j] + fit[i][j]\n\n    for i in range(m):\n      for j in range(n):\n        if not grid[i][j]:\n          x = min(i + stampHeight, m)\n          y = min(j + stampWidth, n)\n          if B[x][y] - B[i][y] - B[x][j] + B[i][j] == 0:\n            return False\n\n    return True\n", "tests": {"23": "def test_possibleToStamp():\n\n    class Solution:\n\n        def possibleToStamp(self, grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:\n            m = len(grid)\n            n = len(grid[0])\n            A = [[0] * (n + 1) for _ in range(m + 1)]\n            B = [[0] * (n + 1) for _ in range(m + 1)]\n            fit = [[False] * n for _ in range(m)]\n            for i in range(m):\n                for j in range(n):\n                    A[i + 1][j + 1] = A[i + 1][j] + A[i][j + 1] - A[i][j] + grid[i][j]\n                    if i + 1 >= stampHeight and j + 1 >= stampWidth:\n                        x = i - stampHeight + 1\n                        y = j - stampWidth + 1\n                        if A[i + 1][j + 1] - A[x][j + 1] - A[i + 1][y] + A[x][y] == 0:\n                            fit[i][j] = True\n            for i in range(m):\n                for j in range(n):\n                    B[i + 1][j + 1] = B[i + 1][j] + B[i][j + 1] - B[i][j] + fit[i][j]\n            for i in range(m):\n                for j in range(n):\n                    if not grid[i][j]:\n                        x = min(i + stampHeight, m)\n                        y = min(j + stampWidth, n)\n                        if B[x][y] - B[i][y] - B[x][j] + B[i][j] == 0:\n                            return False\n            return True\n    solution = Solution()\n    grid = [[1, 0, 1], [0, 0, 1]]\n    stampHeight = 2\n    stampWidth = 2\n    assert solution.possibleToStamp(grid, stampHeight, stampWidth)", "24": "def test_possibleToStamp(self):\n    grid = [[0, 0, 0, 0], [0, 1, 1, 0], [0, 0, 1, 0]]\n    stampHeight = 3\n    stampWidth = 2\n    solution = Solution()\n    self.assertTrue(solution.possibleToStamp(grid, stampHeight, stampWidth))", "25": "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[0, 0, 1], [0, 0, 1]]\n    stampHeight = 2\n    stampWidth = 2\n    assert solution.possibleToStamp(grid, stampHeight, stampWidth)", "26": "def test_possibleToStamp():\n\n    class Solution:\n\n        def possibleToStamp(self, grid, stampHeight, stampWidth):\n            m = len(grid)\n            n = len(grid[0])\n            A = [[0] * (n + 1) for _ in range(m + 1)]\n            B = [[0] * (n + 1) for _ in range(m + 1)]\n            fit = [[False] * n for _ in range(m)]\n            for i in range(m):\n                for j in range(n):\n                    A[i + 1][j + 1] = A[i + 1][j] + A[i][j + 1] - A[i][j] + grid[i][j]\n                    if i + 1 >= stampHeight and j + 1 >= stampWidth:\n                        x = i - stampHeight + 1\n                        y = j - stampWidth + 1\n                        if A[i + 1][j + 1] - A[x][j + 1] - A[i + 1][y] + A[x][y] == 0:\n                            fit[i][j] = True\n            for i in range(m):\n                for j in range(n):\n                    B[i + 1][j + 1] = B[i + 1][j] + B[i][j + 1] - B[i][j] + fit[i][j]\n            for i in range(m):\n                for j in range(n):\n                    if not grid[i][j]:\n                        x = min(i + stampHeight, m)\n                        y = min(j + stampWidth, n)\n                        if B[x][y] - B[i][y] - B[x][j] + B[i][j] == 0:\n                            return False\n            return True\n    solution = Solution()\n    print(solution.possibleToStamp([[1, 0], [0, 1]], 2, 2))", "35": "def test_possibleToStamp():\n\n    class Solution:\n\n        def possibleToStamp(self, grid, stampHeight, stampWidth):\n            m = len(grid)\n            n = len(grid[0])\n            A = [[0] * (n + 1) for _ in range(m + 1)]\n            B = [[0] * (n + 1) for _ in range(m + 1)]\n            fit = [[False] * n for _ in range(m)]\n            for i in range(m):\n                for j in range(n):\n                    A[i + 1][j + 1] = A[i + 1][j] + A[i][j + 1] - A[i][j] + grid[i][j]\n                    if i + 1 >= stampHeight and j + 1 >= stampWidth:\n                        x = i - stampHeight + 1\n                        y = j - stampWidth + 1\n                        if A[i + 1][j + 1] - A[x][j + 1] - A[i + 1][y] + A[x][y] == 0:\n                            fit[i][j] = True\n            for i in range(m):\n                for j in range(n):\n                    B[i + 1][j + 1] = B[i + 1][j] + B[i][j + 1] - B[i][j] + fit[i][j]\n            grid[2:3, 2:4] = [[0, 0], [0, 0]]\n            m = len(grid)\n            n = len(grid[0])\n            A = [[0] * (n + 1) for _ in range(m + 1)]\n            B = [[0] * (n + 1) for _ in range(m + 1)]\n            fit = [[False] * n for _ in range(m)]\n            for i in range(m):\n                for j in range(n):\n                    A[i + 1][j + 1] = A[i + 1][j] + A[i][j + 1] - A[i][j] + grid[i][j]\n                    if i + 1 >= stampHeight and j + 1 >= stampWidth:\n                        x = i - stampHeight + 1\n                        y = j - stampWidth + 1\n                        if A[i + 1][j + 1] - A[x][j + 1] - A[i + 1][y] + A[x][y] == 0:\n                            fit[i][j] = True\n            for i in range(m):\n                for j in range(n):\n                    B[i + 1][j + 1] = B[i + 1][j] + B[i][j + 1] - B[i][j] + fit[i][j]", "36": "def test_possibleToStamp():\n\n    class Solution:\n\n        def possibleToStamp(self, grid, stampHeight, stampWidth):\n            m = len(grid)\n            n = len(grid[0])\n            A = [[0] * (n + 1) for _ in range(m + 1)]\n            B = [[0] * (n + 1) for _ in range(m + 1)]\n            fit = [[False] * n for _ in range(m)]\n            for i in range(m):\n                for j in range(n):\n                    A[i + 1][j + 1] = A[i + 1][j] + A[i][j + 1] - A[i][j] + grid[i][j]\n                    if i + 1 >= stampHeight and j + 1 >= stampWidth:\n                        x = i - stampHeight + 1\n                        y = j - stampWidth + 1\n                        if A[i + 1][j + 1] - A[x][j + 1] - A[i + 1][y] + A[x][y] == 0:\n                            fit[i][j] = True\n            for i in range(m):\n                for j in range(n):\n                    B[i + 1][j + 1] = B[i + 1][j] + B[i][j + 1] - B[i][j] + fit[i][j]\n            grid = [[0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]\n            stampHeight = 2\n            stampWidth = 3\n            for i in range(m):\n                for j in range(n):\n                    if not grid[i][j]:\n                        x = min(i + stampHeight, m)\n                        y = min(j + stampWidth, n)\n                        if B[x][y] - B[i][y] - B[x][j] + B[i][j] != 0:\n                            return False\n            return True\n    solution = Solution()\n    print(solution.possibleToStamp([[0, 1], [0, 0]], 2, 3))", "37": "def test_possibleToStamp():\n\n    class Solution:\n\n        def possibleToStamp(self, grid, stampHeight, stampWidth):\n            m = len(grid)\n            n = len(grid[0])\n            A = [[0] * (n + 1) for _ in range(m + 1)]\n            B = [[0] * (n + 1) for _ in range(m + 1)]\n            fit = [[False] * n for _ in range(m)]\n            for i in range(m):\n                for j in range(n):\n                    A[i + 1][j + 1] = A[i + 1][j] + A[i][j + 1] - A[i][j] + grid[i][j]\n                    if i + 1 >= stampHeight and j + 1 >= stampWidth:\n                        x = i - stampHeight + 1\n                        y = j - stampWidth + 1\n                        if A[i + 1][j + 1] - A[x][j + 1] - A[i + 1][y] + A[x][y] == 0:\n                            fit[i][j] = True\n            for i in range(m):\n                for j in range(n):\n                    B[i + 1][j + 1] = B[i + 1][j] + B[i][j + 1] - B[i][j] + fit[i][j]\n            for i in range(m):\n                for j in range(n):\n                    if not grid[i][j]:\n                        x = min(i + stampHeight, m)\n                        y = min(j + stampWidth, n)\n                        if B[x][y] - B[i][y] - B[x][j] + B[i][j] == 0:\n                            return False\n            return True\n    solution = Solution()\n    grid = [[1, 0], [0, 1]]\n    stampHeight = 2\n    stampWidth = 2\n    assert solution.possibleToStamp(grid, stampHeight, stampWidth) == True", "38": "def test_possibleToStamp():\n\n    class Solution:\n\n        def possibleToStamp(self, grid, stampHeight, stampWidth):\n            m = len(grid)\n            n = len(grid[0])\n            A = [[0] * (n + 1) for _ in range(m + 1)]\n            B = [[0] * (n + 1) for _ in range(m + 1)]\n            grid = [[0, 0, 1], [0, 0, 1], [0, 0, 0]]\n            return self.possibleToStamp(grid, stampHeight=2, stampWidth=2)\nsolution = Solution()\nprint(solution.possibleToStamp())"}}
{"task_num": 2146, "task_title": "K Highest Ranked Items Within a Price Range", "func_name": "highestRankedKItems", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    low, high = pricing\n    row, col = start\n    ans = []\n\n    if low <= grid[row][col] <= high:\n      ans.append([row, col])\n      if k == 1:\n        return ans\n\n    q = collections.deque([(row, col)])\n    seen = {(row, col)}\n\n    while q:\n      neighbors = []\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for t in range(4):\n          x = i + dirs[t][0]\n          y = j + dirs[t][1]\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if not grid[x][y] or (x, y) in seen:\n            continue\n          if low <= grid[x][y] <= high:\n            neighbors.append([x, y])\n          q.append((x, y))\n          seen.add((x, y))\n      neighbors.sort(key=lambda x: (grid[x[0]][x[1]], x[0], x[1]))\n      for neighbor in neighbors:\n        if len(ans) < k:\n          ans.append(neighbor)\n        if len(ans) == k:\n          return ans\n\n    return ans\n", "tests": {"21": "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[1, 0, 1], [0, 2, 3], [4, 5, 6]]\n    pricing = [2, 10]\n    start = [0, 0]\n    k = 1\n    result = solution.highestRankedKItems(grid, pricing, start, k)", "22": "def test_highestRankedKItems():\n\n    def highestRankedKItems(grid, pricing, start, k):\n        dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n        m = len(grid)\n        n = len(grid[0])\n        (low, high) = pricing\n        (row, col) = start\n        ans = []\n        if low <= grid[row][col] <= high:\n            ans.append([row, col])\n            if k == 1:\n                return ans\n        q = collections.deque([(row, col)])\n        seen = {(row, col)}\n        while q:\n            neighbors = []\n            for _ in range(len(q)):\n                (i, j) = q.popleft()\n                for t in range(4):\n                    x = i + dirs[t][0]\n                    y = j + dirs[t][1]\n                    if x < 0 or x == m or y < 0 or (y == n):\n                        continue\n                    if not grid[x][y] or (x, y) in seen:\n                        continue\n                    if low <= grid[x][y] <= high:\n                        neighbors.append([x, y])\n                    q.append((x, y))\n                    seen.add((x, y))\n            neighbors.sort(key=lambda x: (grid[x[0]][x[1]], x[0], x[1]))\n            for neighbor in neighbors:\n                if len(ans) < k:\n                    ans.append(neighbor)\n                if len(ans) == k:\n                    return ans\n        return ans\n    assert highestRankedKItems([[1, 0, 1], [1, 0, 1]], [1, 2], [0, 0], 1) == [[0, 0]]", "23": "def test_highestRankedKItems():\n    solution = Solution()\n\n    def assert_equals(expected, actual):\n        if expected != actual:\n            print(f'Expected: {expected}')\n            print(f'Actual: {actual}')\n            raise AssertionError", "36": "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[1, 0, 2], [3, 4, 5]]\n    pricing = [1, 10]\n    start = [1, 1]\n    k = 2\n\n    def check_output(output):\n        return output == [[1, 1], [0, 2]]\n    assert check_output(solution.highestRankedKItems(grid, pricing, start, k))", "38": "def test_highestRankedKItems():\n\n    class Solution:\n\n        def highestRankedKItems(self, grid, pricing, start, k):\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            m = len(grid)\n            n = len(grid[0])\n            (low, high) = pricing\n            (row, col) = start\n            if grid[row][col] not in [0, 1]:\n                return [[row, col]]\n    solution = Solution()\n    print(solution.highestRankedKItems([[1, 0, 1], [1, 0, 1]], [2, 3], [0, 1], 2))", "40": "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[0, 2, 0, 1], [7, 3, 4, 5], [8, 6, 0, 9]]\n    pricing = [5, 10]\n    start = [2, 0]\n    k = 3\n    assert solution.highestRankedKItems(grid, pricing, start, k) == [[7, 3], [6, 8]]", "46": "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[1, 0, 1], [3, 4, 6], [8, 7, 9]]\n    pricing = [2, 5]\n    start = [1, 1]\n    k = 2\n    assert solution.highestRankedKItems(grid, pricing, start, k) == [[1, 2], [3, 0]]", "48": "def test_highestRankedKItems():\n    solution = Solution()\n\n    def test_case1():\n        grid = [[1, 0, 1], [2, 3, 0], [1, 1, 1]]\n        pricing = [2, 5]\n        start = [1, 0]\n        k = 3\n        expected_output = [[1, 1], [1, 0], [0, 1]]\n        assert solution.highestRankedKItems(grid, pricing, start, k) == expected_output"}}
{"task_num": 2157, "task_title": "Groups of Strings", "func_name": "groupStrings", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.sz = [1] * n\n\n  def unionBySize(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.sz[i] < self.sz[j]:\n      self.sz[j] += self.sz[i]\n      self.id[i] = j\n    else:\n      self.sz[i] += self.sz[j]\n      self.id[j] = i\n    self.count -= 1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def groupStrings(self, words: List[str]) -> List[int]:\n    uf = UnionFind(len(words))\n\n    def getMask(s: str) -> int:\n      mask = 0\n      for c in s:\n        mask |= 1 << ord(c) - ord('a')\n      return mask\n\n    def getAddedMasks(mask: int):\n      for i in range(26):\n        if not (mask >> i & 1):\n          yield mask | 1 << i\n\n    def getDeletedMasks(mask: int):\n      for i in range(26):\n        if mask >> i & 1:\n          yield mask ^ 1 << i\n\n    maskToIndex = {getMask(word): i for i, word in enumerate(words)}\n    deletedMaskToIndex = {}\n\n    for i, word in enumerate(words):\n      mask = getMask(word)\n      for m in getAddedMasks(mask):\n        if m in maskToIndex:\n          uf.unionBySize(i, maskToIndex[m])\n      for m in getDeletedMasks(mask):\n        if m in maskToIndex:\n          uf.unionBySize(i, maskToIndex[m])\n        if m in deletedMaskToIndex:\n          uf.unionBySize(i, deletedMaskToIndex[m])\n        else:\n          deletedMaskToIndex[m] = i\n\n    return [uf.count, max(uf.sz)]\n", "tests": {"21": "def test_groupStrings():\n    solution = Solution()\n\n    def assert_result(expected, actual):\n        if expected != actual:\n            raise AssertionError(f'Expected {expected}, got {actual}')\n    words1 = ['abc', 'cab', 'bca']\n    result = solution.groupStrings(words1)", "23": "def test_groupStrings(self):\n    words = ['abc', 'deq', 'mp', 'no']\n    self.assertEqual(self.solution.groupStrings(words), [2, 3])", "24": "    def test_groupStrings(self):\n        words = [\"abc\",\"bcd\",\"acef\",\"xyz\",\"az\",\"ba\",\"a\",\"z\"]\n        result = Solution().groupStrings(words)\n        self.assertEqual(result, [2, 4])\n\nif __name__ == '__main__':\n    unittest.main()", "26": "def test_groupStrings():\n\n    def getMask(s):\n        mask = 0\n        for c in s:\n            mask |= 1 << ord(c) - ord('a')\n        return mask\n    words = ['abc', 'bac', 'cab']\n    solution = Solution()\n    expected = [3, max(1, 1)]\n    result = solution.groupStrings(words)", "27": "def test_groupStrings():\n    solution = Solution()\n\n    def getMask(s):\n        mask = 0\n        for c in s:\n            mask |= 1 << ord(c) - ord('a')\n        return mask\n    words = ['abc', 'cab', 'bca']\n    result = solution.groupStrings(words)", "32": "def test_groupStrings(self):\n    solution = Solution()\n    words = ['abc', 'bac', 'cab']\n    self.assertEqual(solution.groupStrings(words), [2, 3])", "49": "def test_groupStrings():\n    solution = Solution()\n\n    def get_mask(s):\n        return ord(s[0]) - ord('a')\n    words = ['abc', 'cab', 'bca']\n    expected_result = [1, 3]\n    result = solution.groupStrings(words)", "54": "def test_groupStrings():\n\n    class Solution:\n\n        def getMask(self, s: str) -> int:\n            mask = 0\n            for c in s:\n                mask |= 1 << ord(c) - ord('a')\n            return mask\n\n        def groupStrings(self, words: List[str]) -> List[int]:\n            uf = UnionFind(len(words))\n\n            def getAddedMasks(mask: int):\n                for i in range(26):\n                    if not mask >> i & 1:\n                        yield (mask | 1 << i)\n\n            def getDeletedMasks(mask: int):\n                for i in range(26):\n                    if mask >> i & 1:\n                        yield (mask ^ 1 << i)\n            maskToIndex = {self.getMask(word): i for (i, word) in enumerate(words)}\n            deletedMaskToIndex = {}\n            for (i, word) in enumerate(words):\n                mask = self.getMask(word)\n                for m in getAddedMasks(mask):\n                    if m in maskToIndex:\n                        uf.unionBySize(i, maskToIndex[m])\n                for m in getDeletedMasks(mask):\n                    if m in maskToIndex:\n                        uf.unionBySize(i, maskToIndex[m])\n                    else:\n                        deletedMaskToIndex[m] = i\n            return [uf.count, max(uf.sz)]\n    solution = Solution()\n    words = ['abc', 'cab', 'bca']\n    print(solution.groupStrings(words))", "63": "def test_groupStrings():\n\n    def groupStrings():\n        words = ['abc', 'cab', 'bca']\n        uf = UnionFind(len(words))\n\n        def getMask(s: str) -> int:\n            mask = 0\n            for c in s:\n                mask |= 1 << ord(c) - ord('a')\n            return mask\n\n        def getAddedMasks(mask: int):\n            for i in range(26):\n                if not mask >> i & 1:\n                    yield (mask | 1 << i)\n\n        def getDeletedMasks(mask: int):\n            for i in range(26):\n                if mask >> i & 1:\n                    yield (mask ^ 1 << i)\n        maskToIndex = {getMask(word): i for (i, word) in enumerate(words)}\n        deletedMaskToIndex = {}\n        for (i, word) in enumerate(words):\n            mask = getMask(word)\n            for m in getAddedMasks(mask):\n                if m in maskToIndex:\n                    uf.unionBySize(i, maskToIndex[m])\n            for m in getDeletedMasks(mask):\n                if m in maskToIndex:\n                    uf.unionBySize(i, maskToIndex[m])\n                else:\n                    deletedMaskToIndex[m] = i\n        return [uf.count, max(uf.sz)]\n    assert groupStrings() == [2, 3]", "66": "def test_groupStrings():\n    solution = Solution()\n\n    def test_case(words):\n        return [2, max(uf.sz)]\n    words = ['abc', 'deq']\n    uf = UnionFind(len(words))\n    maskToIndex = {getMask(word): i for (i, word) in enumerate(words)}\n    result = test_case(words)\n    assert result == [2, 1], f'Expected [2, 1] but got {result}'", "68": "def test_groupStrings():\n\n    def getMask(s: str) -> int:\n        mask = 0\n        for c in s:\n            mask |= 1 << ord(c) - ord('a')\n        return mask\n    words = ['abc', 'bac', 'cab']\n    solution = Solution()\n    result = solution.groupStrings(words)", "70": "def test_groupStrings():\n\n    def groupStrings(words):\n        uf = UnionFind(len(words))\n\n        def getMask(s):\n            mask = 0\n            for c in s:\n                mask |= 1 << ord(c) - ord('a')\n            return mask\n\n        def getAddedMasks(mask):\n            for i in range(26):\n                if not mask >> i & 1:\n                    yield (mask | 1 << i)\n\n        def getDeletedMasks(mask):\n            for i in range(26):\n                if mask >> i & 1:\n                    yield (mask ^ 1 << i)\n        maskToIndex = {getMask(word): i for (i, word) in enumerate(words)}\n        deletedMaskToIndex = {}\n        for (i, word) in enumerate(words):\n            mask = getMask(word)\n            for m in getAddedMasks(mask):\n                if m in maskToIndex:\n                    uf.unionBySize(i, maskToIndex[m])\n            for m in getDeletedMasks(mask):\n                if m in maskToIndex:\n                    uf.unionBySize(i, maskToIndex[m])\n                else:\n                    deletedMaskToIndex[m] = i\n        return [uf.count, max(uf.sz)]\n    words = ['abc', 'cab', 'bca']\n    assert groupStrings(words) == [2, 3]"}}
{"task_num": 2182, "task_title": "Construct String With Repeat Limit", "func_name": "repeatLimitedString", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\n    ans = ''\n    count = collections.Counter(s)\n\n    while True:\n      addOne = ans and self._shouldAddOne(ans, count)\n      c = self._getLargestChar(ans, count)\n      if c == ' ':\n        break\n      repeats = 1 if addOne else min(count[c], repeatLimit)\n      ans += c * repeats\n      count[c] -= repeats\n\n    return ans\n\n  def _shouldAddOne(self, ans: str, count: collections.Counter) -> bool:\n    for c in reversed(string.ascii_lowercase):\n      if count[c]:\n        return ans[-1] == c\n    return False\n\n  def _getLargestChar(self, ans: str, count: collections.Counter) -> int:\n    for c in reversed(string.ascii_lowercase):\n      if count[c] and (not ans or ans[-1] != c):\n        return c\n    return ' '\n", "tests": {"20": "def test_repeatLimitedString():\n\n    def _helper(s):\n        result = []\n        count = collections.Counter(s)\n        while True:\n            addOne = result and result[-1] == 'a' and count['a']\n            c = max(count, key=count.get, default='')\n            if not c:\n                break\n            repeats = 1 if addOne else min(count[c], 3)\n            result.append(c * repeats)\n            count[c] -= repeats\n        return ''.join(result)\n    solution = Solution()\n    assert _helper('aaabaaaaa') == 'aabaaaabaaaa'", "30": "def test_repeatLimitedString():\n    solution = Solution()\n    print(solution.repeatLimitedString('abc', 2) == 'abac')", "36": "def test_repeatLimitedString(self):\n    solution = Solution()\n    s = 'aabbcc'\n    repeatLimit = 2\n    self.assertEqual(solution.repeatLimitedString(s, repeatLimit), 'abcabcbc')"}}
{"task_num": 2203, "task_title": "Minimum Weighted Subgraph With the Required Paths", "func_name": "minimumWeight", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\n    graph = [[] for _ in range(n)]\n    reversedGraph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      reversedGraph[v].append((u, w))\n\n    fromSrc1 = self._dijkstra(graph, src1)\n    fromSrc2 = self._dijkstra(graph, src2)\n    fromDest = self._dijkstra(reversedGraph, dest)\n    minWeight = min(a + b + c for a, b, c in zip(fromSrc1, fromSrc2, fromDest))\n    if minWeight == math.inf:\n      return -1\n    else:\n      return minWeight\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int) -> List[int]:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist\n", "tests": {"25": "def test_minimumWeight():\n\n    class Solution:\n\n        def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\n            graph = [[] for _ in range(n)]\n            reversedGraph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                reversedGraph[v].append((u, w))\n            fromSrc1 = self._dijkstra(graph, src1)\n            fromSrc2 = self._dijkstra(graph, src2)\n            fromDest = self._dijkstra(reversedGraph, dest)\n            minWeight = min((a + b + c for (a, b, c) in zip(fromSrc1, fromSrc2, fromDest)))\n            if minWeight == math.inf:\n                return -1\n            else:\n                return minWeight\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int) -> List[int]:\n            dist = [math.inf] * len(graph)\n            dist[src] = 0\n            minHeap = [(dist[src], src)]\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (dist[v], v))\n            return dist\n    solution = Solution()\n    print(solution.minimumWeight(3, [[0, 1, 5], [2, 1, 4]], 0, 2, 1))", "27": "def test_minimumWeight():\n\n    class Solution:\n\n        def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\n            graph = [[] for _ in range(n)]\n            reversedGraph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                reversedGraph[v].append((u, w))\n            fromSrc1 = self._dijkstra(graph, src1)\n            fromSrc2 = self._dijkstra(graph, src2)\n            fromDest = self._dijkstra(reversedGraph, dest)\n            minWeight = min((a + b + c for (a, b, c) in zip(fromSrc1, fromSrc2, fromDest)))\n            if minWeight == math.inf:\n                return -1\n            else:\n                return minWeight\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int) -> List[int]:\n            dist = [math.inf] * len(graph)\n            dist[src] = 0\n            minHeap = [(dist[src], src)]\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (dist[v], v))\n            return dist\n    solution = Solution()\n    assert solution.minimumWeight(4, [[0, 1, 2], [1, 2, 3], [1, 3, 5]], 0, 1, 2) == 6", "38": "def test_minimumWeight(self):\n\n    class Solution:\n\n        def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\n            graph = [[] for _ in range(n)]\n            reversedGraph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                reversedGraph[v].append((u, w))\n            fromSrc1 = self._dijkstra(graph, src1)\n            fromSrc2 = self._dijkstra(graph, src2)\n            fromDest = self._dijkstra(reversedGraph, dest)\n            minWeight = min((a + b + c for (a, b, c) in zip(fromSrc1, fromSrc2, fromDest)))\n            if minWeight == math.inf:\n                return -1\n            else:\n                return minWeight\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int) -> List[int]:\n            dist = [math.inf] * len(graph)\n            dist[src] = 0\n            minHeap = [(dist[src], src)]\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                for (v, w) in graph[u]:\n                    if d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (dist[v], v))\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 2], [1, 2, 3]]\n    src1 = 0\n    src2 = 1\n    dest = 2\n    self.assertEqual(solution.minimumWeight(n, edges, src1, src2, dest), 5)", "41": "def test_minimumWeight():\n\n    def minimumWeight(self, n, edges, src1, src2, dest):\n        graph = [[] for _ in range(n)]\n        reversedGraph = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            reversedGraph[v].append((u, w))\n        fromSrc1 = self._dijkstra(graph, src1)\n        fromSrc2 = self._dijkstra(graph, src2)\n        fromDest = self._dijkstra(reversedGraph, dest)\n        minWeight = min((a + b + c for (a, b, c) in zip(fromSrc1, fromSrc2, fromDest)))\n        if minWeight == math.inf:\n            return -1\n        else:\n            return minWeight\n\n    class Solution:\n\n        def _dijkstra(self, graph, src):\n            dist = [math.inf] * len(graph)\n            dist[src] = 0\n            minHeap = [(dist[src], src)]\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (dist[v], v))\n            return dist\n    solution = Solution()\n    edges = [[0, 1, 10], [0, 2, 20], [2, 4, 30]]\n    n = 5\n    src1 = 0\n    src2 = 1\n    dest = 4\n    assert solution.minimumWeight(n, edges, src1, src2, dest) == 40", "42": "def test_minimumWeight(self):\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 3], [1, 2, 2], [0, 2, 6], [2, 4, 7]]\n    src1 = 0\n    src2 = 1\n    dest = 4\n    result = solution.minimumWeight(n, edges, src1, src2, dest)"}}
{"task_num": 2242, "task_title": "Maximum Score of a Node Sequence", "func_name": "maximumScore", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\n    n = len(scores)\n    ans = -1\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append((scores[v], v))\n      graph[v].append((scores[u], u))\n\n    for i in range(n):\n      graph[i] = heapq.nlargest(3, graph[i])\n\n    for u, v in edges:\n      for scoreA, a in graph[u]:\n        for scoreB, b in graph[v]:\n          if a != b and a != v and b != u:\n            ans = max(ans, scoreA + scores[u] + scores[v] + scoreB)\n\n    return ans\n", "tests": {"28": "def test_maximumScore(self):\n\n    class Solution:\n\n        def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\n            n = len(scores)\n            ans = -1\n            graph = [[] for _ in range(n)]\n            for (u, v) in edges:\n                graph[u].append((scores[v], v))\n                graph[v].append((scores[u], u))\n            for i in range(n):\n                graph[i] = heapq.nlargest(3, graph[i])\n            for (u, v) in edges:\n                for (scoreA, a) in graph[u]:\n                    for (scoreB, b) in graph[v]:\n                        if a != b and a != v and (b != u):\n                            ans = max(ans, scoreA + scores[u] + scores[v] + scoreB)\n            return ans\n    solution = Solution()\n    scores = [1, 2, 3, 4]\n    edges = [[0, 1], [0, 2], [0, 3]]\n    self.assertEqual(solution.maximumScore(scores, edges), 22)"}}
{"task_num": 2245, "task_title": "Maximum Trailing Zeros in a Cornered Path", "func_name": "maxTrailingZeros", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxTrailingZeros(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    leftPrefix2 = [[0] * n for _ in range(m)]\n    leftPrefix5 = [[0] * n for _ in range(m)]\n    topPrefix2 = [[0] * n for _ in range(m)]\n    topPrefix5 = [[0] * n for _ in range(m)]\n\n    def getCount(num: int, factor: int) -> int:\n      count = 0\n      while num % factor == 0:\n        num //= factor\n        count += 1\n      return count\n\n    for i in range(m):\n      for j in range(n):\n        leftPrefix2[i][j] = getCount(grid[i][j], 2)\n        leftPrefix5[i][j] = getCount(grid[i][j], 5)\n        if j:\n          leftPrefix2[i][j] += leftPrefix2[i][j - 1]\n          leftPrefix5[i][j] += leftPrefix5[i][j - 1]\n\n    for j in range(n):\n      for i in range(m):\n        topPrefix2[i][j] = getCount(grid[i][j], 2)\n        topPrefix5[i][j] = getCount(grid[i][j], 5)\n        if i:\n          topPrefix2[i][j] += topPrefix2[i - 1][j]\n          topPrefix5[i][j] += topPrefix5[i - 1][j]\n\n    ans = 0\n    for i in range(m):\n      for j in range(n):\n        curr2 = getCount(grid[i][j], 2)\n        curr5 = getCount(grid[i][j], 5)\n        l2 = leftPrefix2[i][j]\n        l5 = leftPrefix5[i][j]\n        r2 = leftPrefix2[i][n - 1] - (0 if j == 0 else leftPrefix2[i][j - 1])\n        r5 = leftPrefix5[i][n - 1] - (0 if j == 0 else leftPrefix5[i][j - 1])\n        t2 = topPrefix2[i][j]\n        t5 = topPrefix5[i][j]\n        d2 = topPrefix2[m - 1][j] - (0 if i == 0 else topPrefix2[i - 1][j])\n        d5 = topPrefix5[m - 1][j] - (0 if i == 0 else topPrefix5[i - 1][j])\n        ans = max(ans, min(l2 + t2 - curr2, l5 + t5 - curr5), min(r2 + t2 - curr2, r5 + t5 - curr5), min(l2 + d2 - curr2, l5 + d5 - curr5), min(r2 + d2 - curr2, r5 + d5 - curr5))\n\n    return ans\n", "tests": {"32": "def test_maxTrailingZeros():\n\n    class Solution:\n\n        def maxTrailingZeros(self, grid):\n            m = len(grid)\n            n = len(grid[0])\n            leftPrefix2 = [[0] * n for _ in range(m)]\n            leftPrefix5 = [[0] * n for _ in range(m)]\n\n            def getCount(num: int, factor: int) -> int:\n                count = 0\n                while num % factor == 0:\n                    num //= factor\n                    count += 1\n                return count\n            grid[1][1] = 10\n            for i in range(m):\n                for j in range(n):\n                    leftPrefix2[i][j] = getCount(grid[i][j], 2)\n            solution = Solution()\n            assert solution.maxTrailingZeros([[5, 10]]) == 0", "33": "def test_maxTrailingZeros():\n\n    class Solution:\n\n        def maxTrailingZeros(self, grid: List[List[int]]) -> int:\n            m = len(grid)\n            n = len(grid[0])\n            leftPrefix2 = [[0] * n for _ in range(m)]\n            leftPrefix5 = [[0] * n for _ in range(m)]\n            topPrefix2 = [[0] * n for _ in range(m)]\n            topPrefix5 = [[0] * n for _ in range(m)]\n\n            def getCount(num: int, factor: int) -> int:\n                count = 0\n                while num % factor == 0:\n                    num //= factor\n                    count += 1\n                return count\n            for i in range(m):\n                for j in range(n):\n                    leftPrefix2[i][j] = getCount(grid[i][j], 2)\n                    leftPrefix5[i][j] = getCount(grid[i][j], 5)\n                    if j:\n                        leftPrefix2[i][j] += leftPrefix2[i][j - 1]\n                        leftPrefix5[i][j] += leftPrefix5[i][j - 1]\n            solution = Solution()", "40": "def test_maxTrailingZeros():\n\n    class Solution:\n\n        def maxTrailingZeros(self, grid):\n            m = len(grid)\n            n = len(grid[0])\n            leftPrefix2 = [[0] * n for _ in range(m)]\n            leftPrefix5 = [[0] * n for _ in range(m)]\n            topPrefix2 = [[0] * n for _ in range(m)]\n            topPrefix5 = [[0] * n for _ in range(m)]\n\n            def getCount(num, factor):\n                count = 0\n                while num % factor == 0:\n                    num //= factor\n                    count += 1\n                return count\n            for i in range(m):\n                for j in range(n):\n                    leftPrefix2[i][j] = getCount(grid[i][j], 2)\n                    leftPrefix5[i][j] = getCount(grid[i][j], 5)\n                    if j:\n                        leftPrefix2[i][j] += leftPrefix2[i][j - 1]\n                        leftPrefix5[i][j] += leftPrefix5[i][j - 1]\n            for j in range(n):\n                for i in range(m):\n                    topPrefix2[i][j] = getCount(grid[i][j], 2)\n                    topPrefix5[i][j] = getCount(grid[i][j], 5)\n                    if i:\n                        topPrefix2[i][j] += topPrefix2[i - 1][j]\n                        topPrefix5[i][j] += topPrefix5[i - 1][j]\n            ans = 0\n            for i in range(m):\n                for j in range(n):\n                    curr2 = getCount(grid[i][j], 2)\n                    curr5 = getCount(grid[i][j], 5)\n                    l2 = leftPrefix2[i][j]\n                    l5 = leftPrefix5[i][j]\n                    r2 = leftPrefix2[i][n - 1] - (0 if j == 0 else leftPrefix2[i][j - 1])\n                    r5 = leftPrefix5[i][n - 1] - (0 if j == 0 else leftPrefix5[i][j - 1])\n                    t2 = topPrefix2[i][j]\n                    t5 = topPrefix5[i][j]\n                    d2 = topPrefix2[m - 1][j] - (0 if i == 0 else topPrefix2[i - 1][j])\n                    d5 = topPrefix5[m - 1][j] - (0 if i == 0 else topPrefix5[i - 1][j])\n                    ans = max(ans, min(l2 + t2 - curr2, l5 + t5 - curr5), min(r2 + t2 - curr2, r5 + t5 - curr5), min(l2 + d2 - curr2, l5 + d5 - curr5), min(r2 + d2 - curr2, r5 + d5 - curr5))\n            return ans\n    solution = Solution()\n    grid = [[10, 20], [30, 40]]\n    assert solution.maxTrailingZeros(grid) == 1", "41": "def test_maxTrailingZeros():\n\n    class Solution:\n\n        def maxTrailingZeros(self, grid: List[List[int]]) -> int:\n            m = len(grid)\n            n = len(grid[0])\n            leftPrefix2 = [[0] * n for _ in range(m)]\n            leftPrefix5 = [[0] * n for _ in range(m)]\n            topPrefix2 = [[0] * n for _ in range(m)]\n            topPrefix5 = [[0] * n for _ in range(m)]\n\n            def getCount(num: int, factor: int) -> int:\n                count = 0\n                while num % factor == 0:\n                    num //= factor\n                    count += 1\n                return count\n            for i in range(m):\n                for j in range(n):\n                    leftPrefix2[i][j] = getCount(grid[i][j], 2)\n                    leftPrefix5[i][j] = getCount(grid[i][j], 5)\n                    if j:\n                        leftPrefix2[i][j] += leftPrefix2[i][j - 1]\n                        leftPrefix5[i][j] += leftPrefix5[i][j - 1]\n            for j in range(n):\n                for i in range(m):\n                    topPrefix2[i][j] = getCount(grid[i][j], 2)\n                    topPrefix5[i][j] = getCount(grid[i][j], 5)\n                    if i:\n                        topPrefix2[i][j] += topPrefix2[i - 1][j]\n                        assert topPrefix5[i][j] == topPrefix5[i - 1][j]\n            return 0"}}
{"task_num": 2257, "task_title": "Count Unguarded Cells in the Grid", "func_name": "countUnguarded", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\n    ans = 0\n    grid = [[0] * n for _ in range(m)]\n    left = [[0] * n for _ in range(m)]\n    right = [[0] * n for _ in range(m)]\n    up = [[0] * n for _ in range(m)]\n    down = [[0] * n for _ in range(m)]\n\n    for row, col in guards:\n      grid[row][col] = 'G'\n\n    for row, col in walls:\n      grid[row][col] = 'W'\n\n    for i in range(m):\n      lastCell = 0\n      for j in range(n):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          left[i][j] = lastCell\n      lastCell = 0\n      for j in range(n - 1, -1, -1):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          right[i][j] = lastCell\n\n    for j in range(n):\n      lastCell = 0\n      for i in range(m):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          up[i][j] = lastCell\n      lastCell = 0\n      for i in range(m - 1, -1, -1):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          down[i][j] = lastCell\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 0 and left[i][j] != 'G' and right[i][j] != 'G' and up[i][j] != 'G' and down[i][j] != 'G':\n          ans += 1\n\n    return ans\n", "tests": {"30": "def test_countUnguarded():\n\n    class Solution:\n\n        def countUnguarded(self, m, n, guards, walls):\n            ans = 0\n            grid = [[0] * n for _ in range(m)]\n            left = [[0] * n for _ in range(m)]\n            right = [[0] * n for _ in range(m)]\n            up = [[0] * n for _ in range(m)]\n            down = [[0] * n for _ in range(m)]\n            for (row, col) in guards:\n                grid[row][col] = 'G'\n            for (row, col) in walls:\n                grid[row][col] = 'W'\n            for i in range(m):\n                lastCell = 0\n                for j in range(n):\n                    if grid[i][j] == 'G' or grid[i][j] == 'W':\n                        lastCell = grid[i][j]\n                    else:\n                        left[i][j] = lastCell\n                lastCell = 0\n                for j in range(n - 1, -1, -1):\n                    if grid[i][j] == 'G' or grid[i][j] == 'W':\n                        lastCell = grid[i][j]\n                    else:\n                        right[i][j] = lastCell\n            for j in range(n):\n                lastCell = 0\n                for i in range(m):\n                    if grid[i][j] == 'G' or grid[i][j] == 'W':\n                        lastCell = grid[i][j]\n                    else:\n                        up[i][j] = lastCell\n                lastCell = 0\n                for i in range(m - 1, -1, -1):\n                    if grid[i][j] == 'G' or grid[i][j] == 'W':\n                        lastCell = grid[i][j]\n                    else:\n                        down[i][j] = lastCell\n            for i in range(m):\n                for j in range(n):\n                    if grid[i][j] == 0 and left[i][j] != 'G' and (right[i][j] != 'G') and (up[i][j] != 'G') and (down[i][j] != 'G'):\n                        ans += 1\n            return ans\n    solution = Solution()\n    assert solution.countUnguarded(3, 3, [[0, 1]], [[0, 2]]) == 4", "32": "def test_countUnguarded():\n\n    class Solution:\n\n        def countUnguarded(self, m, n, guards, walls):\n            ans = 0\n            grid = [[0] * n for _ in range(m)]\n            left = [[0] * n for _ in range(m)]\n            right = [[0] * n for _ in range(m)]\n            up = [[0] * n for _ in range(m)]\n            down = [[0] * n for _ in range(m)]\n            for (row, col) in guards:\n                grid[row][col] = 'G'\n            for (row, col) in walls:\n                grid[row][col] = 'W'\n            for i in range(m):\n                lastCell = 0\n                for j in range(n):\n                    if grid[i][j] == 'G' or grid[i][j] == 'W':\n                        lastCell = grid[i][j]\n                    else:\n                        left[i][j] = lastCell\n            for j in range(n):\n                lastCell = 0\n                for i in range(m - 1, -1, -1):\n                    if grid[i][j] == 'G' or grid[i][j] == 'W':\n                        lastCell = grid[i][j]\n                    else:\n                        up[i][j] = lastCell\n            return len([cell for row in up for cell in row if cell != 'G'])\nsolution = Solution()\nprint(solution.countUnguarded(2, 3, [[0, 1]], []))", "36": "def test_countUnguarded():\n\n    def countUnguarded(m, n, guards, walls):\n        ans = 0\n        grid = [[0] * n for _ in range(m)]\n        left = [[0] * n for _ in range(m)]\n        right = [[0] * n for _ in range(m)]\n        up = [[0] * n for _ in range(m)]\n        down = [[0] * n for _ in range(m)]\n        for (row, col) in guards:\n            grid[row][col] = 'G'\n        for (row, col) in walls:\n            grid[row][col] = 'W'\n        for i in range(m):\n            lastCell = 0\n            for j in range(n):\n                if grid[i][j] == 'G' or grid[i][j] == 'W':\n                    lastCell = grid[i][j]\n                else:\n                    left[i][j] = lastCell\n            lastCell = 0\n            for j in range(n - 1, -1, -1):\n                if grid[i][j] == 'G' or grid[i][j] == 'W':\n                    lastCell = grid[i][j]\n                else:\n                    right[i][j] = lastCell\n        for j in range(n):\n            lastCell = 0\n            for i in range(m):\n                if grid[i][j] == 'G' or grid[i][j] == 'W':\n                    lastCell = grid[i][j]\n                else:\n                    up[i][j] = lastCell\n            lastCell = 0\n            for i in range(m - 1, -1, -1):\n                if grid[i][j] == 'G' or grid[i][j] == 'W':\n                    lastCell = grid[i][j]\n                else:\n                    down[i][j] = lastCell\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 0 and left[i][j] != 'G' and (right[i][j] != 'G') and (up[i][j] != 'G') and (down[i][j] != 'G'):\n                    ans += 1\n        return ans\n    solution = Solution()\n    assert countUnguarded(5, 5, [[0, 1], [4, 2]], [[3, 1]]) == 13", "38": "def test_countUnguarded(self):\n    solution = Solution()\n    (m, n) = (3, 5)\n    guards = [[0, 1], [1, 2]]\n    walls = [[1, 4]]\n    self.assertEqual(solution.countUnguarded(m, n, guards, walls), 8)", "44": "def test_countUnguarded(self):\n\n    class Solution:\n\n        def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\n            ans = 0\n            grid = [[0] * n for _ in range(m)]\n            left = [[0] * n for _ in range(m)]\n            right = [[0] * n for _ in range(m)]\n            up = [[0] * n for _ in range(m)]\n            down = [[0] * n for _ in range(m)]\n            for (row, col) in guards:\n                grid[row][col] = 'G'\n            grid[1][1] = 'W'\n            grid[2][3] = 'G'\n            walls.append([3, 4])\n            for i in range(m):\n                lastCell = 0\n                for j in range(n):\n                    if grid[i][j] == 'G' or grid[i][j] == 'W':\n                        lastCell = grid[i][j]\n                    else:\n                        left[i][j] = lastCell\n                lastCell = 0\n                for j in range(n - 1, -1, -1):\n                    if grid[i][j] == 'G' or grid[i][j] == 'W':\n                        lastCell = grid[i][j]\n                    else:\n                        right[i][j] = lastCell\n            for j in range(n):\n                lastCell = 0\n                for i in range(m):\n                    if grid[i][j] == 'G' or grid[i][j] == 'W':\n                        lastCell = grid[i][j]\n                    else:\n                        up[i][j] = lastCell\n                lastCell = 0\n                for i in range(m - 1, -1, -1):\n                    if grid[i][j] == 'G' or grid[i][j] == 'W':\n                        lastCell = grid[i][j]\n                    else:\n                        down[i][j] = lastCell\n            for i in range(m):\n                for j in range(n):\n                    if grid[i][j] == 0 and left[i][j] != 'G' and (right[i][j] != 'G') and (up[i][j] != 'G') and (down[i][j] != 'G'):\n                        ans += 1\n            self.assertEqual(ans, 13)\n    solution = Solution()\n    self.assertEqual(solution.countUnguarded(5, 5, [[0, 0], [1, 2]], [[3, 4]]), 16)", "46": "def test_countUnguarded(self):\n\n    class Solution:\n\n        def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\n            ans = 0\n            grid = [[0] * n for _ in range(m)]\n            left = [[0] * n for _ in range(m)]\n            right = [[0] * n for _ in range(m)]\n            up = [[0] * n for _ in range(m)]\n            down = [[0] * n for _ in range(m)]\n            grid[0][0] = 'G'\n            grid[1][1] = 'W'\n            for i in range(m):\n                lastCell = 0\n                for j in range(n):\n                    if grid[i][j] == 'G' or grid[i][j] == 'W':\n                        lastCell = grid[i][j]\n                    else:\n                        up[i][j] = lastCell\n    solution = Solution()\n    self.assertEqual(solution.countUnguarded(2, 2, [[0, 0]], [[1, 1]]), 3)", "50": "def test_countUnguarded(self):\n    (m, n) = (5, 5)\n    guards = [[0, 1], [4, 2]]\n    walls = [[3, 1], [3, 2]]\n    self.assertEqual(solution.countUnguarded(m, n, guards, walls), 10)", "52": "def test_countUnguarded(self):\n    m = 3\n    n = 4\n    guards = [[0, 1], [1, 2]]\n    walls = [[1, 0], [2, 2]]\n    self.assertEqual(solution.countUnguarded(m, n, guards, walls), 6)", "57": "def test_countUnguarded(self):\n    solution = Solution()\n    (m, n) = (5, 5)\n    guards = [[0, 2], [1, 1]]\n    walls = [[3, 3], [3, 4]]\n    self.assertEqual(solution.countUnguarded(m, n, guards, walls), 10)"}}
{"task_num": 2258, "task_title": "Escape the Spreading Fire", "func_name": "maximumMinutes", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumMinutes(self, grid: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    kMax = len(grid) * len(grid[0])\n    fireGrid = [[-1] * len(grid[0]) for _ in range(len(grid))]\n    self._buildFireGrid(grid, fireGrid, dirs)\n\n    ans = -1\n    l = 0\n    r = kMax\n\n    while l <= r:\n      m = (l + r) // 2\n      if self._canStayFor(grid, fireGrid, m, dirs):\n        ans = m\n        l = m + 1\n      else:\n        r = m - 1\n\n    return int(1e9) if ans == kMax else ans\n\n  def _buildFireGrid(self, grid: List[List[int]], fireMinute: List[List[int]], dirs: List[int]) -> None:\n    minuteFromFire = 0\n    q = collections.deque()\n\n    for i in range(len(grid)):\n      for j in range(len(grid[0])):\n        if grid[i][j] == 1:\n          q.append((i, j))\n          fireMinute[i][j] = 0\n    while q:\n      minuteFromFire += 1\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == len(grid) or y < 0 or y == len(grid[0]):\n            continue\n          if grid[x][y] == 2:\n            continue\n          if fireMinute[x][y] != -1:\n            continue\n          fireMinute[x][y] = minuteFromFire\n          q.append((x, y))\n\n  def _canStayFor(self, grid: List[List[int]], fireMinute: List[List[int]], minute: int, dirs: List[int]) -> bool:\n    q = collections.deque([(0, 0)])\n    seen = {(0, 0)}\n\n    while q:\n      minute += 1\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == len(grid) or y < 0 or y == len(grid[0]):\n            continue\n          if grid[x][y] == 2:\n            continue\n          if x == len(grid) - 1 and y == len(grid[0]) - 1:\n            if fireMinute[x][y] != -1 and fireMinute[x][y] < minute:\n              continue\n            return True\n          if fireMinute[x][y] != -1 and fireMinute[x][y] <= minute:\n            continue\n          if (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n\n    return False\n", "tests": {"25": "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[1, 0], [2, 0]]\n    assert solution.maximumMinutes(grid) == 109", "26": "def test_maximumMinutes(self):\n    grid = [[0, 2, 1], [1, 1, 0]]\n    self.assertEqual(solution.maximumMinutes(grid), 6)", "28": "def test_maximumMinutes(self):\n    class Solution:\n        def maximumMinutes(self, grid: List[List[int]]) -> int:\n            # ... rest of the function remains the same ...\n\n    solution = Solution()\n\n    grid = [[0, 1], [2, 0]]\n    self.assertEqual(solution.maximumMinutes(grid), -1)", "39": "def test_maximumMinutes():\n\n    def helper(grid):\n        return grid[0][0]\n    solution = Solution()\n    grid = [[1, 2], [0, 0]]\n    assert helper(solution.maximumMinutes(grid)) == -1", "40": "def test_maximumMinutes(self):\n    grid = [[1, 2], [0, 0]]\n    self.assertEqual(solution.maximumMinutes(grid), 109)", "49": "def test_maximumMinutes():\n\n    class Solution:\n\n        def maximumMinutes(self, grid):\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            kMax = len(grid) * len(grid[0])\n            fireGrid = [[-1] * len(grid[0]) for _ in range(len(grid))]\n            self._buildFireGrid(grid, fireGrid, dirs)\n            ans = -1\n            l = 0\n            r = kMax\n            while l <= r:\n                m = (l + r) // 2\n                if self._canStayFor(grid, fireGrid, m, dirs):\n                    ans = m\n                    l = m + 1\n                else:\n                    r = m - 1\n            return int(1000000000.0) if ans == kMax else ans\n\n        def _buildFireGrid(self, grid: List[List[int]], fireMinute: List[List[int]], dirs: List[int]) -> None:\n            minuteFromFire = 0\n            q = collections.deque()\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == 1:\n                        q.append((i, j))\n                        fireMinute[i][j] = 0\n            while q:\n                minuteFromFire += 1\n                for _ in range(len(q)):\n                    (i, j) = q.popleft()\n                    for (dx, dy) in dirs:\n                        x = i + dx\n                        y = j + dy\n                        if x < 0 or x == len(grid) or y < 0 or (y == len(grid[0])):\n                            continue\n                        if grid[x][y] == 2:\n                            continue\n                        if fireMinute[x][y] != -1:\n                            continue\n                        fireMinute[x][y] = minuteFromFire\n                        q.append((x, y))\n\n        def _canStayFor(self, grid: List[List[int]], fireMinute: List[List[int]], minute: int, dirs: List[int]) -> bool:\n            q = collections.deque([(0, 0)])\n            seen = {(0, 0)}\n            while q:\n                minute += 1\n                for _ in range(len(q)):\n                    (i, j) = q.popleft()\n                    for (dx, dy) in dirs:\n                        x = i + dx\n                        y = j + dy\n                        if x < 0 or x == len(grid) or y < 0 or (y == len(grid[0])):\n                            continue\n                        if grid[x][y] == 2:\n                            continue\n                        if x == len(grid) - 1 and y == len(grid[0]) - 1:\n                            if fireMinute[x][y] != -1 and fireMinute[x][y] < minute:\n                                continue\n                            return True\n                        if fireMinute[x][y] != -1 and fireMinute[x][y] <= minute:\n                            continue\n                        if (x, y) in seen:\n                            continue\n                        q.append((x, y))\n                        seen.add((x, y))\n            return False\n    solution = Solution()\n    grid = [[2, 0], [2, 1]]\n    assert solution.maximumMinutes(grid) == -1", "51": "def test_maximumMinutes():\n    grid = [[2, 0], [0, 1]]\n    print(solution.maximumMinutes(grid))", "53": "    def test_maximumMinutes(self):\n        grid = [\n            [1,0],\n            [2,0]\n        ]\n        self.assertEqual(Solution().maximumMinutes(grid), -1)\n\nif __name__ == '__main__':\n    unittest.main()", "69": "def test_maximumMinutes():\n\n    class Solution:\n\n        def maximumMinutes(self, grid):\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            fireGrid = [[-1] * len(grid[0]) for _ in range(len(grid))]\n            self._buildFireGrid(grid, fireGrid, dirs)\n            return 10 if grid == [[2, 1], [0, 0]] else int(1000000000.0)\nsolution = Solution()\nprint(solution.maximumMinutes([[2, 1], [0, 0]]))", "71": "def test_maximumMinutes():\n\n    class Solution:\n\n        def maximumMinutes(self, grid):\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            fireGrid = [[-1] * len(grid[0]) for _ in range(len(grid))]\n            self._buildFireGrid(grid, fireGrid, dirs)\n            ans = -1\n            l = 0\n            r = 16\n            while l <= r:\n                m = (l + r) // 2\n                if self._canStayFor(grid, fireGrid, m, dirs):\n                    ans = m\n                    l = m + 1\n                else:\n                    r = m - 1\n            return int(1000000000.0) if ans == 16 else ans\n    solution = Solution()\n    print(solution.maximumMinutes([[0, 2], [0, 0]]))", "73": "def test_maximumMinutes(self):\n\n    class Solution:\n\n        def maximumMinutes(self, grid):\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            kMax = len(grid) * len(grid[0])\n            fireGrid = [[-1] * len(grid[0]) for _ in range(len(grid))]\n            self._buildFireGrid(grid, fireGrid, dirs)\n            ans = -1\n            l = 0\n            r = kMax\n            while l <= r:\n                m = (l + r) // 2\n                if self._canStayFor(grid, fireGrid, m, dirs):\n                    ans = m\n                    l = m + 1\n                else:\n                    r = m - 1\n            return int(1000000000.0) if ans == kMax else ans\n\n        def _buildFireGrid(self, grid, fireMinute, dirs):\n            minuteFromFire = 0\n            q = collections.deque()\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == 1:\n                        q.append((i, j))\n                        fireMinute[i][j] = 0\n            while q:\n                minuteFromFire += 1\n                for _ in range(len(q)):\n                    (i, j) = q.popleft()\n                    for (dx, dy) in dirs:\n                        x = i + dx\n                        y = j + dy\n                        if x < 0 or x == len(grid) or y < 0 or (y == len(grid[0])):\n                            continue\n                        if grid[x][y] == 2:\n                            continue\n                        if fireMinute[x][y] != -1:\n                            continue\n                        fireMinute[x][y] = minuteFromFire\n                        q.append((x, y))\n\n        def _canStayFor(self, grid, fireMinute, minute, dirs):\n            q = collections.deque([(0, 0)])\n            seen = {(0, 0)}\n            while q:\n                minute += 1\n                for _ in range(len(q)):\n                    (i, j) = q.popleft()\n                    for (dx, dy) in dirs:\n                        x = i + dx\n                        y = j + dy\n                        if x < 0 or x == len(grid) or y < 0 or (y == len(grid[0])):\n                            continue\n                        if grid[x][y] == 2:\n                            continue\n                        if x == len(grid) - 1 and y == len(grid[0]) - 1:\n                            if fireMinute[x][y] != -1 and fireMinute[x][y] < minute:\n                                continue\n                            return True\n                        if fireMinute[x][y] != -1 and fireMinute[x][y] <= minute:\n                            continue\n                        if (x, y) in seen:\n                            continue\n                        q.append((x, y))\n                        seen.add((x, y))\n    solution = Solution()\n    grid = [[2, 0], [1, 0]]\n    self.assertEqual(solution.maximumMinutes(grid), -1)", "74": "def test_maximumMinutes():\n    grid = [[0, 1], [2, 0]]\n    assert solution.maximumMinutes(grid) == -1", "75": "def test_maximumMinutes(self):\n    grid = [[1, 0], [2, 0]]\n    self.assertEqual(solution.maximumMinutes(grid), 109)", "77": "def test_maximumMinutes():\n    grid = [[1, 0, 2], [0, 0, 0], [0, 0, 0]]\n    print(solution.maximumMinutes(grid))", "79": "def test_maximumMinutes():\n    grid = [[0, 1], [2, 0]]\n    assert solution.maximumMinutes(grid) == -1"}}
{"task_num": 2290, "task_title": "Minimum Obstacle Removal to Reach Corner", "func_name": "minimumObstacles", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumObstacles(self, grid: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    minHeap = [(grid[0][0], 0, 0)]  # (d, i, j)\n    dist = [[math.inf] * n for _ in range(m)]\n    dist[0][0] = grid[0][0]\n\n    while minHeap:\n      d, i, j = heapq.heappop(minHeap)\n      if i == m - 1 and j == n - 1:\n        return d\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        newDist = d + grid[i][j]\n        if newDist < dist[x][y]:\n          dist[x][y] = newDist\n          heapq.heappush(minHeap, (newDist, x, y))\n\n    return dist[m - 1][n - 1]\n", "tests": {"23": "def test_minimumObstacles(self):\n    solution = Solution()\n    self.assertEqual(solution.minimumObstacles([[0, 1], [1, 0]]), 1)", "28": "def test_minimumObstacles(self):\n    solution = Solution()\n    grid = [[0, 1, 0], [0, 1, 0], [0, 1, 0]]\n    self.assertEqual(solution.minimumObstacles(grid), 2)", "31": "def test_minimumObstacles(self):\n\n    class Solution:\n\n        def minimumObstacles(self, grid: List[List[int]]) -> int:\n            return 0\n    solution = Solution()\n    self.assertEqual(solution.minimumObstacles([[0, 1], [1, 0]]), 1)", "32": "def test_minimumObstacles(self):\n\n    class Solution:\n\n        def minimumObstacles(self, grid: List[List[int]]) -> int:\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            m = len(grid)\n            n = len(grid[0])\n            minHeap = [(grid[0][0], 0, 0)]\n            dist = [[math.inf] * n for _ in range(m)]\n            dist[0][0] = grid[0][0]\n            while minHeap:\n                (d, i, j) = heapq.heappop(minHeap)\n                if i == m - 1 and j == n - 1:\n                    return d\n                for (dx, dy) in dirs:\n                    x = i + dx\n                    y = j + dy\n                    if x < 0 or x == m or y < 0 or (y == n):\n                        continue\n                    newDist = d + grid[i][j]\n                    if newDist < dist[x][y]:\n                        dist[x][y] = newDist\n                        heapq.heappush(minHeap, (newDist, x, y))\n            return dist[m - 1][n - 1]\n    solution = Solution()\n    grid = [[0, 1], [1, 0]]\n    self.assertEqual(solution.minimumObstacles(grid), 1)"}}
{"task_num": 2299, "task_title": "Strong Password Checker II", "func_name": "strongPasswordCheckerII", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def strongPasswordCheckerII(self, password: str) -> bool:\n    if len(password) < 8:\n      return False\n    if not any(c.islower() for c in password):\n      return False\n    if not any(c.isupper() for c in password):\n      return False\n    if not any(c.isdigit() for c in password):\n      return False\n    if not any(\"!@#$%^&*()-+\".find(c) != -1 for c in password):\n      return False\n    return all(a != b for a, b in zip(password, password[1:]))\n", "tests": {"14": "def test_strongPasswordCheckerII(self):\n    solution = Solution()\n    self.assertFalse(solution.strongPasswordCheckerII('a'))", "16": "def test_strongPasswordCheckerII():\n    solution = Solution()\n\n    def test_input1():\n        password = 'aAb9'\n        assert not solution.strongPasswordCheckerII(password)", "18": "def test_strongPasswordCheckerII():\n    solution = Solution()\n    print(solution.strongPasswordCheckerII('A'))", "20": "def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert not solution.strongPasswordCheckerII('12345!@#$%^&*()-+')", "22": "def test_strongPasswordCheckerII():\n\n    def strongPasswordCheckerII(self, password: str) -> bool:\n        if any((c.islower() for c in password)):\n            return False\n        return len(password) >= 8 and any(('!@#$%^&*()-+'.find(c) != -1 for c in password))\n    solution = Solution()\n    print(solution.strongPasswordCheckerII('abc!'))"}}
{"task_num": 2301, "task_title": "Match Substring After Replacement", "func_name": "matchReplacement", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def matchReplacement(self, s: str, sub: str, mappings: List[List[str]]) -> bool:\n    isMapped = [[False] * 128 for _ in range(128)]\n\n    for old, new in mappings:\n      isMapped[ord(old)][ord(new)] = True\n\n    for i in range(len(s)):\n      if self._canTransform(s, i, sub, isMapped):\n        return True\n\n    return False\n\n  def _canTransform(self, s: str, start: int, sub: str, isMapped: List[List[bool]]) -> bool:\n    if start + len(sub) > len(s):\n      return False\n\n    for i in range(len(sub)):\n      a = sub[i]\n      b = s[start + i]\n      if a != b and not isMapped[ord(a)][ord(b)]:\n        return False\n\n    return True\n", "tests": {"20": "def test_matchReplacement():\n    solution = Solution()\n\n    def test_input():\n        s = 'aa'\n        sub = 'a'\n        mappings = [['a', 'b'], ['b', 'c']]", "26": "def test_matchReplacement():\n\n    class Solution:\n\n        def matchReplacement(self, s: str, sub: str, mappings: List[List[str]]) -> bool:\n            isMapped = [[False] * 128 for _ in range(128)]\n            for (old, new) in mappings:\n                isMapped[ord(old)][ord(new)] = True\n            for i in range(len(s)):\n                if self._canTransform(s, i, sub, isMapped):\n                    return True\n            return False\n\n        def _canTransform(self, s: str, start: int, sub: str, isMapped: List[List[bool]]) -> bool:\n            if start + len(sub) > len(s):\n                return False\n            for i in range(len(sub)):\n                a = sub[i]\n                b = s[start + i]\n                if a != b and (not isMapped[ord(a)][ord(b)]):\n                    return False\n            return True\n    solution = Solution()\n    print(solution.matchReplacement('abc', 'abcd', [['a', 'b']]))", "32": "def test_matchReplacement():\n    solution = Solution()\n\n    def test_case():\n        s = 'abcd'\n        sub = 'abcde'\n        mappings = [['a', 'e'], ['b', 'c']]"}}
{"task_num": 2322, "task_title": "Minimum Score After Removals on a Tree", "func_name": "minimumScore", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Set\n\nclass Solution:\n  def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\n    n = len(nums)\n    xors = functools.reduce(lambda x, y: x ^ y, nums)\n    subXors = nums[:]\n    tree = [[] for _ in range(n)]\n    children = [{i} for i in range(n)]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, parent: int) -> Tuple[int, Set[int]]:\n      for v in tree[u]:\n        if v == parent:\n          continue\n        vXor, vChildren = dfs(v, u)\n        subXors[u] ^= vXor\n        children[u] |= vChildren\n      return subXors[u], children[u]\n\n    dfs(0, -1)\n\n    ans = math.inf\n    for i in range(len(edges)):\n      a, b = edges[i]\n      if b in children[a]:\n        a, b = b, a\n      for j in range(i):\n        c, d = edges[j]\n        if d in children[c]:\n          c, d = d, c\n\n        if c in children[a] and a != c:\n          cands = [subXors[c], subXors[a] ^ subXors[c], xors ^ subXors[a]]\n        elif a in children[c] and a != c:\n          cands = [subXors[a], subXors[c] ^ subXors[a], xors ^ subXors[c]]\n        else:\n          cands = [subXors[a], subXors[c], xors ^ subXors[a] ^ subXors[c]]\n        ans = min(ans, max(cands) - min(cands))\n\n    return ans\n", "tests": {"26": "def test_minimumScore(self):\n\n    class Solution:\n\n        def dfs(self, u: int, parent: int) -> Tuple[int, Set[int]]:\n            for v in self.tree[u]:\n                if v == parent:\n                    return (0, {u})\n                (vXor, vChildren) = self.dfs(v, u)\n                self.subXors[u] ^= vXor\n                self.children[u] |= vChildren\n            return (self.subXors[u], self.children[u])\n\n        def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\n            n = len(nums)\n            xors = functools.reduce(lambda x, y: x ^ y, nums)\n            self.subXors = [0] * n\n            self.tree = [[] for _ in range(n)]\n            self.children = [{i} for i in range(n)]\n            for (u, v) in edges:\n                self.tree[u].append(v)\n                self.tree[v].append(u)\n            self.dfs(0, -1)\n            ans = math.inf\n            for i in range(len(edges)):\n                (a, b) = edges[i]\n                if b in self.children[a]:\n                    (a, b) = (b, a)\n                for j in range(i):\n                    (c, d) = edges[j]\n                    if d in self.children[c]:\n                        (c, d) = (d, c)\n                    if c in self.children[a] and a != c:\n                        cands = [self.subXors[c], self.subXors[a] ^ self.subXors[c], xors ^ self.subXors[a]]\n                    elif a in self.children[c] and a != c:\n                        cands = [self.subXors[a], self.subXors[c] ^ self.subXors[a], xors ^ self.subXors[c]]\n                    else:\n                        cands = [self.subXors[a], self.subXors[c], xors ^ self.subXors[a] ^ self.subXors[c]]\n                    ans = min(ans, max(cands) - min(cands))\n            return ans\n    solution = Solution()\n    nums = [1, 2]\n    edges = [[0, 1]]\n    self.assertEqual(solution.minimumScore(nums, edges), 3)", "38": "def test_minimumScore():\n\n    def mock_dfs(tree, children, u, parent):\n        for v in tree[u]:\n            if v == parent:\n                continue\n            _ = mock_dfs(tree, children, v, u)\n            subXors[u] ^= _\n            children[u] |= {v}\n        return None\n    solution = Solution()\n    nums = [1, 2, 3]\n    edges = [[0, 1], [1, 2]]\n    tree = [[] for _ in range(len(nums))]\n    children = [{i} for i in range(len(nums))]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    mock_dfs(tree, children, 0, -1)\n    subXors = [x ^ y for (x, y) in zip([2] * len(edges), [3] * len(edges))]\n    assert solution.minimumScore(nums, edges) == max(subXors) - min(subXors)", "42": "def test_minimumScore():\n\n    def helper(n, edges):\n        return min((max(a ^ b, a ^ c, a ^ (c ^ b)) - min(a ^ b, a ^ c, a ^ (c ^ b)) for (a, b) in edges for (c, d) in edges if d != b and d != c))\n    solution = Solution()\n    print(solution.minimumScore([2, 3], [[0, 1], [1, 2]]))", "45": "def test_minimumScore(self):\n    nums = [4, 5, 7]\n    edges = [[0, 1], [1, 2]]\n    self.assertEqual(solution.minimumScore(nums, edges), 6)", "47": "def test_minimumScore():\n\n    class Solution:\n\n        def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\n            n = len(nums)\n            xors = functools.reduce(lambda x, y: x ^ y, nums)\n            subXors = nums[:]\n            tree = [[] for _ in range(n)]\n            children = [{i} for i in range(n)]\n            for (u, v) in edges:\n                tree[u].append(v)\n                tree[v].append(u)\n\n            def dfs(u: int, parent: int) -> Tuple[int, Set[int]]:\n                for v in tree[u]:\n                    if v == parent:\n                        continue\n                    (vXor, vChildren) = dfs(v, u)\n                    subXors[u] ^= vXor\n                    children[u] |= vChildren\n                return (subXors[u], children[u])\n            dfs(0, -1)\n            ans = math.inf\n            for i in range(len(edges)):\n                (a, b) = edges[i]\n                if b in children[a]:\n                    (a, b) = (b, a)\n                for j in range(i):\n                    (c, d) = edges[j]\n                    if d in children[c]:\n                        (c, d) = (d, c)\n                    if c in children[a] and a != c:\n                        cands = [subXors[c], subXors[a] ^ subXors[c], xors ^ subXors[a]]\n                    elif a in children[c] and a != c:\n                        cands = [subXors[a], subXors[c] ^ subXors[a], xors ^ subXors[c]]\n                    else:\n                        cands = [subXors[a], subXors[c], xors ^ subXors[a] ^ subXors[c]]\n                    ans = min(ans, max(cands) - min(cands))\n            return ans\n    solution = Solution()\n    nums = [4, 5, 7]\n    edges = [[0, 1], [1, 2]]\n    print(solution.minimumScore(nums, edges))", "49": "def test_minimumScore(self):\n    class Solution:\n        def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\n            # existing function implementation here...\n\n    solution = Solution()\n    nums = [4, 5, 7]\n    edges = [[0,1],[1,2]]\n    self.assertEqual(solution.minimumScore(nums, edges), 6)"}}
{"task_num": 2332, "task_title": "The Latest Time to Catch a Bus", "func_name": "latestTimeCatchTheBus", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\n    buses.sort()\n    passengers.sort()\n\n    if passengers[0] > buses[-1]:\n      return buses[-1]\n\n    ans = passengers[0] - 1\n    i = 0\n    j = 0\n    while i < len(buses):\n      arrived = 0\n      while arrived < capacity and j < len(passengers) and passengers[j] <= buses[i]:\n        if j > 0 and passengers[j] != passengers[j - 1] + 1:\n          ans = passengers[j] - 1\n        j += 1\n        arrived += 1\n\n      if arrived < capacity and j > 0 and passengers[j - 1] != buses[i]:\n        ans = buses[i]\n      i += 1\n\n    return ans\n", "tests": {"17": "def test_latestTimeCatchTheBus():\n    solution = Solution()\n    buses = [10, 20, 30]\n    passengers = []\n    capacity = 3\n    expected_result = 29\n    assert solution.latestTimeCatchTheBus(buses, passengers, capacity) == expected_result", "26": "def test_latestTimeCatchTheBus():\n    solution = Solution()\n    buses = [2, 3, 5]\n    passengers = [2, 7, 6, 1, 4]\n    capacity = 2\n    print(solution.latestTimeCatchTheBus(buses, passengers, capacity))", "31": "def test_latestTimeCatchTheBus():\n\n    def latestTimeCatchTheBus(buses, passengers, capacity):\n        buses.sort()\n        passengers.sort()\n        if passengers[0] > buses[-1]:\n            return buses[-1]\n        ans = passengers[0] - 1\n        i = 0\n        j = 0\n        while i < len(buses):\n            arrived = 0\n            while arrived < capacity and j < len(passengers) and (passengers[j] <= buses[i]):\n                if j > 0 and passengers[j] != passengers[j - 1] + 1:\n                    ans = passengers[j] - 1\n                j += 1\n                arrived += 1\n            if arrived < capacity and j > 0 and (passengers[j - 1] != buses[i]):\n                return buses[i]\n            i += 1\n        return ans\n    solution = Solution()\n    print(latestTimeCatchTheBus([3, 7, 19], [20, 1, 15, 6], 3))"}}
{"task_num": 2337, "task_title": "Move Pieces to Obtain a String", "func_name": "canChange", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def canChange(self, start: str, target: str) -> bool:\n    n = len(start)\n    i = 0\n    j = 0\n\n    while i <= n and j <= n:\n      while i < n and start[i] == '_':\n        i += 1\n      while j < n and target[j] == '_':\n        j += 1\n      if i == n or j == n:\n        return i == n and j == n\n      if start[i] != target[j]:\n        return False\n      if start[i] == 'R' and i > j:\n        return False\n      if start[i] == 'L' and i < j:\n        return False\n      i += 1\n      j += 1\n\n    return True\n", "tests": {"23": "def test_canChange():\n\n    class Solution:\n\n        def canChange(self, start: str, target: str) -> bool:\n            n = len(start)\n            i = 0\n            j = 0\n            while i <= n and j <= n:\n                while i < n and start[i] == '_':\n                    i += 1\n                while j < n and target[j] == '_':\n                    j += 1\n                if i > n or j > n:\n                    return False\n                if start[i] != target[j]:\n                    return False\n                if start[i] == 'R' and i <= j:\n                    return False\n                if start[i] == 'L' and i >= j:\n                    return False\n                i += 1\n                j += 1\n            return True\n    solution = Solution()\n    print(solution.canChange('_RL__LR_', 'RLLRLLLR_'))", "25": "def test_canChange():\n    solution = Solution()\n    print(solution.canChange('RL', 'LR'))", "27": "def test_canChange():\n    solution = Solution()\n    print(solution.canChange('R_L', 'R__L'))", "29": "def test_canChange():\n\n    class Solution:\n\n        def canChange(self, start: str, target: str) -> bool:\n            n = len(start)\n            i = 0\n            j = 0\n            while i <= n and j <= n:\n                while i < n and start[i] == '_':\n                    i += 1\n                while j < n and target[j] == '_':\n                    j += 1\n                if i == n or j == n:\n                    return i == n and j == n\n                if start[i] != target[j]:\n                    return False\n                if start[i] == 'R' and i > j:\n                    return False\n                if start[i] == 'L' and start.find('L', 0, i) < target.find('L', 0, j):\n                    return False\n                i += 1\n                j += 1\n            return True\n    solution = Solution()\n    print(solution.canChange('RL', 'LR'))"}}
{"task_num": 2392, "task_title": "Build a Matrix With Conditions", "func_name": "buildMatrix", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\n    rowOrder = self._topologicalSort(rowConditions, k)\n    if not rowOrder:\n      return []\n\n    colOrder = self._topologicalSort(colConditions, k)\n    if not colOrder:\n      return []\n\n    ans = [[0] * k for _ in range(k)]\n    nodeToRowIndex = [0] * (k + 1)\n\n    for i, node in enumerate(rowOrder):\n      nodeToRowIndex[node] = i\n\n    for j, node in enumerate(colOrder):\n      i = nodeToRowIndex[node]\n      ans[i][j] = node\n\n    return ans\n\n  def _topologicalSort(self, conditions: List[List[int]], n: int) -> List[int]:\n    order = []\n    graph = [[] for _ in range(n + 1)]\n    inDegrees = [0] * (n + 1)\n\n    for u, v in conditions:\n      graph[u].append(v)\n      inDegrees[v] += 1\n\n    q = collections.deque([i for i in range(1, n + 1) if inDegrees[i] == 0])\n\n    while q:\n      u = q.popleft()\n      order.append(u)\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    if len(order) == n:\n      return order\n    else:\n      return []\n", "tests": {"15": "def test_buildMatrix(self):\n\n    class Solution:\n\n        def _topologicalSort(self, conditions: List[List[int]], n: int) -> List[int]:\n            order = []\n            graph = [[] for _ in range(n + 1)]\n            inDegrees = [0] * (n + 1)\n            for (u, v) in conditions:\n                graph[u].append(v)\n                inDegrees[v] += 1\n            q = collections.deque([i for i in range(1, n + 1) if inDegrees[i] == 0])\n            while q:\n                u = q.popleft()\n                order.append(u)\n                for v in graph[u]:\n                    inDegrees[v] -= 1\n                    if inDegrees[v] == 0:\n                        q.append(v)\n            if len(order) == n:\n                return order\n            else:\n                return []\n\n        def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[int]) -> List[List[int]]:\n            rowOrder = self._topologicalSort(rowConditions, k)\n            if not rowOrder:\n                return []\n            colOrder = self._topologicalSort(colConditions, k)\n            if not colOrder:\n                return []\n            ans = [[0] * k for _ in range(k)]\n            nodeToRowIndex = [0] * (k + 1)\n            for (i, node) in enumerate(rowOrder):\n                nodeToRowIndex[node] = i\n            for (j, node) in enumerate(colOrder):\n                i = nodeToRowIndex[node]\n                ans[i][j] = node\n            return ans\n    solution = Solution()\n    self.assertEqual(solution.buildMatrix(2, [[1, 0], [0, 1]], []), [[1, 2], [2, 1]])", "19": "def test_buildMatrix():\n\n    class Solution:\n\n        def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\n            pass\n    solution = Solution()\n    assert solution.buildMatrix(2, [[1, 2], [2, 1]], []) == []", "50": "def test_buildMatrix(self):\n    solution = Solution()\n    rowConditions = [[1, 2], [3, 4]]\n    colConditions = [[2, 1], [4, 3]]", "53": "def test_buildMatrix():\n\n    class Solution:\n\n        def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\n            pass\n    solution = Solution()\n    rowConditions = [[1, 3], [2, 4]]\n    colConditions = [[1, 3], [2, 4]]\n    expected_result = [[2, 1, 0, 0], [4, 3, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]\n    result = solution.buildMatrix(4, rowConditions, colConditions)", "55": "def test_buildMatrix():\n\n    class Solution:\n\n        def _topologicalSort(self, conditions: List[List[int]], n: int) -> List[int]:\n            order = []\n            graph = [[] for _ in range(n + 1)]\n            inDegrees = [0] * (n + 1)\n            for (u, v) in conditions:\n                graph[u].append(v)\n                inDegrees[v] += 1\n            q = collections.deque([i for i in range(1, n + 1) if inDegrees[i] == 0])\n            while q:\n                u = q.popleft()\n                order.append(u)\n                for v in graph[u]:\n                    inDegrees[v] -= 1\n                    if inDegrees[v] == 0:\n                        q.append(v)\n            return order\n\n        def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[int]) -> List[List[int]]:\n            rowOrder = self._topologicalSort(rowConditions, k)\n            if not rowOrder:\n                return []\n            colOrder = self._topologicalSort(colConditions, k)\n            if not colOrder:\n                return []\n            ans = [[0] * k for _ in range(k)]\n            nodeToRowIndex = [0] * (k + 1)\n            for (i, node) in enumerate(rowOrder):\n                nodeToRowIndex[node] = i\n            for (j, node) in enumerate(colOrder):\n                i = nodeToRowIndex[node]\n                ans[i][j] = node\n            return ans\n    solution = Solution()\n    k = 3\n    rowConditions = [[1, 2], [2, 3]]\n    colConditions = [[1, 2], [2, 3]]\n    assert sorted(solution.buildMatrix(k, rowConditions, colConditions)) == [[[1, 0, 0], [2, 3, 0]], [[0, 1, 2], [0, 0, 3]]]"}}
{"task_num": 2437, "task_title": "Number of Valid Clock Times", "func_name": "countTime", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countTime(self, time: str) -> int:\n    ans = 1\n    if time[3] == '?':\n      ans *= 6\n    if time[4] == '?':\n      ans *= 10\n\n    if time[0] == '?' and time[1] == '?':\n      return ans * 24\n    if time[0] == '?':\n      if time[1] < '4':\n        return ans * 3\n      else:\n        return ans * 2\n    if time[1] == '?':\n      if time[0] == '2':\n        return ans * 4\n      else:\n        return ans * 10\n    return ans\n", "tests": {"15": "def test_countTime():\n\n    def test1():\n        time = '12:?'\n        assert solution.countTime(time) == 60, f'Expected countTime({time}) to return 60, but got {solution.countTime(time)}'", "17": "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('11:?') == 100, 'Test failed'", "20": "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('0?') == 24", "22": "def test_countTime():\n    solution = Solution()\n    print(solution.countTime('0:?'))", "23": "def test_countTime():\n    solution = Solution()\n    print(solution.countTime('1:?'))", "25": "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('1:4') == 20, f\"Expected countTime('1:4') to return 20 but got {solution.countTime('1:4')}\"", "27": "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('1:??:59') == 60", "28": "def test_countTime():\n    solution = Solution()\n    print(solution.countTime('2:?'))", "30": "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('2:?') == 50"}}
{"task_num": 2456, "task_title": "Most Popular Video Creator", "func_name": "mostPopularCreator", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Creator:\n  def __init__(self, popularity: int, videoId: str, maxView: int):\n    self.popularity = popularity\n    self.videoId = videoId\n    self.maxView = maxView\n\n\nclass Solution:\n  def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\n    ans = []\n    maxPopularity = 0\n    nameToCreator = {}\n\n    for name, id, view in zip(creators, ids, views):\n      if name not in nameToCreator:\n        nameToCreator[name] = Creator(view, id, view)\n        maxPopularity = max(maxPopularity, view)\n        continue\n      creator = nameToCreator[name]\n      creator.popularity += view\n      maxPopularity = max(maxPopularity, creator.popularity)\n      if creator.maxView < view or creator.maxView == view and creator.videoId > id:\n        creator.videoId = id\n        creator.maxView = view\n\n    for name, creator in nameToCreator.items():\n      if creator.popularity == maxPopularity:\n        ans.append([name, creator.videoId])\n\n    return ans\n", "tests": {"26": "def test_mostPopularCreator():\n\n    def mostPopularCreator(creators, ids, views):\n        ans = []\n        maxPopularity = 0\n        nameToCreator = {}\n        for (name, id, view) in zip(creators, ids, views):\n            if name not in nameToCreator:\n                nameToCreator[name] = Creator(view, id, view)\n                maxPopularity = max(maxPopularity, view)\n                continue\n            creator = nameToCreator[name]\n            creator.popularity += view\n            maxPopularity = max(maxPopularity, creator.popularity)\n            if creator.maxView < view or (creator.maxView == view and creator.videoId > id):\n                creator.videoId = id\n                creator.maxView = view\n        for (name, creator) in nameToCreator.items():\n            if creator.popularity == maxPopularity:\n                ans.append([name, creator.videoId])\n        return ans\n    solution = Solution()\n    print(mostPopularCreator(['user1', 'user2'], ['video1', 'video2'], [1000, 2000]))", "27": "def test_mostPopularCreator(self):\n    solution = Solution()\n    creators = ['Alice', 'Bob', 'Charlie']\n    ids = ['video1', 'video2', 'video3']\n    views = [10, 20, 30]\n    self.assertEqual(solution.mostPopularCreator(creators, ids, views), [['Charlie', 'video3']])", "28": "def test_mostPopularCreator():\n\n    def mostPopularCreator(creators, ids, views):\n        ans = []\n        maxPopularity = 0\n        nameToCreator = {}\n        for (name, id, view) in zip(creators, ids, views):\n            if name not in nameToCreator:\n                nameToCreator[name] = Creator(view, id, view)\n                maxPopularity = max(maxPopularity, view)\n                continue\n            creator = nameToCreator[name]\n            creator.popularity += view\n            maxPopularity = max(maxPopularity, creator.popularity)\n            if creator.maxView < view or (creator.maxView == view and creator.videoId > id):\n                creator.videoId = id\n                creator.maxView = view\n        for (name, creator) in nameToCreator.items():\n            if creator.popularity == maxPopularity:\n                ans.append([name, creator.videoId])\n        return ans\n    solution = Solution()\n    creators = ['Alice', 'Bob']\n    ids = ['video1', 'video2']\n    views = [100, 200]\n    assert mostPopularCreator(creators, ids, views) == [['Bob', 'video2']]", "33": "def test_mostPopularCreator():\n    solution = Solution()\n    creators = ['sachin', 'sachin', 'anand', 'anand', 'anand']\n    ids = ['123', '123', '456', '456', '456']\n    views = [20, 10, 25, 20, 15]\n    assert solution.mostPopularCreator(creators, ids, views) == [['sachin', '123'], ['anand', '456']]", "34": "def test_mostPopularCreator():\n    solution = Solution()\n    creators = ['a', 'b']\n    ids = ['id1', 'id2']\n    views = [10, 20]\n    assert sorted(solution.mostPopularCreator(creators, ids, views)) == [['a', 'id1']]", "38": "def test_mostPopularCreator(self):\n    solution = Solution()\n    creators = ['user1', 'user2']\n    ids = ['video1', 'video2']\n    views = [100, 200]\n    expectedOutput = [['user2', 'video2']]\n    self.assertEqual(solution.mostPopularCreator(creators, ids, views), expectedOutput)"}}
{"task_num": 2462, "task_title": "Total Cost to Hire K Workers", "func_name": "totalCost", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\n    ans = 0\n    i = 0\n    j = len(costs) - 1\n    minHeapL = []\n    minHeapR = []\n\n    for _ in range(k):\n      while len(minHeapL) < candidates and i <= j:\n        heapq.heappush(minHeapL, costs[i])\n        i += 1\n      while len(minHeapR) < candidates and i <= j:\n        heapq.heappush(minHeapR, costs[j])\n        j -= 1\n      if not minHeapL:\n        ans += heapq.heappop(minHeapR)\n      elif not minHeapR:\n        ans += heapq.heappop(minHeapL)\n      elif minHeapL[0] <= minHeapR[0]:\n        ans += heapq.heappop(minHeapL)\n      else:\n        ans += heapq.heappop(minHeapR)\n\n    return ans\n", "tests": {"27": "def test_totalCost(self):\n    costs = [3, 2, 7, 7, 1, 2]\n    k = 4\n    candidates = 2\n    self.assertEqual(solution.totalCost(costs, k, candidates), 12)", "29": "def test_totalCost():\n    costs = [3, 2, 7, 7, 1]\n    k = 4\n    candidates = 2\n    assert solution.totalCost(costs, k, candidates) == 12", "31": "def test_totalCost(self):\n\n    class Solution:\n\n        def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\n            ans = 0\n            i = 0\n            j = len(costs) - 1\n            minHeapL = []\n            minHeapR = []\n            for _ in range(k):\n                while len(minHeapL) < candidates and i <= j:\n                    heapq.heappush(minHeapL, costs[i])\n                    i += 1\n                while len(minHeapR) < candidates and i <= j:\n                    heapq.heappush(minHeapR, costs[j])\n                    j -= 1\n                if not minHeapL:\n                    ans += heapq.heappop(minHeapR)\n                elif not minHeapR:\n                    ans += heapq.heappop(minHeapL)\n                elif minHeapL[0] <= minHeapR[0]:\n                    ans += heapq.heappop(minHeapL)\n                else:\n                    ans += heapq.heappop(minHeapR)\n            return ans\n    solution = Solution()\n    costs = [3, 2, 7, 7, 1]\n    k = 5\n    candidates = 2\n    self.assertEqual(solution.totalCost(costs, k, candidates), 11)", "33": "def test_totalCost(self):\n    solution = Solution()\n    costs = [10, 2, 5, 1]\n    k = 3\n    candidates = 2\n    self.assertEqual(solution.totalCost(costs, k, candidates), 22)"}}
{"task_num": 2467, "task_title": "Most Profitable Path in a Tree", "func_name": "mostProfitablePath", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\n    n = len(amount)\n    tree = [[] for _ in range(n)]\n    parent = [0] * n\n    aliceDist = [-1] * n\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, prev: int, d: int) -> None:\n      parent[u] = prev\n      aliceDist[u] = d\n      for v in tree[u]:\n        if aliceDist[v] == -1:\n          dfs(v, u, d + 1)\n\n    dfs(0, -1, 0)\n\n    u = bob\n    bobDist = 0\n    while u != 0:\n      if bobDist < aliceDist[u]:\n        amount[u] = 0\n      elif bobDist == aliceDist[u]:\n        amount[u] //= 2\n      u = parent[u]\n      bobDist += 1\n\n    return self._getMoney(tree, 0, -1, amount)\n\n  def _getMoney(self, tree: List[List[int]], u: int, prev: int, amount: List[int]) -> int:\n    if len(tree[u]) == 1 and tree[u][0] == prev:\n      return amount[u]\n\n    maxPath = -math.inf\n    for v in tree[u]:\n      if v != prev:\n        maxPath = max(maxPath, self._getMoney(tree, v, u, amount))\n\n    return amount[u] + maxPath\n", "tests": {"27": "def test_mostProfitablePath():\n\n    class Solution:\n\n        def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\n            n = len(amount)\n            tree = [[] for _ in range(n)]\n            parent = [0] * n\n            aliceDist = [-1] * n\n            for (u, v) in edges:\n                tree[u].append(v)\n                tree[v].append(u)\n\n            def dfs(u: int, prev: int, d: int) -> None:\n                if 4 <= d < 7 and aliceDist[2] == -1:\n                    parent[2] = prev\n                    aliceDist[2] = d\n                    for v in tree[2]:\n                        if aliceDist[v] == -1:\n                            dfs(v, 2, d + 1)\n            edges = [[0, 1], [1, 2]]\n            bob = 1\n            amount = [-5, 10, -15]\n            dfs(0, -1, 0)\n            u = bob\n            bobDist = 0\n            while u != 0:\n                if bobDist < aliceDist[u]:\n                    amount[u] = 0\n                elif bobDist == aliceDist[u]:\n                    amount[u] //= 2\n                u = parent[u]\n                bobDist += 1\n            return self._getMoney(tree, 0, -1, amount)\n    solution = Solution()\n    print(solution.mostProfitablePath([[0, 1], [1, 2]], 1, [-5, 10, -15]))", "35": "def test_mostProfitablePath():\n\n    class Solution:\n\n        def mostProfitablePath(self, edges, bob, amount):\n            n = len(amount)\n            tree = [[] for _ in range(n)]\n            parent = [0] * n\n            aliceDist = [-1] * n\n            for (u, v) in edges:\n                tree[u].append(v)\n                tree[v].append(u)\n\n            def dfs(u: int, prev: int, d: int) -> None:\n                parent[u] = prev\n                aliceDist[u] = d\n                for v in tree[u]:\n                    if aliceDist[v] == -1:\n                        dfs(v, u, d + 1)\n            dfs(0, -1, 0)\n            u = bob\n            bobDist = 0\n            while u != 0:\n                if bobDist < aliceDist[u]:\n                    amount[u] = 0\n                elif bobDist == aliceDist[u]:\n                    amount[u] //= 2\n                u = parent[u]\n                bobDist += 1\n            return self._getMoney(tree, 0, -1, amount)\n\n        def _getMoney(self, tree: List[List[int]], u: int, prev: int, amount: List[int]) -> int:\n            if len(tree[u]) == 1 and tree[u][0] == prev:\n                return amount[u]\n            maxPath = -float('inf')\n            for v in tree[u]:\n                if v != prev:\n                    maxPath = max(maxPath, self._getMoney(tree, v, u, amount))\n            return amount[u] + maxPath\n    solution = Solution()\n    edges = [[1, 0], [2, 0]]\n    bob = 1\n    amount = [-3, -5, -6]\n    assert solution.mostProfitablePath(edges, bob, amount) == -7", "37": "def test_mostProfitablePath():\n    def helper(edges, bob):", "45": "def test_mostProfitablePath(self):\n    class Solution:\n        def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\n            # ... (same implementation as before)\n\n    solution = Solution()\n    n = 3\n    edges = [[0,1],[1,2]]\n    bob = 1\n    amount = [10,-20,5]\n\n    self.assertEqual(solution.mostProfitablePath(edges, bob, amount), -15)", "50": "def test_mostProfitablePath():\n\n    class Solution:\n\n        def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\n            n = len(amount)\n            tree = [[] for _ in range(n)]\n            parent = [0] * n\n            aliceDist = [-1] * n\n            for (u, v) in edges:\n                tree[u].append(v)\n                tree[v].append(u)\n\n            def dfs(u: int, prev: int, d: int) -> None:\n                parent[u] = prev\n                aliceDist[u] = d\n                for v in tree[u]:\n                    if aliceDist[v] == -1:\n                        dfs(v, u, d + 1)\n            dfs(0, -1, 0)\n            u = bob\n            bobDist = 0\n            while u != 0:\n                if bobDist < aliceDist[u]:\n                    amount[u] = 0\n                elif bobDist == aliceDist[u]:\n                    amount[u] //= 2\n                u = parent[u]\n                bobDist += 1\n            return self._getMoney(tree, 0, -1, amount)\n\n        def _getMoney(self, tree: List[List[int]], u: int, prev: int, amount: List[int]) -> int:\n            if len(tree[u]) == 1 and tree[u][0] == prev:\n                return amount[u]\n            maxPath = -math.inf\n            for v in tree[u]:\n                if v != prev:\n                    maxPath = max(maxPath, self._getMoney(tree, v, u, amount))\n            return amount[u] + maxPath\n    solution = Solution()\n    edges = [[0, 1], [1, 2], [3, 4]]\n    bob = 1\n    amount = [10, -5, 100, 1]\n    assert solution.mostProfitablePath(edges, bob, amount) == 105"}}
{"task_num": 2499, "task_title": "Minimum Total Cost to Make Arrays Unequal", "func_name": "minimumTotalCost", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\n    n = len(nums1)\n    ans = 0\n    maxFreq = 0\n    maxFreqNum = 0\n    shouldBeSwapped = 0\n    conflictedNumCount = [0] * (n + 1)\n\n    for i, (num1, num2) in enumerate(zip(nums1, nums2)):\n      if num1 == num2:\n        conflictedNum = num1\n        conflictedNumCount[conflictedNum] += 1\n        if conflictedNumCount[conflictedNum] > maxFreq:\n          maxFreq = conflictedNumCount[conflictedNum]\n          maxFreqNum = conflictedNum\n        shouldBeSwapped += 1\n        ans += i\n\n    for i, (num1, num2) in enumerate(zip(nums1, nums2)):\n      if maxFreq * 2 <= shouldBeSwapped:\n        break\n      if num1 == num2:\n        continue\n\n      if num1 == maxFreqNum or num2 == maxFreqNum:\n        continue\n      shouldBeSwapped += 1\n      ans += i\n\n    if maxFreq * 2 > shouldBeSwapped:\n      return -1\n    else:\n      return ans\n", "tests": {"22": "def test_minimumTotalCost(self):\n\n    class Solution:\n\n        def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\n            n = len(nums1)\n            ans = 0\n            maxFreq = 0\n            maxFreqNum = 0\n            shouldBeSwapped = 0\n            conflictedNumCount = [0] * (n + 1)\n            for (i, (num1, num2)) in enumerate(zip(nums1, nums2)):\n                if num1 == num2:\n                    conflictedNum = num1\n                    conflictedNumCount[conflictedNum] += 1\n                    if conflictedNumCount[conflictedNum] > maxFreq:\n                        maxFreq = conflictedNumCount[conflictedNum]\n                        maxFreqNum = conflictedNum\n                    shouldBeSwapped += 1\n                    ans += i\n            for (i, (num1, num2)) in enumerate(zip(nums1, nums2)):\n                if maxFreq * 2 <= shouldBeSwapped:\n                    break\n                if num1 == num2:\n                    continue\n                if num1 == maxFreqNum or num2 == maxFreqNum:\n                    continue\n                shouldBeSwapped += 1\n                ans += i\n            if maxFreq * 2 > shouldBeSwapped:\n                return -1\n            else:\n                return ans\n    solution = Solution()\n    nums1 = [0, 1]\n    nums2 = [1, 0]\n    self.assertEqual(solution.minimumTotalCost(nums1, nums2), -1)", "23": "def test_minimumTotalCost():\n\n    class Solution:\n\n        def minimumTotalCost(self, nums1, nums2):\n            if len(nums1) != len(nums2):\n                return -1\n            conflictedNumCount = [0] * (max(max(nums1), max(nums2)) + 1)\n            for i in range(len(nums1)):\n                conflictedNumCount[nums1[i]] += 1\n                conflictedNumCount[nums2[i]] += 1\n            return sum((i for i in range(len(nums1)) if nums1[i] != nums2[i]))\n    solution = Solution()\n    print(solution.minimumTotalCost([1, 2, 3], [4, 5, 6]))", "24": "def test_minimumTotalCost():\n\n    class Solution:\n\n        def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\n            n = len(nums1)\n            ans = 0\n            maxFreq = 0\n            maxFreqNum = 0\n            shouldBeSwapped = 0\n            conflictedNumCount = [0] * (n + 1)\n            for (i, (num1, num2)) in enumerate(zip(nums1, nums2)):\n                if num1 == num2:\n                    conflictedNum = num1\n                    conflictedNumCount[conflictedNum] += 1\n                    if conflictedNumCount[conflictedNum] > maxFreq:\n                        maxFreq = conflictedNumCount[conflictedNum]\n                        maxFreqNum = conflictedNum\n                    shouldBeSwapped += 1\n                    ans += i\n            return ans\n    solution = Solution()\n    print(solution.minimumTotalCost([2, 4, 6, 8], [5, 3, 7, 9]))", "25": "def test_minimumTotalCost():\n\n    class Solution:\n\n        def minimumTotalCost(self, nums1, nums2):\n            n = len(nums1)\n            ans = 0\n            maxFreq = 0\n            maxFreqNum = 0\n            shouldBeSwapped = 0\n            conflictedNumCount = [0] * (n + 1)\n            for (i, (num1, num2)) in enumerate(zip(nums1, nums2)):\n                if num1 == num2:\n                    conflictedNum = num1\n                    conflictedNumCount[conflictedNum] += 1\n                    if conflictedNumCount[conflictedNum] > maxFreq:\n                        maxFreq = conflictedNumCount[conflictedNum]\n                        maxFreqNum = conflictedNum\n                    shouldBeSwapped += 1\n                    ans += i\n            assert maxFreq == 2, 'maxFreq not updated correctly'\n    solution = Solution()\n    print(solution.minimumTotalCost([3, 4], [5, 6]))", "26": "def test_minimumTotalCost():\n\n    class Solution:\n\n        def minimumTotalCost(self, nums1, nums2):\n            n = len(nums1)\n            ans = 0\n            maxFreq = 0\n            maxFreqNum = 0\n            shouldBeSwapped = 0\n            conflictedNumCount = [0] * (n + 1)\n            for (i, (num1, num2)) in enumerate(zip([3, 5, 7], [3, 4, 7])):\n                if num1 == num2:\n                    conflictedNum = num1\n                    conflictedNumCount[conflictedNum] += 1\n                    if conflictedNumCount[conflictedNum] > maxFreq:\n                        maxFreq = conflictedNumCount[conflictedNum]\n                        maxFreqNum = conflictedNum\n                    shouldBeSwapped += 1\n                    ans += i\n            return ans\n    solution = Solution()\n    print(solution.minimumTotalCost([3, 5, 7], [3, 4, 7]))", "27": "def test_minimumTotalCost(self):\n\n    class Solution:\n\n        def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\n            n = len(nums1)\n            ans = 0\n            maxFreq = 0\n            maxFreqNum = 0\n            shouldBeSwapped = 0\n            conflictedNumCount = [0] * (n + 1)\n            for (i, (num1, num2)) in enumerate(zip([10, 20, 30], [10, 40, 50])):\n                if num1 == num2:\n                    conflictedNum = num1\n                    conflictedNumCount[conflictedNum] += 1\n                    if conflictedNumCount[conflictedNum] > maxFreq:\n                        maxFreq = conflictedNumCount[conflictedNum]\n                        maxFreqNum = conflictedNum\n                    shouldBeSwapped += 1\n                    ans += i\n    solution = Solution()\n    self.assertEqual(solution.minimumTotalCost([10, 20, 30], [10, 40, 50]), 5)", "28": "def test_minimumTotalCost():\n\n    def helper(nums1, nums2):\n        n = len(nums1)\n        for i in range(n):\n            if nums1[i] == nums2[i]:\n                return i\n        return -1\n    solution = Solution()\n    print(solution.minimumTotalCost([3, 5, 2], [4, 6, 1]))", "32": "def test_minimumTotalCost(self):\n    nums1 = [0, 3]\n    nums2 = [1, 4]\n    self.assertEqual(self.solution.minimumTotalCost(nums1, nums2), -1)", "34": "def test_minimumTotalCost():\n\n    def calculateMinimumTotalCost(nums1, nums2):\n        n = len(nums1)\n        ans = 0\n        maxFreq = 0\n        maxFreqNum = 0\n        shouldBeSwapped = 0\n        conflictedNumCount = [0] * (n + 1)\n        for (i, (num1, num2)) in enumerate(zip(nums1, nums2)):\n            if num1 == num2:\n                conflictedNum = num1\n                conflictedNumCount[conflictedNum] += 1\n                if conflictedNumCount[conflictedNum] > maxFreq:\n                    maxFreq = conflictedNumCount[conflictedNum]\n                    maxFreqNum = conflictedNum\n                shouldBeSwapped += 1\n                ans += i\n        for (i, (num1, num2)) in enumerate(zip(nums1, nums2)):\n            if maxFreq * 2 <= shouldBeSwapped:\n                break\n            if num1 == num2:\n                continue\n            if num1 == maxFreqNum or num2 == maxFreqNum:\n                continue\n            shouldBeSwapped += 1\n            ans += i\n        if maxFreq * 2 > shouldBeSwapped:\n            return -1\n        else:\n            return ans\n    assert calculateMinimumTotalCost([4, 10, 4, 1], [12, 5, 12, 3]) == 6", "37": "def test_minimumTotalCost():\n\n    class Solution:\n\n        def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\n            n = len(nums1)\n            ans = 0\n            maxFreq = 0\n            maxFreqNum = 0\n            shouldBeSwapped = 0\n            conflictedNumCount = [0] * (n + 1)\n            for (i, (num1, num2)) in enumerate(zip(nums1, nums2)):\n                if num1 == num2:\n                    conflictedNum = num1\n                    conflictedNumCount[conflictedNum] += 1\n                    if conflictedNumCount[conflictedNum] > maxFreq:\n                        maxFreq = conflictedNumCount[conflictedNum]\n                        maxFreqNum = conflictedNum\n                    shouldBeSwapped += 1\n                    ans += i\n            for (i, (num1, num2)) in enumerate(zip(nums1, nums2)):\n                if maxFreq * 2 <= shouldBeSwapped:\n                    break\n                if num1 == num2:\n                    continue\n                if num1 == maxFreqNum or num2 == maxFreqNum:\n                    continue\n                shouldBeSwapped += 1\n                ans += i\n            if maxFreq * 2 > shouldBeSwapped:\n                return -1\n            else:\n                return ans\n    solution = Solution()\n    print(solution.minimumTotalCost([1, 3, 5], [2, 4, 6]))", "42": "def test_minimumTotalCost():\n\n    class Solution:\n\n        def minimumTotalCost(self, nums1, nums2):\n            n = len(nums1)\n            ans = 0\n            maxFreq = 0\n            maxFreqNum = 0\n            shouldBeSwapped = 0\n            conflictedNumCount = [0] * (n + 1)\n            for (i, (num1, num2)) in enumerate(zip(nums1, nums2)):\n                if num1 == num2:\n                    conflictedNum = num1\n                    conflictedNumCount[conflictedNum] += 1\n                    if conflictedNumCount[conflictedNum] > maxFreq:\n                        maxFreq = conflictedNumCount[conflictedNum]\n                        maxFreqNum = conflictedNum\n                    shouldBeSwapped += 1\n                    ans += i\n            for (i, (num1, num2)) in enumerate(zip(nums1, nums2)):\n                if maxFreq * 2 <= shouldBeSwapped:\n                    break\n                if num1 == num2:\n                    continue\n                if num1 == maxFreqNum or num2 == maxFreqNum:\n                    continue\n                shouldBeSwapped += 1\n                ans += i\n            if maxFreq * 2 > shouldBeSwapped:\n                return -1\n            else:\n                return ans\n    solution = Solution()\n    print(solution.minimumTotalCost([1, 2, 3], [4, 5, 6]))", "44": "def test_minimumTotalCost():\n\n    class Solution:\n\n        def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\n            n = len(nums1)\n            ans = 0\n            maxFreq = 0\n            maxFreqNum = 0\n            shouldBeSwapped = 0\n            conflictedNumCount = [0] * (n + 1)\n            for (i, (num1, num2)) in enumerate(zip([1, 3, 5], [1, 4, 5])):\n                if num1 == num2:\n                    conflictedNum = num1\n                    conflictedNumCount[conflictedNum] += 1\n                    if conflictedNumCount[conflictedNum] > maxFreq:\n                        maxFreq = conflictedNumCount[conflictedNum]\n                        maxFreqNum = conflictedNum\n                    shouldBeSwapped += 1\n                    ans += i\n            for (i, (num1, num2)) in enumerate(zip(nums1, nums2)):\n                if maxFreq * 2 <= shouldBeSwapped:\n                    break\n                if num1 == num2:\n                    continue\n                if num1 == maxFreqNum or num2 == maxFreqNum:\n                    continue\n                shouldBeSwapped += 1\n                ans += i\n            if maxFreq * 2 > shouldBeSwapped:\n                return -1\n            else:\n                return ans\n    solution = Solution()\n    assert solution.minimumTotalCost([1, 3, 5], [1, 4, 5]) == 7"}}
{"task_num": 2503, "task_title": "Maximum Number of Points From Grid Queries", "func_name": "maxPoints", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, query: int):\n    self.queryIndex = queryIndex\n    self.query = query\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.query\n\n\nclass Solution:\n  def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    ans = [0] * len(queries)\n    minHeap = [(grid[0][0], 0, 0)]\n    seen = {(0, 0)}\n    accumulate = 0\n\n    for queryIndex, query in sorted([IndexedQuery(i, query) for i, query in enumerate(queries)], key=lambda iq: iq.query):\n      while minHeap:\n        val, i, j = heapq.heappop(minHeap)\n        if val >= query:\n          heapq.heappush(minHeap, (val, i, j))\n          break\n        accumulate += 1\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if (x, y) in seen:\n            continue\n          heapq.heappush(minHeap, (grid[x][y], x, y))\n          seen.add((x, y))\n      ans[queryIndex] = accumulate\n\n    return ans\n", "tests": {"35": "def test_maxPoints():\n\n    class Solution:\n\n        def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            m = len(grid)\n            n = len(grid[0])\n            ans = [0] * len(queries)\n            minHeap = [(grid[0][0], 0, 0)]\n            seen = {(0, 0)}\n            accumulate = 0\n            for (queryIndex, query) in sorted([IndexedQuery(i, query) for (i, query) in enumerate(queries)], key=lambda iq: iq.query):\n                while minHeap:\n                    (val, i, j) = heapq.heappop(minHeap)\n                    if val == 1 and (i, j) not in seen:\n                        seen.add((i, j))\n                        ans[queryIndex] += 1\n                    else:\n                        heapq.heappush(minHeap, (val, i, j))\n    import unittest\n\n    class TestSolution(unittest.TestCase):\n\n        def test_maxPoints(self):\n            solution = Solution()\n            grid = [[2, 5], [3, 7]]\n            queries = [4, 6]\n            self.assertEqual(solution.maxPoints(grid, queries), [0, 1])", "36": "def test_maxPoints():\n    solution = Solution()\n\n    def verify_result(grid, queries):\n        expected = [3, 2]\n        actual = solution.maxPoints(grid, queries)", "42": "def test_maxPoints():\n\n    def maxPoints(grid, queries):\n        dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n        m = len(grid)\n        n = len(grid[0])\n        ans = [0] * len(queries)\n        minHeap = [(grid[0][0], 0, 0)]\n        seen = {(0, 0)}\n        accumulate = 0\n        for (queryIndex, query) in sorted([IndexedQuery(i, query) for (i, query) in enumerate(queries)], key=lambda iq: iq.query):\n            while minHeap:\n                (val, i, j) = heapq.heappop(minHeap)\n                if val >= query:\n                    heapq.heappush(minHeap, (val, i, j))\n                    break\n                accumulate += 1\n                for (dx, dy) in dirs:\n                    x = i + dx\n                    y = j + dy\n                    if x < 0 or x == m or y < 0 or (y == n):\n                        continue\n                    heapq.heappush(minHeap, (grid[x][y], x, y))\n                    seen.add((x, y))\n            ans[queryIndex] = accumulate\n        return ans\n    solution = Solution()\n    grid = [[1]]\n    queries = [2]\n    print(maxPoints(grid, queries))", "44": "def test_maxPoints():\n    solution = Solution()\n    queries = [9]\n    grid = [[1, 3, 7], [2, 4, 6], [8, 5, 0], [4, 1, 8], [7, 2, 3]]\n    assert solution.maxPoints(grid, queries) == [11]"}}
{"task_num": 2508, "task_title": "Add Edges to Make Degrees of All Nodes Even", "func_name": "isPossible", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isPossible(self, n: int, edges: List[List[int]]) -> bool:\n    graph = [set() for _ in range(n)]\n\n    for u, v in edges:\n      graph[u - 1].add(v - 1)\n      graph[v - 1].add(u - 1)\n\n    oddNodes = [i for i, neighbor in enumerate(graph) if len(neighbor) & 1]\n    if not oddNodes:\n      return True\n    if len(oddNodes) == 2:\n      a, b = oddNodes\n      return any(a not in graph[i] and b not in graph[i] for i in range(n))\n    if len(oddNodes) == 4:\n      a, b, c, d = oddNodes\n      return (b not in graph[a] and d not in graph[c]) or (c not in graph[a] and d not in graph[b]) or (d not in graph[a] and c not in graph[b])\n    return False\n", "tests": {"21": "def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(3, [[1, 2], [2, 3]]), 'Test failed'", "23": "def test_isPossible():\n\n    class Solution:\n\n        def isPossible(self, n, edges):\n            graph = [set() for _ in range(n)]\n            for (u, v) in edges:\n                graph[u - 1].add(v - 1)\n                graph[v - 1].add(u - 1)\n            oddNodes = [i for (i, neighbor) in enumerate(graph) if len(neighbor) & 1]\n            if not oddNodes:\n                return True\n            if len(oddNodes) == 2:\n                (a, b) = oddNodes\n                return any((a not in graph[i] and b not in graph[i] for i in range(n)))\n            if len(oddNodes) == 4:\n                (a, b, c, d) = oddNodes\n                return b not in graph[a] and d not in graph[c] or (c not in graph[a] and d not in graph[b]) or (d not in graph[a] and c not in graph[b])\n            return False\n    solution = Solution()\n    assert solution.isPossible(4, [[1, 2], [3, 2], [2, 4]]) == True", "24": "def test_isPossible():\n    solution = Solution()\n    n = 5\n    edges = [[1, 2], [3, 4]]\n    assert solution.isPossible(n, edges) == True", "26": "def test_isPossible():\n    solution = Solution()\n\n    def test_case_1():\n        n = 4\n        edges = [[1, 2], [2, 3], [3, 4]]\n        assert solution.isPossible(n, edges) == True", "27": "def test_isPossible():\n\n    class StubSolution(Solution):\n\n        def isPossible(self, n: int, edges: List[List[int]]) -> bool:\n            self.calls = []\n            result = super().isPossible(n, edges)\n            self.calls.append(result)\n            return result\n    solution = StubSolution()\n    solution.isPossible(6, [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5]])"}}
{"task_num": 2523, "task_title": "Closest Prime Numbers in Range", "func_name": "closestPrimes", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def closestPrimes(self, left: int, right: int) -> List[int]:\n    isPrime = self._sieveEratosthenes(right + 1)\n    primes=[]\n    for i in range(left, right+1):\n      if isPrime[i]:\n        primes.append(i)\n\n    if len(primes) < 2:\n      return [-1, -1]\n\n    minDiff = math.inf\n    num1 = -1\n    num2 = -1\n\n    for a, b in zip(primes, primes[1:]):\n      diff = b - a\n      if diff < minDiff:\n        minDiff = diff\n        num1 = a\n        num2 = b\n\n    return [num1, num2]\n\n  def _sieveEratosthenes(self, n: int) -> List[bool]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return isPrime\n", "tests": {"17": "def test_closestPrimes():\n    solution = Solution()\n\n    def helper(left, right):\n        actual = solution.closestPrimes(left, right)", "20": "def test_closestPrimes():\n    solution = Solution()\n    print(solution.closestPrimes(2, 3))", "29": "def test_closestPrimes():\n    solution = Solution()\n\n    def closestPrimes(left, right):\n        assert solution.closestPrimes(10, 50) == [11, 13]", "30": "def test_closestPrimes(self):\n    solution = Solution()\n    self.assertEqual(solution.closestPrimes(2, 10), [3, 5])", "31": "def test_closestPrimes():\n\n    class Solution:\n\n        def _sieveEratosthenes(self, n):\n            isPrime = [True] * n\n            isPrime[0] = False\n            isPrime[1] = False\n            for i in range(2, int(n ** 0.5) + 1):\n                if isPrime[i]:\n                    for j in range(i * i, n, i):\n                        isPrime[j] = False\n            return isPrime\n\n        def closestPrimes(self, left: int, right: int) -> list:\n            isPrime = self._sieveEratosthenes(right + 1)\n            primes = []\n            for i in range(left, right + 1):\n                if isPrime[i]:\n                    primes.append(i)\n            if len(primes) < 2:\n                return [-1, -1]\n            minDiff = float('inf')\n            num1 = -1\n            num2 = -1\n            for (a, b) in zip(primes, primes[1:]):\n                diff = b - a\n                if diff < minDiff:\n                    minDiff = diff\n                    num1 = a\n                    num2 = b\n            return [num1, num2]\n    solution = Solution()\n    assert solution.closestPrimes(10, 17) == [11, 13]", "41": "def test_closestPrimes():\n    solution = Solution()\n\n    def test_case_1():\n        result = solution.closestPrimes(3, 7)", "42": "def test_closestPrimes():\n\n    class Solution:\n\n        def _sieveEratosthenes(self, n: int) -> List[bool]:\n            isPrime = [True] * n\n            isPrime[0] = False\n            isPrime[1] = False\n            for i in range(2, int(n ** 0.5) + 1):\n                if isPrime[i]:\n                    for j in range(i * i, n, i):\n                        isPrime[j] = False\n            return isPrime\n\n        def closestPrimes(self, left: int, right: int) -> List[int]:\n            isPrime = self._sieveEratosthenes(right + 1)\n            primes = []\n            for i in range(left, right + 1):\n                if isPrime[i]:\n                    primes.append(i)\n            if len(primes) < 2:\n                return [-1, -1]\n            minDiff = math.inf\n            num1 = -1\n            num2 = -1\n            for (a, b) in zip(primes, primes[1:]):\n                diff = b - a\n                if diff < minDiff:\n                    minDiff = diff\n                    num1 = a\n                    num2 = b\n            return [num1, num2]\n    solution = Solution()\n    assert solution.closestPrimes(10, 20) == [11, 13]"}}
{"task_num": 2532, "task_title": "Time to Cross a Bridge", "func_name": "findCrossingTime", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n    ans = 0\n    leftBridgeQueue = [(-leftToRight - rightToLeft, -i) for i, (leftToRight, pickOld, rightToLeft, pickNew) in enumerate(time)]\n    rightBridgeQueue = []\n    leftWorkers = []\n    rightWorkers = []\n\n    heapq.heapify(leftBridgeQueue)\n\n    while n > 0 or rightBridgeQueue or rightWorkers:\n      while leftWorkers and leftWorkers[0][0] <= ans:\n        i = heapq.heappop(leftWorkers)[1]\n        heapq.heappush(leftBridgeQueue, (-time[i][0] - time[i][2], -i))\n      while rightWorkers and rightWorkers[0][0] <= ans:\n        i = heapq.heappop(rightWorkers)[1]\n        heapq.heappush(rightBridgeQueue, (-time[i][0] - time[i][2], -i))\n      if rightBridgeQueue:\n        i = -heapq.heappop(rightBridgeQueue)[1]\n        ans += time[i][2]\n        heapq.heappush(leftWorkers, (ans + time[i][3], i))\n      elif leftBridgeQueue and n > 0:\n        i = -heapq.heappop(leftBridgeQueue)[1]\n        ans += time[i][0]\n        heapq.heappush(rightWorkers, (ans + time[i][1], i))\n        n -= 1\n      else:\n        if leftWorkers and n > 0:\n          ans1=leftWorkers[0][0]\n        else:\n          ans1=math.inf\n        if rightWorkers:\n          ans2=rightWorkers[0][0]\n        else:\n          ans2=math.inf\n        ans=min(ans1,ans2)\n\n    return ans", "tests": {"29": "def test_findCrossingTime():\n\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        solution = Solution()\n        (n, k, time) = (3, 2, [[5, 4, 6, 7], [8, 1, 9, 10]])", "30": "def test_findCrossingTime():\n\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        if n == 0 or k == 0:\n            return 0\n        elif len(time) != k:\n            raise ValueError('Invalid number of workers')\n        else:\n            return sum((t[2] for t in time))\nsolution = Solution()\nprint(solution.findCrossingTime(1, 1, [[5, 1, 3, 4]]))", "31": "def test_findCrossingTime(self):\n    n = 2\n    k = 1\n    time = [[10, 3, 20, 5], [100, 30, 200, 50]]\n    self.assertEqual(solution.findCrossingTime(n, k, time), 130)", "33": "def test_findCrossingTime(self):\n    solution = Solution()\n    n = 3\n    k = 2\n    time = [[10, 5, 15, 20], [7, 8, 9, 12]]\n    self.assertEqual(solution.findCrossingTime(n, k, time), 33)", "34": "def test_findCrossingTime():\n\n    class Solution:\n\n        def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n            ans = 0\n            leftBridgeQueue = [(-leftToRight - rightToLeft, -i) for (i, (leftToRight, pickOld, rightToLeft, putNew)) in enumerate(time)]\n            rightBridgeQueue = []\n            leftWorkers = []\n            rightWorkers = []\n            heapq.heapify(leftBridgeQueue)\n            while n > 0 or rightBridgeQueue:\n                while leftWorkers and leftWorkers[0][0] <= ans:\n                    i = heapq.heappop(leftWorkers)[1]\n                    heapq.heappush(leftBridgeQueue, (-time[i][0] - time[i][2], -i))\n                while rightWorkers and rightWorkers[0][0] <= ans:\n                    i = heapq.heappop(rightWorkers)[1]\n                    heapq.heappush(rightBridgeQueue, (-time[i][0] - time[i][2], -i))\n                if rightBridgeQueue:\n                    i = -heapq.heappop(rightBridgeQueue)[1]\n                    ans += time[i][2]\n                    heapq.heappush(leftWorkers, (ans + time[i][3], i))\n                elif leftBridgeQueue and n > 0:\n                    i = -heapq.heappop(leftBridgeQueue)[1]\n                    ans += time[i][0]\n                    heapq.heappush(rightWorkers, (ans + time[i][1], i))\n                    n -= 1\n                else:\n                    if leftWorkers and n > 0:\n                        ans1 = leftWorkers[0][0]\n                    else:\n                        ans1 = math.inf\n                    if rightWorkers:\n                        ans2 = rightWorkers[0][0]\n                    else:\n                        ans2 = math.inf\n                    ans = min(ans1, ans2)\n            return ans\n    solution = Solution()\n    time = [[10, 5, 15, 20], [8, 4, 12, 18]]\n    print(solution.findCrossingTime(1, 2, time))", "35": "def test_findCrossingTime(self):\n    solution = Solution()\n    n = 2\n    k = 2\n    time = [[4, 3, 5, 6], [10, 7, 1, 8]]\n    self.assertEqual(solution.findCrossingTime(n, k, time), 52)", "36": "def test_findCrossingTime(self):\n    solution = Solution()\n    n = 2\n    k = 1\n    time = [[0, 0, 10, 5], [20, 3, 40, 15]]\n    self.assertEqual(solution.findCrossingTime(n, k, time), 45)", "38": "def test_findCrossingTime():\n\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        ans = 0\n        leftBridgeQueue = [(-leftToRight - rightToLeft, -i) for (i, (leftToRight, pickOld, rightToLeft, pickNew)) in enumerate(time)]\n        rightBridgeQueue = []\n        leftWorkers = []\n        rightWorkers = []\n        heapq.heapify(leftBridgeQueue)\n        while n > 0 or rightBridgeQueue or rightWorkers:\n            while leftWorkers and leftWorkers[0][0] <= ans:\n                i = heapq.heappop(leftWorkers)[1]\n                heapq.heappush(leftBridgeQueue, (-time[i][0] - time[i][2], -i))\n            while rightWorkers and rightWorkers[0][0] <= ans:\n                i = heapq.heappop(rightWorkers)[1]\n                heapq.heappush(rightBridgeQueue, (-time[i][0] - time[i][2], -i))\n            if rightBridgeQueue:\n                i = -heapq.heappop(rightBridgeQueue)[1]\n                ans += time[i][2]\n                heapq.heappush(leftWorkers, (ans + time[i][3], i))\n            elif leftBridgeQueue and n > 0:\n                i = -heapq.heappop(leftBridgeQueue)[1]\n                ans += time[i][0]\n                heapq.heappush(rightWorkers, (ans + time[i][1], i))\n                n -= 1\n            else:\n                if leftWorkers and n > 0:\n                    ans1 = leftWorkers[0][0]\n                else:\n                    ans1 = math.inf\n                if rightWorkers:\n                    ans2 = rightWorkers[0][0]\n                else:\n                    ans2 = math.inf\n                ans = min(ans1, ans2)\n        return ans\n    solution = Solution()\n    n = 3\n    k = 4\n    time = [[10, 5, 5, 7], [15, 3, 8, 9], [17, 11, 13, 19], [20, 1, 14, 16]]\n    print(solution.findCrossingTime(n, k, time))", "39": "def test_findCrossingTime():\n\n    class Solution:\n\n        def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n            ans = 0\n            leftBridgeQueue = [(-leftToRight - rightToLeft, -i) for (i, (leftToRight, pickOld, rightToLeft, pickNew)) in enumerate(time)]\n            rightBridgeQueue = []\n            leftWorkers = []\n            rightWorkers = []\n            heapq.heapify(leftBridgeQueue)\n            while n > 0 or rightBridgeQueue:\n                while leftWorkers and leftWorkers[0][0] <= ans:\n                    i = heapq.heappop(leftWorkers)[1]\n                    heapq.heappush(leftBridgeQueue, (-time[i][0] - time[i][2], -i))\n                while rightWorkers and rightWorkers[0][0] <= ans:\n                    i = heapq.heappop(rightWorkers)[1]\n                    heapq.heappush(rightBridgeQueue, (-time[i][0] - time[i][2], -i))\n                if rightBridgeQueue:\n                    i = -heapq.heappop(rightBridgeQueue)[1]\n                    ans += time[i][2]\n                    heapq.heappush(leftWorkers, (ans + time[i][3], i))\n                elif leftBridgeQueue and n > 0:\n                    i = -heapq.heappop(leftBridgeQueue)[1]\n                    ans += time[i][0]\n                    heapq.heappush(rightWorkers, (ans + time[i][1], i))\n                    n -= 1\n                else:\n                    if leftWorkers and n > 0:\n                        ans1 = leftWorkers[0][0]\n                    else:\n                        ans1 = math.inf\n                    if rightWorkers:\n                        ans2 = rightWorkers[0][0]\n                    else:\n                        ans2 = math.inf\n                    ans = min(ans1, ans2)\n            return ans\n    solution = Solution()\n    time = [[1000, 2000, 3000, 4000], [5000, 6000, 7000, 8000]]\n    print(solution.findCrossingTime(2, 2, time))", "41": "def test_findCrossingTime():\n    solution = Solution()\n    n = 1\n    k = 2\n    time = [[10, 5, 20, 15], [8, 3, 12, 9]]\n    assert solution.findCrossingTime(n, k, time) == 40", "42": "def test_findCrossingTime(self):\n    n = 1\n    k = 2\n    time = [[0, 0, 3, 6], [0, 5, 0, 4]]\n    result = self.solution.findCrossingTime(n, k, time)", "43": "def test_findCrossingTime():\n    solution = Solution()\n\n    def findCrossingTime(n, k, time):\n        ans = 0\n        leftBridgeQueue = [(-leftToRight - rightToLeft, -i) for (i, (leftToRight, pickOld, rightToLeft, pickNew)) in enumerate(time)]\n        rightBridgeQueue = []\n        leftWorkers = []\n        rightWorkers = []\n        heapq.heapify(leftBridgeQueue)\n        while n > 0 or rightBridgeQueue or rightWorkers:\n            while leftWorkers and leftWorkers[0][0] <= ans:\n                i = heapq.heappop(leftWorkers)[1]\n                heapq.heappush(leftBridgeQueue, (-time[i][0] - time[i][2], -i))\n            while rightWorkers and rightWorkers[0][0] <= ans:\n                i = heapq.heappop(rightWorkers)[1]\n                heapq.heappush(rightBridgeQueue, (-time[i][0] - time[i][2], -i))\n            if rightBridgeQueue:\n                i = -heapq.heappop(rightBridgeQueue)[1]\n                ans += time[i][2]\n                heapq.heappush(leftWorkers, (ans + time[i][3], i))\n            elif leftBridgeQueue and n > 0:\n                i = -heapq.heappop(leftBridgeQueue)[1]\n                ans += time[i][0]\n                heapq.heappush(rightWorkers, (ans + time[i][1], i))\n                n -= 1\n            else:\n                if leftWorkers and n > 0:\n                    ans1 = leftWorkers[0][0]\n                else:\n                    ans1 = math.inf\n                if rightWorkers:\n                    assert rightWorkers[0][0] == 100\n                    return ans1\n    findCrossingTime(2, 2, [[10, 5, 40, 30], [20, 15, 50, 45]])", "45": "def test_findCrossingTime(self):\n    class Solution:\n        def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n            # function implementation remains the same\n    solution = Solution()\n    ans = solution.findCrossingTime(1, 2, [[math.inf, math.inf, 0, 0], [0, 0, math.inf, math.inf]])", "46": "def test_findCrossingTime():\n    solution = Solution()\n    n = 1\n    k = 1\n    time = [[1000, 10, 200, 20], [1500, 15, 300, 30]]\n    assert solution.findCrossingTime(n, k, time) == 2300"}}
{"task_num": 2577, "task_title": "Minimum Time to Visit a Cell In a Grid", "func_name": "minimumTime", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumTime(self, grid: List[List[int]]) -> int:\n    if grid[0][1] > 1 and grid[1][0] > 1:\n      return -1\n\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    minHeap = [(0, 0, 0)]\n    seen = {(0, 0)}\n\n    while minHeap:\n      time, i, j = heapq.heappop(minHeap)\n      if i == m - 1 and j == n - 1:\n        return time\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if (x, y) in seen:\n          continue\n        if (grid[x][y] - time) % 2 == 0:\n          extraWait = 1\n        else:\n          extraWait = 0\n        nextTime = max(time + 1, grid[x][y] + extraWait)\n        heapq.heappush(minHeap, (nextTime, x, y))\n        seen.add((x, y))\n", "tests": {"14": "def test_minimumTime(self):\n\n    class Solution:\n\n        def minimumTime(self, grid: List[List[int]]) -> int:\n            if grid[0][1] > 1 and grid[1][0] > 1:\n                return -1\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            m = len(grid)\n            n = len(grid[0])\n            minHeap = [(0, 0, 0)]\n            seen = {(0, 0)}\n            while minHeap:\n                (time, i, j) = heapq.heappop(minHeap)\n                if i == m - 1 and j == n - 1:\n                    return time\n                for (dx, dy) in dirs:\n                    x = i + dx\n                    y = j + dy\n                    if x < 0 or x == m or y < 0 or (y == n):\n                        continue\n                    if (x, y) in seen:\n                        continue\n                    if (grid[x][y] - time) % 2 == 0:\n                        extraWait = 1\n                    else:\n                        extraWait = 0\n                    nextTime = max(time + 1, grid[x][y] + extraWait)\n                    heapq.heappush(minHeap, (nextTime, x, y))\n                    seen.add((x, y))\n            return -1\n    solution = Solution()\n    self.assertEqual(solution.minimumTime([[2, 0], [3, 0]]), -1)", "25": "def test_minimumTime(self):\n\n    class Solution:\n\n        def minimumTime(self, grid):\n            if grid[0][1] > 1 and grid[1][0] > 1:\n                return -1\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            m = len(grid)\n            n = len(grid[0])\n            minHeap = [(0, 0, 0)]\n            seen = {(0, 0)}\n            while minHeap:\n                (time, i, j) = heapq.heappop(minHeap)\n                if i == m - 1 and j == n - 1:\n                    return time\n                for (dx, dy) in dirs:\n                    x = i + dx\n                    y = j + dy\n                    if x < 0 or x == m or y < 0 or (y == n):\n                        continue\n                    if (x, y) in seen:\n                        continue\n                    if (grid[x][y] - time) % 2 == 0:\n                        extraWait = 1\n                    else:\n                        extraWait = 0\n                    nextTime = max(time + 1, grid[x][y] + extraWait)\n                    heapq.heappush(minHeap, (nextTime, x, y))\n                    seen.add((x, y))\n            return -1\n    solution = Solution()\n    self.assertEqual(solution.minimumTime([[2, 0, 0], [3, 5, 0]]), 3)", "30": "def test_minimumTime(self):\n    solution = Solution()\n    grid = [[2, 3], [4, 5]]\n    self.assertEqual(solution.minimumTime(grid), 7)", "32": "def test_minimumTime():\n\n    class Solution:\n\n        def minimumTime(self, grid):\n            if grid[0][1] > 1 and grid[1][0] > 1:\n                return -1\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            m = len(grid)\n            n = len(grid[0])\n            minHeap = [(0, 0, 0)]\n            seen = {(0, 0)}\n            while minHeap:\n                (time, i, j) = heapq.heappop(minHeap)\n                if i == m - 1 and j == n - 1:\n                    return time\n                for (dx, dy) in dirs:\n                    x = i + dx\n                    y = j + dy\n                    if x < 0 or x == m or y < 0 or (y == n):\n                        continue\n                    if (x, y) in seen:\n                        assert False, f'Test case failed: grid[{x}][{y}]={grid[x][y]}'\n                    if (grid[x][y] - time) % 2 == 0:\n                        extraWait = 1\n                    else:\n                        extraWait = 0\n                    nextTime = max(time + 1, grid[x][y] + extraWait)\n                    heapq.heappush(minHeap, (nextTime, x, y))\n                    seen.add((x, y))\n    solution = Solution()\n    assert solution.minimumTime([[0, 3], [2, 0]]) == 4", "34": "def test_minimumTime(self):\n\n    class Solution:\n\n        def minimumTime(self, grid):\n            if grid[0][1] > 1 and grid[1][0] > 1:\n                return -1\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            m = len(grid)\n            n = len(grid[0])\n            minHeap = [(0, 0, 0)]\n            seen = {(0, 0)}\n            while minHeap:\n                (time, i, j) = heapq.heappop(minHeap)\n                if i == m - 1 and j == n - 1:\n                    return time\n                for (dx, dy) in dirs:\n                    x = i + dx\n                    y = j + dy\n                    if x < 0 or x == m or y < 0 or (y == n):\n                        continue\n                    if (x, y) in seen:\n                        continue\n                    if grid[x][y] - time > 1 and (grid[x][y] - time) % 2 != 0:\n                        extraWait = 1\n                    else:\n                        extraWait = 0\n                    nextTime = max(time + 1, grid[x][y] + extraWait)\n                    heapq.heappush(minHeap, (nextTime, x, y))\n                    seen.add((x, y))\n            return -1\n    solution = Solution()\n    grid = [[2, 6, 3], [5, 8, 4], [7, 9, 10]]\n    self.assertEqual(solution.minimumTime(grid), 5)", "36": "def test_minimumTime(self):\n\n    class Solution:\n\n        def minimumTime(self, grid):\n            if grid[0][1] > 1 and grid[1][0] > 1:\n                return -1\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            m = len(grid)\n            n = len(grid[0])\n            minHeap = [(0, 0, 0)]\n            seen = {(0, 0)}\n            while minHeap:\n                (time, i, j) = heapq.heappop(minHeap)\n                if i == m - 1 and j == n - 1:\n                    return time\n                for (dx, dy) in dirs:\n                    x = i + dx\n                    y = j + dy\n                    if x < 0 or x == m or y < 0 or (y == n):\n                        continue\n                    if (x, y) in seen:\n                        continue\n                    if grid[x][y] % 2 == 0:\n                        extraWait = 1\n                    else:\n                        extraWait = 0\n                    nextTime = max(time + 1, grid[x][y] + extraWait)\n                    heapq.heappush(minHeap, (nextTime, x, y))\n                    seen.add((x, y))\n            return -1\n    solution = Solution()\n    self.assertEqual(solution.minimumTime([[2, 4], [3, 6]]), 8)"}}
{"task_num": 2601, "task_title": "Prime Subtraction Operation", "func_name": "primeSubOperation", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def primeSubOperation(self, nums: List[int]) -> bool:\n    kMax = 1000\n    primes = self._sieveEratosthenes(kMax)\n\n    prevNum = 0\n    for num in nums:\n      i = bisect.bisect_left(primes, num - prevNum)\n      if i > 0:\n        num -= primes[i - 1]\n      if num <= prevNum:\n        return False\n      prevNum = num\n\n    return True\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return [i for i in range(n) if isPrime[i]]\n", "tests": {"20": "def test_primeSubOperation():\n\n    class Solution:\n\n        def _sieveEratosthenes(self, n):\n            isPrime = [True] * n\n            isPrime[0] = False\n            isPrime[1] = False\n            for i in range(2, int(n ** 0.5) + 1):\n                if isPrime[i]:\n                    for j in range(i * i, n, i):\n                        isPrime[j] = False\n            return [i for i in range(n) if isPrime[i]]\n\n        def primeSubOperation(self, nums):\n            kMax = 1000\n            primes = self._sieveEratosthenes(kMax)\n            prevNum = 0\n            for num in nums:\n                i = bisect.bisect_left(primes, num - prevNum)\n                if i > 0:\n                    num -= primes[i - 1]\n                if num <= prevNum:\n                    return False\n                prevNum = num\n            return True\n    solution = Solution()\n    assert solution.primeSubOperation([4, 8, 12]) == True", "22": "def test_primeSubOperation():\n\n    class Solution:\n\n        def primeSubOperation(self, nums):\n            kMax = 1000\n            primes = self._sieveEratosthenes(kMax)\n            prevNum = 0\n            for num in nums:\n                i = bisect.bisect_left(primes, num - prevNum)\n                if i > 0:\n                    num -= primes[i - 1]\n                if num <= prevNum:\n                    return False\n                prevNum = num\n            return True\n\n    def _sieveEratosthenes(self, n):\n        isPrime = [True] * n\n        isPrime[0] = False\n        isPrime[1] = False\n        for i in range(2, int(n ** 0.5) + 1):\n            if isPrime[i]:\n                for j in range(i * i, n, i):\n                    isPrime[j] = False\n        return [i for i in range(n) if isPrime[i]]\n    solution = Solution()\n    print(solution.primeSubOperation([2, 3, 5]))", "33": "def test_primeSubOperation(self):\n    solution = Solution()\n    nums = [7, 13, 29]\n    self.assertTrue(solution.primeSubOperation(nums))", "34": "def test_primeSubOperation(self):\n\n    class Solution:\n\n        def primeSubOperation(self, nums: List[int]) -> bool:\n            kMax = 1000\n            primes = self._sieveEratosthenes(kMax)\n            prevNum = 0\n            for num in nums:\n                i = bisect.bisect_left(primes, num - prevNum)\n                if i > 0:\n                    num -= primes[i - 1]\n                if num <= prevNum:\n                    return False\n                prevNum = num\n            return True\n\n        def _sieveEratosthenes(self, n: int) -> List[int]:\n            isPrime = [True] * n\n            isPrime[0] = False\n            isPrime[1] = False\n            for i in range(2, int(n ** 0.5) + 1):\n                if isPrime[i]:\n                    for j in range(i * i, n, i):\n                        isPrime[j] = False\n            return [i for i in range(n) if isPrime[i]]\n    solution = Solution()\n    self.assertTrue(solution.primeSubOperation([3, 7, 13]))"}}
{"task_num": 2603, "task_title": "Collect Coins in a Tree", "func_name": "collectTheCoins", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def collectTheCoins(self, coins: List[int], edges: List[List[int]]) -> int:\n    n = len(coins)\n    tree = [set() for _ in range(n)]\n    leavesToBeRemoved = collections.deque()\n\n    for u, v in edges:\n      tree[u].add(v)\n      tree[v].add(u)\n\n    for u in range(n):\n      while len(tree[u]) == 1 and coins[u] == 0:\n        v = tree[u].pop()\n        tree[v].remove(u)\n        u = v\n      if len(tree[u]) == 1:\n        leavesToBeRemoved.append(u)\n\n    for _ in range(2):\n      for _ in range(len(leavesToBeRemoved)):\n        u = leavesToBeRemoved.popleft()\n        if tree[u]:\n          v = tree[u].pop()\n          tree[v].remove(u)\n          if len(tree[v]) == 1:\n            leavesToBeRemoved.append(v)\n\n    return sum(len(children) for children in tree)\n", "tests": {"27": "def test_collectTheCoins(self):\n    solution = Solution()\n    coins = [1, 0, 0]\n    edges = [[0, 1], [1, 2]]\n    self.assertEqual(solution.collectTheCoins(coins, edges), 6)", "33": "def test_collectTheCoins():\n    solution = Solution()\n    coins = [1, 0, 1, 0]\n    edges = [[0, 1], [2, 3]]\n    assert solution.collectTheCoins(coins, edges) == 4", "34": "def test_collectTheCoins():\n\n    def collectTheCoins(coins, edges):\n        n = len(coins)\n        tree = [set() for _ in range(n)]\n        leavesToBeRemoved = collections.deque()\n        for (u, v) in edges:\n            tree[u].add(v)\n            tree[v].add(u)\n        for u in range(n):\n            while len(tree[u]) == 1 and coins[u] == 0:\n                v = tree[u].pop()\n                tree[v].remove(u)\n                u = v\n            if len(tree[u]) == 1:\n                leavesToBeRemoved.append(u)\n        for _ in range(2):\n            for _ in range(len(leavesToBeRemoved)):\n                u = leavesToBeRemoved.popleft()\n                if tree[u]:\n                    v = tree[u].pop()\n                    tree[v].remove(u)\n                    if len(tree[v]) == 1:\n                        leavesToBeRemoved.append(v)\n        return sum((len(children) for children in tree))\n    solution = Solution()\n    edges = [[0, 1], [2, 3]]\n    coins = [1, 0, 1, 0]\n    assert collectTheCoins(coins, edges) == 6", "35": "def test_collectTheCoins():\n\n    class Solution:\n\n        def collectTheCoins(self, coins, edges):\n            n = len(coins)\n            tree = [set() for _ in range(n)]\n            leavesToBeRemoved = collections.deque()\n            for (u, v) in edges:\n                tree[u].add(v)\n                tree[v].add(u)\n            for u in range(n):\n                while len(tree[u]) == 1 and coins[u] == 0:\n                    v = tree[u].pop()\n                    tree[v].remove(u)\n                    u = v\n                if len(tree[u]) == 1:\n                    leavesToBeRemoved.append(u)\n            for _ in range(2):\n                for _ in range(len(leavesToBeRemoved)):\n                    u = leavesToBeRemoved.popleft()\n                    if tree[u]:\n                        v = tree[u].pop()\n                        tree[v].remove(u)\n                        if len(tree[v]) == 1:\n                            leavesToBeRemoved.append(v)\n            return sum((len(children) for children in tree))\n    solution = Solution()\n    coins = [0, 0, 1]\n    edges = [[0, 1], [1, 2]]\n    self.assertEqual(solution.collectTheCoins(coins, edges), 2)", "36": "def test_collectTheCoins(self):\n\n    class Solution:\n\n        def collectTheCoins(self, coins: List[int], edges: List[List[int]]) -> int:\n            n = len(coins)\n            tree = [set() for _ in range(n)]\n            leavesToBeRemoved = collections.deque()\n            for (u, v) in edges:\n                tree[u].add(v)\n                tree[v].add(u)\n            for u in range(n):\n                while len(tree[u]) == 1 and coins[u] == 0:\n                    v = tree[u].pop()\n                    tree[v].remove(u)\n                    u = v\n                if len(tree[u]) == 1:\n                    leavesToBeRemoved.append(u)\n            for _ in range(2):\n                for _ in range(len(leavesToBeingRemoved)):\n                    u = leavesToBeRemoved.popleft()\n                    if tree[u]:\n                        v = tree[u].pop()\n                        tree[v].remove(u)\n                        if len(tree[v]) == 1:\n                            leavesToBeRemoved.append(v)\n            return sum((len(children) for children in tree))\n    solution = Solution()\n    coins = [0, 1, 1]\n    edges = [[0, 1], [1, 2]]\n    self.assertEqual(solution.collectTheCoins(coins, edges), 5)"}}
{"task_num": 2653, "task_title": "Sliding Subarray Beauty", "func_name": "getSubarrayBeauty", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\n    ans = []\n    count = [0] * 50\n\n    for i, num in enumerate(nums):\n      if num < 0:\n        count[num + 50] += 1\n      if i - k >= 0 and nums[i - k] < 0:\n        count[nums[i - k] + 50] -= 1\n      if i + 1 >= k:\n        ans.append(self._getXthSmallestNum(count, x))\n\n    return ans\n\n  def _getXthSmallestNum(self, count: List[int], x: int) -> int:\n    prefix = 0\n    for i in range(50):\n      prefix += count[i]\n      if prefix >= x:\n        return i - 50\n    return 0\n", "tests": {"18": "def test_getSubarrayBeauty():\n\n    def setUp():\n        return Solution()\n\n    def test_0():\n        solution = setUp()\n        nums = [3, -2, 1]\n        k = 3\n        x = 2\n        expected = [0, 0, 0]\n        assert solution.getSubarrayBeauty(nums, k, x) == expected", "20": "def test_getSubarrayBeauty():\n    solution = Solution()\n    nums = [-2, -5, -4, -6, -1]\n    k = 3\n    x = 2\n    result = solution.getSubarrayBeauty(nums, k, x)", "22": "def test_getSubarrayBeauty(self):\n    solution = Solution()\n    nums = [1, 2, -3, -4, -5]\n    k = 3\n    x = 2\n    result = solution.getSubarrayBeauty(nums, k, x)", "31": "def test_getSubarrayBeauty():\n    solution = Solution()\n\n    def get_subarrays(nums, k, x):"}}
{"task_num": 2662, "task_title": "Minimum Cost of a Path With Special Roads", "func_name": "minimumCost", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\n    return self.dijkstra(specialRoads, *start, *target)\n\n  def dijkstra(self, specialRoads: List[List[int]], srcX: int, srcY: int, dstX: int, dstY: int) -> int:\n    n = len(specialRoads)\n    dist = [math.inf] * n\n    minHeap = []\n\n    for u, (x1, y1, _, _, cost) in enumerate(specialRoads):\n      d = abs(x1 - srcX) + abs(y1 - srcY) + cost\n      dist[u] = d\n      heapq.heappush(minHeap, (dist[u], u))\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      _, _, ux2, uy2, _ = specialRoads[u]\n      for v in range(n):\n        if v == u:\n          continue\n        vx1, vy1, _, _, vcost = specialRoads[v]\n        newDist = d + abs(vx1 - ux2) + abs(vy1 - uy2) + vcost\n        if newDist < dist[v]:\n          dist[v] = newDist\n          heapq.heappush(minHeap, (dist[v], v))\n\n    ans = abs(dstX - srcX) + abs(dstY - srcY)\n    for u in range(n):\n      _, _, x2, y2, _ = specialRoads[u]\n      ans = min(ans, dist[u] + abs(dstX - x2) + abs(dstY - y2))\n\n    return ans\n", "tests": {"28": "def test_minimumCost(self):\n\n    class Solution:\n\n        def dijkstra(self, specialRoads: List[List[int]], srcX: int, srcY: int, dstX: int, dstY: int) -> int:\n            n = len(specialRoads)\n            dist = [math.inf] * n\n            minHeap = []\n            for (u, (x1, y1, _, _, cost)) in enumerate(specialRoads):\n                d = abs(x1 - srcX) + abs(y1 - srcY) + cost\n                dist[u] = d\n                heapq.heappush(minHeap, (dist[u], u))\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                (_, _, ux2, uy2, _) = specialRoads[u]\n                for v in range(n):\n                    if v == u:\n                        continue\n                    (vx1, vy1, _, _, vcost) = specialRoads[v]\n                    newDist = d + abs(vx1 - ux2) + abs(vy1 - uy2) + vcost\n                    if newDist < dist[v]:\n                        dist[v] = newDist\n                        heapq.heappush(minHeap, (dist[v], v))\n            ans = abs(dstX - srcX) + abs(dstY - srcY)\n            for u in range(n):\n                (_, _, x2, y2, _) = specialRoads[u]\n                ans = min(ans, dist[u] + abs(dstX - x2) + abs(dstY - y2))\n            return ans\n    solution = Solution()\n    start = [0, 0]\n    target = [5, 5]\n    specialRoads = [[1, 1, 3, 3, 10], [4, 4, 6, 6, 20]]\n    self.assertEqual(solution.minimumCost(start, target, specialRoads), 30)", "32": "def test_minimumCost(self):\n\n    class Solution:\n\n        def dijkstra(self, specialRoads: List[List[int]], srcX: int, srcY: int, dstX: int, dstY: int) -> int:\n            n = len(specialRoads)\n            dist = [math.inf] * n\n            minHeap = []\n            for (u, (x1, y1, _, _, cost)) in enumerate(specialRoads):\n                d = abs(x1 - srcX) + abs(y1 - srcY) + cost\n                dist[u] = d\n                heapq.heappush(minHeap, (dist[u], u))\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                (_, _, ux2, uy2, _) = specialRoads[u]\n                for v in range(n):\n                    if v == u:\n                        continue\n                    (vx1, vy1, _, _, vcost) = specialRoads[v]\n                    newDist = d + abs(vx1 - ux2) + abs(vy1 - uy2) + vcost\n                    if newDist < dist[v]:\n                        dist[v] = newDist\n                        heapq.heappush(minHeap, (dist[v], v))\n            ans = abs(dstX - srcX) + abs(dstY - srcY)\n            for u in range(n):\n                (_, _, x2, y2, _) = specialRoads[u]\n                ans = min(ans, dist[u] + abs(dstX - x2) + abs(dstY - y2))\n            return ans\n    solution = Solution()\n    start = [0, 0]\n    target = [5, 5]\n    specialRoads = [[1, 3, 4, 7, 10], [6, 8, 9, 11, 15]]\n    self.assertEqual(solution.minimumCost(start, target, specialRoads), 34)", "36": "def test_minimumCost(self):\n    class Solution:\n        def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\n            return self.dijkstra(specialRoads, *start, *target)\n\n        def dijkstra(self, specialRoads: List[List[int]], srcX: int, srcY: int, dstX: int, dstY: int) -> int:\n            # ... (rest of the function remains the same)\n    solution = Solution()\n\n    start = [0, 0]\n    target = [1, 2]\n    specialRoads = [[0, 0, 1, 1, 5], [0, 1, 1, 2, 4]]\n\n    result = solution.minimumCost(start, target, specialRoads)", "37": "def test_specialRoad(self):\n    class Solution:\n        def dijkstra(self, specialRoads: List[List[int]], srcX: int, srcY: int, dstX: int, dstY: int) -> int:\n            # implementation here...\n\n    solution = Solution()\n    specialRoads = [[0, 0, 10, 10, 1], [10, 10, 0, 0, 2]]\n    start = [5, 5]\n    target = [15, 15]\n    self.assertEqual(solution.minimumCost(start, target, specialRoads), 4)"}}
{"task_num": 2663, "task_title": "Lexicographically Smallest Beautiful String", "func_name": "smallestBeautifulString", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def smallestBeautifulString(self, s: str, k: int) -> str:\n    chars = list(s)\n\n    for i in reversed(range(len(chars))):\n      chars[i] = chr(ord(chars[i]) + 1)\n      while self._containsPalindrome(chars, i):\n        chars[i] = chr(ord(chars[i]) + 1)\n      if chars[i] < chr(ord('a') + k):\n        return self._changeSuffix(chars, i + 1)\n\n    return ''\n\n  def _containsPalindrome(self, chars: List[str], i: int) -> bool:\n    return (i > 0 and chars[i] == chars[i - 1]) or (i > 1 and chars[i] == chars[i - 2])\n\n  def _changeSuffix(self, chars: List[str], i: int) -> str:\n    for j in range(i, len(chars)):\n      chars[j] = 'a'\n      while self._containsPalindrome(chars, j):\n        chars[j] = chr(ord(chars[j]) + 1)\n    return ''.join(chars)\n", "tests": {"20": "def test_smallestBeautifulString(self):\n    solution = Solution()\n    self.assertEqual(solution.smallestBeautifulString('abcd', 2), 'abce')"}}
{"task_num": 2672, "task_title": "Number of Adjacent Elements With the Same Color", "func_name": "colorTheArray", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\n    ans = []\n    arr = [0] * n\n    sameColors = 0\n\n    for i, color in queries:\n      if i + 1 < n:\n        if arr[i + 1] > 0 and arr[i + 1] == arr[i]:\n          sameColors -= 1\n        if arr[i + 1] == color:\n          sameColors += 1\n      if i > 0:\n        if arr[i - 1] > 0 and arr[i - 1] == arr[i]:\n          sameColors -= 1\n        if arr[i - 1] == color:\n          sameColors += 1\n      arr[i] = color\n      ans.append(sameColors)\n\n    return ans\n", "tests": {"19": "def test_colorTheArray():\n\n    class Solution:\n\n        def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\n            ans = []\n            arr = [0] * n\n            sameColors = 0\n            for (i, color) in queries:\n                if i + 1 < n:\n                    if arr[i + 1] > 0 and arr[i + 1] == arr[i]:\n                        sameColors -= 1\n                    if arr[i + 1] == color:\n                        sameColors += 1\n                if i > 0:\n                    if arr[i - 1] > 0 and arr[i - 1] == arr[i]:\n                        sameColors -= 1\n                    if arr[i - 1] == color:\n                        sameColors += 1\n                arr[i] = color\n                ans.append(sameColors)\n            return ans\n    solution = Solution()\n    queries = [[2, 3], [4, 1]]\n    assert solution.colorTheArray(5, queries) == [0]", "20": "def test_colorTheArray():\n\n    class Solution:\n\n        def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\n            ans = []\n            arr = [0] * n\n            sameColors = 0\n            for (i, color) in queries:\n                if i + 1 < n:\n                    if arr[i + 1] > 0 and arr[i + 1] == arr[i]:\n                        sameColors -= 1\n                    if arr[i + 1] == color:\n                        sameColors += 1\n                if i > 0:\n                    if arr[i - 1] > 0 and arr[i - 1] == arr[i]:\n                        sameColors -= 1\n                    if arr[i - 1] == color:\n                        sameColors += 1\n                arr[i] = color\n                ans.append(sameColors)\n            return ans\n    solution = Solution()\n    queries = [[0, 2], [0, 2]]\n    assert solution.colorTheArray(2, queries) == [0]", "21": "def test_colorTheArray():\n    solution = Solution()\n\n    def helper():", "22": "def test_colorTheArray():\n    solution = Solution()\n\n    def colorTheArrayTest(n, queries):", "24": "def test_colorTheArray(self):\n\n    class Solution:\n\n        def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\n            ans = []\n            arr = [0] * n\n            for (i, color) in queries:\n                if i + 1 < n:\n                    if arr[i + 1] > 0 and arr[i + 1] == arr[i]:\n                        sameColors -= 1\n                    if arr[i + 1] == color:\n                        sameColors += 1\n                if i > 0:\n                    if arr[i - 1] > 0 and arr[i - 1] == arr[i]:\n                        sameColors -= 1\n                    elif arr[i - 1] != 0:\n                        sameColors += 1\n                arr[i] = color\n                ans.append(sameColors)\n            return ans\n    solution = Solution()\n    n = 5\n    queries = [[2, 1], [1, 2]]\n    self.assertEqual(solution.colorTheArray(n, queries), [0, 1])", "25": "def test_colorTheArray(self):\n    solution = Solution()\n    n = 5\n    queries = [[2, 1], [1, 2], [3, 3], [4, 1], [0, 2]]\n    self.assertEqual(solution.colorTheArray(n, queries), [0, 0, 2, 1, 1])", "26": "def test_colorTheArray():\n\n    class Solution:\n\n        def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\n            ans = []\n            arr = [0] * n\n            sameColors = 0\n            for (i, color) in queries:\n                if i + 1 < n:\n                    if arr[i + 1] > 0 and arr[i + 1] == arr[i]:\n                        sameColors -= 1\n                    if arr[i + 1] == color:\n                        sameColors += 1\n                if i > 0:\n                    if arr[i - 1] > 0 and arr[i - 1] == arr[i]:\n                        sameColors -= 1\n                    if arr[i - 1] == color:\n                        sameColors += 1\n                arr[i] = color\n                ans.append(sameColors)\n            return ans\n    solution = Solution()\n    print(solution.colorTheArray(5, [[0, 1], [4, 1], [1, 2], [2, 3]]))", "27": "def test_colorTheArray():\n\n    class Solution:\n\n        def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\n            ans = []\n            arr = [0] * n\n            sameColors = 0\n            for (i, color) in queries:\n                if i + 1 < n:\n                    if arr[i + 1] > 0 and arr[i + 1] == arr[i]:\n                        sameColors -= 1\n                    if arr[i + 1] == color:\n                        sameColors += 1\n                if i > 0:\n                    if arr[i - 1] > 0 and arr[i - 1] == arr[i]:\n                        sameColors -= 1\n                    if arr[i - 1] == color:\n                        sameColors += 1\n                arr[i] = color\n                ans.append(sameColors)\n            return ans\n    solution = Solution()\n    n = 5\n    queries = [[0, 2], [0, 3], [3, 3], [2, 3]]\n    assert solution.colorTheArray(n, queries) == [1, 2, 2, 3]"}}
{"task_num": 2684, "task_title": "Maximum Number of Moves in a Grid", "func_name": "maxMoves", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxMoves(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n\n    for j in range(n - 2, -1, -1):\n      for i in range(m):\n        if grid[i][j + 1] > grid[i][j]:\n          dp[i][j] = 1 + dp[i][j + 1]\n        if i > 0 and grid[i - 1][j + 1] > grid[i][j]:\n          dp[i][j] = max(dp[i][j], 1 + dp[i - 1][j + 1])\n        if i + 1 < m and grid[i + 1][j + 1] > grid[i][j]:\n          dp[i][j] = max(dp[i][j], 1 + dp[i + 1][j + 1])\n\n    return max(dp[i][0] for i in range(m))\n", "tests": {"20": "def test_maxMoves():\n\n    class Solution:\n\n        def maxMoves(self, grid):\n            m = len(grid)\n            n = len(grid[0])\n            dp = [[0] * n for _ in range(m)]\n            for j in range(n - 2, -1, -1):\n                for i in range(m):\n                    if grid[i][j + 1] > grid[i][j]:\n                        dp[i][j] = 1 + dp[i][j + 1]\n                    elif grid[i][0] > grid[i][j] and dp[i][0] > dp[i][j]:\n                        return dp[i][0]\n                    if i > 0 and grid[i - 1][j + 1] > grid[i][j]:\n                        dp[i][j] = max(dp[i][j], 1 + dp[i - 1][j + 1])\n                    if i + 1 < m and grid[i + 1][j + 1] > grid[i][j]:\n                        dp[i][j] = max(dp[i][j], 1 + dp[i + 1][j + 1])\n            return max((dp[i][0] for i in range(m)))\n    solution = Solution()\n    print(solution.maxMoves([[1, 2], [3, 4]]))", "22": "def test_maxMoves():\n\n    class Solution:\n\n        def maxMoves(self, grid):\n            m = len(grid)\n            n = len(grid[0])\n            dp = [[0] * n for _ in range(m)]\n            for j in range(n - 2, -1, -1):\n                for i in range(m):\n                    if grid[i][j + 1] > grid[i][j]:\n                        dp[i][j] = 1 + dp[i][j + 1]\n                    if i > 0 and grid[i - 1][j + 1] > grid[i][j]:\n                        dp[i][j] = max(dp[i][j], 1 + dp[i - 1][j + 1])\n                    if i + 1 < m and grid[i + 1][j + 1] > grid[i][j]:\n                        dp[i][j] = max(dp[i][j], 1 + dp[i + 1][j + 1])\n            return max((dp[i][0] for i in range(m)))\n    solution = Solution()\n    assert solution.maxMoves([[1, 2], [3, 4]]) == 0", "24": "def test_maxMoves():\n\n    class Solution:\n\n        def maxMoves(self, grid: List[List[int]]) -> int:\n            m = len(grid)\n            n = len(grid[0])\n            dp = [[0] * n for _ in range(m)]\n            for j in range(n - 2, -1, -1):\n                for i in range(m):\n                    if grid[i][j + 1] > grid[i][j]:\n                        dp[i][j] = 1 + dp[i][j + 1]\n                    if i > 0 and grid[i - 1][j + 1] > grid[i][j]:\n                        dp[i][j] = max(dp[i][j], 1 + dp[i - 1][j + 1])\n                    if i + 1 < m and grid[i + 1][j + 1] > grid[i][j]:\n                        dp[i][j] = max(dp[i][j], 1 + dp[i + 1][j + 1])\n            return max((dp[i][0] for i in range(m)))\n    solution = Solution()\n    grid = [[9, 9, 4], [6, 6, 8], [2, 1, 1]]\n    assert solution.maxMoves(grid) == 3"}}
{"task_num": 2685, "task_title": "Count the Number of Complete Components", "func_name": "countCompleteComponents", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n    self.nodeCount = [1] * n\n    self.edgeCount = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    self.edgeCount[i] += 1\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n      self.edgeCount[j] += self.edgeCount[i]\n      self.nodeCount[j] += self.nodeCount[i]\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n      self.edgeCount[i] += self.edgeCount[j]\n      self.nodeCount[i] += self.nodeCount[j]\n    else:\n      self.id[i] = j\n      self.edgeCount[j] += self.edgeCount[i]\n      self.nodeCount[j] += self.nodeCount[i]\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n  def isComplete(self, u):\n    return self.nodeCount[u] * (self.nodeCount[u] - 1) // 2 == self.edgeCount[u]\n\n\nclass Solution:\n  def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\n    ans = 0\n    uf = UnionFind(n)\n    parents = set()\n\n    for u, v in edges:\n      uf.unionByRank(u, v)\n\n    for i in range(n):\n      parent = uf.find(i)\n      if parent not in parents and uf.isComplete(parent):\n        ans += 1\n        parents.add(parent)\n\n    return ans\n", "tests": {"23": "def test_countCompleteComponents(self):\n\n    class Solution:\n\n        def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\n            ans = 0\n            uf = UnionFind(n)\n            parents = set()\n            for (u, v) in edges:\n                uf.unionByRank(u, v)\n            for i in range(n):\n                parent = uf.find(i)\n                if parent not in parents and uf.isComplete(parent):\n                    ans += 1\n                    parents.add(parent)\n            return ans\n\n    class UnionFind:\n\n        def __init__(self, n: int):\n            self.id = list(range(n))\n            self.rank = [0] * n\n            self.nodeCount = [1] * n\n            self.edgeCount = [0] * n\n\n        def unionByRank(self, u: int, v: int) -> None:\n            i = self.find(u)\n            j = self.find(v)\n            if i == j:\n                return\n            if self.rank[i] < self.rank[j]:\n                self.id[i] = j\n                self.edgeCount[j] += self.edgeCount[i]\n                self.nodeCount[j] += self.nodeCount[i]\n            elif self.rank[i] > self.rank[j]:\n                self.id[j] = i\n                self.edgeCount[i] += self.edgeCount[j]\n                self.nodeCount[i] += self.nodeCount[j]\n            else:\n                self.id[i] = j\n                self.edgeCount[j] += self.edgeCount[i]\n                self.nodeCount[j] += self.nodeCount[i]\n                self.rank[j] += 1\n\n        def find(self, u: int) -> int:\n            if self.id[u] != u:\n                self.id[u] = self.find(self.id[u])\n            return self.id[u]\n    solution = Solution()\n    n = 5\n    edges = [[0, 1], [2, 3]]\n    result = solution.countCompleteComponents(n, edges)", "25": "    def test_countCompleteComponents(self):\n        def countCompleteComponents(n, edges):\n            ans = 0\n            uf = UnionFind(n)\n            parents = set()\n\n            for u, v in edges:\n                uf.unionByRank(u, v)\n\n            for i in range(n):\n                parent = uf.find(i)\n                if parent not in parents and uf.isComplete(parent):\n                    ans += 1\n                    parents.add(parent)\n\n            return ans\n\n        solution=Solution()\n        n = 5\n        edges = [[0,2],[0,3],[1,2]]\n        self.assertEqual(countCompleteComponents(n, edges), 2)\n\nif __name__ == '__main__':\n    unittest.main()", "26": "def test_countCompleteComponents(self):\n\n    class Solution:\n\n        def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\n            ans = 0\n            uf = UnionFind(n)\n            parents = set()\n            for (u, v) in edges:\n                uf.unionByRank(u, v)\n            for i in range(n):\n                parent = uf.find(i)\n                if parent not in parents and uf.isComplete(parent):\n                    ans += 1\n                    parents.add(parent)\n            return ans\n\n    class UnionFind:\n\n        def __init__(self, n: int):\n            self.id = list(range(n))\n            self.rank = [0] * n\n            self.nodeCount = [1] * n\n            self.edgeCount = [0] * n\n\n        def unionByRank(self, u: int, v: int) -> None:\n            i = self.find(u)\n            j = self.find(v)\n            if i == j:\n                return\n            if self.rank[i] < self.rank[j]:\n                self.id[i] = j\n                self.edgeCount[j] += 0\n                self.nodeCount[j] += self.nodeCount[i]\n            elif self.rank[i] > self.rank[j]:\n                self.id[j] = i\n                self.edgeCount[i] += self.edgeCount[j]\n                self.nodeCount[i] += self.nodeCount[j]\n            else:\n                self.id[i] = j\n                self.edgeCount[j] += self.edgeCount[i]\n                self.nodeCount[j] += self.nodeCount[i]\n                self.rank[j] += 1\n\n        def find(self, u: int) -> int:\n            if self.id[u] != u:\n                self.id[u] = self.find(self.id[u])\n            return self.id[u]\n\n        def isComplete(self, u):\n            return self.nodeCount[u] * (self.nodeCount[u] - 1) // 2 == self.edgeCount[u]\n    solution = Solution()\n    n = 5\n    edges = [[0, 1], [1, 2], [3, 4]]\n    self.assertEqual(solution.countCompleteComponents(n, edges), 2)", "27": "def test_countCompleteComponents(self):\n    class Solution:\n        def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\n            # Implementation of the function is not provided here\n\n    solution = Solution()\n    ans = solution.countCompleteComponents(5, [[0, 1], [1, 2], [3, 4]])", "29": "def test_countCompleteComponents(self):\n\n    class Solution:\n\n        def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\n            ans = 0\n            uf = UnionFind(n)\n            parents = set()\n            for (u, v) in edges:\n                uf.unionByRank(u, v)\n            for i in range(n):\n                parent = uf.find(i)\n                if parent not in parents and uf.isComplete(parent):\n                    ans += 1\n                    parents.add(parent)\n            return ans\n\n    class UnionFind:\n\n        def __init__(self, n: int):\n            self.id = list(range(n))\n            self.rank = [0] * n\n            self.nodeCount = [1] * n\n            self.edgeCount = [0] * n\n\n        def unionByRank(self, u: int, v: int) -> None:\n            i = self.find(u)\n            j = self.find(v)\n            self.edgeCount[i] += 1\n            if i == j:\n                return\n            if self.rank[i] < self.rank[j]:\n                self.id[i] = j\n                self.edgeCount[j] += self.edgeCount[i]\n                self.nodeCount[j] += self.nodeCount[i]\n            elif self.rank[i] > self.rank[j]:\n                self.id[j] = i\n                self.edgeCount[i] += self.edgeCount[j]\n                self.nodeCount[i] += self.nodeCount[j]\n            else:\n                self.id[i] = j\n                self.edgeCount[j] += self.edgeCount[i]\n                self.nodeCount[j] += self.nodeCount[i]\n                self.rank[j] += 1\n\n        def find(self, u: int) -> int:\n            if self.id[u] != u:\n                self.id[u] = self.find(self.id[u])\n            return self.id[u]\n\n        def isComplete(self, u):\n            return self.nodeCount[u] * (self.nodeCount[u] - 1) // 2 == self.edgeCount[u]\n    solution = Solution()\n    n = 4\n    edges = [[0, 1], [0, 3], [1, 2]]\n    self.assertEqual(solution.countCompleteComponents(n, edges), 1)", "30": "def test_countCompleteComponents():\n\n    def test_case1():\n        n = 5\n        edges = [[0, 2], [0, 3], [1, 3]]", "31": "def test_countCompleteComponents(self):\n\n    class Solution:\n\n        def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\n            ans = 0\n            uf = UnionFind(n)\n            parents = set()\n            for (u, v) in edges:\n                uf.unionByRank(u, v)\n            for i in range(n):\n                parent = uf.find(i)\n                if parent not in parents and uf.isComplete(parent):\n                    ans += 1\n                    parents.add(parent)\n            return ans\n    solution = Solution()\n    n = 5\n    edges = [[0, 1], [1, 2], [3, 4]]\n    self.assertEqual(solution.countCompleteComponents(n, edges), 2)", "33": "def test_countCompleteComponents(self):\n\n    class Solution:\n\n        def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\n            ans = 0\n            uf = UnionFind(n)\n            parents = set()\n            for (u, v) in edges:\n                uf.unionByRank(u, v)\n            for i in range(n):\n                parent = uf.find(i)\n                if parent not in parents and uf.isComplete(parent):\n                    ans += 1\n                    parents.add(parent)\n            return ans\n    solution = Solution()\n    n = 5\n    edges = [[0, 2], [0, 3], [1, 2]]\n    self.assertEqual(solution.countCompleteComponents(n, edges), 2)", "34": "def test_countCompleteComponents():\n\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\n        ans = 0\n        uf = UnionFind(n)\n        parents = set()\n        for (u, v) in edges:\n            uf.unionByRank(u, v)\n        for i in range(n):\n            parent = uf.find(i)\n            if parent not in parents and uf.isComplete(parent):\n                ans += 1\n                parents.add(parent)\n        return ans\n    solution = Solution()\n    n = 6\n    edges = [[0, 1], [0, 2], [3, 4]]\n    expectedOutput = 2\n    assert solution.countCompleteComponents(n, edges) == expectedOutput", "35": "def test_countCompleteComponents():\n\n    class TestSolution(unittest.TestCase):\n\n        def test_countCompleteComponents(self):\n            n = 5\n            edges = [[0, 1], [1, 2], [3, 4]]\n            self.assertEqual(Solution().countCompleteComponents(n, edges), 2)\nif __name__ == '__main__':\n    unittest.main()", "36": "def test_countCompleteComponents(self):\n\n    class Solution:\n\n        def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\n            ans = 0\n            uf = UnionFind(n)\n            parents = set()\n            for (u, v) in edges:\n                uf.unionByRank(u, v)\n            for i in range(n):\n                parent = uf.find(i)\n                if parent not in parents and uf.isComplete(parent):\n                    ans += 1\n                    parents.add(parent)\n            return ans\n    solution = Solution()\n    n = 4\n    edges = [[0, 2], [0, 3], [1, 2]]\n    self.assertEqual(solution.countCompleteComponents(n, edges), 1)", "40": "def test_countCompleteComponents(self):\n    solution = Solution()\n    n = 5\n    edges = [[0, 1], [1, 2], [3, 4]]\n    self.assertEqual(solution.countCompleteComponents(n, edges), 2)", "59": "def test_countCompleteComponents():\n    solution = Solution()\n\n    class TestCompleteComponents(unittest.TestCase):\n\n        def test_complete_component(self):\n            solution.countCompleteComponents = lambda self, n, edges: 1", "60": "def test_countCompleteComponents(self):\n    solution = Solution()\n    n = 5\n    edges = [[0, 1], [1, 2], [3, 4]]\n    self.assertEqual(solution.countCompleteComponents(n, edges), 2)"}}
{"task_num": 2699, "task_title": "Modify Graph Edge Weights", "func_name": "modifiedGraphEdges", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\n\nclass Solution:\n  def modifiedGraphEdges(self, n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:\n    kMax = 2_000_000_000\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      if w == -1:\n        continue\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    distToDestination = self._dijkstra(graph, source, destination)\n    if distToDestination < target:\n      return []\n    if distToDestination == target:\n      for edge in edges:\n        if edge[2] == -1:\n          edge[2] = kMax\n      return edges\n\n    for i, (u, v, w) in enumerate(edges):\n      if w != -1:\n        continue\n      edges[i][2] = 1\n      graph[u].append((v, 1))\n      graph[v].append((u, 1))\n      distToDestination = self._dijkstra(graph, source, destination)\n      if distToDestination <= target:\n        edges[i][2] += target - distToDestination\n        for j in range(i + 1, len(edges)):\n          if edges[j][2] == -1:\n            edges[j][2] = kMax\n        return edges\n\n    return []\n\n  def _dijkstra(self, graph: List[List[int]], src: int, dst: int) -> int:\n    dist = [math.inf] * len(graph)\n    minHeap = []\n    dist[src] = 0\n    heapq.heappush(minHeap, (dist[src], src))\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist[dst]\n", "tests": {"19": "def test_modifiedGraphEdges():\n\n    def _helper(n, edges):\n        for i in range(len(edges)):\n            if edges[i][2] == -1:\n                edges[i][2] = 10000000\n        return edges\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, -1], [1, 2, -1]]\n    source = 0\n    destination = 2\n    target = 2\n    result = _helper(n, solution.modifiedGraphEdges(n, edges, source, destination, target))", "25": "def test_modifiedGraphEdges(self):\n    solution = Solution()\n    self.assertEqual(solution.modifiedGraphEdges(1, [[0, 0, -1]], 0, 0, 5), [])", "27": "def test_modifiedGraphEdges():\n\n    class Solution:\n\n        def modifiedGraphEdges(self, n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:\n            kMax = 2000000000\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                if w == -1:\n                    continue\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            distToDestination = self._dijkstra(graph, source, destination)\n            if distToDestination < target:\n                return []\n            if distToDestination == target:\n                for edge in edges:\n                    if edge[2] == -1:\n                        edge[2] = kMax\n                return edges\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, -1], [1, 2, -1]]\n    source = 0\n    destination = 2\n    target = 4\n    assert solution.modifiedGraphEdges(n, edges, source, destination, target) == [[0, 1, 2147483648], [1, 2, 2147483648]]", "28": "def test_modifiedGraphEdges(self):\n\n    class Solution:\n\n        def modifiedGraphEdges(self, n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                if w == -1:\n                    continue\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            distToDestination = self._dijkstra(graph, source, destination)\n            if distToDestination < target:\n                return []\n            if distToDestination == target:\n                for edge in edges:\n                    if edge[2] == -1:\n                        edge[2] = 2000000000\n                return edges\n            for (i, (u, v, w)) in enumerate(edges):\n                if w != -1:\n                    continue\n                edges[i][2] = 1\n                graph[u].append((v, 1))\n                graph[v].append((u, 1))\n                distToDestination = self._dijkstra(graph, source, destination)\n                if distToDestination <= target:\n                    edges[i][2] += target - distToDestination\n                    for j in range(i + 1, len(edges)):\n                        if edges[j][2] == -1:\n                            edges[j][2] = 2000000000\n                    return edges\n            return []\n\n        def _dijkstra(self, graph: List[List[int]], src: int, dst: int) -> int:\n            dist = [float('inf')] * len(graph)\n            minHeap = []\n            dist[src] = 0\n            heapq.heappush(minHeap, (dist[src], src))\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (dist[v], v))\n            return dist[dst]\n    solution = Solution()\n    edges = [[0, 1, -1], [0, 2, -1]]\n    self.assertEqual(solution.modifiedGraphEdges(3, edges, 0, 1, 10), [[0, 1, 11], [0, 2, -1]])", "29": "def test_modifiedGraphEdges():\n    solution = Solution()\n\n    def check_result(edges, expected):\n        result = solution.modifiedGraphEdges(5, edges, 0, 4, 3)", "30": "def test_modifiedGraphEdges():\n\n    class Solution:\n\n        def _dijkstra(self, graph: List[List[int]], src: int, dst: int) -> int:\n            dist = [math.inf] * len(graph)\n            minHeap = []\n            dist[src] = 0\n            heapq.heappush(minHeap, (dist[src], src))\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (dist[v], v))\n            return dist[dst]\n\n        def modifiedGraphEdges(self, n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:\n            kMax = 2000000000\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                if w == -1:\n                    continue\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            distToDestination = self._dijkstra(graph, source, destination)\n            if distToDestination < target:\n                return []\n            if distToDestination == target:\n                for edge in edges:\n                    if edge[2] == -1:\n                        edge[2] = kMax\n                return edges\n            for (i, (u, v, w)) in enumerate(edges):\n                if w != -1:\n                    continue\n                edges[i][2] = 1\n                graph[u].append((v, 1))\n                graph[v].append((u, 1))\n                distToDestination = self._dijkstra(graph, source, destination)\n                if distToDestination <= target:\n                    edges[i][2] += target - distToDestination\n                    for j in range(i + 1, len(edges)):\n                        if edges[j][2] == -1:\n                            edges[j][2] = kMax\n                    return edges\n            return []\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, -1], [0, 2, -1]]\n    source = 0\n    destination = 2\n    target = 1\n    assert solution.modifiedGraphEdges(n, edges, source, destination, target) == [[0, 1, 1], [0, 2, 1]]", "34": "def test_modifiedGraphEdges():\n\n    class Solution:\n\n        def modifiedGraphEdges(self, n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:\n            kMax = 2000000000\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                if w == -1:\n                    continue\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            distToDestination = self._dijkstra(graph, source, destination)\n            if distToDestination < target:\n                return []\n            if distToDestination == target:\n                for edge in edges:\n                    if edge[2] == -1:\n                        edge[2] = kMax\n                return edges\n            for (i, (u, v, w)) in enumerate(edges):\n                if w != -1:\n                    continue\n                edges[i][2] = 1\n                graph[u].append((v, 1))\n                graph[v].append((u, 1))\n                distToDestination = self._dijkstra(graph, source, destination)\n                if distToDestination <= target:\n                    edges[i][2] += target - distToDestination\n                    for j in range(i + 1, len(edges)):\n                        if edges[j][2] == -1:\n                            edges[j][2] = kMax\n                    return edges\n            return []\n\n        def _dijkstra(self, graph: List[List[int]], src: int, dst: int) -> int:\n            dist = [math.inf] * len(graph)\n            minHeap = []\n            dist[src] = 0\n            heapq.heappush(minHeap, (dist[src], src))\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (dist[v], v))\n            return dist[dst]\n    solution = Solution()\n    edges = [[0, 1, -1], [1, 2, -1]]\n    print(solution.modifiedGraphEdges(3, edges, 0, 2, 2))", "40": "def test_modifiedGraphEdges(self):\n    class Solution:\n        # ... (same as above)\n\n    solution = Solution()\n\n    n = 5\n    edges = [[0,1,-1],[1,2,-1],[2,3,-1],[3,4,-1]]\n    source = 0\n    destination = 4\n    target = 2\n\n    result = solution.modifiedGraphEdges(n, edges, source, destination, target)", "41": "def test_modifiedGraphEdges():\n\n    class Solution:\n\n        def modifiedGraphEdges(self, n, edges, source, destination, target):\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                if w == -1:\n                    continue\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            distToDestination = self._dijkstra(graph, source, destination)\n            if distToDestination < target:\n                return []\n            if distToDestination == target:\n                for edge in edges:\n                    if edge[2] == -1:\n                        edge[2] = 2000000000\n                return edges\n            graph[source].append((destination, 0))\n            distToDestination = self._dijkstra(graph, source, destination)\n            for (i, (u, v, w)) in enumerate(edges):\n                if w != -1:\n                    continue\n                edges[i][2] = 1\n                graph[u].append((v, 1))\n                graph[v].append((u, 1))\n                distToDestination = self._dijkstra(graph, source, destination)\n                if distToDestination <= target:\n                    edges[i][2] += target - distToDestination\n                    for j in range(i + 1, len(edges)):\n                        if edges[j][2] == -1:\n                            edges[j][2] = 2000000000\n                    return edges\n            return []\n\n        def _dijkstra(self, graph, src, dst):\n            dist = [float('inf')] * len(graph)\n            minHeap = []\n            dist[src] = 0\n            heapq.heappush(minHeap, (dist[src], src))\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (dist[v], v))\n            return dist[dst]\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, -1], [0, 2, -1], [3, 1, 10]]\n    source = 0\n    destination = 3\n    target = 5\n    expected = [[0, 1, 1], [0, 2, 1], [3, 1, 11]]\n    assert solution.modifiedGraphEdges(n, edges, source, destination, target) == expected", "42": "def test_modifiedGraphEdges():\n\n    class Solution:\n\n        def modifiedGraphEdges(self, n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:\n            kMax = 2000000000\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                if w == -1:\n                    continue\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            distToDestination = self._dijkstra(graph, source, destination)\n            if distToDestination < target:\n                return []\n            if distToDestination == target:\n                for edge in edges:\n                    if edge[2] == -1:\n                        edge[2] = kMax\n                return edges\n            for (i, (u, v, w)) in enumerate(edges):\n                if w != -1:\n                    continue\n                edges[i][2] = 1\n                graph[u].append((v, 1))\n                graph[v].append((u, 1))\n                distToDestination = self._dijkstra(graph, source, destination)\n                if distToDestination <= target:\n                    edges[i][2] += target - distToDestination\n                    for j in range(i + 1, len(edges)):\n                        if edges[j][2] == -1:\n                            edges[j][2] = kMax\n                    return edges\n            return []\n\n        def _dijkstra(self, graph: List[List[int]], src: int, dst: int) -> int:\n            dist = [math.inf] * len(graph)\n            minHeap = []\n            dist[src] = 0\n            heapq.heappush(minHeap, (dist[src], src))\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (dist[v], v))\n            return dist[dst]\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, -1], [1, 2, -1], [2, 3, -1], [4, 3, 2]]\n    source = 4\n    destination = 3\n    target = 2\n    print(solution.modifiedGraphEdges(n, edges, source, destination, target))", "43": "def test_modifiedGraphEdges(self):\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, -1], [1, 2, -1], [2, 3, -1], [3, 0, 2]]\n    source = 0\n    destination = 3\n    target = 5\n    self.assertEqual(solution.modifiedGraphEdges(n, edges, source, destination, target), [[0, 1, 4], [1, 2, -1], [2, 3, -1], [3, 0, 2]])", "44": "def test_modifiedGraphEdges(self):\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, -1], [1, 2, 7], [0, 4, -1]]\n    source = 0\n    destination = 4\n    target = 13\n    expected_output = [[0, 1, 6], [1, 2, 7], [0, 4, 10]]\n    self.assertEqual(solution.modifiedGraphEdges(n, edges, source, destination, target), expected_output)", "57": "def test_modifiedGraphEdges():\n\n    def modifiedGraphEdges(self, n, edges, source, destination, target):\n        kMax = 2000000000\n        graph = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            if w == -1:\n                continue\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        distToDestination = self._dijkstra(graph, source, destination)\n        if distToDestination < target:\n            return []\n        if distToDestination == target:\n            for edge in edges:\n                if edge[2] == -1:\n                    edge[2] = kMax\n            return edges\n        for (i, (u, v, w)) in enumerate(edges):\n            if w != -1:\n                continue\n            edges[i][2] = 1\n            graph[u].append((v, 1))\n            graph[v].append((u, 1))\n            distToDestination = self._dijkstra(graph, source, destination)\n            if distToDestination <= target:\n                edges[i][2] += target - distToDestination\n                for j in range(i + 1, len(edges)):\n                    if edges[j][2] == -1:\n                        edges[j][2] = kMax\n                return edges\n        return []\n\n    class Solution:\n\n        def _dijkstra(self, graph: List[List[int]], src: int, dst: int) -> int:\n            dist = [math.inf] * len(graph)\n            minHeap = []\n            dist[src] = 0\n            heapq.heappush(minHeap, (dist[src], src))\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (dist[v], v))\n            return dist[dst]\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, -1], [1, 2, 7], [2, 3, 8], [3, 4, -1]]\n    source = 0\n    destination = 4\n    target = 10\n    assert solution.modifiedGraphEdges(n, edges, source, destination, target) == [[0, 1, 5], [1, 2, 7], [2, 3, 8], [3, 4, 15]]", "60": "def test_modifiedGraphEdges(self):\n    class Solution:\n        def modifiedGraphEdges(self, n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:\n            # function implementation...\n\n    solution=Solution()\n    n = 5\n    edges = [[0,1,-1],[0,2,4],[1,3,10]]\n    source = 0\n    destination = 3\n    target = 7\n    self.assertEqual(solution.modifiedGraphEdges(n, edges, source, destination, target), [[0,1,6],[0,2,4],[1,3,6]])", "61": "def test_modifiedGraphEdges(self):\n\n    class Solution:\n\n        def modifiedGraphEdges(self, n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:\n            kMax = 2000000000\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                if w == -1:\n                    continue\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            distToDestination = self._dijkstra(graph, source, destination)\n            if distToDestination < target:\n                return []\n            if distToDestination == target:\n                for edge in edges:\n                    if edge[2] == -1:\n                        edge[2] = kMax\n                return edges\n            for (i, (u, v, w)) in enumerate(edges):\n                if w != -1:\n                    continue\n                edges[i][2] = 1\n                graph[u].append((v, 1))\n                graph[v].append((u, 1))\n                distToDestination = self._dijkstra(graph, source, destination)\n                if distToDestination <= target:\n                    edges[i][2] += target - distToDestination\n                    for j in range(i + 1, len(edges)):\n                        if edges[j][2] == -1:\n                            edges[j][2] = kMax\n                    return edges\n            return []\n\n        def _dijkstra(self, graph: List[List[int]], src: int, dst: int) -> int:\n            dist = [math.inf] * len(graph)\n            minHeap = []\n            dist[src] = 0\n            heapq.heappush(minHeap, (dist[src], src))\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (dist[v], v))\n            return dist[dst]\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, -1], [1, 2, -1]]\n    source = 0\n    destination = 2\n    target = 1\n    self.assertEqual(solution.modifiedGraphEdges(n, edges, source, destination, target), [[0, 1, 1], [1, 2, 1]])"}}
{"task_num": 2708, "task_title": "Maximum Strength of a Group", "func_name": "maxStrength", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxStrength(self, nums: List[int]) -> int:\n    posProd = 1\n    negProd = 1\n    maxNeg = -math.inf\n    negCount = 0\n    hasPos = False\n    hasZero = False\n\n    for num in nums:\n      if num > 0:\n        posProd *= num\n        hasPos = True\n      elif num < 0:\n        negProd *= num\n        maxNeg = max(maxNeg, num)\n        negCount += 1\n      else:\n        hasZero = True\n\n    if negCount == 0 and not hasPos:\n      return 0\n    if negCount % 2 == 0:\n      return negProd * posProd\n    if negCount >= 3:\n      return negProd // maxNeg * posProd\n    if hasPos:\n      return posProd\n    if hasZero:\n      return 0\n    return maxNeg\n", "tests": {"22": "def test_maxStrength():\n    solution = Solution()\n    def runTest(nums):", "23": "def test_maxStrength():\n    solution = Solution()\n\n    def test_positive_numbers():\n        nums = [1, 2, 3]\n        result = solution.maxStrength(nums)", "25": "def test_maxStrength(self):\n    solution = Solution()\n    self.assertEqual(solution.maxStrength([-1, 2, 3]), -6)", "26": "def test_maxStrength():\n\n    class Solution:\n\n        def maxStrength(self, nums):\n            posProd = 1\n            negProd = 1\n            maxNeg = -math.inf\n            negCount = 0\n            hasPos = False\n            hasZero = False\n            for num in nums:\n                if num > 0:\n                    posProd *= num\n                    hasPos = True\n                elif num < 0:\n                    negProd *= num\n                    maxNeg = max(maxNeg, num)\n                    negCount += 1\n                else:\n                    hasZero = True\n            solution = Solution()\n            assert solution.maxStrength([3]) == 3", "27": "def test_maxStrength():\n\n    class Solution:\n\n        def maxStrength(self, nums):\n            posProd = 1\n            negProd = 1\n            maxNeg = -float('inf')\n            negCount = 0\n            hasPos = False\n            hasZero = False\n            for num in nums:\n                if num > 0:\n                    posProd *= num\n                    hasPos = True\n                elif num < 0:\n                    negProd *= num\n                    maxNeg = max(maxNeg, num)\n                    negCount += 1\n                else:\n                    hasZero = True\n            return negCount == 27 and (not hasPos)", "29": "def test_maxStrength():\n\n    class Solution:\n\n        def maxStrength(self, nums):\n            posProd = 1\n            negProd = 1\n            maxNeg = -float('inf')\n            negCount = 0\n            hasPos = False\n            hasZero = False\n            for num in nums:\n                if num > 0:\n                    posProd *= num\n                    hasPos = True\n                elif num < 0:\n                    negProd *= num\n                    maxNeg = max(maxNeg, num)\n                    negCount += 1\n                else:\n                    hasZero = True\n            if negCount == 0 and (not hasPos):\n                return 0\n            if negCount % 2 == 0:\n                return negProd * posProd\n            if negCount >= 3:\n                return negProd // maxNeg * posProd\n            if hasPos:\n                return posProd\n            if hasZero:\n                return 0\n            return maxNeg\n    solution = Solution()\n    assert solution.maxStrength([1, 2, -1, 0]) == 0", "32": "def test_maxStrength():\n\n    def maxStrength(self, nums):\n        if not len(nums) and any((x > 0 for x in nums)):\n            return 0\n        else:\n            raise Exception('Invalid input')\n    solution = Solution()\n    print(solution.maxStrength([1, -2, -3]))", "34": "def test_maxStrength():\n\n    class Solution:\n\n        def maxStrength(self, nums):\n            solution = self\n            nums = [5, -2, 3]", "36": "def test_maxStrength():\n\n    def maxStrength(nums):\n        if len(nums) == 0:\n            raise ValueError('Input array is empty')\n        elif all((x <= 0 for x in nums)):\n            return -1e+20\n        pos = [x for x in nums if x > 0]\n        neg = sorted([x for x in nums if x < 0], reverse=True)\n        prod_pos = functools.reduce(lambda x, y: x * y, pos, 1)\n        prod_neg = functools.reduce(lambda x, y: x * y, [neg[0]] + neg[2:], 1)\n        return prod_neg // max(neg[:3]) * prod_pos\n    assert maxStrength([-2, -4, -7, 0, 4]) == -56", "38": "def test_maxStrength():\n    solution = Solution()\n    \n    def get_result(nums):", "40": "def test_maxStrength():\n\n    class Solution:\n\n        def maxStrength(self, nums):\n            posProd = 1\n            negProd = 1\n            maxNeg = -float('inf')\n            negCount = 0\n            hasPos = False\n            hasZero = False\n            for num in nums:\n                if num > 0:\n                    posProd *= num\n                    hasPos = True\n                elif num < 0:\n                    negProd *= num\n                    maxNeg = max(maxNeg, num)\n                    negCount += 1\n                else:\n                    hasZero = True\n            return 0\n    solution = Solution()\n    print(solution.maxStrength([0]))"}}
{"task_num": 2709, "task_title": "Greatest Common Divisor Traversal", "func_name": "canTraverseAllPairs", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.sz = [1] * n\n\n  def unionBySize(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.sz[i] < self.sz[j]:\n      self.sz[j] += self.sz[i]\n      self.id[i] = j\n    else:\n      self.sz[i] += self.sz[j]\n      self.id[j] = i\n\n  def getSize(self, i: int) -> int:\n    return self.sz[i]\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def canTraverseAllPairs(self, nums: List[int]) -> bool:\n    n = len(nums)\n    max_num = max(nums)\n    maxPrimeFactor = self._sieveEratosthenes(max_num + 1)\n    primeToFirstIndex = collections.defaultdict(int)\n    uf = UnionFind(n)\n\n    for i, num in enumerate(nums):\n      for prime_factor in self._getPrimeFactors(num, maxPrimeFactor):\n        if prime_factor in primeToFirstIndex:\n          uf.unionBySize(primeToFirstIndex[prime_factor], i)\n        else:\n          primeToFirstIndex[prime_factor] = i\n\n    return any(uf.getSize(i) == n for i in range(n))\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeFactors(self, num: int, minPrimeFactors: List[int]) -> List[int]:\n    primeFactors = []\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      primeFactors.append(divisor)\n      while num % divisor == 0:\n        num //= divisor\n    return primeFactors\n", "tests": {"20": "def test_canTraverseAllPairs(self):\n    nums = [2, 4, 8]\n    self.assertTrue(solution.canTraverseAllPairs(nums))", "22": "def test_canTraverseAllPairs():\n    solution = Solution()\n\n    def can_traverse_all_pairs():\n        n = 5\n        nums = [14, 21, 7, 16, 18]", "23": "def test_canTraverseAllPairs():\n    solution = Solution()\n\n    def get_nums(size):\n        nums = []\n        for i in range(1, size + 1):\n            prime_factors = [2] * (i // 2) + [3]\n            num = 1\n            while len(prime_factors) < size:\n                p = max(prime_factors)\n                if len([f for f in prime_factors if f == p]) > 1:\n                    continue\n                num *= p\n                prime_factors.append(p)\n            nums.append(num)\n        return nums\n\n    def get_ids(size):\n        ids = [0] * size\n        uf = UnionFind(size)\n        for (i, id) in enumerate(ids):\n            uf.unionBySize(0, i)\n        return ids\n    n = 5\n    max_num = sum(get_nums(n))\n    nums = get_nums(n)\n    solution.canTraverseAllPairs(nums)", "25": "def test_canTraverseAllPairs(self):\n    nums = [2, 4, 6]\n    self.assertTrue(solution.canTraverseAllPairs(nums))", "26": "def test_canTraverseAllPairs():\n    solution = Solution()\n    nums = [2, 3, 4, 6]\n    assert solution.canTraverseAllPairs(nums) == True", "33": "def test_canTraverseAllPairs(self):\n    nums = [2, 4, 6]\n    self.assertTrue(solution.canTraverseAllPairs(nums))", "48": "def test_canTraverseAllPairs(self):\n\n    class Solution:\n\n        def canTraverseAllPairs(self, nums: List[int]) -> bool:\n            n = len(nums)\n            max_num = max(nums)\n            maxPrimeFactor = self._sieveEratosthenes(max_num + 1)\n            primeToFirstIndex = collections.defaultdict(int)\n            uf = UnionFind(n)\n            for (i, num) in enumerate(nums):\n                for prime_factor in self._getPrimeFactors(num, maxPrimeFactor):\n                    if prime_factor in primeToFirstIndex:\n                        uf.unionBySize(primeToFirstIndex[prime_factor], i)\n                    else:\n                        primeToFirstIndex[prime_factor] = i\n            return any((uf.getSize(i) == n for i in range(n)))\n\n    class UnionFind:\n\n        def __init__(self, n: int):\n            self.id = list(range(n))\n            self.sz = [1] * n\n\n        def unionBySize(self, u: int, v: int) -> None:\n            if u > v:\n                (u, v) = (v, u)\n            self.id[v] = u\n            self.sz[u] += self.sz[v]\n\n    class collections:\n\n        class defaultdict(dict):\n            pass\n\n    class heapq:\n        pass\n\n    class sortedcontainers:\n        pass\n\n    class string:\n        pass\n\n    class itertools:\n        pass\n    nums = [4, 6, 8]\n    solution = Solution()\n    result = solution.canTraverseAllPairs(nums)", "50": "def test_canTraverseAllPairs():\n    solution = Solution()\n\n    def generate_nums(nums):\n        return [2 ** 3, 5 ** 2, 7, 11 ** 2]\n    assert solution.canTraverseAllPairs(generate_nums([1]))", "58": "def test_canTraverseAllPairs():\n\n    class Solution:\n\n        def canTraverseAllPairs(self, nums):\n            n = len(nums)\n            max_num = max(nums)\n            maxPrimeFactor = self._sieveEratosthenes(max_num + 1)\n            primeToFirstIndex = collections.defaultdict(int)\n            uf = UnionFind(n)\n            for (i, num) in enumerate(nums):\n                for prime_factor in self._getPrimeFactors(num, maxPrimeFactor):\n                    if prime_factor in primeToFirstIndex:\n                        uf.unionBySize(primeToFirstIndex[prime_factor], i)\n                    else:\n                        primeToFirstIndex[prime_factor] = i\n            return any((uf.getSize(i) == n for i in range(n)))\n\n        def _sieveEratosthenes(self, n):\n            minPrimeFactors = [i for i in range(n + 1)]\n            for i in range(2, int(n ** 0.5) + 1):\n                if minPrimeFactors[i] == i:\n                    for j in range(i * i, n + 1, i):\n                        minPrimeFactors[j] = i\n            return minPrimeFactors\n\n        def _getPrimeFactors(self, num, minPrimeFactors):\n            primeFactors = []\n            while num > 1:\n                divisor = minPrimeFactors[num]\n                primeFactors.append(divisor)\n                while num % divisor == 0:\n                    num //= divisor\n            return primeFactors\n    solution = Solution()\n    nums = [2 ** 10, 3 ** 5, 4 ** 6, 2 ** 15]\n    assert solution.canTraverseAllPairs(nums) is True", "59": "def test_canTraverseAllPairs():\n    solution = Solution()\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    nums = [25, 27, 29, 31]\n    uf = solution.UnionFind(len(nums))\n    max_num = max(nums)\n    minPrimeFactors = solution._sieveEratosthenes(max_num + 1)\n    primeToFirstIndex = {}\n    for (i, num) in enumerate(nums):\n        factors = solution._getPrimeFactors(num, minPrimeFactors)\n        for factor in factors:\n            if is_prime(factor):\n                continue\n            uf.unionBySize(primeToFirstIndex.get(factor, -1), i)\n            primeToFirstIndex[factor] = i\n    return not any((uf.getSize(i) != len(nums) for i in range(len(nums))))"}}
{"task_num": 2736, "task_title": "Maximum Sum Queries", "func_name": "maximumSumQueries", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Pair:\n  def __init__(self, x: int, y: int):\n    self.x = x\n    self.y = y\n\n  def __iter__(self):\n    yield self.x\n    yield self.y\n\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, minX: int, minY: int):\n    self.queryIndex = queryIndex\n    self.minX = minX\n    self.minY = minY\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.minX\n    yield self.minY\n\n\nclass Solution:\n  def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n    pairs = sorted([Pair(nums1[i], nums2[i])\n                   for i in range(len(nums1))], key=lambda p: p.x, reverse=True)\n    ans = [0] * len(queries)\n    stack = []  # [(y, x + y)]\n\n    pairsIndex = 0\n    for queryIndex, minX, minY in sorted([IndexedQuery(i, query[0], query[1]) for i, query in enumerate(queries)], key=lambda iq: -iq.minX):\n      while pairsIndex < len(pairs) and pairs[pairsIndex].x >= minX:\n        x, y = pairs[pairsIndex]\n        while stack and x + y >= stack[-1][1]:\n          stack.pop()\n        if not stack or y > stack[-1][0]:\n          stack.append((y, x + y))\n        pairsIndex += 1\n      j = self._firstGreaterEqual(stack, minY)\n      if j == len(stack):\n        ans[queryIndex] = -1\n      else:\n        ans[queryIndex] = stack[j][1]\n\n    return ans\n\n  def _firstGreaterEqual(self, A: List[Tuple[int, int]], target: int) -> int:\n    l = 0\n    r = len(A)\n    while l < r:\n      m = (l + r) // 2\n      if A[m][0] >= target:\n        r = m\n      else:\n        l = m + 1\n    return l\n", "tests": {"47": "def test_maximumSumQueries():\n\n    class Solution:\n\n        def maximumSumQueries(self, nums1, nums2, queries):\n            pairs = sorted([Pair(nums1[i], nums2[i]) for i in range(len(nums1))], key=lambda p: p.x, reverse=True)\n            ans = [0] * len(queries)\n            stack = []\n            pairsIndex = 0\n            for (queryIndex, minX, minY) in sorted([IndexedQuery(i, query[0], query[1]) for (i, query) in enumerate(queries)], key=lambda iq: -iq.minX):\n                while pairsIndex < len(pairs) and pairs[pairsIndex].x >= minX:\n                    (x, y) = pairs[pairsIndex]\n                    while stack and x + y >= stack[-1][1]:\n                        stack.pop()\n                    if not stack or y > stack[-1][0]:\n                        stack.append((y, x + y))\n                    pairsIndex += 1\n                j = self._firstGreaterEqual(stack, minY)\n                if j == len(stack):\n                    ans[queryIndex] = -1\n                else:\n                    ans[queryIndex] = stack[j][1]\n            return ans\n\n        def _firstGreaterEqual(self, A, target):\n            l = 0\n            r = len(A)\n            while l < r:\n                m = (l + r) // 2\n                if A[m][0] >= target:\n                    r = m\n                else:\n                    l = m + 1\n            return l\n    solution = Solution()\n    nums1 = [10, 20, 30]\n    nums2 = [5, 15, 25]\n    queries = [[20, 20], [20, 30]]\n    result = solution.maximumSumQueries(nums1, nums2, queries)", "51": "def test_maximumSumQueries():\n\n    class Solution:\n\n        def maximumSumQueries(self, nums1, nums2, queries):\n            pairs = sorted([Pair(nums1[i], nums2[i]) for i in range(len(nums1))], key=lambda p: p.x, reverse=True)\n            ans = [0] * len(queries)\n            stack = []\n            pairsIndex = 0\n            for (queryIndex, minX, minY) in sorted([IndexedQuery(i, query[0], query[1]) for (i, query) in enumerate([[3, 5]])], key=lambda iq: -iq.minX):\n                while pairsIndex < len(pairs) and pairs[pairsIndex].x >= minX:\n                    (x, y) = pairs[pairsIndex]\n                    while stack and x + y >= stack[-1][1]:\n                        stack.pop()\n                    if not stack or y > stack[-1][0]:\n                        stack.append((y, x + y))\n                    pairsIndex += 1\n                j = self._firstGreaterEqual(stack, minY)\n                if j == len(stack):\n                    ans[queryIndex] = -1\n                else:\n                    ans[queryIndex] = stack[j][1]\n            return ans\n    solution = Solution()\n    print(solution.maximumSumQueries([3, 4, 5], [5, 6, 7], [[3, 5]]))", "53": "def test_maximumSumQueries():\n\n    class Solution:\n\n        def maximumSumQueries(self, nums1, nums2, queries):\n            return self._maximumSumQueriesHelper(nums1, nums2, queries)\n\n        def _maximumSumQueriesHelper(self, nums1, nums2, queries):\n            pairs = sorted([Pair(nums1[i], nums2[i]) for i in range(len(nums1))], key=lambda p: p.x, reverse=True)\n            ans = [0] * len(queries)\n            stack = []\n            pairsIndex = 0\n            for (queryIndex, minX, minY) in sorted([IndexedQuery(i, query[0], query[1]) for (i, query) in enumerate(queries)], key=lambda iq: -iq.minX):\n                while pairsIndex < len(pairs) and pairs[pairsIndex].x >= minX:\n                    (x, y) = pairs[pairsIndex]\n                    while stack and x + y >= stack[-1][1]:\n                        stack.pop()\n                    if not stack or y > stack[-1][0]:\n                        stack.append((y, x + y))\n                    pairsIndex += 1\n                j = self._firstGreaterEqual(stack, minY)\n                if j == len(stack):\n                    ans[queryIndex] = -1\n                else:\n                    ans[queryIndex] = stack[j][1]\n            return ans\n\n        def _firstGreaterEqual(self, A, target):\n            l = 0\n            r = len(A)\n            while l < r:\n                m = (l + r) // 2\n                if A[m][0] >= target:\n                    r = m\n                else:\n                    l = m + 1\n            return l\n    solution = Solution()\n    nums1 = [10, 100, 200, 300]\n    nums2 = [40, 50, 60, 70]\n    queries = [[80, 20], [150, 90]]\n    print(solution.maximumSumQueries(nums1, nums2, queries))", "63": "def test_maximumSumQueries():\n\n    class Solution:\n\n        def maximumSumQueries(self, nums1, nums2, queries):\n            pairs = sorted([Pair(nums1[i], nums2[i]) for i in range(len(nums1))], key=lambda p: p.x, reverse=True)\n            ans = [0] * len(queries)\n            stack = []\n            pairsIndex = 0\n            for (queryIndex, minX, minY) in sorted([IndexedQuery(i, query[0], query[1]) for (i, query) in enumerate(queries)], key=lambda iq: -iq.minX):\n                while pairsIndex < len(pairs) and pairs[pairsIndex].x >= minX:\n                    (x, y) = pairs[pairsIndex]\n                    while stack and x + y >= stack[-1][1]:\n                        stack.pop()\n                    if not stack or y > stack[-1][0]:\n                        stack.append((y, x + y))\n                    pairsIndex += 1\n                j = self._firstGreaterEqual(stack, minY)\n                if j == len(stack):\n                    ans[queryIndex] = -1\n                else:\n                    ans[queryIndex] = stack[j][1]\n            return ans\n\n        def _firstGreaterEqual(self, A, target):\n            l = 0\n            r = len(A)\n            while l < r:\n                m = (l + r) // 2\n                if A[m][0] >= target:\n                    r = m\n                else:\n                    l = m + 1\n            return l\n    solution = Solution()\n    nums1 = [10, 5, 3]\n    nums2 = [8, 6, 7]\n    queries = [[3, 4], [1, 0]]\n    print(solution.maximumSumQueries(nums1, nums2, queries))", "65": "def test_maximumSumQueries():\n\n    class Solution:\n\n        def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n            pairs = sorted([Pair(nums1[i], nums2[i]) for i in range(len(nums1))], key=lambda p: p.x, reverse=True)\n            ans = [0] * len(queries)\n            stack = []\n            pairsIndex = 0\n            for (queryIndex, minX, minY) in sorted([IndexedQuery(i, query[0], query[1]) for (i, query) in enumerate(queries)], key=lambda iq: -iq.minX):\n                while pairsIndex < len(pairs) and pairs[pairsIndex].x >= minX:\n                    (x, y) = pairs[pairsIndex]\n                    while stack and x + y >= stack[-1][1]:\n                        stack.pop()\n                    if not stack or y > stack[-1][0]:\n                        stack.append((y, x + y))\n                    pairsIndex += 1\n                j = self._firstGreaterEqual(stack, minY)\n                if j == len(stack):\n                    ans[queryIndex] = -1\n                else:\n                    ans[queryIndex] = stack[j][1]\n            return ans\n\n        def _firstGreaterEqual(self, A: List[Tuple[int, int]], target: int) -> int:\n            l = 0\n            r = len(A)\n            while l < r:\n                m = (l + r) // 2\n                if A[m][0] >= target:\n                    r = m\n                else:\n                    l = m + 1\n            return l\n    solution = Solution()\n    nums1 = [10, 20, 30]\n    nums2 = [5, 15, 25]\n    queries = [[7, 4], [8, 3], [9, 2]]\n    result = solution.maximumSumQueries(nums1, nums2, queries)"}}
{"task_num": 2747, "task_title": "Count Zero Request Servers", "func_name": "countServers", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, query: int):\n    self.queryIndex = queryIndex\n    self.query = query\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.query\n\n\nclass Solution:\n  def countServers(self, n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:\n    ans = [0] * len(queries)\n    count = [0] * (n + 1)\n\n    logs.sort(key=lambda log: log[1])\n\n    i = 0\n    j = 0\n    servers = 0\n\n    for queryIndex, query in sorted([IndexedQuery(i, query) for i, query in enumerate(queries)], key=lambda iq: iq.query):\n      while j < len(logs) and logs[j][1] <= query:\n        count[logs[j][0]] += 1\n        if count[logs[j][0]] == 1:\n          servers += 1\n        j += 1\n      while i < len(logs) and logs[i][1] < query - x:\n        count[logs[i][0]] -= 1\n        if count[logs[i][0]] == 0:\n          servers -= 1\n        i += 1\n      ans[queryIndex] = n - servers\n\n    return ans\n", "tests": {"36": "def test_countServers(self):\n    solution = Solution()\n    n = 5\n    logs = [[1, 10], [2, 15], [3, 20], [4, 25], [5, 30]]\n    x = 2\n    queries = [8, 7]\n    self.assertEqual(solution.countServers(n, logs, x, queries), [0, 1])", "41": "def test_countServers():\n\n    def countServers(n, logs, x, queries):\n        ans = [0] * len(queries)\n        count = [0] * (n + 1)\n        logs.sort(key=lambda log: log[1])\n        i = 0\n        j = 0\n        servers = 0\n        for (queryIndex, query) in sorted([IndexedQuery(i, query) for (i, query) in enumerate(queries)], key=lambda iq: iq.query):\n            while j < len(logs) and logs[j][1] <= query:\n                count[logs[j][0]] += 1\n                if count[logs[j][0]] == 1:\n                    servers += 1\n                j += 1\n            while i < len(logs) and logs[i][1] < query - x:\n                count[logs[i][0]] -= 1\n                if count[logs[i][0]] == 0:\n                    servers = max(servers - 1, 0)\n                i += 1\n            ans[queryIndex] = n - servers\n        return ans\n    logs = [[1, 10], [2, 15]]\n    queries = [14]\n    print(countServers(3, logs, 5, queries))"}}
{"task_num": 2751, "task_title": "Robot Collisions", "func_name": "survivedRobotsHealths", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\nfrom dataclasses import dataclass\n\n@dataclass\nclass Robot:\n  index: int\n  position: int\n  health: int\n  direction: str\n\n\nclass Solution:\n  def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\n    robots = sorted([Robot(index, position, health, direction) for index, (position, health, direction) in enumerate(zip(positions, healths, directions))], key=lambda robot: robot.position)\n    stack: List[Robot] = []\n\n    for robot in robots:\n      if robot.direction == 'R':\n        stack.append(robot)\n        continue\n      while stack and stack[-1].direction == 'R' and robot.health > 0:\n        if stack[-1].health == robot.health:\n          stack.pop()\n          robot.health = 0\n        elif stack[-1].health < robot.health:\n          stack.pop()\n          robot.health -= 1\n        else:\n          stack[-1].health -= 1\n          robot.health = 0\n      if robot.health > 0:\n        stack.append(robot)\n\n    stack.sort(key=lambda robot: robot.index)\n    return [robot.health for robot in stack]\n", "tests": {"27": "def test_survivedRobotsHealths(self):\n    solution = Solution()\n    positions = [1, 3, 2]\n    healths = [10, 5, 15]\n    directions = ['R', 'L', 'R']\n    self.assertEqual(solution.survivedRobotsHealths(positions, healths, directions), [0, 4, 14])", "28": "    def test_survivedRobotsHealths(self):\n        positions = [1, 2, 3]\n        healths = [5, 4, 6]\n        directions = ['R', 'L', 'R']\n        self.assertEqual(solution-survivedRobotsHealths(positions, healths, directions), [0, 4, 0])\n\nif __name__ == '__main__':\n    unittest.main()", "31": "def test_survivedRobotsHealths():\n\n    def test_collide_both_health_zero(sut):\n        result = sut.survivedRobotsHealths([0, 1], [10, 10], ['R', 'L'])\n        assert result == [], f'Expected empty list but got {result}'\n    solution = Solution()\n    test_collide_both_health_zero(solution)", "32": "def test_survivedRobotsHealths():\n    solution = Solution()\n\n    def assert_equal(a, b):\n        if a != b:\n            print(f'Expected: {a}, Got: {b}')\n    result = solution.survivedRobotsHealths([0], [5], ['L'])", "34": "def test_survivedRobotsHealths():\n    solution = Solution()\n\n    def make_robots(positions=[5, 3, 1], healths=[10, 5, 8], directions='LRLL'):\n        return [Robot(0, p, h, d) for (p, h, d) in zip(positions, healths, directions)]\n\n    def test_case(positions, healths, directions):\n        robots = make_robots(positions, healths, directions)\n        assert solution.survivedRobotsHealths(positions, healths, directions) == [0, 5, 9]", "35": "def test_survivedRobotsHealths():\n\n    class Solution:\n\n        def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\n            robots = sorted([Robot(index, position, health, direction) for (index, (position, health, direction)) in enumerate(zip(positions, healths, directions))], key=lambda robot: robot.position)\n            stack: List[Robot] = []\n            for robot in robots:\n                if robot.direction == 'R':\n                    stack.append(robot)\n                    continue\n                while stack and stack[-1].direction == 'R' and (robot.health > 0):\n                    if stack[-1].health == robot.health:\n                        stack.pop()\n                        robot.health = 0\n                    elif stack[-1].health < robot.health:\n                        stack.pop()\n                        robot.health -= 1\n                    else:\n                        stack[-1].health -= 1\n                        robot.health = 0\n                if robot.health > 0:\n                    stack.append(robot)\n            stack.sort(key=lambda robot: robot.index)\n            return [robot.health for robot in stack]\n    import unittest\n\n    class TestSurvivedRobotsHealths(unittest.TestCase):\n\n        def test_survivedRobotsHealths(self):\n            solution = Solution()\n            positions = [3, 0, 1]\n            healths = [2, 5, 4]\n            directions = 'RRLL'\n            result = solution.survivedRobotsHealths(positions, healths, directions)", "37": "def test_survivedRobotsHealths():\n    solution = Solution()\n    positions = [10, 5, 15]\n    healths = [2, 1, 3]\n    directions = ['L', 'R', 'R']\n    result = solution.survivedRobotsHealths(positions, healths, directions)", "38": "def test_survivedRobotsHealths():\n\n    def survivedRobotsHealths(positions, healths, directions):\n        robots = sorted([Robot(index, position, health, direction) for (index, (position, health, direction)) in enumerate(zip(positions, healths, directions))], key=lambda robot: robot.position)\n        stack = []\n        for robot in robots:\n            if robot.direction == 'R':\n                stack.append(robot)\n                continue\n            while stack and stack[-1].direction == 'R' and (robot.health > 0):\n                if stack[-1].health == robot.health:\n                    stack.pop()\n                    robot.health = 0\n                elif stack[-1].health < robot.health:\n                    stack.pop()\n                    robot.health -= 1\n                else:\n                    stack[-1].health -= 1\n                    robot.health = 0\n            if robot.health > 0:\n                stack.append(robot)\n        stack.sort(key=lambda robot: robot.index)\n        return [robot.health for robot in stack]\n    solution = Solution()\n    positions = [10, 4]\n    healths = [12, 7]\n    directions = ['R', 'L']\n    assert survivedRobotsHealths(positions, healths, directions) == []", "40": "def test_survivedRobotsHealths():\n\n    class Solution:\n\n        def survivedRobotsHealths(self, positions, healths, directions):\n            robots = sorted([Robot(index, position, health, direction) for (index, (position, health, direction)) in enumerate(zip(positions, healths, directions))], key=lambda robot: robot.position)\n            stack = []\n            for robot in robots:\n                if robot.direction == 'R':\n                    stack.append(robot)\n                    continue\n                while stack and stack[-1].direction == 'R' and (robot.health > 0):\n                    if stack[-1].health == robot.health:\n                        stack.pop()\n                        robot.health = 0\n                    elif stack[-1].health < robot.health:\n                        stack.pop()\n                        robot.health -= 1\n                    else:\n                        stack[-1].health -= 1\n                        robot.health = 0\n                if robot.health > 0:\n                    stack.append(robot)\n            stack.sort(key=lambda robot: robot.index)\n            return [robot.health for robot in stack]\n\n    class Robot:\n\n        def __init__(self, index, position, health, direction):\n            self.index = index\n            self.position = position\n            self.health = health\n            self.direction = direction\n    solution = Solution()\n    result = solution.survivedRobotsHealths([1, 2, 3], [10, 20, 30], ['R', 'L', 'R'])"}}
{"task_num": 2812, "task_title": "Find the Safest Path in a Grid", "func_name": "maximumSafenessFactor", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumSafenessFactor(self, grid: List[List[int]]) -> int:\n    self.dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    n = len(grid)\n    distToThief = self._getDistToThief(grid)\n\n    def hasValidPath(safeness: int) -> bool:\n      if distToThief[0][0] < safeness:\n        return False\n\n      q = collections.deque([(0, 0)])\n      seen = {(0, 0)}\n\n      while q:\n        i, j = q.popleft()\n        if distToThief[i][j] < safeness:\n          continue\n        if i == n - 1 and j == n - 1:\n          return True\n        for dx, dy in self.dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == n or y < 0 or y == n:\n            continue\n          if (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n\n      return False\n\n    return bisect.bisect_left(range(n * 2), True, key=lambda m: not hasValidPath(m)) - 1\n\n  def _getDistToThief(self, grid: List[List[int]]) -> List[List[int]]:\n    n = len(grid)\n    distToThief = [[0] * n for _ in range(n)]\n    q = collections.deque()\n    seen = set()\n\n    for i in range(n):\n      for j in range(n):\n        if grid[i][j] == 1:\n          q.append((i, j))\n          seen.add((i, j))\n\n    dist = 0\n    while q:\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        distToThief[i][j] = dist\n        for dx, dy in self.dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == n or y < 0 or y == n:\n            continue\n          if (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n      dist += 1\n\n    return distToThief\n", "tests": {"19": "def test_maximumSafenessFactor():\n\n    class Solution:\n\n        def maximumSafenessFactor(self, grid):\n            self.dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            n = len(grid)\n            distToThief = self._getDistToThief(grid)\n\n            def hasValidPath(safeness: int) -> bool:\n                if distToThief[0][0] < safeness:\n                    return False\n                q = collections.deque([(0, 0)])\n                seen = {(0, 0)}\n                while q:\n                    (i, j) = q.popleft()\n                    if distToThief[i][j] < safeness:\n                        continue\n                    if i == n - 1 and j == n - 1:\n                        return True\n                    for (dx, dy) in self.dirs:\n                        x = i + dx\n                        y = j + dy\n                        if x < 0 or x == n or y < 0 or (y == n):\n                            continue\n                        if (x, y) in seen:\n                            continue\n                        q.append((x, y))\n                        seen.add((x, y))\n                return False\n            return bisect.bisect_left(range(n * 2), True, key=lambda m: not hasValidPath(m)) - 1\n\n        def _getDistToThief(self, grid):\n            n = len(grid)\n            distToThief = [[0] * n for _ in range(n)]\n            q = collections.deque()\n            seen = set()\n            for i in range(n):\n                for j in range(n):\n                    if grid[i][j] == 1:\n                        q.append((i, j))\n                        seen.add((i, j))\n            dist = 0\n            while q:\n                for _ in range(len(q)):\n                    (i, j) = q.popleft()\n                    distToThief[i][j] = dist\n                    for (dx, dy) in self.dirs:\n                        x = i + dx\n                        y = j + dy\n                        if x < 0 or x == n or y < 0 or (y == n):\n                            continue\n                        if (x, y) in seen:\n                            continue\n                        q.append((x, y))\n                        seen.add((x, y))\n                dist += 1\n            return distToThief\n    solution = Solution()\n    grid = [[0, 1], [1, 0]]\n    assert solution.maximumSafenessFactor(grid) == 2", "27": "def test_maximumSafenessFactor():\n\n    class Solution:\n\n        def __init__(self):\n            self.dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n\n        def maximumSafenessFactor(self, grid: List[List[int]]) -> int:\n            n = len(grid)\n            distToThief = self._getDistToThief(grid)\n\n            def hasValidPath(safeness: int) -> bool:\n                if distToThief[0][0] < safeness:\n                    return False\n                q = collections.deque([(0, 0)])\n                seen = {(0, 0)}\n                while q:\n                    (i, j) = q.popleft()\n                    if distToThief[i][j] < safeness:\n                        continue\n                    if i == n - 1 and j == n - 1:\n                        return True\n                    for (dx, dy) in self.dirs:\n                        x = i + dx\n                        y = j + dy\n                        if x < 0 or x == n or y < 0 or (y == n):\n                            continue\n                        if (x, y) in seen:\n                            continue\n                        q.append((x, y))\n                        seen.add((x, y))\n                return False\n            return bisect.bisect_left(range(n * 2), True, key=lambda m: not hasValidPath(m)) - 1\n\n        def _getDistToThief(self, grid: List[List[int]]) -> List[List[int]]:\n            n = len(grid)\n            distToThief = [[0] * n for _ in range(n)]\n            q = collections.deque()\n            seen = set()\n            for i in range(n):\n                for j in range(n):\n                    if grid[i][j] == 1:\n                        q.append((i, j))\n                        seen.add((i, j))\n            dist = 0\n            while q:\n                for _ in range(len(q)):\n                    (i, j) = q.popleft()\n                    distToThief[i][j] = dist\n                    for (dx, dy) in self.dirs:\n                        x = i + dx\n                        y = j + dy\n                        if x < 0 or x == n or y < 0 or (y == n):\n                            continue\n                        if (x, y) in seen:\n                            continue\n                        q.append((x, y))\n                        seen.add((x, y))\n                dist += 1\n            return distToThief\n    solution = Solution()\n    grid = [[0, 0, 1], [1, 1, 1]]\n    print(solution.maximumSafenessFactor(grid))", "29": "def test_maximumSafenessFactor():\n\n    def _getDistToThief(grid):\n        n = len(grid)\n        distToThief = [[0] * n for _ in range(n)]\n        q = collections.deque()\n        seen = set()\n        for i in range(n):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    q.append((i, j))\n                    seen.add((i, j))\n        dist = 0\n        while q:\n            for _ in range(len(q)):\n                (i, j) = q.popleft()\n                distToThief[i][j] = dist\n                for (dx, dy) in ((0, 1), (1, 0), (0, -1), (-1, 0)):\n                    x = i + dx\n                    y = j + dy\n                    if 0 <= x < n and 0 <= y < n and ((x, y) not in seen):\n                        q.append((x, y))\n                        seen.add((x, y))\n            dist += 1\n        return distToThief\n\n    def hasValidPath(safeness):\n        n = len(grid)\n        if grid[0][0] == 1 and _getDistToThief(grid)[0][0] < safeness:\n            return False\n        q = collections.deque([(0, 0)])\n        seen = {(0, 0)}\n        while q:\n            (i, j) = q.popleft()\n            if _getDistToThief(grid)[i][j] >= safeness and (i == n - 1 and j == n - 1):\n                return True\n            for (dx, dy) in ((0, 1), (1, 0), (0, -1), (-1, 0)):\n                x = i + dx\n                y = j + dy\n                if 0 <= x < n and 0 <= y < n and ((x, y) not in seen):\n                    q.append((x, y))\n                    seen.add((x, y))\n    solution = Solution()\n    grid = [[0 for _ in range(3)] for _ in range(3)]\n    grid[2][2] = 1\n    assert solution.maximumSafenessFactor(grid) == 2", "34": "def test_maximumSafenessFactor():\n\n    class Solution:\n\n        def __init__(self):\n            self.dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n\n        def maximumSafenessFactor(self, grid: List[List[int]]) -> int:\n            n = len(grid)\n            distToThief = self._getDistToThief(grid)\n\n            def hasValidPath(safeness: int) -> bool:\n                if distToThief[0][0] < safeness:\n                    return False\n                q = collections.deque([(0, 0)])\n                seen = {(0, 0)}\n                while q:\n                    (i, j) = q.popleft()\n                    if distToThief[i][j] < safeness:\n                        continue\n                    if i == n - 1 and j == n - 1:\n                        return True\n                    for (dx, dy) in self.dirs:\n                        x = i + dx\n                        y = j + dy\n                        if x < 0 or x == n or y < 0 or (y == n):\n                            continue\n                        if (x, y) in seen:\n                            continue\n                        q.append((x, y))\n                        seen.add((x, y))\n                    return False\n                return False\n            return bisect.bisect_left(range(n * 2), True, key=lambda m: not hasValidPath(m)) - 1\n\n        def _getDistToThief(self, grid: List[List[int]]) -> List[List[int]]:\n            n = len(grid)\n            distToThief = [[0] * n for _ in range(n)]\n            q = collections.deque()\n            seen = set()\n            for i in range(n):\n                for j in range(n):\n                    if grid[i][j] == 1:\n                        q.append((i, j))\n                        seen.add((i, j))\n            dist = 0\n            while q:\n                for _ in range(len(q)):\n                    (i, j) = q.popleft()\n                    distToThief[i][j] = dist\n                    for (dx, dy) in self.dirs:\n                        x = i + dx\n                        y = j + dy\n                        if x < 0 or x == n or y < 0 or (y == n):\n                            continue\n                        if (x, y) in seen:\n                            continue\n                        q.append((x, y))\n                        seen.add((x, y))\n                dist += 1\n            return distToThief\n    solution = Solution()\n    grid = [[0] * 3 for _ in range(3)]\n    grid[2][2] = 1\n    print(solution.maximumSafenessFactor(grid))", "36": "def test_maximumSafenessFactor():\n\n    class Solution:\n\n        def maximumSafenessFactor(self, grid):\n            self.dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            n = len(grid)\n            distToThief = self._getDistToThief(grid)\n\n            def hasValidPath(safeness):\n                if distToThief[0][0] < safeness:\n                    return False\n                q = collections.deque([(0, 0)])\n                seen = {(0, 0)}\n                while q:\n                    (i, j) = q.popleft()\n                    if i == n - 1 and j == n - 1:\n                        return True\n                    for (dx, dy) in self.dirs:\n                        x = i + dx\n                        y = j + dy\n                        if x < 0 or x == n or y < 0 or (y == n):\n                            continue\n                        if (x, y) in seen:\n                            continue\n                        q.append((x, y))\n                        seen.add((x, y))\n                return False\n            return bisect.bisect_left(range(n * 2), True, key=lambda m: not hasValidPath(m)) - 1\n\n        def _getDistToThief(self, grid):\n            n = len(grid)\n            distToThief = [[0] * n for _ in range(n)]\n            q = collections.deque()\n            seen = set()\n            for i in range(n):\n                for j in range(n):\n                    if grid[i][j] == 1:\n                        q.append((i, j))\n                        seen.add((i, j))\n            dist = 0\n            while q:\n                for _ in range(len(q)):\n                    (i, j) = q.popleft()\n                    distToThief[i][j] = dist\n                    for (dx, dy) in self.dirs:\n                        x = i + dx\n                        y = j + dy\n                        if (x, y) in seen:\n                            continue\n                        q.append((x, y))\n                        seen.add((x, y))\n                dist += 1\n            return distToThief\n    solution = Solution()\n    grid = [[0]]\n    assert solution.maximumSafenessFactor(grid) == 2", "53": "def test_maximumSafenessFactor():\n\n    class Solution:\n\n        def maximumSafenessFactor(self, grid):\n            self.dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            n = len(grid)\n            distToThief = self._getDistToThief(grid)\n\n            def hasValidPath(safeness):\n                if distToThief[0][0] < safeness:\n                    return False\n                q = collections.deque([(0, 0)])\n                seen = {(0, 0)}\n                while q:\n                    (i, j) = q.popleft()\n                    if distToThief[i][j] < safeness:\n                        continue\n                    if i == n - 1 and j == n - 1:\n                        return True\n                    for (dx, dy) in self.dirs:\n                        x = i + dx\n                        y = j + dy\n                        if x < 0 or x == n or y < 0 or (y == n):\n                            continue\n                        if (x, y) in seen:\n                            continue\n                        q.append((x, y))\n                        seen.add((x, y))\n                    return False\n            return bisect.bisect_left(range(n * n), True, key=lambda m: not hasValidPath(m)) - 1\n\n        def _getDistToThief(self, grid):\n            n = len(grid)\n            distToThief = [[0] * n for _ in range(n)]\n            q = collections.deque()\n            seen = set()\n            for i in range(n):\n                for j in range(n):\n                    if grid[i][j] == 1:\n                        q.append((i, j))\n                        seen.add((i, j))\n            dist = 0\n            while q:\n                for _ in range(len(q)):\n                    (i, j) = q.popleft()\n                    distToThief[i][j] = dist\n                    for (dx, dy) in self.dirs:\n                        x = i + dx\n                        y = j + dy\n                        if x < 0 or x == n or y < 0 or (y == n):\n                            continue\n                        if (x, y) in seen:\n                            continue\n                        q.append((x, y))\n                        seen.add((x, y))\n                dist += 1\n            return distToThief\n    solution = Solution()\n    grid = [[1, 0], [0, 0]]\n    assert solution.maximumSafenessFactor(grid) == 2", "54": "def test_maximumSafenessFactor():\n\n    class Solution:\n\n        def __init__(self):\n            self.dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n\n        def maximumSafenessFactor(self, grid: List[List[int]]) -> int:\n            n = len(grid)\n            distToThief = self._getDistToThief(grid)\n\n            def hasValidPath(safeness: int) -> bool:\n                if distToThief[0][0] < safeness:\n                    return False\n                q = collections.deque([(0, 0)])\n                seen = {(0, 0)}\n                while q:\n                    (i, j) = q.popleft()\n                    if distToThief[i][j] < safeness:\n                        continue\n                    if i == n - 1 and j == n - 1:\n                        return True\n                    for (dx, dy) in self.dirs:\n                        x = i + dx\n                        y = j + dy\n                        if x < 0 or x == n or y < 0 or (y == n):\n                            continue\n                        if (x, y) in seen:\n                            continue\n                        q.append((x, y))\n                        seen.add((x, y))\n                return False\n            return bisect.bisect_left(range(n * n), True, key=lambda m: not hasValidPath(m)) - 1\n\n        def _getDistToThief(self, grid: List[List[int]]) -> List[List[int]]:\n            n = len(grid)\n            distToThief = [[0] * n for _ in range(n)]\n            q = collections.deque()\n            seen = set()\n            for i in range(n):\n                for j in range(n):\n                    if grid[i][j] == 1:\n                        q.append((i, j))\n                        seen.add((i, j))\n            dist = 0\n            while q:\n                for _ in range(len(q)):\n                    (i, j) = q.popleft()\n                    distToThief[i][j] = dist\n                    for (dx, dy) in self.dirs:\n                        x = i + dx\n                        y = j + dy\n                        if x < 0 or x == n or y < 0 or (y == n):\n                            continue\n                        if (x, y) in seen:\n                            continue\n                        q.append((x, y))\n                        seen.add((x, y))\n                dist += 1\n            return distToThief\n    solution = Solution()\n    grid = [[0] * 5 for _ in range(5)]\n    assert solution.maximumSafenessFactor(grid) == 4", "65": "def test_maximumSafenessFactor():\n\n    class Solution:\n\n        def maximumSafenessFactor(self, grid):\n            self.dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            n = len(grid)\n            distToThief = self._getDistToThief(grid)\n\n            def hasValidPath(safeness: int) -> bool:\n                if distToThief[0][0] < safeness:\n                    return False\n                q = collections.deque([(0, 0)])\n                seen = {(0, 0)}\n                while q:\n                    (i, j) = q.popleft()\n                    if i == n - 1 and j == n - 1:\n                        return True\n                    for (dx, dy) in self.dirs:\n                        x = i + dx\n                        y = j + dy\n                        if x < 0 or x == n or y < 0 or (y == n):\n                            continue\n                        q.append((x, y))\n                        seen.add((x, y))\n                return False\n\n            def _getDistToThief(self, grid):\n                n = len(grid)\n                distToThief = [[0] * n for _ in range(n)]\n                q = collections.deque()\n                seen = set()\n                for i in range(n):\n                    for j in range(n):\n                        if grid[i][j] == 1:\n                            q.append((i, j))\n                            seen.add((i, j))\n                dist = 0\n                while q:\n                    for _ in range(len(q)):\n                        (i, j) = q.popleft()\n                        distToThief[i][j] = dist\n                        for (dx, dy) in self.dirs:\n                            x = i + dx\n                            y = j + dy\n                            if grid[x][y] == 1 or (x, y) in seen:\n                                continue\n                            q.append((x, y))\n                            seen.add((x, y))\n                    dist += 1\n                return distToThief\n            return bisect.bisect_left(range(n * n), True, key=lambda m: not hasValidPath(m)) - 1\n    solution = Solution()\n    grid = [[0, 1], [0, 0]]\n    assert solution.maximumSafenessFactor(grid) == 2", "67": "def test_maximumSafenessFactor():\n\n    def maximumSafenessFactor(grid):\n        self.dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n        n = len(grid)\n        distToThief = self._getDistToThief(grid)\n\n        def hasValidPath(safeness: int) -> bool:\n            if distToThief[0][0] < safeness:\n                return False\n            q = collections.deque([(0, 0)])\n            seen = {(0, 0)}\n            while q:\n                (i, j) = q.popleft()\n                if distToThief[i][j] < safeness:\n                    continue\n                if i == n - 1 and j == n - 1:\n                    return True\n                for (dx, dy) in self.dirs:\n                    x = i + dx\n                    y = j + dy\n                    if (x, y) in seen:\n                        return False\n                    q.append((x, y))\n                    seen.add((x, y))\n            return False\n        return bisect.bisect_left(range(n * 2), True, key=lambda m: not hasValidPath(m)) - 1\n    grid = [[0 for _ in range(3)] for _ in range(3)]\n    grid[0][0] = 0\n    solution = Solution()\n    assert maximumSafenessFactor(grid) == 3"}}
{"task_num": 2818, "task_title": "Apply Operations to Maximize Score", "func_name": "maximumScore", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumScore(self, nums: List[int], k: int) -> int:\n    kMod = 1_000_000_007\n    n = len(nums)\n    ans = 1\n    minPrimeFactors = self._sieveEratosthenes(max(nums) + 1)\n    primeScores = [self._getPrimeScore(num, minPrimeFactors) for num in nums]\n    left = [-1] * n\n    right = [n] * n\n    stack = []\n\n    for i in reversed(range(n)):\n      while stack and primeScores[stack[-1]] <= primeScores[i]:\n        left[stack.pop()] = i\n      stack.append(i)\n\n    stack = []\n\n    for i in range(n):\n      while stack and primeScores[stack[-1]] < primeScores[i]:\n        right[stack.pop()] = i\n      stack.append(i)\n\n    numAndIndexes = [(num, i) for i, num in enumerate(nums)]\n\n    def modPow(x: int, n: int) -> int:\n      if n == 0:\n        return 1\n      if n & 1:\n        return x * modPow(x, n - 1) % kMod\n      return modPow(x * x % kMod, n // 2)\n\n    for num, i in sorted(numAndIndexes, key=lambda x: (-x[0], x[1])):\n      rangeCount = (i - left[i]) * (right[i] - i)\n      actualCount = min(rangeCount, k)\n      k -= actualCount\n      ans *= modPow(num, actualCount)\n      ans %= kMod\n\n    return ans\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeScore(self, num: int, minPrimeFactors: List[int]) -> int:\n    primeFactors = set()\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      primeFactors.add(divisor)\n      while num % divisor == 0:\n        num //= divisor\n    return len(primeFactors)\n", "tests": {"38": "def test_maximumScore():\n\n    def _sieveEratosthenes(n):\n        minPrimeFactors = [i for i in range(n + 1)]\n        for i in range(2, int(n ** 0.5) + 1):\n            if minPrimeFactors[i] == i:\n                for j in range(i * i, n, i):\n                    minPrimeFactors[j] = min(minPrimeFactors[j], i)\n        return minPrimeFactors\n\n    def _getPrimeScore(num, minPrimeFactors):\n        primeFactors = set()\n        while num > 1:\n            divisor = minPrimeFactors[num]\n            primeFactors.add(divisor)\n            while num % divisor == 0:\n                num //= divisor\n        return len(primeFactors)\n\n    class Solution:\n\n        def modPow(self, x, n, k):\n            if n == 0:\n                return 1\n            if n & 1:\n                return x * self.modPow(x, n - 1, k) % (10 ** 9 + 7)\n            return self.modPow(x * x % (10 ** 9 + 7), n // 2, 10 ** 9 + 7)\n\n        def maximumScore(self, nums, k):\n            minPrimeFactors = _sieveEratosthenes(max(nums) + 1)\n            primeScores = [_getPrimeScore(num, minPrimeFactors) for num in nums]\n            left = [-1] * len(nums)\n            right = [len(nums)] * len(nums)\n            stackL = []\n            for i in reversed(range(len(nums))):\n                while stackL and primeScores[stackL[-1]] <= primeScores[i]:\n                    left[stackL.pop()] = i\n                stackL.append(i)\n            stackR = []\n            for i in range(len(nums)):\n                while stackR and primeScores[stackR[-1]] < primeScores[i]:\n                    right[stackR.pop()] = i\n                stackR.append(i)\n            numAndIndexes = [(num, i) for (i, num) in enumerate(nums)]\n            sorted_numAndIndexes = sorted(numAndIndexes, key=lambda x: (-x[0], x[1]))\n            ans = 1\n            kMod = 10 ** 9 + 7\n            for (num, i) in sorted_numAndIndexes:\n                rangeCount = (i - left[i]) * (right[i] - i)\n                actualCount = min(rangeCount, k)\n                k -= actualCount\n                ans *= self.modPow(num, actualCount, kMod)\n                ans %= kMod\n            return ans\n    solution = Solution()\n    assert solution.maximumScore([2, 7, 11, 5], 1) == 9", "40": "def test_maximumScore():\n\n    def test_case(nums, k, expected):\n        solution = Solution()\n        result = solution.maximumScore(nums, k)", "56": "def test_maximumScore(self):\n    class Solution:\n        def maximumScore(self, nums: List[int], k: int) -> int:\n            # implementation here...\n\n    solution = Solution()\n    self.assertEqual(solution.maximumScore([1, 2, 3, 4, 5], 10), 12)", "57": "def test_maximumScore(self):\n    class Solution:\n        def maximumScore(self, nums, k):\n            # function implementation...\n\n    solution = Solution()\n    self.assertEqual(solution.maximumScore([1000], 2), 4)"}}
{"task_num": 2836, "task_title": "Maximize Value of Function in a Ball Passing Game", "func_name": "getMaxFunctionValue", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:\n    n = len(receiver)\n    m = int(math.log2(k)) + 1\n    ans = 0\n    jump = [[0] * m for _ in range(n)]\n    summ = [[0] * m for _ in range(n)]\n\n    for i in range(n):\n      jump[i][0] = receiver[i]\n      summ[i][0] = receiver[i]\n\n    for j in range(1, m):\n      for i in range(n):\n        midNode = jump[i][j - 1]\n        jump[i][j] = jump[midNode][j - 1]\n        summ[i][j] = summ[i][j - 1] + summ[midNode][j - 1]\n\n    for i in range(n):\n      currSum = i\n      currPos = i\n      for j in range(m):\n        if (k >> j) & 1 == 1:\n          currSum += summ[currPos][j]\n          currPos = jump[currPos][j]\n      ans = max(ans, currSum)\n\n    return ans\n", "tests": {"34": "def test_getMaxFunctionValue(self):\n    solution = Solution()\n    receiver = [1, 2, 3]\n    k = 4\n    self.assertEqual(solution.getMaxFunctionValue(receiver, k), 10)", "35": "def test_getMaxFunctionValue():\n\n    class Solution:\n\n        def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:\n            n = len(receiver)\n            m = 3\n            ans = 0\n            jump = [[0] * m for _ in range(n)]\n            summ = [[0] * m for _ in range(n)]\n            for i in range(n):\n                jump[i][0] = receiver[i]\n                summ[i][0] = receiver[i]\n            for j in range(1, m):\n                for i in range(n):\n                    midNode = jump[i][j - 1]\n                    jump[i][j] = jump[midNode][j - 1]\n                    summ[i][j] = summ[i][j - 1] + summ[midNode][j - 1]\n            receiver = [0, 2, 3]\n            k = 3\n            for i in range(n):\n                currSum = i\n                currPos = i\n                for j in range(m):\n                    if k >> j & 1 == 1:\n                        currSum += summ[currPos][j]\n                        currPos = jump[currPos][j]\n                        assert currPos != receiver[receiver[i]]\n                ans = max(ans, currSum)\n            return ans\n    solution = Solution()\n    print(solution.getMaxFunctionValue([0, 2, 3], 3))"}}
{"task_num": 2844, "task_title": "Minimum Operations to Make a Special Number", "func_name": "minimumOperations", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumOperations(self, num: str) -> int:\n    n = len(num)\n    seenFive = False\n    seenZero = False\n\n    for i in range(n - 1, -1, -1):\n      if seenZero and num[i] == '0':\n        return n - i - 2\n      if seenZero and num[i] == '5':\n        return n - i - 2\n      if seenFive and num[i] == '2':\n        return n - i - 2\n      if seenFive and num[i] == '7':\n        return n - i - 2\n      seenZero = seenZero or num[i] == '0'\n      seenFive = seenFive or num[i] == '5'\n\n    if seenZero:\n      return n - 1\n    else:\n      return n\n", "tests": {"19": "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('250') == 1", "21": "def test_minimumOperations(self):\n\n    class Solution:\n\n        def minimumOperations(self, num: str) -> int:\n            n = len(num)\n            seenFive = False\n            seenZero = False\n            for i in range(n - 1, -1, -1):\n                if seenZero and num[i] == '0':\n                    return n - i - 2\n                elif seenFive and num[i] == '7':\n                    return n - i\n                seenZero = seenZero or num[i] == '0'\n                seenFive = seenFive or num[i] == '5'\n            if seenZero:\n                return n - 1\n            else:\n                return n\n    solution = Solution()\n    self.assertEqual(solution.minimumOperations('720'), 2)", "23": "def test_minimumOperations():\n\n    class Solution:\n\n        def minimumOperations(self, num: str) -> int:\n            n = len(num)\n            seenFive = False\n            seenZero = False\n            for i in range(n - 1, -1, -1):\n                if seenZero and num[i] == '0':\n                    return n - i - 2\n                if seenZero and num[i] == '5':\n                    return n - i - 2\n                if seenFive and num[i] == '2':\n                    assert n - i - 2 == 3, f'Expected 3 but got {n - i - 2}'\n                if seenFive and num[i] == '7':\n                    return n - i - 2\n                seenZero = seenZero or num[i] == '0'\n                seenFive = seenFive or num[i] == '5'\n            if seenZero:\n                return n - 1\n            else:\n                return n\n    solution = Solution()\n    print(solution.minimumOperations('725'))", "25": "def test_minimumOperations():\n    solution = Solution()\n    print(solution.minimumOperations('275'))", "30": "def test_minimumOperations(self):\n    solution = Solution()\n    self.assertEqual(solution.minimumOperations('250'), 2)", "32": "def test_minimumOperations():\n\n    class MockSolution:\n\n        def minimumOperations(self, num: str) -> int:\n            if num == '00000':\n                return 5\n            else:\n                raise Exception(\"Expected number '00000' for test case\")\n    solution = MockSolution()\n    assert solution.minimumOperations('00000') == 5"}}
{"task_num": 2846, "task_title": "Minimum Edge Weight Equilibrium Queries in a Tree", "func_name": "minOperationsQueries", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minOperationsQueries(self, n: int, edges: List[List[int]], queries: List[List[int]]) -> List[int]:\n    kMax = 26\n    m = int(math.log2(n)) + 1\n    ans = []\n    graph = [[] for _ in range(n)]\n    jump = [[0] * m for _ in range(n)]\n    count = [[] for _ in range(n)]\n    depth = [0] * n\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    def dfs(u: int, prev: int, d: int):\n      if prev != -1:\n        jump[u][0] = prev\n      depth[u] = d\n      for v, w in graph[u]:\n        if v == prev:\n          continue\n        count[v] = count[u][:]\n        count[v][w] += 1\n        dfs(v, u, d + 1)\n\n    count[0] = [0] * (kMax + 1)\n    dfs(0, -1, 0)\n\n    for j in range(1, m):\n      for i in range(n):\n        jump[i][j] = jump[jump[i][j - 1]][j - 1]\n\n    def getLCA(u: int, v: int) -> int:\n      if depth[u] > depth[v]:\n        return getLCA(v, u)\n      for j in range(m):\n        if depth[v] - depth[u] >> j & 1:\n          v = jump[v][j]\n      if u == v:\n        return u\n      for j in range(m - 1, -1, -1):\n        if jump[u][j] != jump[v][j]:\n          u = jump[u][j]\n          v = jump[v][j]\n      return jump[v][0]\n\n    for u, v in queries:\n      lca = getLCA(u, v)\n      numEdges = depth[u] + depth[v] - 2 * depth[lca]\n      maxFreq = max(count[u][j] + count[v][j] - 2 * count[lca][j] for j in range(1, kMax + 1))\n      ans.append(numEdges - maxFreq)\n\n    return ans\n", "tests": {"27": "def test_minOperationsQueries():\n\n    class Solution:\n\n        def minOperationsQueries(self, n: int, edges: List[List[int]], queries: List[List[int]]) -> List[int]:\n            kMax = 26\n            m = int(math.log2(n)) + 1\n            ans = []\n            graph = [[] for _ in range(n)]\n            jump = [[0] * m for _ in range(n)]\n            count = [[] for _ in range(n)]\n            depth = [0] * n\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n\n            def dfs(u: int, prev: int, d: int):\n                jump[u][0] = 10\n                depth[u] = d\n                for (v, w) in graph[u]:\n                    if v == prev:\n                        continue\n                    count[v] = count[u][:]\n                    count[v][w] += 1\n                    dfs(v, u, d + 1)\n            count[0] = [0] * (kMax + 1)\n            dfs(0, -1, 0)\n            for j in range(1, m):\n                for i in range(n):\n                    jump[i][j] = jump[jump[i][j - 1]][j - 1]\n\n            def getLCA(u: int, v: int) -> int:\n                if depth[u] > depth[v]:\n                    return getLCA(v, u)\n                for j in range(m):\n                    if depth[v] - depth[u] >> j & 1:\n                        v = jump[v][j]\n                if u == v:\n                    return u\n                for j in range(m - 1, -1, -1):\n                    if jump[u][j] != jump[v][j]:\n                        u = jump[u][j]\n                        v = jump[v][j]\n                return jump[v][0]\n            queries = [[10, 20], [5, 15]]\n            for (u, v) in queries:\n                lca = getLCA(u, v)\n                numEdges = depth[u] + depth[v] - 2 * depth[lca]\n                maxFreq = max((count[u][j] + count[v][j] - 2 * count[lca][j] for j in range(1, kMax + 1)))\n                ans.append(numEdges - maxFreq)\n            return ans\n    solution = Solution()\n    print(solution.minOperationsQueries(5, [[0, 1, 2], [1, 2, 3], [0, 2, 4]], [[0, 3], [1, 3]]))", "31": "def test_minOperationsQueries():\n\n    def find_solution():\n        n = 3\n        edges = [[0, 1, 2], [0, 2, 3]]\n        queries = [[0, 2]]", "45": "def test_minOperationsQueries():\n\n    class Solution:\n\n        def minOperationsQueries(self, n: int, edges: List[List[int]], queries: List[List[int]]) -> List[int]:\n            kMax = 26\n            m = int(math.log2(n)) + 1\n            ans = []\n            graph = [[] for _ in range(n)]\n            jump = [[0] * m for _ in range(n)]\n            count = [[] for _ in range(n)]\n            depth = [0] * n\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n\n            def dfs(u: int, prev: int, d: int):\n                if prev != -1:\n                    jump[u][0] = prev\n                depth[u] = d\n                for (v, w) in graph[u]:\n                    if v == prev:\n                        continue\n                    count[v] = count[u][:]\n                    count[v][w] += 1\n                    dfs(v, u, d + 1)\n            count[0] = [0] * (kMax + 1)\n            dfs(0, -1, 0)\n            for j in range(1, m):\n                for i in range(n):\n                    jump[i][j] = jump[jump[i][j - 1]][j - 1]\n\n            def getLCA(u: int, v: int) -> int:\n                if depth[u] > depth[v]:\n                    return getLCA(v, u)\n                for j in range(m):\n                    if depth[v] - depth[u] >> j & 1:\n                        v = jump[v][j]\n                if u == v:\n                    return u\n                for j in range(m - 1, -1, -1):\n                    if jump[u][j] != jump[v][j]:\n                        u = jump[u][j]\n                        v = jump[v][j]\n                return jump[v][0]\n            queries = [[3, 2], [5, 4]]\n            ans = self.minOperationsQueries(6, [[0, 1, 1], [1, 2, 1], [2, 3, 1]], queries)\n            assert ans == [1, 0]\ntest_minOperationsQueries()", "48": "def test_minOperationsQueries():\n\n    class Solution:\n\n        def minOperationsQueries(self, n: int, edges: List[List[int]], queries: List[List[int]]) -> List[int]:\n            kMax = 26\n            m = int(math.log2(n)) + 1\n            ans = []\n            graph = [[] for _ in range(n)]\n            jump = [[0] * m for _ in range(n)]\n            count = [[] for _ in range(n)]\n            depth = [0] * n\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n\n            def dfs(u: int, prev: int, d: int):\n                if prev != -1:\n                    jump[u][0] = prev\n                depth[u] = d\n                for (v, w) in graph[u]:\n                    if v == prev:\n                        continue\n                    count[v] = count[u][:]\n                    count[v][w] += 1\n                    dfs(v, u, d + 1)\n            count[0] = [0] * (kMax + 1)\n            dfs(0, -1, 0)\n            for j in range(1, m):\n                for i in range(n):\n                    jump[i][j] = jump[jump[i][j - 1]][j - 1]\n\n            def getLCA(u: int, v: int) -> int:\n                if depth[u] > depth[v]:\n                    return getLCA(v, u)\n                for j in range(m):\n                    if depth[v] - depth[u] >> j & 1:\n                        v = jump[v][j]\n                if u == v:\n                    return u\n                for j in range(m - 1, -1, -1):\n                    if jump[u][j] != jump[v][j]:\n                        u = jump[u][j]\n                        v = jump[v][j]\n                return jump[v][0]\n            queries = [[5, 8], [9, 10]]\n            for (u, v) in queries:\n                lca = getLCA(u, v)\n                numEdges = depth[u] + depth[v] - 2 * depth[lca]\n                maxFreq = max((count[u][j] + count[v][j] - 2 * count[lca][j] for j in range(1, kMax + 1)))\n                ans.append(numEdges - maxFreq)\n            return ans\n    solution = Solution()\n    print(solution.minOperationsQueries(10, [[0, 1, 1], [1, 2, 1]], [[3, 4]]))", "50": "def test_minOperationsQueries():\n\n    class Solution:\n\n        def minOperationsQueries(self, n, edges, queries):\n            kMax = 26\n            m = int(math.log2(n)) + 1\n            ans = []\n            graph = [[] for _ in range(n)]\n            jump = [[0] * m for _ in range(n)]\n            count = [[] for _ in range(n)]\n            depth = [0] * n\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n\n            def dfs(u, prev, d):\n                if prev != -1:\n                    jump[u][0] = prev\n                depth[u] = d\n                for (v, w) in graph[u]:\n                    if v == prev:\n                        continue\n                    count[v] = count[u][:]\n                    count[v][w] += 1\n                    dfs(v, u, d + 1)\n            count[0] = [0] * (kMax + 1)\n            dfs(0, -1, 0)\n            for j in range(1, m):\n                for i in range(n):\n                    jump[i][j] = jump[jump[i][j - 1]][j - 1]\n\n            def getLCA(u, v):\n                if depth[u] > depth[v]:\n                    return getLCA(v, u)\n                for j in range(m):\n                    if depth[v] - depth[u] >> j & 1:\n                        v = jump[v][j]\n                if u == v:\n                    return u\n                for j in range(m - 1, -1, -1):\n                    if jump[u][j] != jump[v][j]:\n                        u = jump[u][j]\n                        v = jump[v][j]\n                return jump[v][0]\n            assert getLCA(1, 2) == 0", "53": "def test_minOperationsQueries():\n\n    class Solution:\n\n        def minOperationsQueries(self, n: int, edges: List[List[int]], queries: List[List[int]]) -> List[int]:\n            kMax = 26\n            m = int(math.log2(n)) + 1\n            ans = []\n            graph = [[] for _ in range(n)]\n            jump = [[0] * m for _ in range(n)]\n            count = [[] for _ in range(n)]\n            depth = [0] * n\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n\n            def dfs(u: int, prev: int, d: int):\n                if prev != -1:\n                    jump[u][0] = prev\n                depth[u] = d\n                for (v, w) in graph[u]:\n                    if v == prev:\n                        continue\n                    count[v] = count[u][:]\n                    count[v][w] += 1\n                    dfs(v, u, d + 1)\n            count[0] = [0] * (kMax + 1)\n            dfs(0, -1, 0)\n            for j in range(1, m):\n                for i in range(n):\n                    jump[i][j] = jump[jump[i][j - 1]][j - 1]\n\n            def getLCA(u: int, v: int) -> int:\n                if depth[u] > depth[v]:\n                    return getLCA(v, u)\n                for j in range(m):\n                    if depth[v] - depth[u] >> j & 1:\n                        v = jump[v][j]\n                if u == v:\n                    return u\n                for j in range(m - 1, -1, -1):\n                    if jump[u][j] != jump[v][j]:\n                        u = jump[u][j]\n                        v = jump[v][j]\n                return jump[v][0]\n\n            def test_case():\n                n = 5\n                edges = [[0, 1, 3], [1, 2, 2], [2, 3, 4]]\n                queries = [[0, 2], [2, 3]]\n                assert self.minOperationsQueries(n, edges, queries) == [6, 8]\n            test_case()\nsolution = Solution()\ntest_minOperationsQueries()", "54": "def test_minOperationsQueries():\n\n    class Solution:\n\n        def minOperationsQueries(self, n: int, edges: List[List[int]], queries: List[List[int]]) -> List[int]:\n            kMax = 26\n            m = int(math.log2(n)) + 1\n            ans = []\n            graph = [[] for _ in range(n)]\n            jump = [[0] * m for _ in range(n)]\n            count = [[] for _ in range(n)]\n            depth = [0] * n\n\n            def dfs(u: int, prev: int, d: int):\n                if prev != -1:\n                    jump[u][0] = prev\n                depth[u] = d\n                for (v, w) in graph[u]:\n                    if v == prev:\n                        continue\n                    count[v] = count[u][:]\n                    count[v][w] += 1\n                    dfs(v, u, d + 1)\n            edges.append([3, 4, 2])\n            dfs(0, -1, 0)\n            for j in range(1, m):\n                for i in range(n):\n                    jump[i][j] = jump[jump[i][j - 1]][j - 1]\n\n            def getLCA(u: int, v: int) -> int:\n                if depth[u] > depth[v]:\n                    return getLCA(v, u)\n                for j in range(m):\n                    if depth[v] - depth[u] >> j & 1:\n                        v = jump[v][j]\n                if u == v:\n                    return u\n                for j in range(m - 1, -1, -1):\n                    if jump[u][j] != jump[v][j]:\n                        if jump[u][j] == 3 and jump[v][j] == 4:\n                            u = jump[u][j]\n                            v = jump[v][j]\n                        else:\n                            u = jump[u][j]\n                            v = jump[v][j]\n                return jump[v][0]\n            queries.append([3, 4])\n            lca = getLCA(3, 4)\n            numEdges = depth[3] + depth[4] - 2 * depth[lca]\n            maxFreq = max((count[3][j] + count[4][j] - 2 * count[lca][j] for j in range(1, kMax + 1)))\n            ans.append(numEdges - maxFreq)\n            return ans\n    solution = Solution()\n    print(solution.minOperationsQueries(5, [[0, 1, 2], [1, 2, 3]], [[0, 4]]))"}}
{"task_num": 2850, "task_title": "Minimum Moves to Spread Stones Over Grid", "func_name": "minimumMoves", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumMoves(self, grid: List[List[int]]) -> int:\n    if sum(row.count(0) for row in grid) == 0:\n      return 0\n\n    ans = math.inf\n\n    for i in range(3):\n      for j in range(3):\n        if grid[i][j] == 0:\n          for x in range(3):\n            for y in range(3):\n              if grid[x][y] > 1:\n                grid[x][y] -= 1\n                grid[i][j] += 1\n                ans = min(ans, abs(x - i) + abs(y - j) + self.minimumMoves(grid))\n                grid[x][y] += 1\n                grid[i][j] -= 1\n\n    return ans\n", "tests": {"14": "def test_minimumMoves():\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    assert solution.minimumMoves(grid) == 4, f'Expected 4, got {solution.minimumMoves(grid)}'", "21": "def test_minimumMoves():\n    grid = [[1, 0, 2], [0, 0, 0], [2, 0, 1]]\n    assert 5 == solution.minimumMoves(grid)", "22": "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 2, 1], [1, 0, 1], [2, 1, 0]]\n    assert solution.minimumMoves(grid) == 3", "23": "def test_minimumMoves():\n\n    class Solution:\n\n        def minimumMoves(self, grid):\n            ans = math.inf\n            for i in range(3):\n                for j in range(3):\n                    if grid[i][j] == 0:\n                        for x in range(3):\n                            for y in range(3):\n                                if grid[x][y] > 1:\n                                    grid[x][y] -= 1\n                                    grid[i][j] += 1\n                                    ans = min(ans, abs(x - i) + abs(y - j) + self.minimumMoves(grid))\n                                    grid[x][y] += 1\n                                    grid[i][j] -= 1\n            return ans\n    solution = Solution()\n    print(solution.minimumMoves([[0, 2, 3], [4, 5, 6], [7, 8, 9]]))", "24": "def test_minimumMoves():\n\n    class Solution:\n\n        def minimumMoves(self, grid):\n            return self._minimumMoves(grid)\n\n        def _minimumMoves(self, grid):\n            if sum((row.count(0) for row in grid)) == 0:\n                return 0\n            ans = float('inf')\n            for i in range(3):\n                for j in range(3):\n                    if grid[i][j] > 1 and grid[i][j] != 2:\n                        return 1\n            for i in range(3):\n                for j in range(3):\n                    if grid[i][j] == 0:\n                        for x in range(3):\n                            for y in range(3):\n                                if grid[x][y] > 1 and grid[x][y] != 2:\n                                    temp = grid[i][j]\n                                    grid[x][y] -= 1\n                                    grid[i][j] += 1\n                                    ans = min(ans, self._minimumMoves(grid))\n                                    grid[x][y] += 1\n                                    grid[i][j] = temp\n            return ans\n    solution = Solution()\n    print(solution.minimumMoves([[0, 2, 0], [1, 0, 2], [0, 2, 0]]))", "25": "def test_minimumMoves():\n\n    class SolutionMock:\n\n        def minimumMoves(self, grid):\n            if sum((row.count(0) for row in grid)) == 0:\n                return 0\n            ans = math.inf\n            for i in range(3):\n                for j in range(3):\n                    if grid[i][j] == 0:\n                        for x in range(3):\n                            for y in range(3):\n                                if grid[x][y] > 1:\n                                    grid[x][y] -= 1\n                                    grid[i][j] += 1\n                                    ans = min(ans, abs(x - i) + abs(y - j))\n                                    grid[x][y] += 1\n                                    grid[i][j] -= 1\n            return ans\n    solution = SolutionMock()\n    grid = [[0, 2, 0], [3, 4, 5], [6, 7, 8]]\n    assert solution.minimumMoves(grid) == 5", "26": "def test_minimumMoves():\n\n    class SolutionMock:\n\n        def minimumMoves(self, grid):\n            return 0 if sum((row.count(0) for row in grid)) == 0 else float('inf')\n    solution = SolutionMock()\n    grid = [[2, 1, 3], [4, 5, 6], [7, 8, 9]]\n    assert solution.minimumMoves(grid) == 17", "27": "def test_minimumMoves(self):\n    grid = [[1, 0, 2], [3, 0, 4], [5, 6, 7]]\n    self.assertEqual(solution.minimumMoves(grid), 11)", "28": "def test_minimumMoves():\n    solution = Solution()\n\n    def is_valid(grid):\n        return sum((row.count(0) for row in grid)) == 1 and all(((row[i] > 0 and row[i - 1] == 0 or i == 0) and (col[j] > 0 and col[j - 1] == 0 or j == 0) for (i, row) in enumerate(grid) for (j, col) in enumerate(zip(*grid))))\n    grid = [[9, 8, 7], [6, 5, 4], [3, 2, 1]]\n    assert solution.minimumMoves(grid) == 3"}}
{"task_num": 2851, "task_title": "String Transformation", "func_name": "numberOfWays", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numberOfWays(self, s: str, t: str, k: int) -> int:\n    kMod = 1_000_000_007\n    n = len(s)\n    negOnePowK = 1 if k % 2 == 0 else -1  # (-1)^k\n    z = self._zFunction(s + t + t)\n\n    indices = [i - n for i in range(n, n + n) if z[i] >= n]\n    dp = [0] * 2\n    dp[1] = (pow(n - 1, k, kMod) - negOnePowK) * pow(n, kMod - 2, kMod)\n    dp[0] = dp[1] + negOnePowK\n    res = 0\n    for index in indices:\n      if index == 0:\n        res += dp[0]\n      else: \n        res += dp[1]\n    return res % kMod\n\n\n  def _zFunction(self, s: str) -> List[int]:\n    n = len(s)\n    z = [0] * n\n    l = 0\n    r = 0\n    for i in range(1, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l])\n      while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n    return z\n", "tests": {"25": "def test_numberOfWays():\n\n    class Solution:\n\n        def numberOfWays(self, s: str, t: str, k: int) -> int:\n            kMod = 1000000007\n            n = len(s)\n            negOnePowK = 1 if k % 2 == 0 else -1\n            z = self._zFunction(s + t + t)\n            indices = [i - n for i in range(n, n + n) if z[i] >= n]\n            dp = [0] * 2\n            dp[1] = (pow(n - 1, k, kMod) - negOnePowK) * pow(n, kMod - 2, kMod)\n            dp[0] = dp[1] + negOnePowK\n            res = 0\n            for index in indices:\n                if index == 0:\n                    res += dp[0]\n                else:\n                    res += dp[1]\n            return res % kMod\n\n        def _zFunction(self, s: str) -> List[int]:\n            n = len(s)\n            z = [0] * n\n            l = 0\n            r = 0\n            for i in range(1, n):\n                if i < r:\n                    z[i] = min(r - i, z[i - l])\n                while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n                    z[i] += 1\n                if i + z[i] > r:\n                    l = i\n                    r = i + z[i]\n            return z\n    solution = Solution()\n    print(solution.numberOfWays('abcd', 'cbad', 1))", "27": "def test_numberOfWays(self):\n    solution = Solution()\n    self.assertEqual(solution.numberOfWays('abc', 'cab', 2), 1)", "38": "def test_numberOfWays(self):\n\n    class Solution:\n\n        def _zFunction(self, s: str) -> List[int]:\n            n = len(s)\n            z = [0] * n\n            l = 0\n            r = 0\n            for i in range(1, n):\n                if i < r:\n                    z[i] = min(r - i, z[i - l])\n                while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n                    z[i] += 1\n                if i + z[i] > r:\n                    l = i\n                    r = i + z[i]\n            return z\n\n        def numberOfWays(self, s: str, t: str, k: int) -> int:\n            kMod = 1000000007\n            n = len(s)\n            negOnePowK = 1 if k % 2 == 0 else -1\n            z = self._zFunction(s + t + t)\n            indices = [i - n for i in range(n, n + n) if z[i] >= n]\n            dp = [0] * 2\n            dp[1] = (pow(n - 1, k, kMod) - negOnePowK) * pow(n, kMod - 2, kMod)\n            dp[0] = dp[1] + negOnePowK\n            res = 0\n            for index in indices:\n                if index == 0:\n                    res += dp[0]\n                else:\n                    res += dp[1]\n            return res % kMod\n    solution = Solution()\n    s = 'aabbcc'\n    t = 'bbccaab'\n    k = 3\n    self.assertEqual(solution.numberOfWays(s, t, k), 2)", "42": "def test_numberOfWays():\n\n    class Solution:\n\n        def numberOfWays(self, s: str, t: str, k: int) -> int:\n            kMod = 1000000007\n            n = len(s)\n            negOnePowK = 1 if k % 2 == 0 else -1\n            z = self._zFunction(s + t + t)\n            indices = [i - n for i in range(n, n + n) if z[i] >= n]\n            dp = [0] * 2\n            dp[1] = (pow(n - 1, k, kMod) - negOnePowK) * pow(n, kMod - 2, kMod)\n            dp[0] = dp[1] + negOnePowK\n            res = 0\n            for index in indices:\n                if index == 0:\n                    res += dp[0]\n                else:\n                    res += dp[1]\n            return res % kMod\n\n        def _zFunction(self, s: str) -> List[int]:\n            n = len(s)\n            z = [0] * n\n            l = 0\n            r = 0\n            for i in range(1, n):\n                if i < r:\n                    z[i] = min(r - i, z[i - l])\n                while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n                    z[i] += 1\n                if i + z[i] > r:\n                    l = i\n                    r = i + z[i]\n            return z\n    solution = Solution()\n    assert solution.numberOfWays('abcddcba', 'dcbabcd', 2) == 2", "43": "def test_numberOfWays():\n\n    class Solution:\n\n        def _zFunction(self, s: str) -> List[int]:\n            n = len(s)\n            z = [0] * n\n            l = 0\n            r = 0\n            for i in range(1, n):\n                if i < r:\n                    z[i] = min(r - i, z[i - l])\n                while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n                    z[i] += 1\n                if i + z[i] > r:\n                    l = i\n                    r = i + z[i]\n            return z\n\n        def numberOfWays(self, s: str, t: str, k: int) -> int:\n            kMod = 1000000007\n            n = len(s)\n            negOnePowK = 1 if k % 2 == 0 else -1\n            z = self._zFunction(s + t + t)\n            indices = [i - n for i in range(n, n + n) if z[i] >= n]\n            dp = [0] * 2\n            dp[1] = (pow(n - 1, k, kMod) - negOnePowK) * pow(n, kMod - 2, kMod)\n            dp[0] = dp[1] + negOnePowK\n            res = 0\n            for index in indices:\n                if index == 0:\n                    res += dp[0]\n                else:\n                    res += dp[1]\n            return res % kMod\n    solution = Solution()\n    s = 'abcd'\n    t = 'cdab'\n    k = 2\n    assert solution.numberOfWays(s, t, k) == 3"}}
{"task_num": 2876, "task_title": "Count Visited Nodes in a Directed Graph", "func_name": "countVisitedNodes", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countVisitedNodes(self, edges: List[int]) -> List[int]:\n    n = len(edges)\n    ans = [0] * n\n    inDegrees = [0] * n\n    seen = [False] * n\n    stack = []\n\n    for v in edges:\n      inDegrees[v] += 1\n\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n\n    while q:\n      u = q.popleft()\n      inDegrees[edges[u]] -= 1\n      if inDegrees[edges[u]] == 0:\n        q.append(edges[u])\n      stack.append(u)\n      seen[u] = True\n\n    for i in range(n):\n      if not seen[i]:\n        self._fillCycle(edges, i, seen, ans)\n\n    while stack:\n      u = stack.pop()\n      ans[u] = ans[edges[u]] + 1\n\n    return ans\n\n  def _fillCycle(self, edges: List[int], start: int, seen: List[bool], ans: List[int]) -> None:\n    cycleLength = 0\n    u = start\n    while not seen[u]:\n      cycleLength += 1\n      seen[u] = True\n      u = edges[u]\n    ans[start] = cycleLength\n    u = edges[start]\n    while u != start:\n      ans[u] = cycleLength\n      u = edges[u]\n", "tests": {"28": "def test_countVisitedNodes():\n\n    class Solution:\n\n        def countVisitedNodes(self, edges: List[int]) -> List[int]:\n            n = len(edges)\n            ans = [0] * n\n            inDegrees = [0] * n\n            seen = [False] * n\n            stack = []\n            for v in edges:\n                inDegrees[v] += 1\n            q = collections.deque([i for (i, d) in enumerate(inDegrees) if d == 0])\n            while q:\n                u = q.popleft()\n                inDegrees[edges[u]] -= 1\n                if inDegrees[edges[u]] == 0:\n                    q.append(edges[u])\n                stack.append(u)\n                seen[u] = True\n            for i in range(n):\n                if not seen[i]:\n                    self._fillCycle(edges, i, seen, ans)\n            while stack:\n                u = stack.pop()\n                ans[u] = ans[edges[u]] + 1\n            return ans\n    solution = Solution()\n    edges = [0, 1, 2, 3]\n    print(solution.countVisitedNodes(edges))", "34": "def test_countVisitedNodes():\n\n    class Solution:\n\n        def countVisitedNodes(self, edges):\n            n = len(edges)\n            ans = [0] * n\n            inDegrees = [0] * n\n            seen = [False] * n\n            stack = []\n            for v in edges:\n                inDegrees[v] += 1\n            q = collections.deque([i for (i, d) in enumerate(inDegrees) if d == 0])\n            while q:\n                u = q.popleft()\n                inDegrees[edges[u]] -= 1\n                if inDegrees[edges[u]] == 0:\n                    q.append(edges[u])\n                stack.append(u)\n                seen[u] = True\n            for i in range(n):\n                if not seen[i]:\n                    self._fillCycle(edges, i, seen, ans)\n            while stack:\n                u = stack.pop()\n                ans[u] = ans[edges[u]] + 1\n            return ans\n\n        def _fillCycle(self, edges, start, seen, ans):\n            cycleLength = 0\n            u = start\n            while not seen[u]:\n                cycleLength += 1\n                seen[u] = True\n                u = edges[u]\n            ans[start] = cycleLength\n            u = edges[start]\n            while u != start:\n                ans[u] = cycleLength\n                u = edges[u]\n    solution = Solution()\n    edges = [0, 1, 2, 3, 4, 5, 6, 7, 8]\n    solution.countVisitedNodes(edges)"}}
{"task_num": 2901, "task_title": "Longest Unequal Adjacent Groups Subsequence II", "func_name": "getWordsInLongestSubsequence", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def getWordsInLongestSubsequence(self, words: List[str], groups: List[int]) -> List[str]:\n    ans = []\n    n=len(words)\n    dp = [1] * n\n    prev = [-1] * n\n\n    for i in range(1, n):\n      for j in range(i):\n        if groups[i] == groups[j]:\n          continue\n        if len(words[i]) != len(words[j]):\n          continue\n        if sum(a != b for a, b in zip(words[i], words[j])) != 1:\n          continue\n        if dp[i] < dp[j] + 1:\n          dp[i] = dp[j] + 1\n          prev[i] = j\n\n    index = dp.index(max(dp))\n    while index != -1:\n      ans.append(words[index])\n      index = prev[index]\n\n    return ans[::-1]\n", "tests": {"21": "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = ['abc', 'cde', 'efg', 'ghi']\n    groups = [1, 2, 3, 4]\n    result = solution.getWordsInLongestSubsequence(words, groups)", "23": "    def test_getWordsInLongestSubsequence(self):\n        def getWordsInLongestSubsequence(words, groups):\n            ans = []\n            n=len(words)\n            dp = [1] * n\n            prev = [-1] * n\n            for i in range(1, n):\n                for j in range(i):\n                    if groups[i] == groups[j]:\n                        continue\n                    if len(words[i]) != len(words[j]):\n                        return [''] # Return an empty list to indicate test failure\n                    if sum(a != b for a, b in zip(words[i], words[j])) != 1:\n                        continue\n                    if dp[i] < dp[j] + 1:\n                        dp[i] = dp[j] + 1\n                        prev[i] = j\n            index = dp.index(max(dp))\n            while index != -1:\n                ans.append(words[index])\n                index = prev[index]\n            return ans[::-1]\n\n        solution=Solution()\n        words=[\"abcd\",\"cdef\",\"abcw\", \"cdew\",\"zwcde\"]\n        groups=[1,1,1,0,0]\n        self.assertEqual(getWordsInLongestSubsequence(words, groups), ['abcd','cdef'])\n", "25": "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = ['ab', 'ba', 'aa']\n    groups = [1, 2, 1]\n    assert solution.getWordsInLongestSubsequence(words, groups) == ['ab', 'ba']", "27": "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = ['abc', 'bcd', 'cd']\n    groups = [0, 2, 1]\n    assert solution.getWordsInLongestSubsequence(words, groups) == ['bcd']", "28": "def test_getWordsInLongestSubsequence(self):\n    words = ['abc', 'bcd', 'cde', 'a']\n    groups = [1, 2, 3, 1]\n    self.assertEqual(solution.getWordsInLongestSubsequence(words, groups), ['cde', 'a'])"}}
{"task_num": 2904, "task_title": "Shortest and Lexicographically Smallest Beautiful String", "func_name": "shortestBeautifulSubstring", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def shortestBeautifulSubstring(self, s: str, k: int) -> str:\n    bestLeft = -1\n    minLength = len(s) + 1\n    ones = 0\n\n    l = 0\n    for r, c in enumerate(s):\n      if c == '1':\n        ones += 1\n      while ones == k:\n        if r - l + 1 < minLength:\n          bestLeft = l\n          minLength = r - l + 1\n        elif r - l + 1 == minLength and s[l:l + minLength] < s[bestLeft:bestLeft + minLength]:\n          bestLeft = l\n        if s[l] == '1':\n          ones -= 1\n        l += 1\n\n    if bestLeft == -1:\n      return \"\"\n    else:\n      return s[bestLeft:bestLeft + minLength]\n", "tests": {"20": "def test_shortestBeautifulSubstring():\n\n    class MockSolution:\n\n        def __init__(self):\n            self.s = '10101'\n            self.k = 2\n\n        def shortestBeautifulSubstring(self, s: str, k: int) -> str:\n            return self.shortestBeautifulSubstringHelper(s, k)\n\n        def shortestBeautifulSubstringHelper(self, s, k):\n            bestLeft = -1\n            minLength = len(s) + 1\n            ones = 0\n            l = 0\n            for (r, c) in enumerate(s):\n                if c == '1':\n                    ones += 1\n                while ones == k:\n                    if r - l + 1 < minLength:\n                        bestLeft = l\n                        minLength = r - l + 1\n                    elif r - l + 1 == minLength and s[l:l + minLength] < s[bestLeft:bestLeft + minLength]:\n                        bestLeft = l\n                    if s[l] == '1':\n                        ones -= 1\n                    l += 1\n            if bestLeft == -1:\n                return ''\n            else:\n                return s[bestLeft:bestLeft + minLength]\n    solution = MockSolution()\n    result = solution.shortestBeautifulSubstring(solution.s, solution.k)", "23": "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('1100110001', 2) == '10'", "24": "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    s = '11001101'\n    k = 2\n    assert solution.shortestBeautifulSubstring(s, k) == '11', f\"Expected '11', got {solution.shortestBeautifulSubstring(s, k)}\"", "26": "def test_shortestBeautifulSubstring(self):\n    solution = Solution()\n    self.assertEqual(solution.shortestBeautifulSubstring('11001111101', 2), '11')", "28": "def test_shortestBeautifulSubstring():\n\n    def assert_equals(expected, actual):\n        if expected != actual:\n            raise AssertionError(f'Expected {expected}, but got {actual}')\n    solution = Solution()\n    s = '100101'\n    k = 2\n    assert_equals('', solution.shortestBeautifulSubstring(s, k))", "32": "def test_shortestBeautifulSubstring():\n\n    class Solution:\n\n        def shortestBeautifulSubstring(self, s: str, k: int) -> str:\n            if k > len(s):\n                return ''\n    solution = Solution()\n    print(solution.shortestBeautifulSubstring('110000', 3))", "34": "def test_shortestBeautifulSubstring():\n    solution = Solution()\n\n    def test_input(s, k):\n        result = solution.shortestBeautifulSubstring(s, k)"}}
{"task_num": 2911, "task_title": "Minimum Changes to Make K Semi-palindromes", "func_name": "minimumChanges", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumChanges(self, s: str, k: int) -> int:\n    n = len(s)\n    factors = self._getFactors(n)\n    cost = self._getCost(s, n, factors)\n    dp = [[n] * (k + 1) for _ in range(n + 1)]\n\n    dp[n][0] = 0\n\n    for i in range(n - 1, -1, -1):\n      for j in range(1, k + 1):\n        for l in range(i + 1, n):\n          dp[i][j] = min(dp[i][j], dp[l + 1][j - 1] + cost[i][l])\n\n    return dp[0][k]\n\n  def _getFactors(self, n: int) -> List[List[int]]:\n    factors = [[1] for _ in range(n + 1)]\n    for d in range(2, n):\n      for i in range(d * 2, n + 1, d):\n        factors[i].append(d)\n    return factors\n\n  def _getCost(self, s: str, n: int, factors: List[List[int]]) -> List[List[int]]:\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n      for j in range(i + 1, n):\n        length = j - i + 1\n        minCost = length\n        for d in factors[length]:\n          minCost = min(minCost, self._getCostD(s, i, j, d))\n        cost[i][j] = minCost\n    return cost\n\n  def _getCostD(self, s: str, i: int, j: int, d: int) -> int:\n    cost = 0\n    for offset in range(d):\n      l = i + offset\n      r = j - d + 1 + offset\n      while l < r:\n        if s[l] != s[r]:\n          cost += 1\n        l += d\n        r -= d\n    return cost\n", "tests": {"52": "def test_minimumChanges():\n\n    class Solution:\n\n        def minimumChanges(self, s: str, k: int) -> int:\n            n = len(s)\n            factors = self._getFactors(n)\n            cost = self._getCost(s, n, factors)\n            dp = [[n] * (k + 1) for _ in range(n + 1)]\n            dp[n][0] = 0\n            for i in range(n - 1, -1, -1):\n                for j in range(1, k + 1):\n                    for l in range(i + 1, n):\n                        dp[i][j] = min(dp[i][j], dp[l + 1][j - 1] + cost[i][l])\n            return dp[0][k]\n\n        def _getFactors(self, n: int) -> List[List[int]]:\n            factors = [[1] for _ in range(n + 1)]\n            for d in range(2, n):\n                for i in range(d * 2, n + 1, d):\n                    factors[i].append(d)\n            return factors\n\n        def _getCost(self, s: str, n: int, factors: List[List[int]]) -> List[List[int]]:\n            cost = [[0] * n for _ in range(n)]\n            for i in range(n):\n                for j in range(i + 1, n):\n                    length = j - i + 1\n                    minCost = length\n                    for d in factors[length]:\n                        minCost = min(minCost, self._getCostD(s, i, j, d))\n                    cost[i][j] = minCost\n            return cost\n\n        def _getCostD(self, s: str, i: int, j: int, d: int) -> int:\n            cost = 0\n            for offset in range(d):\n                l = i + offset\n                r = j - d + 1 + offset\n                while l < r:\n                    if s[l] != s[r]:\n                        cost += 1\n                    l += d\n                    r -= d\n            return cost\n    solution = Solution()\n    assert solution.minimumChanges('abccba', 2) == 0"}}
{"task_num": 2932, "task_title": "Maximum Strong Pair XOR I", "func_name": "maximumStrongPairXor", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Optional\n\nclass TrieNode:\n  def __init__(self):\n    self.children: List[Optional[TrieNode]] = [None] * 2\n    self.min = math.inf\n    self.max = -math.inf\n\n\nclass BitTrie:\n  def __init__(self, maxBit: int):\n    self.maxBit = maxBit\n    self.root = TrieNode()\n\n  def insert(self, num: int) -> None:\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n      node.min = min(node.min, num)\n      node.max = max(node.max, num)\n\n  def getMaxXor(self, x: int) -> int:\n    maxXor = 0\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = x >> i & 1\n      toggleBit = bit ^ 1\n      if node.children[toggleBit] and node.children[toggleBit].max > x and node.children[toggleBit].min <= 2 * x:\n        maxXor = maxXor | 1 << i\n        node = node.children[toggleBit]\n      elif node.children[bit]:\n        node = node.children[bit]\n      else:\n        return 0\n    return maxXor\n\n\nclass Solution:\n  def maximumStrongPairXor(self, nums: List[int]) -> int:\n    maxNum = max(nums)\n    maxBit = int(math.log2(maxNum))\n    bitTrie = BitTrie(maxBit)\n\n    for num in nums:\n      bitTrie.insert(num)\n\n    return max(bitTrie.getMaxXor(num) for num in nums)\n", "tests": {"28": "def test_maximumStrongPairXor():\n\n    def assert_maximumStrongPairXor(nums, expected):\n        solution = Solution()\n        result = solution.maximumStrongPairXor(nums)", "40": "def test_maximumStrongPairXor():\n\n    class Solution:\n\n        def maximumStrongPairXor(self, nums):\n            maxNum = max(nums)\n            maxBit = int(math.log2(maxNum))\n            bitTrie = BitTrie(maxBit)\n            for num in nums:\n                bitTrie.insert(num)\n            return max((bitTrie.getMaxXor(num) for num in nums))\n    solution = Solution()\n    result = solution.maximumStrongPairXor([1, 2, 3, 4, 5])", "41": "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [5, 3, 6]\n    assert solution.maximumStrongPairXor(nums) == 7", "43": "def test_maximumStrongPairXor():\n\n    class Solution:\n\n        def maximumStrongPairXor(self, nums):\n            maxNum = 8\n            maxBit = int(math.log2(maxNum))\n            bitTrie = BitTrie(maxBit)\n            for num in nums:\n                bitTrie.insert(num)\n            return max((bitTrie.getMaxXor(num) for num in nums))\n    solution = Solution()\n    print(solution.maximumStrongPairXor([1, 2, 3]))", "45": "def test_maximumStrongPairXor():\n    solution = Solution()\n\n    def maximumStrongPairXor(nums):\n        maxNum = max(nums)\n        maxBit = int(math.log2(maxNum))\n        bitTrie = BitTrie(maxBit)\n        for num in nums:\n            bitTrie.insert(num)\n        return max((bitTrie.getMaxXor(num) for num in nums))\n    assert maximumStrongPairXor([1, 2]) == 0"}}
{"task_num": 2940, "task_title": "Find Building Where Alice and Bob Can Meet", "func_name": "leftmostBuildingQueries", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, a: int, b: int):\n    self.queryIndex = queryIndex\n    self.a = a\n    self.b = b\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.a\n    yield self.b\n\n\nclass Solution:\n  def leftmostBuildingQueries(self, heights: List[int], queries: List[List[int]]) -> List[int]:\n    ans = [-1] * len(queries)\n    stack = []\n\n    heightsIndex = len(heights) - 1\n    for queryIndex, a, b in sorted([IndexedQuery(i, min(a, b), max(a, b)) for i, (a, b) in enumerate(queries)], key=lambda iq: -iq.b):\n      if a == b or heights[a] < heights[b]:\n        ans[queryIndex] = b\n      else:\n        while heightsIndex > b:\n          while stack and heights[stack[-1]] <= heights[heightsIndex]:\n            stack.pop()\n          stack.append(heightsIndex)\n          heightsIndex -= 1\n        j = self._lastGreater(stack, a, heights)\n        if j != -1:\n          ans[queryIndex] = stack[j]\n\n    return ans\n\n  def _lastGreater(self, A: List[int], target: int, heights: List[int]):\n    l = -1\n    r = len(A) - 1\n    while l < r:\n      m = (l + r + 1) // 2\n      if heights[A[m]] > heights[target]:\n        l = m\n      else:\n        r = m - 1\n    return l\n", "tests": {"31": "def test_leftmostBuildingQueries():\n\n    def leftmostBuildingQueries(heights, queries):\n        ans = [-1] * len(queries)\n        stack = []\n        heightsIndex = len(heights) - 1\n        for (queryIndex, a, b) in sorted([IndexedQuery(i, min(a, b), max(a, b)) for (i, (a, b)) in enumerate(queries)], key=lambda iq: -iq.b):\n            if a == b or heights[a] < heights[b]:\n                ans[queryIndex] = b\n            else:\n                while heightsIndex > b:\n                    while stack and heights[stack[-1]] <= heights[heightsIndex]:\n                        stack.pop()\n                    stack.append(heightsIndex)\n                    heightsIndex -= 1\n                j = _lastGreater(stack, a, heights)\n                if j != -1:\n                    ans[queryIndex] = stack[j]\n        return ans\n    solution = Solution()\n    heights = [3, 5, 4, 6, 2]\n    queries = [[0, 1], [0, 1]]\n    assert leftmostBuildingQueries(heights, queries) == [-1]", "33": "def test_leftmostBuildingQueries():\n\n    class Solution:\n\n        def leftmostBuildingQueries(self, heights, queries):\n            ans = [-1] * len(queries)\n            stack = []\n            heightsIndex = len(heights) - 1\n            for (queryIndex, a, b) in sorted([IndexedQuery(i, min(a, b), max(a, b)) for (i, (a, b)) in enumerate(queries)], key=lambda iq: -iq.b):\n                if a == b or heights[a] < heights[b]:\n                    ans[queryIndex] = b\n                else:\n                    while heightsIndex > b:\n                        while stack and heights[stack[-1]] <= heights[heightsIndex]:\n                            stack.pop()\n                        stack.append(heightsIndex)\n                        heightsIndex -= 1\n                    j = self._lastGreater(stack, a, heights)\n                    if j != -1:\n                        ans[queryIndex] = stack[j]\n            return ans\n\n        def _lastGreater(self, A, target, heights):\n            l = -1\n            r = len(A) - 1\n            while l < r:\n                m = (l + r + 1) // 2\n                if heights[A[m]] > heights[target]:\n                    l = m\n                else:\n                    r = m - 1\n            return l\n    solution = Solution()\n    heights = [3, 4, 5]\n    queries = [[0, 1], [1, 2]]\n    print(solution.leftmostBuildingQueries(heights, queries))", "34": "def test_leftmostBuildingQueries():\n\n    def leftmostBuildingQueries(heights, queries):\n        ans = [-1] * len(queries)\n        stack = []\n        heightsIndex = len(heights) - 1\n        for (queryIndex, a, b) in sorted([IndexedQuery(i, min(a, b), max(a, b)) for (i, (a, b)) in enumerate(queries)], key=lambda iq: -iq.b):\n            if a == b or heights[a] < heights[b]:\n                ans[queryIndex] = b\n            else:\n                while stack and heights[stack[-1]] <= heights[heightsIndex]:\n                    stack.pop()\n                stack.append(heightsIndex)\n                heightsIndex -= 1\n        return ans\n    solution = Solution()\n    heights = [3, 4, 5]\n    queries = [[0, 2], [1, 2]]\n    print(solution.leftmostBuildingQueries(heights, queries))", "35": "def test_leftmostBuildingQueries():\n\n    class SolutionMock(Solution):\n\n        def _lastGreater(self, A, target, heights):\n            return 0\n    solution = SolutionMock()\n    heights = [1, 2, 3]\n    queries = [[0, 2], [1, 2]]\n    result = solution.leftmostBuildingQueries(heights, queries)", "36": "def test_leftmostBuildingQueries():\n    heights = [3, 4, 7]\n    queries = [[1, 2], [2, 2]]\n    ans = [-1, 2]\n    assert solution.leftmostBuildingQueries(heights, queries) == ans", "37": "def test_leftmostBuildingQueries():\n\n    def leftmostBuildingQueries(heights, queries):\n        ans = [-1] * len(queries)\n        stack = []\n        heightsIndex = len(heights) - 1\n        for (queryIndex, a, b) in sorted([IndexedQuery(i, min(a, b), max(a, b)) for (i, (a, b)) in enumerate(queries)], key=lambda iq: -iq.b):\n            if a == b or heights[a] < heights[b]:\n                ans[queryIndex] = b\n            else:\n                while heightsIndex > b:\n                    while stack and heights[stack[-1]] <= heights[heightsIndex]:\n                        stack.pop()\n                    stack.append(heightsIndex)\n                    heightsIndex -= 1\n                j = self._lastGreater(stack, a, heights)\n                if j != -1:\n                    ans[queryIndex] = stack[j]\n        return ans\n    solution = Solution()\n    print(leftmostBuildingQueries([5, 3, 8, 2], [[0, 2], [1, 2]]))", "38": "def test_leftmostBuildingQueries():\n\n    def leftmostBuildingQueries(heights, queries):\n        ans = [-1] * len(queries)\n        stack = []\n        heightsIndex = len(heights) - 1\n        for (queryIndex, a, b) in sorted([IndexedQuery(i, min(a, b), max(a, b)) for (i, (a, b)) in enumerate(queries)], key=lambda iq: -iq.b):\n            if a == b or heights[a] < heights[b]:\n                ans[queryIndex] = b\n            else:\n                while heightsIndex > b:\n                    while stack and heights[stack[-1]] <= heights[heightsIndex]:\n                        stack.pop()\n                    stack.append(heightsIndex)\n                    heightsIndex -= 1\n                j = _lastGreater(stack, a, heights)\n                if j != -1:\n                    ans[queryIndex] = stack[j]\n        return ans\n    solution = Solution()\n    heights = [10, 2, 3, 4, 5]\n    queries = [[0, 2], [1, 2]]\n    print(leftmostBuildingQueries(heights, queries))\n\nclass IndexedQuery:\n\n    def __init__(self, queryIndex: int, a: int, b: int):\n        self.queryIndex = queryIndex\n        self.a = a\n        self.b = b\n\n    def __iter__(self):\n        yield self.queryIndex\n        yield self.a\n        yield self.b\n\nclass Solution:\n\n    def _lastGreater(self, A: List[int], target: int, heights: List[int]):\n        l = -1\n        r = len(A) - 1\n        while l < r:\n            m = (l + r + 1) // 2\n            if heights[A[m]] > heights[target]:\n                l = m\n            else:\n                r = m - 1\n        return l\nfrom typing import List, Dict, Tuple, Iterator", "39": "def test_leftmostBuildingQueries():\n\n    class Solution:\n\n        def leftmostBuildingQueries(self, heights: List[int], queries: List[List[int]]) -> List[int]:\n            ans = [-1] * len(queries)\n            stack = []\n            heightsIndex = len(heights) - 1\n            for (queryIndex, a, b) in sorted([IndexedQuery(i, min(a, b), max(a, b)) for (i, (a, b)) in enumerate(queries)], key=lambda iq: -iq.b):\n                if a == b or heights[a] < heights[b]:\n                    ans[queryIndex] = b\n                else:\n                    while heightsIndex > b:\n                        while stack and heights[stack[-1]] <= heights[heightsIndex]:\n                            stack.pop()\n                        stack.append(heightsIndex)\n                        heightsIndex -= 1\n                    j = self._lastGreater(stack, a, heights)\n                    if j != -1:\n                        ans[queryIndex] = stack[j]\n            return ans\n\n        def _lastGreater(self, A: List[int], target: int, heights: List[int]):\n            l = -1\n            r = len(A) - 1\n            while l < r:\n                m = (l + r + 1) // 2\n                if heights[A[m]] > heights[target]:\n                    l = m\n                else:\n                    r = m - 1\n            return l\n    solution = Solution()\n    heights = [1, 3, 5, 4]\n    queries = [[1, 5], [0, 4]]\n    result = solution.leftmostBuildingQueries(heights, queries)", "40": "def test_leftmostBuildingQueries():\n\n    def helper(heights, queries):\n        heights = [10, 5, 8, 7, 3]\n        queries = [[0, 4], [1, 3]]", "50": "def test_leftmostBuildingQueries():\n\n    def leftmostBuildingQueries(heights, queries):\n        ans = [-1] * len(queries)\n        stack = []\n        heightsIndex = len(heights) - 1\n        for (queryIndex, a, b) in sorted([IndexedQuery(i, min(a, b), max(a, b)) for (i, (a, b)) in enumerate(queries)], key=lambda iq: -iq.b):\n            if a == b or heights[a] < heights[b]:\n                ans[queryIndex] = b\n            else:\n                while heightsIndex > b:\n                    while stack and heights[stack[-1]] <= heights[heightsIndex]:\n                        stack.pop()\n                    stack.append(heightsIndex)\n                    heightsIndex -= 1\n                j = _lastGreater(stack, a, heights)\n                if j != -1:\n                    ans[queryIndex] = stack[j]\n        return ans\n\n    class IndexedQuery:\n\n        def __init__(self, queryIndex: int, a: int, b: int):\n            self.queryIndex = queryIndex\n            self.a = a\n            self.b = b\n\n        def __iter__(self):\n            yield self.queryIndex\n            yield self.a\n            yield self.b\n\n    class Solution:\n\n        def _lastGreater(self, A: List[int], target: int, heights: List[int]):\n            l = -1\n            r = len(A) - 1\n            while l < r:\n                m = (l + r + 1) // 2\n                if heights[A[m]] > heights[target]:\n                    l = m\n                else:\n                    r = m - 1\n            return l\n    heights = [1, 3, 5, 7]\n    queries = [[0, 1], [0, 2]]\n    solution = Solution()\n    result = leftmostBuildingQueries(heights, queries)\n    assert result == [-1, 1], f'Expected [-1, 1] but got {result}'", "52": "def test_leftmostBuildingQueries():\n\n    def leftmostBuildingQueries(heights, queries):\n        ans = [-1] * len(queries)\n        stack = []\n        heightsIndex = len(heights) - 1\n        for (queryIndex, a, b) in sorted([IndexedQuery(i, min(a, b), max(a, b)) for (i, (a, b)) in enumerate(queries)], key=lambda iq: -iq.b):\n            if a == b or heights[a] < heights[b]:\n                ans[queryIndex] = b\n            else:\n                while heightsIndex > b:\n                    while stack and heights[stack[-1]] <= heights[heightsIndex]:\n                        stack.pop()\n                    stack.append(heightsIndex)\n                    heightsIndex -= 1\n                j = self._lastGreater(stack, a, heights)\n                if j != -1:\n                    ans[queryIndex] = stack[j]\n        return ans\n\n    class IndexedQuery:\n\n        def __init__(self, queryIndex: int, a: int, b: int):\n            self.queryIndex = queryIndex\n            self.a = a\n            self.b = b\n\n        def __iter__(self):\n            yield self.queryIndex\n            yield self.a\n            yield self.b\n    solution = Solution()\n    heights = [1, 3, 2]\n    queries = [[0, 1], [1, 2]]\n    assert leftmostBuildingQueries(heights, queries) == [-1, -1]"}}
{"task_num": 2948, "task_title": "Make Lexicographically Smallest Array by Swapping Elements", "func_name": "lexicographicallySmallestArray", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def lexicographicallySmallestArray(self, nums: List[int], limit: int) -> List[int]:\n    ans = [0] * len(nums)\n    numAndIndexes = sorted([(num, i) for i, num in enumerate(nums)])\n    numAndIndexesGroups: List[List[Tuple[int, int]]] = []\n\n    for numAndIndex in numAndIndexes:\n      if not numAndIndexesGroups or numAndIndex[0] - numAndIndexesGroups[-1][-1][0] > limit:\n        numAndIndexesGroups.append([numAndIndex])\n      else:\n        numAndIndexesGroups[-1].append(numAndIndex)\n\n    for numAndIndexesGroup in numAndIndexesGroups:\n      sortedNums = [num for num, _ in numAndIndexesGroup]\n      sortedIndices = sorted([index for _, index in numAndIndexesGroup])\n      for num, index in zip(sortedNums, sortedIndices):\n        ans[index] = num\n\n    return ans\n", "tests": {"19": "def test_lexicographicallySmallestArray(self):\n    nums = [5, 3, 4]\n    limit = 1\n    expected = [3, 5, 4]\n    self.assertEqual(self.solution.lexicographicallySmallestArray(nums, limit), expected)", "21": "def test_lexicographicallySmallestArray():\n\n    class Solution:\n\n        def lexicographicallySmallestArray(self, nums: List[int], limit: int) -> List[int]:\n            ans = [0] * len(nums)\n            numAndIndexes = sorted([(num, i) for (i, num) in enumerate([1, 2, 3])])\n            numAndIndexesGroups: List[List[Tuple[int, int]]] = []\n            for numAndIndex in numAndIndexes:\n                if not numAndIndexesGroups or numAndIndex[0] - numAndIndexesGroups[-1][-1][0] > limit:\n                    numAndIndexesGroups.append([numAndIndex])\n                else:\n                    numAndIndexesGroups[-1].append(numAndIndex)\n            for numAndIndexesGroup in numAndIndexesGroups:\n                sortedNums = [num for (num, _) in numAndIndexesGroup]\n                sortedIndices = sorted([index for (_, index) in numAndIndexesGroup])\n                for (num, index) in zip(sortedNums, sortedIndices):\n                    ans[index] = num\n            return ans\n    solution = Solution()\n    print(solution.lexicographicallySmallestArray([1, 2, 3], 0))"}}
{"task_num": 2953, "task_title": "Count Complete Substrings", "func_name": "countCompleteSubstrings", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countCompleteSubstrings(self, word: str, k: int) -> int:\n    uniqueLetters = len(set(word))\n    return sum(self._countCompleteStrings(word, k, windowSize) for windowSize in range(k, k * uniqueLetters + 1, k))\n\n  def _countCompleteStrings(self, word: str, k: int, windowSize: int) -> int:\n    res = 0\n    countLetters = 0\n    count = collections.Counter()\n\n    for i, c in enumerate(word):\n      count[c] += 1\n      countLetters += 1\n      if i > 0 and abs(ord(c) - ord(word[i - 1])) > 2:\n        count = collections.Counter()\n        count[c] += 1\n        countLetters = 1\n      if countLetters == windowSize + 1:\n        count[word[i - windowSize]] -= 1\n        countLetters -= 1\n      if countLetters == windowSize:\n        res += all(freq == 0 or freq == k for freq in count.values())\n\n    return res\n", "tests": {"25": "def test_countCompleteSubstrings():\n\n    class Solution:\n\n        def _countCompleteStrings(self, word: str, k: int, windowSize: int) -> int:\n            res = 0\n            countLetters = 0\n            count = collections.Counter()\n            for (i, c) in enumerate(word):\n                count[c] += 1\n                countLetters += 1\n                if i > 0 and abs(ord(c) - ord(word[i - 1])) > 2:\n                    count = collections.Counter()\n                    count[c] += 1\n                if countLetters == windowSize + 1:\n                    count[word[i - windowSize]] -= 1\n                    countLetters -= 1\n                if countLetters == windowSize:\n                    res += all((freq == 0 or freq == k for freq in count.values()))\n            return res\n\n        def test_countCompleteSubstrings(self, word: str, k: int) -> int:\n            uniqueLetters = len(set(word))\n            return sum((self._countCompleteStrings(word, k, windowSize) for windowSize in range(k, k * uniqueLetters + 1, k)))\n    solution = Solution()\n    print(solution.test_countCompleteSubstrings('abcde', 2))", "26": "def test_countCompleteSubstrings():\n\n    class Solution:\n\n        def countCompleteSubstrings(self, word: str, k: int) -> int:\n            uniqueLetters = len(set(word))\n            return sum((self._countCompleteStrings(word, k, windowSize) for windowSize in range(k, k * uniqueLetters + 1, k)))\n\n        def _countCompleteStrings(self, word: str, k: int, windowSize: int) -> int:\n            res = 0\n            countLetters = 0\n            count = collections.Counter()\n            for (i, c) in enumerate(word):\n                count[c] += 1\n                countLetters += 1\n                if i > 0 and abs(ord(c) - ord(word[i - 1])) > 2:\n                    count = collections.Counter()\n                if countLetters == windowSize + 1:\n                    count[word[i - windowSize]] -= 1\n                    countLetters -= 1\n                if countLetters == windowSize:\n                    res += all((freq == 0 or freq == k for freq in count.values()))\n            return res\n    solution = Solution()\n    assert solution.countCompleteSubstrings('abccba', 3) == 2, 'Test failed'", "27": "def test_countCompleteSubstrings():\n\n    class Solution:\n\n        def countCompleteSubstrings(self, word: str, k: int) -> int:\n            uniqueLetters = len(set(word))\n            return sum((self._countCompleteStrings(word, k, windowSize) for windowSize in range(k, k * uniqueLetters + 1, k)))\n\n        def _countCompleteStrings(self, word: str, k: int, windowSize: int) -> int:\n            res = 0\n            countLetters = 0\n            count = collections.Counter()\n            for (i, c) in enumerate(word):\n                count[c] += 1\n                countLetters += 1\n                if i > 0 and abs(ord(c) - ord(word[i - 1])) > 2:\n                    count = collections.Counter()\n                    count[c] += 1\n                    countLetters = 1\n                if countLetters == windowSize + 1:\n                    count[word[i - windowSize]] -= 1\n                    countLetters -= 1\n                if countLetters == windowSize:\n                    res += all((freq == 0 or freq == k for freq in count.values()))\n            return res\n    solution = Solution()\n    assert solution.countCompleteSubstrings('abcdddadcd', 2) == 2", "29": "def test_countCompleteSubstrings():\n\n    def _test_countCompleteSubstrings(word, k):\n        return Solution().countCompleteSubstrings(word, k)\n    assert _test_countCompleteSubstrings('abc', 1) == 0", "30": "def test_countCompleteSubstrings():\n\n    class Solution:\n\n        def countCompleteSubstrings(self, word: str, k: int) -> int:\n            uniqueLetters = len(set(word))\n            return sum((self._countCompleteStrings(word, k, windowSize) for windowSize in range(k, k * uniqueLetters + 1, k)))\n\n        def _countCompleteStrings(self, word: str, k: int, windowSize: int) -> int:\n            res = 0\n            countLetters = 0\n            count = collections.Counter()\n            for (i, c) in enumerate(word):\n                count[c] += 1\n                countLetters += 1\n                if i > 0 and abs(ord(c) - ord(word[i - 1])) > 2:\n                    count = collections.Counter()\n                    count[c] += 1\n                    countLetters = 1\n                if countLetters == windowSize + 1:\n                    count[word[i - windowSize]] -= 1\n                    countLetters -= 1\n                if countLetters == windowSize:\n                    res += all((freq == 0 or freq == k for freq in count.values()))\n            return res\n    solution = Solution()\n    assert solution.countCompleteSubstrings('abcdefghijklmnopqrstuvwxyz', 1) == 26, f\"Expected 26, got {solution.countCompleteSubstrings('abcdefghijklmnopqrstuvwxyz', 1)}\"", "32": "def test_countCompleteSubstrings():\n\n    def countCompleteSubstrings(self, word: str, k: int) -> int:\n        uniqueLetters = len(set(word))\n        return sum((self._countCompleteStrings(word, k, windowSize) for windowSize in range(k, k * uniqueLetters + 1, k)))\nsolution = Solution()\nprint(solution.countCompleteSubstrings('abcde', 2))"}}
{"task_num": 2959, "task_title": "Number of Possible Sets of Closing Branches", "func_name": "numberOfSets", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:\n    return sum(self._floydWarshall(n, maxDistance, roads, mask) <= maxDistance for mask in range(1 << n))\n\n  def _floydWarshall(self, n: int, maxDistanceThreshold: int, roads: List[List[int]], mask: int) -> List[List[int]]:\n    maxDistance = 0\n    dist = [[maxDistanceThreshold + 1] * n for _ in range(n)]\n\n    for i in range(n):\n      if mask >> i & 1:\n        dist[i][i] = 0\n\n    for u, v, w in roads:\n      if mask >> u & 1 and mask >> v & 1:\n        dist[u][v] = min(dist[u][v], w)\n        dist[v][u] = min(dist[v][u], w)\n\n    for k in range(n):\n      if mask >> k & 1:\n        for i in range(n):\n          if mask >> i & 1:\n            for j in range(n):\n              if mask >> j & 1:\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    for i in range(n):\n      if mask >> i & 1:\n        for j in range(i + 1, n):\n          if mask >> j & 1:\n            maxDistance = max(maxDistance, dist[i][j])\n\n    return maxDistance\n", "tests": {"21": "def test_numberOfSets(self):\n\n    class Solution:\n\n        def _floydWarshall(self, n: int, maxDistanceThreshold: int, roads: List[List[int]], mask: int) -> List[List[int]]:\n            return [[0 for _ in range(n)] for _ in range(n)]\n\n        def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:\n            return sum((self._floydWarshall(n, maxDistance, roads, mask) <= maxDistance for mask in range(1 << n)))\n    solution = Solution()\n    self.assertEqual(solution.numberOfSets(2, 10, [[0, 1, 5]]), 3)", "25": "def test_numberOfSets():\n    solution = Solution()\n\n    def f(n, maxDistance, roads):", "26": "def test_numberOfSets():\n\n    class Solution:\n\n        def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:\n            return sum((self._floydWarshall(n, maxDistance, roads, mask) <= maxDistance for mask in range(1 << n)))\n\n        def _floydWarshall(self, n: int, maxDistanceThreshold: int, roads: List[List[int]], mask: int) -> List[List[int]]:\n            maxDistance = 0\n            dist = [[maxDistanceThreshold + 1] * n for _ in range(n)]\n            for i in range(n):\n                if mask >> i & 1:\n                    dist[i][i] = 0\n            for (u, v, w) in roads:\n                if mask >> u & 1 and mask >> v & 1:\n                    dist[u][v] = min(dist[u][v], w)\n                    dist[v][u] = min(dist[v][u], w)\n            for k in range(n):\n                if mask >> k & 1:\n                    for i in range(n):\n                        if mask >> i & 1:\n                            for j in range(n):\n                                if mask >> j & 1:\n                                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n            for i in range(n):\n                if mask >> i & 1:\n                    for j in range(i + 1, n):\n                        if mask >> j & 1:\n                            maxDistance = max(maxDistance, dist[i][j])\n            return maxDistance\n    solution = Solution()\n    roads = [[0, 1, 5], [1, 2, 3]]\n    print(solution.numberOfSets(3, 6, roads))", "30": "def test_numberOfSets():\n\n    class Solution:\n\n        def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:\n            return sum((self._floydWarshall(n, maxDistance, roads, mask) <= maxDistance for mask in range(1 << n)))\n    solution = Solution()\n\n    def test_input():\n        n = 2\n        maxDistance = 10\n        roads = [[0, 1, 5], [1, 2, 3]]", "31": "def test_numberOfSets():\n    solution = Solution()\n\n    def helper(n, maxDistance, roads):", "32": "def test_numberOfSets():\n\n    class Solution:\n\n        def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:\n            return sum((self._floydWarshall(n, maxDistance, roads, mask) <= maxDistance for mask in range(1 << n)))\n\n        def _floydWarshall(self, n: int, maxDistanceThreshold: int, roads: List[List[int]], mask: int) -> List[List[int]]:\n            maxDistance = 0\n            dist = [[maxDistanceThreshold + 1] * n for _ in range(n)]\n            for i in range(n):\n                if mask >> i & 1:\n                    dist[i][i] = 0\n            for (u, v, w) in roads:\n                if mask >> u & 1 and mask >> v & 1:\n                    dist[u][v] = min(dist[u][v], w)\n                    dist[v][u] = min(dist[v][u], w)\n            for k in range(n):\n                if mask >> k & 1:\n                    for i in range(n):\n                        if mask >> i & 1:\n                            for j in range(n):\n                                if mask >> j & 1:\n                                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n            for i in range(n):\n                if mask >> i & 1:\n                    for j in range(i + 1, n):\n                        if mask >> j & 1:\n                            maxDistance = max(maxDistance, dist[i][j])\n            return maxDistance\n    solution = Solution()\n    roads = [[0, 1, 2], [0, 2, 3], [1, 2, 5]]\n    assert solution.numberOfSets(3, 4, roads) == 1", "33": "def test_numberOfSets():\n    solution = Solution()\n\n    def is_valid_solution(n, maxDistance, roads):", "34": "def test_numberOfSets():\n\n    class Solution:\n\n        def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:\n            return sum((self._floydWarshall(n, maxDistance, roads, mask) <= maxDistance for mask in range(1 << n)))\n\n        def _floydWarshall(self, n: int, maxDistanceThreshold: int, roads: List[List[int]], mask: int) -> List[List[int]]:\n            maxDistance = 0\n            dist = [[maxDistanceThreshold + 1] * n for _ in range(n)]\n            for i in range(n):\n                if mask >> i & 1:\n                    dist[i][i] = 0\n            for (u, v, w) in roads:\n                if mask >> u & 1 and mask >> v & 1:\n                    dist[u][v] = min(dist[u][v], w)\n                    dist[v][u] = min(dist[v][u], w)\n            for k in range(n):\n                if mask >> k & 1:\n                    for i in range(n):\n                        if mask >> i & 1:\n                            for j in range(n):\n                                if mask >> j & 1:\n                                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n            return maxDistance\n    solution = Solution()\n    n = 3\n    maxDistance = 2\n    roads = [[0, 1, 2], [0, 2, 3]]\n    assert solution.numberOfSets(n, maxDistance, roads) == 4", "38": "def test_numberOfSets():\n    solution = Solution()\n    roads = [[0, 1, 2], [0, 2, 3]]\n    print(solution.numberOfSets(3, 4, roads))", "39": "def test_numberOfSets(self):\n    class Solution:\n        def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:\n            return sum(self._floydWarshall(n, maxDistance, roads, mask) <= maxDistance for mask in range(1 << n))\n\n        def _floydWarshall(self, n: int, maxDistanceThreshold: int, roads: List[List[int]], mask: int) -> List[List[int]]:\n            # implementation of the function\n\n    solution = Solution()\n    self.assertEqual(solution.numberOfSets(4, 5, [[0,1,2],[1,2,3],[0,3,1]]), 15)", "40": "def test_numberOfSets():\n\n    class Solution:\n\n        def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:\n            return sum((self._floydWarshall(n, maxDistance, roads, mask) <= maxDistance for mask in range(1 << n)))\n\n        def _floydWarshall(self, n: int, maxDistanceThreshold: int, roads: List[List[int]], mask: int) -> List[List[int]]:\n            maxDistance = 0\n            dist = [[maxDistanceThreshold + 1] * n for _ in range(n)]\n            for i in range(n):\n                if mask >> i & 1:\n                    dist[i][i] = 0\n            for (u, v, w) in roads:\n                if mask >> u & 1 and mask >> v & 1:\n                    dist[u][v] = min(dist[u][v], w)\n                    dist[v][u] = min(dist[v][u], w)\n            for k in range(n):\n                if mask >> k & 1:\n                    for i in range(n):\n                        if mask >> i & 1:\n                            for j in range(n):\n                                if mask >> j & 1:\n                                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n            for i in range(n):\n                if mask >> i & 1:\n                    for j in range(i + 1, n):\n                        if mask >> j & 1:\n                            maxDistance = max(maxDistance, dist[i][j])\n                            return maxDistance\n    solution = Solution()\n    roads = [[0, 1, 5], [1, 2, 3]]\n    print(solution.numberOfSets(3, 6, roads))"}}
{"task_num": 2973, "task_title": "Find Number of Coins to Place in Tree Nodes", "func_name": "placedCoins", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass ChildCost:\n  def __init__(self, cost: int):\n    self.numNodes = 1\n    self.maxPosCosts = [cost] if cost > 0 else []\n    self.minNegCosts = [cost] if cost < 0 else []\n\n  def update(self, childCost: 'ChildCost') -> None:\n    self.numNodes += childCost.numNodes\n    self.maxPosCosts.extend(childCost.maxPosCosts)\n    self.minNegCosts.extend(childCost.minNegCosts)\n    self.maxPosCosts.sort(reverse=True)\n    self.minNegCosts.sort()\n    self.maxPosCosts = self.maxPosCosts[:3]\n    self.minNegCosts = self.minNegCosts[:2]\n\n  def maxProduct(self) -> int:\n    if self.numNodes < 3:\n      return 1\n    if not self.maxPosCosts:\n      return 0\n    res = 0\n    if len(self.maxPosCosts) == 3:\n      res = self.maxPosCosts[0] * self.maxPosCosts[1] * self.maxPosCosts[2]\n    if len(self.minNegCosts) == 2:\n      res = max(res, self.minNegCosts[0] * self.minNegCosts[1] * self.maxPosCosts[0])\n    return res\n\n\nclass Solution:\n  def placedCoins(self, edges: List[List[int]], cost: List[int]) -> List[int]:\n    n = len(cost)\n    ans = [0] * n\n    tree = [[] for _ in range(n)]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, prev: int) -> None:\n      res = ChildCost(cost[u])\n      for v in tree[u]:\n        if v != prev:\n          res.update(dfs(v, u))\n      ans[u] = res.maxProduct()\n      return res\n\n    dfs(0, -1)\n    return ans\n", "tests": {"28": "def test_placedCoins():\n\n    class Solution:\n\n        def placedCoins(self, edges: List[List[int]], cost: List[int]) -> List[int]:\n            n = len(cost)\n            ans = [0] * n\n            tree = [[] for _ in range(n)]\n            for (u, v) in edges:\n                tree[u].append(v)\n                tree[v].append(u)\n\n            def dfs(u: int, prev: int) -> None:\n                res = ChildCost(cost[u])\n                for v in tree[u]:\n                    if v != prev:\n                        res.update(dfs(v, u))\n                ans[u] = res.maxProduct()\n                return res\n            dfs(0, -1)\n            return ans\n    solution = Solution()\n    edges = [[0, 1], [2]]\n    cost = [10, -5, 10]\n    expected_output = [23]\n    assert solution.placedCoins(edges, cost) == expected_output", "30": "def test_placedCoins(self):\n    edges = [[1, 0], [2, 0]]\n    cost = [5, -4, 6]\n    result = [6, 8, 7]\n    self.assertEqual(solution.placedCoins(edges, cost), result)", "33": "def test_placedCoins():\n    solution = Solution()\n    edges = [[0, 1], [1, 2]]\n    cost = [1, 2, 3]\n    result = solution.placedCoins(edges, cost)", "35": "def test_placedCoins():\n\n    class Solution:\n\n        def placedCoins(self, edges: List[List[int]], cost: List[int]) -> List[int]:\n            n = len(cost)\n            ans = [0] * n\n            tree = [[] for _ in range(n)]\n            for (u, v) in edges:\n                tree[u].append(v)\n                tree[v].append(u)\n\n            def dfs(u: int, prev: int) -> None:\n                res = ChildCost(cost[u])\n                for v in tree[u]:\n                    if v != prev:\n                        res.update(dfs(v, u))\n                ans[u] = res.maxProduct()\n                return res\n            dfs(0, -1)\n            return ans\n    solution = Solution()\n    edges = [[0, 2], [0, 3], [1, 3]]\n    cost = [5, 2, 6, 8]\n    assert solution.placedCoins(edges, cost) == [13, 10, 13, 10]", "53": "def test_placedCoins():\n\n    def mock_tree():\n        return [[], [1], [2], [], []]\n    solution = Solution()\n    edges = [(0, 1), (0, 2)]\n    cost = [5, -3, 4]\n    ans = solution.placedCoins(edges, cost)"}}
{"task_num": 2976, "task_title": "Minimum Cost to Convert String I", "func_name": "minimumCost", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n    ans = 0\n    dist = [[math.inf] * 26 for _ in range(26)]\n\n    for a, b, c in zip(original, changed, cost):\n      u = ord(a) - ord('a')\n      v = ord(b) - ord('a')\n      dist[u][v] = min(dist[u][v], c)\n\n    for k in range(26):\n      for i in range(26):\n        if dist[i][k] < math.inf:\n          for j in range(26):\n            if dist[k][j] < math.inf:\n              dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    for s, t in zip(source, target):\n      if s == t:\n        continue\n      u = ord(s) - ord('a')\n      v = ord(t) - ord('a')\n      if dist[u][v] == math.inf:\n        return -1\n      ans += dist[u][v]\n\n    return ans\n", "tests": {"24": "def test_minimumCost(self):\n    solution = Solution()\n    source = 'abc'\n    target = 'cde'\n    original = ['a', 'b', 'c']\n    changed = ['d', 'e', 'f']\n    cost = [10, 20, 30]\n    self.assertEqual(solution.minimumCost(source, target, original, changed, cost), 60)", "25": "def test_minimumCost(self):\n    solution = Solution()\n    source = 'abc'\n    target = 'bcd'\n    original = ['a', 'b', 'c']\n    changed = ['a', 'd', 'e']\n    cost = [1, 2, math.inf]\n    self.assertEqual(solution.minimumCost(source, target, original, changed, cost), 3)", "26": "def test_minimumCost():\n    solution = Solution()\n\n    def check_result(result):\n        if result != 4:\n            raise AssertionError(f'Expected result to be 4, but got {result}')\n    source = 'ab'\n    target = 'cd'\n    original = ['a', 'b']\n    changed = ['c', 'd']\n    cost = [1, 2]\n    check_result(solution.minimumCost(source, target, original, changed, cost))", "30": "def test_minimumCost():\n\n    def compare_strings(s, t):\n        solution = Solution()", "34": "def test_minimumCost(self):\n    source = 'a'\n    target = 'a'\n    original = ['a']\n    changed = ['b']\n    cost = [1]\n    self.assertEqual(solution.minimumCost(source, target, original, changed, cost), 0)"}}
{"task_num": 2977, "task_title": "Minimum Cost to Convert String II", "func_name": "minimumCost", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n    subLengths = set(len(s) for s in original)\n    subToId = self._getSubToId(original, changed)\n    subCount = len(subToId)\n    dist = [[math.inf for _ in range(subCount)] for _ in range(subCount)]\n    dp = [math.inf for _ in range(len(source) + 1)]\n\n    for a, b, c in zip(original, changed, cost):\n      u = subToId[a]\n      v = subToId[b]\n      dist[u][v] = min(dist[u][v], c)\n\n    for k in range(subCount):\n      for i in range(subCount):\n        if dist[i][k] < math.inf:\n          for j in range(subCount):\n            if dist[k][j] < math.inf:\n              dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    dp[0] = 0\n\n    for i, (s, t) in enumerate(zip(source, target)):\n      if dp[i] == math.inf:\n        continue\n      if s == t:\n        dp[i + 1] = min(dp[i + 1], dp[i])\n      for subLength in subLengths:\n        if i + subLength > len(source):\n          continue\n        subSource = source[i:i + subLength]\n        subTarget = target[i:i + subLength]\n        if subSource not in subToId or subTarget not in subToId:\n          continue\n        u = subToId[subSource]\n        v = subToId[subTarget]\n        if dist[u][v] != math.inf:\n          dp[i + subLength] = min(dp[i + subLength], dp[i] + dist[u][v])\n\n    if dp[len(source)] == math.inf:\n      return -1\n    else:\n      return dp[len(source)]\n\n  def _getSubToId(self, original: str, changed: str) -> Dict[str, int]:\n    subToId = {}\n    for s in original + changed:\n      if s not in subToId:\n        subToId[s] = len(subToId)\n    return subToId\n", "tests": {"27": "def test_minimumCost():\n\n    class Solution:\n\n        def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n            subLengths = set((len(s) for s in original))\n            subToId = self._getSubToId(original, changed)\n            subCount = len(subToId)\n            dist = [[math.inf for _ in range(subCount)] for _ in range(subCount)]\n            dp = [math.inf for _ in range(len(source) + 1)]\n            for (a, b, c) in zip(original, changed, cost):\n                u = subToId[a]\n                v = subToId[b]\n                dist[u][v] = min(dist[u][v], c)\n            for k in range(subCount):\n                for i in range(subCount):\n                    if dist[i][k] < math.inf:\n                        for j in range(subCount):\n                            if dist[k][j] < math.inf and i != k:\n                                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n            dp[0] = 0\n            for (i, (s, t)) in enumerate(zip(source, target)):\n                if dp[i] == math.inf:\n                    continue\n                if s == t:\n                    dp[i + 1] = min(dp[i + 1], dp[i])\n                for subLength in subLengths:\n                    if i + subLength > len(source):\n                        continue\n                    subSource = source[i:i + subLength]\n                    subTarget = target[i:i + subLength]\n                    if subSource not in subToId or subTarget not in subToId:\n                        continue\n                    u = subToId[subSource]\n                    v = subToId[subTarget]\n                    if dist[u][v] != math.inf:\n                        dp[i + subLength] = min(dp[i + subLength], dp[i] + dist[u][v])\n            if dp[len(source)] == math.inf:\n                return -1\n            else:\n                return dp[len(source)]\n    solution = Solution()\n    source = 'abcd'\n    target = 'caba'\n    original = ['a', 'b', 'cd']\n    changed = ['c', 'a', 'ba']\n    cost = [2, 1, 3]\n    assert solution.minimumCost(source, target, original, changed, cost) == -1", "28": "def test_minimumCost():\n\n    class Solution:\n\n        def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n            subLengths = set((len(s) for s in original))\n            subToId = self._getSubToId(original, changed)\n            dist = [[math.inf for _ in range(1)] for _ in range(1)]\n            dp = [math.inf for _ in range(len(source) + 1)]\n            dist[0][0] = cost[0]\n            dp[0] = 0\n            for (i, (s, t)) in enumerate(zip(source, target)):\n                if dp[i] == math.inf:\n                    continue\n                if s == t:\n                    dp[i + 1] = min(dp[i + 1], dp[i])\n                dist[0][0] = min(dist[0][0], cost[0])\n            return dp[len(source)]\n    solution = Solution()\n    print(solution.minimumCost('abcd', 'dcba', ['abc', 'dca'], ['bcd', 'cab'], [3, 4]))", "29": "def test_minimumCost():\n\n    class Solution:\n\n        def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n            subLengths = set((len(s) for s in original))\n            subToId = self._getSubToId(original, changed)\n            dist = [[math.inf for _ in range(3)] for _ in range(3)]\n            dp = [math.inf for _ in range(len(source) + 1)]\n            for (a, b, c) in zip(original, changed, cost):\n                u = subToId[a]\n                v = subToId[b]\n                dist[u][v] = min(dist[u][v], c)\n            for k in range(3):\n                for i in range(3):\n                    if dist[i][k] < math.inf:\n                        for j in range(3):\n                            if dist[k][j] < math.inf:\n                                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n            dp[0] = 0\n            source = 'abc'\n            target = 'abf'\n            original = ['abc', 'bcd']\n            changed = ['abf', 'def']\n            cost = [2, 4]\n            for (i, (s, t)) in enumerate(zip(source, target)):\n                if dp[i] == math.inf:\n                    continue\n                if s == t:\n                    dp[i + 1] = min(dp[i + 1], dp[i])\n                subLength = 3\n                if i + subLength > len(source):\n                    continue\n                subSource = source[i:i + subLength]\n                subTarget = target[i:i + subLength]\n                if subSource not in subToId or subTarget not in subToId:\n                    continue\n                u = subToId[subSource]\n                v = subToId[subTarget]\n                dp[i + subLength] = min(dp[i + subLength], dp[i] + dist[u][v])\n            return dp[-1]\n    solution = Solution()\n    print(solution.minimumCost('abc', 'abf', ['abc', 'bcd'], ['abf', 'def'], [2, 4]))", "35": "def test_minimumCost():\n\n    class Solution:\n\n        def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n            subLengths = set((len(s) for s in original))\n            subToId = self._getSubToId(original, changed)\n            dist = [[math.inf for _ in range(len(subToId))] for _ in range(len(subToId))]\n            dp = [math.inf for _ in range(len(source) + 1)]\n            for (a, b, c) in zip(original, changed, cost):\n                u = subToId[a]\n                v = subToId[b]\n                dist[u][v] = min(dist[u][v], c)\n            for k in range(len(subToId)):\n                for i in range(len(subToId)):\n                    if dist[i][k] < math.inf:\n                        for j in range(len(subToId)):\n                            if dist[k][j] < math.inf:\n                                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n            dp[0] = 0\n            for (i, (s, t)) in enumerate(zip(source, target)):\n                if s == t:\n                    dp[i + 1] = min(dp[i + 1], dp[i])\n                else:\n                    return -1\n    solution = Solution()\n    original = ['abc', 'bcd']\n    changed = ['abcd', 'cdab']\n    cost = [10, 20]\n    source = 'abcd'\n    target = 'cdab'\n    print(solution.minimumCost(source, target, original, changed, cost))", "37": "def test_minimumCost(self):\n    solution = Solution()\n    source = 'leetcode'\n    target = 'practice'\n    original = ['let', 'leet', 'code']\n    changed = ['lt', 'lee', 'code']\n    cost = [100, 300, 0]\n    self.assertEqual(solution.minimumCost(source, target, original, changed, cost), 3400)", "40": "def test_minimumCost():\n\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        subLengths = set((len(s) for s in original))\n        subToId = self._getSubToId(original, changed)\n        subCount = len(subToId)\n        dist = [[math.inf for _ in range(subCount)] for _ in range(subCount)]\n        dp = [math.inf for _ in range(len(source) + 1)]\n        for (a, b, c) in zip(original, changed, cost):\n            u = subToId[a]\n            v = subToId[b]\n            dist[u][v] = min(dist[u][v], c)\n        for k in range(subCount):\n            for i in range(subCount):\n                if dist[i][k] < math.inf:\n                    for j in range(subCount):\n                        if dist[k][j] < math.inf:\n                            dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n        dp[0] = 0\n        for (i, (s, t)) in enumerate(zip(source, target)):\n            if dp[i] == math.inf:\n                continue\n            if s == t:\n                dp[i + 1] = min(dp[i + 1], dp[i])\n            for subLength in subLengths:\n                if i + subLength > len(source):\n                    return -1\n                subSource = source[i:i + subLength]\n                subTarget = target[i:i + subLength]\n                if subSource not in subToId or subTarget not in subToId:\n                    continue\n                u = subToId[subSource]\n                v = subToId[subTarget]\n                if dist[u][v] != math.inf:\n                    dp[i + subLength] = min(dp[i + subLength], dp[i] + dist[u][v])\n        if dp[len(source)] == math.inf:\n            return -1\n        else:\n            return dp[len(source)]\nsolution = Solution()\nprint(minimumCost(solution, 'abc', 'def', ['ab', 'de'], [0, 1]))", "44": "def test_minimumCost():\n\n    def helper(source, target, original, changed, cost):\n        subLengths = set((len(s) for s in original))\n        subToId = self._getSubToId(original, changed)\n        dist = [[math.inf for _ in range(len(subToId))] for _ in range(len(subToId))]\n        dp = [math.inf for _ in range(len(source) + 1)]\n        for (a, b, c) in zip(original, changed, cost):\n            u = subToId[a]\n            v = subToId[b]\n            dist[u][v] = min(dist[u][v], c)\n        for k in range(len(subToId)):\n            for i in range(len(subToId)):\n                if dist[i][k] < math.inf:\n                    for j in range(len(subToId)):\n                        if dist[k][j] < math.inf:\n                            dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n        dp[0] = 0\n        for (i, (s, t)) in enumerate(zip(source, target)):\n            if dp[i] == math.inf:\n                continue\n            if s == t:\n                dp[i + 1] = min(dp[i + 1], dp[i])\n            for subLength in subLengths:\n                if i + subLength > len(source):\n                    continue\n                subSource = source[i:i + subLength]\n                subTarget = target[i:i + subLength]\n                if subSource not in subToId or subTarget not in subToId:\n                    return -1\n                u = subToId[subSource]\n                v = subToId[subTarget]\n                if dist[u][v] != math.inf:\n                    dp[i + subLength] = min(dp[i + subLength], dp[i] + dist[u][v])\n        return dp[len(source)]\n    solution = Solution()\n    print(helper('abcd', 'abce', ['abc', 'abd', 'abe'], ['cde', 'cfe', 'dbe'], [1, 2, 3]))", "48": "def test_minimumCost():\n    solution = Solution()\n    source = 'abc'\n    target = 'efg'\n    original = ['ab', 'cd']\n    changed = ['xy', 'yz']\n    cost = [1, 2]\n    print(solution.minimumCost(source, target, original, changed, cost))", "51": "def test_minimumCost():\n\n    class Solution:\n\n        def _getSubToId(self, original, changed):\n            subToId = {}\n            for s in original + changed:\n                if s not in subToId:\n                    subToId[s] = len(subToId)\n            return subToId\n\n        def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n            subLengths = set((len(s) for s in original))\n            subToId = self._getSubToId(original, changed)\n            dist = [[float('inf') for _ in range(len(subToId))] for _ in range(len(subToId))]\n            dp = [float('inf') for _ in range(len(source) + 1)]\n            for (a, b, c) in zip(original, changed, cost):\n                u = subToId[a]\n                v = subToId[b]\n                dist[u][v] = min(dist[u][v], c)\n            for k in range(len(subToId)):\n                for i in range(len(subToId)):\n                    if dist[i][k] < float('inf'):\n                        for j in range(len(subToId)):\n                            if dist[k][j] < float('inf'):\n                                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n            dp[0] = 0\n            for (i, (s, t)) in enumerate(zip(source, target)):\n                if dp[i] == float('inf'):\n                    continue\n                if s == t:\n                    dp[i + 1] = min(dp[i + 1], dp[i])\n                for subLength in subLengths:\n                    if i + subLength > len(source):\n                        continue\n                    subSource = source[i:i + subLength]\n                    subTarget = target[i:i + subLength]\n                    if subSource not in subToId or subTarget not in subToId:\n                        continue\n                    u = subToId[subSource]\n                    v = subToId[subTarget]\n                    if dist[u][v] != float('inf'):\n                        dp[i + subLength] = min(dp[i + subLength], dp[i] + dist[u][v])\n            if dp[len(source)] == float('inf'):\n                return -1\n            else:\n                return dp[len(source)]\n    solution = Solution()\n    source = 'abcd'\n    target = 'dcba'\n    original = ['abcd', 'cdab']\n    changed = ['dcba', 'acbd']\n    cost = [2, 3]\n    assert solution.minimumCost(source, target, original, changed, cost) == -1", "53": "def test_minimumCost():\n    solution = Solution()\n    source = 'abc'\n    target = 'cde'\n    original = ['a', 'b', 'c']\n    changed = ['d', 'e', 'f']\n    cost = [1, 2, 3]\n    assert solution.minimumCost(source, target, original, changed, cost) == -1", "59": "def test_minimumCost():\n\n    class Solution:\n\n        def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n            subLengths = set((len(s) for s in original))\n            subToId = self._getSubToId(original, changed)\n            subCount = len(subToId)\n            dist = [[math.inf for _ in range(subCount)] for _ in range(subCount)]\n            dp = [math.inf for _ in range(len(source) + 1)]\n            for (a, b, c) in zip(original, changed, cost):\n                u = subToId[a]\n                v = subToId[b]\n                dist[u][v] = min(dist[u][v], c)\n            for k in range(subCount):\n                for i in range(subCount):\n                    if dist[i][k] < math.inf:\n                        for j in range(subCount):\n                            if dist[k][j] < math.inf:\n                                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n            dp[0] = 0\n            for (i, (s, t)) in enumerate(zip(source, target)):\n                if dp[i] == math.inf:\n                    continue\n                if s == t:\n                    dp[i + 1] = min(dp[i + 1], dp[i])\n                for subLength in subLengths:\n                    if i + subLength > len(source):\n                        continue\n                    subSource = source[i:i + subLength]\n                    subTarget = target[i:i + subLength]\n                    if subSource not in subToId or subTarget not in subToId:\n                        continue\n                    u = subToId[subSource]\n                    v = subToId[subTarget]\n                    if dist[u][v] != math.inf:\n                        dp[i + subLength] = min(dp[i + subLength], dp[i] + dist[u][v])\n            if dp[len(source)] == math.inf:\n                return -1\n            else:\n                return dp[len(source)]\n    solution = Solution()\n    source = 'abcd'\n    target = 'abcd'\n    original = ['ab', 'cd']\n    changed = ['ab', 'cd']\n    cost = [1, 2]\n    assert solution.minimumCost(source, target, original, changed, cost) == 3"}}
{"task_num": 2983, "task_title": "Palindrome Rearrangement Queries", "func_name": "canMakePalindromeQueries", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n    n = len(s)\n    mirroredDiffs = self._getMirroredDiffs(s)\n    counts = self._getCounts(s)\n    ans = []\n\n    def subtractArrays(a: List[int], b: List[int]):\n      return [x - y for x, y in zip(a, b)]\n\n    for a, b, c, d in queries:\n      b += 1\n      d += 1\n      ra = n - a\n      rb = n - b\n      rc = n - c\n      rd = n - d\n\n      if (min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0) or (n // 2 > max(b, rc) and mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0):\n        ans.append(False)\n      else:\n        leftRangeCount = subtractArrays(counts[b], counts[a])\n        rightRangeCount = subtractArrays(counts[d], counts[c])\n        if a > rd:\n          rightRangeCount = subtractArrays(\n              rightRangeCount, subtractArrays(counts[min(a, rc)], counts[rd]))\n        if rc > b:\n          rightRangeCount = subtractArrays(\n              rightRangeCount, subtractArrays(counts[rc], counts[max(b, rd)]))\n        if c > rb:\n          leftRangeCount = subtractArrays(\n              leftRangeCount, subtractArrays(counts[min(c, ra)], counts[rb]))\n        if ra > d:\n          leftRangeCount = subtractArrays(\n              leftRangeCount, subtractArrays(counts[ra], counts[max(d, rb)]))\n        ans.append(min(leftRangeCount) >= 0\n                   and min(rightRangeCount) >= 0\n                   and leftRangeCount == rightRangeCount)\n\n    return ans\n\n  def _getMirroredDiffs(self, s: str) -> List[int]:\n    diffs = [0]\n    for i, j in zip(range(len(s)), reversed(range(len(s)))):\n      if i >= j:\n        break\n      diffs.append(diffs[-1] + (s[i] != s[j]))\n    return diffs\n\n  def _getCounts(self, s: str) -> List[List[int]]:\n    count = [0] * 26\n    counts = [count.copy()]\n    for c in s:\n      count[ord(c) - ord('a')] += 1\n      counts.append(count.copy())\n    return counts\n", "tests": {"30": "def test_canMakePalindromeQueries():\n\n    class Solution:\n\n        def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n            n = len(s)\n            mirroredDiffs = self._getMirroredDiffs(s)\n            counts = self._getCounts(s)\n            ans = []\n            for (a, b, c, d) in queries:\n                b += 1\n                d += 1\n                ra = n - a\n                rb = n - b\n                rc = n - c\n                rd = n - d\n                if min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0 or (n // 2 > max(b, rc) and mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0):\n                    ans.append(False)\n                else:\n                    leftRangeCount = subtractArrays(counts[b], counts[a])\n                    rightRangeCount = subtractArrays(counts[d], counts[c])\n                    if a > rd:\n                        rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[min(a, rc)], counts[rd]))\n                    if rc > b:\n                        rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[rc], counts[max(b, rd)]))\n                    if c > rb:\n                        leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[min(c, ra)], counts[rb]))\n                    if ra > d:\n                        leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[ra], counts[max(d, rb)]))\n                    ans.append(min(leftRangeCount) >= 0 and min(rightRangeCount) >= 0 and (leftRangeCount == rightRangeCount))\n            return ans\n\n        def _getMirroredDiffs(self, s: str) -> List[int]:\n            diffs = [0]\n            for (i, j) in zip(range(len(s)), reversed(range(len(s)))):\n                if i >= j:\n                    break\n                diffs.append(diffs[-1] + (s[i] != s[j]))\n            return diffs\n\n        def _getCounts(self, s: str) -> List[List[int]]:\n            count = [0] * 26\n            counts = [count.copy()]\n            for c in s:\n                count[ord(c) - ord('a')] += 1\n                counts.append(count.copy())\n            return counts\n\n    def subtractArrays(a: List[int], b: List[int]):\n        return [x - y for (x, y) in zip(a, b)]\n    solution = Solution()\n    print(solution.canMakePalindromeQueries('abcddcba', [[0, 2, 4, 5]]))", "32": "def test_canMakePalindromeQueries():\n\n    class Solution:\n\n        def _getCounts(self, s: str) -> List[List[int]]:\n            count = [0] * 26\n            counts = [count.copy()]\n            for c in 'abacaba':\n                count[ord(c) - ord('a')] += 1\n                counts.append(count.copy())\n            return counts\n\n        def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n            n = len(s)\n            mirroredDiffs = self._getMirroredDiffs(s)\n            counts = self._getCounts(s)\n            ans = []\n            for (a, b, c, d) in [[0, 3, 4, 6]]:\n                leftRangeCount = subtractArrays(counts[b], counts[a])\n                rightRangeCount = subtractArrays(counts[d], counts[c])\n                ans.append(min(leftRangeCount) >= 0 and min(rightRangeCount) >= 0 and (leftRangeCount == rightRangeCount))\n            return ans\n\n    def subtractArrays(a: List[int], b: List[int]):\n        return [x - y for (x, y) in zip(a, b)]\n    solution = Solution()\n    print(solution.canMakePalindromeQueries('abacaba', [[0, 3, 4, 6]]))", "33": "def test_canMakePalindromeQueries():\n\n    class Solution:\n\n        def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n            n = len(s)\n            mirroredDiffs = self._getMirroredDiffs(s)\n            counts = self._getCounts(s)\n\n            def subtractArrays(a: List[int], b: List[int]):\n                return [x - y for (x, y) in zip(a, b)]\n            ans = []\n            for (a, b, c, d) in queries:\n                if a == 0 and b == 1 and (c == n - 2) and (d == n - 1) or (a == 5 and b == 6 and (c == 9) and (d == 10)):\n                    ans.append(False)\n                else:\n                    leftRangeCount = subtractArrays(counts[b], counts[a])\n                    rightRangeCount = subtractArrays(counts[d], counts[c])\n                    if a > n - 1 - d:\n                        rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[min(a, n - 2 - c)], counts[n - 1 - d]))\n                    if c > n - 1 - b:\n                        rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[c], counts[max(n - 2 - b, n - 1 - n)]))\n                    if d > n - 1 - a:\n                        leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[min(d, n - 2 - a)], counts[n - 1 - b]))\n                    if n - 1 - d > b:\n                        leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[n - 1 - d], counts[max(b, a)]))\n                    ans.append(min(leftRangeCount) >= 0 and min(rightRangeCount) >= 0 and (leftRangeCount == rightRangeCount))\n            return ans\n    solution = Solution()\n    print(solution.canMakePalindromeQueries('abccba', [[5, 6, 9, 10]]))", "34": "def test_canMakePalindromeQueries():\n\n    def canMakePalindromeQueries(self, s, queries):\n        n = len(s)\n        mirroredDiffs = self._getMirroredDiffs(s)\n        counts = self._getCounts(s)\n\n        def subtractArrays(a, b):\n            return [x - y for (x, y) in zip(a, b)]\n        ans = []\n        for (a, b, c, d) in queries:\n            b += 1\n            d += 1\n            ra = n - a\n            rb = n - b\n            rc = n - c\n            rd = n - d\n            if min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0 or (n // 2 > max(b, rc) and mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0):\n                ans.append(False)\n            else:\n                leftRangeCount = subtractArrays(counts[b], counts[a])\n                rightRangeCount = subtractArrays(counts[d], counts[c])\n                if a > rd:\n                    rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[min(a, rc)], counts[rd]))\n                if rc > b:\n                    rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[rc], counts[max(b, rd)]))\n                if c > rb:\n                    leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[min(c, ra)], counts[rb]))\n                if ra > d:\n                    leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[ra], counts[max(d, rb)]))\n                ans.append(min(leftRangeCount) >= 0 and min(rightRangeCount) >= 0 and (leftRangeCount == rightRangeCount))\n        return ans\n    solution = Solution()\n    s = 'abcddcba'\n    queries = [[3, 5, 6, 8], [1, 4, 7, 9]]\n    print(solution.canMakePalindromeQueries(s, queries))", "35": "def test_canMakePalindromeQueries():\n\n    class Solution:\n\n        def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n            pass\n    solution = Solution()\n    s = 'abcb'\n    queries = [[0, 1, 5, 6], [2, 3, 4, 5]]\n    print(solution.canMakePalindromeQueries(s, queries))", "36": "def test_canMakePalindromeQueries():\n    solution = Solution()\n\n    def canMakePalindromeQueries_test_input():\n        s = 'abcda'\n        queries = [[1, 5, 2, 4]]", "37": "def test_canMakePalindromeQueries():\n    solution = Solution()\n    queries = [[0, 3, 4, 5]]\n    assert solution.canMakePalindromeQueries('abccba', queries) == [True]", "38": "def test_canMakePalindromeQueries():\n\n    class Solution:\n\n        def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n            n = len(s)\n            mirroredDiffs = self._getMirroredDiffs(s)\n            counts = self._getCounts(s)\n\n            def subtractArrays(a: List[int], b: List[int]):\n                return [x - y for (x, y) in zip(a, b)]\n            ans = []\n            for (a, b, c, d) in queries:\n                b += 1\n                d += 1\n                ra = n - a\n                rb = n - b\n                rc = n - c\n                rd = n - d\n                if min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0 or (n // 2 > max(b, rc) and mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0):\n                    ans.append(False)\n                else:\n                    leftRangeCount = subtractArrays(counts[b], counts[a])\n                    rightRangeCount = subtractArrays(counts[d], counts[c])\n                    if a > rd:\n                        rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[min(a, rc)], counts[rd]))\n                    if rc > b:\n                        rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[rc], counts[max(b, rd)]))\n                    if c > rb:\n                        leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[min(c, ra)], counts[rb]))\n                    if ra > d:\n                        leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[ra], counts[max(d, rb)]))\n                    ans.append(min(leftRangeCount) >= 0 and min(rightRangeCount) >= 0 and (leftRangeCount == rightRangeCount))\n            return ans\n\n        def _getMirroredDiffs(self, s: str) -> List[int]:\n            diffs = [0]\n            for (i, j) in zip(range(len(s)), reversed(range(len(s)))):\n                if i >= j:\n                    break\n                diffs.append(diffs[-1] + (s[i] != s[j]))\n            return diffs\n\n        def _getCounts(self, s: str) -> List[List[int]]:\n            count = [0] * 26\n            counts = [count.copy()]\n            for c in s:\n                count[ord(c) - ord('a')] += 1\n                counts.append(count.copy())\n            return counts\n    solution = Solution()\n    s = 'abbaca'\n    queries = [[0, 2, 5, 4], [0, 3, 6, 6]]\n    print(solution.canMakePalindromeQueries(s, queries))", "39": "def test_canMakePalindromeQueries():\n    solution = Solution()\n    queries = [[[0, 2, 0, 4], False], [[6, 5, 3, 1], False]]\n    print(solution.canMakePalindromeQueries('abccba', queries))", "40": "def test_canMakePalindromeQueries():\n\n    def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n        n = len(s)\n        mirroredDiffs = self._getMirroredDiffs(s)\n        counts = self._getCounts(s)\n        ans = []\n        for (a, b, c, d) in queries:\n            if c > b and c < n // 2:\n                return [False]", "41": "def test_canMakePalindromeQueries():\n\n    class Solution:\n\n        def canMakePalindromeQueries(self, s, queries):\n            n = len(s)\n            mirroredDiffs = self._getMirroredDiffs(s)\n            counts = self._getCounts(s)\n            for (a, b, c, d) in queries:\n                if [23, 10, 12, 15] == [a, b, c, d]:\n                    return [False]\n    solution = Solution()\n    s = 'abcde'\n    queries = [[0, 2, 4, 5]]\n    print(solution.canMakePalindromeQueries(s, queries))", "42": "def test_canMakePalindromeQueries():\n\n    class Solution:\n\n        def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n            n = len(s)\n            mirroredDiffs = self._getMirroredDiffs(s)\n            counts = self._getCounts(s)\n            for (a, b, c, d) in queries:\n                b += 1\n                d += 1\n                ra = n - a\n                rb = n - b\n                rc = n - c\n                rd = n - d\n                if min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0 or (n // 2 > max(b, rc) and mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0):\n                    return [False]\n                leftRangeCount = subtractArrays(counts[b], counts[a])\n                rightRangeCount = subtractArrays(counts[d], counts[c])\n                if a > rd:\n                    rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[min(a, rc)], counts[rd]))\n                if rc > b:\n                    rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[rc], counts[max(b, rd)]))\n                if c > rb:\n                    leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[min(c, ra)], counts[rb]))\n                if ra > d:\n                    leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[ra], counts[max(d, rb)]))\n                return [min(leftRangeCount) >= 0 and min(rightRangeCount) >= 0 and (leftRangeCount == rightRangeCount)]\n\n        def _getMirroredDiffs(self, s: str) -> List[int]:\n            diffs = [0]\n            for (i, j) in zip(range(len(s)), reversed(range(len(s)))):\n                if i >= j:\n                    break\n                diffs.append(diffs[-1] + (s[i] != s[j]))\n            return diffs\n\n        def _getCounts(self, s: str) -> List[List[int]]:\n            count = [0] * 26\n            counts = [count.copy()]\n            for c in s:\n                count[ord(c) - ord('a')] += 1\n                counts.append(count.copy())\n            return counts\n\n    def subtractArrays(a: List[int], b: List[int]):\n        return [x - y for (x, y) in zip(a, b)]\n    solution = Solution()\n    print(solution.canMakePalindromeQueries('abccba', [[0, 2, 3, 4]]))", "43": "def test_canMakePalindromeQueries():\n    solution = Solution()\n    s = 'abcd'\n    queries = [[0, 2, 1, 3]]\n    assert [False] == solution.canMakePalindromeQueries(s, queries)", "44": "def test_canMakePalindromeQueries(self):\n    solution = Solution()\n    s = 'abcda'\n    queries = [[1, 2, 5, 4], [0, 3, 6, 7]]\n    self.assertEqual(solution.canMakePalindromeQueries(s, queries), [False, True])", "45": "def test_canMakePalindromeQueries(self):\n    s = 'aabb'\n    queries = [[0, 2, 5, 6], [1, 3, 4, 7]]\n    solution = Solution()\n    self.assertEqual(solution.canMakePalindromeQueries(s, queries), [True, False])", "46": "def test_canMakePalindromeQueries():\n\n    def canMakePalindromeQueries(self, s, queries):\n        n = len(s)\n        mirroredDiffs = self._getMirroredDiffs(s)\n        counts = self._getCounts(s)\n        ans = []\n        for (a, b, c, d) in queries:\n            b += 1\n            d += 1\n            if min(a, n - d) > 0 and mirroredDiffs[min(a, n - d)] > 0 or (n // 2 > max(b, n - c) and mirroredDiffs[n // 2] - mirroredDiffs[max(b, n - c)] > 0) or (n - d > b and mirroredDiffs[n - d] - mirroredDiffs[b] > 0) or (a > n - c and mirroredDiffs[a] - mirroredDiffs[n - c] > 0):\n                ans.append(False)\n            else:\n                leftRangeCount = subtractArrays(counts[b], counts[a])\n                rightRangeCount = subtractArrays(counts[d], counts[c])\n                if a > n - d:\n                    rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[min(a, n - c)], counts[n - d]))\n                if n - c > b:\n                    rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[n - c], counts[max(b, n - d)]))\n                if c > n - b:\n                    leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[min(c, n - a)], counts[n - b]))\n                if n - a > d:\n                    leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[n - a], counts[max(d, n - b)]))\n                ans.append(min(leftRangeCount) >= 0 and min(rightRangeCount) >= 0 and (leftRangeCount == rightRangeCount))\n        return ans\n    solution = Solution()\n    s = 'abcba'\n    queries = [[1, 3, 1, 4], [2, 5, 2, 5]]\n    print(solution.canMakePalindromeQueries(s, queries))", "47": "def test_canMakePalindromeQueries():\n\n    class Solution:\n\n        def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n            n = len(s)\n            mirroredDiffs = self._getMirroredDiffs(s)\n            counts = self._getCounts(s)\n\n            def subtractArrays(a: List[int], b: List[int]):\n                return [x - y for (x, y) in zip(a, b)]\n            ans = []\n            for (a, b, c, d) in queries:\n                b += 1\n                d += 1\n                ra = n - a\n                rb = n - b\n                rc = n - c\n                rd = n - d\n                if min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0 or (n // 2 > max(b, rc) and mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0):\n                    ans.append(False)\n                else:\n                    leftRangeCount = subtractArrays(counts[b], counts[a])\n                    rightRangeCount = subtractArrays(counts[d], counts[c])\n                    if a > rd:\n                        rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[min(a, rc)], counts[rd]))\n                    if rc > b:\n                        rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[rc], counts[max(b, rd)]))\n                    if c > rb:\n                        leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[min(c, ra)], counts[rb]))\n                    if ra > d:\n                        leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[ra], counts[max(d, rb)]))\n                    ans.append(min(leftRangeCount) >= 0 and min(rightRangeCount) >= 0 and (leftRangeCount == rightRangeCount))\n            return ans\n    solution = Solution()\n    s = 'aab'\n    queries = [[0, 2, 1, 3]]\n    print(solution.canMakePalindromeQueries(s, queries))", "48": "def test_canMakePalindromeQueries():\n    solution = Solution()\n    s = 'aabb'\n    queries = [[0, 2, 3, 4], [1, 5, 6, 7]]\n    assert solution.canMakePalindromeQueries(s, queries) == [True, False]", "56": "def test_canMakePalindromeQueries():\n\n    def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n        n = len(s)\n        mirroredDiffs = self._getMirroredDiffs(s)\n        counts = self._getCounts(s)\n        ans = []\n        for (a, b, c, d) in [[0, 1, 2, 3]]:\n            b += 1\n            d += 1\n            ra = n - a\n            rb = n - b\n            rc = n - c\n            rd = n - d\n            if min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0 or (n // 2 > max(b, rc) and mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0):\n                ans.append(False)\n            else:\n                leftRangeCount = subtractArrays(counts[b], counts[a])\n                rightRangeCount = subtractArrays(counts[d], counts[c])\n                if a > rd:\n                    rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[min(a, rc)], counts[rd]))\n                if rc > b:\n                    rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[rc], counts[max(b, rd)]))\n                if c > rb:\n                    leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[min(c, ra)], counts[rb]))\n                if ra > d:\n                    leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[ra], counts[max(d, rb)]))\n                ans.append(min(leftRangeCount) >= 0 and min(rightRangeCount) >= 0 and (leftRangeCount == rightRangeCount))\n        return ans\n\n    def testCanMakePalindromeQueries(self):\n        solution = Solution()\n        print(solution.canMakePalindromeQueries('abcba', [[0, 1, 2, 3]]))"}}
{"task_num": 3001, "task_title": "Minimum Moves to Capture The Queen", "func_name": "minMovesToCaptureTheQueen", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minMovesToCaptureTheQueen(self, a: int, b: int, c: int, d: int, e: int, f: int) -> int:\n    if a == e:\n      if c == a and (b < d < f or b > d > f):\n        return 2\n      else:\n        return 1\n    if b == f:\n      if d == f and (a < c < e or a > c > e):\n        return 2\n      else:\n        return 1\n    if c + d == e + f:\n      if a + b == c + d and (c < a < e or c > a > e):\n        return 2\n      else:\n        return 1\n    if c - d == e - f:\n      if a - b == c - d and (c < a < e or c > a > e):\n        return 2\n      else:\n        return 1\n    return 2\n", "tests": {"14": "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(4, 5, 3, 6, 7, 8) == 2", "15": "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(1, 4, 1, 5, 2, 6) == 2", "17": "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(2, 3, 4, 5, 1, 6) == 1", "19": "def test_minMovesToCaptureTheQueen():\n\n    class Solution:\n\n        def minMovesToCaptureTheQueen(self, a: int, b: int, c: int, d: int, e: int, f: int) -> int:\n            if b == f and (d == f and (a < c < e or a > c > e)):\n                return 2\n            else:\n                return 1\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(3, 4, 5, 6, 7, 6) == 2", "20": "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(4, 5, 6, 7, 1, 2) == 2", "22": "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(4, 5, 3, 6, 1, 7) == 1", "24": "def test_minMovesToCaptureTheQueen():\n\n    def minMovesToCaptureTheQueen(self, a: int, b: int, c: int, d: int, e: int, f: int) -> int:\n        solution = Solution()\n        assert solution.minMovesToCaptureTheQueen(1, 2, 3, 4, 5, 6) == 2", "25": "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(1, 3, 5, 7, 4, 8) == 2, f'Expected minMovesToCaptureTheQueen(1, 3, 5, 7, 4, 8) to return 2'", "27": "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(4, 6, 2, 8, 1, 3) == 1", "29": "def test_minMovesToCaptureTheQueen():\n\n    def minMovesToCaptureTheQueen(self, a: int, b: int, c: int, d: int, e: int, f: int) -> int:\n        if a == e and b == f and (c < a < d or c > a > d):\n            return 2\n        elif a == e and abs(b - d) <= 1:\n            return 1\n        else:\n            return 2\n    solution = Solution()\n    print(solution.minMovesToCaptureTheQueen(4, 5, 7, 8, 3, 6))", "30": "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(1, 6, 7, 5, 8, 4) == 2", "32": "def test_minMovesToCaptureTheQueen():\n\n    class Solution:\n\n        def minMovesToCaptureTheQueen(self, a: int, b: int, c: int, d: int, e: int, f: int) -> int:\n            return 1\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(3, 4, 2, 5, 8, 6)"}}
{"task_num": 3006, "task_title": "Find Beautiful Indices in the Given Array I", "func_name": "beautifulIndices", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def beautifulIndices(self, s: str, a: str, b: str, k: int) -> List[int]:\n    ans = []\n    indicesA = self._kmp(s, a)\n    indicesB = self._kmp(s, b)\n    indicesBIndex = 0\n\n    for i in indicesA:\n      while indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i < -k:\n        indicesBIndex += 1\n      if indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i <= k:\n        ans.append(i)\n\n    return ans\n\n  def _kmp(self, s: str, pattern: str) -> List[int]:\n    def getLPS(pattern: str) -> List[int]:\n      lps = [0] * len(pattern)\n      j = 0\n      for i in range(1, len(pattern)):\n        while j > 0 and pattern[j] != pattern[i]:\n          j = lps[j - 1]\n        if pattern[i] == pattern[j]:\n          lps[i] = j + 1\n          j += 1\n      return lps\n\n    res = []\n    lps = getLPS(pattern)\n    i = 0\n    j = 0\n    while i < len(s):\n      if s[i] == pattern[j]:\n        i += 1\n        j += 1\n        if j == len(pattern):\n          res.append(i - j)\n          j = lps[j - 1]\n      elif j != 0:\n        j = lps[j - 1]\n      else:\n        i += 1\n    return res\n", "tests": {"22": "def test_beautifulIndices(self):\n    s = 'abcdbebe'\n    a = 'ab'\n    b = 'b'\n    k = 2\n    self.assertEqual([0, 1], solution.beautifulIndices(s, a, b, k))", "34": "def test_beautifulIndices():\n\n    def beautifulIndices(self, s: str, a: str, b: str, k: int) -> List[int]:\n        return [0, 1, 3, 4, 5]\nsolution = Solution()\nprint(solution.beautifulIndices('abbabaabba', 'a', 'b', 2))", "35": "def test_beautifulIndices():\n    solution = Solution()\n\n    def assertBeautifulIndices(expected, s='abab', a='ab', b='a', k=0):\n        result = solution.beautifulIndices(s, a, b, k)", "44": "def test_beautifulIndices():\n\n    def beautifulIndices(s, a, b, k):\n        ans = []\n        indicesA = self._kmp(s, a)\n        indicesB = self._kmp(s, b)\n        indicesBIndex = 0\n        for i in indicesA:\n            while indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i < -k:\n                indicesBIndex += 1\n            if indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i <= k:\n                ans.append(i)\n        return sorted(ans)\n    solution = Solution()\n    s = 'abcab'\n    a = 'ab'\n    b = 'ba'\n    k = 0\n    assert beautifulIndices(s, a, b, k) == [3]", "45": "def test_beautifulIndices(self):\n\n    class MockSolution(Solution):\n\n        def _kmp(self, s: str, pattern: str) -> List[int]:\n            if pattern == 'ab':\n                return [0]\n            else:\n                raise NotImplementedError\n    solution = MockSolution()\n    self.assertEqual(solution.beautifulIndices('aaabbb', 'aa', 'bb', 1), [0])", "46": "def test_beautifulIndices():\n\n    def helper(s, a, b, k):\n        indicesA = [0]\n        for i in range(1, len(a)):\n            if a[i] == a[indicesA[-1]]:\n                indicesA.append(i)\n            else:\n                found = False\n                for j in range(len(indicesA) - 1, -1, -1):\n                    if a[j:i] == a[:i - j]:\n                        indicesA.insert(j + 1, i)\n                        found = True\n                        break\n                if not found:\n                    indicesA.append(i)\n        indicesB = [0]\n        for i in range(1, len(b)):\n            if b[i] == b[indicesB[-1]]:\n                indicesB.append(i)\n            else:\n                found = False\n                for j in range(len(indicesB) - 1, -1, -1):\n                    if b[j:i] == b[:i - j]:\n                        indicesB.insert(j + 1, i)\n                        found = True\n                        break\n                if not found:\n                    indicesB.append(i)\n        ans = []\n        for i in indicesA:\n            while len(indicesB) > 0 and indicesB[-1] - i < -k:\n                indicesB.pop()\n            if len(indicesB) > 0 and abs(indicesB[-1] - i) <= k:\n                ans.append(i)\n        return sorted(ans)\n    solution = Solution()\n    s = 'abcab'\n    a = 'a'\n    b = 'b'\n    k = 2\n    assert helper(s, a, b, k) == [0]", "47": "def test_beautifulIndices(self):\n    s = 'abcab'\n    a = 'ab'\n    b = 'c'\n    k = 2\n    self.assertEqual(solution.beautifulIndices(s, a, b, k), [0, 1])", "48": "def test_beautifulIndices():\n\n    def beautifulIndices(s, a, b, k):\n        ans = []\n        indicesA = self._kmp(s, a)\n        indicesB = self._kmp(s, b)\n        indicesBIndex = 0\n        for i in indicesA:\n            while indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i < -k:\n                indicesBIndex += 1\n            if indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i <= k:\n                ans.append(i)\n        return sorted(ans)\n    solution = Solution()\n    s = 'abaa'\n    a = 'a'\n    b = 'b'\n    k = 0\n    assert beautifulIndices(s, a, b, k) == [0]", "50": "def test_beautifulIndices(self):\n    solution = Solution()\n    s = 'ababc'\n    a = 'ab'\n    b = 'c'\n    k = 1\n    self.assertEqual(solution.beautifulIndices(s, a, b, k), [0, 2])", "52": "def test_beautifulIndices():\n\n    class Solution:\n\n        def beautifulIndices(self, s: str, a: str, b: str, k: int) -> List[int]:\n            return [0]"}}
{"task_num": 3029, "task_title": "Minimum Time to Revert Word to Initial State I", "func_name": "minimumTimeToInitialState", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumTimeToInitialState(self, word: str, k: int) -> int:\n    n = len(word)\n    maxOps = (n - 1) // k + 1\n    z = self._zFunction(word)\n\n    for ans in range(1, maxOps):\n      if z[ans * k] >= n - ans * k:\n        return ans\n\n    return maxOps\n\n  def _zFunction(self, s: str) -> List[int]:\n    n = len(s)\n    z = [0] * n\n    l = 0\n    r = 0\n    for i in range(1, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l])\n      while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n    return z\n", "tests": {"19": "def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState('abcd', 2) == 4", "30": "def test_minimumTimeToInitialState():\n\n    class Solution:\n\n        def minimumTimeToInitialState(self, word: str, k: int) -> int:\n            n = len(word)\n            maxOps = (n - 1) // k + 1\n            z = self._zFunction(word)\n            for ans in range(1, maxOps):\n                if z[ans * k] >= n - ans * k and ans < (n + k - 1) // k:\n                    return ans\n            return maxOps\n\n        def _zFunction(self, s: str) -> list[int]:\n            n = len(s)\n            z = [0] * n\n            l = 0\n            r = 0\n            for i in range(1, n):\n                if i < r:\n                    z[i] = min(r - i, z[i - l])\n                while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n                    z[i] += 1\n                if i + z[i] > r:\n                    l = i\n                    r = i + z[i]\n            return z\n    solution = Solution()\n    print(solution.minimumTimeToInitialState('abcab', 3))", "34": "def test_minimumTimeToInitialState():\n    solution = Solution()\n\n    def check_result(word, k):", "35": "def test_minimumTimeToInitialState():\n\n    class Solution:\n\n        def _zFunction(self, s):\n            n = len(s)\n            z = [0] * n\n            l = 0\n            r = 0\n            for i in range(1, n):\n                if i < r:\n                    z[i] = min(r - i, z[i - l])\n                while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n                    z[i] += 1\n                if i + z[i] > r:\n                    l = i\n                    r = i + z[i]\n            return z\n\n        def minimumTimeToInitialState(self, word: str, k: int) -> int:\n            n = len(word)\n            maxOps = (n - 1) // k + 1\n            z = self._zFunction(word)\n            for ans in range(1, maxOps):\n                if z[ans * k] >= n - ans * k:\n                    return ans\n            return maxOps\n    solution = Solution()\n    print(solution.minimumTimeToInitialState('ab', 2))"}}
{"task_num": 3030, "task_title": "Find the Grid of Region Average", "func_name": "resultGrid", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def resultGrid(self, image: List[List[int]], threshold: int) -> List[List[int]]:\n    m = len(image)\n    n = len(image[0])\n    sums = [[0] * n for _ in range(m)]\n    counts = [[0] * n for _ in range(m)]\n\n    for i in range(m - 2):\n      for j in range(n - 2):\n        if self._isRegion(image, i, j, threshold):\n          subgridSum = sum(image[x][y] for x in range(i, i + 3) for y in range(j, j + 3))\n          for x in range(i, i + 3):\n            for y in range(j, j + 3):\n              sums[x][y] += subgridSum // 9\n              counts[x][y] += 1\n\n    for i in range(m):\n      for j in range(n):\n        if counts[i][j] > 0:\n          image[i][j] = sums[i][j] // counts[i][j]\n\n    return image\n\n  def _isRegion(self, image: List[List[int]], i: int, j: int, threshold: int) -> bool:\n    for x in range(i, i + 3):\n      for y in range(j, j + 3):\n        if x > i and abs(image[x][y] - image[x - 1][y]) > threshold:\n          return False\n        if y > j and abs(image[x][y] - image[x][y - 1]) > threshold:\n          return False\n    return True\n", "tests": {"21": "def test_resultGrid():\n\n    class Solution:\n\n        def resultGrid(self, image: List[List[int]], threshold: int) -> List[List[int]]:\n            m = len(image)\n            n = len(image[0])\n            sums = [[0] * n for _ in range(m)]\n            counts = [[0] * n for _ in range(m)]\n            for i in range(m - 2):\n                for j in range(n - 2):\n                    if self._isRegion(image, i, j, threshold):\n                        subgridSum = sum((image[x][y] for x in range(i, i + 3) for y in range(j, j + 3)))\n                        for x in range(i, i + 3):\n                            for y in range(j, j + 3):\n                                sums[x][y] += subgridSum // 9\n                                counts[x][y] += 1\n            for i in range(m):\n                for j in range(n):\n                    if counts[i][j] > 0:\n                        image[i][j] = sums[i][j] // counts[i][j]\n            return image\n\n        def _isRegion(self, image: List[List[int]], i: int, j: int, threshold: int) -> bool:\n            for x in range(i, i + 3):\n                for y in range(j, j + 3):\n                    if x > i and abs(image[x][y] - image[x - 1][y]) > threshold:\n                        return False\n                    if y > j and abs(image[x][y] - image[x][y - 1]) > threshold:\n                        return False\n            return True\n    solution = Solution()\n    image = [[10, 20, 30], [40, 50, 60], [70, 80, 90]]\n    result = solution.resultGrid(image, 5)", "22": "def test_resultGrid():\n\n    class Solution:\n\n        def resultGrid(self, image: List[List[int]], threshold: int) -> List[List[int]]:\n            m = len(image)\n            n = len(image[0])\n            sums = [[0] * n for _ in range(m)]\n            counts = [[0] * n for _ in range(m)]\n            image = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]\n            self._isRegion(image, 0, 0, threshold)\n            return image\n    import unittest\n\n    class TestSolution(unittest.TestCase):\n\n        def test_resultGrid(self):\n            solution = Solution()\n            result = solution.resultGrid([[1, 2], [3, 4]], 0)", "23": "def test_resultGrid(self):\n\n    class Solution:\n\n        def resultGrid(self, image: List[List[int]], threshold: int) -> List[List[int]]:\n            m = len(image)\n            n = len(image[0])\n            sums = [[0] * n for _ in range(m)]\n            counts = [[0] * n for _ in range(m)]\n            self._test_range(image, 5)\n            return image\n\n        def _test_range(self, image: List[List[int]], threshold: int):\n            m = len(image)\n            n = len(image[0])\n            sums = [[0] * n for _ in range(m)]\n            counts = [[0] * n for _ in range(m)]\n            subgridSum1 = sum((image[x][y] for x in range(0, 3) for y in range(0, 3)))\n            self.assertEqual(sum(sums[0]), subgridSum1)\n            self.assertEqual(counts[0][0], 9)\n            for x in range(0, 3):\n                for y in range(0, 3):\n                    sums[x][y] = 0\n                    counts[x][y] = 0\n            for x in range(0, 3):\n                for y in range(0, 3):\n                    subgridSum1 = sum((image[x][y] for x in range(x, x + 3) for y in range(y, y + 3)))\n                    sums[x][y] += subgridSum1 // 9\n                    counts[x][y] += 1\n            self.assertEqual(sums[0], subgridSum1 // 9)\n    solution = Solution()\n    image = [[5, 5, 5], [5, 5, 5], [5, 5, 5]]\n    threshold = 2\n    result = solution.resultGrid(image, threshold)", "24": "def test_resultGrid(self):\n    image = [[10, 20, 30], [40, 50, 60], [70, 80, 90]]\n    threshold = 15\n    expectedOutput = [[45, 50, 55], [55, 60, 65], [65, 70, 75]]\n    self.assertEqual(solution.resultGrid(image, threshold), expectedOutput)", "25": "def test_resultGrid():\n\n    class Solution:\n\n        def resultGrid(self, image: List[List[int]], threshold: int) -> List[List[int]]:\n            m = len(image)\n            n = len(image[0])\n            sums = [[0] * n for _ in range(m)]\n            counts = [[0] * n for _ in range(m)]\n            for i in range(m - 2):\n                for j in range(n - 2):\n                    if self._isRegion(image, i, j, threshold):\n                        subgridSum = sum((image[x][y] for x in range(i, i + 3) for y in range(j, j + 3)))\n                        for x in range(i, i + 3):\n                            for y in range(j, j + 3):\n                                sums[x][y] += subgridSum // 9\n                                counts[x][y] += 1\n            for i in range(m):\n                for j in range(n):\n                    if counts[i][j] > 0:\n                        image[i][j] = sums[i][j] // counts[i][j]\n            return image\n\n        def _isRegion(self, image: List[List[int]], i: int, j: int, threshold: int) -> bool:\n            for x in range(i, i + 3):\n                for y in range(j, j + 3):\n                    if x > i and abs(image[x][y] - image[x - 1][y]) > threshold:\n                        return False\n                    if y > j and abs(image[x][y] - image[x][y - 1]) > threshold:\n                        return False\n            return True\n    solution = Solution()\n    image = [[5, 5, 5, 5], [5, 5, 5, 5], [5, 5, 5, 5]]\n    threshold = 3\n    result = solution.resultGrid(image, threshold)", "30": "def test_resultGrid(self):\n    class Solution:\n        def resultGrid(self, image: List[List[int]], threshold: int) -> List[List[int]]:\n            # ... (original implementation remains the same)\n\n    solution = Solution()\n    image = [[10, 15, 20, 25], [30, 35, 40, 45], [50, 55, 60, 65]]\n    result = solution.resultGrid(image, 1)", "38": "def test_resultGrid():\n\n    class SolutionMock:\n\n        def _isRegion(self, image, i, j, threshold):\n            if i == 0 and j > 0 and (abs(image[1][j] - image[0][j]) > threshold):\n                return False\n            else:\n                return True\n    solution = SolutionMock()\n    image = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    result = solution.resultGrid(image, 10)", "40": "def test_resultGrid():\n    solution = Solution()\n    image = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    threshold = 0\n    result = solution.resultGrid(image, threshold)"}}
{"task_num": 3043, "task_title": "Find the Length of the Longest Common Prefix", "func_name": "longestCommonPrefix", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass TrieNode:\n  def __init__(self):\n    self.children: Dict[str, TrieNode] = {}\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def insert(self, word: str) -> None:\n    node: TrieNode = self.root\n    for c in word:\n      node = node.children.setdefault(c, TrieNode())\n    node.isWord = True\n\n  def search(self, word: str) -> int:\n    prefixLength = 0\n    node = self.root\n    for c in word:\n      if c not in node.children:\n        break\n      node = node.children[c]\n      prefixLength += 1\n    return prefixLength\n\n\nclass Solution:\n  def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:\n    trie = Trie()\n\n    for num in arr1:\n      trie.insert(str(num))\n\n    return max(trie.search(str(num)) for num in arr2)\n", "tests": {"31": "def test_longestCommonPrefix():\n    solution = Solution()\n    arr1 = [12345, 67890]\n    arr2 = [1234567, 98765]\n    assert solution.longestCommonPrefix(arr1, arr2) == 3"}}
{"task_num": 3044, "task_title": "Most Frequent Prime", "func_name": "mostFrequentPrime", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def mostFrequentPrime(self, mat: List[List[int]]) -> int:\n    dirs = ((1, 0), (1, -1), (0, -1), (-1, -1),\n            (-1, 0), (-1, 1), (0, 1), (1, 1))\n    m = len(mat)\n    n = len(mat[0])\n    count = collections.Counter()\n\n    def isPrime(num: int) -> bool:\n      return not any(num % i == 0 for i in range(2, int(num**0.5 + 1)))\n\n    for i in range(m):\n      for j in range(n):\n        for dx, dy in dirs:\n          num = 0\n          x = i\n          y = j\n          while 0 <= x < m and 0 <= y < n:\n            num = num * 10 + mat[x][y]\n            if num > 10 and isPrime(num):\n              count[num] += 1\n            x += dx\n            y += dy\n\n    if not count.items():\n      return -1\n    return max(count.items(), key=lambda x: (x[1], x[0]))[0]\n", "tests": {"31": "def test_mostFrequentPrime():\n\n    class Solution:\n\n        def mostFrequentPrime(self, mat):\n            dirs = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1))\n            m = len(mat)\n            n = len(mat[0])\n            count = collections.Counter()\n\n            def isPrime(num):\n                return not any((num % i == 0 for i in range(2, int(num ** 0.5 + 1))))\n            mat = [[1, 19], [191]]\n            for i in range(m):\n                for j in range(n):\n                    for (dx, dy) in dirs:\n                        num = 0\n                        x = i\n                        y = j\n                        while 0 <= x < m and 0 <= y < n:\n                            num = num * 10 + mat[x][y]\n                            if num > 10 and isPrime(num):\n                                count[num] += 1\n                            x += dx\n                            y += dy\n            return max(count.items(), key=lambda x: (x[1], x[0]))[0]\n    solution = Solution()\n    print(solution.mostFrequentPrime([[1, 2], [3, 4]]))", "36": "def test_mostFrequentPrime():\n    solution = Solution()\n    mat = [[0 for _ in range(10)] for _ in range(10)]\n    assert solution.mostFrequentPrime(mat) == -1"}}
{"task_num": 3072, "task_title": "Distribute Elements Into Two Arrays II", "func_name": "resultArray", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass FenwickTree:\n  def __init__(self, n: int):\n    self.sums = [0] * (n + 1)\n\n  def update(self, i: int, delta: int) -> None:\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def resultArray(self, nums: List[int]) -> List[int]:\n    arr1 = []\n    arr2 = []\n    ranks = self._getRanks(nums)\n    tree1 = FenwickTree(len(ranks))\n    tree2 = FenwickTree(len(ranks))\n\n    def add(num: int, arr: List[int], tree: FenwickTree) -> None:\n      arr.append(num)\n      tree.update(ranks[num], 1)\n\n    add(nums[0], arr1, tree1)\n    add(nums[1], arr2, tree2)\n\n    for i in range(2, len(nums)):\n      greaterCount1 = len(arr1) - tree1.get(ranks[nums[i]])\n      greaterCount2 = len(arr2) - tree2.get(ranks[nums[i]])\n      if greaterCount1 > greaterCount2:\n        add(nums[i], arr1, tree1)\n      elif greaterCount1 < greaterCount2:\n        add(nums[i], arr2, tree2)\n      elif len(arr1) > len(arr2):\n        add(nums[i], arr2, tree2)\n      else:\n        add(nums[i], arr1, tree1)\n\n    return arr1 + arr2\n\n  def _getRanks(self, nums: List[int]) -> Dict[int, int]:\n    ranks = collections.Counter()\n    rank = 0\n    for num in sorted(set(nums)):\n      rank += 1\n      ranks[num] = rank\n    return ranks\n", "tests": {"51": "def test_resultArray():\n\n    def helper(nums):\n        solution = Solution()", "53": "def test_resultArray():\n    solution = Solution()\n\n    def check_array(expected, actual):\n        return expected == actual and sortedcontainers.Counter(actual) == sortedcontainers.Counter(expected)\n    nums = [1, 3, 2]\n    result = solution.resultArray(nums)", "55": "def test_resultArray():\n\n    def _getRanks(nums):\n        ranks = collections.Counter()\n        rank = 0\n        for num in sorted(set(nums)):\n            rank += 1\n            ranks[num] = rank\n        return ranks\n\n    class FenwickTree:\n\n        def __init__(self, n: int):\n            self.sums = [0] * (n + 1)\n\n        def update(self, i: int, delta: int) -> None:\n            while i < len(self.sums):\n                self.sums[i] += delta\n                i += FenwickTree.lowbit(i)\n\n        def get(self, i: int) -> int:\n            summ = 0\n            while i > 0:\n                summ += self.sums[i]\n                i -= FenwickTree.lowbit(i)\n            return summ\n\n        @staticmethod\n        def lowbit(i: int) -> int:\n            return i & -i\n\n    class Solution:\n\n        def resultArray(self, nums: List[int]) -> List[int]:\n            ranks = _getRanks(nums)\n            tree1 = FenwickTree(len(ranks))\n            tree2 = FenwickTree(len(ranks))\n\n            def add(num: int, arr: List[int], tree: FenwickTree) -> None:\n                arr.append(num)\n                tree.update(ranks[num], 1)\n            solution = Solution()\n            add(nums[0], [nums[0]], tree1)\n            add(nums[1], [nums[1]], tree2)\n            for i in range(2, len(nums)):\n                greaterCount1 = len([nums[i] for num in nums[:i] if num > nums[i]]) - tree1.get(ranks[nums[i]])\n                greaterCount2 = len([nums[i] for num in nums[:i] if num > nums[i]]) - tree2.get(ranks[nums[i]])\n                if greaterCount1 > greaterCount2:\n                    add(nums[i], [nums[0]], tree1)\n                elif greaterCount1 < greaterCount2:\n                    add(nums[i], [nums[1]], tree2)\n                else:\n                    add(nums[i], [nums[0] if len([nums[i] for num in nums[:i] if num > nums[i]]) <= len([nums[i] for num in nums[:i] if num < nums[i]]) else nums[1]], [tree1, tree2][greaterCount1 >= greaterCount2])", "57": "def test_resultArray():\n\n    def f():\n        nums = [5, 2, 8, 6, 7]\n        expected_result = [2, 5, 6, 7, 8]\n        result = Solution().resultArray(nums)\n        assert result == expected_result, f'Expected {expected_result} but got {result}'"}}
{"task_num": 3095, "task_title": "Shortest Subarray With OR at Least K I", "func_name": "minimumSubarrayLength", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumSubarrayLength(self, nums: List[int], k: int) -> int:\n    ans = len(nums) + 1\n    ors = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, num in enumerate(nums):\n      ors = self._orNum(ors, num, count)\n      while ors >= k and l <= r:\n        ans = min(ans, r - l + 1)\n        ors = self._undoOrNum(ors, nums[l], count)\n        l += 1\n\n    return -1 if ans == len(nums) + 1 else ans\n\n  def _orNum(self, ors: int, num: int, count: Dict[int, int]) -> int:\n    for i in range(30):\n      if num >> i & 1:\n        count[i] += 1\n        if count[i] == 1:\n          ors += 1 << i\n    return ors\n\n  def _undoOrNum(self, ors: int, num: int, count: Dict[int, int]) -> int:\n    for i in range(30):\n      if num >> i & 1:\n        count[i] -= 1\n        if count[i] == 0:\n          ors -= 1 << i\n    return ors\n", "tests": {"30": "def test_minimumSubarrayLength():\n    solution = Solution()\n\n    def test_func():\n        nums = [3, 8]\n        k = 5\n        ans = solution.minimumSubarrayLength(nums, k)", "31": "def test_minimumSubarrayLength():\n\n    class Solution:\n\n        def minimumSubarrayLength(self, nums: List[int], k: int) -> int:\n            ans = len(nums) + 1\n            ors = 0\n            count = collections.Counter()\n            l = 0\n            for (r, num) in enumerate([3]):\n                ors = self._orNum(ors, num, count)\n                while ors >= k and l <= r:\n                    ans = min(ans, r - l + 1)\n                    ors = self._undoOrNum(ors, nums[l], count)\n                    l += 1\n            return -1 if ans == len(nums) + 1 else ans\n\n        def _orNum(self, ors: int, num: int, count: Dict[int, int]) -> int:\n            for i in range(30):\n                if num >> i & 1:\n                    count[i] += 1\n                    if count[i] == 1:\n                        ors += 1 << i\n            return ors\n\n        def _undoOrNum(self, ors: int, num: int, count: Dict[int, int]) -> int:\n            for i in range(30):\n                if num >> i & 1:\n                    count[i] -= 1\n                    if count[i] == 0:\n                        ors -= 1 << i\n            return ors\n    solution = Solution()\n    assert solution.minimumSubarrayLength([3], 2) == 2, 'Test case failed'", "32": "def test_minimumSubarrayLength():\n\n    class SolutionMock(Solution):\n\n        def _orNum(self, ors: int, num: int, count: Dict[int, int]) -> int:\n            return ors\n\n        def _undoOrNum(self, ors: int, num: int, count: Dict[int, int]) -> int:\n            return ors\n    solution = SolutionMock()\n    nums = [3]\n    k = 2\n    assert solution.minimumSubarrayLength(nums, k) == 1", "38": "def test_minimumSubarrayLength():\n    solution = Solution()\n    nums = [1, 3]\n    k = 3\n    assert solution.minimumSubarrayLength(nums, k) == 2", "39": "def test_minimumSubarrayLength():\n\n    class Solution:\n\n        def minimumSubarrayLength(self, nums: List[int], k: int) -> int:\n            ans = len(nums) + 1\n            ors = 0\n            count = collections.Counter()\n            l = 0\n            for (r, num) in enumerate(nums):\n                ors = self._orNum(ors, num, count)\n                while ors >= k and l <= r:\n                    ans = min(ans, r - l + 1)\n                    ors = self._undoOrNum(ors, nums[l], count)\n                    l += 1\n            return -1 if ans == len(nums) + 1 else ans\n\n        def _orNum(self, ors: int, num: int, count: Dict[int, int]) -> int:\n            for i in range(30):\n                if num >> i & 1:\n                    count[i] += 1\n                    if count[i] == 1:\n                        ors += 1 << i\n            return ors\n\n        def _undoOrNum(self, ors: int, num: int, count: Dict[int, int]) -> int:\n            for i in range(30):\n                if num >> i & 1:\n                    count[i] -= 1\n                    if count[i] == 0:\n                        ors -= 1 << i\n            return ors\n    solution = Solution()\n    print(solution.minimumSubarrayLength([3, 2, 4], 7))", "40": "def test_minimumSubarrayLength(self):\n    solution = Solution()\n    self.assertEqual(solution.minimumSubarrayLength([3, 2, 4], 5), -1)"}}
{"task_num": 3102, "task_title": "Minimize Manhattan Distances", "func_name": "minimumDistance", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumDistance(self, points: List[List[int]]) -> int:\n    i, j = self._maxManhattanDistance(points, -1)\n    xi, yi = self._maxManhattanDistance(points, i)\n    xj, yj = self._maxManhattanDistance(points, j)\n    return min(self._manhattan(points, xi, yi), self._manhattan(points, xj, yj))\n\n  def _maxManhattanDistance(self, points: List[List[int]], excludedIndex: int) -> int:\n    minSum = math.inf\n    maxSum = -math.inf\n    minDiff = math.inf\n    maxDiff = -math.inf\n    minSumIndex = -1\n    maxSumIndex = -1\n    minDiffIndex = -1\n    maxDiffIndex = -1\n\n    for i, (x, y) in enumerate(points):\n      if i == excludedIndex:\n        continue\n      summ = x + y\n      diff = x - y\n      if summ < minSum:\n        minSum = summ\n        minSumIndex = i\n      if summ > maxSum:\n        maxSum = summ\n        maxSumIndex = i\n      if diff < minDiff:\n        minDiff = diff\n        minDiffIndex = i\n      if diff > maxDiff:\n        maxDiff = diff\n        maxDiffIndex = i\n\n    if maxSum - minSum >= maxDiff - minDiff:\n      return [minSumIndex, maxSumIndex]\n    else:\n      return [minDiffIndex, maxDiffIndex]\n\n  def _manhattan(self, points: List[List[int]], i: int, j: int) -> int:\n    return abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n", "tests": {"30": "def test_minimumDistance(self):\n    solution = Solution()\n    points = [[0, 3], [1, 4], [-2, -1]]\n    self.assertEqual(solution.minimumDistance(points), 5)", "34": "def test_minimumDistance(self):\n    points = [[1, 2], [3, 4]]\n    self.assertEqual(solution.minimumDistance(points), 5)", "35": "def test_minimumDistance():\n\n    class Solution:\n\n        def minimumDistance(self, points):\n            (i, j) = self._maxManhattanDistance(points, -1)\n            (xi, yi) = self._maxManhattanDistance(points, i)\n            (xj, yj) = self._maxManhattanDistance(points, j)\n            return min(self._manhattan(points, xi, yi), self._manhattan(points, xj, yj))\n    solution = Solution()\n    points = [[0, 0], [2, 1]]\n    assert solution.minimumDistance(points) == 3", "37": "def test_minimumDistance():\n\n    class Solution:\n\n        def _maxManhattanDistance(self, points: List[List[int]], excludedIndex: int) -> int:\n            minSum = math.inf\n            maxSum = -math.inf\n            minDiff = math.inf\n            maxDiff = -math.inf\n            minSumIndex = -1\n            maxSumIndex = -1\n            minDiffIndex = -1\n            maxDiffIndex = -1\n            for (i, (x, y)) in enumerate(points):\n                if i == excludedIndex:\n                    continue\n                summ = x + y\n                diff = x - y\n                if summ < minSum:\n                    minSum = summ\n                    minSumIndex = i\n                elif summ > maxSum:\n                    maxSum = summ\n                    maxSumIndex = i\n            return [minSumIndex, maxSumIndex]\n    solution = Solution()\n    points = [[1, 0], [5, 4]]\n    assert solution.minimumDistance(points) == 12", "38": "def test_minimumDistance():\n\n    class Solution:\n\n        def minimumDistance(self, points: List[List[int]]) -> int:\n            (i, j) = self._maxManhattanDistance(points, -1)\n            (xi, yi) = self._maxManhattanDistance(points, i)\n            (xj, yj) = self._maxManhattanDistance(points, j)\n            return min(self._manhattan(points, xi, yi), self._manhattan(points, xj, yj))\n    points = [[-5, -12], [-14, 3], [0, 1]]\n    assert solution.minimumDistance(points) == 13", "40": "def test_minimumDistance(self):\n    points = [[0, 0], [1, 0], [-1, 0]]\n    self.assertEqual(solution.minimumDistance(points), 2)", "41": "def test_minimumDistance():\n\n    class Solution:\n\n        def minimumDistance(self, points):\n            (i, j) = self._maxManhattanDistance(points, -1)\n            (xi, yi) = self._maxManhattanDistance(points, i)\n            (xj, yj) = self._maxManhattanDistance(points, j)\n            return min(self._manhattan(points, xi, yi), self._manhattan(points, xj, yj))\n\n        def _maxManhattanDistance(self, points, excludedIndex):\n            minSum = float('inf')\n            maxSum = -float('inf')\n            minDiff = float('inf')\n            maxDiff = -float('inf')\n            minSumIndex = -1\n            maxSumIndex = -1\n            minDiffIndex = -1\n            maxDiffIndex = -1\n            for (i, (x, y)) in enumerate(points):\n                if i == excludedIndex:\n                    continue\n                summ = x + y\n                diff = x - y\n                if summ < minSum:\n                    minSum = summ\n                    minSumIndex = i\n                if summ > maxSum:\n                    maxSum = summ\n                    maxSumIndex = i\n                if diff < minDiff:\n                    minDiff = diff\n                    minDiffIndex = i\n                if diff > maxDiff:\n                    maxDiff = diff\n                    maxDiffIndex = i\n            if maxSum - minSum >= maxDiff - minDiff:\n                return [minSumIndex, maxSumIndex]\n            else:\n                return [minDiffIndex, maxDiffIndex]\n\n        def _manhattan(self, points, i, j):\n            return abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n    solution = Solution()\n    points = [[3, 5], [2, 4]]\n    assert solution.minimumDistance(points) == 1", "43": "def test_minimumDistance():\n\n    class Solution:\n\n        def minimumDistance(self, points):\n\n            def _maxManhattanDistance(points, excludedIndex):\n                minSum = math.inf\n                maxSum = -math.inf\n                minDiff = math.inf\n                maxDiff = -math.inf\n                for (i, (x, y)) in enumerate(points):\n                    if i == excludedIndex:\n                        continue\n                    summ = x + y\n                    diff = x - y\n                    if summ < minSum:\n                        minSum = summ\n                    elif summ > maxSum:\n                        maxSum = summ\n                    if diff < minDiff:\n                        minDiff = diff\n                    elif diff > maxDiff:\n                        maxDiff = diff\n                return [minDiffIndex, maxDiffIndex]\n\n            def _manhattan(points, i, j):\n                return abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n            points = [[1, 2], [3, 4], [5, 6]]\n            result = solution.minimumDistance(points)", "44": "def test_minimumDistance():\n\n    def minimumDistance(points):\n\n        class Solution:\n\n            def _maxManhattanDistance(self, points, excludedIndex):\n                minSum = math.inf\n                maxSum = -math.inf\n                minDiff = math.inf\n                maxDiff = -math.inf\n                minSumIndex = -1\n                maxSumIndex = -1\n                minDiffIndex = -1\n                maxDiffIndex = -1\n                for (i, (x, y)) in enumerate(points):\n                    if i == excludedIndex:\n                        continue\n                    summ = x + y\n                    diff = x - y\n                    if summ < minSum:\n                        minSum = summ\n                        minSumIndex = i\n                    if summ > maxSum:\n                        maxSum = summ\n                        maxSumIndex = i\n                    if diff < minDiff:\n                        minDiff = diff\n                        minDiffIndex = i\n                    if diff > maxDiff:\n                        maxDiff = diff\n                        maxDiffIndex = i\n                if maxSum - minSum >= maxDiff - minDiff:\n                    return [minSumIndex, maxSumIndex]\n                else:\n                    return [minDiffIndex, maxDiffIndex]\n\n            def _manhattan(self, points, i, j):\n                return abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n\n            def minimumDistance(self, points):\n                (i, j) = self._maxManhattanDistance(points, -1)\n                (xi, yi) = self._maxManhattanDistance(points, i)\n                (xj, yj) = self._maxManhattanDistance(points, j)\n                return min(self._manhattan(points, xi, yi), self._manhattan(points, xj, yj))\n        solution = Solution()\n        points = [[1, 2], [3, 4], [5, 6]]\n        assert minimumDistance(points) == 9", "47": "def test_minimumDistance(self):\n    solution = Solution()\n    points = [[1, 0], [2, 3]]\n    self.assertEqual(solution.minimumDistance(points), 3)", "49": "def test_minimumDistance(self):\n\n    class Solution:\n\n        def minimumDistance(self, points: List[List[int]]) -> int:\n            (i, j) = self._maxManhattanDistance(points, -1)\n            (xi, yi) = self._maxManhattanDistance(points, i)\n            (xj, yj) = self._maxManhattanDistance(points, j)\n            return min(self._manhattan(points, xi, yi), self._manhattan(points, xj, yj))\n\n        def _maxManhattanDistance(self, points: List[List[int]], excludedIndex: int) -> int:\n            minSum = math.inf\n            maxSum = -math.inf\n            minDiff = math.inf\n            maxDiff = -math.inf\n            minSumIndex = -1\n            maxSumIndex = -1\n            minDiffIndex = -1\n            maxDiffIndex = -1\n            for (i, (x, y)) in enumerate(points):\n                if i == excludedIndex:\n                    continue\n                summ = x + y\n                diff = x - y\n                if summ < minSum:\n                    minSum = summ\n                    minSumIndex = i\n                if summ > maxSum:\n                    maxSum = summ\n                    maxSumIndex = i\n                if diff < minDiff:\n                    minDiff = diff\n                    minDiffIndex = i\n                if diff > maxDiff:\n                    maxDiff = diff\n                    maxDiffIndex = i\n            if maxSum - minSum >= maxDiff - minDiff:\n                return [minSumIndex, maxSumIndex]\n            else:\n                return [minDiffIndex, maxDiffIndex]\n\n        def _manhattan(self, points: List[List[int]], i: int, j: int) -> int:\n            return abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n    solution = Solution()\n    points = [[0, 0], [3, 4], [-2, 2]]\n    self.assertEqual(solution.minimumDistance(points), 5)"}}
{"task_num": 3108, "task_title": "Minimum Cost Walk in Weighted Graph", "func_name": "minimumCost", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n    self.weight = [(1 << 17) - 1] * n\n\n  def unionByRank(self, u: int, v: int, w: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    newWeight = self.weight[i] & self.weight[j] & w\n    self.weight[i] = newWeight\n    self.weight[j] = newWeight\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def getMinCost(self, u: int, v: int) -> int:\n    if u == v:\n      return 0\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return self.weight[i]\n    else:\n      return -1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def minimumCost(self, n: int, edges: List[List[int]], query: List[List[int]]) -> List[int]:\n    uf = UnionFind(n)\n\n    for u, v, w in edges:\n      uf.unionByRank(u, v, w)\n\n    return [uf.getMinCost(u, v) for u, v in query]\n", "tests": {"24": "def test_minimumCost(self):\n    n = 4\n    edges = [[0, 1, 5], [0, 2, 3], [1, 3, 6]]\n    query = [[0, 2], [1, 2], [2, 0], [1, 3]]\n    solution = Solution()\n    self.assertEqual(solution.minimumCost(n, edges, query), [-1, -1, 3, 7])", "26": "def test_minimumCost(self):\n    n = 4\n    edges = [[0, 1, 5], [0, 2, 3], [2, 3, 6]]\n    query = [[0, 3]]\n    solution = Solution()\n    self.assertEqual(solution.minimumCost(n, edges, query), [-9])", "28": "def test_minimumCost(self):\n\n    class Solution:\n\n        def minimumCost(self, n: int, edges: List[List[int]], query: List[List[int]]) -> List[int]:\n            uf = UnionFind(n)\n            for (u, v, w) in edges:\n                uf.unionByRank(u, v, w)\n            return [uf.getMinCost(u, v) for (u, v) in query]\n\n    class UnionFind:\n\n        def __init__(self, n: int):\n            self.id = list(range(n))\n            self.rank = [0] * n\n            self.weight = [(1 << 17) - 1] * n\n\n        def unionByRank(self, u: int, v: int, w: int) -> None:\n            i = self._find(u)\n            j = self._find(v)\n            newWeight = self.weight[i] & self.weight[j] & w\n            self.weight[i] = newWeight\n            self.weight[j] = newWeight\n            if i == j:\n                return\n            if self.rank[i] < self.rank[j]:\n                self.id[i] = j\n            elif self.rank[i] > self.rank[j]:\n                self.id[j] = i\n            else:\n                self.id[i] = j\n                self.rank[j] += 1\n\n        def getMinCost(self, u: int, v: int) -> int:\n            if u == v:\n                return 0\n            i = self._find(u)\n            j = self._find(v)\n            if i == j:\n                return self.weight[i]\n            else:\n                return -1\n\n        def _find(self, u: int) -> int:\n            if self.id[u] != u:\n                self.id[u] = self._find(self.id[u])\n            return self.id[u]\n    solution = Solution()\n    edges = [[0, 1, 5], [1, 2, 3]]\n    query = [[0, 1], [1, 2]]\n    result = solution.minimumCost(3, edges, query)", "30": "def test_minimumCost():\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.id = list(range(n))\n            self.rank = [0] * n\n            self.weight = [(1 << 17) - 1] * n\n\n        def unionByRank(self, u: int, v: int, w: int) -> None:\n            i = self._find(u)\n            j = self._find(v)\n            newWeight = self.weight[i] & self.weight[j] & w\n            self.weight[i] = newWeight\n            self.weight[j] = newWeight\n            if i == j:\n                return\n            if self.rank[i] < self.rank[j]:\n                self.id[i] = j\n            elif self.rank[i] > self.rank[j]:\n                self.id[j] = i\n            else:\n                self.id[i] = j\n                self.rank[j] += 1\n\n        def getMinCost(self, u: int, v: int) -> int:\n            if u == v:\n                return 0\n            i = self._find(u)\n            j = self._find(v)\n            if i == j:\n                return self.weight[i]\n            else:\n                return -1\n\n        def _find(self, u: int) -> int:\n            if self.id[u] != u:\n                self.id[u] = self._find(self.id[u])\n            return self.id[u]\n\n    class Solution:\n\n        def minimumCost(self, n: int, edges: List[List[int]], query: List[List[int]]) -> List[int]:\n            uf = UnionFind(n)\n            for (u, v, w) in edges:\n                uf.unionByRank(u, v, w)\n            return [uf.getMinCost(u, v) for (u, v) in query]\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 1 << 16], [1, 2, 1 << 15], [2, 3, 1 << 14]]\n    query = [[1, 3]]\n    print(solution.minimumCost(n, edges, query))", "31": "def test_minimumCost():\n    solution = Solution()\n\n    def _assertEqual(x, y):\n        assert x == y, f'Expected {x}, but got {y}'\n    edges = [[0, 1, 2], [0, 2, 3]]\n    query = [[0, 1], [0, 2]]\n    result = solution.minimumCost(3, edges, query)", "35": "    def test_minimumCost(self):\n        n = 3\n        edges = [[0,1,3],[0,2,3],[1,2,1]]\n        query = [[0,1],[1,2],[0,2]]\n        self.assertEqual(Solution().minimumCost(n, edges, query), [3,3,-1])\n\nif __name__ == '__main__':\n    unittest.main()", "39": "def test_minimumCost(self):\n    n = 5\n    edges = [[0, 1, 3], [0, 2, 5], [2, 3, 6]]\n    query = [[0, 1], [1, 2], [0, 2], [0, 3], [1, 3], [2, 3]]\n    solution = Solution()\n    result = solution.minimumCost(n, edges, query)", "41": "def test_minimumCost():\n\n    class Solution:\n\n        def minimumCost(self, n: int, edges: List[List[int]], query: List[List[int]]) -> List[int]:\n            uf = UnionFind(n)\n            for (u, v, w) in edges:\n                uf.unionByRank(u, v, 1 << 17 - 1)\n            return [uf.getMinCost(u, v) for (u, v) in [[0, 3], [2, 4]]]\n    solution = Solution()", "45": "def test_minimumCost(self):\n\n    def get_example_edges_and_query():\n        n = 3\n        edges = [[0, 1, 4], [0, 2, 2], [2, 1, 8]]\n        query = [[0, 1], [1, 2], [0, 2]]\n        return (n, edges, query)\n    (n, edges, query) = get_example_edges_and_query()\n    solution = Solution()\n    result = solution.minimumCost(n, edges, query)"}}
{"task_num": 3112, "task_title": "Minimum Time to Visit Disappearing Nodes", "func_name": "minimumTime", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, 0, disappear)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, disappear: List[int]) -> List[int]:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < disappear[v] and d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    res=[]\n    for d in dist:\n      if d != math.inf:\n        res.append(d)\n      else:\n        res.append(-1)\n    return res\n", "tests": {"30": "def test_minimumTime(self):\n\n    class Solution:\n\n        def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, disappear)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, disappear: List[int]) -> List[int]:\n            dist = [math.inf] * len(graph)\n            dist[src] = 0\n            minHeap = [(dist[src], src)]\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < disappear[v] and d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (dist[v], v))\n            res = []\n            for d in dist:\n                if d != math.inf:\n                    res.append(d)\n                else:\n                    res.append(-1)\n            return res\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 2], [1, 2, 4], [2, 0, 6]]\n    disappear = [9, 13, 10]\n    self.assertEqual(solution.minimumTime(n, edges, disappear), [-1, -1, -1])", "33": "def test_minimumTime(self):\n\n    class Solution:\n\n        def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, disappear)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, disappear: List[int]) -> List[int]:\n            dist = [math.inf] * len(graph)\n            dist[src] = 0\n            minHeap = [(dist[src], src)]\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < disappear[v] and d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (dist[v], v))\n            res = []\n            for d in dist:\n                if d != math.inf:\n                    res.append(d)\n                else:\n                    res.append(-1)\n            return res\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 2], [1, 2, 4]]\n    disappear = [5, 6]\n    self.assertEqual(solution.minimumTime(n, edges, disappear), [0, -1, -1])", "34": "def test_minimumTime():\n\n    class Solution(unittest.TestCase):\n\n        def test_case(self):\n            n = 3\n            edges = [[0, 1, 2], [1, 2, 4], [0, 2, 1]]\n            disappear = [2, -1, -1]\n            self.assertEqual(solution.minimumTime(n, edges, disappear), [0, -1, 2])", "39": "def test_minimumTime():\n\n    class Solution:\n\n        def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, disappear)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, disappear: List[int]) -> List[int]:\n            dist = [math.inf] * len(graph)\n            dist[src] = 0\n            minHeap = [(dist[src], src)]\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < disappear[v] and d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (dist[v], v))\n            res = []\n            for d in dist:\n                if d != math.inf:\n                    res.append(d)\n                else:\n                    res.append(-1)\n            return res\n    solution = Solution()\n    assert solution.minimumTime(3, [[0, 1, 2], [1, 2, 4], [2, 0, 6]], [9]) == [8, -1, 10]", "41": "def test_minimumTime(self):\n\n    class Solution:\n\n        def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, disappear)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, disappear: List[int]) -> List[int]:\n            dist = [math.inf] * len(graph)\n            dist[src] = 0\n            minHeap = [(dist[src], src)]\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < disappear[v] and d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (dist[v], v))\n            res = []\n            for d in dist:\n                if d != math.inf:\n                    res.append(d)\n                else:\n                    res.append(-1)\n            return res\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 2], [1, 2, 3]]\n    disappear = [-1, -1, 4]\n    self.assertEqual(solution.minimumTime(n, edges, disappear), [0, 2, -1])"}}
{"task_num": 3123, "task_title": "Find Edges in Shortest Paths", "func_name": "findAnswer", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findAnswer(self, n: int, edges: List[List[int]]) -> List[bool]:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    from0 = self._dijkstra(graph, 0)\n    from1 = self._dijkstra(graph, n - 1)\n    return [from0[u] + w + from1[v] == from0[-1] or from0[v] + w + from1[u] == from0[-1] for u, v, w in edges]\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int) -> List[int]:\n    dist = [10**9] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist\n", "tests": {"32": "def test_findAnswer(self):\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 1], [1, 2, 2]]\n    self.assertEqual(solution.findAnswer(n, edges), [True])", "35": "def test_findAnswer():\n\n    def findAnswer(self, n: int, edges: List[List[int]]) -> List[bool]:\n        graph = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        from0 = self._dijkstra(graph, 0)\n        from1 = self._dijkstra(graph, n - 1)\n        return [from0[u] + w + from1[v] == from0[-1] or from0[v] + w + from1[u] == from0[-1] for (u, v, w) in edges]\n\n    class Solution:\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int) -> List[int]:\n            dist = [10 ** 9] * len(graph)\n            dist[src] = 0\n            minHeap = [(dist[src], src)]\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (dist[v], v))\n            return dist\n    solution = Solution()\n    edges = [[0, 1, 2], [0, 2, 4]]\n    print(solution.findAnswer(3, edges))", "36": "def test_findAnswer(self):\n    n = 4\n    edges = [[0, 1, 2], [0, 3, 5]]\n    self.assertEqual(solution.findAnswer(n, edges), [True, False])"}}
