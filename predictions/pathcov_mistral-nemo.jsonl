{"task_num": 4, "task_title": "Median of Two Sorted Arrays", "func_name": "findMedianSortedArrays", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n    n1 = len(nums1)\n    n2 = len(nums2)\n    if n1 > n2:\n      return self.findMedianSortedArrays(nums2, nums1)\n\n    l = 0\n    r = n1\n\n    while l <= r:\n      partition1 = (l + r) // 2\n      partition2 = (n1 + n2 + 1) // 2 - partition1\n      maxLeft1 = -2**31 if partition1 == 0 else nums1[partition1 - 1]\n      maxLeft2 = -2**31 if partition2 == 0 else nums2[partition2 - 1]\n      minRight1 = 2**31 - 1 if partition1 == n1 else nums1[partition1]\n      minRight2 = 2**31 - 1 if partition2 == n2 else nums2[partition2]\n      if maxLeft1 <= minRight2 and maxLeft2 <= minRight1:\n        if (n1 + n2) % 2 == 0:\n          return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) * 0.5\n        else:\n          return max(maxLeft1, maxLeft2)\n      elif maxLeft1 > minRight2:\n        r = partition1 - 1\n      else:\n        l = partition1 + 1\n", "tests": ["def test_findMedianSortedArrays():\n    solution = Solution()\n    nums1 = [1, 3]\n    nums2 = [2]\n    assert abs(solution.findMedianSortedArrays(nums1, nums2) - 2.0) < 0.0001", "def test_findMedianSortedArrays():\n    solution = Solution()\n    assert solution.findMedianSortedArrays([1, 3], [2]) == 2.0"]}
{"task_num": 10, "task_title": "Regular Expression Matching", "func_name": "isMatch", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isMatch(self, s: str, p: str) -> bool:\n    m = len(s)\n    n = len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    def isMatch(i: int, j: int) -> bool:\n      return j >= 0 and p[j] == '.' or s[i] == p[j]\n\n    for j, c in enumerate(p):\n      if c == '*' and dp[0][j - 1]:\n        dp[0][j + 1] = True\n\n    for i in range(m):\n      for j in range(n):\n        if p[j] == '*':\n          noRepeat = dp[i + 1][j - 1]\n          doRepeat = isMatch(i, j - 1) and dp[i][j + 1]\n          dp[i + 1][j + 1] = noRepeat or doRepeat\n        elif isMatch(i, j):\n          dp[i + 1][j + 1] = dp[i][j]\n\n    return dp[m][n]\n", "tests": ["```python\ndef test_isMatch():\n    solution = Solution()\n    assert not solution.isMatch(\"aa\", \"a*\")\n```", "```python\ndef test_isMatch():\n    solution = Solution()\n    assert not solution.isMatch('a', '**')\n```", "def test_isMatch():\n    solution = Solution()\n    assert not solution.isMatch('a', '*')", "```python\ndef test_isMatch():\n    solution = Solution()\n    assert not solution.isMatch(\"a\", \".\")\n```"]}
{"task_num": 15, "task_title": "3Sum", "func_name": "threeSum", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def threeSum(self, nums: List[int]) -> List[List[int]]:\n    if len(nums) < 3:\n      return []\n\n    ans = []\n\n    nums.sort()\n\n    for i in range(len(nums) - 2):\n      if i > 0 and nums[i] == nums[i - 1]:\n        continue\n\n      l = i + 1\n      r = len(nums) - 1\n      while l < r:\n        summ = nums[i] + nums[l] + nums[r]\n        if summ == 0:\n          ans.append((nums[i], nums[l], nums[r]))\n          l += 1\n          r -= 1\n          while nums[l] == nums[l - 1] and l < r:\n            l += 1\n          while nums[r] == nums[r + 1] and l < r:\n            r -= 1\n        elif summ < 0:\n          l += 1\n        else:\n          r -= 1\n\n    return ans\n", "tests": ["def test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([-1, -1, 2, 0]) == [[-1, -1, 2]]", "```python\ndef test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([-1, 0, 1, 2, -1]) == [[-1, -1, 2]]\n```", "def test_threeSum():\n    solution = Solution()\n    nums = [0, -1, 1, -2, 2]\n    assert solution.threeSum(nums) == [[-2, -1, 3], [-2, 0, 2]]", "```python\ndef test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([-1, 0, 1, 2, -1, -4]) == []\n```\nIn this test case, the inner loop never reaches the condition `summ == 0` because `nums[i] + nums[l]` is always negative and thus `summ < 0`. The function returns an empty list as expected."]}
{"task_num": 44, "task_title": "Wildcard Matching", "func_name": "isMatch", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isMatch(self, s: str, p: str) -> bool:\n    m = len(s)\n    n = len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    def isMatch(i: int, j: int) -> bool:\n      return i >= 0 and p[j] == '?' or s[i] == p[j]\n\n    for j, c in enumerate(p):\n      if c == '*':\n        dp[0][j + 1] = dp[0][j]\n\n    for i in range(m):\n      for j in range(n):\n        if p[j] == '*':\n          matchEmpty = dp[i + 1][j]\n          matchSome = dp[i][j + 1]\n          dp[i + 1][j + 1] = matchEmpty or matchSome\n        elif isMatch(i, j):\n          dp[i + 1][j + 1] = dp[i][j]\n\n    return dp[m][n]\n", "tests": ["```python\ndef test_isMatch():\n    solution = Solution()\n    assert not solution.isMatch('aa', 'a')\n```", "def test_isMatch():\n    solution = Solution()\n    assert not solution.isMatch(\"ab\", \"?\")", "def test_isMatch():\n    solution = Solution()\n    assert not solution.isMatch('a', '*')", "```python\ndef test_isMatch():\n    solution = Solution()\n    assert solution.isMatch(\"aa\", \"a*\")\n```"]}
{"task_num": 54, "task_title": "Spiral Matrix", "func_name": "spiralOrder", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n    if not matrix:\n      return []\n\n    m = len(matrix)\n    n = len(matrix[0])\n    ans = []\n    r1 = 0\n    c1 = 0\n    r2 = m - 1\n    c2 = n - 1\n\n    while len(ans) < m * n:\n      j = c1\n      while j <= c2 and len(ans) < m * n:\n        ans.append(matrix[r1][j])\n        j += 1\n      i = r1 + 1\n      while i <= r2 - 1 and len(ans) < m * n:\n        ans.append(matrix[i][c2])\n        i += 1\n      j = c2\n      while j >= c1 and len(ans) < m * n:\n        ans.append(matrix[r2][j])\n        j -= 1\n      i = r2 - 1\n      while i >= r1 + 1 and len(ans) < m * n:\n        ans.append(matrix[i][c1])\n        i -= 1\n      r1 += 1\n      c1 += 1\n      r2 -= 1\n      c2 -= 1\n\n    return ans\n", "tests": ["def test_spiralOrder():\n    solution = Solution()\n    assert solution.spiralOrder([[1,2,3],[4,5,6],[7,8,9]]) == [1,2,3,6,9,8,7,4,5]\n    # Path: Line 26 -> Line 26 -> Line 26 -> Line 30 -> Line 34", "```python\ndef test_spiralOrder():\n    solution = Solution()\n    matrix = [[1, 2], [3, 4]]\n    assert solution.spiralOrder(matrix) == [1, 2, 4, 3]\n```\nThe provided test case contains a 2x2 matrix where the spiral order traversal yields `[1, 2, 4, 3]`. This test covers the target execution path specified in your description.", "```python\ndef test_spiralOrder():\n    solution = Solution()\n    assert solution.spiralOrder([[1,2],[3,4]]) == [1, 2, 4, 3]\n```", "def test_spiralOrder():\n    solution = Solution()\n    assert solution.spiralOrder([[1, 2], [3, 4]]) == [1, 2, 4, 3]"]}
{"task_num": 65, "task_title": "Valid Number", "func_name": "isNumber", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isNumber(self, s: str) -> bool:\n    s = s.strip()\n    if not s:\n      return False\n\n    seenNum = False\n    seenDot = False\n    seenE = False\n\n    for i, c in enumerate(s):\n      if c == '.':\n        if seenDot or seenE:\n          return False\n        seenDot = True\n      elif c == 'e' or c == 'E':\n        if seenE or not seenNum:\n          return False\n        seenE = True\n        seenNum = False\n      elif c in '+-':\n        if i > 0 and s[i - 1] not in 'eE':\n          return False\n        seenNum = False\n      else:\n        if not c.isdigit():\n          return False\n        seenNum = True\n\n    return seenNum\n", "tests": ["def test_isNumber():\n    solution = Solution()\n    assert not solution.isNumber(\"a\")", "```python\ndef test_isNumber():\n    solution = Solution()\n    assert not solution.isNumber('e')\n```", "def test_isNumber():\n    solution = Solution()\n    assert not solution.isNumber('.')"]}
{"task_num": 73, "task_title": "Set Matrix Zeroes", "func_name": "setZeroes", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def setZeroes(self, matrix: List[List[int]]) -> None:\n    m = len(matrix)\n    n = len(matrix[0])\n    shouldFillFirstRow = 0 in matrix[0]\n    shouldFillFirstCol = 0 in list(zip(*matrix))[0]\n\n    for i in range(1, m):\n      for j in range(1, n):\n        if matrix[i][j] == 0:\n          matrix[i][0] = 0\n          matrix[0][j] = 0\n\n    for i in range(1, m):\n      for j in range(1, n):\n        if matrix[i][0] == 0 or matrix[0][j] == 0:\n          matrix[i][j] = 0\n\n    if shouldFillFirstRow:\n      matrix[0] = [0] * n\n\n    if shouldFillFirstCol:\n      for row in matrix:\n        row[0] = 0\n", "tests": ["def test_setZeroes():\n    solution = Solution()\n    matrix = [[1, 0], [2, 3]]\n    solution.setZeroes(matrix)\n    assert matrix == [[0, 0], [2, 0]]", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[0, 1], [2, 0]]\n    solution.setZeroes(matrix)\n    assert matrix == [[0, 0], [0, 0]]", "def test_setZeroes():\n    solution = Solution()\n    matrix = [\n        [0, 1, 2],\n        [3, 4, 5],\n        [6, 7, 8]\n    ]\n    solution.setZeroes(matrix)\n    assert matrix == [[0, 0, 0], [0, 4, 0], [0, 0, 8]]", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[1, 0, 3], [4, 5, 6], [7, 8, 9]]\n    solution.setZeroes(matrix)\n    assert matrix == [[0, 0, 3], [4, 0, 6], [7, 0, 9]]"]}
{"task_num": 97, "task_title": "Interleaving String", "func_name": "isInterleave", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n    m = len(s1)\n    n = len(s2)\n    if m + n != len(s3):\n      return False\n\n    dp=[]\n    for _ in range(m + 1):\n      dp.append([False] * (n + 1))\n    dp[0][0] = True\n\n    for i in range(1, m + 1):\n      dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n\n    for j in range(1, n + 1):\n      dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n\n    return dp[m][n]\n", "tests": ["def test_isInterleave():\n    solution = Solution()\n    assert not solution.isInterleave(\"a\", \"b\", \"ab\")", "def test_isInterleave():\n    solution = Solution()\n    assert not solution.isInterleave(\"\", \"\", \"\")", "def test_isInterleave():\n    solution = Solution()\n    assert not solution.isInterleave(\"a\", \"b\", \"\")"]}
{"task_num": 126, "task_title": "Word Ladder II", "func_name": "findLadders", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Set\n\nclass Solution:\n  def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n    from collections import deque\n    def connected(a: str, b: str) -> bool:\n      k = 0\n      for i in range(len(a)):\n        if a[i] != b[i]:\n          k += 1\n      return k == 1\n\n    if endWord not in wordList:\n      return []\n\n    visited = set([beginWord])\n\n    q = deque([beginWord])\n    nodes = []\n    find = False\n\n    while q and not find:\n      nodes.append(q.copy())\n      n = len(q)\n      for _ in range(n):\n        word = q.popleft()\n        for item in wordList:\n          if item in visited:\n            continue\n          if not connected(word, item):\n            continue\n          if item == endWord:\n            find = True\n            break\n          visited.add(item)\n          q.append(item)\n        if find:\n          break\n\n    if not find:\n      return []\n\n    ans = []\n\n    def backtracking(word, level: int, steps: List[str]):\n      if word == beginWord:\n        ans.append(steps[::-1])\n        return\n      if level < 0:\n        return\n      for item in nodes[level]:\n        if connected(item, word):\n          steps.append(item)\n          backtracking(item, level-1, steps)\n          steps.pop()\n\n    backtracking(endWord, len(nodes)-1, [endWord])\n    return ans\n", "tests": ["def test_findLadders():\n    solution = Solution()\n    assert solution.findLadders(\"hit\", \"cog\", [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"]) == [[\"hit\", \"hot\", \"dot\", \"dog\", \"cog\"]]", "def test_findLadders():\n    solution = Solution()\n    assert solution.findLadders(\"hit\", \"cog\", [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]) == [[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]", "def test_findLadders():\n    solution = Solution()\n    assert solution.findLadders(\"hit\", \"cog\", [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]) == []"]}
{"task_num": 130, "task_title": "Surrounded Regions", "func_name": "solve", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def solve(self, board: List[List[str]]) -> None:\n    if not board:\n      return\n\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(board)\n    n = len(board[0])\n    q = collections.deque()\n\n    for i in range(m):\n      for j in range(n):\n        if i * j == 0 or i == m - 1 or j == n - 1:\n          if board[i][j] == 'O':\n            q.append((i, j))\n            board[i][j] = '*'\n\n    while q:\n      i, j = q.popleft()\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if board[x][y] != 'O':\n          continue\n        q.append((x, y))\n        board[x][y] = '*'\n\n    for row in board:\n      for i, c in enumerate(row):\n        if c == '*':\n          row[i] = 'O'\n        else:\n          row[i] = 'X'\n", "tests": ["def test_solve():\n    board = [\n        ['X', 'O', 'X'],\n        ['O', 'O', 'O'],\n        ['X', 'O', 'X']\n    ]\n    solution = Solution()\n    solution.solve(board)\n    assert board == [['X', 'O', 'X'], ['X', 'X', 'X'], ['X', 'O', 'X']]", "def test_solve():\n    solution = Solution()\n    board = [\n        ['O', 'X', 'O'],\n        ['O', 'O', 'O'],\n        ['X', 'O', 'X']\n    ]\n    solution.solve(board)\n    assert board == [\n        ['X', 'X', 'O'],\n        ['X', 'X', 'X'],\n        ['X', 'O', 'X']\n    ]", "```python\ndef test_solve():\n    solution = Solution()\n    board = [\n        ['O', 'X', 'O'],\n        ['O', 'O', 'O'],\n        ['X', 'O', 'X']\n    ]\n    solution.solve(board)\n    assert board == [\n        ['X', 'X', 'O'],\n        ['X', 'O', 'X'],\n        ['X', 'O', 'X']\n    ]\n```"]}
{"task_num": 132, "task_title": "Palindrome Partitioning II", "func_name": "minCut", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minCut(self, s: str) -> int:\n    n = len(s)\n    isPalindrome=[]\n    for _ in range(n):\n      isPalindrome.append([True] * n)\n    dp = [n] * n\n\n    for l in range(2, n + 1):\n      i = 0\n      for j in range(l - 1, n):\n        isPalindrome[i][j] = s[i] == s[j] and isPalindrome[i + 1][j - 1]\n        i += 1\n\n    for i in range(n):\n      if isPalindrome[0][i]:\n        dp[i] = 0\n        continue\n\n      for j in range(i):\n        if isPalindrome[j + 1][i]:\n          dp[i] = min(dp[i], dp[j] + 1)\n\n    return dp[-1]\n", "tests": ["def test_minCut():\n    solution = Solution()\n    assert solution.minCut(\"abacdx\") == 3", "```python\ndef test_minCut():\n    solution = Solution()\n    assert solution.minCut(\"abcd\") == 2\n```\nThis test case will cover the target execution path in function minCut. The string \"abcd\" is chosen because it requires at least two cuts to make all substrings palindromes (i.e., \"a\", \"b\", \"c\", and \"d\").", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('ab') == 1", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('abcd') == 2"]}
{"task_num": 218, "task_title": "The Skyline Problem", "func_name": "getSkyline", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:\n    n = len(buildings)\n    if n == 0:\n      return []\n    if n == 1:\n      left, right, height = buildings[0]\n      return [[left, height], [right, 0]]\n\n    left = self.getSkyline(buildings[:n // 2])\n    right = self.getSkyline(buildings[n // 2:])\n    return self._merge(left, right)\n\n  def _merge(self, left: List[List[int]], right: List[List[int]]) -> List[List[int]]:\n    ans = []\n    i = 0\n    j = 0\n    leftY = 0\n    rightY = 0\n\n    while i < len(left) and j < len(right):\n      if left[i][0] < right[j][0]:\n        leftY = left[i][1]\n        self._addPoint(ans, left[i][0], max(left[i][1], rightY))\n        i += 1\n      else:\n        rightY = right[j][1]\n        self._addPoint(ans, right[j][0], max(right[j][1], leftY))\n        j += 1\n\n    while i < len(left):\n      self._addPoint(ans, left[i][0], left[i][1])\n      i += 1\n\n    while j < len(right):\n      self._addPoint(ans, right[j][0], right[j][1])\n      j += 1\n\n    return ans\n\n  def _addPoint(self, ans: List[List[int]], x: int, y: int) -> None:\n    if ans and ans[-1][0] == x:\n      ans[-1][1] = y\n      return\n    if ans and ans[-1][1] == y:\n      return\n    ans.append([x, y])\n", "tests": ["def test_getSkyline():\n    solution = Solution()\n    assert solution.getSkyline([[1,2,3],[4,5,6]]) == [[1,3],[2,0],[4,6]]", "def test_getSkyline():\n    solution = Solution()\n    assert solution.getSkyline([[1, 3, 2], [5, 7, 4], [8, 10, 6], [12, 15, 4]]) == [[1, 2], [5, 4], [8, 6], [12, 4]]", "def test_getSkyline():\n    solution = Solution()\n    assert solution.getSkyline([[5, 8, 7], [2, 4, 9]]) == [[2, 9], [5, 7], [8, 0]]", "def test_getSkyline():\n    solution = Solution()\n    assert solution.getSkyline([[2, 4, 3], [5, 7, 3]]) == [[2, 3], [5, 0]]"]}
{"task_num": 227, "task_title": "Basic Calculator II", "func_name": "calculate", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def calculate(self, s: str) -> int:\n    ans = 0\n    prevNum = 0\n    currNum = 0\n    op = '+'\n\n    for i, c in enumerate(s):\n      if c.isdigit():\n        currNum = currNum * 10 + int(c)\n      if not c.isdigit() and c != ' ' or i == len(s) - 1:\n        if op == '+' or op == '-':\n          ans += prevNum\n          prevNum = currNum if op == '+' else -currNum\n        elif op == '*':\n          prevNum = prevNum * currNum\n        elif op == '/':\n          if prevNum < 0:\n            prevNum = math.ceil(prevNum / currNum)\n          else:\n            prevNum = prevNum // currNum\n        op = c\n        currNum = 0\n\n    return ans + prevNum\n", "tests": ["def test_calculate():\n    solution = Solution()\n    assert solution.calculate(\"1+2*3\") == 9", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate(\"5 * 2 + 3 - 4\") == 7", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate(\"1 / 2\") == 0", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate(\"+\") == 0"]}
{"task_num": 289, "task_title": "Game of Life", "func_name": "gameOfLife", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def gameOfLife(self, board: List[List[int]]) -> None:\n    m = len(board)\n    n = len(board[0])\n\n    for i in range(m):\n      for j in range(n):\n        ones = 0\n        for x in range(max(0, i - 1), min(m, i + 2)):\n          for y in range(max(0, j - 1), min(n, j + 2)):\n            ones += board[x][y] & 1\n\n        if board[i][j] == 1 and (ones == 3 or ones == 4):\n          board[i][j] |= 0b10\n\n        if board[i][j] == 0 and ones == 3:\n          board[i][j] |= 0b10\n\n    for i in range(m):\n      for j in range(n):\n        board[i][j] >>= 1\n", "tests": ["def test_gameOfLife():\n    solution = Solution()\n    board = [[1, 0], [0, 1]]\n    solution.gameOfLife(board)\n    assert board == [[2, 1], [1, 2]]", "def test_gameOfLife():\n    solution = Solution()\n    board = [[1]]\n    solution.gameOfLife(board)\n    assert board == [[3]]", "```python\ndef test_gameOfLife():\n    solution = Solution()\n    board = [[1, 0, 0], [0, 0, 1], [0, 0, 0]]\n    solution.gameOfLife(board)\n    assert board == [[1, 0, 0], [0, 1, 1], [0, 0, 0]]\n```", "def test_gameOfLife():\n    solution = Solution()\n    board = [[0, 1], [0, 0]]\n    solution.gameOfLife(board)\n    assert board == [[1, 1], [0, 0]]"]}
{"task_num": 310, "task_title": "Minimum Height Trees", "func_name": "findMinHeightTrees", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\n    if n == 1 or not edges:\n      return [0]\n\n    ans = []\n    graph = collections.defaultdict(set)\n\n    for u, v in edges:\n      graph[u].add(v)\n      graph[v].add(u)\n\n    for label, children in graph.items():\n      if len(children) == 1:\n        ans.append(label)\n\n    while n > 2:\n      n -= len(ans)\n      nextLeaves = []\n      for leaf in ans:\n        u = next(iter(graph[leaf]))\n        graph[u].remove(leaf)\n        if len(graph[u]) == 1:\n          nextLeaves.append(u)\n      ans = nextLeaves\n\n    return ans\n", "tests": ["Here's the requested test case:\n\n```python\ndef test_findMinHeightTrees():\n    solution = Solution()\n    assert solution.findMinHeightTrees(6, [[0, 3], [1, 3], [2, 3], [4, 5]]) == [3]\n```\n\nThis test case covers the target execution path by providing a graph with more than two nodes initially (`n > 2`), and an initial set of leaves (`ans`) that are iterated over twice (`leaf in ans`). The second leaf has only one neighbor left after removal (`len(graph[u]) == 1`), causing the loop to iterate again.", "def test_findMinHeightTrees():\n    solution = Solution()\n    assert solution.findMinHeightTrees(6, [[0,1],[0,2],[2,3],[3,4],[4,5]]) == [3, 4]", "Here's the required test case:\n\n```python\ndef test_findMinHeightTrees():\n    solution = Solution()\n    assert solution.findMinHeightTrees(\n        n=6,\n        edges=[[0, 1], [0, 2], [2, 3], [3, 4], [4, 5]]\n    ) == [0, 3]\n```", "def test_findMinHeightTrees():\n    solution = Solution()\n    assert solution.findMinHeightTrees(6, [[0,1], [0,2], [2,3], [1,4], [4,5]]) == [1, 2]"]}
{"task_num": 327, "task_title": "Count of Range Sum", "func_name": "countRangeSum", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countRangeSum(self, nums: List[int], lower: int, upper: int) -> int:\n    n = len(nums)\n    self.ans = 0\n    prefix = [0] + list(itertools.accumulate(nums))\n\n    self._mergeSort(prefix, 0, n, lower, upper)\n    return self.ans\n\n  def _mergeSort(self, prefix: List[int], l: int, r: int, lower: int, upper: int) -> None:\n    if l >= r:\n      return\n\n    m = (l + r) // 2\n    self._mergeSort(prefix, l, m, lower, upper)\n    self._mergeSort(prefix, m + 1, r, lower, upper)\n    self._merge(prefix, l, m, r, lower, upper)\n\n  def _merge(self, prefix: List[int], l: int, m: int, r: int, lower: int, upper: int) -> None:\n    lo = m + 1\n    hi = m + 1\n\n    for i in range(l, m + 1):\n      while lo <= r and prefix[lo] - prefix[i] < lower:\n        lo += 1\n      while hi <= r and prefix[hi] - prefix[i] <= upper:\n        hi += 1\n      self.ans += hi - lo\n\n    sorted = [0] * (r - l + 1)\n    k = 0\n    i = l\n    j = m + 1\n\n    while i <= m and j <= r:\n      if prefix[i] < prefix[j]:\n        sorted[k] = prefix[i]\n        k += 1\n        i += 1\n      else:\n        sorted[k] = prefix[j]\n        k += 1\n        j += 1\n\n    while i <= m:\n      sorted[k] = prefix[i]\n      k += 1\n      i += 1\n\n    while j <= r:\n      sorted[k] = prefix[j]\n      k += 1\n      j += 1\n\n    prefix[l:l + len(sorted)] = sorted\n", "tests": ["def test_countRangeSum():\n    solution = Solution()\n    nums = [20,-5,-7,6]\n    lower = -4\n    upper = 9\n    assert solution.countRangeSum(nums, lower, upper) == 3", "def test_countRangeSum():\n    solution = Solution()\n    nums = [1, 2, 3]\n    lower = 1\n    upper = 3\n    assert solution.countRangeSum(nums, lower, upper) == 0"]}
{"task_num": 335, "task_title": "Self Crossing", "func_name": "isSelfCrossing", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isSelfCrossing(self, x: List[int]) -> bool:\n    if len(x) <= 3:\n      return False\n\n    for i in range(3, len(x)):\n      if x[i - 2] <= x[i] and x[i - 1] <= x[i - 3]:\n        return True\n      if i >= 4 and x[i - 1] == x[i - 3] and x[i - 2] <= x[i] + x[i - 4]:\n        return True\n      if i >= 5 and x[i - 4] <= x[i - 2] and x[i - 2] <= x[i] + x[i - 4] and x[i - 1] <= x[i - 3] and x[i - 3] <= x[i - 1] + x[i - 5]:\n        return True\n\n    return False\n", "tests": ["```python\ndef test_isSelfCrossing():\n    solution = Solution()\n    assert not solution.isSelfCrossing([2, 1, 1, 6])\n```", "def test_isSelfCrossing():\n    solution = Solution()\n    assert not solution.isSelfCrossing([1, 2, 3, 4])"]}
{"task_num": 336, "task_title": "Palindrome Pairs", "func_name": "palindromePairs", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def palindromePairs(self, words: List[str]) -> List[List[int]]:\n    ans = []\n    dict = {word[::-1]: i for i, word in enumerate(words)}\n\n    for i, word in enumerate(words):\n      if \"\" in dict and dict[\"\"] != i and word == word[::-1]:\n        ans.append([i, dict[\"\"]])\n\n      for j in range(1, len(word) + 1):\n        l = word[:j]\n        r = word[j:]\n        if l in dict and dict[l] != i and r == r[::-1]:\n          ans.append([i, dict[l]])\n        if r in dict and dict[r] != i and l == l[::-1]:\n          ans.append([dict[r], i])\n\n    return ans\n", "tests": ["def test_palindromePairs():\n    solution = Solution()\n    words = [\"abcd\", \"dcba\", \"ll\"]\n    assert solution.palindromePairs(words) == [[0, 1]]", "def test_palindromePairs():\n    solution = Solution()\n    words = [\"abcd\", \"dcba\", \"ll\", \"ei\"]\n    assert solution.palindromePairs(words) == [[0, 1], [1, 0]]", "def test_palindromePairs():\n    solution = Solution()\n    words = [\"abcd\", \"dcba\", \"\", \"dcba\"]\n    assert solution.palindromePairs(words) == [[0, 1], [2, 3]]"]}
{"task_num": 391, "task_title": "Perfect Rectangle", "func_name": "isRectangleCover", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Set\n\nclass Solution:\n  def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\n    area = 0\n    x1 = math.inf\n    y1 = math.inf\n    x2 = -math.inf\n    y2 = -math.inf\n    corners: Set[Tuple[int, int]] = set()\n\n    for x, y, a, b in rectangles:\n      area += (a - x) * (b - y)\n      x1 = min(x1, x)\n      y1 = min(y1, y)\n      x2 = max(x2, a)\n      y2 = max(y2, b)\n\n      for point in [(x, y), (x, b), (a, y), (a, b)]:\n        if point in corners:\n          corners.remove(point)\n        else:\n          corners.add(point)\n\n    if len(corners) != 4:\n      return False\n    if (x1, y1) not in corners or (x1, y2) not in corners or (x2, y1) not in corners or (x2, y2) not in corners:\n      return False\n    return area == (x2 - x1) * (y2 - y1)\n", "tests": ["def test_isRectangleCover():\n    solution = Solution()\n    assert solution.isRectangleCover([[1, 1, 4, 3]]) == False", "def test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[0, 0, 1, 1], [0.5, 0.5, 1, 1]]\n    assert not solution.isRectangleCover(rectangles)", "def test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[1, 1, 2, 2], [2, 2, 3, 3]]\n    assert not solution.isRectangleCover(rectangles)", "def test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[0, 0, 1, 1], [1, 0, 2, 1]]\n    assert not solution.isRectangleCover(rectangles)", "def test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[0, 0, 2, 1], [1, 1, 3, 2]]\n    assert all(not (point in solution.corners) for _, point in zip(range(4), itertools.product(*rectangles)))"]}
{"task_num": 402, "task_title": "Remove K Digits", "func_name": "removeKdigits", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def removeKdigits(self, num: str, k: int) -> str:\n    if len(num) == k:\n      return '0'\n\n    ans = []\n    stack = []\n\n    for i, digit in enumerate(num):\n      while k > 0 and stack and stack[-1] > digit:\n        stack.pop()\n        k -= 1\n      stack.append(digit)\n\n    for _ in range(k):\n      stack.pop()\n\n    for c in stack:\n      if c == '0' and not ans:\n        continue\n      ans.append(c)\n\n    return ''.join(ans) if ans else '0'\n", "tests": ["def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits(\"10203\", 2) == \"120\"", "def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits(\"10200\", 3) == \"100\"", "def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits('123', 3) == '0'", "def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits(\"1432219\", 3) == \"1219\""]}
{"task_num": 407, "task_title": "Trapping Rain Water II", "func_name": "trapRainWater", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def trapRainWater(self, heightMap: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(heightMap)\n    n = len(heightMap[0])\n    ans = 0\n    minHeap = []\n    seen = set()\n\n    for i in range(m):\n      heapq.heappush(minHeap, (heightMap[i][0], i, 0))\n      heapq.heappush(minHeap, (heightMap[i][n - 1], i, n - 1))\n      seen.add((i, 0))\n      seen.add((i, n - 1))\n\n    for j in range(1, n - 1):\n      heapq.heappush(minHeap, (heightMap[0][j], 0, j))\n      heapq.heappush(minHeap, (heightMap[m - 1][j], m - 1, j))\n      seen.add((0, j))\n      seen.add((m - 1, j))\n\n    while minHeap:\n      h, i, j = heapq.heappop(minHeap)\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if (x, y) in seen:\n          continue\n        if heightMap[x][y] < h:\n          ans += h - heightMap[x][y]\n          heapq.heappush(minHeap, (h, x, y))\n        else:\n          heapq.heappush(minHeap, (heightMap[x][y], x, y))\n        seen.add((x, y))\n\n    return ans\n", "tests": ["def test_trapRainWater():\n    solution = Solution()\n    heightMap = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    assert solution.trapRainWater(heightMap) == 0", "def test_trapRainWater():\n    solution = Solution()\n    heightMap = [[1, 4, 3], [3, 2, 1], [5, 0, 1]]\n    assert solution.trapRainWater(heightMap) == 4", "def test_trapRainWater():\n    solution = Solution()\n    heightMap = [[1, 2, 3], [4, 0, 5], [6, 7, 8]]\n    assert solution.trapRainWater(heightMap) == 1", "def test_trapRainWater():\n    solution = Solution()\n    assert solution.trapRainWater([[0,1,0],[1,0,1],[0,1,0]]) == 2"]}
{"task_num": 417, "task_title": "Pacific Atlantic Water Flow", "func_name": "pacificAtlantic", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(heights)\n    n = len(heights[0])\n    qP = collections.deque()\n    qA = collections.deque()\n    seenP = [[False] * n for _ in range(m)]\n    seenA = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n      qP.append((i, 0))\n      qA.append((i, n - 1))\n      seenP[i][0] = True\n      seenA[i][n - 1] = True\n\n    for j in range(n):\n      qP.append((0, j))\n      qA.append((m - 1, j))\n      seenP[0][j] = True\n      seenA[m - 1][j] = True\n\n    def bfs(q: collections.deque, seen: List[List[bool]]):\n      while q:\n        i, j = q.popleft()\n        h = heights[i][j]\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if seen[x][y] or heights[x][y] < h:\n            continue\n          q.append((x, y))\n          seen[x][y] = True\n\n    bfs(qP, seenP)\n    bfs(qA, seenA)\n\n    res=[]\n    for i in range(m):\n      for j in range(n):\n        if seenP[i][j] and seenA[i][j]:\n          res.append([i, j])\n    return res\n", "tests": ["def test_pacificAtlantic():\n    solution = Solution()\n    heights = [[1, 2, 3], [4, 5, 6]]\n    assert solution.pacificAtlantic(heights) == [[0, 0], [0, 1]]", "def test_pacific_atlantic():\n    solution = Solution()\n    heights = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    assert solution.pacificAtlantic(heights) == [[0, 0]]", "```python\ndef test_pacificAtlantic():\n    solution = Solution()\n    assert solution.pacificAtlantic([[1,2],[3,4]]) == [[0, 0], [0, 1]]\n```", "def test_pacificAtlantic():\n    solution = Solution()\n    heights = [[1,2,3],[3,4,5],[6,7,8]]\n    assert solution.pacificAtlantic(heights) == [[0, 0], [0, 1]]"]}
{"task_num": 420, "task_title": "Strong Password Checker", "func_name": "strongPasswordChecker", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def strongPasswordChecker(self, password: str) -> int:\n    n = len(password)\n    missing = self._getMissing(password)\n    replaces = 0\n    oneSeq = 0\n    twoSeq = 0\n\n    i = 2\n    while i < n:\n      if password[i] == password[i - 1] and password[i - 1] == password[i - 2]:\n        length = 2\n        while i < n and password[i] == password[i - 1]:\n          length += 1\n          i += 1\n        replaces += length // 3\n        if length % 3 == 0:\n          oneSeq += 1\n        if length % 3 == 1:\n          twoSeq += 1\n      else:\n        i += 1\n\n    if n < 6:\n      return max(6 - n, missing)\n    if n <= 20:\n      return max(replaces, missing)\n\n    deletes = n - 20\n    replaces -= min(oneSeq, deletes)\n    replaces -= min(max(deletes - oneSeq, 0), twoSeq * 2) // 2\n    replaces -= max(deletes - oneSeq - twoSeq * 2, 0) // 3\n    return deletes + max(replaces, missing)\n\n  def _getMissing(self, password: str) -> int:\n    return 3 - any(c.isupper() for c in password) - any(c.islower() for c in password) - any(c.isdigit() for c in password)\n", "tests": ["def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker(\"a\") == 5", "def test_strongPasswordChecker():\n    solution = Solution()\n    assert(solution.strongPasswordChecker(\"abc\") == 0)", "def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker(\"a\") == 5"]}
{"task_num": 423, "task_title": "Reconstruct Original Digits from English", "func_name": "originalDigits", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def originalDigits(self, s: str) -> str:\n    count = [0] * 10\n\n    for c in s:\n      if c == 'z':\n        count[0] += 1\n      if c == 'o':\n        count[1] += 1\n      if c == 'w':\n        count[2] += 1\n      if c == 'h':\n        count[3] += 1\n      if c == 'u':\n        count[4] += 1\n      if c == 'f':\n        count[5] += 1\n      if c == 'x':\n        count[6] += 1\n      if c == 's':\n        count[7] += 1\n      if c == 'g':\n        count[8] += 1\n      if c == 'i':\n        count[9] += 1\n\n    count[1] -= count[0] + count[2] + count[4]\n    count[3] -= count[8]\n    count[5] -= count[4]\n    count[7] -= count[6]\n    count[9] -= count[5] + count[6] + count[8]\n\n    return ''.join(chr(i + ord('0')) for i, c in enumerate(count) for j in range(c))\n", "tests": ["def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits(\"fou\") == \"024\"", "def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits('ooz') == '021'", "def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits(\"i\") == \"9\"", "def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits(\"woow\") == \"022\""]}
{"task_num": 457, "task_title": "Circular Array Loop", "func_name": "circularArrayLoop", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def circularArrayLoop(self, nums: List[int]) -> bool:\n    def advance(i: int) -> int:\n      return (i + nums[i]) % len(nums)\n\n    if len(nums) < 2:\n      return False\n\n    for i, num in enumerate(nums):\n      if num == 0:\n        continue\n\n      slow = i\n      fast = advance(slow)\n      while num * nums[fast] > 0 and num * nums[advance(fast)] > 0:\n        if slow == fast:\n          if slow == advance(slow):\n            break\n          return True\n        slow = advance(slow)\n        fast = advance(advance(fast))\n\n      slow = i\n      sign = num\n      while sign * nums[slow] > 0:\n        next = advance(slow)\n        nums[slow] = 0\n        slow = next\n\n    return False\n", "tests": ["def test_circularArrayLoop():\n    solution = Solution()\n    assert not solution.circularArrayLoop([2, -1, 1, 2, 2])", "def test_circularArrayLoop():\n    solution = Solution()\n    assert not solution.circularArrayLoop([2,-1,1,2,2])", "def test_circularArrayLoop():\n    solution = Solution()\n    assert not solution.circularArrayLoop([1, -1])", "Here's the Python function for testing the given execution path:\n\n```python\ndef test_circularArrayLoop():\n    solution = Solution()\n    nums = [2, -1, 1, 2, 2]\n    assert solution.circularArrayLoop(nums) == True\n```\n\nThis test case uses the input `[2, -1, 1, 2, 2]`, which creates a cycle with indices `0 -> 1 -> 4 -> 3 -> 0`. The function should return `True` for this input according to the target execution path."]}
{"task_num": 524, "task_title": "Longest Word in Dictionary through Deleting", "func_name": "findLongestWord", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findLongestWord(self, s: str, d: List[str]) -> str:\n    ans = ''\n\n    for word in d:\n      i = 0\n      for c in s:\n        if i < len(word) and c == word[i]:\n          i += 1\n      if i == len(word):\n        if len(word) > len(ans) or len(word) == len(ans) and word < ans:\n          ans = word\n\n    return ans\n", "tests": ["def test_findLongestWord():\n    solution = Solution()\n    assert solution.findLongestWord(\"abcde\", [\"abc\", \"bcd\", \"abcd\"]) == \"abc\"", "def test_findLongestWord():\n    solution = Solution()\n    assert solution.findLongestWord(\"abcd\", [\"dcba\", \"bad\", \"dca\", \"acd\"]) == \"dcba\"", "def test_findLongestWord():\n    solution = Solution()\n    assert solution.findLongestWord(\"abpcplea\", [\"ale\",\"apple\",\"monkey\",\"plea\"]) == \"apple\"", "def test_findLongestWord():\n    solution = Solution()\n    assert solution.findLongestWord(\"abcd\", [\"abc\"]) == \"abc\""]}
{"task_num": 542, "task_title": "01 Matrix", "func_name": "updateMatrix", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(mat)\n    n = len(mat[0])\n    q = collections.deque()\n    seen = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j] == 0:\n          q.append((i, j))\n          seen[i][j] = True\n\n    while q:\n      i, j = q.popleft()\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if seen[x][y]:\n          continue\n        mat[x][y] = mat[i][j] + 1\n        q.append((x, y))\n        seen[x][y] = True\n\n    return mat\n", "tests": ["def test_updateMatrix():\n    solution = Solution()\n    mat = [[1,0,1],[1,1,0],[1,1,1]]\n    assert solution.updateMatrix(mat) == [[2, 0, 1], [2, 1, 0], [2, 1, 1]]", "```python\ndef test_updateMatrix():\n    solution = Solution()\n    mat = [[0, 0], [0, 1]]\n    solution.updateMatrix(mat)\n```", "def test_updateMatrix():\n    solution = Solution()\n    mat = [[1, 0], [0, 1]]\n    assert solution.updateMatrix(mat) == [[0, 1], [2, 1]]", "def test_updateMatrix():\n    solution = Solution()\n    mat = [\n        [0, 0],\n        [1, 1]\n    ]\n    solution.updateMatrix(mat)\n    assert mat == [[0, 1], [2, 3]]"]}
{"task_num": 547, "task_title": "Number of Provinces", "func_name": "findCircleNum", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    self.count -= 1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findCircleNum(self, isConnected: List[List[int]]) -> int:\n    n = len(isConnected)\n    uf = UnionFind(n)\n\n    for i in range(n):\n      for j in range(i, n):\n        if isConnected[i][j] == 1:\n          uf.unionByRank(i, j)\n\n    return uf.count\n", "tests": ["def test_findCircleNum():\n    solution = Solution()\n    assert solution.findCircleNum([[0, 1], [1, 0]]) == 2", "```python\ndef test_findCircleNum():\n    solution = Solution()\n    assert solution.findCircleNum([[1,0],[0,1]]) == 2\n```", "def test_findCircleNum():\n    solution = Solution()\n    assert solution.findCircleNum([[1] * 2 for _ in range(2)]) == 0", "def test_findCircleNum():\n    solution = Solution()\n    assert solution.findCircleNum([[1]]) == 0"]}
{"task_num": 581, "task_title": "Shortest Unsorted Continuous Subarray", "func_name": "findUnsortedSubarray", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findUnsortedSubarray(self, nums: List[int]) -> int:\n    mini = math.inf\n    maxi = -math.inf\n    flag = False\n\n    for i in range(1, len(nums)):\n      if nums[i] < nums[i - 1]:\n        flag = True\n      if flag:\n        mini = min(mini, nums[i])\n\n    flag = False\n\n    for i in reversed(range(len(nums) - 1)):\n      if nums[i] > nums[i + 1]:\n        flag = True\n      if flag:\n        maxi = max(maxi, nums[i])\n\n    for l in range(len(nums)):\n      if nums[l] > mini:\n        break\n\n    for r, num in reversed(list(enumerate(nums))):\n      if num < maxi:\n        break\n\n    return 0 if l >= r else r - l + 1\n", "tests": ["def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([3,2,6,5,7,8,9,4,1]) == 6", "def test_findUnsortedSubarray():\n    solution = Solution()\n    nums = [2, 6, 4, 8, 10, 9, 15]\n    assert solution.findUnsortedSubarray(nums) == 5", "def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([2, 6, 4, 8, 10, 9]) == 5", "def test_findUnsortedSubarray():\n    solution = Solution()\n    nums = [2, 6, 4, 8, 10, 9, 15]\n    assert solution.findUnsortedSubarray(nums) == 5", "def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([2, 6, 4, 8, 10, 9]) == 5"]}
{"task_num": 591, "task_title": "Tag Validator", "func_name": "isValid", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isValid(self, code: str) -> bool:\n    if code[0] != '<' or code[-1] != '>':\n      return False\n\n    containsTag = False\n    stack = []\n\n    def isValidCdata(s: str) -> bool:\n      return s.find('[CDATA[') == 0\n\n    def isValidTagName(tagName: str, isEndTag: bool) -> bool:\n      nonlocal containsTag\n      if not tagName or len(tagName) > 9:\n        return False\n      if any(not c.isupper() for c in tagName):\n        return False\n\n      if isEndTag:\n        return stack and stack.pop() == tagName\n\n      containsTag = True\n      stack.append(tagName)\n      return True\n\n    i = 0\n    while i < len(code):\n      if not stack and containsTag:\n        return False\n      if code[i] == '<':\n        if stack and code[i + 1] == '!':\n          closeIndex = code.find(']]>', i + 2)\n          if closeIndex == -1 or not isValidCdata(code[i + 2:closeIndex]):\n            return False\n        elif code[i + 1] == '/':\n          closeIndex = code.find('>', i + 2)\n          if closeIndex == -1 or not isValidTagName(code[i + 2:closeIndex], True):\n            return False\n        else:\n          closeIndex = code.find('>', i + 1)\n          if closeIndex == -1 or not isValidTagName(code[i + 1:closeIndex], False):\n            return False\n        i = closeIndex\n      i += 1\n\n    return not stack and containsTag\n", "tests": ["def test_isValid():\n    solution = Solution()\n    assert not solution.isValid(\"<><>\")", "def test_isValid():\n    solution = Solution()\n    assert not solution.isValid(\"<TAG>\")", "def test_isValid():\n    solution = Solution()\n    assert not solution.isValid(\"<!CDATA[<tag>]]></tag>\")"]}
{"task_num": 648, "task_title": "Replace Words", "func_name": "replaceWords", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def __init__(self):\n    self.root = {}\n\n  def insert(self, word: str) -> None:\n    node = self.root\n    for c in word:\n      if c not in node:\n        node[c] = {}\n      node = node[c]\n    node['word'] = word\n\n  def search(self, word: str) -> str:\n    node = self.root\n    for c in word:\n      if 'word' in node:\n        return node['word']\n      if c not in node:\n        return word\n      node = node[c]\n    return word\n\n  def replaceWords(self, dictionary: List[str], sentence: str) -> str:\n    for word in dictionary:\n      self.insert(word)\n\n    words = sentence.split(' ')\n    return ' '.join([self.search(word) for word in words])\n", "tests": ["def test_replaceWords():\n    solution = Solution()\n    assert solution.replaceWords([\"cat\", \"dog\", \"dogs\"], \"The cats and dogs are playing\") == \"The cats and cat are playing\"", "def test_replaceWords():\n    solution = Solution()\n    dictionary = [\"good\", \"better\"]\n    sentence = \"better\"\n    assert solution.replaceWords(dictionary, sentence) == \"good\"", "```python\ndef test_replaceWords():\n    solution = Solution()\n    solution.insert(\"the\")\n    assert solution.replaceWords([\"the\", \"then\"], \"the then\") == \"the the\"\n```\nThis test case covers the target execution path by first inserting a root word (\"the\") and then calling `replaceWords` with a sentence that contains this root followed by another word. The expected output is \"the the\".", "def test_replaceWords():\n    solution = Solution()\n    dictionary = [\"the\", \"quick\"]\n    sentence = \"the quick the\"\n    assert solution.replaceWords(dictionary, sentence) == \"the quick\""]}
{"task_num": 673, "task_title": "Number of Longest Increasing Subsequence", "func_name": "findNumberOfLIS", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findNumberOfLIS(self, nums: List[int]) -> int:\n    ans = 0\n    maxLength = 0\n    length = [1] * len(nums)\n    count = [1] * len(nums)\n\n    for i, num in enumerate(nums):\n      for j in range(i):\n        if nums[j] < num:\n          if length[i] < length[j] + 1:\n            length[i] = length[j] + 1\n            count[i] = count[j]\n          elif length[i] == length[j] + 1:\n            count[i] += count[j]\n\n    for i, l in enumerate(length):\n      if l > maxLength:\n        maxLength = l\n        ans = count[i]\n      elif l == maxLength:\n        ans += count[i]\n\n    return ans\n", "tests": ["def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([3, 4, 6, 5]) == 2", "```python\ndef test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([3,4,-1,0,6,2,3]) == 2\n```\nThe input `[3,4,-1,0,6,2,3]` will traverse the specified execution path in `findNumberOfLIS`.", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4", "def test_findNumberOfLIS():\n    solution = Solution()\n    nums = [3,4,-1,0,6,2,3]\n    assert solution.findNumberOfLIS(nums) == 4"]}
{"task_num": 684, "task_title": "Redundant Connection", "func_name": "findRedundantConnection", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n    uf = UnionFind(len(edges) + 1)\n\n    for edge in edges:\n      u, v = edge\n      if not uf.unionByRank(u, v):\n        return edge\n", "tests": ["def test_findRedundantConnection():\n    solution = Solution()\n    assert solution.findRedundantConnection([[1,2],[3,4],[5,6],[7,8],[9,10],[1,5]]) == [1, 5]", "def test_findRedundantConnection():\n    solution = Solution()\n    edges = [[1, 2], [2, 3], [3, 4], [1, 4], [1, 5]]\n    assert solution.findRedundantConnection(edges) == [1, 4]", "def test_findRedundantConnection():\n    solution = Solution()\n    edges = [[1,2],[2,3],[3,4],[1,5]]\n    assert solution.findRedundantConnection(edges) == [1,5]"]}
{"task_num": 685, "task_title": "Redundant Connection II", "func_name": "findRedundantDirectedConnection", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\n    ids = [0] * (len(edges) + 1)\n    nodeWithTwoParents = 0\n\n    for _, v in edges:\n      ids[v] += 1\n      if ids[v] == 2:\n        nodeWithTwoParents = v\n\n    def findRedundantDirectedConnection(skippedEdgeIndex: int) -> List[int]:\n      uf = UnionFind(len(edges) + 1)\n\n      for i, edge in enumerate(edges):\n        if i == skippedEdgeIndex:\n          continue\n        if not uf.unionByRank(edge[0], edge[1]):\n          return edge\n\n      return []\n\n    if nodeWithTwoParents == 0:\n      return findRedundantDirectedConnection(-1)\n\n    for i in reversed(range(len(edges))):\n      _, v = edges[i]\n      if v == nodeWithTwoParents:\n        if not findRedundantDirectedConnection(i):\n          return edges[i]\n", "tests": ["def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1,2],[2,3],[3,4],[4,5],[1,5]]\n    assert solution.findRedundantDirectedConnection(edges) == [1, 5]", "def test_findRedundantDirectedConnection():\n    edges = [[1,2],[1,3],[2,3]]\n    solution = Solution()\n    assert solution.findRedundantDirectedConnection(edges) == [1, 2]", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1,2],[1,3],[2,3]]\n    assert solution.findRedundantDirectedConnection(edges) == [1, 3]", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1,2],[2,3],[3,4],[4,1],[1,5]]\n    assert solution.findRedundantDirectedConnection(edges) == [1, 5]"]}
{"task_num": 688, "task_title": "Knight Probability in Chessboard", "func_name": "knightProbability", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\n    dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n    dp = [[0] * n for _ in range(n)]\n    dp[row][column] = 1.0\n\n    for _ in range(k):\n      newDp = [[0] * n for _ in range(n)]\n      for i in range(n):\n        for j in range(n):\n          for dx, dy in dirs:\n            x = i + dx\n            y = j + dy\n            if 0 <= x < n and 0 <= y < n:\n              newDp[i][j] += dp[x][y]\n      dp = newDp\n\n    return sum(map(sum, dp)) / 8**k\n", "tests": ["```python\ndef test_knightProbability():\n    solution = Solution()\n    assert solution.knightProbability(3, 4, 0, 1) == pytest.approx(0.265625, abs=1e-5)\n```", "def test_knightProbability():\n    solution = Solution()\n    assert abs(solution.knightProbability(3, 2, 0, 0) - 0.5789473684210425) < 1e-8", "def test_knightProbability():\n    solution = Solution()\n    assert solution.knightProbability(3, 2, 1, 1) == pytest.approx(0.45833333333333336)"]}
{"task_num": 689, "task_title": "Maximum Sum of 3 Non-Overlapping Subarrays", "func_name": "maxSumOfThreeSubarrays", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:\n    n = len(nums) - k + 1\n    sums = [0] * n\n    l = [0] * n\n    r = [0] * n\n\n    summ = 0\n    for i, num in enumerate(nums):\n      summ += num\n      if i >= k:\n        summ -= nums[i - k]\n      if i >= k - 1:\n        sums[i - k + 1] = summ\n\n    maxIndex = 0\n    for i in range(n):\n      if sums[i] > sums[maxIndex]:\n        maxIndex = i\n      l[i] = maxIndex\n\n    maxIndex = n - 1\n    for i in range(n - 1, -1, -1):\n      if sums[i] >= sums[maxIndex]:\n        maxIndex = i\n      r[i] = maxIndex\n\n    ans = [-1, -1, -1]\n\n    for i in range(k, n - k):\n      if ans[0] == -1 or sums[ans[0]] + sums[ans[1]] + sums[ans[2]] < sums[l[i - k]] + sums[i] + sums[r[i + k]]:\n        ans[0] = l[i - k]\n        ans[1] = i\n        ans[2] = r[i + k]\n\n    return ans\n", "tests": ["```python\ndef test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([1]*99 + [2]*3, 3) == [-1] * 3\n\ntest_maxSumOfThreeSubarrays()\n```", "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    nums = [1,2,3,7,5,6,4,8]\n    k = 3\n    assert solution.maxSumOfThreeSubarrays(nums, k) == [0, 3, 6]", "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    nums = [1, 2, 3, 4, 5, 6]\n    k = 2\n    assert solution.maxSumOfThreeSubarrays(nums, k) == [0, 2, 4]", "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    nums = [3, 4, 5, 2, 10, 6]\n    k = 3\n    assert solution.maxSumOfThreeSubarrays(nums, k) == [0, 1, 4]"]}
{"task_num": 691, "task_title": "Stickers to Spell Word", "func_name": "minStickers", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minStickers(self, stickers: List[str], target: str) -> int:\n    maxMask = 1 << len(target)\n    dp = [math.inf] * maxMask\n    dp[0] = 0\n\n    for mask in range(maxMask):\n      if dp[mask] == math.inf:\n        continue\n      for sticker in stickers:\n        superMask = mask\n        for c in sticker:\n          for i, t in enumerate(target):\n            if c == t and not (superMask >> i & 1):\n              superMask |= 1 << i\n              break\n        dp[superMask] = min(dp[superMask], dp[mask] + 1)\n\n    return -1 if dp[-1] == math.inf else dp[-1]\n", "tests": ["def test_minStickers():\n    solution = Solution()\n    stickers = [\"abc\", \"de\"]\n    target = \"abcd\"\n    assert solution.minStickers(stickers, target) == 2", "def test_minStickers():\n    stickers = ['abc', 'de']\n    target = 'abcde'\n    solution = Solution()\n    assert solution.minStickers(stickers, target) == 2", "def test_minStickers():\n    solution = Solution()\n    assert solution.minStickers([\"abc\", \"de\"], \"\") == -1"]}
{"task_num": 722, "task_title": "Remove Comments", "func_name": "removeComments", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def removeComments(self, source: List[str]) -> List[str]:\n    ans = []\n    commenting = False\n    modified = ''\n\n    for line in source:\n      i = 0\n      while i < len(line):\n        if i + 1 == len(line):\n          if not commenting:\n            modified += line[i]\n          i += 1\n          break\n        twoChars = line[i:i + 2]\n        if twoChars == '/*' and not commenting:\n          commenting = True\n          i += 2\n        elif twoChars == '*/' and commenting:\n          commenting = False\n          i += 2\n        elif twoChars == '//':\n          if not commenting:\n            break\n          else:\n            i += 2\n        else:\n          if not commenting:\n            modified += line[i]\n          i += 1\n      if modified and not commenting:\n        ans.append(modified)\n        modified = ''\n\n    return ans\n", "tests": ["def test_removeComments():\n    solution = Solution()\n    assert solution.removeComments([\"int main()\", \"/*\", \"*/\", \"/*\", \"// comment\", \"*/\"]) == [\"int main()\", \"\", \"\"]\n    assert solution.removeComments([\"int main()\", \"{}\"]", "def test_removeComments():\n    solution = Solution()\n    source = [\"1\", \"/*2\", \"*/\", \"3\"]\n    assert solution.removeComments(source) == [\"1\", \"\", \"3\"]", "def test_removeComments():\n    solution = Solution()\n    source = [\"/*\", \"string\", \"s = \", \"*/\"]\n    assert solution.removeComments(source) == [\"string s = \"]"]}
{"task_num": 730, "task_title": "Count Different Palindromic Subsequences", "func_name": "countPalindromicSubsequences", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countPalindromicSubsequences(self, s: str) -> int:\n    kMod = 1_000_000_007\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n      dp[i][i] = 1\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        if s[i] == s[j]:\n          lo = i + 1\n          hi = j - 1\n          while lo <= hi and s[lo] != s[i]:\n            lo += 1\n          while lo <= hi and s[hi] != s[i]:\n            hi -= 1\n          if lo > hi:\n            dp[i][j] = dp[i + 1][j - 1] * 2 + 2\n          elif lo == hi:\n            dp[i][j] = dp[i + 1][j - 1] * 2 + 1\n          else:\n            dp[i][j] = dp[i + 1][j - 1] * 2 - dp[lo + 1][hi - 1]\n        else:\n          dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1]\n        dp[i][j] = (dp[i][j] + kMod) % kMod\n\n    return dp[0][n - 1]\n", "tests": ["```python\ndef test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('a') == 1\n```\nThis test case will cover the target execution path and check if the function returns the correct result for a single character string 'a', where there is only one non-empty palindromic subsequence, which is the string itself.", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences(\"abcd\") == 6", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences(\"a\") == 1", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences(\"abba\") == 6"]}
{"task_num": 735, "task_title": "Asteroid Collision", "func_name": "asteroidCollision", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def asteroidCollision(self, asteroids: List[int]) -> List[int]:\n    stack = []\n\n    for a in asteroids:\n      if a > 0:\n        stack.append(a)\n      else:\n        while stack and stack[-1] > 0 and stack[-1] < -a:\n          stack.pop()\n        if not stack or stack[-1] < 0:\n          stack.append(a)\n        elif stack[-1] == -a:\n          stack.pop()\n        else:\n          pass\n\n    return stack\n", "tests": ["def test_asteroidCollision():\n    solution = Solution()\n    assert solution.asteroidCollision([-5, 5]) == [-5]", "def test_asteroidCollision():\n    solution = Solution()\n    asteroids = [5, -5, 5]\n    assert solution.asteroidCollision(asteroids) == [-5]", "def test_asteroidCollision():\n    solution = Solution()\n    assert solution.asteroidCollision([5, 10, -5]) == [5, 10]", "def test_asteroidCollision():\n    solution = Solution()\n    assert solution.asteroidCollision([5, 10, -5]) == [10]\n    assert solution.asteroidCollision([]) == []\n    assert solution.asteroidCollision([-5, 10]) == [-5]"]}
{"task_num": 743, "task_title": "Network Delay Time", "func_name": "networkDelayTime", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in times:\n      graph[u - 1].append((v - 1, w))\n\n    return self._dijkstra(graph, k - 1)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int) -> int:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    maxDist = max(dist)\n    return maxDist if maxDist != math.inf else -1\n", "tests": ["def test_networkDelayTime():\n    solution = Solution()\n    assert solution.networkDelayTime([[2, 1, 1], [2, 3, 1], [3, 4, 1]], n=4, k=2) == 2", "def test_networkDelayTime():\n    solution = Solution()\n    times = [[2, 1, 1], [2, 3, 1], [1, 3, 2]]\n    n = 3\n    k = 2\n    assert solution.networkDelayTime(times, n, k) == 2", "def test_networkDelayTime():\n    solution = Solution()\n    times = [(2, 1, 1), (2, 3, 1), (3, 4, 1)]\n    n = 4\n    k = 2\n    assert solution.networkDelayTime(times, n, k) == 2", "def test_networkDelayTime():\n    solution = Solution()\n    assert solution.networkDelayTime([[1, 2, 1], [2, 3, 2]], n=4, k=2) == 2"]}
{"task_num": 770, "task_title": "Basic Calculator IV", "func_name": "basicCalculatorIV", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Poly:\n  def __init__(self, term: str = None, coef: int = None):\n    if term and coef:\n      self.terms = collections.Counter({term: coef})\n    else:\n      self.terms = collections.Counter()\n\n  def __add__(self, other):\n    for term, coef in other.terms.items():\n      self.terms[term] += coef\n    return self\n\n  def __sub__(self, other):\n    for term, coef in other.terms.items():\n      self.terms[term] -= coef\n    return self\n\n  def __mul__(self, other):\n    res = Poly()\n    for a, aCoef in self.terms.items():\n      for b, bCoef in other.terms.items():\n        res.terms[self._merge(a, b)] += aCoef * bCoef\n    return res\n\n  def toList(self) -> List[str]:\n    for term in list(self.terms.keys()):\n      if not self.terms[term]:\n        del self.terms[term]\n\n    def cmp(term: str) -> tuple:\n      if term == '1':\n        return (0,)\n      var = term.split('*')\n      return (-len(var), term)\n\n    def concat(term: str) -> str:\n      if term == '1':\n        return str(self.terms[term])\n      return str(self.terms[term]) + '*' + term\n\n    terms = list(self.terms.keys())\n    terms.sort(key=cmp)\n    return [concat(term) for term in terms]\n\n  def _merge(self, a: str, b: str) -> str:\n    if a == '1':\n      return b\n    if b == '1':\n      return a\n    res = []\n    A = a.split('*')\n    B = b.split('*')\n    i = 0\n    j = 0\n    while i < len(A) and j < len(B):\n      if A[i] < B[j]:\n        res.append(A[i])\n        i += 1\n      else:\n        res.append(B[j])\n        j += 1\n    return '*'.join(res + A[i:] + B[j:])\n\n\nclass Solution:\n  def basicCalculatorIV(self, expression: str, evalvars: List[str], evalints: List[int]) -> List[str]:\n    tokens = list(self._getTokens(expression))\n    evalMap = {a: b for a, b in zip(evalvars, evalints)}\n\n    for i, token in enumerate(tokens):\n      if token in evalMap:\n        tokens[i] = str(evalMap[token])\n\n    postfix = self._infixToPostfix(tokens)\n    return self._evaluate(postfix).toList()\n\n  def _getTokens(self, s: str) -> Iterator[str]:\n    i = 0\n    for j, c in enumerate(s):\n      if c == ' ':\n        if i < j:\n          yield s[i:j]\n        i = j + 1\n      elif c in '()+-*':\n        if i < j:\n          yield s[i:j]\n        yield c\n        i = j + 1\n    if i < len(s):\n      yield s[i:]\n\n  def _infixToPostfix(self, tokens: List[str]) -> List[str]:\n    postfix = []\n    ops = []\n\n    def precedes(prevOp: str, currOp: str) -> bool:\n      if prevOp == '(':\n        return False\n      return prevOp == '*' or currOp in '+-'\n\n    for token in tokens:\n      if token == '(':\n        ops.append(token)\n      elif token == ')':\n        while ops[-1] != '(':\n          postfix.append(ops.pop())\n        ops.pop()\n      elif token in '+-*':\n        while ops and precedes(ops[-1], token):\n          postfix.append(ops.pop())\n        ops.append(token)\n      else:\n        postfix.append(token)\n    return postfix + ops[::-1]\n\n  def _evaluate(self, postfix: List[str]) -> Poly:\n    polys: List[Poly] = []\n    for token in postfix:\n      if token in '+-*':\n        b = polys.pop()\n        a = polys.pop()\n        if token == '+':\n          polys.append(a + b)\n        elif token == '-':\n          polys.append(a - b)\n        else:\n          polys.append(a * b)\n      elif token.lstrip('-').isnumeric():\n        polys.append(Poly(\"1\", int(token)))\n      else:\n        polys.append(Poly(token, 1))\n    return polys[0]\n", "tests": ["Here's a function that covers the specified execution path:\n\n```python\ndef test_basicCalculatorIV():\n    solution = Solution()\n\n    expression = \"a\"\n    evalvars = [\"a\"]\n    evalints = [1]\n\n    assert solution.basicCalculatorIV(expression, evalvars, evalints) == [\"1*a*\"]\n```", "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV(\"a*2-1\", [\"a\"], [2]) == [\"1*a\",\"-3\"]", "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV(\"a + b\", [\"a\", \"b\"], [1, 1]) == [\"2*a*b\"]", "def test_basicCalculatorIV():\n    solution = Solution()\n    expression = \"a*1*b\"\n    evalvars = [\"a\", \"b\"]\n    evalints = [2, 3]\n    assert solution.basicCalculatorIV(expression, evalvars, evalints) == [\"6*a*b\"]", "def test_basicCalculatorIV():\n    solution = Solution()\n    expression = \"a + b \"\n    evalvars, evalints = [\"a\", \"b\"], [10, 20]\n    assert solution.basicCalculatorIV(expression, evalvars, evalints) == [\"30*b\", \"10*a\"]", "def test_basicCalculatorIV():\n    solution = Solution()\n    expression = \"a + b\"\n    evalvars = [\"a\", \"b\"]\n    evalints = [1, 2]\n    assert solution.basicCalculatorIV(expression, evalvars, evalints) == [\"3\"]"]}
{"task_num": 777, "task_title": "Swap Adjacent in LR String", "func_name": "canTransform", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def canTransform(self, start: str, end: str) -> bool:\n    if start.replace('X', '') != end.replace('X', ''):\n      return False\n\n    i = 0\n    j = 0\n\n    while i < len(start) and j < len(end):\n      while i < len(start) and start[i] == 'X':\n        i += 1\n      while j < len(end) and end[j] == 'X':\n        j += 1\n      if i == len(start) and j == len(end):\n        return True\n      if i == len(start) or j == len(end):\n        return False\n      if start[i] == 'L' and i < j:\n        return False\n      if start[i] == 'R' and i > j:\n        return False\n      i += 1\n      j += 1\n\n    return True\n", "tests": ["```python\ndef test_canTransform():\n    solution = Solution()\n    assert not solution.canTransform(\"XXXXXX\", \"XXXXXXX\")\n```\nIn this test case, the `start` string contains only `'X'` characters and its length is less than that of the `end` string. This ensures that the condition on line 20 (`i < len(start) and start[i] == 'X'`) is satisfied twice consecutively before moving to the next loop iteration where `j < len(end) and end[j] == 'X'` is checked twice.", "```python\ndef test_canTransform():\n    solution = Solution()\n    assert solution.canTransform(\"XXX\", \"X\")\n```", "def test_canTransform():\n    solution = Solution()\n    assert not solution.canTransform(\"XX\", \"L\")"]}
{"task_num": 782, "task_title": "Transform to Chessboard", "func_name": "movesToChessboard", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def movesToChessboard(self, board: List[List[int]]) -> int:\n    n = len(board)\n\n    for i in range(n):\n      for j in range(n):\n        if board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]:\n          return -1\n\n    rowSum = sum(board[0])\n    colSum = sum(board[i][0] for i in range(n))\n\n    if rowSum != n // 2 and rowSum != (n + 1) // 2:\n      return -1\n    if colSum != n // 2 and colSum != (n + 1) // 2:\n      return -1\n\n    rowSwaps = sum(board[i][0] == (i & 1) for i in range(n))\n    colSwaps = sum(board[0][i] == (i & 1) for i in range(n))\n\n    if n & 1:\n      if rowSwaps & 1:\n        rowSwaps = n - rowSwaps\n      if colSwaps & 1:\n        colSwaps = n - colSwaps\n    else:\n      rowSwaps = min(rowSwaps, n - rowSwaps)\n      colSwaps = min(colSwaps, n - colSwaps)\n\n    return (rowSwaps + colSwaps) // 2\n", "tests": ["def test_movesToChessboard():\n    solution = Solution()\n    board = [[0, 0], [1, 1]]\n    assert solution.movesToChessboard(board) == -1", "def test_movesToChessboard():\n    solution = Solution()\n    board = [[0, 1], [1, 0]]\n    assert solution.movesToChessboard(board) == -1", "```python\ndef test_movesToChessboard():\n    solution = Solution()\n    board = [[0, 0], [1, 1]]\n    assert solution.movesToChessboard(board) == -1\n```\nThis test case covers the execution path through the inner loop (`j in range(n)` on line 16) three times before moving to the next iteration of the outer loop (`i in range(n)` on line 15). The board used in this test case has rows and columns that differ from half and half plus one, which should lead to the function returning `-1` as expected."]}
{"task_num": 786, "task_title": "K-th Smallest Prime Fraction", "func_name": "kthSmallestPrimeFraction", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\n    n = len(arr)\n    ans = [0, 1]\n    l = 0\n    r = 1\n\n    while True:\n      m = (l + r) / 2\n      ans[0] = 0\n      count = 0\n      j = 1\n\n      for i in range(n):\n        while j < n and arr[i] > m * arr[j]:\n          j += 1\n        count += n - j\n        if j == n:\n          break\n        if ans[0] * arr[j] < ans[1] * arr[i]:\n          ans[0] = arr[i]\n          ans[1] = arr[j]\n\n      if count < k:\n        l = m\n      elif count > k:\n        r = m\n      else:\n        return ans\n", "tests": ["def test_kthSmallestPrimeFraction():\n    arr = [3, 5, 7, 9]\n    k = 1\n    solution = Solution()\n    assert solution.kthSmallestPrimeFraction(arr, k) == [3, 5]", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    assert solution.kthSmallestPrimeFraction([1, 2, 3], 2) == [1, 2]", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    assert solution.kthSmallestPrimeFraction([1, 3, 6], 2) == [3, 6]", "Here's the test case that follows the target execution path:\n\n```python\ndef test_kthSmallestPrimeFraction():\n    solution = Solution()\n    arr = [7, 12, 4]\n    k = 3\n    assert solution.kthSmallestPrimeFraction(arr, k) == [7, 12]\n```\n\nThis test case will execute the loop at line 24 for `i` equals to 0 and 1. For both iterations, it will execute the loop at line 25 until `j` equals to the length of `arr`. After that, it will enter the else clause at line 34 since `count` is not less than `k`, then it will update `l` at line 36 because `count` is greater than `k`. Finally, it will return `[7, 12]` which is the third smallest fraction from the given array."]}
{"task_num": 787, "task_title": "Cheapest Flights Within K Stops", "func_name": "findCheapestPrice", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in flights:\n      graph[u].append((v, w))\n\n    return self._dijkstra(graph, src, dst, k)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, k: int) -> int:\n    dist=[]\n    for i in range(len(graph)):\n      dist.append([math.inf for _ in range(k + 2)])\n\n    dist[src][k + 1] = 0\n    minHeap = [(dist[src][k + 1], src, k + 1)]\n\n    while minHeap:\n      d, u, stops = heapq.heappop(minHeap)\n      if u == dst:\n        return d\n      if stops == 0 or d > dist[u][stops]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v][stops - 1]:\n          dist[v][stops - 1] = d + w\n          heapq.heappush(minHeap, (dist[v][stops - 1], v, stops - 1))\n\n    return -1\n", "tests": ["def test_findCheapestPrice():\n    solution = Solution()\n    flights = [[0, 1, 2], [0, 3, 5]]\n    assert solution.findCheapestPrice(4, flights, 0, 3, 2) == -1", "```python\ndef test_findCheapestPrice():\n    solution = Solution()\n    assert solution.findCheapestPrice(4, [[0,1,1],[1,2,1],[2,3,1],[3,1,1]], 0, 3, 2) == -1\n```\nThe provided test case covers the target execution path by using a graph with 4 cities and specific flight connections. The source city is 0, the destination city is 3, and the maximum number of stops allowed is 2. According to the function description, there is no such route that meets these criteria, so the expected output is -1.", "Here's a test case that follows the given execution path:\n\n```python\ndef test_findCheapestPrice():\n    solution = Solution()\n    flights = [[0, 1, 100], [0, 2, 300], [1, 2, 200]]\n    assert solution.findCheapestPrice(3, flights, 0, 2, 1) == -1\n```", "```python\ndef test_findCheapestPrice():\n    solution = Solution()\n    flights = [[0, 1, 100], [1, 2, 200], [2, 3, 500]]\n    assert solution.findCheapestPrice(4, flights, 0, 3, 2) == 600\n```", "def test_findCheapestPrice():\n    solution = Solution()\n    assert solution.findCheapestPrice(\n        n=4,\n        flights=[[0,1,100],[1,2,100],[2,3,600],[3,1,200]],\n        src=0,\n        dst=3,\n        k=1\n    ) == 700"]}
{"task_num": 794, "task_title": "Valid Tic-Tac-Toe State", "func_name": "validTicTacToe", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def validTicTacToe(self, board: List[str]) -> bool:\n    def isWin(c: str) -> bool:\n      return any(row.count(c) == 3 for row in board) or any(row.count(c) == 3 for row in list(zip(*board))) or all(board[i][i] == c for i in range(3)) or all(board[i][2 - i] == c for i in range(3))\n\n    countX = sum(row.count('X') for row in board)\n    countO = sum(row.count('O') for row in board)\n\n    if countX < countO or countX - countO > 1:\n      return False\n    if isWin('X') and countX == countO or isWin('O') and countX != countO:\n      return False\n\n    return True\n", "tests": ["def test_validTicTacToe():\n    solution = Solution()\n    assert not solution.validTicTacToe([\"XOX\",\"OOX\",\"OXO\"])", "def test_validTicTacToe():\n    solution = Solution()\n    assert not solution.validTicTacToe([\"XOX\", \"OXX\", \"XOX\"])"]}
{"task_num": 805, "task_title": "Split Array With Same Average", "func_name": "splitArraySameAverage", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def splitArraySameAverage(self, nums: List[int]) -> bool:\n    n = len(nums)\n    summ = sum(nums)\n    if not any(i * summ % n == 0 for i in range(1, n // 2 + 1)):\n      return False\n\n    sums = [set() for _ in range(n // 2 + 1)]\n    sums[0].add(0)\n\n    for num in nums:\n      for i in range(n // 2, 0, -1):\n        for val in sums[i - 1]:\n          sums[i].add(num + val)\n\n    for i in range(1, n // 2 + 1):\n      if i * summ % n == 0 and i * summ // n in sums[i]:\n        return True\n\n    return False\n", "tests": ["def test_splitArraySameAverage():\n    nums = [90, 47, 65, 17, 30, 2, 83]\n    solution = Solution()\n    assert solution.splitArraySameAverage(nums) == True", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert not solution.splitArraySameAverage([1, 2, 3])", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert(solution.splitArraySameAverage([40, 45, 83]) == True)", "def test_splitArraySameAverage():\n    solution = Solution()\n    nums = [5,7]\n    assert not solution.splitArraySameAverage(nums)"]}
{"task_num": 815, "task_title": "Bus Routes", "func_name": "numBusesToDestination", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:\n    if source == target:\n      return 0\n\n    graph = collections.defaultdict(list)\n    usedBuses = set()\n\n    for i in range(len(routes)):\n      for route in routes[i]:\n        graph[route].append(i)\n\n    ans = 0\n    q = collections.deque([source])\n\n    while q:\n      ans += 1\n      for _ in range(len(q)):\n        for bus in graph[q.popleft()]:\n          if bus in usedBuses:\n            continue\n          usedBuses.add(bus)\n          for nextRoute in routes[bus]:\n            if nextRoute == target:\n              return ans\n            q.append(nextRoute)\n\n    return -1\n", "tests": ["```python\ndef test_numBusesToDestination():\n    solution = Solution()\n    routes = [[1, 2], [3, 4], [5]]\n    source = 1\n    target = 4\n    assert solution.numBusesToDestination(routes, source, target) == -1\n```", "```python\ndef test_numBusesToDestination():\n    solution = Solution()\n    routes = [[7, 12], [4, 5, 15], [6], [15], [3]]\n    source = 6\n    target = 15\n    assert solution.numBusesToDestination(routes, source, target) == -1\n```", "def test_numBusesToDestination():\n    solution = Solution()\n    assert solution.numBusesToDestination([[7,12],[4,5,15],[6]], 15, 12) == -1", "def test_numBusesToDestination():\n    solution = Solution()\n    routes = [[7], [6, 2, 9, 10, 5, 4], [3, 8]]\n    source = 1\n    target = 10"]}
{"task_num": 838, "task_title": "Push Dominoes", "func_name": "pushDominoes", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def pushDominoes(self, dominoes: str) -> str:\n    ans = list(dominoes)\n    L = -1\n    R = -1\n\n    for i in range(len(dominoes) + 1):\n      if i == len(dominoes) or dominoes[i] == 'R':\n        if L < R:\n          while R < i:\n            ans[R] = 'R'\n            R += 1\n        R = i\n      elif dominoes[i] == 'L':\n        if R < L or (L, R) == (-1, -1):\n          if (L, R) == (-1, -1):\n            L += 1\n          while L < i:\n            ans[L] = 'L'\n            L += 1\n        else:\n          l = R + 1\n          r = i - 1\n          while l < r:\n            ans[l] = 'R'\n            ans[r] = 'L'\n            l += 1\n            r -= 1\n        L = i\n\n    return ''.join(ans)\n", "tests": ["def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes(\".LR.\") == \"LLRR\"", "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes(\"RR.L\") == \"RR.R\"", "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes(\"...L.R...\") == \"LL.LLRRR\"", "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes(\"LL.RR\") == \"LL.RR\""]}
{"task_num": 845, "task_title": "Longest Mountain in Array", "func_name": "longestMountain", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def longestMountain(self, arr: List[int]) -> int:\n    ans = 0\n    i = 0\n\n    while i + 1 < len(arr):\n      while i + 1 < len(arr) and arr[i] == arr[i + 1]:\n        i += 1\n\n      increasing = 0\n      decreasing = 0\n\n      while i + 1 < len(arr) and arr[i] < arr[i + 1]:\n        increasing += 1\n        i += 1\n\n      while i + 1 < len(arr) and arr[i] > arr[i + 1]:\n        decreasing += 1\n        i += 1\n\n      if increasing > 0 and decreasing > 0:\n        ans = max(ans, increasing + decreasing + 1)\n\n    return ans\n", "tests": ["def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([0, 2, 4, 1, 3]) == 5", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([0, 3, 2, 1, 4, 5, 6, 7]) == 8", "```python\ndef test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([0, 3, 2, 0]) == 3\n```\nIn this test case, the function 'longestMountain' should follow the target execution path and return `3` for the input `[0, 3, 2, 0]` as it is a mountain array with the longest subarray being [3, 2]."]}
{"task_num": 854, "task_title": "K-Similar Strings", "func_name": "kSimilarity", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def kSimilarity(self, s1: str, s2: str) -> int:\n    ans = 0\n    q = collections.deque([s1])\n    seen = {s1}\n\n    while q:\n      for _ in range(len(q)):\n        curr = q.popleft()\n        if curr == s2:\n          return ans\n        for child in self._getChildren(curr, s2):\n          if child in seen:\n            continue\n          q.append(child)\n          seen.add(child)\n      ans += 1\n\n    return -1\n\n  def _getChildren(self, curr: str, target: str) -> List[str]:\n    children = []\n    s = list(curr)\n    i = 0\n    while curr[i] == target[i]:\n      i += 1\n\n    for j in range(i + 1, len(s)):\n      if s[j] == target[i]:\n        s[i], s[j] = s[j], s[i]\n        children.append(''.join(s))\n        s[i], s[j] = s[j], s[i]\n\n    return children\n", "tests": ["def test_kSimilarity():\n    solution = Solution()\n    assert solution.kSimilarity(\"abc\", \"acb\") == -1", "```python\ndef test_kSimilarity():\n    solution = Solution()\n    assert solution.kSimilarity(\"abc\", \"bac\") == 1\n\ntest_kSimilarity()\n```", "```python\ndef test_kSimilarity():\n    solution = Solution()\n    assert solution.kSimilarity(\"abc\", \"acb\") == 1\n```\nThis test case covers the target execution path as follows:\n\n- `s1` and `s2` are not equal initially, so it enters the loop at line 18.\n- In `_getChildren`, `i` equals 0 since 'a' is not equal to 'c'.\n- It iterates over `j` in range(i+1, len(s)), which is [1, len('abc')).\n- When `j` equals 1, `s[j]` ('b') is equal to `target[i]` ('c'), so it swaps them.\n- The resulting string 'acb' is appended to the list of children and then added back into `q`.\n- After this iteration, `q.popleft()` would return 'acb', which matches `s2`, so it returns 1."]}
{"task_num": 861, "task_title": "Score After Flipping Matrix", "func_name": "matrixScore", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def matrixScore(self, grid: List[List[int]]) -> int:\n    for row in grid:\n      if row[0] == 0:\n        self._flip(row)\n\n    for j, col in enumerate(list(zip(*grid))):\n      if sum(col) * 2 < len(grid):\n        self._flipCol(grid, j)\n\n    return sum(self._binary(row) for row in grid)\n\n  def _flip(self, row: List[int]) -> None:\n    for i in range(len(row)):\n      row[i] ^= 1\n\n  def _flipCol(self, grid: List[List[int]], j: int) -> None:\n    for i in range(len(grid)):\n      grid[i][j] ^= 1\n\n  def _binary(self, row: List[int]) -> int:\n    res = row[0]\n    for j in range(1, len(row)):\n      res = res * 2 + row[j]\n    return res\n", "tests": ["def test_matrixScore():\n    solution = Solution()\n    grid = [[0,0],[1,1]]\n    assert solution.matrixScore(grid) == 6", "def test_matrixScore():\n    solution = Solution()\n    grid = [[0, 0], [1, 1]]\n    assert solution.matrixScore(grid) == 6", "```python\ndef test_matrixScore():\n    solution = Solution()\n    grid = [[0, 0], [1, 1]]\n    assert solution.matrixScore(grid) == 3\n```"]}
{"task_num": 866, "task_title": "Prime Palindrome", "func_name": "primePalindrome", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def primePalindrome(self, n: int) -> int:\n    def getPalindromes(n: int):\n      length = n // 2\n      for i in range(10**(length - 1), 10**length):\n        s = str(i)\n        for j in range(10):\n          yield int(s + str(j) + s[::-1])\n\n    def isPrime(num: int) -> bool:\n      for i in range(2, int(num**0.5 + 1)):\n        if num % i == 0:\n          return False\n      return True\n\n    if n <= 2:\n      return 2\n    if n == 3:\n      return 3\n    if n <= 5:\n      return 5\n    if n <= 7:\n      return 7\n    if n <= 11:\n      return 11\n\n    nLength = len(str(n))\n\n    while True:\n      for num in getPalindromes(nLength):\n        if num >= n and isPrime(num):\n          return num\n      nLength += 1\n", "tests": ["def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(8) == 11", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(39999) == 407", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(10) == 11", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(7) == 11"]}
{"task_num": 882, "task_title": "Reachable Nodes In Subdivided Graph", "func_name": "reachableNodes", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def reachableNodes(self, edges: List[List[int]], maxMoves: int, n: int) -> int:\n    graph = [[] for _ in range(n)]\n    dist = [maxMoves + 1] * n\n\n    for u, v, cnt in edges:\n      graph[u].append((v, cnt))\n      graph[v].append((u, cnt))\n\n    reachableNodes = self._dijkstra(graph, 0, maxMoves, dist)\n    reachableSubnodes = 0\n\n    for u, v, cnt in edges:\n      a = 0 if dist[u] > maxMoves else min(maxMoves - dist[u], cnt)\n      b = 0 if dist[v] > maxMoves else min(maxMoves - dist[v], cnt)\n      reachableSubnodes += min(a + b, cnt)\n\n    return reachableNodes + reachableSubnodes\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, maxMoves: int, dist: List[int]) -> int:\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if dist[u] >= maxMoves:\n        break\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        newDist = d + w + 1\n        if newDist < dist[v]:\n          dist[v] = newDist\n          heapq.heappush(minHeap, (newDist, v))\n\n    return sum(d <= maxMoves for d in dist)\n", "tests": ["```\ndef test_reachableNodes():\n    solution = Solution()\n    assert solution.reachableNodes([[0,1,5],[0,2,3],[2,3,9]], 4, 6) == 3\n```", "def test_reachableNodes():\n    solution = Solution()\n    edges = [[0,1,3],[1,2,1],[0,2,5]]\n    maxMoves = 6\n    n = 3\n    assert solution.reachableNodes(edges, maxMoves, n) == 4", "def test_reachableNodes():\n    solution = Solution()\n    assert solution.reachableNodes([[0,1,2],[0,2,1]], 3, 3) == 3", "```python\ndef test_reachableNodes():\n    solution = Solution()\n    assert solution.reachableNodes([[0,1,1],[1,2,1]], 3, 3) == 2\n```", "def test_reachableNodes():\n    solution = Solution()\n    edges = [[0,1,2],[1,2,3],[2,3,2]]\n    maxMoves = 4\n    n = 4\n    assert solution.reachableNodes(edges, maxMoves, n) == 3"]}
{"task_num": 909, "task_title": "Snakes and Ladders", "func_name": "snakesAndLadders", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def snakesAndLadders(self, board: List[List[int]]) -> int:\n    n = len(board)\n    ans = 0\n    q = collections.deque([1])\n    seen = set()\n    A = [0] * (1 + n * n)\n\n    for i in range(n):\n      for j in range(n):\n        if n - i & 1 :\n          A[(n - 1 - i) * n + (j + 1)] = board[i][j]\n        else:\n          A[(n - 1 - i) * n + (n - j)] = board[i][j]\n\n    while q:\n      ans += 1\n      for _ in range(len(q)):\n        curr = q.popleft()\n        for next in range(curr + 1, min(curr + 6, n * n) + 1):\n          dest = A[next] if A[next] > 0 else next\n          if dest == n * n:\n            return ans\n          if dest in seen:\n            continue\n          q.append(dest)\n          seen.add(dest)\n\n    return -1\n", "tests": ["def test_snakesAndLadders():\n    solution = Solution()\n    board = [[-1, 4], [-1, 3]]\n    assert solution.snakesAndLadders(board) == -1", "def test_snakesAndLadders():\n    solution = Solution()\n    board = [[-1, -1], [-1, 3]]\n    assert solution.snakesAndLadders(board) == -1", "def test_snakesAndLadders():\n    solution = Solution()\n    assert solution.snakesAndLadders([[1, 3], [2, -1]]) == 3", "```python\ndef test_snakesAndLadders():\n    solution = Solution()\n    board = [[4,-1],[-1,3]]\n    assert solution.snakesAndLadders(board) == 2\n```\nThis test case will follow the target execution path. The board is `[[-1,4],[-1,3]]`, and on the first move, your destination square is `2`. You follow the ladder to square `3`, but do not follow the subsequent ladder to `4`."]}
{"task_num": 913, "task_title": "Cat and Mouse", "func_name": "catMouseGame", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import IntEnum\n\n\nclass State(IntEnum):\n  kDraw = 0\n  kMouseWin = 1\n  kCatWin = 2\n\n\nclass Solution:\n  def catMouseGame(self, graph: List[List[int]]) -> int:\n    n = len(graph)\n    states = [[[0] * 2 for i in range(n)] for j in range(n)]\n    outDegree = [[[0] * 2 for i in range(n)] for j in range(n)]\n    q = collections.deque()\n\n    for cat in range(n):\n      for mouse in range(n):\n        outDegree[cat][mouse][0] = len(graph[mouse])\n        outDegree[cat][mouse][1] = len(graph[cat]) - graph[cat].count(0)\n\n    for cat in range(1, n):\n      for move in range(2):\n        states[cat][0][move] = int(State.kMouseWin)\n        q.append((cat, 0, move, int(State.kMouseWin)))\n        states[cat][cat][move] = int(State.kCatWin)\n        q.append((cat, cat, move, int(State.kCatWin)))\n\n    while q:\n      cat, mouse, move, state = q.popleft()\n      if cat == 2 and mouse == 1 and move == 0:\n        return state\n      prevMove = move ^ 1\n      for prev in graph[cat if prevMove else mouse]:\n        prevCat = prev if prevMove else cat\n        if prevCat == 0:\n          continue\n        prevMouse = mouse if prevMove else prev\n        if states[prevCat][prevMouse][prevMove]:\n          continue\n        if prevMove == 0 and state == int(State.kMouseWin) or \\\n                prevMove == 1 and state == int(State.kCatWin):\n          states[prevCat][prevMouse][prevMove] = state\n          q.append((prevCat, prevMouse, prevMove, state))\n        else:\n          outDegree[prevCat][prevMouse][prevMove] -= 1\n          if outDegree[prevCat][prevMouse][prevMove] == 0:\n            states[prevCat][prevMouse][prevMove] = state\n            q.append((prevCat, prevMouse, prevMove, state))\n\n    return states[2][1][0]\n", "tests": ["def test_catMouseGame():\n    solution = Solution()\n    graph = [[1,2], [0,3], [4], [5]]\n    assert solution.catMouseGame(graph) == 2", "def test_catMouseGame():\n    solution = Solution()\n    graph = [[1, 2], [0, 3], [1, 4], [2, 5], [3]]\n    assert solution.catMouseGame(graph) == int(State.kCatWin)", "def test_catMouseGame():\n    solution = Solution()\n    assert solution.catMouseGame([[1], [2, 0], [1]]) == 1", "def test_catMouseGame():\n    solution = Solution()\n    graph = [\n        [1, 2, 3],\n        [],\n        [],\n        []\n    ]\n    assert solution.catMouseGame(graph) == int(State.kCatWin)"]}
{"task_num": 923, "task_title": "3Sum With Multiplicity", "func_name": "threeSumMulti", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def threeSumMulti(self, arr: List[int], target: int) -> int:\n    kMod = 1_000_000_007\n    ans = 0\n    count = collections.Counter(arr)\n\n    for i, x in count.items():\n      for j, y in count.items():\n        k = target - i - j\n        if k not in count:\n          continue\n        if i == j and j == k:\n          ans = (ans + x * (x - 1) * (x - 2) // 6) % kMod\n        elif i == j and j != k:\n          ans = (ans + x * (x - 1) // 2 * count[k]) % kMod\n        elif i < j and j < k:\n          ans = (ans + x * y * count[k]) % kMod\n\n    return ans % kMod\n", "tests": ["def test_threeSumMulti():\n    solution = Solution()\n    arr = [3, 5, 2, 7]\n    target = 10\n    assert solution.threeSumMulti(arr, target) == 8", "def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([3,6,7,10], 15) == 1", "```python\ndef test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([1, 2, 3], 6) == 0\n```\n\nIn this test case, the input array is [1, 2, 3] and target is 6. The condition `arr[i] + arr[j] + arr[k] == target` cannot be satisfied for any i < j < k in this array, so the expected output is 0. This test case follows the specified execution path as it enters the loop at line 17 but immediately exits at line 20 due to `k not in count`.", "def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([1, 1, 2], 4) == 1", "def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([3, 0, 4], 7) == 12"]}
{"task_num": 927, "task_title": "Three Equal Parts", "func_name": "threeEqualParts", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def threeEqualParts(self, arr: List[int]) -> List[int]:\n    ones = sum(a == 1 for a in arr)\n\n    if ones == 0:\n      return [0, len(arr) - 1]\n    if ones % 3 != 0:\n      return [-1, -1]\n\n    k = ones // 3\n    i = 0\n\n    for i in range(len(arr)):\n      if arr[i] == 1:\n        first = i\n        break\n\n    gapOnes = k\n\n    for j in range(i + 1, len(arr)):\n      if arr[j] == 1:\n        gapOnes -= 1\n        if gapOnes == 0:\n          second = j\n          break\n\n    gapOnes = k\n\n    for i in range(j + 1, len(arr)):\n      if arr[i] == 1:\n        gapOnes -= 1\n        if gapOnes == 0:\n          third = i\n          break\n\n    while third < len(arr) and arr[first] == arr[second] == arr[third]:\n      first += 1\n      second += 1\n      third += 1\n\n    if third == len(arr):\n      return [first - 1, second]\n    return [-1, -1]\n", "tests": ["def test_threeEqualParts():\n    solution = Solution()\n    assert solution.threeEqualParts([1,2]) == [-1,-1]", "def test_threeEqualParts():\n    solution = Solution()\n    assert solution.threeEqualParts([1,0,1,0,1,1,0,0]) == [3, 5]", "def test_threeEqualParts():\n    solution = Solution()\n    assert solution.threeEqualParts([0,0,0]) == [1, 3]", "def test_threeEqualParts():\n    solution = Solution()\n    assert solution.threeEqualParts([1,0,1,1,0,1,0,1,0,0,1]) == [3, 7]"]}
{"task_num": 935, "task_title": "Knight Dialer", "func_name": "knightDialer", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def knightDialer(self, n: int) -> int:\n    dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n    kMod = 1_000_000_007\n\n    dp = [[1] * 3 for _ in range(4)]\n    dp[3][0] = dp[3][2] = 0\n\n    for _ in range(n - 1):\n      newDp = [[0] * 3 for _ in range(4)]\n      for i in range(4):\n        for j in range(3):\n          if (i, j) in ((3, 0), (3, 2)):\n            continue\n          for dx, dy in dirs:\n            x = i + dx\n            y = j + dy\n            if x < 0 or x >= 4 or y < 0 or y >= 3:\n              continue\n            if (x, y) in ((3, 0), (3, 2)):\n              continue\n            newDp[x][y] = (newDp[x][y] + dp[i][j]) % kMod\n      dp = newDp\n\n    return sum(map(sum, dp)) % kMod\n", "tests": ["def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(1) == 1", "def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(10) == 9", "def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(5) == 96", "def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(3) == 6", "def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(3) == 20"]}
{"task_num": 939, "task_title": "Minimum Area Rectangle", "func_name": "minAreaRect", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minAreaRect(self, points: List[List[int]]) -> int:\n    ans = math.inf\n    xToYs = collections.defaultdict(set)\n\n    for x, y in points:\n      xToYs[x].add(y)\n\n    for i in range(len(points)):\n      for j in range(i):\n        x1, y1 = points[i]\n        x2, y2 = points[j]\n        if x1 == x2 or y1 == y2:\n          continue\n        if y2 in xToYs[x1] and y1 in xToYs[x2]:\n          ans = min(ans, abs(x1 - x2) * abs(y1 - y2))\n\n    return ans if ans < math.inf else 0\n", "tests": ["def test_minAreaRect():\n    solution = Solution()\n    points = [[0, 0], [0, 1], [1, 0], [1, 1]]\n    assert solution.minAreaRect(points) == 1", "def test_minAreaRect():\n    solution = Solution()\n    points = [[1, 1], [1, 3], [3, 1], [3, 3]]\n    assert solution.minAreaRect(points) == 4", "def test_minAreaRect():\n    solution = Solution()\n    points = [[0, 0], [0, 1]]\n    assert(solution.minAreaRect(points) == 0)", "def test_minAreaRect():\n    solution = Solution()\n    points = [[0, 0], [1, 1], [1, 0]]\n    assert solution.minAreaRect(points) == 1"]}
{"task_num": 952, "task_title": "Largest Component Size by Common Factor", "func_name": "largestComponentSize", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def largestComponentSize(self, nums: List[int]) -> int:\n    ans = 0\n    uf = UnionFind(max(nums) + 1)\n    count = collections.Counter()\n\n    for num in nums:\n      for x in range(2, int(math.sqrt(num) + 1)):\n        if num % x == 0:\n          uf.unionByRank(num, x)\n          uf.unionByRank(num, num // x)\n\n    for num in nums:\n      numRoot = uf.find(num)\n      count[numRoot] += 1\n      ans = max(ans, count[numRoot])\n\n    return ans\n", "tests": ["def test_largestComponentSize():\n    solution = Solution()\n    nums = [2,3,6,8,10,15]\n    assert solution.largestComponentSize(nums) == 4", "def test_largestComponentSize():\n    solution = Solution()\n    nums = [6,10,15]\n    assert solution.largestComponentSize(nums) == 3", "```python\ndef test_largestComponentSize():\n    solution = Solution()\n    nums = [4,6,15,35]\n    assert solution.largestComponentSize(nums) == 2\n```\nThis test case covers the target execution path by providing an input array `nums` where each number shares a common factor with another number in the array, except for one number which is prime. This ensures that the condition at Line 30 (`self.id[u] != u`) is satisfied multiple times as the function iterates over the numbers in `nums`.", "def test_largestComponentSize():\n    solution = Solution()\n    assert(solution.largestComponentSize([36, 40, 9]) == 2)", "def test_largestComponentSize():\n    nums = [24, 8, 16]\n    expected = 3\n    solution = Solution()\n    assert solution.largestComponentSize(nums) == expected", "def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([4,6,15,35]) == 4"]}
{"task_num": 963, "task_title": "Minimum Area Rectangle II", "func_name": "minAreaFreeRect", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\nfrom math import sqrt\n\nclass Solution:\n  def minAreaFreeRect(self, points: List[List[int]]) -> float:\n    ans = math.inf\n    centerToPoints = collections.defaultdict(list)\n\n    for ax, ay in points:\n      for bx, by in points:\n        center = ((ax + bx) / 2, (ay + by) / 2)\n        centerToPoints[center].append((ax, ay, bx, by))\n\n    def dist(px: int, py: int, qx: int, qy: int) -> float:\n      return (px - qx)**2 + (py - qy)**2\n\n    for points in centerToPoints.values():\n      for ax, ay, _, _ in points:\n        for cx, cy, dx, dy in points:\n          if (cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0:\n            squaredArea = dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy)\n            if squaredArea > 0:\n              ans = min(ans, squaredArea)\n\n    return 0 if ans == math.inf else sqrt(ans)\n", "tests": ["def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[0,0], [1,0], [0,1], [1,1]]\n    assert solution.minAreaFreeRect(points) == 0.5", "```python\ndef test_minAreaFreeRect():\n    solution = Solution()\n    points = [[0, 0], [1, 0], [2, 1], [3, 1]]\n    assert abs(solution.minAreaFreeRect(points) - sqrt(5)) < 1e-5\n```", "def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[1, 1], [1, -1], [-1, 1], [-1, -1]]\n    assert solution.minAreaFreeRect(points) == pytest.approx(0.0, abs=1e-5)\n    assert solution.minAreaFreeRect([[-2, 0], [2, 0], [-2, 4], [2, 4]]) == pytest.approx(36.0, abs=1e-5)", "def test_minAreaFreeRect():\n    solution = Solution()\n    assert solution.minAreaFreeRect([[0, 1], [1, 2], [-1, -1]]) == pytest.approx(4.0)", "def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[0, 0], [1, 0], [0, 1], [-1, 0]]\n    assert solution.minAreaFreeRect(points) == 1.0", "def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[0,0],[1,0],[2,0],[3,0]]\n    assert solution.minAreaFreeRect(points) == 0."]}
{"task_num": 990, "task_title": "Satisfiability of Equality Equations", "func_name": "equationsPossible", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n\n  def union(self, u: int, v: int) -> None:\n    self.id[self.find(u)] = self.find(v)\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def equationsPossible(self, equations: List[str]) -> bool:\n    uf = UnionFind(26)\n\n    for x, op, _, y in equations:\n      if op == '=':\n        uf.union(ord(x) - ord('a'), ord(y) - ord('a'))\n\n    for x, op, _, y in equations:\n      if op == '!':\n        if uf.find(ord(x) - ord('a')) == uf.find(ord(y) - ord('a')):\n          return False\n    return True\n", "tests": ["def test_equationsPossible():\n    solution = Solution()\n    equations = [\"a==b\", \"c!=d\"]\n    assert solution.equationsPossible(equations) == False", "def test_equationsPossible():\n    solution = Solution()\n    assert not solution.equationsPossible(['a==b', 'c!=d'])", "def test_equationsPossible():\n    solution = Solution()\n    assert not solution.equationsPossible([\"a==b\", \"c!=a\", \"b==c\"])"]}
{"task_num": 999, "task_title": "Available Captures for Rook", "func_name": "numRookCaptures", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numRookCaptures(self, board: List[List[str]]) -> int:\n    ans = 0\n\n    for i in range(8):\n      for j in range(8):\n        if board[i][j] == 'R':\n          i0 = i\n          j0 = j\n\n    for d in [[1, 0], [0, 1], [-1, 0], [0, -1]]:\n      i = i0 + d[0]\n      j = j0 + d[1]\n      while 0 <= i < 8 and 0 <= j < 8:\n        if board[i][j] == 'p':\n          ans += 1\n        if board[i][j] != '.':\n          break\n        i += d[0]\n        j += d[1]\n\n    return ans\n", "tests": ["```python\ndef test_numRookCaptures():\n    solution = Solution()\n    board = [\n        ['.', '.', '.', '.', '.', '.', '.', '.'],\n        ['p', 'p', 'p', 'p', '.', 'p', 'p', 'p'],\n        ['.', '.', '.', '.', '.', '.', '.', '.'],\n        ['.', '.', '.', '.', '.', '.', '.', '.'],\n        ['.', '.', '.', '.', '.', '.', '.', '.'],\n        ['.', '.', '.', '.', '.', '.', '.', '.'],\n        ['.', '.', '.', 'R', '.', '.', '.', '.'],\n        ['p', 'p', 'p', 'p', '.', 'p', 'p', 'p']\n    ]\n    assert solution.numRookCaptures(board) == 3\n```", "def test_numRookCaptures():\n    solution = Solution()\n    board = [\n        ['.', '.', '.', '.', '.', '.', '.', '.'],\n        ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],\n        ['.', '.', '.', '.', '.', '.', '.', '.'],\n        ['.', '.', '.', 'R', '.', '.', '.', '.'],\n        ['.', '.', '.', '.', '.', '.', '.', '.'],\n        ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],\n        ['.', '.', '.', '.', '.', '.', '.', '.'],\n        ['.', '.', '.', '.', '.', '.', '.', '.']\n    ]\n    assert solution.numRookCaptures(board) == 8", "```python\ndef test_numRookCaptures():\n    solution = Solution()\n    board = [\n        ['.', '.', '.', 'p', '.', '.', '.', '.'],\n        ['.', 'p', '.', '.', '.', '.', '.', '.'],\n        ['.', '.', '.', '.', '.', '.', '.', '.'],\n        ['R', '.', '.', '.', '.', '.', '.', '.'],\n        ['.', '.', '.', '.', '.', '.', '.', '.'],\n        ['.', 'p', '.', '.', '.', '.', '.', '.'],\n        ['.', '.', '.', 'p', '.', '.', '.', '.'],\n        ['.', '.', '.', '.', '.', '.', '.', '.']\n    ]\n    assert solution.numRookCaptures(board) == 3\n```", "def test_numRookCaptures():\n    solution = Solution()\n    board = [\n        ['.', '.', '.', '.', 'p', '.', '.', '.'],\n        ['.', '.', '.', '.', 'p', '.', '.', '.'],\n        ['.', '.', '.', '.', 'p', '.', '.', '.'],\n        ['.', '.', '.', 'R', '.', '.', '.', '.'],\n        ['.', '.', '.', '.', 'p', '.', '.', '.'],\n        ['.', '.', '.', '.', 'p', '.', '.', '.'],\n        ['.', '.', '.', '.', 'p', '.', '.', '.'],\n        ['.', '.', '.', '.', '.', '.', '.', '.']\n    ]\n    assert solution.numRookCaptures(board) == 3", "def test_numRookCaptures():\n    solution = Solution()\n    assert solution.numRookCaptures([\n        ['.', '.', '.', '.', '.', '.', '.', '.'],\n        ['.', '.', '.', 'p', '.', '.', '.', '.'],\n        ['.', '.', '.', '.', '.', '.', '.', '.'],\n        ['.', '.', '.', '.', 'R', '.', '.', '.'],\n        ['.', '.', '.', '.', '.', '.', '.', '.'],\n        ['.', '.', '.', '.', '.', '.', '.', '.'],\n        ['.', '.', '.', 'p', '.', '.', '.', '.'],\n        ['.', '.', '.', '.', '.', '.', '.', '.']\n    ]) == 2"]}
{"task_num": 1001, "task_title": "Grid Illumination", "func_name": "gridIllumination", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def gridIllumination(self, n: int, lamps: List[List[int]], queries: List[List[int]]) -> List[int]:\n    ans = []\n    rows = collections.Counter()\n    cols = collections.Counter()\n    diag1 = collections.Counter()\n    diag2 = collections.Counter()\n    lampsSet = set()\n\n    for i, j in lamps:\n      if (i, j) not in lampsSet:\n        lampsSet.add((i, j))\n        rows[i] += 1\n        cols[j] += 1\n        diag1[i + j] += 1\n        diag2[i - j] += 1\n\n    for i, j in queries:\n      if rows[i] or cols[j] or diag1[i + j] or diag2[i - j]:\n        ans.append(1)\n        for y in range(max(0, i - 1), min(n, i + 2)):\n          for x in range(max(0, j - 1), min(n, j + 2)):\n            if (y, x) in lampsSet:\n              lampsSet.remove((y, x))\n              rows[y] -= 1\n              cols[x] -= 1\n              diag1[y + x] -= 1\n              diag2[y - x] -= 1\n      else:\n        ans.append(0)\n\n    return ans\n", "tests": ["def test_gridIllumination():\n    solution = Solution()\n    assert solution.gridIllumination(\n        n=3,\n        lamps=[[0,0], [0,1], [1,0]],\n        queries=[[0,2]]\n    ) == [1]", "def test_gridIllumination():\n    solution = Solution()\n    assert solution.gridIllumination(5, [[0, 0], [0, 4]], [[1, 2]]) == [1]", "```python\ndef test_gridIllumination():\n    solution = Solution()\n    assert(solution.gridIllumination(5, [[0, 0], [4, 4]], [[1, 2], [2, 3]])) == [1, 1]\n```", "def test_gridIllumination():\n    solution = Solution()\n    lamps = [[0, 0], [0, 1], [1, 0]]\n    queries = [[0, 0]]\n    assert solution.gridIllumination(2, lamps, queries) == [1]", "def test_gridIllumination():\n    solution = Solution()\n    assert solution.gridIllumination(3, [[0,0], [1,1]], [[1,1]]) == [1]", "def test_gridIllumination():\n    solution = Solution()\n    assert solution.gridIllumination(\n        5,\n        [[0, 0], [4, 4]],\n        [[1, 1], [2, 2], [3, 3]]\n    ) == [1, 1, 1]"]}
{"task_num": 1093, "task_title": "Statistics from a Large Sample", "func_name": "sampleStats", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def sampleStats(self, count: List[int]) -> List[float]:\n    minimum = next((i for i, num in enumerate(count) if num), None)\n    maximum = next((i for i, num in reversed(list(enumerate(count))) if num), None)\n    n = sum(count)\n    mean = sum(i * c / n for i, c in enumerate(count))\n    mode = count.index(max(count))\n\n    numCount = 0\n    leftMedian = 0\n    for i, c in enumerate(count):\n      numCount += c\n      if numCount >= n / 2:\n        leftMedian = i\n        break\n\n    numCount = 0\n    rightMedian = 0\n    for i, c in reversed(list(enumerate(count))):\n      numCount += c\n      if numCount >= n / 2:\n        rightMedian = i\n        break\n\n    return [minimum, maximum, mean, (leftMedian + rightMedian) / 2, mode]\n", "tests": ["def test_sampleStats():\n    solution = Solution()\n    count = [0]*256\n    count[1] = 1\n    count[2] = 1\n    count[3] = 1\n    count[4] = 1\n    count[5] = 1\n    assert solution.sampleStats(count) == [None, None, 3.0, 3.5, None]"]}
{"task_num": 1129, "task_title": "Shortest Path with Alternating Colors", "func_name": "shortestAlternatingPaths", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import Enum\n\n\nclass Color(Enum):\n  kInit = 0\n  kRed = 1\n  kBlue = 2\n\n\nclass Solution:\n  def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:\n    ans = [-1] * n\n    graph = [[] for _ in range(n)]\n    q = collections.deque([(0, Color.kInit)])\n\n    for u, v in redEdges:\n      graph[u].append((v, Color.kRed))\n\n    for u, v in blueEdges:\n      graph[u].append((v, Color.kBlue))\n\n    step = 0\n    while q:\n      for _ in range(len(q)):\n        u, prevColor = q.popleft()\n        if ans[u] == -1:\n          ans[u] = step\n        for i, (v, edgeColor) in enumerate(graph[u]):\n          if v == -1 or edgeColor == prevColor:\n            continue\n          q.append((v, edgeColor))\n          graph[u][i] = (-1, edgeColor)\n      step += 1\n\n    return ans\n", "tests": ["def test_shortestAlternatingPaths():\n    solution = Solution()\n    redEdges, blueEdges = [(0, 1), (1, 2)], [(3, 4)]\n    assert solution.shortestAlternatingPaths(5, redEdges, blueEdges) == [-1, 0, 1, -1, -1]", "def test_shortestAlternatingPaths():\n    solution = Solution()\n    n = 5\n    redEdges = [[0,1],[1,2],[2,3]]\n    blueEdges = [[0,4],[3,2],[1,0]]\n    assert solution.shortestAlternatingPaths(n, redEdges, blueEdges) == [-1, 0, 1, -1, -1]", "```python\ndef test_shortestAlternatingPaths():\n    solution = Solution()\n    assert solution.shortestAlternatingPaths(5, [[0,2],[1,3],[0,4]], [[1,0],[2,1],[4,1]]) == [-1, 0, 1, -1, -1]\n```"]}
{"task_num": 1139, "task_title": "Largest 1-Bordered Square", "func_name": "largest1BorderedSquare", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n\n    leftOnes = [[0] * n for _ in range(m)]\n    topOnes = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1:\n          if j==0:\n            leftOnes[i][j]=1\n          else:\n            leftOnes[i][j]=1+leftOnes[i][j-1]\n          if i==0:\n            topOnes[i][j]=1\n          else:\n            topOnes[i][j]=1+topOnes[i-1][j]\n\n    for sz in range(min(m, n), 0, -1):\n      for i in range(m - sz + 1):\n        for j in range(n - sz + 1):\n          x = i + sz - 1\n          y = j + sz - 1\n          if min(leftOnes[i][y], leftOnes[x][y], topOnes[x][j], topOnes[x][y]) >= sz:\n            return sz * sz\n\n    return 0\n", "tests": ["```python\ndef test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[1, 0, 1], [1, 1, 1], [1, 0, 1]]\n    assert solution.largest1BorderedSquare(grid) == 4\n```\nThis test case covers the execution path from lines 20 to 31 by providing a grid where all conditions are met sequentially. The largest square subgrid with all ones on its border in this grid is of size 2x2, thus the expected output is 4 (2*2).", "def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[1, 1, 0], [1, 1, 1], [0, 1, 0]]\n    assert solution.largest1BorderedSquare(grid) == 4", "def test_largest1BorderedSquare():\n    solution = Solution()\n    assert solution.largest1BorderedSquare([[0, 1], [1, 0]]) == 4", "def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [\n        [1, 1, 1],\n        [1, 0, 1],\n        [1, 1, 1]\n    ]\n    assert solution.largest1BorderedSquare(grid) == 4"]}
{"task_num": 1162, "task_title": "As Far from Land as Possible", "func_name": "maxDistance", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxDistance(self, grid: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    q = collections.deque()\n    water = 0\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 0:\n          water += 1\n        else:\n          q.append((i, j))\n\n    if water == 0 or water == m * n:\n      return -1\n\n    ans = 0\n    d = 0\n\n    while q:\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        ans = d\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if grid[x][y] > 0:\n            continue\n          q.append((x, y))\n          grid[x][y] = 2\n      d += 1\n\n    return ans\n", "tests": ["```python\ndef test_maxDistance():\n    solution = Solution()\n    assert solution.maxDistance([[1, 0], [0, 1]]) == 2\n```\nIn this test case, the grid is `[[1, 0], [0, 1]]`. After the first iteration of the while loop (line 33), the queue will contain `(0, 1)`. The next four iterations of the for loop (lines 36-45) will lead to checking `(0, 2)` which is out of bounds and thus satisfying the target execution path.", "def test_maxDistance():\n    solution = Solution()\n    grid = [[1, 0], [0, 1]]\n    assert solution.maxDistance(grid) == 2", "```python\ndef test_maxDistance():\n    solution = Solution()\n    grid = [[0, 0], [1, 1]]\n    assert solution.maxDistance(grid) == 2\n```", "```python\ndef test_maxDistance():\n    solution = Solution()\n    grid = [\n        [1, 0],\n        [0, 1]\n    ]\n    assert solution.maxDistance(grid) == 2\n```\nThis test case covers the target execution path by providing a `grid` where all water cells have a Manhattan distance of `2` to their nearest land cell. The first iteration of the while loop will pop both land cells and try to flood in each direction, but since there are no other land cells in the grid, it will immediately return `-1`."]}
{"task_num": 1202, "task_title": "Smallest String With Swaps", "func_name": "smallestStringWithSwaps", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n    ans = ''\n    uf = UnionFind(len(s))\n    map = collections.defaultdict(list)\n\n    for a, b in pairs:\n      uf.unionByRank(a, b)\n\n    for i, c in enumerate(s):\n      map[uf.find(i)].append(c)\n\n    for key in map.keys():\n      map[key].sort(reverse=True)\n\n    for i in range(len(s)):\n      ans += map[uf.find(i)].pop()\n\n    return ans\n", "tests": ["def test_smallestStringWithSwaps():\n    solution = Solution()\n    assert solution.smallestStringWithSwaps(\"dcba\", [[0, 3], [1, 2]]) == \"abcd\"", "```python\ndef test_smallestStringWithSwaps():\n    solution = Solution()\n    s = \"dcba\"\n    pairs = [[0, 1], [1, 2], [2, 3]]\n    assert solution.smallestStringWithSwaps(s, pairs) == \"abcd\"\n```\nThis test case covers the target execution path by providing a string `s` with characters that can be swapped to form a smaller string according to lexicographical order. The pairs provided ensure that all characters can be swapped among themselves, allowing for the smallest possible string to be formed using the swaps indicated in the function description.", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    assert solution.smallestStringWithSwaps(\"dcba\", [[0, 3], [1, 2]]) == \"abcd\"", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    pairs = [[0, 1], [2, 3]]\n    s = \"dcba\"\n    assert solution.smallestStringWithSwaps(s, pairs) == \"abcd\"", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    assert solution.smallestStringWithSwaps(\"dcab\", [[0, 3], [1, 2]]) == \"bacd\"", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    assert solution.smallestStringWithSwaps(\"dcba\", [[1, 0], [2, 3]]) == \"abcd\""]}
{"task_num": 1210, "task_title": "Minimum Moves to Reach Target with Rotations", "func_name": "minimumMoves", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import IntEnum\n\n\nclass Pos(IntEnum):\n  kHorizontal = 0\n  kVertical = 1\n\n\nclass Solution:\n  def minimumMoves(self, grid: List[List[int]]) -> int:\n    n = len(grid)\n    ans = 0\n\n    q = collections.deque([(0, 0, Pos.kHorizontal)])\n    seen = {(0, 0, Pos.kHorizontal)}\n\n    def canMoveRight(x: int, y: int, pos: Pos) -> bool:\n      if pos == Pos.kHorizontal:\n        return y + 2 < n and not grid[x][y + 2]\n      return y + 1 < n and not grid[x][y + 1] and not grid[x + 1][y + 1]\n\n    def canMoveDown(x: int, y: int, pos: Pos) -> bool:\n      if pos == Pos.kVertical:\n        return x + 2 < n and not grid[x + 2][y]\n      return x + 1 < n and not grid[x + 1][y] and not grid[x + 1][y + 1]\n\n    def canRotateClockwise(x: int, y: int, pos: Pos) -> bool:\n      return pos == Pos.kHorizontal and x + 1 < n and \\\n          not grid[x + 1][y + 1] and not grid[x + 1][y]\n\n    def canRotateCounterclockwise(x: int, y: int, pos: Pos) -> bool:\n      return pos == Pos.kVertical and y + 1 < n and \\\n          not grid[x + 1][y + 1] and not grid[x][y + 1]\n\n    while q:\n      for _ in range(len(q)):\n        x, y, pos = q.popleft()\n        if x == n - 1 and y == n - 2 and pos == Pos.kHorizontal:\n          return ans\n        if canMoveRight(x, y, pos) and (x, y + 1, pos) not in seen:\n          q.append((x, y + 1, pos))\n          seen.add((x, y + 1, pos))\n        if canMoveDown(x, y, pos) and (x + 1, y, pos) not in seen:\n          q.append((x + 1, y, pos))\n          seen.add((x + 1, y, pos))\n        newPos = Pos.kVertical if pos == Pos.kHorizontal else Pos.kHorizontal\n        if (canRotateClockwise(x, y, pos) or canRotateCounterclockwise(x, y, pos)) and (x, y, newPos) not in seen:\n          q.append((x, y, newPos))\n          seen.add((x, y, newPos))\n      ans += 1\n\n    return -1\n", "tests": ["def test_minimumMoves():\n    solution = Solution()\n    assert solution.minimumMoves([[0]*3 for _ in range(3)]) == -1", "def test_minimumMoves():\n    solution = Solution()\n    assert(solution.minimumMoves([[0, 0], [1, 0]]) == 2)", "def test_minimumMoves():\n    solution = Solution()\n    assert(solution.minimumMoves([[0, 0], [0, 0]]) == -1)\n    assert(solution.minimumMoves([[0, 0], [0, 1]]) == 0)", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 0], [1, 0]]\n    assert solution.minimumMoves(grid) == -1"]}
{"task_num": 1253, "task_title": "Reconstruct a 2-Row Binary Matrix", "func_name": "reconstructMatrix", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def reconstructMatrix(self, upper: int, lower: int, colsum: List[int]) -> List[List[int]]:\n    if upper + lower != sum(colsum):\n      return []\n    if min(upper, lower) < colsum.count(2):\n      return []\n\n    ans = [[0] * len(colsum) for _ in range(2)]\n\n    for j, c in enumerate(colsum):\n      if c == 2:\n        ans[0][j] = 1\n        ans[1][j] = 1\n        upper -= 1\n        lower -= 1\n\n    for j, c in enumerate(colsum):\n      if c == 1 and upper > 0:\n        ans[0][j] = 1\n        c -= 1\n        upper -= 1\n      if c == 1 and lower > 0:\n        ans[1][j] = 1\n        lower -= 1\n\n    return ans\n", "tests": ["def test_reconstructMatrix():\n    solution = Solution()\n    assert solution.reconstructMatrix(4, 3, [2, 1, 1]) == [[1, 0, 1], [1, 1, 0]]", "def test_reconstructMatrix():\n    solution = Solution()\n    assert solution.reconstructMatrix(5, 4, [1, 1, 1, 2, 1]) == [[1, 0, 1, 1, 0], [1, 0, 0, 1, 0]]", "def test_reconstructMatrix():\n    solution = Solution()\n    assert solution.reconstructMatrix(3, 3, [2, 1, 1]) == [[1, 0, 1], [1, 1, 0]]", "def test_reconstructMatrix():\n    solution = Solution()\n    assert solution.reconstructMatrix(3, 1, [2, 2, 1]) == [[0, 1, 0], [1, 0, 1]]", "def test_reconstructMatrix():\n    solution = Solution()\n    assert solution.reconstructMatrix(5, 5, [2] * 6) == []"]}
{"task_num": 1254, "task_title": "Number of Closed Islands", "func_name": "closedIsland", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def closedIsland(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n\n    def dfs(i: int, j: int) -> None:\n      if i < 0 or i == m or j < 0 or j == n:\n        return\n      if grid[i][j] == 1:\n        return\n\n      grid[i][j] = 1\n      dfs(i + 1, j)\n      dfs(i - 1, j)\n      dfs(i, j + 1)\n      dfs(i, j - 1)\n\n    for i in range(m):\n      for j in range(n):\n        if i * j == 0 or i == m - 1 or j == n - 1:\n          if grid[i][j] == 0:\n            dfs(i, j)\n\n    ans = 0\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 0:\n          dfs(i, j)\n          ans += 1\n\n    return ans\n", "tests": ["def test_closedIsland():\n    solution = Solution()\n    grid = [\n        [0,0,1,1,0],\n        [0,1,0,1,0],\n        [1,1,0,0,1]\n    ]\n    assert solution.closedIsland(grid) == 2", "```python\ndef test_closedIsland():\n    solution = Solution()\n    grid = [[0, 0], [1, 0]]\n    assert solution.closedIsland(grid) == 1\n```\nThis test case will ensure that the inner loop (line 37: `(j in range(n))`) is executed multiple times as intended. The `grid` contains a closed island with one `0` surrounded by water (`1s`), so the expected output is `1`.", "```python\ndef test_closedIsland():\n    solution = Solution()\n    grid = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]\n    assert solution.closedIsland(grid) == 0\n```", "def test_closedIsland():\n    solution = Solution()\n    grid = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]\n    assert solution.closedIsland(grid) == 1", "```python\ndef test_closedIsland():\n    solution = Solution()\n    assert solution.closedIsland([[1, 1, 0, 0], [0, 0, 1, 0], [0, 0, 1, 0]]) == 2\n```", "def test_closedIsland():\n    solution = Solution()\n    grid = [[1, 1, 1], [0, 0, 1], [1, 1, 1]]\n    assert solution.closedIsland(grid) == 1"]}
{"task_num": 1263, "task_title": "Minimum Moves to Move a Box to Their Target Location", "func_name": "minPushBox", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\nfrom collections import deque\n\nclass Solution:\n  def minPushBox(self, grid: List[List[str]]) -> int:\n    for i in range(len(grid)):\n      for j in range(len(grid[0])):\n        if grid[i][j] == \"T\":\n          target = (i,j)\n        if grid[i][j] == \"B\":\n          box = (i,j)\n        if grid[i][j] == \"S\":\n          person = (i,j)\n\n    def valid(x,y):\n      return 0<=x<len(grid) and 0<=y<len(grid[0]) and grid[x][y]!='#'\n\n    def check(curr,dest,box):\n      que = deque([curr])\n      v = set()\n      while que:\n        pos = que.popleft()\n        if pos == dest: \n          return True\n        new_pos = [(pos[0]+1,pos[1]),(pos[0]-1,pos[1]),(pos[0],pos[1]+1),(pos[0],pos[1]-1)]\n        for x,y in new_pos:\n          if valid(x,y) and (x,y) not in v and (x,y)!=box:\n            v.add((x,y))\n            que.append((x,y))\n      return False\n\n    q = deque([(0,box,person)])\n    vis = {box+person}\n    while q :\n      dist, box, person = q.popleft()\n      if box == target:\n        return dist\n\n      b_coord = [(box[0]+1,box[1]),(box[0]-1,box[1]),(box[0],box[1]+1),(box[0],box[1]-1)]\n      p_coord = [(box[0]-1,box[1]),(box[0]+1,box[1]),(box[0],box[1]-1),(box[0],box[1]+1)]\n\n      for new_box,new_person in zip(b_coord,p_coord): \n        if valid(*new_box) and new_box+box not in vis:\n          if valid(*new_person) and check(person,new_person,box):\n            vis.add(new_box+box)\n            q.append((dist+1,new_box,box))\n\n    return -1\n", "tests": ["Here's a test case that covers the target execution path:\n\n```python\ndef test_minPushBox():\n    solution = Solution()\n    grid = [\n        ['#', '.', '#'],\n        ['.', 'B', '.'],\n        ['.', '#', '.'],\n        ['T', '.', '.']\n    ]\n    assert list(itertools.chain(*solution.minPushBox(grid)))[0] == 4\n```", "def test_minPushBox():\n    solution = Solution()\n    grid = [\n        ['#', '#', '#'],\n        ['S', '.', '.'],\n        ['B', 'T', '.']\n    ]\n    assert solution.minPushBox(grid) == 3"]}
{"task_num": 1267, "task_title": "Count Servers that Communicate", "func_name": "countServers", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countServers(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    ans = 0\n    rows = [0] * m\n    cols = [0] * n\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1:\n          rows[i] += 1\n          cols[j] += 1\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1 and (rows[i] > 1 or cols[j] > 1):\n          ans += 1\n\n    return ans\n", "tests": ["def test_countServers():\n    solution = Solution()\n    grid = [[1, 1], [0, 0]]\n    assert solution.countServers(grid) == 2", "def test_countServers():\n    solution = Solution()\n    assert solution.countServers([[1,0,0],[0,1,0],[0,0,1]]) == 2", "def test_countServers():\n    solution = Solution()\n    grid = [\n        [1, 0],\n        [0, 1]\n    ]\n    assert solution.countServers(grid) == 2", "def test_countServers():\n    solution = Solution()\n    grid = [\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1]\n    ]\n    assert solution.countServers(grid) == 2", "Here's the Python function that satisfies all branch conditions:\n\n```python\ndef test_countServers():\n    solution = Solution()\n    grid = [\n        [1, 0],\n        [0, 1]\n    ]\n    assert solution.countServers(grid) == 2\n```\n\nThis grid has one server in each row and column, so both servers communicate with each other. The target execution path is followed as expected: we first encounter the 'if grid[i][j] == 1' condition on line 21, then iterate through rows (line 25) and columns (line 26), eventually incrementing the answer when `rows[i] > 1 or cols[j] > 1` (line 27)."]}
{"task_num": 1284, "task_title": "Minimum Number of Flips to Convert Binary Matrix to Zero Matrix", "func_name": "minFlips", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minFlips(self, mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    hash = self._getHash(mat, m, n)\n    if hash == 0:\n      return 0\n\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    step = 0\n    q = collections.deque([hash])\n    seen = {hash}\n\n    while q:\n      step += 1\n      for _ in range(len(q)):\n        curr = q.popleft()\n        for i in range(m):\n          for j in range(n):\n            next = curr ^ 1 << (i * n + j)\n            for dx, dy in dirs:\n              x = i + dx\n              y = j + dy\n              if x < 0 or x == m or y < 0 or y == n:\n                continue\n              next ^= 1 << (x * n + y)\n            if next == 0:\n              return step\n            if next in seen:\n              continue\n            q.append(next)\n            seen.add(next)\n\n    return -1\n\n  def _getHash(self, mat: List[List[int]], m: int, n: int) -> int:\n    hash = 0\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j]:\n          hash |= 1 << (i * n + j)\n    return hash\n", "tests": ["def test_minFlips():\n    solution = Solution()\n    mat = [[1, 1, 0], [0, 0, 0], [0, 0, 1]]\n    assert solution.minFlips(mat) == 2", "def test_minFlips():\n    solution = Solution()\n    mat = [[1, 0], [0, 0]]\n    assert solution.minFlips(mat) == -1", "def test_minFlips():\n    solution = Solution()\n    assert solution.minFlips([[0, 1], [1, 0]]) == -1", "def test_minFlips():\n    solution = Solution()\n    assert solution.minFlips([[1]]) == 0", "def test_minFlips():\n    solution = Solution()\n    assert solution.minFlips([[1, 1, 1], [1, 0, 1], [1, 1, 1]]) == -1"]}
{"task_num": 1293, "task_title": "Shortest Path in a Grid with Obstacles Elimination", "func_name": "shortestPath", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def shortestPath(self, grid: List[List[int]], k: int) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    if m == 1 and n == 1:\n      return 0\n\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    steps = 0\n    q = collections.deque([(0, 0, k)])\n    seen = {(0, 0, k)}\n\n    while q:\n      steps += 1\n      for _ in range(len(q)):\n        i, j, eliminate = q.popleft()\n        for l in range(4):\n          x = i + dirs[l][0]\n          y = j + dirs[l][1]\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if x == m - 1 and y == n - 1:\n            return steps\n          if grid[x][y] == 1 and eliminate == 0:\n            continue\n          newEliminate = eliminate - grid[x][y]\n          if (x, y, newEliminate) in seen:\n            continue\n          q.append((x, y, newEliminate))\n          seen.add((x, y, newEliminate))\n\n    return -1\n", "tests": ["```python\ndef test_shortestPath():\n    solution = Solution()\n    grid = [[0, 1], [1, 1]]\n    k = 2\n    assert solution.shortestPath(grid, k) == -1\n```\nThis test case will follow the target execution path: 'Line 37: ((x, y, newEliminate) in seen)' -> 'Line 27: (l in range(4))' -> 'Line 37: ((x, y, newEliminate) in seen)' -> 'Line 25: (_ in range(len(q)))' -> 'Line 27: (l in range(4))'. The function will return `-1` because it's not possible to reach the destination with the given constraints.", "def test_shortestPath():\n    solution = Solution()\n    assert solution.shortestPath([[1, 0], [0, 0]], 0) == -1", "def test_shortestPath():\n    solution = Solution()\n    grid = [[1, 1], [1, 1]]\n    k = 0\n    assert solution.shortestPath(grid, k) == -1", "def test_shortestPath():\n    solution = Solution()\n    assert(solution.shortestPath([[1, 1, 1], [0, 1, 0], [0, 1, 1]], 0) == -1)"]}
{"task_num": 1301, "task_title": "Number of Paths with Max Score", "func_name": "pathsWithMaxScore", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def pathsWithMaxScore(self, board: List[str]) -> List[int]:\n    kMod = 1_000_000_007\n    n = len(board)\n    dirs = ((0, 1), (1, 0), (1, 1))\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    count = [[0] * (n + 1) for _ in range(n + 1)]\n\n    dp[0][0] = 0\n    dp[n - 1][n - 1] = 0\n    count[n - 1][n - 1] = 1\n\n    for i in reversed(range(n)):\n      for j in reversed(range(n)):\n        if board[i][j] == 'S' or board[i][j] == 'X':\n          continue\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if dp[i][j] < dp[x][y]:\n            dp[i][j] = dp[x][y]\n            count[i][j] = count[x][y]\n          elif dp[i][j] == dp[x][y]:\n            count[i][j] += count[x][y]\n            count[i][j] %= kMod\n\n        if dp[i][j] != -1 and board[i][j] != 'E':\n          dp[i][j] += int(board[i][j])\n          dp[i][j] %= kMod\n\n    return [dp[0][0], count[0][0]]\n", "tests": ["def test_pathsWithMaxScore():\n    solution = Solution()\n    board = [\"9\", \"5\", \"X\", \"S\"]\n    assert solution.pathsWithMaxScore(board) == [14, 2]", "def test_pathsWithMaxScore():\n    board = [\"X\", \"1\", \"S\", \"9\"]\n    solution = Solution()\n    assert solution.pathsWithMaxScore(board) == [6, 2]", "```python\ndef test_pathsWithMaxScore():\n    solution = Solution()\n    board = ['1', 'X', '2', '3', '4']\n    assert solution.pathsWithMaxScore(board) == [7, 0]\n```", "def test_pathsWithMaxScore():\n    solution = Solution()\n    board = [\n        \"999\",\n        \"X99\",\n        \"S89\"\n    ]\n    assert solution.pathsWithMaxScore(board) == [2, 3]", "Here's the test case following the specified execution path:\n\n```python\ndef test_pathsWithMaxScore():\n    solution = Solution()\n    board = [\n        [\"9\", \"X\", \"5\"],\n        [\"S\", \"4\", \"E\"],\n        [\"2\", \"3\", \"X\"]\n    ]\n    assert solution.pathsWithMaxScore(board) == [16, 3]\n```"]}
{"task_num": 1334, "task_title": "Find the City With the Smallest Number of Neighbors at a Threshold Distance", "func_name": "findTheCity", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -> int:\n    ans = -1\n    minCitiesCount = n\n    dist = self._floydWarshall(n, edges, distanceThreshold)\n\n    for i in range(n):\n      citiesCount = sum(dist[i][j] <= distanceThreshold for j in range(n))\n      if citiesCount <= minCitiesCount:\n        ans = i\n        minCitiesCount = citiesCount\n\n    return ans\n\n  def _floydWarshall(self, n: int, edges: List[List[int]], distanceThreshold: int) -> List[List[int]]:\n    dist = [[distanceThreshold + 1] * n for _ in range(n)]\n\n    for i in range(n):\n      dist[i][i] = 0\n\n    for u, v, w in edges:\n      dist[u][v] = w\n      dist[v][u] = w\n\n    for k in range(n):\n      for i in range(n):\n        for j in range(n):\n          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    return dist\n", "tests": ["def test_findTheCity():\n    solution = Solution()\n    n = 5\n    edges = [[0,1,2],[0,2,4],[2,3,1],[1,3,3],[1,4,6],[3,4,1]]\n    distanceThreshold = 7\n    assert solution.findTheCity(n, edges, distanceThreshold) == 3", "def test_findTheCity():\n    solution = Solution()\n    assert solution.findTheCity(5, [[0,1,2],[0,2,3],[1,3,4],[1,4,5]], 7) == 0", "def test_findTheCity():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 2], [0, 2, 3], [1, 3, 4]]\n    distanceThreshold = 6", "def test_findTheCity():\n    solution = Solution()\n    n = 4\n    edges = [[0,1,2],[0,2,3],[1,3,1]]\n    distanceThreshold = 2\n    assert solution.findTheCity(n, edges, distanceThreshold) == 2"]}
{"task_num": 1340, "task_title": "Jump Game V", "func_name": "maxJumps", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxJumps(self, arr: List[int], d: int) -> int:\n    n = len(arr)\n    dp = [1] * n\n    stack = []\n\n    for i in range(n + 1):\n      while stack and (i == n or arr[stack[-1]] < arr[i]):\n        indices = [stack.pop()]\n        while stack and arr[stack[-1]] == arr[indices[0]]:\n          indices.append(stack.pop())\n        for j in indices:\n          if i < n and i - j <= d:\n            dp[i] = max(dp[i], dp[j] + 1)\n          if stack and j - stack[-1] <= d:\n            dp[stack[-1]] = max(dp[stack[-1]], dp[j] + 1)\n      stack.append(i)\n\n    return max(dp)\n", "tests": ["def test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([6,4,2,5,3,8], 1) == 4", "```python\ndef test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([3, 4, 2, 1], 1) == 2\n```\nThis test case covers the target execution path. The input `[3, 4, 2, 1]` with `d=1` will make the function go through the specified branches.", "def test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([3, 4, 2, 1], 2) == 3", "def test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([3, 4, 2, 1], 2) == 3", "def test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([3, 4, 2, 1], 0) == 3", "Here's the Python code for your requested test case:\n\n```python\ndef test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([5,6,4,7], 1) == 2\n```\n\nThis test case will trigger the target execution path by providing an array where each element is greater than its subsequent elements (except for the last one), ensuring that we jump from higher to lower indices in sequence. The input `d` is set to 1 to limit jumps to adjacent indices only, which forces us to check all possible jump scenarios as specified in your target execution path."]}
{"task_num": 1345, "task_title": "Jump Game IV", "func_name": "minJumps", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minJumps(self, arr: List[int]) -> int:\n    n = len(arr)\n    graph = collections.defaultdict(list)\n    step = 0\n    q = collections.deque([0])\n    seen = {0}\n\n    for i, a in enumerate(arr):\n      graph[a].append(i)\n\n    while q:\n      for _ in range(len(q)):\n        i = q.popleft()\n        if i == n - 1:\n          return step\n        seen.add(i)\n        u = arr[i]\n        if i + 1 < n:\n          graph[u].append(i + 1)\n        if i - 1 >= 0:\n          graph[u].append(i - 1)\n        for v in graph[u]:\n          if v in seen:\n            continue\n          q.append(v)\n        graph[u].clear()\n      step += 1\n", "tests": ["def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([1, 0, 0]) == 2", "def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([1, 3, 6, 4, 1, 2]) == 3", "def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([5, 6, 4, 1, 2, 8, 9, 3]) == 7", "def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([10,9,8,7,6,5,4,3,2,1]) == 5", "def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([3,6,4,3,9,1]) == 1"]}
{"task_num": 1377, "task_title": "Frog Position After T Seconds", "func_name": "frogPosition", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n    tree = [[] for _ in range(n + 1)]\n    q = collections.deque([1])\n    seen = [False] * (n + 1)\n    prob = [0] * (n + 1)\n\n    prob[1] = 1\n    seen[1] = True\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    for _ in range(t):\n      for _ in range(len(q)):\n        a = q.popleft()\n        nChildren = sum(not seen[b] for b in tree[a])\n        for b in tree[a]:\n          if seen[b]:\n            continue\n          seen[b] = True\n          prob[b] = prob[a] / nChildren\n          q.append(b)\n        if nChildren > 0:\n          prob[a] = 0\n\n    return prob[target]\n", "tests": ["def test_frogPosition():\n    solution = Solution()\n    assert solution.frogPosition(3, [[1,2], [1,3]], 2, 2) == pytest.approx(0.5, rel=1e-5)", "def test_frogPosition():\n    solution = Solution()\n    assert solution.frogPosition(n=4, edges=[[1,2],[1,3],[1,4]], t=1, target=2) == 0.5", "def test_frogPosition():\n    solution = Solution()\n    assert abs(solution.frogPosition(4, [[1,2], [1,3], [1,4]], 2, 3) - 0.5) < 0.00001", "def test_frogPosition():\n    solution = Solution()\n    assert solution.frogPosition(n=3, edges=[[1,2],[2,3]], t=2, target=3) == 0.5"]}
{"task_num": 1417, "task_title": "Reformat The String", "func_name": "reformat", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def reformat(self, s: str) -> str:\n    A=[]\n    for c in s:\n      if c.isalpha():\n        A.append(c)\n    B=[]\n    for c in s:\n      if c.isdigit():\n        B.append(c)\n\n    if len(A) < len(B):\n      A, B = B, A\n    if len(A) - len(B) > 1:\n      return ''\n\n    ans = []\n\n    for i in range(len(B)):\n      ans.append(A[i])\n      ans.append(B[i])\n\n    if len(A) == len(B) + 1:\n      ans.append(A[-1])\n    return ''.join(ans)\n", "tests": ["def test_reformat():\n    solution = Solution()\n    assert solution.reformat(\"abc\") == \"a_b_c\"", "```python\ndef test_reformat():\n    solution = Solution()\n    assert solution.reformat(\"a\") == \"a\"\n```", "def test_reformat():\n    solution = Solution()\n    assert solution.reformat(\"aabb\") == \"ababa\"", "def test_reformat():\n    solution = Solution()\n    assert solution.reformat(\"aabbcc\") == \"abcabc\"", "def test_reformat():\n    solution = Solution()\n    assert solution.reformat(\"ab12\") == \"a1b2\"", "def test_reformat():\n    solution = Solution()\n    assert solution.reformat(\"a1b2\") == \"ab12\""]}
{"task_num": 1462, "task_title": "Course Schedule IV", "func_name": "checkIfPrerequisite", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:\n    graph = [[] for _ in range(numCourses)]\n    isPrerequisite = [[False] * numCourses for _ in range(numCourses)]\n\n    for u, v in prerequisites:\n      graph[u].append(v)\n\n    for i in range(numCourses):\n      self._dfs(graph, i, isPrerequisite[i])\n\n    return [isPrerequisite[u][v] for u, v in queries]\n\n  def _dfs(self, graph: List[List[int]], u: int, used: List[bool]) -> None:\n    for v in graph[u]:\n      if used[v]:\n        continue\n      used[v] = True\n      self._dfs(graph, v, used)\n", "tests": ["def test_checkIfPrerequisite():\n    solution = Solution()\n    numCourses, prerequisites, queries = 3, [[0, 1], [1, 2]], [[1, 2]]\n    assert solution.checkIfPrerequisite(numCourses, prerequisites, queries) == [False]", "def test_checkIfPrerequisite():\n    solution = Solution()\n    assert solution.checkIfPrerequisite(3, [[1,0],[2,1]], [[0,1]]) == [True]", "def test_checkIfPrerequisite():\n    solution = Solution()\n    assert solution.checkIfPrerequisite(3, [[0, 1], [0, 2]], [[1, 0]]) == [False]\n    assert solution.checkIfPrerequisite(4, [[1, 0], [2, 0], [3, 1], [3, 2]], [[1, 3]]) == [False]\n    assert solution.checkIfPrerequisite(5, [[0, 1], [1, 2], [2, 3], [3, 4]], [[1, 2], [2, 3], [4, 0]]) == [True, True, False]", "Here is a test case that covers the mentioned execution path:\n\n```python\ndef test_checkIfPrerequisite():\n    solution = Solution()\n    assert solution.checkIfPrerequisite(4, [[0, 1], [0, 2], [1, 3], [2, 3]], [[0, 1], [0, 2], [1, 2]]) == [True, True, False]\n```"]}
{"task_num": 1489, "task_title": "Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree", "func_name": "findCriticalAndPseudoCriticalEdges", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Union\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n    criticalEdges = []\n    pseudoCriticalEdges = []\n\n    for i in range(len(edges)):\n      edges[i].append(i)\n\n    edges.sort(key=lambda x: x[2])\n\n    def getMSTWeight(firstEdge: List[int], deletedEdgeIndex: int) -> Union[int, float]:\n      mstWeight = 0\n      uf = UnionFind(n)\n\n      if firstEdge:\n        uf.unionByRank(firstEdge[0], firstEdge[1])\n        mstWeight += firstEdge[2]\n\n      for u, v, weight, index in edges:\n        if index == deletedEdgeIndex:\n          continue\n        if uf.find(u) == uf.find(v):\n          continue\n        uf.unionByRank(u, v)\n        mstWeight += weight\n\n      root = uf.find(0)\n      if any(uf.find(i) != root for i in range(n)):\n        return math.inf\n\n      return mstWeight\n\n    mstWeight = getMSTWeight([], -1)\n\n    for edge in edges:\n      index = edge[3]\n      if getMSTWeight([], index) > mstWeight:\n        criticalEdges.append(index)\n      elif getMSTWeight(edge, -1) == mstWeight:\n        pseudoCriticalEdges.append(index)\n\n    return [criticalEdges, pseudoCriticalEdges]\n", "tests": ["def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    assert solution.findCriticalAndPseudoCriticalEdges(4, [[0, 1, 1], [1, 2, 1], [2, 3, 1], [0, 3, 1], [0, 2, 5]]) == [[0], [1]]", "Here's the test case for the provided execution path:\n\n```python\ndef test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 5\n    edges = [\n        [0, 1, 3],\n        [0, 2, 4],\n        [1, 2, 6],\n        [1, 3, 1],\n        [2, 3, 7],\n        [2, 4, 9],\n        [3, 4, 2]\n    ]\n    assert solution.findCriticalAndPseudoCriticalEdges(n, edges) == [[], [5]]\n```\n\nIn this test case:\n- `n` is set to 5.\n- The `edges` list contains 7 edges with varying weights and indices.\n- When executed with the given input, the function follows the target execution path, and the expected output is `[[], [5]]`, indicating that edge index 5 is a pseudo-critical edge.", "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    assert solution.findCriticalAndPseudoCriticalEdges(5, [[0, 1, 3], [0, 2, 5], [2, 4, 8], [2, 3, 7]]) == ([[0]], [])", "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 3], [1, 2, 1], [2, 3, 2], [0, 2, 6], [1, 3, 5], [0, 3, 7]]\n    assert solution.findCriticalAndPseudoCriticalEdges(n, edges) == [[4], [1]]"]}
{"task_num": 1573, "task_title": "Number of Ways to Split a String", "func_name": "numWays", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numWays(self, s: str) -> int:\n    kMod = 1_000_000_007\n    ones = s.count('1')\n    if ones % 3 != 0:\n      return 0\n    if ones == 0:\n      n = len(s)\n      return (n - 1) * (n - 2) // 2 % kMod\n\n    s1End = -1\n    s2Start = -1\n    s2End = -1\n    s3Start = -1\n    onesSoFar = 0\n\n    for i, c in enumerate(s):\n      if c == '1':\n        onesSoFar += 1\n      if s1End == -1 and onesSoFar == ones // 3:\n        s1End = i\n      elif s2Start == -1 and onesSoFar == ones // 3 + 1:\n        s2Start = i\n      if s2End == -1 and onesSoFar == ones // 3 * 2:\n        s2End = i\n      elif s3Start == -1 and onesSoFar == ones // 3 * 2 + 1:\n        s3Start = i\n\n    return (s2Start - s1End) * (s3Start - s2End) % kMod\n", "tests": ["```python\ndef test_numWays():\n    solution = Solution()\n    assert solution.numWays(\"101101\") == 2\n```\nThis test case covers the target execution path by setting 's' to \"101101\", which has three ones. On the first iteration of the loop (line 27), it will satisfy the condition on line 30, and set s1End to 2. On the second iteration, it will increment onesSoFar but not satisfy any conditions, then on the third iteration it will satisfy the condition on line 32, setting s2Start to 4. The function will return (s2Start - s1End) * (s3Start - s2End) modulo kMod, which in this case is 2.", "def test_numWays():\n    solution = Solution()\n    assert solution.numWays('11100') == 3", "```python\ndef test_numWays():\n    solution = Solution()\n    assert solution.numWays(\"\") == 0\n```\n\nThis test case checks the execution path where `ones` is 0.", "def test_numWays():\n    solution = Solution()\n    assert solution.numWays(\"12\") == 0"]}
{"task_num": 1574, "task_title": "Shortest Subarray to be Removed to Make Array Sorted", "func_name": "findLengthOfShortestSubarray", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n    n = len(arr)\n    l = 0\n    r = n - 1\n\n    while l < n - 1 and arr[l + 1] >= arr[l]:\n      l += 1\n    while r > 0 and arr[r - 1] <= arr[r]:\n      r -= 1\n    ans = min(n - 1 - l, r)\n\n    i = l\n    j = n - 1\n    while i >= 0 and j >= r and j > i:\n      if arr[i] <= arr[j]:\n        j -= 1\n      else:\n        i -= 1\n      ans = min(ans, j - i)\n\n    return ans\n", "tests": ["def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([4,3,2,7,8,9,5]) == 3", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([5, 2, 4, 1, 3]) == 3", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([1, 3, 5, 7]) == 0", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([1, 2, 3, 4]) == 0"]}
{"task_num": 1579, "task_title": "Remove Max Number of Edges to Keep Graph Fully Traversable", "func_name": "maxNumEdgesToRemove", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    self.count -= 1\n    return True\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\n    alice = UnionFind(n)\n    bob = UnionFind(n)\n    requiredEdges = 0\n\n    for type, u, v in sorted(edges, reverse=True):\n      u -= 1\n      v -= 1\n      if type == 3:\n        if alice.unionByRank(u, v) | bob.unionByRank(u, v):\n          requiredEdges += 1\n      elif type == 2:\n        if bob.unionByRank(u, v):\n          requiredEdges += 1\n      else:\n        if alice.unionByRank(u, v):\n          requiredEdges += 1\n\n    if alice.count == 1 and bob.count == 1:\n        return len(edges) - requiredEdges\n    else:\n        return -1\n", "tests": ["def test_maxNumEdgesToRemove():\n    solution = Solution()\n    assert solution.maxNumEdgesToRemove(3, [[2, 1, 2], [3, 0, 1], [2, 2, 0]]) == -1", "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    edges = [[3,1,2],[2,2,4],[1,3,4]]\n    assert(solution.maxNumEdgesToRemove(4,edges) == 1)", "Here's a Python function that tests the `maxNumEdgesToRemove` function according to the specified execution path:\n\n```python\ndef test_maxNumEdgesToRemove():\n    solution = Solution()\n\n    edges = [\n        [3, 1, 2],\n        [1, 2, 3],\n        [3, 4, 5],\n        [2, 5, 6],\n        [2, 7, 8]\n    ]\n\n    assert solution.maxNumEdgesToRemove(9, edges) == -1\n```", "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    assert solution.maxNumEdgesToRemove(3, [[3, 0, 1], [2, 1, 2]]) == -1", "def test_maxNumEdgesToRemove():\n    edges = [[3, 1, 2], [2, 2, 3], [1, 3, 4]]\n    solution = Solution()\n    assert solution.maxNumEdgesToRemove(4, edges) == -1", "Here's a test case for the `maxNumEdgesToRemove` function that covers the target execution path:\n\n```python\ndef test_maxNumEdgesToRemove():\n    solution = Solution()\n    edges = [[3, 1, 2], [1, 3, 4], [2, 3, 5], [2, 4, 6]]\n    assert solution.maxNumEdgesToRemove(6, edges) == -1\n```\n\nIn this test case:\n\n- The edge `(3, 1, 2)` causes `alice.unionByRank(u, v) | bob.unionByRank(u, v)` to return `True` and increases the required edges.\n- The edge `(1, 3, 4)` does not satisfy `type == 3`, so it's skipped.\n- The edge `(2, 3, 5)` satisfies `type == 2` and causes `bob.unionByRank(u, v)` to return `True`, increasing the required edges.\n- The edge `(2, 4, 6)` causes `self.id[u] != u` in line 33 to be False for node 2.\n- After processing all edges, Alice and Bob cannot fully traverse the graph, so the function returns `-1`."]}
{"task_num": 1582, "task_title": "Special Positions in a Binary Matrix", "func_name": "numSpecial", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numSpecial(self, mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    ans = 0\n    rowOnes = [0] * m\n    colOnes = [0] * n\n\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j] == 1:\n          rowOnes[i] += 1\n          colOnes[j] += 1\n\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j] == 1 and rowOnes[i] == 1 and colOnes[j] == 1:\n          ans += 1\n\n    return ans\n", "tests": ["```python\ndef test_numSpecial():\n    solution = Solution()\n    assert solution.numSpecial([[1,0,0],[0,1,0],[0,0,1]]) == 3\n```\nThis test case covers the target execution path by providing a matrix with exactly one '1' in each row and column. The function should return 3 because there are three special positions in this matrix.", "```python\ndef test_numSpecial():\n    solution = Solution()\n    assert solution.numSpecial([[1,0,0],[0,0,0],[0,0,0]]) == 3\n```\nThis test case will satisfy the target execution path as follows:\n- `i` is set to `0`, so `mat[0]` contains a `1`.\n- `j` ranges from `0` to `2`, so all positions in row `0` are checked.\n- The next `i` is `1`, so `mat[1]` contains no `1`s.\n- `j` again ranges from `0` to `2`, but this time none of the positions have a `1`.\n- Finally, when `i` is `2`, all positions in row `2` are checked and there's one more `1`.", "def test_numSpecial():\n    solution = Solution()\n    assert solution.numSpecial([[1,0,0],[0,0,1],[1,0,0]]) == 3", "def test_numSpecial():\n    solution = Solution()\n    mat = [[0, 0, 0], [1, 0, 0], [0, 0, 0]]\n    assert solution.numSpecial(mat) == 1"]}
{"task_num": 1583, "task_title": "Count Unhappy Friends", "func_name": "unhappyFriends", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\n    ans = 0\n    matches = [0] * n\n    prefer = [{} for _ in range(n)]\n\n    for x, y in pairs:\n      matches[x] = y\n      matches[y] = x\n\n    for i in range(n):\n      for j in range(n - 1):\n        prefer[i][preferences[i][j]] = j\n\n    for x in range(n):\n      for u in prefer[x].keys():\n        y = matches[x]\n        v = matches[u]\n        if prefer[x][u] < prefer[x][y] and prefer[u][x] < prefer[u][v]:\n          ans += 1\n          break\n\n    return ans\n", "tests": ["def test_unhappyFriends():\n    solution = Solution()\n    assert(solution.unhappyFriends(4, [[1, 3, 0, 2], [2, 3, 1, 0], [1, 2, 3, 0], [2, 0, 3, 1]], [[0, 1], [2, 3]]) == 2)", "def test_unhappyFriends():\n    solution = Solution()\n    assert solution.unhappyFriends(\n        n=4,\n        preferences=[[3, 2, 0, 1], [2, 3, 1, 0], [1, 0, 3, 2], [0, 1, 2, 3]],\n        pairs=[[0, 1], [2, 3]]\n    ) == 2", "def test_unhappyFriends():\n    solution = Solution()\n    preferences = [[0, 1], [1, 0]]\n    pairs = [[0, 1]]\n    assert solution.unhappyFriends(2, preferences, pairs) == 0", "def test_unhappyFriends():\n    solution = Solution()\n    n = 4\n    preferences = [[1, 3, 0, 2], [2, 0, 1, 3], [0, 2, 3, 1], [1, 0, 2, 3]]\n    pairs = [[0, 1], [2, 3]]\n    assert solution.unhappyFriends(n, preferences, pairs) == 2"]}
{"task_num": 1591, "task_title": "Strange Printer II", "func_name": "isPrintable", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import Enum\n\n\nclass State(Enum):\n  kInit = 0\n  kVisiting = 1\n  kVisited = 2\n\n\nclass Solution:\n  def isPrintable(self, targetGrid: List[List[int]]) -> bool:\n    kMaxColor = 60\n    m = len(targetGrid)\n    n = len(targetGrid[0])\n\n    graph = [set() for _ in range(kMaxColor + 1)]\n\n    for color in range(1, kMaxColor + 1):\n      minI = m\n      minJ = n\n      maxI = -1\n      maxJ = -1\n      for i in range(m):\n        for j in range(n):\n          if targetGrid[i][j] == color:\n            minI = min(minI, i)\n            minJ = min(minJ, j)\n            maxI = max(maxI, i)\n            maxJ = max(maxJ, j)\n\n      for i in range(minI, maxI + 1):\n        for j in range(minJ, maxJ + 1):\n          if targetGrid[i][j] != color:\n            graph[color].add(targetGrid[i][j])\n\n    states = [State.kInit] * (kMaxColor + 1)\n\n    def hasCycle(u: int) -> bool:\n      if states[u] == State.kVisiting:\n        return True\n      if states[u] == State.kVisited:\n        return False\n\n      states[u] = State.kVisiting\n      if any(hasCycle(v) for v in graph[u]):\n        return True\n      states[u] = State.kVisited\n\n      return False\n\n    for i in range(1, kMaxColor + 1):\n      if hasCycle(i):\n        return False\n    return True\n", "tests": ["```python\ndef test_isPrintable():\n    solution = Solution()\n    targetGrid = [[60, 59], [61, 62]]\n    assert solution.isPrintable(targetGrid) == False\n```\nThis test case covers the execution path of four nested loops in `isPrintable` function. The first two calls to `j in range(n)` are skipped because `j` is already equal to `n`. The third call enters the loop and skips the inner loop because `i` is already equal to `m`. Finally, the fourth call enters both loops and satisfies the condition for calculating the minimum and maximum values of `i` and `j`.", "def test_isPrintable():\n    solution = Solution()\n    assert solution.isPrintable([[1, 2], [2, 1]])", "def test_isPrintable():\n    solution = Solution()\n    assert not solution.isPrintable([[60, 59], [58, 57]])", "def test_isPrintable():\n    solution = Solution()\n    assert solution.isPrintable([[1,2],[3,4]]), True", "def test_isPrintable():\n    solution = Solution()\n    assert solution.isPrintable([[60, 59, 58], [57, 56, 55], [54, 53, 52]])"]}
{"task_num": 1604, "task_title": "Alert Using Same Key-Card Three or More Times in a One Hour Period", "func_name": "alertNames", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n    nameToMinutes = collections.defaultdict(list)\n\n    for name, time in zip(keyName, keyTime):\n      minutes = self._getMinutes(time)\n      nameToMinutes[name].append(minutes)\n\n    res=[]\n    for name, minutes in nameToMinutes.items():\n      if self._hasAlert(minutes):\n        res.append(name)\n    return sorted(res)\n\n  def _hasAlert(self, minutes: List[int]) -> bool:\n    if len(minutes) > 70:\n      return True\n    minutes.sort()\n    for i in range(2, len(minutes)):\n      if minutes[i - 2] + 60 >= minutes[i]:\n        return True\n    return False\n\n  def _getMinutes(self, time: str) -> int:\n    h, m = map(int, time.split(':'))\n    return 60 * h + m\n", "tests": ["def test_alertNames():\n    solution = Solution()\n    assert solution.alertNames([\"daniel\",\"daniel\",\"daniel\",\"luis\",\"luis\",\"luis\",\"luis\"], [\"07:42\",\"07:19\",\"08:05\",\"06:50\",\"06:52\",\"06:53\",\"07:25\"]) == [\"luis\"]", "def test_alertNames():\n    solution = Solution()\n    keyName = [\"daniel\", \"daniel\", \"daniel\"]\n    keyTime = [\"08:00\", \"09:00\", \"10:00\"]\n    assert solution.alertNames(keyName, keyTime) == [\"daniel\"]", "def test_alertNames():\n    solution = Solution()\n    keyName = [\"daniel\", \"daniel\", \"daniel\", \"lucas\", \"lucas\", \"lucas\"]\n    keyTime = [\"10:00\", \"10:40\", \"11:00\", \"09:00\", \"09:30\", \"12:00\"]\n    assert solution.alertNames(keyName, keyTime) == ['daniel', 'lucas']", "def test_alertNames():\n    solution = Solution()\n    assert solution.alertNames([\"daniel\",\"daniel\",\"daniel\",\"luis\",\"luis\",\"luis\",\"luis\"], [\"09:01\",\"09:49\",\"10:00\",\"12:01\",\"13:00\",\"15:01\",\"18:00\"]) == ['daniel', 'luis']"]}
{"task_num": 1615, "task_title": "Maximal Network Rank", "func_name": "maximalNetworkRank", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\n    degrees = [0] * n\n\n    for u, v in roads:\n      degrees[u] += 1\n      degrees[v] += 1\n\n    maxDegree1 = 0\n    maxDegree2 = 0\n    for degree in degrees:\n      if degree > maxDegree1:\n        maxDegree2 = maxDegree1\n        maxDegree1 = degree\n      elif degree > maxDegree2:\n        maxDegree2 = degree\n\n    countMaxDegree1 = 0\n    countMaxDegree2 = 0\n    for degree in degrees:\n      if degree == maxDegree1:\n        countMaxDegree1 += 1\n      elif degree == maxDegree2:\n        countMaxDegree2 += 1\n\n    if countMaxDegree1 == 1:\n      edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree2) + self._getEdgeCount(roads, degrees, maxDegree2, maxDegree1)\n      return maxDegree1 + maxDegree2 - (countMaxDegree2 == edgeCount)\n    else:\n      edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree1)\n      maxPossibleEdgeCount = countMaxDegree1 * (countMaxDegree1 - 1) // 2\n      return 2 * maxDegree1 - (maxPossibleEdgeCount == edgeCount)\n\n  def _getEdgeCount(self, roads: List[List[int]], degrees: List[int], degreeU: int, degreeV: int) -> int:\n    edgeCount = 0\n    for u, v in roads:\n      if degrees[u] == degreeU and degrees[v] == degreeV:\n        edgeCount += 1\n    return edgeCount\n", "tests": ["def test_maximalNetworkRank():\n    solution = Solution()\n    roads = [[0, 1], [0, 2], [1, 3], [1, 4]]\n    assert solution.maximalNetworkRank(5, roads) == 5", "def test_maximalNetworkRank():\n    solution = Solution()\n    assert solution.maximalNetworkRank(4, [[0,1],[0,2],[2,3]]) == 3", "def test_maximalNetworkRank():\n    solution = Solution()\n    assert(solution.maximalNetworkRank(5,[[0,1],[0,2],[2,3],[2,4]]) == 4)", "def test_maximalNetworkRank():\n    solution = Solution()\n    assert solution.maximalNetworkRank(4, [[0,1],[0,2],[1,3]]) == 4", "def test_maximalNetworkRank():\n    solution = Solution()\n    assert solution.maximalNetworkRank(5, [[0,1],[0,2],[0,3],[1,2],[1,4]]) == 4"]}
{"task_num": 1616, "task_title": "Split Two Strings to Make Palindrome", "func_name": "checkPalindromeFormation", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def checkPalindromeFormation(self, a: str, b: str) -> bool:\n    return self._check(a, b) or self._check(b, a)\n\n  def _check(self, a: str, b: str) -> bool:\n    i, j = 0, len(a) - 1\n    while i < j:\n      if a[i] != b[j]:\n        return self._isPalindrome(a, i, j) or self._isPalindrome(b, i, j)\n      i += 1\n      j -= 1\n    return True\n\n  def _isPalindrome(self, s: str, i: int, j: int) -> bool:\n    while i < j:\n      if s[i] != s[j]:\n        return False\n      i += 1\n      j -= 1\n    return True\n", "tests": ["def test_checkPalindromeFormation():\n    solution = Solution()\n    assert not solution.checkPalindromeFormation(\"abc\", \"bca\")", "def test_checkPalindromeFormation():\n    solution = Solution()\n    assert not solution.checkPalindromeFormation(\"ab\", \"ba\")", "def test_checkPalindromeFormation():\n    solution = Solution()\n    assert solution.checkPalindromeFormation(\"abcd\", \"dcba\")", "def test_checkPalindromeFormation():\n    solution = Solution()\n    assert not solution.checkPalindromeFormation('abc', 'cba')"]}
{"task_num": 1617, "task_title": "Count Subtrees With Max Distance Between Cities", "func_name": "countSubgraphsForEachDiameter", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:\n    maxMask = 1 << n\n    dist = self._floydWarshall(n, edges)\n    ans = [0] * (n - 1)\n\n    for mask in range(maxMask):\n      maxDist = self._getMaxDist(mask, dist, n)\n      if maxDist > 0:\n        ans[maxDist - 1] += 1\n\n    return ans\n\n  def _floydWarshall(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n    dist = [[n] * n for _ in range(n)]\n\n    for i in range(n):\n      dist[i][i] = 0\n\n    for u, v in edges:\n      dist[u - 1][v - 1] = 1\n      dist[v - 1][u - 1] = 1\n\n    for k in range(n):\n      for i in range(n):\n        for j in range(n):\n          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    return dist\n\n  def _getMaxDist(self, mask: int, dist: List[List[int]], n: int) -> int:\n    maxDist = 0\n    edgeCount = 0\n    cityCount = 0\n    for u in range(n):\n      if (mask >> u) & 1 == 0:\n        continue\n      cityCount += 1\n      for v in range(u + 1, n):\n        if (mask >> v) & 1 == 0:\n          continue\n        if dist[u][v] == 1:\n          edgeCount += 1\n        maxDist = max(maxDist, dist[u][v])\n\n    if edgeCount == cityCount - 1:\n      return maxDist\n    else:\n      return 0\n", "tests": ["def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    n = 4\n    edges = [[1, 2], [2, 3], [3, 4]]\n    assert solution.countSubgraphsForEachDiameter(n, edges) == [0, 0, 1]", "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    assert solution.countSubgraphsForEachDiameter(3, [[1, 2], [1, 3]]) == [0, 0]", "```python\ndef test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    n = 4\n    edges = [[1,2], [2,3], [3,4]]\n    assert solution.countSubgraphsForEachDiameter(n, edges) == [1, 0, 0]\n```", "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    assert solution.countSubgraphsForEachDiameter(6, [[1, 2], [1, 3], [1, 4], [1, 5]]) == [0, 1, 0, 1, 0]\n    assert solution._getMaxDist((1 << 3) | (1 << 5), [[0, 0, float('inf'), float('inf'), float('inf')], [float('inf'), 0, 2, float('inf'), float('inf')], [float('inf'), float('inf'), 0, 1, float('inf')], [float('inf'), float('inf'), float('inf'), 0, 1], [float('inf'), float('inf'), float('inf'), float('inf'), 0]], 6) == 2", "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    assert solution.countSubgraphsForEachDiameter(3, [[1,2], [2,3]]) == [0, 1]", "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    assert solution.countSubgraphsForEachDiameter(4, [[1, 2], [1, 3], [2, 3]]) == [0, 0, 1]"]}
{"task_num": 1627, "task_title": "Graph Connectivity With Threshold", "func_name": "areConnected", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def areConnected(self, n: int, threshold: int, queries: List[List[int]]) -> List[bool]:\n    uf = UnionFind(n + 1)\n\n    for z in range(threshold + 1, n + 1):\n      for x in range(z * 2, n + 1, z):\n        uf.unionByRank(z, x)\n\n    return [uf.find(a) == uf.find(b) for a, b in queries]\n", "tests": ["def test_areConnected():\n    solution = Solution()\n    assert solution.areConnected(8, 2, [(3, 5), (6, 7)]) == [True, True]", "def test_areConnected():\n    solution = Solution()\n    assert(solution.areConnected(n=7, threshold=2, queries=[[3,6], [4,5]]))", "def test_areConnected():\n    solution = Solution()\n    assert solution.areConnected(6, 2, [[1, 5], [2, 4], [3, 5]]) == [False, True, False]\n\ntest_areConnected()", "def test_areConnected():\n    solution = Solution()\n    assert solution.areConnected(6, 2, [(5, 4), (5, 3), (4, 3)]) == [False, False, True]"]}
{"task_num": 1631, "task_title": "Path With Minimum Effort", "func_name": "minimumEffortPath", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumEffortPath(self, heights: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(heights)\n    n = len(heights[0])\n    diff = [[math.inf] * n for _ in range(m)]\n    seen = set()\n\n    minHeap = [(0, 0, 0)]\n    diff[0][0] = 0\n\n    while minHeap:\n      d, i, j = heapq.heappop(minHeap)\n      if i == m - 1 and j == n - 1:\n        return d\n      seen.add((i, j))\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if (x, y) in seen:\n          continue\n        newDiff = abs(heights[i][j] - heights[x][y])\n        maxDiff = max(diff[i][j], newDiff)\n        if diff[x][y] > maxDiff:\n          diff[x][y] = maxDiff\n          heapq.heappush(minHeap, (diff[x][y], x, y))\n", "tests": ["def test_minimumEffortPath():\n    solution = Solution()\n    assert solution.minimumEffortPath([[1, 2], [3, 4]]) == 1", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [\n        [1, 2, 2],\n        [3, 8, 2],\n        [5, 3, 5]\n    ]\n    assert solution.minimumEffortPath(heights) == 2", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[1, 10, 6], [12, 3, 9]]\n    assert solution.minimumEffortPath(heights) == 5", "```python\ndef test_minimumEffortPath():\n    solution = Solution()\n    heights = [[1, 2], [0, 3]]\n    solution.minimumEffortPath(heights)\n```", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    assert solution.minimumEffortPath(heights) == 2", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[1, 2], [3, 4]]\n    assert solution.minimumEffortPath(heights) == 0"]}
{"task_num": 1632, "task_title": "Rank Transform of a Matrix", "func_name": "matrixRankTransform", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self):\n    self.id = {}\n\n  def union(self, u: int, v: int) -> None:\n    self.id.setdefault(u, u)\n    self.id.setdefault(v, v)\n    i = self._find(u)\n    j = self._find(v)\n    if i != j:\n      self.id[i] = j\n\n  def getGroupIdToValues(self) -> Dict[int, List[int]]:\n    groupIdToValues = collections.defaultdict(list)\n    for u in self.id.keys():\n      groupIdToValues[self._find(u)].append(u)\n    return groupIdToValues\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def matrixRankTransform(self, matrix: List[List[int]]) -> List[List[int]]:\n    m = len(matrix)\n    n = len(matrix[0])\n    ans = [[0] * n for _ in range(m)]\n    valToGrids = collections.defaultdict(list)\n    maxRankSoFar = [0] * (m + n)\n\n    for i, row in enumerate(matrix):\n      for j, val in enumerate(row):\n        valToGrids[val].append((i, j))\n\n    for _, grids in sorted(valToGrids.items()):\n      uf = UnionFind()\n      for i, j in grids:\n        uf.union(i, j + m)\n      for values in uf.getGroupIdToValues().values():\n        maxRank = max(maxRankSoFar[i] for i in values)\n        for i in values:\n          maxRankSoFar[i] = maxRank + 1\n      for i, j in grids:\n        ans[i][j] = maxRankSoFar[i]\n\n    return ans\n", "tests": ["```python\ndef test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[3,2,1],[0,1,2],[1,2,3]]\n    assert solution.matrixRankTransform(matrix) == [[3,2,1],[1,2,3],[2,3,1]]\n```", "```\ndef test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[3,5],[1,7]]\n    assert solution.matrixRankTransform(matrix) == [[2,4],[1,5]]\n```", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [\n        [7, 4, 3],\n        [1, 8, 5],\n        [2, 6, 9]\n    ]\n    assert solution.matrixRankTransform(matrix) == [[3, 3, 1], [1, 2, 1], [1, 1, 3]]", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[1]]\n    assert solution.matrixRankTransform(matrix) == [[1]]", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[2, 3], [1, 2]]\n    solution.matrixRankTransform(matrix)", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[7, 7], [1, 1]]\n    assert solution.matrixRankTransform(matrix) == [[2, 1]]"]}
{"task_num": 1654, "task_title": "Minimum Jumps to Reach Home", "func_name": "minimumJumps", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import Enum\n\n\nclass Direction(Enum):\n  kForward = 0\n  kBackward = 1\n\n\nclass Solution:\n  def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\n    furthest = max(x + a + b, max(pos + a + b for pos in forbidden))\n    seenForward = {pos for pos in forbidden}\n    seenBackward = {pos for pos in forbidden}\n\n    q = collections.deque([(Direction.kForward, 0)])\n\n    ans = 0\n    while q:\n      for _ in range(len(q)):\n        dir, pos = q.popleft()\n        if pos == x:\n          return ans\n        forward = pos + a\n        backward = pos - b\n        if forward <= furthest and forward not in seenForward:\n          seenForward.add(forward)\n          q.append((Direction.kForward, forward))\n        if dir == Direction.kForward and backward >= 0 and backward not in seenBackward:\n          seenBackward.add(backward)\n          q.append((Direction.kBackward, backward))\n      ans += 1\n\n    return -1\n", "tests": ["def test_minimumJumps():\n    solution = Solution()\n    forbidden = [3]\n    a, b, x = 5, 2, 6\n    assert solution.minimumJumps(forbidden, a, b, x) == 1", "```python\ndef test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([10], 5, 3, 20) == -1\n```\nThis test case covers the target execution path by providing a forbidden position (10) that is between the bug's starting position (0) and its home position (20), with jump distances of `a=5` forward and `b=3` backward. The function should return `-1`, indicating no possible sequence of jumps to reach the bug's home.", "```python\ndef test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([5], 2, 3, 6) == -1\n```\nThis test case will follow the target execution path as described. The forbidden position is 5, and the bug cannot reach its home (position 6) with the given jump rules, so it should return `-1`.", "def test_minimumJumps():\n    forbidden = [4, 5]\n    a = 3\n    b = 1\n    x = 7\n    solution = Solution()\n    assert solution.minimumJumps(forbidden, a, b, x) == -1", "def test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([1, 2], 3, 2, 5) == -1", "def test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([], 3, 2, 10) == 4"]}
{"task_num": 1655, "task_title": "Distribute Repeating Integers", "func_name": "canDistribute", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\n    freqs = list(collections.Counter(nums).values())\n    validDistribution = self._getValidDistribution(freqs, quantity)\n    n = len(freqs)\n    m = len(quantity)\n    maxMask = 1 << m\n    dp = [[False] * maxMask for _ in range(n + 1)]\n    dp[n][maxMask - 1] = True\n\n    for i in range(n - 1, -1, -1):\n      for mask in range(maxMask):\n        dp[i][mask] = dp[i + 1][mask]\n        availableMask = ~mask & (maxMask - 1)\n        submask = availableMask\n        while submask > 0:\n          if validDistribution[i][submask]:\n            dp[i][mask] = dp[i][mask] or dp[i + 1][mask | submask]\n          submask = (submask - 1) & availableMask\n\n    return dp[0][0]\n\n  def _getValidDistribution(self, freqs: List[int], quantity: List[int]) -> List[List[bool]]:\n    maxMask = 1 << len(quantity)\n    validDistribution = [[False] * maxMask for _ in range(len(freqs))]\n    for i, freq in enumerate(freqs):\n      for mask in range(maxMask):\n        if freq >= self._getQuantitySum(quantity, mask):\n          validDistribution[i][mask] = True\n    return validDistribution\n\n  def _getQuantitySum(self, quantity: List[int], mask: int) -> int:\n    res=[]\n    for i, q in enumerate(quantity):\n      if mask >> i & 1:\n        res.append(q)\n    return sum(res)\n", "tests": ["def test_canDistribute():\n    solution = Solution()\n    nums = [10, 10]\n    quantity = [5, 10]\n    assert not solution.canDistribute(nums, quantity)", "def test_canDistribute():\n    solution = Solution()\n    nums = [1, 1, 2]\n    quantity = [2]\n    assert not solution.canDistribute(nums, quantity)", "def test_canDistribute():\n    solution = Solution()\n    nums = [10, 20, 30, 40]\n    quantity = [1, 1, 1]\n    assert not solution.canDistribute(nums, quantity)", "def test_canDistribute():\n    nums = [1, 1, 2, 2, 3]\n    quantity = [2, 3]\n    solution = Solution()\n    assert solution.canDistribute(nums, quantity) == True", "def test_canDistribute():\n    solution = Solution()\n    nums = [3, 1, 2]\n    quantity = [3, 2, 1]\n    assert not solution.canDistribute(nums, quantity)", "def test_canDistribute():\n    solution = Solution()\n    nums = [2, 2, 1]\n    quantity = [1, 1]\n    assert solution.canDistribute(nums, quantity) == False"]}
{"task_num": 1681, "task_title": "Minimum Incompatibility", "func_name": "minimumIncompatibility", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def __init__(self):\n    self.kMaxNum = 16\n\n  def minimumIncompatibility(self, nums: List[int], k: int) -> int:\n    kMaxCompatibility = (16 - 1) * (16 // 2)\n    n = len(nums)\n    subsetSize = n // k\n    maxMask = 1 << n\n    incompatibilities = self._getIncompatibilities(nums, subsetSize)\n\n    dp = [kMaxCompatibility] * maxMask\n    dp[0] = 0\n\n    for mask in range(1, maxMask):\n      if mask.bit_count() % subsetSize != 0:\n        continue\n      submask = mask\n      while submask > 0:\n        if incompatibilities[submask] != -1:\n          dp[mask] = min(dp[mask], dp[mask - submask] + incompatibilities[submask])\n        submask = (submask - 1) & mask\n\n    if dp[-1] != kMaxCompatibility:\n      return dp[-1]\n    else:\n      return -1\n\n  def _getIncompatibilities(self, nums: List[int], subsetSize: int) -> List[int]:\n    maxMask = 1 << len(nums)\n    incompatibilities = [-1] * maxMask\n    for mask in range(maxMask):\n      if mask.bit_count() == subsetSize and self._isUnique(nums, mask, subsetSize):\n        incompatibilities[mask] = self._getIncompatibility(nums, mask)\n    return incompatibilities\n\n  def _isUnique(self, nums: List[int], mask: int, subsetSize: int) -> bool:\n    used = 0\n    for i, num in enumerate(nums):\n      if mask >> i & 1:\n        used |= 1 << num\n    return used.bit_count() == subsetSize\n\n  def _getIncompatibility(self, nums: List[int], mask: int) -> int:\n    mini = self.kMaxNum\n    maxi = 0\n    for i, num in enumerate(nums):\n      if mask >> i & 1:\n        maxi = max(maxi, num)\n        mini = min(mini, num)\n    return maxi - mini\n", "tests": ["def test_minimumIncompatibility():\n    solution = Solution()\n    nums = [1, 2, 3, 4]\n    k = 2", "Here's the Python function for your test case:\n\n```python\ndef test_minimumIncompatibility():\n    nums = [1, 2, 3, 4]\n    k = 2\n    solution = Solution()\n```\n\nThis test input covers the target execution path in `minimumIncompatibility` because it contains exactly four elements and is divided into two subsets of equal size. The first loop iteration (line 49) will process `num=1`, then the second (`num=2`), third (`num=3`), and fourth (`num=4`). On each iteration, line 50 will evaluate `(mask >> i & 1)` to determine whether the current element should be included in the subset based on the current mask.", "```python\ndef test_minimumIncompatibility():\n    solution = Solution()\n    nums = [1, 2, 3, 4]\n    k = 2\n    assert solution.minimumIncompatibility(nums, k) == -1\n```", "def test_minimumIncompatibility():\n    solution = Solution()\n    nums = [100, 97, 64, 23, 22, 89, 56, 60]\n    k = 3\n    assert solution.minimumIncompatibility(nums, k) == 5", "def test_minimumIncompatibility():\n    solution = Solution()\n    nums = [4,2,3,1]\n    k = 2\n    assert(solution.minimumIncompatibility(nums,k) == 1)"]}
{"task_num": 1687, "task_title": "Delivering Boxes from Storage to Ports", "func_name": "boxDelivering", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\n    n = len(boxes)\n    dp = [0] * (n + 1)\n    trips = 2\n    weight = 0\n\n    l = 0\n    for r in range(n):\n      weight += boxes[r][1]\n\n      if r > 0 and boxes[r][0] != boxes[r - 1][0]:\n        trips += 1\n\n      while r - l + 1 > maxBoxes or weight > maxWeight or (l < r and dp[l + 1] == dp[l]):\n        weight -= boxes[l][1]\n        if boxes[l][0] != boxes[l + 1][0]:\n          trips -= 1\n        l += 1\n\n      dp[r + 1] = dp[l] + trips\n\n    return dp[n]\n", "tests": ["```python\ndef test_boxDelivering():\n    solution = Solution()\n    assert solution.boxDelivering([[1, 5], [2, 3], [2, 4]], portsCount=2, maxBoxes=1, maxWeight=8) == 6\n```\nThis test case will ensure the execution path follows the given target path through the 'boxDelivering' function. The input boxes array is designed to trigger the conditions specified in the target path.", "def test_boxDelivering():\n    solution = Solution()\n    boxes = [[1, 5], [2, 7], [3, 6], [1, 8]]\n    portsCount = 3\n    maxBoxes = 2\n    maxWeight = 10\n    assert solution.boxDelivering(boxes, portsCount, maxBoxes, maxWeight) == 4", "def test_boxDelivering():\n    solution = Solution()\n    boxes = [[1, 5], [2, 3], [1, 6], [4, 8], [5, 7]]\n    portsCount = 5\n    maxBoxes = 2\n    maxWeight = 10\n    assert solution.boxDelivering(boxes, portsCount, maxBoxes, maxWeight) == 3", "def test_boxDelivering():\n    solution = Solution()\n    boxes = [[0, 5], [1, 4], [2, 3], [0, 6]]\n    portsCount = 2\n    maxBoxes = 3\n    maxWeight = 10\n    assert solution.boxDelivering(boxes, portsCount, maxBoxes, maxWeight) == 6", "```python\ndef test_boxDelivering():\n    solution = Solution()\n    boxes = [[0, 5], [1, 5], [2, 6]]\n    portsCount = 3\n    maxBoxes = 7\n    maxWeight = 10\n    assert solution.boxDelivering(boxes, portsCount, maxBoxes, maxWeight) == 4\n```"]}
{"task_num": 1705, "task_title": "Maximum Number of Eaten Apples", "func_name": "eatenApples", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def eatenApples(self, apples: List[int], days: List[int]) -> int:\n    n = len(apples)\n    ans = 0\n    minHeap = []\n\n    i = 0\n    while i < n or minHeap:\n      while minHeap and minHeap[0][0] <= i:\n        heapq.heappop(minHeap)\n      if i < n and apples[i] > 0:\n        heapq.heappush(minHeap, (i + days[i], apples[i]))\n      if minHeap:\n        rottenDay, numApples = heapq.heappop(minHeap)\n        if numApples > 1:\n          heapq.heappush(minHeap, (rottenDay, numApples - 1))\n        ans += 1\n      i += 1\n\n    return ans\n", "tests": ["def test_eatenApples():\n    solution = Solution()\n    apples = [1, 2, 1]\n    days = [1, 1, 1]\n    assert solution.eatenApples(apples, days) == 3", "Here's the Python code for a test method that matches the given execution path:\n\n```python\ndef test_eatenApples():\n    solution = Solution()\n    days = [3, 0, 1]\n    apples = [2, 0, 1]\n    assert solution.eatenApples(apples, days) == 2\n```\n\nThis input will cause the function to follow the specified execution path because:\n\n- On day 0 (`i == 0`), `apples[i] > 0` so it pushes `(3, 2)` into `minHeap`.\n- On day 1 (`i == 1`), `apples[i] == 0`, so no apples are added to the heap.\n- On day 2 (`i == 2`), `apples[i] > 0` so it pushes `(4, 1)` into `minHeap`.\n- The loop continues until both `i < n` and there are apples left in `minHeap`.", "def test_eatenApples():\n    solution = Solution()\n    apples = [6,0,3,4,0,5]\n    days = [2,3,2,1,4,5]\n    assert solution.eatenApples(apples, days) == 6", "def test_eatenApples():\n    apples = [3,0,0,1]\n    days = [4,0,0,2]\n    solution = Solution()\n    assert solution.eatenApples(apples, days) == 1"]}
{"task_num": 1706, "task_title": "Where Will the Ball Fall", "func_name": "findBall", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findBall(self, grid: List[List[int]]) -> List[int]:\n    m = len(grid)\n    n = len(grid[0])\n    dp = [i for i in range(n)]\n    ans = [-1] * n\n\n    for i in range(m):\n      newDp = [-1] * n\n      for j in range(n):\n        if j + grid[i][j] < 0 or j + grid[i][j] == n:\n          continue\n        if grid[i][j] == 1 and grid[i][j + 1] == -1 or grid[i][j] == -1 and grid[i][j - 1] == 1:\n          continue\n        newDp[j + grid[i][j]] = dp[j]\n      dp = newDp\n\n    for i, ball in enumerate(dp):\n      if ball != -1:\n        ans[ball] = i\n\n    return ans\n", "tests": ["```python\ndef test_findBall():\n    solution = Solution()\n    assert solution.findBall([[1,1,1,-1], [-1,-1,-1,1]]) == [0, -1]\n```", "def test_findBall():\n    solution = Solution()\n    grid = [[-1, -1], [1, 1]]\n    assert solution.findBall(grid) == [-1, -1, -1, 0]", "def test_findBall():\n    solution = Solution()\n    grid = [[1], [-1], [1]]\n    assert solution.findBall(grid) == [2, 0]", "def test_findBall():\n    solution = Solution()\n    grid = [[1, -1], [1, 1]]\n    assert solution.findBall(grid) == [-1, 0]", "def test_findBall():\n    solution = Solution()\n    assert solution.findBall([[1,-1],[-1,1]]) == [-1,-1]"]}
{"task_num": 1707, "task_title": "Maximum XOR With an Element From Array", "func_name": "maximizeXor", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Optional\n\nclass TrieNode:\n  def __init__(self):\n    self.children: List[Optional[TrieNode]] = [None] * 2\n\n\nclass BitTrie:\n  def __init__(self, maxBit: int):\n    self.maxBit = maxBit\n    self.root = TrieNode()\n\n  def insert(self, num: int) -> None:\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n\n  def getMaxXor(self, num: int) -> int:\n    maxXor = 0\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      toggleBit = bit ^ 1\n      if node.children[toggleBit]:\n        maxXor = maxXor | 1 << i\n        node = node.children[toggleBit]\n      elif node.children[bit]:\n        node = node.children[bit]\n      else:\n        return 0\n    return maxXor\n\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, x: int, m: int):\n    self.queryIndex = queryIndex\n    self.x = x\n    self.m = m\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.x\n    yield self.m\n\n\nclass Solution:\n  def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n    ans = [-1] * len(queries)\n    maxBit = int(math.log2(max(max(nums), max(x for x, _ in queries))))\n    bitTrie = BitTrie(maxBit)\n\n    nums.sort()\n\n    i = 0\n    for queryIndex, x, m in sorted([IndexedQuery(i, x, m) for i, (x, m) in enumerate(queries)], key=lambda iq: iq.m):\n      while i < len(nums) and nums[i] <= m:\n        bitTrie.insert(nums[i])\n        i += 1\n      if i > 0 and nums[i - 1] <= m:\n        ans[queryIndex] = bitTrie.getMaxXor(x)\n\n    return ans\n", "tests": ["def test_maximizeXor():\n    nums = [6,8,9]\n    queries = [[2,10]]\n    solution = Solution()\n    assert solution.maximizeXor(nums, queries) == [-1]", "def test_maximizeXor():\n    solution = Solution()\n    nums = [3, 2]\n    queries = [[5, 3], [4, 6]]\n    assert solution.maximizeXor(nums, queries) == [-1, 0]", "def test_maximizeXor():\n    nums = [1, 2, 3]\n    queries = [[4, 2], [3, 2]]\n    solution = Solution()\n    assert solution.maximizeXor(nums, queries) == [-1, 1]"]}
{"task_num": 1717, "task_title": "Maximum Score From Removing Substrings", "func_name": "maximumGain", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumGain(self, s: str, x: int, y: int) -> int:\n    if x > y:\n      return self._gain(s, 'ab', x, 'ba', y)\n    else:\n      return self._gain(s, 'ba', y, 'ab', x)\n\n  def _gain(self, s: str, sub1: str, point1: int, sub2: str, point2: int) -> int:\n    points = 0\n    stack1 = []\n    stack2 = []\n\n    for c in s:\n      if stack1 and stack1[-1] == sub1[0] and c == sub1[1]:\n        stack1.pop()\n        points += point1\n      else:\n        stack1.append(c)\n\n    for c in stack1:\n      if stack2 and stack2[-1] == sub2[0] and c == sub2[1]:\n        stack2.pop()\n        points += point2\n      else:\n        stack2.append(c)\n\n    return points\n", "tests": ["def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain(\"abcba\", 1, 2) == 0", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain(\"abc\", 1, 2) == 1", "Here's the Python function that covers your target execution path:\n\n```python\ndef test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain(\"abc\", 10, 5) == 0\n```\n\nThis test case will follow the specified execution path in `maximumGain` method:\n- On line 24: `c` is 'b', so `(stack1 and stack1[-1] == sub1[0] and c == sub1[1])` evaluates to False.\n- The control flow goes to line 27, appending 'b' to `stack1`.\n- Then it checks the next character in `s`, which is 'c'.\n- Again on line 24: `(stack1 and stack1[-1] == sub1[0] and c == sub1[1])` evaluates to False because 'c' doesn't match `sub1[1]`.\n- The control flow goes back to line 27, appending 'c' to `stack1`.\n- Then it checks the next character in `s`, which is None (end of string), so the loop ends without incrementing points."]}
{"task_num": 1719, "task_title": "Number Of Ways To Reconstruct A Tree", "func_name": "checkWays", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def checkWays(self, pairs: List[List[int]]) -> int:\n    kMax = 501\n    graph = collections.defaultdict(list)\n    degrees = [0] * kMax\n    connected = [[False] * kMax for _ in range(kMax)]\n\n    for u, v in pairs:\n      graph[u].append(v)\n      graph[v].append(u)\n      degrees[u] += 1\n      degrees[v] += 1\n      connected[u][v] = True\n      connected[v][u] = True\n\n    for _, children in graph.items():\n      children.sort(key=lambda a: degrees[a], reverse=True)\n\n    root = next((i for i, d in enumerate(degrees) if d == len(graph) - 1), -1)\n    if root == -1:\n      return 0\n\n    hasMoreThanOneWay = False\n\n    def dfs(u: int, ancestors: List[int], seen: List[bool]) -> bool:\n      nonlocal hasMoreThanOneWay\n      seen[u] = True\n      for ancestor in ancestors:\n        if not connected[u][ancestor]:\n          return False\n      ancestors.append(u)\n      for v in graph[u]:\n        if seen[v]:\n          continue\n        if degrees[v] == degrees[u]:\n          hasMoreThanOneWay = True\n        if not dfs(v, ancestors, seen):\n          return False\n      ancestors.pop()\n      return True\n\n    if not dfs(root, [], [False] * kMax):\n      return 0\n    if hasMoreThanOneWay:\n      return 2\n    else:\n      return 1\n", "tests": ["def test_checkWays():\n    solution = Solution()\n    pairs = [[1, 2], [1, 3], [2, 4]]\n    assert solution.checkWays(pairs) == 0", "def test_checkWays():\n    solution = Solution()\n    pairs = [[1, 2], [1, 3], [1, 4], [1, 5]]\n    assert solution.checkWays(pairs) == 1", "```python\ndef test_checkWays():\n    solution = Solution()\n    pairs = [[1,2], [2,3], [3,1]]\n    assert solution.checkWays(pairs) == 0\n```", "def test_checkWays():\n    solution = Solution()\n    pairs = [[1, 2], [2, 3], [3, 4], [4, 5]]\n    assert solution.checkWays(pairs) == 0", "def test_checkWays():\n    solution = Solution()\n    pairs = [[1, 2], [2, 3], [3, 4]]\n    assert solution.checkWays(pairs) == 0", "```python\ndef test_checkWays():\n    solution = Solution()\n    pairs = [[1, 2], [2, 3], [3, 4]]\n    assert solution.checkWays(pairs) == 0\n```"]}
{"task_num": 1722, "task_title": "Minimize Hamming Distance After Swap Operations", "func_name": "minimumHammingDistance", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -> int:\n    n = len(source)\n    ans = 0\n    uf = UnionFind(n)\n    groupIdToCount = [collections.Counter() for _ in range(n)]\n\n    for a, b in allowedSwaps:\n      uf.unionByRank(a, b)\n\n    for i in range(n):\n      groupIdToCount[uf.find(i)][source[i]] += 1\n\n    for i in range(n):\n      groupId = uf.find(i)\n      count = groupIdToCount[groupId]\n      if target[i] not in count:\n        ans += 1\n      else:\n        count[target[i]] -= 1\n        if count[target[i]] == 0:\n          del count[target[i]]\n\n    return ans\n", "tests": ["def test_minimumHammingDistance():\n    solution = Solution()\n    source = [1, 2, 3, 4]\n    target = [2, 1, 3, 4]\n    allowedSwaps = [[0, 1]]\n    assert solution.minimumHammingDistance(source, target, allowedSwaps) == 2", "def test_minimumHammingDistance():\n    solution = Solution()\n    source = [1, 2, 3, 0]\n    target = [1, 2, 3, 4]\n    allowedSwaps = [[0, 3]]\n    assert solution.minimumHammingDistance(source, target, allowedSwaps) == 1", "```python\ndef test_minimumHammingDistance():\n    source = [1, 2, 3]\n    target = [1, 2, 3]\n    allowedSwaps = [[0, 1]]\n    solution = Solution()\n    assert solution.minimumHammingDistance(source, target, allowedSwaps) == 0\n```", "```python\ndef test_minimumHammingDistance():\n    source = [1, 0, 2]\n    target = [2, 1, 0]\n    allowedSwaps = [(0, 1), (1, 2)]\n    solution = Solution()\n    assert solution.minimumHammingDistance(source, target, allowedSwaps) == 1\n```", "def test_minimumHammingDistance():\n    source = [1, 2, 3]\n    target = [1, 0, 3]\n    allowedSwaps = [[0, 1]]\n    solution = Solution()\n    assert solution.minimumHammingDistance(source, target, allowedSwaps) == 1", "def test_minimumHammingDistance():\n    solution = Solution()\n    source = [0, 1]\n    target = [1, 0]\n    allowedSwaps = [[0, 1]]\n    assert solution.minimumHammingDistance(source, target, allowedSwaps) == 2"]}
{"task_num": 1735, "task_title": "Count Ways to Make Array With Product", "func_name": "waysToFillArray", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def waysToFillArray(self, queries: List[List[int]]) -> List[int]:\n    kMod = 1_000_000_007\n    kMax = 10_000\n    minPrimeFactors = self._sieveEratosthenes(kMax + 1)\n\n    @functools.lru_cache(None)\n    def fact(i: int) -> int:\n      return 1 if i <= 1 else i * fact(i - 1) % kMod\n\n    @functools.lru_cache(None)\n    def inv(i: int) -> int:\n      return pow(i, kMod - 2, kMod)\n\n    @functools.lru_cache(None)\n    def nCk(n: int, k: int) -> int:\n      return fact(n) * inv(fact(k)) * inv(fact(n - k)) % kMod\n\n    ans = []\n\n    for n, k in queries:\n      res = 1\n      for freq in self._getPrimeFactorsCount(k, minPrimeFactors).values():\n        res = res * nCk(n - 1 + freq, freq) % kMod\n      ans.append(res)\n\n    return ans\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeFactorsCount(self, num: int, minPrimeFactors: List[int]) -> Dict[int, int]:\n    count = collections.Counter()\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      while num % divisor == 0:\n        num //= divisor\n        count[divisor] += 1\n    return count\n", "tests": ["def test_waysToFillArray():\n    solution = Solution()\n    assert solution.waysToFillArray([[500001, 1], [499999, 2]]) == [376897934, 817560149]\n    assert solution._sieveEratosthenes(500000) == [0, 2, 2, 2, 3, 3, 3, 3]"]}
{"task_num": 1765, "task_title": "Map of Highest Peak", "func_name": "highestPeak", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(isWater)\n    n = len(isWater[0])\n    ans = [[-1] * n for _ in range(m)]\n    q = collections.deque()\n\n    for i in range(m):\n      for j in range(n):\n        if isWater[i][j] == 1:\n          q.append((i, j))\n          ans[i][j] = 0\n\n    while q:\n      i, j = q.popleft()\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if ans[x][y] != -1:\n          continue\n        ans[x][y] = ans[i][j] + 1\n        q.append((x, y))\n\n    return ans\n", "tests": ["def test_highestPeak():\n    solution = Solution()\n    isWater = [[1, 0, 0], [0, 1, 0], [0, 0, 0]]\n    assert solution.highestPeak(isWater) == [[0, 1, 2], [1, 0, 1], [2, 1, 0]]", "def test_highestPeak():\n    solution = Solution()\n    isWater = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n    assert solution.highestPeak(isWater) == [[-1, -1, -1], [-1, 0, -1], [-1, -1, -1]]", "def test_highestPeak():\n    solution = Solution()\n    assert solution.highestPeak([[0,0],[0,1]]) == [[2,1]]", "def test_highestPeak():\n    solution = Solution()\n    isWater = [[1], [0]]\n    assert solution.highestPeak(isWater) == [[0], [-1]]"]}
{"task_num": 1782, "task_title": "Count Pairs Of Nodes", "func_name": "countPairs", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:\n    ans = [0] * len(queries)\n\n    count = [0] * (n + 1)\n\n    shared = [collections.Counter() for _ in range(n + 1)]\n\n    for u, v in edges:\n      count[u] += 1\n      count[v] += 1\n      shared[min(u, v)][max(u, v)] += 1\n\n    sortedCount = sorted(count)\n\n    for k, query in enumerate(queries):\n      i = 1\n      j = n\n      while i < j:\n        if sortedCount[i] + sortedCount[j] > query:\n          ans[k] += j - i\n          j -= 1\n        else:\n          i += 1\n      for i in range(1, n + 1):\n        for j, sh in shared[i].items():\n          if count[i] + count[j] > query and count[i] + count[j] - sh <= query:\n            ans[k] -= 1\n\n    return ans\n", "tests": ["def test_countPairs():\n    solution = Solution()\n    assert(solution.countPairs(n=6,\n        edges=[[0,2],[1,3],[2,4],[3,5]],\n        queries=[1, 3]) == [0, 0])", "def test_countPairs():\n    solution = Solution()\n    assert solution.countPairs(n=4,\n                                edges=[[1,2],[2,3],[3,4]],\n                                queries=[1]) == [0]", "def test_countPairs():\n    solution = Solution()\n    assert solution.countPairs(n=5, edges=[[1,2],[1,3],[3,4],[4,5]], queries=[0]) == [0]", "def test_countPairs():\n    solution = Solution()\n    assert solution.countPairs(n=5, edges=[[1,2],[2,3],[3,4],[4,5]], queries=[1]) == [0]"]}
{"task_num": 1786, "task_title": "Number of Restricted Paths From First to Last Node", "func_name": "countRestrictedPaths", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countRestrictedPaths(self, n: int, edges: List[List[int]]) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u - 1].append((v - 1, w))\n      graph[v - 1].append((u - 1, w))\n\n    return self._dijkstra(graph, 0, n - 1)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int) -> int:\n    kMod = 10**9 + 7\n    ways = [0] * len(graph)\n    dist = [math.inf] * len(graph)\n\n    ways[dst] = 1\n    dist[dst] = 0\n    minHeap = [(dist[dst], dst)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n        if dist[v] < dist[u]:\n          ways[u] += ways[v]\n          ways[u] %= kMod\n\n    return ways[src]\n", "tests": ["def test_countRestrictedPaths():\n    solution = Solution()\n    edges = [[1,2,1],[2,3,2],[1,3,4]]\n    assert solution.countRestrictedPaths(3, edges) == 0", "```python\ndef test_countRestrictedPaths():\n    solution = Solution()\n    edges = [[1,2,1],[2,3,3],[3,4,5]]\n    assert solution.countRestrictedPaths(4, edges) == 0\n```\nThis test case covers the target execution path by creating a graph with four nodes and specific edge weights. The `assert` statement checks that the function returns 0 for this input, as there are no restricted paths in this graph.", "def test_countRestrictedPaths():\n    solution = Solution()\n    assert solution.countRestrictedPaths(4, [(1, 2, 1), (2, 3, 3), (3, 4, 5)]) == 0", "def test_countRestrictedPaths():\n    solution = Solution()\n    edges = [[1, 2, 1], [2, 3, 2], [3, 4, 3]]\n    assert solution.countRestrictedPaths(4, edges) == 0"]}
{"task_num": 1793, "task_title": "Maximum Score of a Good Subarray", "func_name": "maximumScore", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumScore(self, nums: List[int], k: int) -> int:\n    ans = 0\n    stack = []\n\n    for i in range(len(nums) + 1):\n      while stack and (i == len(nums) or nums[stack[-1]] > nums[i]):\n        h = nums[stack.pop()]\n        w = i - stack[-1] - 1 if stack else i\n        if (not stack or stack[-1] + 1 <= k) and i - 1 >= k:\n          ans = max(ans, h * w)\n      stack.append(i)\n\n    return ans\n", "tests": ["def test_maximumScore():\n    solution = Solution()\n    nums = [5, 2, 8, 1]\n    k = 0\n    assert solution.maximumScore(nums, k) == 4", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([7, 3, 8, 4], 2) == 20", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([3, 2, 4, 5], 0) == 1", "```python\ndef test_maximumScore():\n    solution = Solution()\n    nums = [3, 2, 5, 4]\n    k = 2\n    assert solution.maximumScore(nums, k) == 10\n```\nThis test case covers the target execution path by providing `nums` such that it iterates through all elements and `k` is within the range of subarray indices. The expected output is `10`, which is the maximum possible score for a good subarray in this scenario."]}
{"task_num": 1805, "task_title": "Number of Different Integers in a String", "func_name": "numDifferentIntegers", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numDifferentIntegers(self, word: str) -> int:\n    nums = set()\n    curr = []\n\n    for c in word:\n      if c.isdigit():\n        curr.append(c)\n      elif curr:\n        nums.add(''.join(self._removeLeadingZeros(curr)))\n        curr = []\n\n    if curr:\n      nums.add(''.join(self._removeLeadingZeros(curr)))\n\n    return len(nums)\n\n  def _removeLeadingZeros(self, s: str) -> str:\n    index = next((i for i, c in enumerate(s) if c != '0'), -1)\n    if index == -1:\n      return ['0']\n    else:\n      return s[index:]\n", "tests": ["def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers(\"123\") == 1", "```python\ndef test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers(\"a123bc34\") == 2\n```", "def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers(\"0123\") == 3", "def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers(\"a1230b\") == 2"]}
{"task_num": 1857, "task_title": "Largest Color Value in a Directed Graph", "func_name": "largestPathValue", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\n    n = len(colors)\n    ans = 0\n    processed = 0\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n    q = collections.deque()\n    count = [[0] * 26 for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      inDegrees[v] += 1\n\n    for i, degree in enumerate(inDegrees):\n      if degree == 0:\n        q.append(i)\n\n    while q:\n      u = q.popleft()\n      processed += 1\n      count[u][ord(colors[u]) - ord('a')] += 1\n      ans = max(ans, count[u][ord(colors[u]) - ord('a')])\n      for v in graph[u]:\n        for i in range(26):\n          count[v][i] = max(count[v][i], count[u][i])\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    if processed == n:\n      return ans\n    else:\n      return -1\n", "tests": ["```python\ndef test_largestPathValue():\n    solution = Solution()\n    assert solution.largestPathValue(\"aba\", [[0, 1], [0, 2], [1, 3], [2, 3]]) == -1\n```", "```python\ndef test_largestPathValue():\n    colors = \"abc\"\n    edges = [[0,1],[0,2],[1,3],[2,4],[5,6]]\n    solution = Solution()\n    assert solution.largestPathValue(colors, edges) == 2\n```"]}
{"task_num": 1878, "task_title": "Get Biggest Three Rhombus Sums in a Grid", "func_name": "getBiggestThree", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom sortedcontainers import SortedSet\n\n\nclass Solution:\n  def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\n    m = len(grid)\n    n = len(grid[0])\n    sums = SortedSet()\n\n    for i in range(m):\n      for j in range(n):\n        sz = 0\n        while i + sz < m and i - sz >= 0 and j + 2 * sz < n:\n          summ = grid[i][j] if sz == 0 else self._getSum(grid, i, j, sz)\n          sums.add(summ)\n          if len(sums) > 3:\n            sums.pop(0)\n          sz += 1\n\n    return reversed(sums)\n\n  def _getSum(self, grid: List[List[int]], i: int, j: int, sz: int) -> int:\n    x = i\n    y = j\n    summ = 0\n\n    for _ in range(sz):\n      x -= 1\n      y += 1\n      summ += grid[x][y]\n\n    for _ in range(sz):\n      x += 1\n      y += 1\n      summ += grid[x][y]\n\n    for _ in range(sz):\n      x += 1\n      y -= 1\n      summ += grid[x][y]\n\n    for _ in range(sz):\n      x -= 1\n      y -= 1\n      summ += grid[x][y]\n\n    return summ\n", "tests": ["def test_getBiggestThree():\n    solution = Solution()\n    grid = [\n        [3, 4, 5],\n        [2, 8, 7],\n        [1, 9, 6]\n    ]\n    assert solution.getBiggestThree(grid) == [25, 20, 18]", "```python\ndef test_getBiggestThree():\n    solution = Solution()\n    grid = [\n        [3, 4, 5],\n        [2, 8, 7],\n        [1, 0, 9]\n    ]\n    assert solution.getBiggestThree(grid) == [46, 37, 31]\n```", "def test_getBiggestThree():\n    solution = Solution()\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    assert solution.getBiggestThree(grid) == [10+8+6+4+2+1, 11+9+7+5]", "def test_getBiggestThree():\n    solution = Solution()\n    grid = [[3, 4, 5], [6, 7, 8], [9, 10, 11]]\n    assert solution.getBiggestThree(grid) == [25, 24, 23]", "def test_getBiggestThree():\n    solution = Solution()\n    assert solution.getBiggestThree([[5, 2], [1, 6]]) == [10, 9, 7]\n\n# The input grid will result in the following rhombus sums: 10 (red), 9 (blue), and 7 (green). The condition len(sums) > 3 is satisfied on line 26 for the first two iterations of the outer loop on line 20, forcing sums.pop(0) to be executed.", "def test_getBiggestThree():\n    solution = Solution()\n    grid = [\n        [1, 2],\n        [3, 4]\n    ]\n    assert solution.getBiggestThree(grid) == [5]"]}
{"task_num": 1896, "task_title": "Minimum Cost to Change the Final Value of Expression", "func_name": "minOperationsToFlip", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minOperationsToFlip(self, expression: str) -> int:\n    stack = []\n\n    for e in expression:\n      if e in '(&|':\n        stack.append((e, 0))\n        continue\n      if e == ')':\n        lastPair = stack.pop()\n        stack.pop()\n      else: \n        lastPair = (e, 1)\n      if stack and stack[-1][0] in '&|':\n        op = stack.pop()[0]\n        a, costA = stack.pop()\n        b, costB = lastPair\n        if op == '&':\n          if a == '0' and b == '0':\n            lastPair = ('0', 1 + min(costA, costB))\n          elif a == '0' and b == '1':\n            lastPair = ('0', 1)\n          elif a == '1' and b == '0':\n            lastPair = ('0', 1)\n          else:\n            lastPair = ('1', min(costA, costB))\n        else:\n          if a == '0' and b == '0':\n            lastPair = ('0', min(costA, costB))\n          elif a == '0' and b == '1':\n            lastPair = ('1', 1)\n          elif a == '1' and b == '0':\n            lastPair = ('1', 1)\n          else:\n            lastPair = ('1', 1 + min(costA, costB))\n      stack.append(lastPair)\n\n    return stack[-1][1]\n", "tests": ["def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip(\"(1)&(0)\") == 3", "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip(\"((&)|(1))\") == 2", "```python\ndef test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip(\"(&|)\") == 0\n```", "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip(\"(&(1)&(0))|((1)&(0)|(0)&(1))\") == 2", "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip(\"(0&(1))\") == 2"]}
{"task_num": 1906, "task_title": "Minimum Absolute Difference Queries", "func_name": "minDifference", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom bisect import bisect_left\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minDifference(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n    numToIndices = [[] for _ in range(101)]\n\n    for i, num in enumerate(nums):\n      numToIndices[num].append(i)\n\n    if len(numToIndices[nums[0]]) == len(nums):\n      return [-1] * len(queries)\n\n    ans = []\n\n    for l, r in queries:\n      prevNum = -1\n      minDiff = 101\n      for num in range(1, 101):\n        indices = numToIndices[num]\n        i = bisect_left(indices, l)\n        if i == len(indices) or indices[i] > r:\n          continue\n        if prevNum != -1:\n          minDiff = min(minDiff, num - prevNum)\n        prevNum = num\n      ans.append(-1 if minDiff == 101 else minDiff)\n\n    return ans\n", "tests": ["def test_minDifference():\n    solution = Solution()\n    nums = [5]*90 + [2]\n    queries = [[89, 91], [90, 92]]\n    assert(solution.minDifference(nums, queries) == [-1, -1])", "def test_minDifference():\n    nums = [5, 2, 3, 7]\n    queries = [[1, 2], [2, 3]]\n    solution = Solution()\n    assert solution.minDifference(nums, queries) == [-1, 1]"]}
{"task_num": 1923, "task_title": "Longest Common Subpath", "func_name": "longestCommonSubpath", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Set\n\nclass Solution:\n  def __init__(self):\n    self.kMod = 8_417_508_174_513\n    self.kBase = 165_131\n\n  def longestCommonSubpath(self, n: int, paths: List[List[int]]) -> int:\n    l = 0\n    r = len(paths[0])\n\n    while l < r:\n      m = l + (r - l + 1) // 2\n      if self._checkCommonSubpath(paths, m):\n        l = m\n      else:\n        r = m - 1\n\n    return l\n\n  def _checkCommonSubpath(self, paths: List[List[int]], m: int) -> bool:\n    hashSets = [self._rabinKarp(path, m) for path in paths]\n\n    for subpathHash in hashSets[0]:\n      if all(subpathHash in hashSet for hashSet in hashSets):\n        return True\n\n    return False\n\n  def _rabinKarp(self, path: List[int], m: int) -> Set[int]:\n    hashes = set()\n    maxPower = 1\n    hash = 0\n\n    for i, num in enumerate(path):\n      hash = (hash * self.kBase + num) % self.kMod\n      if i >= m:\n        hash = (hash - path[i - m] * maxPower % self.kMod + self.kMod) % self.kMod\n      else:\n        maxPower = maxPower * self.kBase % self.kMod\n      if i >= m - 1:\n        hashes.add(hash)\n\n    return hashes\n", "tests": ["```python\ndef test_longestCommonSubpath():\n    solution = Solution()\n    assert solution.longestCommonSubpath(5, [[1, 2, 3], [2, 1, 4, 3], [3, 1, 2]]) == 1\n```", "def test_longestCommonSubpath():\n    solution = Solution()\n    paths = [[7, 3, 6, 5, 2], [8, 0, 9, 1, 4]]\n    assert solution.longestCommonSubpath(10, paths) == 2", "def test_longestCommonSubpath():\n    solution = Solution()\n    paths = [[1], [2]]\n    assert solution.longestCommonSubpath(3, paths) == 0", "Here's a test method that covers the specified execution path:\n\n```python\ndef test_longestCommonSubpath():\n    solution = Solution()\n    paths = [[1, 2], [1, 3, 4]]\n    assert solution.longestCommonSubpath(4, paths) == 1\n```\n\nIn this case, `paths[0] = [1, 2]` and `paths[1] = [1, 3, 4]`. The longest common subpath is `[1]`, which has a length of 1. This test case will execute the target execution path as intended.", "def test_longestCommonSubpath():\n    solution = Solution()\n    paths = [[0,1],[2,3,0]]\n    assert solution.longestCommonSubpath(4, paths) == 0"]}
{"task_num": 1926, "task_title": "Nearest Exit from Entrance in Maze", "func_name": "nearestExit", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def nearestExit(self, maze: List[List[str]], entrance: List[int]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(maze)\n    n = len(maze[0])\n    ans = 0\n    q = collections.deque([(entrance[0], entrance[1])])\n    seen = {(entrance[0], entrance[1])}\n\n    while q:\n      ans += 1\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if (x, y) in seen or maze[x][y] == '+':\n            continue\n          if x == 0 or x == m - 1 or y == 0 or y == n - 1:\n            return ans\n          q.append((x, y))\n          seen.add((x, y))\n\n    return -1\n", "tests": ["def test_nearestExit():\n    solution = Solution()\n    assert solution.nearestExit([['+', '.'], ['+', '.']], [1, 1]) == -1", "def test_nearestExit():\n    solution = Solution()\n    assert solution.nearestExit([\n        ['+', '.'],\n        ['.', '+']\n    ], [0, 1]) == -1", "def test_nearestExit():\n    solution = Solution()\n    assert(solution.nearestExit([['+', '.', '+'], ['.', '.', '.'], ['+', '+', '+']], [1, 1]) == -1)", "def test_nearestExit():\n    solution = Solution()\n    maze = [['.', '.', '+'], ['+', '+', '.'], ['+', '.', '+']]\n    entrance = [0, 1]\n    assert solution.nearestExit(maze, entrance) == -1", "def test_nearestExit():\n    solution = Solution()\n    assert solution.nearestExit([['+', '.'], ['.', '+']], [0, 1]) == -1", "def test_nearestExit():\n    solution = Solution()\n    maze = [['.', '+', '.'], ['+', '+', '+'], ['.', '.', '.']]\n    entrance = [0, 1]"]}
{"task_num": 1928, "task_title": "Minimum Cost to Reach Destination in Time", "func_name": "minCost", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\n    n = len(passingFees)\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, 0, n - 1, maxTime, passingFees)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, maxTime: int, passingFees: List[int]) -> int:\n    cost = [math.inf for _ in range(len(graph))]\n    dist = [maxTime + 1 for _ in range(len(graph))]\n\n    cost[src] = passingFees[src]\n    dist[src] = 0\n    minHeap = [(cost[src], dist[src], src)]\n\n    while minHeap:\n      currCost, d, u = heapq.heappop(minHeap)\n      if u == dst:\n        return cost[dst]\n      if d > dist[u] and currCost > cost[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w > maxTime:\n          continue\n        if currCost + passingFees[v] < cost[v]:\n          cost[v] = currCost + passingFees[v]\n          dist[v] = d + w\n          heapq.heappush(minHeap, (cost[v], dist[v], v))\n        elif d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (currCost + passingFees[v], dist[v], v))\n\n    return -1\n", "tests": ["```python\ndef test_minCost():\n    solution = Solution()\n    assert solution.minCost(120, [[0, 1, 7], [0, 2, 5], [1, 3, 8], [2, 3, 4]], [10, 20, 30, 40]) == -1\n```", "def test_minCost():\n    solution = Solution()\n    assert solution.minCost(10, [[0, 1, 2], [0, 2, 3]], [1, 2, 3]) == -1", "def test_minCost():\n    solution = Solution()\n    edges = [[0, 1, 2], [0, 2, 4]]\n    passingFees = [1, 2, 3]\n    maxTime = 5\n    assert solution.minCost(maxTime, edges, passingFees) == 6", "Here's a test case that satisfies the target execution path:\n\n```python\ndef test_minCost():\n    solution = Solution()\n    maxTime = 10\n    edges = [[0, 1, 5], [0, 2, 3], [1, 2, 2]]\n    passingFees = [2, 4, 6]\n    assert solution.minCost(maxTime, edges, passingFees) == 10\n```\n\nIn this test case:\n- The journey from city 0 to city 2 goes through city 1.\n- The total time taken is 5 + 3 = 8 minutes which is less than `maxTime`.\n- The total cost is the sum of passing fees for cities 0, 1, and 2: 2 + 4 + 6 = 12 dollars.\n- So, the minimum cost to complete this journey is 12 dollars.", "def test_minCost():\n    solution = Solution()\n    assert solution.minCost(20, [[0,1,5],[0,2,8],[1,3,9],[2,3,4]], [1,3,7,1]) == 1", "def test_minCost():\n    solution = Solution()\n    assert solution.minCost(10, [[0, 1, 2], [0, 2, 3], [1, 2, 4]], [2, 5, 3]) == 7"]}
{"task_num": 1938, "task_title": "Maximum Genetic Difference Query", "func_name": "maxGeneticDifference", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass TrieNode:\n  def __init__(self):\n    self.children = [None] * 2\n    self.count = 0\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n    self.kHeight = 17\n\n  def update(self, num: int, val: int) -> None:\n    node = self.root\n    for i in range(self.kHeight, -1, -1):\n      bit = (num >> i) & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n      node.count += val\n\n  def query(self, num: int) -> int:\n    ans = 0\n    node = self.root\n    for i in range(self.kHeight, -1, -1):\n      bit = (num >> i) & 1\n      targetBit = bit ^ 1\n      if node.children[targetBit] and node.children[targetBit].count > 0:\n        ans += 1 << i\n        node = node.children[targetBit]\n      else:\n        node = node.children[targetBit ^ 1]\n    return ans\n\n\nclass Solution:\n  def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\n    n = len(parents)\n    ans = [0] * len(queries)\n    rootVal = -1\n    tree = [[] for _ in range(n)]\n    nodeToQueries = collections.defaultdict(list)\n    trie = Trie()\n\n    for i, parent in enumerate(parents):\n      if parent == -1:\n        rootVal = i\n      else:\n        tree[parent].append(i)\n\n    for i, (node, val) in enumerate(queries):\n      nodeToQueries[node].append((i, val))\n\n    def dfs(node: int) -> None:\n      trie.update(node, 1)\n\n      for i, val in nodeToQueries[node]:\n        ans[i] = trie.query(val)\n\n      for child in tree[node]:\n        dfs(child)\n\n      trie.update(node, -1)\n\n    dfs(rootVal)\n    return ans\n", "tests": ["parents = [0, 2, 0, 2]\nqueries = [[0, 5], [1, 3], [2, 7]]\nreturn_value = solution.maxGeneticDifference(parents, queries)", "def test_maxGeneticDifference():\n    parents = [1, -1, 2]\n    queries = [[1, 7], [2, 3]]\n    solution = Solution()\n    assert solution.maxGeneticDifference(parents, queries) == [6, 5]", "def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [0]*7 + [-1]\n    queries = [(6, 3), (4, 5), (2, 7)]\n    assert solution.maxGeneticDifference(parents, queries) == [6, 5, 7]"]}
{"task_num": 1971, "task_title": "Find if Path Exists in Graph", "func_name": "validPath", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def validPath(self, n: int, edges: List[List[int]], source: int, destination: int) -> bool:\n    uf = UnionFind(n)\n\n    for u, v in edges:\n      uf.unionByRank(u, v)\n\n    return uf.find(source) == uf.find(destination)\n", "tests": ["def test_validPath():\n    solution = Solution()\n    assert not solution.validPath(5, [[0,1], [2,3], [4,3]], 2, 0)", "def test_validPath():\n    solution = Solution()\n    edges = [[0, 2], [0, 1]]\n    assert not solution.validPath(3, edges, 0, 2)", "def test_validPath():\n    solution = Solution()\n    assert not solution.validPath(4, [[0,1], [0,2]], 0, 3)"]}
{"task_num": 1976, "task_title": "Number of Ways to Arrive at Destination", "func_name": "countPaths", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countPaths(self, n: int, roads: List[List[int]]) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in roads:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, 0, n - 1)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int) -> int:\n    kMod = 10**9 + 7\n    ways = [0] * len(graph)\n    dist = [math.inf] * len(graph)\n\n    ways[src] = 1\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          ways[v] = ways[u]\n          heapq.heappush(minHeap, (dist[v], v))\n        elif d + w == dist[v]:\n          ways[v] += ways[u]\n          ways[v] %= kMod\n\n    return ways[dst]\n", "tests": ["Here is a function to create the necessary input for your target execution path:\n\n```python\ndef test_countPaths():\n    solution = Solution()\n    roads = [[0, 1, 5], [0, 2, 3]]\n    n = 3\n    assert solution.countPaths(n, roads) == 4\n```\n\nIn this case we have three intersections and two possible paths from intersection `0` to `n - 1`. The second branch condition is not satisfied (`d + w < dist[v]`), so the function goes back to line 30 without updating `dist[v]`, then it continues iterating over `graph[u]` at line 34.", "def test_countPaths():\n    solution = Solution()\n    roads = [[0, 1, 1], [1, 2, 1], [1, 3, 2], [2, 3, 1]]\n    assert solution.countPaths(4, roads) == 2", "def test_countPaths():\n    solution = Solution()\n    assert solution.countPaths(4, [[0,1,5],[0,2,1],[1,2,3],[2,3,6]]) == 1"]}
{"task_num": 1977, "task_title": "Number of Ways to Separate Numbers", "func_name": "numberOfCombinations", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numberOfCombinations(self, num: str) -> int:\n    if num[0] == '0':\n      return 0\n\n    kMod = 1_000_000_007\n    n = len(num)\n    dp = [[0] * (n + 1) for _ in range(n)]\n    lcs = [[0] * (n + 1) for _ in range(n + 1)]\n\n    for i in range(n - 1, -1, -1):\n      for j in range(i + 1, n):\n        if num[i] == num[j]:\n          lcs[i][j] = lcs[i + 1][j + 1] + 1\n\n    for i in range(n):\n      for k in range(1, i + 2):\n        dp[i][k] += dp[i][k - 1]\n        dp[i][k] %= kMod\n        s = i - k + 1\n        if num[s] == '0':\n          continue\n        if s == 0:\n          dp[i][k] += 1\n          continue\n        if s < k:\n          dp[i][k] += dp[s - 1][s]\n          continue\n        l = lcs[s - k][s]\n        if l >= k or num[s - k + l] <= num[s + l]:\n          dp[i][k] += dp[s - 1][k]\n        else:\n          dp[i][k] += dp[s - 1][k - 1]\n\n    return dp[n - 1][n] % kMod\n", "tests": ["def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('0') == 0", "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations(\"0\") == 0", "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations(\"10\") == 1"]}
{"task_num": 1994, "task_title": "The Number of Good Subsets", "func_name": "numberOfGoodSubsets", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numberOfGoodSubsets(self, nums: List[int]) -> int:\n    kMod = 1_000_000_007\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n    n = 1 << len(primes)\n    dp = [1] + [0] * (n - 1)\n    count = collections.Counter(nums)\n\n    for num, freq in count.items():\n      if num == 1:\n        continue\n      if any(num % squared == 0 for squared in [4, 9, 25]):\n        continue\n      numPrimesMask = 0\n      for i, prime in enumerate(primes):\n        if num % prime == 0:\n          numPrimesMask += 1 << i\n      for primesMask in range(n):\n        if primesMask & numPrimesMask > 0:\n          continue\n        nextPrimesMask = numPrimesMask | primesMask\n        dp[nextPrimesMask] += dp[primesMask] * freq\n        dp[nextPrimesMask] %= kMod\n\n    return (1 << count[1]) * sum(dp[1:]) % kMod\n", "tests": ["def test_numberOfGoodSubsets():\n    solution = Solution()\n    nums = [1, 2, 3, 4]\n    assert solution.numberOfGoodSubsets(nums) == 7", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    nums = [1, 2, 3, 4]\n    assert solution.numberOfGoodSubsets(nums) == 7"]}
{"task_num": 1998, "task_title": "GCD Sort of an Array", "func_name": "gcdSort", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def gcdSort(self, nums: List[int]) -> bool:\n    maxNum = max(nums)\n    minPrimeFactors = self._sieveEratosthenes(maxNum + 1)\n    uf = UnionFind(maxNum + 1)\n\n    for num in nums:\n      for primeFactor in self._getPrimeFactors(num, minPrimeFactors):\n        uf.unionByRank(num, primeFactor)\n\n    for a, b in zip(nums, sorted(nums)):\n      if uf.find(a) != uf.find(b):\n        return False\n\n    return True\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeFactors(self, num: int, minPrimeFactors: List[int]) -> List[int]:\n    primeFactors = []\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      primeFactors.append(divisor)\n      while num % divisor == 0:\n        num //= divisor\n    return primeFactors\n", "tests": ["def test_gcdSort():\n    solution = Solution()\n    nums = [60, 48, 36, 24, 18]\n    assert solution.gcdSort(nums) == False", "def test_gcdSort():\n    solution = Solution()\n    nums = [12, 72, 30]\n    assert solution.gcdSort(nums)", "def test_gcdSort():\n    solution = Solution()\n    nums = [12, 8]\n    assert solution.gcdSort(nums) == False", "def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([5, 10, 7])", "def test_gcdSort():\n    solution = Solution()\n    nums = [15, 7, 9]\n    assert solution.gcdSort(nums) == True", "def test_gcdSort():\n    solution = Solution()\n    nums = [10, 5]\n    assert not solution.gcdSort(nums)"]}
{"task_num": 2019, "task_title": "The Score of Students Solving Math Expression", "func_name": "scoreOfStudents", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nimport operator\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def scoreOfStudents(self, s: str, answers: List[int]) -> int:\n    n = len(s) // 2 + 1\n    ans = 0\n    func = {'+': operator.add, '*': operator.mul}\n    dp = [[set() for j in range(n)] for _ in range(n)]\n\n    for i in range(n):\n      dp[i][i].add(int(s[i * 2]))\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        for k in range(i, j):\n          op = s[k * 2 + 1]\n          for a in dp[i][k]:\n            for b in dp[k + 1][j]:\n              res = func[op](a, b)\n              if res <= 1000:\n                dp[i][j].add(res)\n\n    correctAnswer = eval(s)\n\n    for answer, freq in collections.Counter(answers).items():\n      if answer == correctAnswer:\n        ans += 5 * freq\n      elif answer in dp[0][n - 1]:\n        ans += 2 * freq\n\n    return ans\n", "tests": ["def test_scoreOfStudents():\n    s = \"5+4*2\"\n    answers = [6, 8]\n    solution = Solution()\n    assert solution.scoreOfStudents(s, answers) == 10", "def test_scoreOfStudents():\n    solution = Solution()\n    s = \"3+5*2\"\n    answers = [15, 800, 47]\n    assert solution.scoreOfStudents(s, answers) == 6", "def test_scoreOfStudents():\n    s = \"2*3+1\"\n    answers = [67, 8]\n    solution = Solution()\n    assert solution.scoreOfStudents(s, answers) == 5", "def test_scoreOfStudents():\n    solution = Solution()\n    s = \"3+5*2\"\n    answers = [6, 7]\n    assert solution.scoreOfStudents(s, answers) == 10", "def test_scoreOfStudents():\n    solution = Solution()\n    s = \"+*123\"\n    answers = [70, 84]\n    assert solution.scoreOfStudents(s, answers) == 6", "def test_scoreOfStudents():\n    s = \"3+5*2\"\n    answers = [64, 17, 1000]\n    solution = Solution()\n    assert solution.scoreOfStudents(s, answers) == 7"]}
{"task_num": 2030, "task_title": "Smallest K-Length Subsequence With Occurrences of a Letter", "func_name": "smallestSubsequence", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\n    stack = []\n    required = repetition\n    nLetters = s.count(letter)\n\n    for i, c in enumerate(s):\n      while stack and stack[-1] > c  and len(stack) + len(s) - i - 1 >= k and (stack[-1] != letter or nLetters > required):\n        if stack.pop() == letter:\n          required += 1\n      if len(stack) < k:\n        if c == letter:\n          stack.append(c)\n          required -= 1\n        elif k - len(stack) > required:\n          stack.append(c)\n      if c == letter:\n        nLetters -= 1\n\n    return ''.join(stack)\n", "tests": ["```python\ndef test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence(\"abc\", 3, \"b\", 1) == \"ab\"\n```\nIn this test case, the input string is \"abc\" with a required length of subsequence `k` equals to 3. The target letter 'b' should appear at least once (`repetition=1`). The smallest lexicographically subsequence satisfying these conditions is \"ab\".", "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence(\"bcccaa\", 4, \"c\", 2) == \"acc\"", "```python\ndef test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence(\"aabc\", 2, \"b\", 1) == \"ab\"\n```", "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence(\"abc\", 3, \"b\", 1) == \"abc\"", "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence(\"abcba\", 3, \"a\", 2) == \"aba\""]}
{"task_num": 2040, "task_title": "Kth Smallest Product of Two Sorted Arrays", "func_name": "kthSmallestProduct", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int) -> int:\n    A1 = [-num for num in nums1 if num < 0][::-1]\n    A2 = [num for num in nums1 if num >= 0]\n    B1 = [-num for num in nums2 if num < 0][::-1]\n    B2 = [num for num in nums2 if num >= 0]\n\n    negCount = len(A1) * len(B2) + len(A2) * len(B1)\n\n    if k > negCount:\n      k -= negCount\n      sign = 1\n    else:\n      k = negCount - k + 1\n      sign = -1\n      B1, B2 = B2, B1\n\n    def numProductNoGreaterThan(A: List[int], B: List[int], m: int) -> int:\n      ans = 0\n      j = len(B) - 1\n      for i in range(len(A)):\n        while j >= 0 and A[i] * B[j] > m:\n          j -= 1\n        ans += j + 1\n      return ans\n\n    l = 0\n    r = 10**10\n\n    while l < r:\n      m = (l + r) // 2\n      if numProductNoGreaterThan(A1, B1, m) + numProductNoGreaterThan(A2, B2, m) >= k:\n        r = m\n      else:\n        l = m + 1\n\n    return sign * l\n", "tests": ["def test_kthSmallestProduct():\n    solution = Solution()\n    nums1 = [2, -3, 4]\n    nums2 = [-5, 6]\n    k = 8\n    assert solution.kthSmallestProduct(nums1, nums2, k) == 7", "def test_kthSmallestProduct():\n    solution = Solution()\n    nums1 = [3, -1, 0]\n    nums2 = [-3, 1, 0]\n    k = 6\n    assert solution.kthSmallestProduct(nums1, nums2, k) == 0", "def test_kthSmallestProduct():\n    solution = Solution()\n    nums1 = [-3, -2, 0]\n    nums2 = [1, 2, 3]\n    k = 5\n    assert solution.kthSmallestProduct(nums1, nums2, k) == -9"]}
{"task_num": 2045, "task_title": "Second Minimum Time to Reach Destination", "func_name": "secondMinimum", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\n    graph = [[] for _ in range(n + 1)]\n    q = collections.deque([(1, 0)])\n    minTime = [[math.inf] * 2 for _ in range(n + 1)]\n    minTime[1][0] = 0\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    while q:\n      i, prevTime = q.popleft()\n\n      numChangeSignal = prevTime // change\n      waitTime = change - (prevTime % change) if numChangeSignal & 1 else 0\n      newTime = prevTime + waitTime + time\n      for j in graph[i]:\n        if newTime < minTime[j][0]:\n          minTime[j][0] = newTime\n          q.append((j, newTime))\n        elif minTime[j][0] < newTime < minTime[j][1]:\n          if j == n:\n            return newTime\n          minTime[j][1] = newTime\n          q.append((j, newTime))\n", "tests": ["def test_secondMinimum():\n    solution = Solution()\n    assert solution.secondMinimum(3, [[1,2], [2,3]], 10, 5) == 4", "def test_secondMinimum():\n    solution = Solution()\n    assert solution.secondMinimum(6, [[1,2],[1,3],[2,4],[2,5],[4,5],[5,6]], 7, 10) == 38", "def test_secondMinimum():\n    solution = Solution()\n    assert solution.secondMinimum(3, [[1, 2], [1, 3]], 10, 6) == 50", "def test_secondMinimum():\n    solution = Solution()\n    assert solution.secondMinimum(4, [[1, 2], [1, 3], [2, 3]], 10, 5) == 86"]}
{"task_num": 2059, "task_title": "Minimum Operations to Convert Number", "func_name": "minimumOperations", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\n    ans = 0\n    q = collections.deque([start])\n    seen = {start}\n\n    while q:\n      ans += 1\n      for _ in range(len(q)):\n        x = q.popleft()\n        for num in nums:\n          for res in (x + num, x - num, x ^ num):\n            if res == goal:\n              return ans\n            if res < 0 or res > 1000 or res in seen:\n              continue\n            seen.add(res)\n            q.append(res)\n\n    return -1\n", "tests": ["def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations([10, 5], 3, 9) == 2", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations([3,5], 0, 8) == -1", "Here is the Python function that covers the target execution path:\n\n```python\ndef test_minimumOperations():\n    solution = Solution()\n    nums = [5, -2]\n    start = 10\n    goal = 20\n\n    assert solution.minimumOperations(nums, start, goal) == -1\n```\n\nIn this case, for `x = start` (`start = 10`), none of the operations (`+`, `-`, `^`) with `nums[0]` (`5`) and `nums[1]` (`-2`) can directly reach the `goal` (`20`). So, the function returns `-1`.", "def test_minimumOperations():\n    nums = [5]\n    start = 1000\n    goal = 500\n    solution = Solution()\n    assert solution.minimumOperations(nums, start, goal) == -1", "def test_minimumOperations():\n    solution = Solution()\n    nums, start, goal = [50], 200, -300\n    assert solution.minimumOperations(nums, start, goal) == 2", "```python\ndef test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations([-1, 1], 2, 5) == -1\n\ntest_minimumOperations()\n```"]}
{"task_num": 2076, "task_title": "Process Restricted Friend Requests", "func_name": "friendRequests", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\n    ans = []\n    uf = UnionFind(n)\n\n    for u, v in requests:\n      pu = uf.find(u)\n      pv = uf.find(v)\n      isValid = True\n      if pu != pv:\n        for x, y in restrictions:\n          px = uf.find(x)\n          py = uf.find(y)\n          if (pu, pv) in [(px, py), (py, px)]:\n            isValid = False\n            break\n      ans.append(isValid)\n      if isValid:\n        uf.unionByRank(pu, pv)\n\n    return ans\n", "tests": ["```python\ndef test_friendRequests():\n    solution = Solution()\n    assert(solution.friendRequests(3,\n        [[0, 2]],\n        [[1, 2]]) == [False])\n```", "Here is the Python code for the function `friendRequests`. The test case is designed to follow the specified execution path.\n\n```python\ndef test_friendRequests():\n    solution = Solution()\n\n    # Test case following the target execution path\n    n = 6\n    restrictions = [[0, 1], [2, 3]]\n    requests = [[4, 5], [0, 2], [3, 0]]\n\n    assert solution.friendRequests(n, restrictions, requests) == [True, False, False]\n```\n\nIn this test case:\n- `n` is set to 6.\n- The first two people (0 and 1) cannot be friends due to the restriction `[0, 1]`.\n- There are three friend requests: between people 4 and 5, then 0 and 2, and finally 3 and 0.\n- The third request fails because person 3 has already been connected with person 0 (through the second request), and there is a restriction between them. This follows the target execution path in the function `friendRequests`.", "def test_friendRequests():\n    solution = Solution()\n    assert solution.friendRequests(3, [[1, 2]], [[0, 1]]) == [True]"]}
{"task_num": 2086, "task_title": "Minimum Number of Food Buckets to Feed the Hamsters", "func_name": "minimumBuckets", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumBuckets(self, street: str) -> int:\n    A = list(street)\n\n    for i, c in enumerate(A):\n      if c == 'H':\n        if i > 0 and A[i - 1] == 'B':\n          continue\n        if i + 1 < len(A) and A[i + 1] == '.':\n          A[i + 1] = 'B'\n        elif i > 0 and A[i - 1] == '.':\n          A[i - 1] = 'B'\n        else:\n          return -1\n\n    return A.count('B')\n", "tests": ["def test_minimumBuckets():\n    solution = Solution()\n    assert(solution.minimumBuckets(\"HH\") == -1)", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('..H.B.H.') == -1", "def test_minimumBuckets():\n    solution = Solution()\n    assert(solution.minimumBuckets(\"H....\") == -1)", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets(\"H....\") == 0"]}
{"task_num": 2092, "task_title": "Find All People With Secret", "func_name": "findAllPeople", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def connected(self, u: int, v: int) -> bool:\n    return self._find(self.id[u]) == self._find(self.id[v])\n\n  def reset(self, u: int) -> None:\n    self.id[u] = u\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\n    uf = UnionFind(n)\n    timeToPairs = collections.defaultdict(list)\n\n    uf.unionByRank(0, firstPerson)\n\n    for x, y, time in meetings:\n      timeToPairs[time].append((x, y))\n\n    for _, pairs in sorted(timeToPairs.items(), key=lambda x: x[0]):\n      peopleUnioned = set()\n      for x, y in pairs:\n        uf.unionByRank(x, y)\n        peopleUnioned.add(x)\n        peopleUnioned.add(y)\n      for person in peopleUnioned:\n        if not uf.connected(person, 0):\n          uf.reset(person)\n\n    res=[]\n    for i in range(n):\n      if uf.connected(i, 0):\n        res.append(i)\n    return res\n", "tests": ["```python\ndef test_findAllPeople():\n    solution = Solution()\n    meetings = [[0, 1, 0], [1, 2, 1], [2, 3, 2]]\n    assert solution.findAllPeople(4, meetings, 1) == [0, 1, 2]\n```", "def test_findAllPeople():\n    solution = Solution()\n    assert solution.findAllPeople(4, [[0, 1, 0], [1, 2, 1], [2, 3, 2]], 0) == [0, 1, 2, 3]", "```python\ndef test_findAllPeople():\n    solution = Solution()\n    meetings = [[0, 1, 0], [1, 2, 1], [2, 3, 2]]\n    assert solution.findAllPeople(4, meetings, 1) == [0, 1, 2]\n```", "def test_findAllPeople():\n    solution = Solution()\n    assert solution.findAllPeople(4, [(0, 1, 1), (2, 3, 1)], 1) == [0, 1, 2, 3]", "def test_findAllPeople():\n    solution = Solution()\n    n = 4\n    meetings = [[0,1,0],[1,2,1],[3,1,2]]\n    firstPerson = 1\n    assert solution.findAllPeople(n, meetings, firstPerson) == [0,1,2]"]}
{"task_num": 2115, "task_title": "Find All Possible Recipes from Given Supplies", "func_name": "findAllRecipes", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n    ans = []\n    supplies = set(supplies)\n    graph = collections.defaultdict(list)\n    inDegrees = collections.Counter()\n    q = collections.deque()\n\n    for i, recipe in enumerate(recipes):\n      for ingredient in ingredients[i]:\n        if ingredient not in supplies:\n          graph[ingredient].append(recipe)\n          inDegrees[recipe] += 1\n\n    for recipe in recipes:\n      if inDegrees[recipe] == 0:\n        q.append(recipe)\n\n    while q:\n      u = q.popleft()\n      ans.append(u)\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    return ans\n", "tests": ["def test_findAllRecipes():\n    solution = Solution()\n    assert solution.findAllRecipes([\"a\", \"b\"], [[\"a\", \"b\"]], [\"b\"]) == [\"a\"]\n    assert solution.findAllRecipes([\"a\", \"b\"], [[\"a\", \"b\"]], [\"b\", \"a\"]) == [\"a\", \"b\"]\n    assert solution.findAllRecipes([\"a\", \"b\"], [[\"a\", \"b\"]], [\"c\"]) == []", "```python\ndef test_findAllRecipes():\n    solution = Solution()\n    recipes = [\"a\", \"b\"]\n    ingredients = [[\"c\"], [\"d\"]]\n    supplies = [\"d\"]\n    assert solution.findAllRecipes(recipes, ingredients, supplies) == [\"a\"]\n```", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = [\"A\", \"B\"]\n    ingredients = [[\"B\"], [\"A\"]]\n    supplies = [\"X\", \"Y\"]\n    assert solution.findAllRecipes(recipes, ingredients, supplies) == [\"B\", \"A\"]", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = [\"a\", \"b\", \"c\"]\n    ingredients = [[\"x\"], [\"y\", \"z\"], []]\n    supplies = [\"x\", \"y\", \"z\"]\n    assert solution.findAllRecipes(recipes, ingredients, supplies) == [\"a\", \"b\", \"c\"]", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = [\"a\", \"b\", \"c\"]\n    ingredients = [[\"c\"], [\"a\"], [\"b\"]]\n    supplies = [\"c\", \"d\"]\n    assert solution.findAllRecipes(recipes, ingredients, supplies) == []"]}
{"task_num": 2127, "task_title": "Maximum Employees to Be Invited to a Meeting", "func_name": "maximumInvitations", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import Enum\n\n\nclass State(Enum):\n  kInit = 0\n  kVisiting = 1\n  kVisited = 2\n\n\nclass Solution:\n  def maximumInvitations(self, favorite: List[int]) -> int:\n    n = len(favorite)\n    sumComponentsLength = 0\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n    maxChainLength = [1] * n\n\n    for i, f in enumerate(favorite):\n      graph[i].append(f)\n      inDegrees[f] += 1\n\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n\n    while q:\n      u = q.popleft()\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n        maxChainLength[v] = max(maxChainLength[v], 1 + maxChainLength[u])\n\n    for i in range(n):\n      if favorite[favorite[i]] == i:\n        sumComponentsLength += maxChainLength[i] + maxChainLength[favorite[i]]\n\n    maxCycleLength = 0\n    parent = [-1] * n\n    seen = set()\n    states = [State.kInit] * n\n\n    def findCycle(u: int) -> None:\n      nonlocal maxCycleLength\n      seen.add(u)\n      states[u] = State.kVisiting\n      for v in graph[u]:\n        if v not in seen:\n          parent[v] = u\n          findCycle(v)\n        elif states[v] == State.kVisiting:\n          curr = u\n          cycleLength = 1\n          while curr != v:\n            curr = parent[curr]\n            cycleLength += 1\n          maxCycleLength = max(maxCycleLength, cycleLength)\n      states[u] = State.kVisited\n\n    for i in range(n):\n      if i not in seen:\n        findCycle(i)\n\n    return max(sumComponentsLength // 2, maxCycleLength)\n", "tests": ["```python\ndef test_maximumInvitations():\n    solution = Solution()\n    favorite = [1, 2, 0]\n    assert solution.maximumInvitations(favorite) == 2\n```\nIn this test case, the execution path should follow 'Line 62: (curr != v)' -> 'Line 68: (i in range(n))' -> 'Line 69: (i not in seen)', as described in the target execution path.", "def test_maximumInvitations():\n    solution = Solution()\n    favorite = [1,2,0]\n    assert solution.maximumInvitations(favorite) == 2", "def test_maximumInvitations():\n    favorite = [0, 2, 1, 3, 4, 5]\n    assert solution.maximumInvitations(favorite) == 5", "def test_maximumInvitations():\n    solution = Solution()\n    favorite = [0, 1, 2, 1]\n    assert solution.maximumInvitations(favorite) == max(sumComponentsLength // 2, maxCycleLength)", "def test_maximumInvitations():\n    solution = Solution()\n    favorite = [0, 1, 2, 3, 1]\n    assert solution.maximumInvitations(favorite) == 2"]}
{"task_num": 2132, "task_title": "Stamping the Grid", "func_name": "possibleToStamp", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def possibleToStamp(self, grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:\n    m = len(grid)\n    n = len(grid[0])\n    A = [[0] * (n + 1) for _ in range(m + 1)]\n    B = [[0] * (n + 1) for _ in range(m + 1)]\n    fit = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        A[i + 1][j + 1] = A[i + 1][j] + A[i][j + 1] - A[i][j] + grid[i][j]\n        if i + 1 >= stampHeight and j + 1 >= stampWidth:\n          x = i - stampHeight + 1\n          y = j - stampWidth + 1\n          if A[i + 1][j + 1] - A[x][j + 1] - A[i + 1][y] + A[x][y] == 0:\n            fit[i][j] = True\n\n    for i in range(m):\n      for j in range(n):\n        B[i + 1][j + 1] = B[i + 1][j] + B[i][j + 1] - B[i][j] + fit[i][j]\n\n    for i in range(m):\n      for j in range(n):\n        if not grid[i][j]:\n          x = min(i + stampHeight, m)\n          y = min(j + stampWidth, n)\n          if B[x][y] - B[i][y] - B[x][j] + B[i][j] == 0:\n            return False\n\n    return True\n", "tests": ["def test_possibleToStamp():\n    solution = Solution()\n    assert not solution.possibleToStamp([[0]], 1, 1)", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [\n        [0, 0],\n        [1, 1]\n    ]\n    stampHeight = 2\n    stampWidth = 2\n    assert not solution.possibleToStamp(grid, stampHeight, stampWidth)", "def test_possibleToStamp():\n    solution = Solution()\n    assert solution.possibleToStamp([[0, 0], [1, 1]], 2, 1)", "```python\ndef test_possibleToStamp():\n    solution = Solution()\n    assert not solution.possibleToStamp([[1, 1], [1, 1]], 2, 2)\n```\nThis test case covers the target execution path by providing a grid that has all cells occupied with `1`s. The stamps have dimensions of `2 x 2`, ensuring that the condition in line 22 is satisfied for at least some iterations (i.e., when `i` and `j` are both greater than or equal to `stampHeight - 1`). However, since all cells are occupied, the function will return `False` as it's impossible to fit any stamps while following the given restrictions."]}
{"task_num": 2146, "task_title": "K Highest Ranked Items Within a Price Range", "func_name": "highestRankedKItems", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    low, high = pricing\n    row, col = start\n    ans = []\n\n    if low <= grid[row][col] <= high:\n      ans.append([row, col])\n      if k == 1:\n        return ans\n\n    q = collections.deque([(row, col)])\n    seen = {(row, col)}\n\n    while q:\n      neighbors = []\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for t in range(4):\n          x = i + dirs[t][0]\n          y = j + dirs[t][1]\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if not grid[x][y] or (x, y) in seen:\n            continue\n          if low <= grid[x][y] <= high:\n            neighbors.append([x, y])\n          q.append((x, y))\n          seen.add((x, y))\n      neighbors.sort(key=lambda x: (grid[x[0]][x[1]], x[0], x[1]))\n      for neighbor in neighbors:\n        if len(ans) < k:\n          ans.append(neighbor)\n        if len(ans) == k:\n          return ans\n\n    return ans\n", "tests": ["def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[1,2],[0,3]]\n    pricing = [1, 3]\n    start = [0, 0]\n    k = 4\n    assert solution.highestRankedKItems(grid, pricing, start, k) == [[0, 0], [0, 1]]", "```python\ndef test_highestRankedKItems():\n    solution = Solution()\n    assert solution.highestRankedKItems([[1, 0, 1], [1, 1, 1]], [1, 2], [0, 0], 3) == [[0, 0], [1, 0]]\n```", "```python\ndef test_highestRankedKItems():\n    solution = Solution()\n    assert solution.highestRankedKItems([[1, 2], [3, 4]], [1, 3], [0, 0], 5) == [[1, 0], [0, 0], [0, 1]]\n```", "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[1, 2], [3, 0]]\n    pricing = [1, 3]\n    start = [0, 0]\n    k = 2\n    assert solution.highestRankedKItems(grid, pricing, start, k) == [[1, 0]]", "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[1, 0], [0, 2]]\n    pricing = [1, 3]\n    start = [0, 0]\n    k = 2\n    assert solution.highestRankedKItems(grid, pricing, start, k) == [[0, 1]]", "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[0, 1, 1], [1, 2, 3], [1, 1, 1]]\n    pricing = [1, 3]\n    start = [0, 0]\n    k = 4\n    assert solution.highestRankedKItems(grid, pricing, start, k) == [[0, 1]]"]}
{"task_num": 2157, "task_title": "Groups of Strings", "func_name": "groupStrings", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.sz = [1] * n\n\n  def unionBySize(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.sz[i] < self.sz[j]:\n      self.sz[j] += self.sz[i]\n      self.id[i] = j\n    else:\n      self.sz[i] += self.sz[j]\n      self.id[j] = i\n    self.count -= 1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def groupStrings(self, words: List[str]) -> List[int]:\n    uf = UnionFind(len(words))\n\n    def getMask(s: str) -> int:\n      mask = 0\n      for c in s:\n        mask |= 1 << ord(c) - ord('a')\n      return mask\n\n    def getAddedMasks(mask: int):\n      for i in range(26):\n        if not (mask >> i & 1):\n          yield mask | 1 << i\n\n    def getDeletedMasks(mask: int):\n      for i in range(26):\n        if mask >> i & 1:\n          yield mask ^ 1 << i\n\n    maskToIndex = {getMask(word): i for i, word in enumerate(words)}\n    deletedMaskToIndex = {}\n\n    for i, word in enumerate(words):\n      mask = getMask(word)\n      for m in getAddedMasks(mask):\n        if m in maskToIndex:\n          uf.unionBySize(i, maskToIndex[m])\n      for m in getDeletedMasks(mask):\n        if m in maskToIndex:\n          uf.unionBySize(i, maskToIndex[m])\n        if m in deletedMaskToIndex:\n          uf.unionBySize(i, deletedMaskToIndex[m])\n        else:\n          deletedMaskToIndex[m] = i\n\n    return [uf.count, max(uf.sz)]\n", "tests": ["def test_groupStrings():\n    solution = Solution()\n    words = [\"abc\", \"acb\"]\n    assert solution.groupStrings(words) == [1, len(words)]", "def test_groupStrings():\n    solution = Solution()\n    words = [\"abc\", \"acc\"]\n    assert solution.groupStrings(words) == [2, 2]", "def test_groupStrings():\n    solution = Solution()\n    words = [\"abc\", \"acb\", \"bca\", \"cab\", \"cba\"]\n    assert solution.groupStrings(words) == [3, 2]"]}
{"task_num": 2182, "task_title": "Construct String With Repeat Limit", "func_name": "repeatLimitedString", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\n    ans = ''\n    count = collections.Counter(s)\n\n    while True:\n      addOne = ans and self._shouldAddOne(ans, count)\n      c = self._getLargestChar(ans, count)\n      if c == ' ':\n        break\n      repeats = 1 if addOne else min(count[c], repeatLimit)\n      ans += c * repeats\n      count[c] -= repeats\n\n    return ans\n\n  def _shouldAddOne(self, ans: str, count: collections.Counter) -> bool:\n    for c in reversed(string.ascii_lowercase):\n      if count[c]:\n        return ans[-1] == c\n    return False\n\n  def _getLargestChar(self, ans: str, count: collections.Counter) -> int:\n    for c in reversed(string.ascii_lowercase):\n      if count[c] and (not ans or ans[-1] != c):\n        return c\n    return ' '\n", "tests": ["def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString(\"ccz\", 3) == \"cczz\"", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString(\"aabbcc\", 2) == \"ccabbaa\"", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('aab', 3) == 'bbba'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString(\"bbb\", 2) == \"b\""]}
{"task_num": 2203, "task_title": "Minimum Weighted Subgraph With the Required Paths", "func_name": "minimumWeight", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\n    graph = [[] for _ in range(n)]\n    reversedGraph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      reversedGraph[v].append((u, w))\n\n    fromSrc1 = self._dijkstra(graph, src1)\n    fromSrc2 = self._dijkstra(graph, src2)\n    fromDest = self._dijkstra(reversedGraph, dest)\n    minWeight = min(a + b + c for a, b, c in zip(fromSrc1, fromSrc2, fromDest))\n    if minWeight == math.inf:\n      return -1\n    else:\n      return minWeight\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int) -> List[int]:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist\n", "tests": ["def test_minimumWeight():\n    solution = Solution()\n    assert solution.minimumWeight(\n        n=4,\n        edges=[[0, 1, 2], [0, 2, 3], [1, 2, 1], [1, 3, 4], [2, 3, 5]],\n        src1=0,\n        src2=1,\n        dest=3\n    ) == -1", "def test_minimumWeight():\n    solution = Solution()\n    n = 6\n    edges = [[0, 1, 3], [0, 2, 1], [1, 2, 4], [1, 3, 5], [3, 4, 7], [4, 5, 9]]\n    src1 = 0\n    src2 = 2\n    dest = 5\n    assert solution.minimumWeight(n, edges, src1, src2, dest) == -1", "def test_minimumWeight():\n    solution = Solution()\n    assert solution.minimumWeight(4,\n                                   [[0, 1, 2], [0, 2, 3], [1, 3, 5], [2, 3, 7]],\n                                   0, 1, 3) == -1"]}
{"task_num": 2242, "task_title": "Maximum Score of a Node Sequence", "func_name": "maximumScore", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\n    n = len(scores)\n    ans = -1\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append((scores[v], v))\n      graph[v].append((scores[u], u))\n\n    for i in range(n):\n      graph[i] = heapq.nlargest(3, graph[i])\n\n    for u, v in edges:\n      for scoreA, a in graph[u]:\n        for scoreB, b in graph[v]:\n          if a != b and a != v and b != u:\n            ans = max(ans, scoreA + scores[u] + scores[v] + scoreB)\n\n    return ans\n", "tests": ["```python\ndef test_maximumScore():\n    solution = Solution()\n    scores = [10, 9, 8, 7]\n    edges = [[0, 1], [1, 2], [2, 3]]\n    assert solution.maximumScore(scores, edges) == 24\n```", "Here's the test case that follows the target execution path:\n\n```python\ndef test_maximumScore():\n    solution = Solution()\n    scores = [10, 9, 8, 7]\n    edges = [(0, 1), (1, 2), (2, 3)]\n    assert solution.maximumScore(scores, edges) == 34\n```", "def test_maximumScore():\n    solution = Solution()\n    scores = [10, 5, 20, 8]\n    edges = [[0, 1], [0, 3], [1, 2], [2, 3]]\n    assert solution.maximumScore(scores, edges) == -1", "def test_maximumScore():\n    solution = Solution()\n    scores = [10, 15, 20]\n    edges = [[0, 1], [0, 2], [1, 2]]\n    assert solution.maximumScore(scores, edges) == -1"]}
{"task_num": 2245, "task_title": "Maximum Trailing Zeros in a Cornered Path", "func_name": "maxTrailingZeros", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxTrailingZeros(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    leftPrefix2 = [[0] * n for _ in range(m)]\n    leftPrefix5 = [[0] * n for _ in range(m)]\n    topPrefix2 = [[0] * n for _ in range(m)]\n    topPrefix5 = [[0] * n for _ in range(m)]\n\n    def getCount(num: int, factor: int) -> int:\n      count = 0\n      while num % factor == 0:\n        num //= factor\n        count += 1\n      return count\n\n    for i in range(m):\n      for j in range(n):\n        leftPrefix2[i][j] = getCount(grid[i][j], 2)\n        leftPrefix5[i][j] = getCount(grid[i][j], 5)\n        if j:\n          leftPrefix2[i][j] += leftPrefix2[i][j - 1]\n          leftPrefix5[i][j] += leftPrefix5[i][j - 1]\n\n    for j in range(n):\n      for i in range(m):\n        topPrefix2[i][j] = getCount(grid[i][j], 2)\n        topPrefix5[i][j] = getCount(grid[i][j], 5)\n        if i:\n          topPrefix2[i][j] += topPrefix2[i - 1][j]\n          topPrefix5[i][j] += topPrefix5[i - 1][j]\n\n    ans = 0\n    for i in range(m):\n      for j in range(n):\n        curr2 = getCount(grid[i][j], 2)\n        curr5 = getCount(grid[i][j], 5)\n        l2 = leftPrefix2[i][j]\n        l5 = leftPrefix5[i][j]\n        r2 = leftPrefix2[i][n - 1] - (0 if j == 0 else leftPrefix2[i][j - 1])\n        r5 = leftPrefix5[i][n - 1] - (0 if j == 0 else leftPrefix5[i][j - 1])\n        t2 = topPrefix2[i][j]\n        t5 = topPrefix5[i][j]\n        d2 = topPrefix2[m - 1][j] - (0 if i == 0 else topPrefix2[i - 1][j])\n        d5 = topPrefix5[m - 1][j] - (0 if i == 0 else topPrefix5[i - 1][j])\n        ans = max(ans, min(l2 + t2 - curr2, l5 + t5 - curr5), min(r2 + t2 - curr2, r5 + t5 - curr5), min(l2 + d2 - curr2, l5 + d5 - curr5), min(r2 + d2 - curr2, r5 + d5 - curr5))\n\n    return ans\n", "tests": ["def test_maxTrailingZeros():\n    solution = Solution()\n    assert solution.maxTrailingZeros([[16, 0, 2], [8, 4, 0]]) == 3", "def test_maxTrailingZeros():\n    solution = Solution()\n    grid = [[16,8],[4,2]]\n    assert solution.maxTrailingZeros(grid) == 3", "def test_maxTrailingZeros():\n    solution = Solution()\n    grid = [[16, 256], [3, 8]]\n    assert solution.maxTrailingZeros(grid) == 3", "def test_maxTrailingZeros():\n    solution = Solution()\n    assert solution.maxTrailingZeros([[4, 3, 5], [12, 6, 2]]) == 0"]}
{"task_num": 2257, "task_title": "Count Unguarded Cells in the Grid", "func_name": "countUnguarded", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\n    ans = 0\n    grid = [[0] * n for _ in range(m)]\n    left = [[0] * n for _ in range(m)]\n    right = [[0] * n for _ in range(m)]\n    up = [[0] * n for _ in range(m)]\n    down = [[0] * n for _ in range(m)]\n\n    for row, col in guards:\n      grid[row][col] = 'G'\n\n    for row, col in walls:\n      grid[row][col] = 'W'\n\n    for i in range(m):\n      lastCell = 0\n      for j in range(n):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          left[i][j] = lastCell\n      lastCell = 0\n      for j in range(n - 1, -1, -1):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          right[i][j] = lastCell\n\n    for j in range(n):\n      lastCell = 0\n      for i in range(m):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          up[i][j] = lastCell\n      lastCell = 0\n      for i in range(m - 1, -1, -1):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          down[i][j] = lastCell\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 0 and left[i][j] != 'G' and right[i][j] != 'G' and up[i][j] != 'G' and down[i][j] != 'G':\n          ans += 1\n\n    return ans\n", "tests": ["def test_countUnguarded():\n\tsolution = Solution()\n\tassert(solution.countUnguarded(2, 3, [[0, 1]], [[0, 0], [1, 2]]) == 4)", "def test_countUnguarded():\n    solution = Solution()\n    assert solution.countUnguarded(2, 3, [[0, 0], [1, 1]], [[1, 0]]) == 5", "def test_countUnguarded():\n    solution = Solution()\n    assert solution.countUnguarded(3, 4, [[0, 1], [2, 2]], [[1, 2]]) == 5", "def test_countUnguarded():\n    solution = Solution()\n    assert solution.countUnguarded(5, 5, [[0, 2], [1, 4]], [[3, 1], [2, 2]]) == 6"]}
{"task_num": 2258, "task_title": "Escape the Spreading Fire", "func_name": "maximumMinutes", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumMinutes(self, grid: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    kMax = len(grid) * len(grid[0])\n    fireGrid = [[-1] * len(grid[0]) for _ in range(len(grid))]\n    self._buildFireGrid(grid, fireGrid, dirs)\n\n    ans = -1\n    l = 0\n    r = kMax\n\n    while l <= r:\n      m = (l + r) // 2\n      if self._canStayFor(grid, fireGrid, m, dirs):\n        ans = m\n        l = m + 1\n      else:\n        r = m - 1\n\n    return int(1e9) if ans == kMax else ans\n\n  def _buildFireGrid(self, grid: List[List[int]], fireMinute: List[List[int]], dirs: List[int]) -> None:\n    minuteFromFire = 0\n    q = collections.deque()\n\n    for i in range(len(grid)):\n      for j in range(len(grid[0])):\n        if grid[i][j] == 1:\n          q.append((i, j))\n          fireMinute[i][j] = 0\n    while q:\n      minuteFromFire += 1\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == len(grid) or y < 0 or y == len(grid[0]):\n            continue\n          if grid[x][y] == 2:\n            continue\n          if fireMinute[x][y] != -1:\n            continue\n          fireMinute[x][y] = minuteFromFire\n          q.append((x, y))\n\n  def _canStayFor(self, grid: List[List[int]], fireMinute: List[List[int]], minute: int, dirs: List[int]) -> bool:\n    q = collections.deque([(0, 0)])\n    seen = {(0, 0)}\n\n    while q:\n      minute += 1\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == len(grid) or y < 0 or y == len(grid[0]):\n            continue\n          if grid[x][y] == 2:\n            continue\n          if x == len(grid) - 1 and y == len(grid[0]) - 1:\n            if fireMinute[x][y] != -1 and fireMinute[x][y] < minute:\n              continue\n            return True\n          if fireMinute[x][y] != -1 and fireMinute[x][y] <= minute:\n            continue\n          if (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n\n    return False\n", "tests": ["```python\ndef test_maximumMinutes():\n    solution = Solution()\n    grid = [\n        [1, 2],\n        [2, 1]\n    ]\n    assert solution.maximumMinutes(grid) == -1\n```\nThis test case covers the target execution path by having `fireMinute[x][y]` not equal to `-1` at line 52 and then trying to access invalid indices `(x < 0 or x == len(grid) or y < 0 or y == len(grid[0]))` in the following iterations, ensuring that the loop condition at lines 45 and 48 is met.", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [\n        [0, 2],\n        [1, 2]\n    ]\n    assert solution.maximumMinutes(grid) == 1", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[1, 2, 0], [0, 0, 0], [0, 0, 1]]\n    assert solution.maximumMinutes(grid) == -1", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[1, 0], [2, 0]]\n    assert solution.maximumMinutes(grid) == 0", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [\n        [0, 2],\n        [1, 0]\n    ]\n    assert solution.maximumMinutes(grid) == 1", "Here's a test method for `maximumMinutes` that follows the given execution path:\n\n```python\ndef test_maximumMinutes():\n    solution = Solution()\n\n    # Prepare the grid\n    grid = [\n        [1, 0, 0],\n        [0, 2, 0],\n        [0, 0, 2]\n    ]\n\n    # Prepare the test case for maximumMinutes function\n    assert solution.maximumMinutes(grid) == 5\n\n    # Test execution path:\n    # Line 65: (dx, dy in dirs)\n    # Line 72: (x == len(grid) - 1 and y == len(grid[0]) - 1)\n    # Line 24: (self._canStayFor(grid, fireGrid, m, dirs))\n    # Line 22: (l <= r)\n    # Line 61: (q)\n\n    grid = [\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 2]\n    ]\n\n    assert solution.maximumMinutes(grid) == -1\n```"]}
{"task_num": 2290, "task_title": "Minimum Obstacle Removal to Reach Corner", "func_name": "minimumObstacles", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumObstacles(self, grid: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    minHeap = [(grid[0][0], 0, 0)]  # (d, i, j)\n    dist = [[math.inf] * n for _ in range(m)]\n    dist[0][0] = grid[0][0]\n\n    while minHeap:\n      d, i, j = heapq.heappop(minHeap)\n      if i == m - 1 and j == n - 1:\n        return d\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        newDist = d + grid[i][j]\n        if newDist < dist[x][y]:\n          dist[x][y] = newDist\n          heapq.heappush(minHeap, (newDist, x, y))\n\n    return dist[m - 1][n - 1]\n", "tests": ["```python\ndef test_minimumObstacles():\n    solution = Solution()\n    assert solution.minimumObstacles([[0,1],[1,1]]) == 2\n```\nThis test case will follow the target execution path by providing a grid with obstacles only in the second cell of each row. This ensures that all branch conditions are satisfied sequentially as intended.", "def test_minimumObstacles():\n    solution = Solution()\n    assert solution.minimumObstacles([[0, 1], [1, 0]]) == 2", "def test_minimumObstacles():\n    solution = Solution()\n    grid = [[1, 0], [0, 1]]\n    assert solution.minimumObstacles(grid) == 2", "```python\ndef test_minimumObstacles():\n    solution = Solution()\n    grid = [[1, 0], [0, 1]]\n    assert solution.minimumObstacles(grid) == 1\n```\nIn this test case, the grid is `[[1, 0], [0, 1]]`. The function should return 1 because to move from `(0, 0)` to `(1, 1)`, we need to remove one obstacle. This test case covers the target execution path in the given program under test."]}
{"task_num": 2299, "task_title": "Strong Password Checker II", "func_name": "strongPasswordCheckerII", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def strongPasswordCheckerII(self, password: str) -> bool:\n    if len(password) < 8:\n      return False\n    if not any(c.islower() for c in password):\n      return False\n    if not any(c.isupper() for c in password):\n      return False\n    if not any(c.isdigit() for c in password):\n      return False\n    if not any(\"!@#$%^&*()-+\".find(c) != -1 for c in password):\n      return False\n    return all(a != b for a, b in zip(password, password[1:]))\n", "tests": ["def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert not solution.strongPasswordCheckerII(\"aabbcc\")", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert not solution.strongPasswordCheckerII(\"Aa@123\")", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert not solution.strongPasswordCheckerII(\"a\")"]}
{"task_num": 2301, "task_title": "Match Substring After Replacement", "func_name": "matchReplacement", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def matchReplacement(self, s: str, sub: str, mappings: List[List[str]]) -> bool:\n    isMapped = [[False] * 128 for _ in range(128)]\n\n    for old, new in mappings:\n      isMapped[ord(old)][ord(new)] = True\n\n    for i in range(len(s)):\n      if self._canTransform(s, i, sub, isMapped):\n        return True\n\n    return False\n\n  def _canTransform(self, s: str, start: int, sub: str, isMapped: List[List[bool]]) -> bool:\n    if start + len(sub) > len(s):\n      return False\n\n    for i in range(len(sub)):\n      a = sub[i]\n      b = s[start + i]\n      if a != b and not isMapped[ord(a)][ord(b)]:\n        return False\n\n    return True\n", "tests": ["def test_matchReplacement():\n    solution = Solution()\n    assert not solution.matchReplacement(\"abc\", \"ab\", [[\"a\", \"b\"]])", "def test_matchReplacement():\n    solution = Solution()\n    assert not solution.matchReplacement(\"abc\", \"abcd\", [[\"a\", \"b\"], [\"b\", \"c\"], [\"d\", \"e\"]])", "def test_matchReplacement():\n    solution = Solution()\n    assert not solution.matchReplacement(\"abc\", \"abcd\", [[\"a\", \"b\"], [\"c\", \"d\"]])", "Here is the test case that covers the target execution path:\n\n```python\ndef test_matchReplacement():\n    solution = Solution()\n    assert not solution.matchReplacement(\"abc\", \"ab\", [[\"a\", \"b\"]])\n```", "def test_matchReplacement():\n    solution = Solution()\n    assert not solution.matchReplacement(\"abc\", \"a\", [[\"b\", \"c\"]])"]}
{"task_num": 2322, "task_title": "Minimum Score After Removals on a Tree", "func_name": "minimumScore", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Set\n\nclass Solution:\n  def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\n    n = len(nums)\n    xors = functools.reduce(lambda x, y: x ^ y, nums)\n    subXors = nums[:]\n    tree = [[] for _ in range(n)]\n    children = [{i} for i in range(n)]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, parent: int) -> Tuple[int, Set[int]]:\n      for v in tree[u]:\n        if v == parent:\n          continue\n        vXor, vChildren = dfs(v, u)\n        subXors[u] ^= vXor\n        children[u] |= vChildren\n      return subXors[u], children[u]\n\n    dfs(0, -1)\n\n    ans = math.inf\n    for i in range(len(edges)):\n      a, b = edges[i]\n      if b in children[a]:\n        a, b = b, a\n      for j in range(i):\n        c, d = edges[j]\n        if d in children[c]:\n          c, d = d, c\n\n        if c in children[a] and a != c:\n          cands = [subXors[c], subXors[a] ^ subXors[c], xors ^ subXors[a]]\n        elif a in children[c] and a != c:\n          cands = [subXors[a], subXors[c] ^ subXors[a], xors ^ subXors[c]]\n        else:\n          cands = [subXors[a], subXors[c], xors ^ subXors[a] ^ subXors[c]]\n        ans = min(ans, max(cands) - min(cands))\n\n    return ans\n", "tests": ["def test_minimumScore():\n    solution = Solution()\n    nums = [1,2,3,4]\n    edges = [[0,1],[1,2],[2,3]]\n    assert solution.minimumScore(nums, edges) == 2", "def test_minimumScore():\n    solution = Solution()\n    nums = [1, 3, 7]\n    edges = [[0, 1], [1, 2]]\n    assert solution.minimumScore(nums, edges) == min([nums[0] ^ nums[1]] - [nums[2]], [nums[1] ^ nums[2]] - [nums[0]], [(nums[0] ^ nums[1]) ^ nums[2]] - [nums[1]])", "def test_minimumScore():\n    solution = Solution()\n    nums = [0, 2, 3, 7, 5]\n    edges = [[0, 1], [0, 2], [2, 3], [2, 4]]\n    assert solution.minimumScore(nums, edges) == 6", "def test_minimumScore():\n    nums = [3,1,7,6]\n    edges = [[0,1],[1,2],[2,3]]\n    solution = Solution()\n    assert solution.minimumScore(nums, edges) == 4"]}
{"task_num": 2332, "task_title": "The Latest Time to Catch a Bus", "func_name": "latestTimeCatchTheBus", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\n    buses.sort()\n    passengers.sort()\n\n    if passengers[0] > buses[-1]:\n      return buses[-1]\n\n    ans = passengers[0] - 1\n    i = 0\n    j = 0\n    while i < len(buses):\n      arrived = 0\n      while arrived < capacity and j < len(passengers) and passengers[j] <= buses[i]:\n        if j > 0 and passengers[j] != passengers[j - 1] + 1:\n          ans = passengers[j] - 1\n        j += 1\n        arrived += 1\n\n      if arrived < capacity and j > 0 and passengers[j - 1] != buses[i]:\n        ans = buses[i]\n      i += 1\n\n    return ans\n", "tests": ["def test_latestTimeCatchTheBus():\n    solution = Solution()\n    assert solution.latestTimeCatchTheBus([10,20,30], [5,8,9,12], 3) == 4", "def test_latestTimeCatchTheBus():\n    solution = Solution()\n    buses = [9, 7, 5]\n    passengers = [3, 6, 8, 10, 12]\n    capacity = 4\n    assert solution.latestTimeCatchTheBus(buses, passengers, capacity) == 8", "def test_latestTimeCatchTheBus():\n    solution = Solution()\n    buses = [1, 2]\n    passengers = [3, 5]\n    capacity = 1\n    assert solution.latestTimeCatchTheBus(buses, passengers, capacity) == 4", "def test_latestTimeCatchTheBus():\n    solution = Solution()\n    buses = [8, 2]\n    passengers = [6, 7]\n    capacity = 3\n    assert solution.latestTimeCatchTheBus(buses, passengers, capacity) == 5"]}
{"task_num": 2337, "task_title": "Move Pieces to Obtain a String", "func_name": "canChange", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def canChange(self, start: str, target: str) -> bool:\n    n = len(start)\n    i = 0\n    j = 0\n\n    while i <= n and j <= n:\n      while i < n and start[i] == '_':\n        i += 1\n      while j < n and target[j] == '_':\n        j += 1\n      if i == n or j == n:\n        return i == n and j == n\n      if start[i] != target[j]:\n        return False\n      if start[i] == 'R' and i > j:\n        return False\n      if start[i] == 'L' and i < j:\n        return False\n      i += 1\n      j += 1\n\n    return True\n", "tests": ["def test_canChange():\n    solution = Solution()\n    assert not solution.canChange(\"R__\", \"__R\")", "def test_canChange():\n    solution = Solution()\n    assert not solution.canChange('RL_', '__R')", "def test_canChange():\n    solution = Solution()\n    assert not solution.canChange('_L__', '__R__')", "def test_canChange():\n    solution = Solution()\n    assert not solution.canChange('_L___', '_R_R_R_')"]}
{"task_num": 2392, "task_title": "Build a Matrix With Conditions", "func_name": "buildMatrix", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\n    rowOrder = self._topologicalSort(rowConditions, k)\n    if not rowOrder:\n      return []\n\n    colOrder = self._topologicalSort(colConditions, k)\n    if not colOrder:\n      return []\n\n    ans = [[0] * k for _ in range(k)]\n    nodeToRowIndex = [0] * (k + 1)\n\n    for i, node in enumerate(rowOrder):\n      nodeToRowIndex[node] = i\n\n    for j, node in enumerate(colOrder):\n      i = nodeToRowIndex[node]\n      ans[i][j] = node\n\n    return ans\n\n  def _topologicalSort(self, conditions: List[List[int]], n: int) -> List[int]:\n    order = []\n    graph = [[] for _ in range(n + 1)]\n    inDegrees = [0] * (n + 1)\n\n    for u, v in conditions:\n      graph[u].append(v)\n      inDegrees[v] += 1\n\n    q = collections.deque([i for i in range(1, n + 1) if inDegrees[i] == 0])\n\n    while q:\n      u = q.popleft()\n      order.append(u)\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    if len(order) == n:\n      return order\n    else:\n      return []\n", "tests": ["def test_buildMatrix():\n    solution = Solution()\n    rowConditions = [[1,2], [2,3]]\n    colConditions = [[1,2], [2,3], [3,4]]\n    assert solution.buildMatrix(4, rowConditions, colConditions) == [[1,0,0,0],[0,2,0,0],[0,0,3,0],[0,0,0,4]]", "```\ndef test_buildMatrix():\n    solution = Solution()\n    assert solution.buildMatrix(3, [[1, 2], [2, 3]], [[1, 2], [2, 3]]) == []\n```", "def test_buildMatrix():\n    solution = Solution()\n    k = 3\n    rowConditions = [[2, 3], [1, 2]]\n    colConditions = [[3, 2], [2, 1], [1, 2]]\n    assert solution.buildMatrix(k, rowConditions, colConditions) == []"]}
{"task_num": 2437, "task_title": "Number of Valid Clock Times", "func_name": "countTime", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countTime(self, time: str) -> int:\n    ans = 1\n    if time[3] == '?':\n      ans *= 6\n    if time[4] == '?':\n      ans *= 10\n\n    if time[0] == '?' and time[1] == '?':\n      return ans * 24\n    if time[0] == '?':\n      if time[1] < '4':\n        return ans * 3\n      else:\n        return ans * 2\n    if time[1] == '?':\n      if time[0] == '2':\n        return ans * 4\n      else:\n        return ans * 10\n    return ans\n", "tests": ["def test_countTime():\n    solution = Solution()\n    assert solution.countTime(\"??::\") == 24 * 6 * 10", "def test_countTime():\n    solution = Solution()\n    assert solution.countTime(\"???0\") == 3", "def test_countTime():\n    solution = Solution()\n    assert solution.countTime(\"12::\") == 40"]}
{"task_num": 2456, "task_title": "Most Popular Video Creator", "func_name": "mostPopularCreator", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Creator:\n  def __init__(self, popularity: int, videoId: str, maxView: int):\n    self.popularity = popularity\n    self.videoId = videoId\n    self.maxView = maxView\n\n\nclass Solution:\n  def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\n    ans = []\n    maxPopularity = 0\n    nameToCreator = {}\n\n    for name, id, view in zip(creators, ids, views):\n      if name not in nameToCreator:\n        nameToCreator[name] = Creator(view, id, view)\n        maxPopularity = max(maxPopularity, view)\n        continue\n      creator = nameToCreator[name]\n      creator.popularity += view\n      maxPopularity = max(maxPopularity, creator.popularity)\n      if creator.maxView < view or creator.maxView == view and creator.videoId > id:\n        creator.videoId = id\n        creator.maxView = view\n\n    for name, creator in nameToCreator.items():\n      if creator.popularity == maxPopularity:\n        ans.append([name, creator.videoId])\n\n    return ans\n", "tests": ["def test_mostPopularCreator():\n    solution = Solution()\n    creators = ['A', 'B', 'C']\n    ids = ['1', '2', '3']\n    views = [10, 50, 60]\n    assert solution.mostPopularCreator(creators, ids, views) == [['B', '2']]", "def test_mostPopularCreator():\n    solution = Solution()\n    creators = [\"creatori\", \"creatori\", \"creatorj\"]\n    ids = [\"idi\", \"idk\", \"idi\"]\n    views = [10, 20, 30]\n    assert solution.mostPopularCreator(creators, ids, views) == [[\"creatori\", \"idi\"]]", "def test_mostPopularCreator():\n    solution = Solution()\n    creators = [\"alice\", \"bob\", \"alice\", \"charlie\"]\n    ids = [\"video1\", \"video2\", \"video3\", \"video4\"]\n    views = [10, 20, 15, 30]\n    assert solution.mostPopularCreator(creators, ids, views) == [[\"alice\", \"video3\"]]"]}
{"task_num": 2462, "task_title": "Total Cost to Hire K Workers", "func_name": "totalCost", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\n    ans = 0\n    i = 0\n    j = len(costs) - 1\n    minHeapL = []\n    minHeapR = []\n\n    for _ in range(k):\n      while len(minHeapL) < candidates and i <= j:\n        heapq.heappush(minHeapL, costs[i])\n        i += 1\n      while len(minHeapR) < candidates and i <= j:\n        heapq.heappush(minHeapR, costs[j])\n        j -= 1\n      if not minHeapL:\n        ans += heapq.heappop(minHeapR)\n      elif not minHeapR:\n        ans += heapq.heappop(minHeapL)\n      elif minHeapL[0] <= minHeapR[0]:\n        ans += heapq.heappop(minHeapL)\n      else:\n        ans += heapq.heappop(minHeapR)\n\n    return ans\n", "tests": ["def test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([1, 2, 3, 4], 4, 2) == 8", "def test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([3,2,7,7,1,2], 3, 2) == 6", "def test_totalCost():\n    solution = Solution()\n    costs = [1, 2, 3, candidates+2, candidates+1] # Ensure i <= j and len(minHeapL) < candidates initially\n    assert solution.totalCost(costs, k=2, candidates=candidates) == 4", "def test_totalCost():\n    solution = Solution()\n    costs = [3, 2, 7, 7, 1, 2]\n    k = 5\n    candidates = 1\n    assert solution.totalCost(costs, k, candidates) == 8"]}
{"task_num": 2467, "task_title": "Most Profitable Path in a Tree", "func_name": "mostProfitablePath", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\n    n = len(amount)\n    tree = [[] for _ in range(n)]\n    parent = [0] * n\n    aliceDist = [-1] * n\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, prev: int, d: int) -> None:\n      parent[u] = prev\n      aliceDist[u] = d\n      for v in tree[u]:\n        if aliceDist[v] == -1:\n          dfs(v, u, d + 1)\n\n    dfs(0, -1, 0)\n\n    u = bob\n    bobDist = 0\n    while u != 0:\n      if bobDist < aliceDist[u]:\n        amount[u] = 0\n      elif bobDist == aliceDist[u]:\n        amount[u] //= 2\n      u = parent[u]\n      bobDist += 1\n\n    return self._getMoney(tree, 0, -1, amount)\n\n  def _getMoney(self, tree: List[List[int]], u: int, prev: int, amount: List[int]) -> int:\n    if len(tree[u]) == 1 and tree[u][0] == prev:\n      return amount[u]\n\n    maxPath = -math.inf\n    for v in tree[u]:\n      if v != prev:\n        maxPath = max(maxPath, self._getMoney(tree, v, u, amount))\n\n    return amount[u] + maxPath\n", "tests": ["def test_mostProfitablePath():\n    solution = Solution()\n    edges = [[0, 1], [0, 2], [1, 3]]\n    bob = 0\n    amount = [-5, -6, -7, -8]\n    assert solution.mostProfitablePath(edges, bob, amount) == -5", "def test_mostProfitablePath():\n    edges = [[0,1], [0,2]]\n    bob = 1\n    amount = [-5, -3, -7]\n    solution = Solution()\n    assert solution.mostProfitablePath(edges, bob, amount) == 6", "def test_mostProfitablePath():\n    solution = Solution()\n    edges = [[0,1],[0,2],[1,3],[1,4]]\n    bob = 1\n    amount = [-5,-6,-7,-8]\n    assert solution.mostProfitablePath(edges, bob, amount) == -9", "Here's a test case for the `mostProfitablePath` function that covers the given execution path:\n\n```python\ndef test_mostProfitablePath():\n    solution = Solution()\n\n    edges = [[0, 1], [0, 2], [1, 3], [1, 4]]\n    bob = 0\n    amount = [-5, -3, 6, -7, 8]\n\n    assert solution.mostProfitablePath(edges, bob, amount) == 9\n```\n\nThis test case creates a tree with nodes `0`, `1`, `2`, `3`, and `4`. The execution path follows the conditions specified in the problem description:\n\n1. Bob starts at node `0` (line 31), so `u != 0` is false initially.\n2. Alice is at node `0` with distance `aliceDist[0] = 0` and Bob has distance `bobDist = 0`. So, `bobDist < aliceDist[u]` is true (line 34).\n3. Alice moves to node `1`, so `u != 0` becomes true.\n4. Now, Bob's distance is still less than Alice's (`bobDist < aliceDist[1]`), so the condition at line 34 is false.\n5. Since Bob's distance equals Alice's at node `1`, `(bobDist == aliceDist[u])` evaluates to true (line 36).\n6. In the next iteration, both Alice and Bob move to nodes `2` and `3`, respectively. Here, we have `v in tree[u]` being true for both Alice and Bob, following the condition at line 48."]}
{"task_num": 2499, "task_title": "Minimum Total Cost to Make Arrays Unequal", "func_name": "minimumTotalCost", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\n    n = len(nums1)\n    ans = 0\n    maxFreq = 0\n    maxFreqNum = 0\n    shouldBeSwapped = 0\n    conflictedNumCount = [0] * (n + 1)\n\n    for i, (num1, num2) in enumerate(zip(nums1, nums2)):\n      if num1 == num2:\n        conflictedNum = num1\n        conflictedNumCount[conflictedNum] += 1\n        if conflictedNumCount[conflictedNum] > maxFreq:\n          maxFreq = conflictedNumCount[conflictedNum]\n          maxFreqNum = conflictedNum\n        shouldBeSwapped += 1\n        ans += i\n\n    for i, (num1, num2) in enumerate(zip(nums1, nums2)):\n      if maxFreq * 2 <= shouldBeSwapped:\n        break\n      if num1 == num2:\n        continue\n\n      if num1 == maxFreqNum or num2 == maxFreqNum:\n        continue\n      shouldBeSwapped += 1\n      ans += i\n\n    if maxFreq * 2 > shouldBeSwapped:\n      return -1\n    else:\n      return ans\n", "tests": ["def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([1, 1, 0], [0, 1, 1]) == 3", "Here is the test case covering the target execution path:\n\n```python\ndef test_minimumTotalCost():\n    solution = Solution()\n    nums1 = [1, 2, 3, 4]\n    nums2 = [1, 3, 2, 4]\n    assert solution.minimumTotalCost(nums1, nums2) == -1\n```\n\nThis test case will execute the following branch conditions sequentially:\n\n1. `nums1[i] != nums2[i]` for all `0 <= i <= n - 1` after performing all operations (`Line 36`)\n2. Loop through `zip(nums1, nums2)` (`Line 30`)\n3. `num1 == maxFreqNum or num2 == maxFreqNum` (`Line 33`)\n4. Loop through `zip(nums1, nums2)` again (`Line 30`)\n5. `num1 == num2` (`Line 33`)", "def test_minimumTotalCost():\n    solution = Solution()\n    nums1 = [1, 2, 2]\n    nums2 = [2, 1, 1]\n    assert solution.minimumTotalCost(nums1, nums2) == 3", "def test_minimumTotalCost():\n    solution = Solution()\n    nums1 = [4, 5, 3]\n    nums2 = [5, 4, 3]\n    assert solution.minimumTotalCost(nums1, nums2) == 6", "def test_minimumTotalCost():\n    solution = Solution()\n    nums1 = [1, 2, 3]\n    nums2 = [2, 3, 1]\n    assert solution.minimumTotalCost(nums1, nums2) == 4"]}
{"task_num": 2503, "task_title": "Maximum Number of Points From Grid Queries", "func_name": "maxPoints", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, query: int):\n    self.queryIndex = queryIndex\n    self.query = query\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.query\n\n\nclass Solution:\n  def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    ans = [0] * len(queries)\n    minHeap = [(grid[0][0], 0, 0)]\n    seen = {(0, 0)}\n    accumulate = 0\n\n    for queryIndex, query in sorted([IndexedQuery(i, query) for i, query in enumerate(queries)], key=lambda iq: iq.query):\n      while minHeap:\n        val, i, j = heapq.heappop(minHeap)\n        if val >= query:\n          heapq.heappush(minHeap, (val, i, j))\n          break\n        accumulate += 1\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if (x, y) in seen:\n            continue\n          heapq.heappush(minHeap, (grid[x][y], x, y))\n          seen.add((x, y))\n      ans[queryIndex] = accumulate\n\n    return ans\n", "tests": ["def test_maxPoints():\n    solution = Solution()\n    grid = [[5]]\n    queries = [6]\n    assert solution.maxPoints(grid, queries) == [1]", "def test_maxPoints():\n    solution = Solution()\n    grid = [[1]]\n    queries = [2]\n    assert solution.maxPoints(grid, queries) == [0]", "def test_maxPoints():\n    solution = Solution()\n    grid = [[1,2],[3,4]]\n    queries = [10]\n    assert solution.maxPoints(grid, queries) == [0]"]}
{"task_num": 2508, "task_title": "Add Edges to Make Degrees of All Nodes Even", "func_name": "isPossible", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isPossible(self, n: int, edges: List[List[int]]) -> bool:\n    graph = [set() for _ in range(n)]\n\n    for u, v in edges:\n      graph[u - 1].add(v - 1)\n      graph[v - 1].add(u - 1)\n\n    oddNodes = [i for i, neighbor in enumerate(graph) if len(neighbor) & 1]\n    if not oddNodes:\n      return True\n    if len(oddNodes) == 2:\n      a, b = oddNodes\n      return any(a not in graph[i] and b not in graph[i] for i in range(n))\n    if len(oddNodes) == 4:\n      a, b, c, d = oddNodes\n      return (b not in graph[a] and d not in graph[c]) or (c not in graph[a] and d not in graph[b]) or (d not in graph[a] and c not in graph[b])\n    return False\n", "tests": ["def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(3, [[1,2], [1,3], [2,3], [2,4], [3,5]])", "```python\ndef test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(n=6, edges=[[1,2],[2,3],[3,4],[4,5],[5,6]])\n```", "def test_isPossible():\n    solution = Solution()\n    assert not solution.isPossible(5, [[1,2],[3,4]]), \"Expected False for 5 nodes and edges [[1,2],[3,4]]\""]}
{"task_num": 2523, "task_title": "Closest Prime Numbers in Range", "func_name": "closestPrimes", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def closestPrimes(self, left: int, right: int) -> List[int]:\n    isPrime = self._sieveEratosthenes(right + 1)\n    primes=[]\n    for i in range(left, right+1):\n      if isPrime[i]:\n        primes.append(i)\n\n    if len(primes) < 2:\n      return [-1, -1]\n\n    minDiff = math.inf\n    num1 = -1\n    num2 = -1\n\n    for a, b in zip(primes, primes[1:]):\n      diff = b - a\n      if diff < minDiff:\n        minDiff = diff\n        num1 = a\n        num2 = b\n\n    return [num1, num2]\n\n  def _sieveEratosthenes(self, n: int) -> List[bool]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return isPrime\n", "tests": ["def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(97, 103) == [97, 101]", "def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(20, 30) == [23, 29]", "def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(50, 200) == [53, 59]", "def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(7, 20) == [11, 13]"]}
{"task_num": 2532, "task_title": "Time to Cross a Bridge", "func_name": "findCrossingTime", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n    ans = 0\n    leftBridgeQueue = [(-leftToRight - rightToLeft, -i) for i, (leftToRight, pickOld, rightToLeft, pickNew) in enumerate(time)]\n    rightBridgeQueue = []\n    leftWorkers = []\n    rightWorkers = []\n\n    heapq.heapify(leftBridgeQueue)\n\n    while n > 0 or rightBridgeQueue or rightWorkers:\n      while leftWorkers and leftWorkers[0][0] <= ans:\n        i = heapq.heappop(leftWorkers)[1]\n        heapq.heappush(leftBridgeQueue, (-time[i][0] - time[i][2], -i))\n      while rightWorkers and rightWorkers[0][0] <= ans:\n        i = heapq.heappop(rightWorkers)[1]\n        heapq.heappush(rightBridgeQueue, (-time[i][0] - time[i][2], -i))\n      if rightBridgeQueue:\n        i = -heapq.heappop(rightBridgeQueue)[1]\n        ans += time[i][2]\n        heapq.heappush(leftWorkers, (ans + time[i][3], i))\n      elif leftBridgeQueue and n > 0:\n        i = -heapq.heappop(leftBridgeQueue)[1]\n        ans += time[i][0]\n        heapq.heappush(rightWorkers, (ans + time[i][1], i))\n        n -= 1\n      else:\n        if leftWorkers and n > 0:\n          ans1=leftWorkers[0][0]\n        else:\n          ans1=math.inf\n        if rightWorkers:\n          ans2=rightWorkers[0][0]\n        else:\n          ans2=math.inf\n        ans=min(ans1,ans2)\n\n    return ans", "tests": ["def test_findCrossingTime():\n    solution = Solution()\n    assert(solution.findCrossingTime(3, 2,\n        [[1, 2, 5, 6], [4, 7, 2, 9]]) == 18)", "def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(1, 1, [[5, 3, 4, 2]]) == 9"]}
{"task_num": 2577, "task_title": "Minimum Time to Visit a Cell In a Grid", "func_name": "minimumTime", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumTime(self, grid: List[List[int]]) -> int:\n    if grid[0][1] > 1 and grid[1][0] > 1:\n      return -1\n\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    minHeap = [(0, 0, 0)]\n    seen = {(0, 0)}\n\n    while minHeap:\n      time, i, j = heapq.heappop(minHeap)\n      if i == m - 1 and j == n - 1:\n        return time\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if (x, y) in seen:\n          continue\n        if (grid[x][y] - time) % 2 == 0:\n          extraWait = 1\n        else:\n          extraWait = 0\n        nextTime = max(time + 1, grid[x][y] + extraWait)\n        heapq.heappush(minHeap, (nextTime, x, y))\n        seen.add((x, y))\n", "tests": ["def test_minimumTime():\n    solution = Solution()\n    assert solution.minimumTime([[0,0]]) == -1", "def test_minimumTime():\n    solution = Solution()\n    assert solution.minimumTime([[2, 2], [1, 1]]) == -1", "def test_minimumTime():\n    solution = Solution()\n    grid = [[4, 2], [3, 0]]\n    assert(solution.minimumTime(grid) == -1)\n\ntest_minimumTime()"]}
{"task_num": 2601, "task_title": "Prime Subtraction Operation", "func_name": "primeSubOperation", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def primeSubOperation(self, nums: List[int]) -> bool:\n    kMax = 1000\n    primes = self._sieveEratosthenes(kMax)\n\n    prevNum = 0\n    for num in nums:\n      i = bisect.bisect_left(primes, num - prevNum)\n      if i > 0:\n        num -= primes[i - 1]\n      if num <= prevNum:\n        return False\n      prevNum = num\n\n    return True\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return [i for i in range(n) if isPrime[i]]\n", "tests": ["def test_primeSubOperation():\n    solution = Solution()\n    assert solution.primeSubOperation([7, 19]) == False"]}
{"task_num": 2603, "task_title": "Collect Coins in a Tree", "func_name": "collectTheCoins", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def collectTheCoins(self, coins: List[int], edges: List[List[int]]) -> int:\n    n = len(coins)\n    tree = [set() for _ in range(n)]\n    leavesToBeRemoved = collections.deque()\n\n    for u, v in edges:\n      tree[u].add(v)\n      tree[v].add(u)\n\n    for u in range(n):\n      while len(tree[u]) == 1 and coins[u] == 0:\n        v = tree[u].pop()\n        tree[v].remove(u)\n        u = v\n      if len(tree[u]) == 1:\n        leavesToBeRemoved.append(u)\n\n    for _ in range(2):\n      for _ in range(len(leavesToBeRemoved)):\n        u = leavesToBeRemoved.popleft()\n        if tree[u]:\n          v = tree[u].pop()\n          tree[v].remove(u)\n          if len(tree[v]) == 1:\n            leavesToBeRemoved.append(v)\n\n    return sum(len(children) for children in tree)\n", "tests": ["def test_collectTheCoins():\n    solution = Solution()\n    assert solution.collectTheCoins([1, 0], [[0, 1]]) == 3", "Here's a test case for the given target execution path:\n\n```python\ndef test_collectTheCoins():\n    solution = Solution()\n\n    coins = [1, 0, 0, 0]\n    edges = [[0, 1], [1, 2], [1, 3]]\n\n    assert solution.collectTheCoins(coins, edges) == 5\n```\n\nThis test case will execute the following branch conditions sequentially:\n- Line 29: `(_ in range(2))` (entered once)\n- Line 30: `(_ in range(len(leavesToBeRemoved)))` (entered twice)\n- Line 32: `(tree[u])` (true on second iteration of line 30)", "def test_collectTheCoins():\n    solution = Solution()\n    coins = [0] * 4 + [1]\n    edges = [(0, 1), (0, 2), (0, 3), (1, 2)]\n    assert solution.collectTheCoins(coins, edges) == 6", "def test_collectTheCoins():\n    solution = Solution()\n    coins = [0, 0, 1, 0]\n    edges = [[0, 1], [0, 2], [1, 3]]\n    assert solution.collectTheCoins(coins, edges) == 4"]}
{"task_num": 2653, "task_title": "Sliding Subarray Beauty", "func_name": "getSubarrayBeauty", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\n    ans = []\n    count = [0] * 50\n\n    for i, num in enumerate(nums):\n      if num < 0:\n        count[num + 50] += 1\n      if i - k >= 0 and nums[i - k] < 0:\n        count[nums[i - k] + 50] -= 1\n      if i + 1 >= k:\n        ans.append(self._getXthSmallestNum(count, x))\n\n    return ans\n\n  def _getXthSmallestNum(self, count: List[int], x: int) -> int:\n    prefix = 0\n    for i in range(50):\n      prefix += count[i]\n      if prefix >= x:\n        return i - 50\n    return 0\n", "tests": ["def test_getSubarrayBeauty():\n    solution = Solution()\n    nums = [-1, -2, -3, -4, -5]\n    k = 3\n    x = 2\n    assert solution.getSubarrayBeauty(nums, k, x) == [0, 0, -3]", "def test_getSubarrayBeauty():\n    solution = Solution()\n    nums = [1, -2, 3, -4, 5]\n    k = 4\n    x = 10\n    assert solution.getSubarrayBeauty(nums, k, x) == [0, 0, 0]"]}
{"task_num": 2662, "task_title": "Minimum Cost of a Path With Special Roads", "func_name": "minimumCost", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\n    return self.dijkstra(specialRoads, *start, *target)\n\n  def dijkstra(self, specialRoads: List[List[int]], srcX: int, srcY: int, dstX: int, dstY: int) -> int:\n    n = len(specialRoads)\n    dist = [math.inf] * n\n    minHeap = []\n\n    for u, (x1, y1, _, _, cost) in enumerate(specialRoads):\n      d = abs(x1 - srcX) + abs(y1 - srcY) + cost\n      dist[u] = d\n      heapq.heappush(minHeap, (dist[u], u))\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      _, _, ux2, uy2, _ = specialRoads[u]\n      for v in range(n):\n        if v == u:\n          continue\n        vx1, vy1, _, _, vcost = specialRoads[v]\n        newDist = d + abs(vx1 - ux2) + abs(vy1 - uy2) + vcost\n        if newDist < dist[v]:\n          dist[v] = newDist\n          heapq.heappush(minHeap, (dist[v], v))\n\n    ans = abs(dstX - srcX) + abs(dstY - srcY)\n    for u in range(n):\n      _, _, x2, y2, _ = specialRoads[u]\n      ans = min(ans, dist[u] + abs(dstX - x2) + abs(dstY - y2))\n\n    return ans\n", "tests": ["def test_minimum_cost():\n    solution = Solution()\n    special_roads = [[0, 0, 1, 1, 1], [1, 0, 2, 0, 1]]\n    assert solution.minimumCost([0, 0], [2, 0], special_roads) == 3", "def test_minimumCost():\n    solution = Solution()\n    start = [1, 2]\n    target = [4, 6]\n    specialRoads = [[1, 1, 2, 2, 0], [3, 3, 4, 4, 0]]\n    assert solution.minimumCost(start, target, specialRoads) == 5", "def test_minimumCost():\n    solution = Solution()\n    start = [1, 2]\n    target = [4, 5]\n    specialRoads = [\n        [1, 3, 2, 4, 10],\n        [2, 4, 3, 5, 15],\n        [1, 5, 3, 6, 20],\n        [2, 6, 4, 7, 25]\n    ]\n    assert solution.minimumCost(start, target, specialRoads) == 35", "def test_minimumCost():\n    solution = Solution()\n    start = [1, 2]\n    target = [4, 5]\n    specialRoads = [[1, 2, 3, 4, 0], [2, 3, 4, 5, 0]]\n    assert solution.minimumCost(start, target, specialRoads) == 7"]}
{"task_num": 2663, "task_title": "Lexicographically Smallest Beautiful String", "func_name": "smallestBeautifulString", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def smallestBeautifulString(self, s: str, k: int) -> str:\n    chars = list(s)\n\n    for i in reversed(range(len(chars))):\n      chars[i] = chr(ord(chars[i]) + 1)\n      while self._containsPalindrome(chars, i):\n        chars[i] = chr(ord(chars[i]) + 1)\n      if chars[i] < chr(ord('a') + k):\n        return self._changeSuffix(chars, i + 1)\n\n    return ''\n\n  def _containsPalindrome(self, chars: List[str], i: int) -> bool:\n    return (i > 0 and chars[i] == chars[i - 1]) or (i > 1 and chars[i] == chars[i - 2])\n\n  def _changeSuffix(self, chars: List[str], i: int) -> str:\n    for j in range(i, len(chars)):\n      chars[j] = 'a'\n      while self._containsPalindrome(chars, j):\n        chars[j] = chr(ord(chars[j]) + 1)\n    return ''.join(chars)\n", "tests": ["def test_smallestBeautifulString():\n    solution = Solution()\n    assert solution.smallestBeautifulString(\"aa\", 3) == \"aab\"", "def test_smallestBeautifulString():\n    solution = Solution()\n    assert(solution.smallestBeautifulString(\"aaab\", 4) == \"\")"]}
{"task_num": 2672, "task_title": "Number of Adjacent Elements With the Same Color", "func_name": "colorTheArray", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\n    ans = []\n    arr = [0] * n\n    sameColors = 0\n\n    for i, color in queries:\n      if i + 1 < n:\n        if arr[i + 1] > 0 and arr[i + 1] == arr[i]:\n          sameColors -= 1\n        if arr[i + 1] == color:\n          sameColors += 1\n      if i > 0:\n        if arr[i - 1] > 0 and arr[i - 1] == arr[i]:\n          sameColors -= 1\n        if arr[i - 1] == color:\n          sameColors += 1\n      arr[i] = color\n      ans.append(sameColors)\n\n    return ans\n", "tests": ["```python\ndef test_colorTheArray():\n    solution = Solution()\n    queries = [(1, 1), (0, 2), (2, 1)]\n    assert solution.colorTheArray(3, queries) == [0, 1, 1]\n```\nThis test case covers the target execution path by having `queries` such that:\n- The first query (`(1, 1)`) should satisfy `(i + 1 < n)` on line 18 and not affect any left neighbor.\n- The second query (`(0, 2)`) should satisfy `(i > 0)` on line 23 and make the left neighbor of index `1` different from it, thus satisfying `(arr[i - 1] == color)` on line 26.\n- The third query (`(2, 1)`) should also satisfy `(i + 1 < n)` on line 18.", "def test_colorTheArray():\n    solution = Solution()\n    assert solution.colorTheArray(3, [[0, 1], [1, 2], [2, 1]]) == [0, 1, 1]", "```python\ndef test_colorTheArray():\n    solution = Solution()\n    assert solution.colorTheArray(3, [[0, 1], [1, 2], [2, 1]]) == [0, 1, 2]\n```"]}
{"task_num": 2684, "task_title": "Maximum Number of Moves in a Grid", "func_name": "maxMoves", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxMoves(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n\n    for j in range(n - 2, -1, -1):\n      for i in range(m):\n        if grid[i][j + 1] > grid[i][j]:\n          dp[i][j] = 1 + dp[i][j + 1]\n        if i > 0 and grid[i - 1][j + 1] > grid[i][j]:\n          dp[i][j] = max(dp[i][j], 1 + dp[i - 1][j + 1])\n        if i + 1 < m and grid[i + 1][j + 1] > grid[i][j]:\n          dp[i][j] = max(dp[i][j], 1 + dp[i + 1][j + 1])\n\n    return max(dp[i][0] for i in range(m))\n", "tests": ["def test_maxMoves():\n    solution = Solution()\n    assert solution.maxMoves([[3, 4, 6], [7, 2, 5], [10, 8, 9]]) == 3", "def test_maxMoves():\n    solution = Solution()\n    grid = [[3, 4, 6], [7, 2, 5], [8, 10, 9]]\n    assert solution.maxMoves(grid) == 3", "def test_maxMoves():\n    solution = Solution()\n    grid = [\n        [2, 4],\n        [3, 0]\n    ]\n    assert solution.maxMoves(grid) == 1", "def test_maxMoves():\n    solution = Solution()\n    grid = [[3, 4, 6], [7, 2, 5]]\n    assert solution.maxMoves(grid) == 1"]}
{"task_num": 2685, "task_title": "Count the Number of Complete Components", "func_name": "countCompleteComponents", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n    self.nodeCount = [1] * n\n    self.edgeCount = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    self.edgeCount[i] += 1\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n      self.edgeCount[j] += self.edgeCount[i]\n      self.nodeCount[j] += self.nodeCount[i]\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n      self.edgeCount[i] += self.edgeCount[j]\n      self.nodeCount[i] += self.nodeCount[j]\n    else:\n      self.id[i] = j\n      self.edgeCount[j] += self.edgeCount[i]\n      self.nodeCount[j] += self.nodeCount[i]\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n  def isComplete(self, u):\n    return self.nodeCount[u] * (self.nodeCount[u] - 1) // 2 == self.edgeCount[u]\n\n\nclass Solution:\n  def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\n    ans = 0\n    uf = UnionFind(n)\n    parents = set()\n\n    for u, v in edges:\n      uf.unionByRank(u, v)\n\n    for i in range(n):\n      parent = uf.find(i)\n      if parent not in parents and uf.isComplete(parent):\n        ans += 1\n        parents.add(parent)\n\n    return ans\n", "tests": ["def test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(6, [[0,1], [0,2], [2,3], [2,4], [5,1]]) == 2", "def test_countCompleteComponents():\n    solution = Solution()\n    assert(solution.countCompleteComponents(3, [[0,1], [2,1]]) == 1)", "def test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(6, [[0, 1], [0, 2], [0, 3], [4, 5]]) == 2", "def test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(3, [[0,1], [1,2]]) == 1"]}
{"task_num": 2699, "task_title": "Modify Graph Edge Weights", "func_name": "modifiedGraphEdges", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\n\nclass Solution:\n  def modifiedGraphEdges(self, n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:\n    kMax = 2_000_000_000\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      if w == -1:\n        continue\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    distToDestination = self._dijkstra(graph, source, destination)\n    if distToDestination < target:\n      return []\n    if distToDestination == target:\n      for edge in edges:\n        if edge[2] == -1:\n          edge[2] = kMax\n      return edges\n\n    for i, (u, v, w) in enumerate(edges):\n      if w != -1:\n        continue\n      edges[i][2] = 1\n      graph[u].append((v, 1))\n      graph[v].append((u, 1))\n      distToDestination = self._dijkstra(graph, source, destination)\n      if distToDestination <= target:\n        edges[i][2] += target - distToDestination\n        for j in range(i + 1, len(edges)):\n          if edges[j][2] == -1:\n            edges[j][2] = kMax\n        return edges\n\n    return []\n\n  def _dijkstra(self, graph: List[List[int]], src: int, dst: int) -> int:\n    dist = [math.inf] * len(graph)\n    minHeap = []\n    dist[src] = 0\n    heapq.heappush(minHeap, (dist[src], src))\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist[dst]\n", "tests": ["```python\ndef test_modifiedGraphEdges():\n    solution = Solution()\n    edges = [[0,1,-1],[0,2,-1],[1,3,4],[2,3,-1]]\n    assert solution.modifiedGraphEdges(4, edges, 0, 3, 6) == [[0,1,5],[0,2,3],[1,3,4],[2,3,7]]\n```", "def test_modifiedGraphEdges():\n    solution = Solution()\n    edges = [[1, 2, -1], [3, 4, 5]]\n    assert solution.modifiedGraphEdges(5, edges, 0, 3, 9) == [[1, 2, 1], [3, 4, 5]]", "def test_modifiedGraphEdges():\n    solution = Solution()\n    edges = [[0,1,-1],[0,2,-1],[1,3,4],[2,3,5]]\n    assert solution.modifiedGraphEdges(4, edges, 0, 3, 6) == [[0,1,1],[0,2,2],[1,3,4],[2,3,5]]", "def test_modifiedGraphEdges():\n    solution = Solution()\n    edges = [[0, 1, -1], [1, 2, -1], [2, 3, -1]]\n    assert solution.modifiedGraphEdges(4, edges, 0, 3, 7) == [[0, 1, 6], [1, 2, 1]]", "def test_modifiedGraphEdges():\n    solution = Solution()\n    assert solution.modifiedGraphEdges(3, [[0, 1, -1], [1, 2, -1], [2, 0, -1]], 0, 2, 4) == [[0, 1, 2], [1, 2, 2]]", "def test_modifiedGraphEdges():\n    solution = Solution()\n    assert solution.modifiedGraphEdges(3, [[0, 1, -1], [1, 2, -1], [2, 0, 4]], 0, 2, 6) == [[0, 1, 5]]"]}
{"task_num": 2708, "task_title": "Maximum Strength of a Group", "func_name": "maxStrength", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxStrength(self, nums: List[int]) -> int:\n    posProd = 1\n    negProd = 1\n    maxNeg = -math.inf\n    negCount = 0\n    hasPos = False\n    hasZero = False\n\n    for num in nums:\n      if num > 0:\n        posProd *= num\n        hasPos = True\n      elif num < 0:\n        negProd *= num\n        maxNeg = max(maxNeg, num)\n        negCount += 1\n      else:\n        hasZero = True\n\n    if negCount == 0 and not hasPos:\n      return 0\n    if negCount % 2 == 0:\n      return negProd * posProd\n    if negCount >= 3:\n      return negProd // maxNeg * posProd\n    if hasPos:\n      return posProd\n    if hasZero:\n      return 0\n    return maxNeg\n", "tests": ["def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([-1, -2, -3]) == 6", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([-3, -5]) == -15", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([-1, -2, -3]) == -6", "def test_maxStrength():\n    solution = Solution()\n    nums = [-1, -2, -3]\n    assert solution.maxStrength(nums) == (-1 * -2 * -3) // (-3), \"Test case 1 failed\""]}
{"task_num": 2709, "task_title": "Greatest Common Divisor Traversal", "func_name": "canTraverseAllPairs", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.sz = [1] * n\n\n  def unionBySize(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.sz[i] < self.sz[j]:\n      self.sz[j] += self.sz[i]\n      self.id[i] = j\n    else:\n      self.sz[i] += self.sz[j]\n      self.id[j] = i\n\n  def getSize(self, i: int) -> int:\n    return self.sz[i]\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def canTraverseAllPairs(self, nums: List[int]) -> bool:\n    n = len(nums)\n    max_num = max(nums)\n    maxPrimeFactor = self._sieveEratosthenes(max_num + 1)\n    primeToFirstIndex = collections.defaultdict(int)\n    uf = UnionFind(n)\n\n    for i, num in enumerate(nums):\n      for prime_factor in self._getPrimeFactors(num, maxPrimeFactor):\n        if prime_factor in primeToFirstIndex:\n          uf.unionBySize(primeToFirstIndex[prime_factor], i)\n        else:\n          primeToFirstIndex[prime_factor] = i\n\n    return any(uf.getSize(i) == n for i in range(n))\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeFactors(self, num: int, minPrimeFactors: List[int]) -> List[int]:\n    primeFactors = []\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      primeFactors.append(divisor)\n      while num % divisor == 0:\n        num //= divisor\n    return primeFactors\n", "tests": ["def test_canTraverseAllPairs():\n    solution = Solution()\n    nums = [180, 270]\n    assert not solution.canTraverseAllPairs(nums)", "def test_canTraverseAllPairs():\n    solution = Solution()\n    nums = [18, 9]\n    assert solution.canTraverseAllPairs(nums) == False", "def test_canTraverseAllPairs():\n    nums = [10, 20, 30, 40]\n    solution = Solution()\n    assert not solution.canTraverseAllPairs(nums)", "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([10, 5, 2])", "def test_canTraverseAllPairs():\n    solution = Solution()\n    nums = [4, 8, 10]\n    assert solution.canTraverseAllPairs(nums) == False", "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert not solution.canTraverseAllPairs([5, 10, 15, 20])"]}
{"task_num": 2736, "task_title": "Maximum Sum Queries", "func_name": "maximumSumQueries", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Pair:\n  def __init__(self, x: int, y: int):\n    self.x = x\n    self.y = y\n\n  def __iter__(self):\n    yield self.x\n    yield self.y\n\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, minX: int, minY: int):\n    self.queryIndex = queryIndex\n    self.minX = minX\n    self.minY = minY\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.minX\n    yield self.minY\n\n\nclass Solution:\n  def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n    pairs = sorted([Pair(nums1[i], nums2[i])\n                   for i in range(len(nums1))], key=lambda p: p.x, reverse=True)\n    ans = [0] * len(queries)\n    stack = []  # [(y, x + y)]\n\n    pairsIndex = 0\n    for queryIndex, minX, minY in sorted([IndexedQuery(i, query[0], query[1]) for i, query in enumerate(queries)], key=lambda iq: -iq.minX):\n      while pairsIndex < len(pairs) and pairs[pairsIndex].x >= minX:\n        x, y = pairs[pairsIndex]\n        while stack and x + y >= stack[-1][1]:\n          stack.pop()\n        if not stack or y > stack[-1][0]:\n          stack.append((y, x + y))\n        pairsIndex += 1\n      j = self._firstGreaterEqual(stack, minY)\n      if j == len(stack):\n        ans[queryIndex] = -1\n      else:\n        ans[queryIndex] = stack[j][1]\n\n    return ans\n\n  def _firstGreaterEqual(self, A: List[Tuple[int, int]], target: int) -> int:\n    l = 0\n    r = len(A)\n    while l < r:\n      m = (l + r) // 2\n      if A[m][0] >= target:\n        r = m\n      else:\n        l = m + 1\n    return l\n", "tests": ["```python\ndef test_maximumSumQueries():\n    solution = Solution()\n    nums1 = [2, 3]\n    nums2 = [1, 4]\n    queries = [[2, 1], [3, 1]]\n    assert solution.maximumSumQueries(nums1, nums2, queries) == [-1, -1]\n```", "def test_maximumSumQueries():\n    nums1 = [5, 2, 8]\n    nums2 = [3, 7, 6]\n    queries = [[6, 4], [9, 2]]\n    solution = Solution()\n    assert solution.maximumSumQueries(nums1, nums2, queries) == [-1, -1]", "def test_maximumSumQueries():\n    solution = Solution()\n    nums1 = [7, 6, 8]\n    nums2 = [1, 3, 4]\n    queries = [[5, 0], [6, 1], [2, 2]]\n    assert solution.maximumSumQueries(nums1, nums2, queries) == [-1, -1, 10]", "def test_maximumSumQueries():\n    solution = Solution()\n    nums1 = [5, 2, 3]\n    nums2 = [4, 6, 7]\n    queries = [[3, 7], [5, 8]]\n    assert solution.maximumSumQueries(nums1, nums2, queries) == [-1, 10]", "def test_maximumSumQueries():\n    nums1 = [7, 6, 8]\n    nums2 = [1, 2, 3]\n    queries = [[5, 0], [7, 5], [8, 2]]\n    solution = Solution()\n    assert(solution.maximumSumQueries(nums1, nums2, queries) == [-1, -1, 16])"]}
{"task_num": 2747, "task_title": "Count Zero Request Servers", "func_name": "countServers", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, query: int):\n    self.queryIndex = queryIndex\n    self.query = query\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.query\n\n\nclass Solution:\n  def countServers(self, n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:\n    ans = [0] * len(queries)\n    count = [0] * (n + 1)\n\n    logs.sort(key=lambda log: log[1])\n\n    i = 0\n    j = 0\n    servers = 0\n\n    for queryIndex, query in sorted([IndexedQuery(i, query) for i, query in enumerate(queries)], key=lambda iq: iq.query):\n      while j < len(logs) and logs[j][1] <= query:\n        count[logs[j][0]] += 1\n        if count[logs[j][0]] == 1:\n          servers += 1\n        j += 1\n      while i < len(logs) and logs[i][1] < query - x:\n        count[logs[i][0]] -= 1\n        if count[logs[i][0]] == 0:\n          servers -= 1\n        i += 1\n      ans[queryIndex] = n - servers\n\n    return ans\n", "tests": ["def test_countServers():\n    solution = Solution()\n    logs = [[0, 0], [1, 2], [0, 4], [2, 6], [1, 8]]\n    queries = [5, 9]\n    x = 3\n    assert solution.countServers(3, logs, x, queries) == [1, 2]", "def test_countServers():\n    solution = Solution()\n    n = 5\n    logs = [[1, 3], [2, 4], [3, 6], [4, 7], [5, 8]]\n    x = 2\n    queries = [5, 9]\n    assert solution.countServers(n, logs, x, queries) == [1, 3]", "def test_countServers():\n  n = 3\n  logs = [[0, 1], [1, 2], [2, 4]]\n  x = 2\n  queries = [1.5, 3]\n  solution = Solution()\n  assert solution.countServers(n, logs, x, queries) == [1, 2]", "def test_countServers():\n    solution = Solution()\n    n, x = 3, 1\n    logs = [[0, 2], [1, 1], [2, 3]]\n    queries = [2]\n    assert solution.countServers(n, logs, x, queries) == [1]"]}
{"task_num": 2751, "task_title": "Robot Collisions", "func_name": "survivedRobotsHealths", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\nfrom dataclasses import dataclass\n\n@dataclass\nclass Robot:\n  index: int\n  position: int\n  health: int\n  direction: str\n\n\nclass Solution:\n  def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\n    robots = sorted([Robot(index, position, health, direction) for index, (position, health, direction) in enumerate(zip(positions, healths, directions))], key=lambda robot: robot.position)\n    stack: List[Robot] = []\n\n    for robot in robots:\n      if robot.direction == 'R':\n        stack.append(robot)\n        continue\n      while stack and stack[-1].direction == 'R' and robot.health > 0:\n        if stack[-1].health == robot.health:\n          stack.pop()\n          robot.health = 0\n        elif stack[-1].health < robot.health:\n          stack.pop()\n          robot.health -= 1\n        else:\n          stack[-1].health -= 1\n          robot.health = 0\n      if robot.health > 0:\n        stack.append(robot)\n\n    stack.sort(key=lambda robot: robot.index)\n    return [robot.health for robot in stack]\n", "tests": ["def test_survivedRobotsHealths():\n    solution = Solution()\n    positions, healths, directions = [1, 2, 3], [50, 50, 50], 'RRL'\n    assert solution.survivedRobotsHealths(positions, healths, directions) == [49]", "def test_survivedRobotsHealths():\n    solution = Solution()\n    positions = [2, 1]\n    healths = [3, 3]\n    directions = \"RR\"\n    assert solution.survivedRobotsHealths(positions, healths, directions) == [0]", "```python\ndef test_survivedRobotsHealths():\n    solution = Solution()\n    positions = [1, 2]\n    healths = [30, 40]\n    directions = \"RR\"\n    assert solution.survivedRobotsHealths(positions, healths, directions) == [0, 39]\n```", "def test_survivedRobotsHealths():\n    solution = Solution()\n    assert solution.survivedRobotsHealths([1, 2, 3], [5, 5, 5], 'RRR') == [0, 0, 0]", "def test_survivedRobotsHealths():\n    solution = Solution()\n    positions = [3, 2, 1]\n    healths = [5, 4, 3]\n    directions = 'RRR'\n    assert solution.survivedRobotsHealths(positions, healths, directions) == [0]"]}
{"task_num": 2812, "task_title": "Find the Safest Path in a Grid", "func_name": "maximumSafenessFactor", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumSafenessFactor(self, grid: List[List[int]]) -> int:\n    self.dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    n = len(grid)\n    distToThief = self._getDistToThief(grid)\n\n    def hasValidPath(safeness: int) -> bool:\n      if distToThief[0][0] < safeness:\n        return False\n\n      q = collections.deque([(0, 0)])\n      seen = {(0, 0)}\n\n      while q:\n        i, j = q.popleft()\n        if distToThief[i][j] < safeness:\n          continue\n        if i == n - 1 and j == n - 1:\n          return True\n        for dx, dy in self.dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == n or y < 0 or y == n:\n            continue\n          if (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n\n      return False\n\n    return bisect.bisect_left(range(n * 2), True, key=lambda m: not hasValidPath(m)) - 1\n\n  def _getDistToThief(self, grid: List[List[int]]) -> List[List[int]]:\n    n = len(grid)\n    distToThief = [[0] * n for _ in range(n)]\n    q = collections.deque()\n    seen = set()\n\n    for i in range(n):\n      for j in range(n):\n        if grid[i][j] == 1:\n          q.append((i, j))\n          seen.add((i, j))\n\n    dist = 0\n    while q:\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        distToThief[i][j] = dist\n        for dx, dy in self.dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == n or y < 0 or y == n:\n            continue\n          if (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n      dist += 1\n\n    return distToThief\n", "tests": ["def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [\n        [0, 0, 0],\n        [1, 0, 0],\n        [0, 0, 0]\n    ]\n    assert solution.maximumSafenessFactor(grid) == 2", "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[1, 0], [0, 0]]\n    solution.maximumSafenessFactor(grid)", "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n    assert solution.maximumSafenessFactor(grid) == 2", "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [\n        [0, 1],\n        [0, 0]\n    ]\n    assert solution.maximumSafenessFactor(grid) == 2", "Here's a Python function for the given task. The test case aims to cover the execution path mentioned:\n\n```python\ndef test_maximumSafenessFactor():\n    solution = Solution()\n\n    # Test case covering the target execution path\n    grid = [\n        [0, 0, 1],\n        [1, 1, 0],\n        [1, 0, 0]\n    ]\n\n    assert solution._getDistToThief(grid)[1][1] == 2\n\ntest_maximumSafenessFactor()\n```", "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [\n        [0, 1, 0],\n        [0, 0, 0],\n        [0, 0, 0]\n    ]\n    solution.maximumSafenessFactor(grid)"]}
{"task_num": 2818, "task_title": "Apply Operations to Maximize Score", "func_name": "maximumScore", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumScore(self, nums: List[int], k: int) -> int:\n    kMod = 1_000_000_007\n    n = len(nums)\n    ans = 1\n    minPrimeFactors = self._sieveEratosthenes(max(nums) + 1)\n    primeScores = [self._getPrimeScore(num, minPrimeFactors) for num in nums]\n    left = [-1] * n\n    right = [n] * n\n    stack = []\n\n    for i in reversed(range(n)):\n      while stack and primeScores[stack[-1]] <= primeScores[i]:\n        left[stack.pop()] = i\n      stack.append(i)\n\n    stack = []\n\n    for i in range(n):\n      while stack and primeScores[stack[-1]] < primeScores[i]:\n        right[stack.pop()] = i\n      stack.append(i)\n\n    numAndIndexes = [(num, i) for i, num in enumerate(nums)]\n\n    def modPow(x: int, n: int) -> int:\n      if n == 0:\n        return 1\n      if n & 1:\n        return x * modPow(x, n - 1) % kMod\n      return modPow(x * x % kMod, n // 2)\n\n    for num, i in sorted(numAndIndexes, key=lambda x: (-x[0], x[1])):\n      rangeCount = (i - left[i]) * (right[i] - i)\n      actualCount = min(rangeCount, k)\n      k -= actualCount\n      ans *= modPow(num, actualCount)\n      ans %= kMod\n\n    return ans\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeScore(self, num: int, minPrimeFactors: List[int]) -> int:\n    primeFactors = set()\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      primeFactors.add(divisor)\n      while num % divisor == 0:\n        num //= divisor\n    return len(primeFactors)\n", "tests": ["def test_maximumScore():\n    solution = Solution()\n    nums = [300, 100, 200]\n    k = 2", "def test_maximumScore():\n    solution = Solution()\n    nums = [300, 400]\n    k = 2\n    assert solution.maximumScore(nums, k) == 9", "def test_maximumScore():\n    solution = Solution()\n    nums = [7846, 2356]\n    k = 1\n    assert solution.maximumScore(nums, k) == 7846", "def test_maximumScore():\n    solution = Solution()\n    nums = [10, 5, 15, 20]\n    k = 3\n    assert solution.maximumScore(nums, k) == 60"]}
{"task_num": 2836, "task_title": "Maximize Value of Function in a Ball Passing Game", "func_name": "getMaxFunctionValue", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:\n    n = len(receiver)\n    m = int(math.log2(k)) + 1\n    ans = 0\n    jump = [[0] * m for _ in range(n)]\n    summ = [[0] * m for _ in range(n)]\n\n    for i in range(n):\n      jump[i][0] = receiver[i]\n      summ[i][0] = receiver[i]\n\n    for j in range(1, m):\n      for i in range(n):\n        midNode = jump[i][j - 1]\n        jump[i][j] = jump[midNode][j - 1]\n        summ[i][j] = summ[i][j - 1] + summ[midNode][j - 1]\n\n    for i in range(n):\n      currSum = i\n      currPos = i\n      for j in range(m):\n        if (k >> j) & 1 == 1:\n          currSum += summ[currPos][j]\n          currPos = jump[currPos][j]\n      ans = max(ans, currSum)\n\n    return ans\n", "tests": ["def test_getMaxFunctionValue():\n    solution = Solution()\n    receiver = [1, 0, 0]\n    k = 5\n    assert solution.getMaxFunctionValue(receiver, k) == 2", "def test_getMaxFunctionValue():\n    solution = Solution()\n    receiver = [2, 2, 0]\n    k = 3\n    assert solution.getMaxFunctionValue(receiver, k) == 4", "def test_getMaxFunctionValue():\n    solution = Solution()\n    receiver = [0, 2, 1] # Ensure i == receiver[i] at j=0, trigger line 33 condition\n    k = 4 # Ensure ((k >> j) & 1 == 1) for j=0 and j=2, trigger loop at lines 32 and 33", "def test_getMaxFunctionValue():\n    solution = Solution()\n    assert solution.getMaxFunctionValue([0,0,0], 7) == 0"]}
{"task_num": 2844, "task_title": "Minimum Operations to Make a Special Number", "func_name": "minimumOperations", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumOperations(self, num: str) -> int:\n    n = len(num)\n    seenFive = False\n    seenZero = False\n\n    for i in range(n - 1, -1, -1):\n      if seenZero and num[i] == '0':\n        return n - i - 2\n      if seenZero and num[i] == '5':\n        return n - i - 2\n      if seenFive and num[i] == '2':\n        return n - i - 2\n      if seenFive and num[i] == '7':\n        return n - i - 2\n      seenZero = seenZero or num[i] == '0'\n      seenFive = seenFive or num[i] == '5'\n\n    if seenZero:\n      return n - 1\n    else:\n      return n\n", "tests": ["def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations(\"0\") == 1", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations(\"50\") == 2", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations(\"250\") == 3"]}
{"task_num": 2846, "task_title": "Minimum Edge Weight Equilibrium Queries in a Tree", "func_name": "minOperationsQueries", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minOperationsQueries(self, n: int, edges: List[List[int]], queries: List[List[int]]) -> List[int]:\n    kMax = 26\n    m = int(math.log2(n)) + 1\n    ans = []\n    graph = [[] for _ in range(n)]\n    jump = [[0] * m for _ in range(n)]\n    count = [[] for _ in range(n)]\n    depth = [0] * n\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    def dfs(u: int, prev: int, d: int):\n      if prev != -1:\n        jump[u][0] = prev\n      depth[u] = d\n      for v, w in graph[u]:\n        if v == prev:\n          continue\n        count[v] = count[u][:]\n        count[v][w] += 1\n        dfs(v, u, d + 1)\n\n    count[0] = [0] * (kMax + 1)\n    dfs(0, -1, 0)\n\n    for j in range(1, m):\n      for i in range(n):\n        jump[i][j] = jump[jump[i][j - 1]][j - 1]\n\n    def getLCA(u: int, v: int) -> int:\n      if depth[u] > depth[v]:\n        return getLCA(v, u)\n      for j in range(m):\n        if depth[v] - depth[u] >> j & 1:\n          v = jump[v][j]\n      if u == v:\n        return u\n      for j in range(m - 1, -1, -1):\n        if jump[u][j] != jump[v][j]:\n          u = jump[u][j]\n          v = jump[v][j]\n      return jump[v][0]\n\n    for u, v in queries:\n      lca = getLCA(u, v)\n      numEdges = depth[u] + depth[v] - 2 * depth[lca]\n      maxFreq = max(count[u][j] + count[v][j] - 2 * count[lca][j] for j in range(1, kMax + 1))\n      ans.append(numEdges - maxFreq)\n\n    return ans\n", "tests": ["def test_minOperationsQueries():\n    solution = Solution()\n    assert solution.minOperationsQueries(n=8,\n                                         edges=[[0, 1, 5], [0, 2, 3], [1, 2, 6], [1, 3, 7], [2, 4, 9], [3, 5, 8]],\n                                         queries=[[0, 2], [1, 3], [0, 4]]) == [3, 2, 4]", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 16\n    edges = [[0, 1, 2], [0, 4, 3], [0, 5, 4]]\n    queries = [[1, 5]]\n    assert solution.minOperationsQueries(n, edges, queries) == [2]", "def test_minOperationsQueries():\n    solution = Solution()\n    assert solution.minOperationsQueries(4, [[0, 1, 1], [0, 2, 2]], [[3, 1]]) == [1]", "def test_minOperationsQueries():\n    solution = Solution()\n    assert solution.minOperationsQueries(n=4,\n                                         edges=[[0,1,1],[1,2,1],[2,3,1]],\n                                         queries=[[0,2]]) == [0]"]}
{"task_num": 2850, "task_title": "Minimum Moves to Spread Stones Over Grid", "func_name": "minimumMoves", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumMoves(self, grid: List[List[int]]) -> int:\n    if sum(row.count(0) for row in grid) == 0:\n      return 0\n\n    ans = math.inf\n\n    for i in range(3):\n      for j in range(3):\n        if grid[i][j] == 0:\n          for x in range(3):\n            for y in range(3):\n              if grid[x][y] > 1:\n                grid[x][y] -= 1\n                grid[i][j] += 1\n                ans = min(ans, abs(x - i) + abs(y - j) + self.minimumMoves(grid))\n                grid[x][y] += 1\n                grid[i][j] -= 1\n\n    return ans\n", "tests": ["def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n    assert solution.minimumMoves(grid) == math.inf", "```python\ndef test_minimumMoves():\n    solution = Solution()\n    assert solution.minimumMoves([[1,0,0],[1,1,0],[1,0,0]]) == 2\n```\nThis test case will cover the given execution path: it will go through two iterations of 'y in range(3)', then enter the loop where 'grid[x][y] > 1', and finally return early when all cells are non-zero. The expected output is 2, as there are two moves needed to distribute one stone into each cell from the initial state [[1,0,0],[1,1,0],[1,0,0]].", "```python\ndef test_minimumMoves():\n    solution = Solution()\n    grid = [[4,0,2],[0,2,1],[2,3,1]]\n    assert solution.minimumMoves(grid) == 6\n```"]}
{"task_num": 2851, "task_title": "String Transformation", "func_name": "numberOfWays", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numberOfWays(self, s: str, t: str, k: int) -> int:\n    kMod = 1_000_000_007\n    n = len(s)\n    negOnePowK = 1 if k % 2 == 0 else -1  # (-1)^k\n    z = self._zFunction(s + t + t)\n\n    indices = [i - n for i in range(n, n + n) if z[i] >= n]\n    dp = [0] * 2\n    dp[1] = (pow(n - 1, k, kMod) - negOnePowK) * pow(n, kMod - 2, kMod)\n    dp[0] = dp[1] + negOnePowK\n    res = 0\n    for index in indices:\n      if index == 0:\n        res += dp[0]\n      else: \n        res += dp[1]\n    return res % kMod\n\n\n  def _zFunction(self, s: str) -> List[int]:\n    n = len(s)\n    z = [0] * n\n    l = 0\n    r = 0\n    for i in range(1, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l])\n      while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n    return z\n", "tests": ["def test_numberOfWays():\n    solution = Solution()\n    s = \"abcd\"\n    t = \"dcba\"\n    k = 2", "def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('abcd', 'dcba', 2) == 2", "def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('abc', 'abc', 4) == 25", "def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('abc', 'cab', 2) == 0"]}
{"task_num": 2876, "task_title": "Count Visited Nodes in a Directed Graph", "func_name": "countVisitedNodes", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countVisitedNodes(self, edges: List[int]) -> List[int]:\n    n = len(edges)\n    ans = [0] * n\n    inDegrees = [0] * n\n    seen = [False] * n\n    stack = []\n\n    for v in edges:\n      inDegrees[v] += 1\n\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n\n    while q:\n      u = q.popleft()\n      inDegrees[edges[u]] -= 1\n      if inDegrees[edges[u]] == 0:\n        q.append(edges[u])\n      stack.append(u)\n      seen[u] = True\n\n    for i in range(n):\n      if not seen[i]:\n        self._fillCycle(edges, i, seen, ans)\n\n    while stack:\n      u = stack.pop()\n      ans[u] = ans[edges[u]] + 1\n\n    return ans\n\n  def _fillCycle(self, edges: List[int], start: int, seen: List[bool], ans: List[int]) -> None:\n    cycleLength = 0\n    u = start\n    while not seen[u]:\n      cycleLength += 1\n      seen[u] = True\n      u = edges[u]\n    ans[start] = cycleLength\n    u = edges[start]\n    while u != start:\n      ans[u] = cycleLength\n      u = edges[u]\n", "tests": ["def test_countVisitedNodes():\n    solution = Solution()\n    edges = [0, 1, 2, 3]\n    assert solution.countVisitedNodes(edges) == [4]", "```python\ndef test_countVisitedNodes():\n    solution = Solution()\n    assert solution.countVisitedNodes([0, 1, 2]) == [3, 3, 3]\n```", "def test_countVisitedNodes():\n    solution = Solution()\n    edges = [2, 0, 3, 2, 1]\n    assert solution.countVisitedNodes(edges) == [4, 1, 1, 3, 2]", "def test_countVisitedNodes():\n    solution = Solution()\n    assert solution.countVisitedNodes([0, 1, 2]) == [1, 1, 1]"]}
{"task_num": 2901, "task_title": "Longest Unequal Adjacent Groups Subsequence II", "func_name": "getWordsInLongestSubsequence", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def getWordsInLongestSubsequence(self, words: List[str], groups: List[int]) -> List[str]:\n    ans = []\n    n=len(words)\n    dp = [1] * n\n    prev = [-1] * n\n\n    for i in range(1, n):\n      for j in range(i):\n        if groups[i] == groups[j]:\n          continue\n        if len(words[i]) != len(words[j]):\n          continue\n        if sum(a != b for a, b in zip(words[i], words[j])) != 1:\n          continue\n        if dp[i] < dp[j] + 1:\n          dp[i] = dp[j] + 1\n          prev[i] = j\n\n    index = dp.index(max(dp))\n    while index != -1:\n      ans.append(words[index])\n      index = prev[index]\n\n    return ans[::-1]\n", "tests": ["Here is the Python function:\n\n```python\ndef test_getWordsInLongestSubsequence():\n    solution = Solution()\n    assert solution.getWordsInLongestSubsequence([\"abc\", \"abd\", \"ace\", \"bcd\"], [1, 2, 3, 4]) == ['abd', 'bcd']\n```\n\nThis test case verifies the function's behavior when it encounters a subsequence with unequal groups and words that differ by one character. The expected output is `['abd', 'bcd']`, which matches the target execution path.", "def test_getWordsInLongestSubsequence():\n    words = ['abc', 'abd', 'ace', 'bce']\n    groups = [1, 2, 3, 4]\n    solution = Solution()\n    assert solution.getWordsInLongestSubsequence(words, groups) == ['abc']", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = [\"cat\", \"act\", \"tac\", \"atc\"]\n    groups = [0, 1, 1, 0]\n    assert solution.getWordsInLongestSubsequence(words, groups) == [\"cat\", \"act\"]", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = [\"abc\", \"acb\", \"bad\", \"acc\"]\n    groups = [0, 1, 1, 2]\n    assert solution.getWordsInLongestSubsequence(words, groups) == ['abc', 'acb']"]}
{"task_num": 2904, "task_title": "Shortest and Lexicographically Smallest Beautiful String", "func_name": "shortestBeautifulSubstring", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def shortestBeautifulSubstring(self, s: str, k: int) -> str:\n    bestLeft = -1\n    minLength = len(s) + 1\n    ones = 0\n\n    l = 0\n    for r, c in enumerate(s):\n      if c == '1':\n        ones += 1\n      while ones == k:\n        if r - l + 1 < minLength:\n          bestLeft = l\n          minLength = r - l + 1\n        elif r - l + 1 == minLength and s[l:l + minLength] < s[bestLeft:bestLeft + minLength]:\n          bestLeft = l\n        if s[l] == '1':\n          ones -= 1\n        l += 1\n\n    if bestLeft == -1:\n      return \"\"\n    else:\n      return s[bestLeft:bestLeft + minLength]\n", "tests": ["def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring(\"101101\", 2) == \"\"", "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring(\"11011010\", 3) == \"101\"", "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring(\"10101\", 2) == \"01\"", "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring(\"11011110\", 4) == \"1110\"", "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring(\"10110101\", 3) == \"101\""]}
{"task_num": 2911, "task_title": "Minimum Changes to Make K Semi-palindromes", "func_name": "minimumChanges", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumChanges(self, s: str, k: int) -> int:\n    n = len(s)\n    factors = self._getFactors(n)\n    cost = self._getCost(s, n, factors)\n    dp = [[n] * (k + 1) for _ in range(n + 1)]\n\n    dp[n][0] = 0\n\n    for i in range(n - 1, -1, -1):\n      for j in range(1, k + 1):\n        for l in range(i + 1, n):\n          dp[i][j] = min(dp[i][j], dp[l + 1][j - 1] + cost[i][l])\n\n    return dp[0][k]\n\n  def _getFactors(self, n: int) -> List[List[int]]:\n    factors = [[1] for _ in range(n + 1)]\n    for d in range(2, n):\n      for i in range(d * 2, n + 1, d):\n        factors[i].append(d)\n    return factors\n\n  def _getCost(self, s: str, n: int, factors: List[List[int]]) -> List[List[int]]:\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n      for j in range(i + 1, n):\n        length = j - i + 1\n        minCost = length\n        for d in factors[length]:\n          minCost = min(minCost, self._getCostD(s, i, j, d))\n        cost[i][j] = minCost\n    return cost\n\n  def _getCostD(self, s: str, i: int, j: int, d: int) -> int:\n    cost = 0\n    for offset in range(d):\n      l = i + offset\n      r = j - d + 1 + offset\n      while l < r:\n        if s[l] != s[r]:\n          cost += 1\n        l += d\n        r -= d\n    return cost\n", "tests": ["```python\ndef test_minimumChanges():\n    solution = Solution()\n    assert solution.minimumChanges(\"abcabc\", 2) == 3\n```", "def test_minimumChanges():\n    solution = Solution()\n    assert solution.minimumChanges(\"abcabc\", 3) == 0", "def test_minimumChanges():\n    solution = Solution()\n    assert solution.minimumChanges(\"abcabc\", k=3) == 0", "def test_minimumChanges():\n    solution = Solution()\n    assert solution.minimumChanges(\"abcabc\", 2) == 1", "def test_minimumChanges():\n    solution = Solution()\n    assert(solution.minimumChanges(\"abcabc\", 2) == 1)\n    assert(solution.minimumChanges(\"abcabc\", 3) == 0)\n    assert(solution.minimumChanges(\"abaab\", 1) == 0)", "def test_minimumChanges():\n    solution = Solution()\n    assert solution.minimumChanges('abcabc', 2) == 4"]}
{"task_num": 2932, "task_title": "Maximum Strong Pair XOR I", "func_name": "maximumStrongPairXor", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Optional\n\nclass TrieNode:\n  def __init__(self):\n    self.children: List[Optional[TrieNode]] = [None] * 2\n    self.min = math.inf\n    self.max = -math.inf\n\n\nclass BitTrie:\n  def __init__(self, maxBit: int):\n    self.maxBit = maxBit\n    self.root = TrieNode()\n\n  def insert(self, num: int) -> None:\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n      node.min = min(node.min, num)\n      node.max = max(node.max, num)\n\n  def getMaxXor(self, x: int) -> int:\n    maxXor = 0\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = x >> i & 1\n      toggleBit = bit ^ 1\n      if node.children[toggleBit] and node.children[toggleBit].max > x and node.children[toggleBit].min <= 2 * x:\n        maxXor = maxXor | 1 << i\n        node = node.children[toggleBit]\n      elif node.children[bit]:\n        node = node.children[bit]\n      else:\n        return 0\n    return maxXor\n\n\nclass Solution:\n  def maximumStrongPairXor(self, nums: List[int]) -> int:\n    maxNum = max(nums)\n    maxBit = int(math.log2(maxNum))\n    bitTrie = BitTrie(maxBit)\n\n    for num in nums:\n      bitTrie.insert(num)\n\n    return max(bitTrie.getMaxXor(num) for num in nums)\n", "tests": ["def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [4, 6]\n    assert solution.maximumStrongPairXor(nums) == 2", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [10, 2, 5]\n    assert solution.maximumStrongPairXor(nums) == 6", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [5, 3, 8]\n    assert solution.maximumStrongPairXor(nums) == 1", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [4, 2, 6]\n    assert solution.maximumStrongPairXor(nums) == 0", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [5,4,2]\n    assert solution.maximumStrongPairXor(nums) == 6"]}
{"task_num": 2940, "task_title": "Find Building Where Alice and Bob Can Meet", "func_name": "leftmostBuildingQueries", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, a: int, b: int):\n    self.queryIndex = queryIndex\n    self.a = a\n    self.b = b\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.a\n    yield self.b\n\n\nclass Solution:\n  def leftmostBuildingQueries(self, heights: List[int], queries: List[List[int]]) -> List[int]:\n    ans = [-1] * len(queries)\n    stack = []\n\n    heightsIndex = len(heights) - 1\n    for queryIndex, a, b in sorted([IndexedQuery(i, min(a, b), max(a, b)) for i, (a, b) in enumerate(queries)], key=lambda iq: -iq.b):\n      if a == b or heights[a] < heights[b]:\n        ans[queryIndex] = b\n      else:\n        while heightsIndex > b:\n          while stack and heights[stack[-1]] <= heights[heightsIndex]:\n            stack.pop()\n          stack.append(heightsIndex)\n          heightsIndex -= 1\n        j = self._lastGreater(stack, a, heights)\n        if j != -1:\n          ans[queryIndex] = stack[j]\n\n    return ans\n\n  def _lastGreater(self, A: List[int], target: int, heights: List[int]):\n    l = -1\n    r = len(A) - 1\n    while l < r:\n      m = (l + r + 1) // 2\n      if heights[A[m]] > heights[target]:\n        l = m\n      else:\n        r = m - 1\n    return l\n", "tests": ["```python\ndef test_leftmostBuildingQueries():\n    solution = Solution()\n    heights = [7, 5, 8, 4]\n    queries = [(0, 2), (1, 3)]\n    assert solution.leftmostBuildingQueries(heights, queries) == [-1, 3]\n```", "def test_leftmostBuildingQueries():\n    solution = Solution()\n    assert solution.leftmostBuildingQueries([5, 3, 4, 2], [[0, 3], [1, 2]]) == [-1, 2]", "```\ndef test_leftmostBuildingQueries():\n    solution = Solution()\n    heights = [5, 8, 2, 6]\n    queries = [(0, 1), (2, 3)]\n    assert solution.leftmostBuildingQueries(heights, queries) == [-1, -1]\n```", "def test_leftmostBuildingQueries():\n    solution = Solution()\n    heights = [2, 4, 5, 7]\n    queries = [(0, 3), (2, 3)]\n    assert solution.leftmostBuildingQueries(heights, queries) == [-1, 2]"]}
{"task_num": 2948, "task_title": "Make Lexicographically Smallest Array by Swapping Elements", "func_name": "lexicographicallySmallestArray", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def lexicographicallySmallestArray(self, nums: List[int], limit: int) -> List[int]:\n    ans = [0] * len(nums)\n    numAndIndexes = sorted([(num, i) for i, num in enumerate(nums)])\n    numAndIndexesGroups: List[List[Tuple[int, int]]] = []\n\n    for numAndIndex in numAndIndexes:\n      if not numAndIndexesGroups or numAndIndex[0] - numAndIndexesGroups[-1][-1][0] > limit:\n        numAndIndexesGroups.append([numAndIndex])\n      else:\n        numAndIndexesGroups[-1].append(numAndIndex)\n\n    for numAndIndexesGroup in numAndIndexesGroups:\n      sortedNums = [num for num, _ in numAndIndexesGroup]\n      sortedIndices = sorted([index for _, index in numAndIndexesGroup])\n      for num, index in zip(sortedNums, sortedIndices):\n        ans[index] = num\n\n    return ans\n", "tests": ["def test_lexicographicallySmallestArray():\n    solution = Solution()\n    nums = [715, 875, 119, 620]\n    limit = 34\n    assert solution.lexicographicallySmallestArray(nums, limit) == [119, 875, 715, 620]", "def test_lexicographicallySmallestArray():\n    solution = Solution()\n    nums = [5, 10, 2]\n    limit = 3\n    assert solution.lexicographicallySmallestArray(nums, limit) == [2, 5, 10]", "Here's a Python function that covers the specified execution path:\n\n```python\ndef test_lexicographicallySmallestArray():\n    solution = Solution()\n    nums = [2, 10, 3, 5]\n    limit = 5\n    result = solution.lexicographicallySmallestArray(nums, limit)\n    assert result == [2, 3, 5, 10], \"Test case failed\"\n```", "```python\ndef test_lexicographicallySmallestArray():\n    solution = Solution()\n    nums = [2, 4, 3]\n    limit = 1\n    assert solution.lexicographicallySmallestArray(nums, limit) == [2, 3, 4]\n```", "def test_lexicographicallySmallestArray():\n    solution = Solution()\n    nums = [7, 9, 5, 6]\n    limit = 1\n    assert solution.lexicographicallySmallestArray(nums, limit) == [5, 6, 7, 9]", "```python\ndef test_lexicographicallySmallestArray():\n    solution = Solution()\n    nums = [5, 6, 4, 3]\n    limit = 1\n    assert solution.lexicographicallySmallestArray(nums, limit) == [4, 5, 3, 6]\n```"]}
{"task_num": 2953, "task_title": "Count Complete Substrings", "func_name": "countCompleteSubstrings", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countCompleteSubstrings(self, word: str, k: int) -> int:\n    uniqueLetters = len(set(word))\n    return sum(self._countCompleteStrings(word, k, windowSize) for windowSize in range(k, k * uniqueLetters + 1, k))\n\n  def _countCompleteStrings(self, word: str, k: int, windowSize: int) -> int:\n    res = 0\n    countLetters = 0\n    count = collections.Counter()\n\n    for i, c in enumerate(word):\n      count[c] += 1\n      countLetters += 1\n      if i > 0 and abs(ord(c) - ord(word[i - 1])) > 2:\n        count = collections.Counter()\n        count[c] += 1\n        countLetters = 1\n      if countLetters == windowSize + 1:\n        count[word[i - windowSize]] -= 1\n        countLetters -= 1\n      if countLetters == windowSize:\n        res += all(freq == 0 or freq == k for freq in count.values())\n\n    return res\n", "tests": ["def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings(\"abcabc\", 2) == 3", "def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings(\"aabc\", 2) == 1", "def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings('abcabc', 3) == 2", "def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings('abc', 2) == 0"]}
{"task_num": 2959, "task_title": "Number of Possible Sets of Closing Branches", "func_name": "numberOfSets", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:\n    return sum(self._floydWarshall(n, maxDistance, roads, mask) <= maxDistance for mask in range(1 << n))\n\n  def _floydWarshall(self, n: int, maxDistanceThreshold: int, roads: List[List[int]], mask: int) -> List[List[int]]:\n    maxDistance = 0\n    dist = [[maxDistanceThreshold + 1] * n for _ in range(n)]\n\n    for i in range(n):\n      if mask >> i & 1:\n        dist[i][i] = 0\n\n    for u, v, w in roads:\n      if mask >> u & 1 and mask >> v & 1:\n        dist[u][v] = min(dist[u][v], w)\n        dist[v][u] = min(dist[v][u], w)\n\n    for k in range(n):\n      if mask >> k & 1:\n        for i in range(n):\n          if mask >> i & 1:\n            for j in range(n):\n              if mask >> j & 1:\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    for i in range(n):\n      if mask >> i & 1:\n        for j in range(i + 1, n):\n          if mask >> j & 1:\n            maxDistance = max(maxDistance, dist[i][j])\n\n    return maxDistance\n", "tests": ["def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(4, 20, [[0, 1, 1], [1, 2, 4], [2, 3, 5]]) == 7", "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(3, 5, [[0, 1, 4], [1, 2, 8]]) == 7", "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(4, 20, [[0, 1, 10], [0, 2, 20], [1, 3, 5]]) == 7", "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(3, 2, [[0, 1, 1], [0, 2, 1]]) == 4", "def test_numberOfSets():\n    solution = Solution()\n    roads = [[0, 1, 3], [1, 2, 4], [0, 2, 2]]\n    assert solution.numberOfSets(3, 5, roads) == 6", "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(4, 3, [[0, 1, 2], [0, 2, 1]]) == 6"]}
{"task_num": 2973, "task_title": "Find Number of Coins to Place in Tree Nodes", "func_name": "placedCoins", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass ChildCost:\n  def __init__(self, cost: int):\n    self.numNodes = 1\n    self.maxPosCosts = [cost] if cost > 0 else []\n    self.minNegCosts = [cost] if cost < 0 else []\n\n  def update(self, childCost: 'ChildCost') -> None:\n    self.numNodes += childCost.numNodes\n    self.maxPosCosts.extend(childCost.maxPosCosts)\n    self.minNegCosts.extend(childCost.minNegCosts)\n    self.maxPosCosts.sort(reverse=True)\n    self.minNegCosts.sort()\n    self.maxPosCosts = self.maxPosCosts[:3]\n    self.minNegCosts = self.minNegCosts[:2]\n\n  def maxProduct(self) -> int:\n    if self.numNodes < 3:\n      return 1\n    if not self.maxPosCosts:\n      return 0\n    res = 0\n    if len(self.maxPosCosts) == 3:\n      res = self.maxPosCosts[0] * self.maxPosCosts[1] * self.maxPosCosts[2]\n    if len(self.minNegCosts) == 2:\n      res = max(res, self.minNegCosts[0] * self.minNegCosts[1] * self.maxPosCosts[0])\n    return res\n\n\nclass Solution:\n  def placedCoins(self, edges: List[List[int]], cost: List[int]) -> List[int]:\n    n = len(cost)\n    ans = [0] * n\n    tree = [[] for _ in range(n)]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, prev: int) -> None:\n      res = ChildCost(cost[u])\n      for v in tree[u]:\n        if v != prev:\n          res.update(dfs(v, u))\n      ans[u] = res.maxProduct()\n      return res\n\n    dfs(0, -1)\n    return ans\n", "tests": ["def test_placedCoins():\n    solution = Solution()\n    edges = [[0,1], [0,2]]\n    cost = [-3, -2, -1]\n    assert solution.placedCoins(edges, cost) == [1, 0, 1]"]}
{"task_num": 2976, "task_title": "Minimum Cost to Convert String I", "func_name": "minimumCost", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n    ans = 0\n    dist = [[math.inf] * 26 for _ in range(26)]\n\n    for a, b, c in zip(original, changed, cost):\n      u = ord(a) - ord('a')\n      v = ord(b) - ord('a')\n      dist[u][v] = min(dist[u][v], c)\n\n    for k in range(26):\n      for i in range(26):\n        if dist[i][k] < math.inf:\n          for j in range(26):\n            if dist[k][j] < math.inf:\n              dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    for s, t in zip(source, target):\n      if s == t:\n        continue\n      u = ord(s) - ord('a')\n      v = ord(t) - ord('a')\n      if dist[u][v] == math.inf:\n        return -1\n      ans += dist[u][v]\n\n    return ans\n", "tests": ["def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('source', 'target', ['a', 'b', 'c'], ['d', 'e', 'f'], [10, 20, 30]) == -1", "def test_minimumCost():\n    solution = Solution()\n    source = \"aaaaa\"\n    target = \"bbbbb\"\n    original = [\"a\", \"a\", \"a\", \"a\", \"a\"]\n    changed = [\"b\", \"b\", \"b\", \"b\", \"b\"]\n    cost = [26, 26, 26, 26, 26]\n    assert solution.minimumCost(source, target, original, changed, cost) == -1"]}
{"task_num": 2977, "task_title": "Minimum Cost to Convert String II", "func_name": "minimumCost", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n    subLengths = set(len(s) for s in original)\n    subToId = self._getSubToId(original, changed)\n    subCount = len(subToId)\n    dist = [[math.inf for _ in range(subCount)] for _ in range(subCount)]\n    dp = [math.inf for _ in range(len(source) + 1)]\n\n    for a, b, c in zip(original, changed, cost):\n      u = subToId[a]\n      v = subToId[b]\n      dist[u][v] = min(dist[u][v], c)\n\n    for k in range(subCount):\n      for i in range(subCount):\n        if dist[i][k] < math.inf:\n          for j in range(subCount):\n            if dist[k][j] < math.inf:\n              dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    dp[0] = 0\n\n    for i, (s, t) in enumerate(zip(source, target)):\n      if dp[i] == math.inf:\n        continue\n      if s == t:\n        dp[i + 1] = min(dp[i + 1], dp[i])\n      for subLength in subLengths:\n        if i + subLength > len(source):\n          continue\n        subSource = source[i:i + subLength]\n        subTarget = target[i:i + subLength]\n        if subSource not in subToId or subTarget not in subToId:\n          continue\n        u = subToId[subSource]\n        v = subToId[subTarget]\n        if dist[u][v] != math.inf:\n          dp[i + subLength] = min(dp[i + subLength], dp[i] + dist[u][v])\n\n    if dp[len(source)] == math.inf:\n      return -1\n    else:\n      return dp[len(source)]\n\n  def _getSubToId(self, original: str, changed: str) -> Dict[str, int]:\n    subToId = {}\n    for s in original + changed:\n      if s not in subToId:\n        subToId[s] = len(subToId)\n    return subToId\n", "tests": ["def test_minimumCost():\n    solution = Solution()\n    source = \"abc\"\n    target = \"bad\"\n    original = [\"ab\", \"bc\"]\n    changed = [\"ba\", \"cd\"]\n    cost = [1, 2]\n    assert solution.minimumCost(source, target, original, changed, cost) == 3", "def test_minimumCost():\n    source = \"abc\"\n    target = \"de\"\n    original = [\"a\", \"bc\"]\n    changed = [\"d\", \"e\"]\n    cost = [1]\n    solution = Solution()\n    assert solution.minimumCost(source, target, original, changed, cost) == -1", "```python\ndef test_minimumCost():\n    solution = Solution()\n    source = \"abc\"\n    target = \"bad\"\n    original = [\"ab\", \"bc\"]\n    changed = [\"ba\", \"dc\"]\n    cost = [1, 2]\n    assert solution.minimumCost(source, target, original, changed, cost) == -1\n```", "def test_minimumCost():\n    solution = Solution()\n    source = \"abc\"\n    target = \"def\"\n    original = [\"ab\", \"bc\"]\n    changed = [\"de\", \"ef\"]\n    cost = [1, 2]\n    assert solution.minimumCost(source, target, original, changed, cost) == 3", "def test_minimumCost():\n    solution = Solution()\n    source = \"abc\"\n    target = \"bca\"\n    original = [\"abc\"]\n    changed = [\"bca\"]\n    cost = [1]\n    assert solution.minimumCost(source, target, original, changed, cost) == 1", "Here's the required test case:\n\n```python\ndef test_minimumCost():\n    solution = Solution()\n\n    source = \"abc\"\n    target = \"def\"\n    original = [\"ab\", \"bc\"]\n    changed = [\"de\", \"ef\"]\n    cost = [1, 2]\n\n    # Ensure dist matrix has finite values at indices (0, 1) and (1, 2)\n    assert solution.minimumCost(source, target, original, changed, cost) == -1\n```\n\nThis test case covers the given execution path by ensuring that `dist[0][1]` and `dist[1][2]` are finite values when calling `solution.minimumCost()`."]}
{"task_num": 2983, "task_title": "Palindrome Rearrangement Queries", "func_name": "canMakePalindromeQueries", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n    n = len(s)\n    mirroredDiffs = self._getMirroredDiffs(s)\n    counts = self._getCounts(s)\n    ans = []\n\n    def subtractArrays(a: List[int], b: List[int]):\n      return [x - y for x, y in zip(a, b)]\n\n    for a, b, c, d in queries:\n      b += 1\n      d += 1\n      ra = n - a\n      rb = n - b\n      rc = n - c\n      rd = n - d\n\n      if (min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0) or (n // 2 > max(b, rc) and mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0):\n        ans.append(False)\n      else:\n        leftRangeCount = subtractArrays(counts[b], counts[a])\n        rightRangeCount = subtractArrays(counts[d], counts[c])\n        if a > rd:\n          rightRangeCount = subtractArrays(\n              rightRangeCount, subtractArrays(counts[min(a, rc)], counts[rd]))\n        if rc > b:\n          rightRangeCount = subtractArrays(\n              rightRangeCount, subtractArrays(counts[rc], counts[max(b, rd)]))\n        if c > rb:\n          leftRangeCount = subtractArrays(\n              leftRangeCount, subtractArrays(counts[min(c, ra)], counts[rb]))\n        if ra > d:\n          leftRangeCount = subtractArrays(\n              leftRangeCount, subtractArrays(counts[ra], counts[max(d, rb)]))\n        ans.append(min(leftRangeCount) >= 0\n                   and min(rightRangeCount) >= 0\n                   and leftRangeCount == rightRangeCount)\n\n    return ans\n\n  def _getMirroredDiffs(self, s: str) -> List[int]:\n    diffs = [0]\n    for i, j in zip(range(len(s)), reversed(range(len(s)))):\n      if i >= j:\n        break\n      diffs.append(diffs[-1] + (s[i] != s[j]))\n    return diffs\n\n  def _getCounts(self, s: str) -> List[List[int]]:\n    count = [0] * 26\n    counts = [count.copy()]\n    for c in s:\n      count[ord(c) - ord('a')] += 1\n      counts.append(count.copy())\n    return counts\n", "tests": ["def test_canMakePalindromeQueries():\n    s = \"abca\"\n    queries = [[0, 1, 2, 3]]\n    solution = Solution()\n    assert(solution.canMakePalindromeQueries(s, queries)) == [False]", "def test_canMakePalindromeQueries():\n    solution = Solution()\n    assert solution.canMakePalindromeQueries(\"abcd\", [[0, 1, 2, 3]]) == [False]", "def test_canMakePalindromeQueries():\n    solution = Solution()\n    assert solution.canMakePalindromeQueries(\"abcba\", [[0, 1, 2, 3]]) == [False]\n    assert solution.canMakePalindromeQueries(\"a\", [[0, 0, 0, 0]]) == [True]\n    assert solution.canMakePalindromeQueries(\"abcd\", [[0, 3, 2, 4]]) == [False]", "def test_canMakePalindromeQueries():\n    solution = Solution()\n    assert solution.canMakePalindromeQueries(\"abcdba\", [[4, 5, 6, 7]]) == [True]", "def test_canMakePalindromeQueries():\n    solution = Solution()\n    assert(solution.canMakePalindromeQueries('abcba', [[0, 2, 2, 4]]) == [False])", "def test_canMakePalindromeQueries():\n    solution = Solution()\n    s = \"abcdcba\"\n    queries = [[0, 2, 3, 5], [1, 3, 4, 6], [2, 4, 5, 7], [3, 5, 6, 8]]\n    assert solution.canMakePalindromeQueries(s, queries) == [False] * len(queries)"]}
{"task_num": 3001, "task_title": "Minimum Moves to Capture The Queen", "func_name": "minMovesToCaptureTheQueen", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minMovesToCaptureTheQueen(self, a: int, b: int, c: int, d: int, e: int, f: int) -> int:\n    if a == e:\n      if c == a and (b < d < f or b > d > f):\n        return 2\n      else:\n        return 1\n    if b == f:\n      if d == f and (a < c < e or a > c > e):\n        return 2\n      else:\n        return 1\n    if c + d == e + f:\n      if a + b == c + d and (c < a < e or c > a > e):\n        return 2\n      else:\n        return 1\n    if c - d == e - f:\n      if a - b == c - d and (c < a < e or c > a > e):\n        return 2\n      else:\n        return 1\n    return 2\n", "tests": ["def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(4, 5, 2, 3, 6, 7) == 1", "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(3, 4, 2, 5, 3, 6) == 1"]}
{"task_num": 3006, "task_title": "Find Beautiful Indices in the Given Array I", "func_name": "beautifulIndices", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def beautifulIndices(self, s: str, a: str, b: str, k: int) -> List[int]:\n    ans = []\n    indicesA = self._kmp(s, a)\n    indicesB = self._kmp(s, b)\n    indicesBIndex = 0\n\n    for i in indicesA:\n      while indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i < -k:\n        indicesBIndex += 1\n      if indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i <= k:\n        ans.append(i)\n\n    return ans\n\n  def _kmp(self, s: str, pattern: str) -> List[int]:\n    def getLPS(pattern: str) -> List[int]:\n      lps = [0] * len(pattern)\n      j = 0\n      for i in range(1, len(pattern)):\n        while j > 0 and pattern[j] != pattern[i]:\n          j = lps[j - 1]\n        if pattern[i] == pattern[j]:\n          lps[i] = j + 1\n          j += 1\n      return lps\n\n    res = []\n    lps = getLPS(pattern)\n    i = 0\n    j = 0\n    while i < len(s):\n      if s[i] == pattern[j]:\n        i += 1\n        j += 1\n        if j == len(pattern):\n          res.append(i - j)\n          j = lps[j - 1]\n      elif j != 0:\n        j = lps[j - 1]\n      else:\n        i += 1\n    return res\n", "tests": ["```python\ndef test_beautifulIndices():\n    solution = Solution()\n    assert solution.beautifulIndices(\"abcd\", \"bc\", \"ab\", 1) == [0]\n```\nThis test case covers the target execution path by creating a situation where `s[i] == pattern[j]` at line 43, incrementing `j` to match the length of the pattern at line 46, moving forward in `s` but not matching any further characters with `a`, and thus not triggering the condition for adding `i` to the result.", "def test_beautifulIndices():\n    solution = Solution()\n    assert solution.beautifulIndices(\"sabbbbbbbbb\", \"a\", \"b\", 5) == [0]", "def test_beautifulIndices():\n    solution = Solution()\n    assert solution.beautifulIndices(\"abcd\", \"ab\", \"cd\", 3) == [0, 2]"]}
{"task_num": 3029, "task_title": "Minimum Time to Revert Word to Initial State I", "func_name": "minimumTimeToInitialState", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumTimeToInitialState(self, word: str, k: int) -> int:\n    n = len(word)\n    maxOps = (n - 1) // k + 1\n    z = self._zFunction(word)\n\n    for ans in range(1, maxOps):\n      if z[ans * k] >= n - ans * k:\n        return ans\n\n    return maxOps\n\n  def _zFunction(self, s: str) -> List[int]:\n    n = len(s)\n    z = [0] * n\n    l = 0\n    r = 0\n    for i in range(1, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l])\n      while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n    return z\n", "tests": ["def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState(\"abcd\", 2) == 4", "def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState(\"abcd\", 2) == 3", "def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert(solution.minimumTimeToInitialState(\"abc\", 2) == 3)\n    assert(solution.minimumTimeToInitialState(\"a\", 1) == 0)\n    assert(solution.minimumTimeToInitialState(\"abcd\", 3) == 4)", "def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState(\"abcd\", 2) == 3", "def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState(\"aabbcaab\", 3) == 2"]}
{"task_num": 3030, "task_title": "Find the Grid of Region Average", "func_name": "resultGrid", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def resultGrid(self, image: List[List[int]], threshold: int) -> List[List[int]]:\n    m = len(image)\n    n = len(image[0])\n    sums = [[0] * n for _ in range(m)]\n    counts = [[0] * n for _ in range(m)]\n\n    for i in range(m - 2):\n      for j in range(n - 2):\n        if self._isRegion(image, i, j, threshold):\n          subgridSum = sum(image[x][y] for x in range(i, i + 3) for y in range(j, j + 3))\n          for x in range(i, i + 3):\n            for y in range(j, j + 3):\n              sums[x][y] += subgridSum // 9\n              counts[x][y] += 1\n\n    for i in range(m):\n      for j in range(n):\n        if counts[i][j] > 0:\n          image[i][j] = sums[i][j] // counts[i][j]\n\n    return image\n\n  def _isRegion(self, image: List[List[int]], i: int, j: int, threshold: int) -> bool:\n    for x in range(i, i + 3):\n      for y in range(j, j + 3):\n        if x > i and abs(image[x][y] - image[x - 1][y]) > threshold:\n          return False\n        if y > j and abs(image[x][y] - image[x][y - 1]) > threshold:\n          return False\n    return True\n", "tests": ["def test_resultGrid():\n    solution = Solution()\n    image = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    threshold = 0\n    assert solution.resultGrid(image, threshold) == [[3, 4, 5], [6, 7, 8], [9, 10, 11]]"]}
{"task_num": 3043, "task_title": "Find the Length of the Longest Common Prefix", "func_name": "longestCommonPrefix", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass TrieNode:\n  def __init__(self):\n    self.children: Dict[str, TrieNode] = {}\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def insert(self, word: str) -> None:\n    node: TrieNode = self.root\n    for c in word:\n      node = node.children.setdefault(c, TrieNode())\n    node.isWord = True\n\n  def search(self, word: str) -> int:\n    prefixLength = 0\n    node = self.root\n    for c in word:\n      if c not in node.children:\n        break\n      node = node.children[c]\n      prefixLength += 1\n    return prefixLength\n\n\nclass Solution:\n  def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:\n    trie = Trie()\n\n    for num in arr1:\n      trie.insert(str(num))\n\n    return max(trie.search(str(num)) for num in arr2)\n", "tests": ["def test_longestCommonPrefix():\n    solution = Solution()\n    assert solution.longestCommonPrefix([123, 456], [789]) == 0", "def test_longestCommonPrefix():\n    solution = Solution()\n    assert solution.longestCommonPrefix([123, 456], [789]) == 0", "def test_longestCommonPrefix():\n    solution = Solution()\n    assert solution.longestCommonPrefix([123, 456], [789, 1234]) == 0", "Here's the Python function to test `longestCommonPrefix` covering the specified execution path:\n\n```python\ndef test_longestCommonPrefix():\n    solution = Solution()\n\n    trie = Trie()\n    trie.insert('123')\n    trie.insert('456')\n\n    assert solution.longestCommonPrefix([123, 456], [789]) == 0\n\ntest_longestCommonPrefix()\n```\n\nThis test case covers the following execution path:\n\n- `Line 22: (c in word)` \u2192 `'1'` not found, breaks loop\n- `Line 41: (num in arr1)` \u2192 Next iteration starts with `456`\n- `Line 22: (c in word)` \u2192 `'4'` found, continues searching for common prefix\n- `Line 41: (num in arr1)` \u2192 Next iteration starts with `789` (no common prefix)\n- `Line 22: (c in word)` \u2192 No matching `c` in `789`, returns maximum common prefix length as `0`."]}
{"task_num": 3044, "task_title": "Most Frequent Prime", "func_name": "mostFrequentPrime", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def mostFrequentPrime(self, mat: List[List[int]]) -> int:\n    dirs = ((1, 0), (1, -1), (0, -1), (-1, -1),\n            (-1, 0), (-1, 1), (0, 1), (1, 1))\n    m = len(mat)\n    n = len(mat[0])\n    count = collections.Counter()\n\n    def isPrime(num: int) -> bool:\n      return not any(num % i == 0 for i in range(2, int(num**0.5 + 1)))\n\n    for i in range(m):\n      for j in range(n):\n        for dx, dy in dirs:\n          num = 0\n          x = i\n          y = j\n          while 0 <= x < m and 0 <= y < n:\n            num = num * 10 + mat[x][y]\n            if num > 10 and isPrime(num):\n              count[num] += 1\n            x += dx\n            y += dy\n\n    if not count.items():\n      return -1\n    return max(count.items(), key=lambda x: (x[1], x[0]))[0]\n", "tests": ["Here's a test case that covers the specified execution path:\n\n```python\ndef test_mostFrequentPrime():\n    solution = Solution()\n\n    # Test matrix where all paths lead to prime numbers greater than 10.\n    mat = [\n        [2, 3],\n        [3, 5]\n    ]\n    assert solution.mostFrequentPrime(mat) == 13\n```\n\nThis test case uses a 2x2 matrix with values `[2, 3]` and `[3, 5]`. When traversing the matrix in all directions, you get numbers `123`, `132`, `213`, `231`, `312`, `321` (among others). All these numbers are primes greater than 10, so the function returns the largest one, which is `13`. This test case ensures that all branch conditions in the target execution path are satisfied sequentially.", "def test_mostFrequentPrime():\n    solution = Solution()\n    mat = [[1, 2], [3, 4]]\n    assert solution.mostFrequentPrime(mat) == 1", "def test_mostFrequentPrime():\n    solution = Solution()\n    assert solution.mostFrequentPrime([[10, 5], [20, 30]]) == 30", "def test_mostFrequentPrime():\n    solution = Solution()\n    assert solution.mostFrequentPrime([[10, 30]]) == 10"]}
{"task_num": 3072, "task_title": "Distribute Elements Into Two Arrays II", "func_name": "resultArray", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass FenwickTree:\n  def __init__(self, n: int):\n    self.sums = [0] * (n + 1)\n\n  def update(self, i: int, delta: int) -> None:\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def resultArray(self, nums: List[int]) -> List[int]:\n    arr1 = []\n    arr2 = []\n    ranks = self._getRanks(nums)\n    tree1 = FenwickTree(len(ranks))\n    tree2 = FenwickTree(len(ranks))\n\n    def add(num: int, arr: List[int], tree: FenwickTree) -> None:\n      arr.append(num)\n      tree.update(ranks[num], 1)\n\n    add(nums[0], arr1, tree1)\n    add(nums[1], arr2, tree2)\n\n    for i in range(2, len(nums)):\n      greaterCount1 = len(arr1) - tree1.get(ranks[nums[i]])\n      greaterCount2 = len(arr2) - tree2.get(ranks[nums[i]])\n      if greaterCount1 > greaterCount2:\n        add(nums[i], arr1, tree1)\n      elif greaterCount1 < greaterCount2:\n        add(nums[i], arr2, tree2)\n      elif len(arr1) > len(arr2):\n        add(nums[i], arr2, tree2)\n      else:\n        add(nums[i], arr1, tree1)\n\n    return arr1 + arr2\n\n  def _getRanks(self, nums: List[int]) -> Dict[int, int]:\n    ranks = collections.Counter()\n    rank = 0\n    for num in sorted(set(nums)):\n      rank += 1\n      ranks[num] = rank\n    return ranks\n", "tests": ["def test_resultArray():\n    nums = [3, 2, 4]\n    expected = [2, 3, 4]\n    assert solution.resultArray(nums) == expected", "```python\ndef test_resultArray():\n    solution = Solution()\n    nums = [1, 5, 3, 4, 7]\n    assert solution.resultArray(nums) == [1, 5, 3, 4, 7]\n```\nThis test case will follow the target execution path. It starts with 'Line 16: (i < len(self.sums))' because the length of `nums` is greater than the length of the initial `self.sums`. Then it enters the loop at 'Line 47', and for each iteration, the condition 'i in range(2, len(nums))' is satisfied. Finally, the conditions 'Line 22: (i > 0)' are met as we're not getting any index out of range error during the loop iterations.", "def test_resultArray():\n    solution = Solution()\n    nums = [1, 3, 4]\n    assert solution.resultArray(nums) == [1, 3, 4]", "def test_resultArray():\n    solution = Solution()\n    nums = [10, 5, 8, 3, 6, 9]\n    assert solution.resultArray(nums) == [5, 10]", "def test_resultArray():\n    solution = Solution()\n    nums = [3, 1, 2]\n    assert solution.resultArray(nums) == [1, 2, 3]"]}
{"task_num": 3095, "task_title": "Shortest Subarray With OR at Least K I", "func_name": "minimumSubarrayLength", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumSubarrayLength(self, nums: List[int], k: int) -> int:\n    ans = len(nums) + 1\n    ors = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, num in enumerate(nums):\n      ors = self._orNum(ors, num, count)\n      while ors >= k and l <= r:\n        ans = min(ans, r - l + 1)\n        ors = self._undoOrNum(ors, nums[l], count)\n        l += 1\n\n    return -1 if ans == len(nums) + 1 else ans\n\n  def _orNum(self, ors: int, num: int, count: Dict[int, int]) -> int:\n    for i in range(30):\n      if num >> i & 1:\n        count[i] += 1\n        if count[i] == 1:\n          ors += 1 << i\n    return ors\n\n  def _undoOrNum(self, ors: int, num: int, count: Dict[int, int]) -> int:\n    for i in range(30):\n      if num >> i & 1:\n        count[i] -= 1\n        if count[i] == 0:\n          ors -= 1 << i\n    return ors\n", "tests": ["def test_minimumSubarrayLength():\n    solution = Solution()\n    nums = [1, 2, 3]\n    k = 5", "def test_minimumSubarrayLength():\n    nums = [1, 2, 3]\n    k = 64\n    solution = Solution()\n    assert solution.minimumSubarrayLength(nums, k) == -1", "def test_minimumSubarrayLength():\n    nums = [2, 4, 6]\n    k = 8\n    solution = Solution()\n    assert solution.minimumSubarrayLength(nums, k) == 3"]}
{"task_num": 3102, "task_title": "Minimize Manhattan Distances", "func_name": "minimumDistance", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumDistance(self, points: List[List[int]]) -> int:\n    i, j = self._maxManhattanDistance(points, -1)\n    xi, yi = self._maxManhattanDistance(points, i)\n    xj, yj = self._maxManhattanDistance(points, j)\n    return min(self._manhattan(points, xi, yi), self._manhattan(points, xj, yj))\n\n  def _maxManhattanDistance(self, points: List[List[int]], excludedIndex: int) -> int:\n    minSum = math.inf\n    maxSum = -math.inf\n    minDiff = math.inf\n    maxDiff = -math.inf\n    minSumIndex = -1\n    maxSumIndex = -1\n    minDiffIndex = -1\n    maxDiffIndex = -1\n\n    for i, (x, y) in enumerate(points):\n      if i == excludedIndex:\n        continue\n      summ = x + y\n      diff = x - y\n      if summ < minSum:\n        minSum = summ\n        minSumIndex = i\n      if summ > maxSum:\n        maxSum = summ\n        maxSumIndex = i\n      if diff < minDiff:\n        minDiff = diff\n        minDiffIndex = i\n      if diff > maxDiff:\n        maxDiff = diff\n        maxDiffIndex = i\n\n    if maxSum - minSum >= maxDiff - minDiff:\n      return [minSumIndex, maxSumIndex]\n    else:\n      return [minDiffIndex, maxDiffIndex]\n\n  def _manhattan(self, points: List[List[int]], i: int, j: int) -> int:\n    return abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n", "tests": ["def test_minimumDistance():\n    solution = Solution()\n    points = [[-1000, -1000], [-1000, 1000], [1000, -1000], [1000, 1000]]\n    assert solution.minimumDistance(points) == min(2000, 2000)", "```python\ndef test_minimumDistance():\n    solution = Solution()\n    points = [[3,1], [5,-2], [-1,4]]\n    assert solution.minimumDistance(points) == 5\n\ntest_minimumDistance()\n```", "def test_minimumDistance():\n    solution = Solution()\n    points = [[-10,-8],[-5,4],[-2,-6],[7,-4],[3,9]]\n    assert solution.minimumDistance(points) == 9", "def test_minimumDistance():\n    solution = Solution()\n    points = [[-4,-4],[-1,-3],[0,-2],[5,2],[6,3]]\n    assert solution.minimumDistance(points) == 5"]}
{"task_num": 3108, "task_title": "Minimum Cost Walk in Weighted Graph", "func_name": "minimumCost", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n    self.weight = [(1 << 17) - 1] * n\n\n  def unionByRank(self, u: int, v: int, w: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    newWeight = self.weight[i] & self.weight[j] & w\n    self.weight[i] = newWeight\n    self.weight[j] = newWeight\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def getMinCost(self, u: int, v: int) -> int:\n    if u == v:\n      return 0\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return self.weight[i]\n    else:\n      return -1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def minimumCost(self, n: int, edges: List[List[int]], query: List[List[int]]) -> List[int]:\n    uf = UnionFind(n)\n\n    for u, v, w in edges:\n      uf.unionByRank(u, v, w)\n\n    return [uf.getMinCost(u, v) for u, v in query]\n", "tests": ["def test_minimumCost():\n    solution = Solution()\n    n = 5\n    edges = [[0,1,4],[0,2,3],[1,3,2],[1,4,5],[3,2,6]]\n    query = [[0,4],[0,2],[2,3],[1,3]]\n    assert solution.minimumCost(n, edges, query) == [28, 27, -1, 1]", "```python\ndef test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost(5, [[0, 1, 3], [0, 2, 4], [1, 2, 6], [2, 3, 7]], [[0, 1], [1, 2], [2, 3]]) == [-1, -1, -1]\n```", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost(3, [[0,1,2],[1,2,3]], [[0,1],[1,2]]) == [-1,-1]", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost(10, [[0, 5, 3], [2, 7, 6], [9, 8, 4]], [[1, 2], [4, 5]]) == [-1, -1]\n    assert solution.minimumCost(4, [[0, 1, 1], [1, 2, 1]], [[3, 0], [1, 3], [3, 1]]) == [0, -1, -1]"]}
{"task_num": 3112, "task_title": "Minimum Time to Visit Disappearing Nodes", "func_name": "minimumTime", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, 0, disappear)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, disappear: List[int]) -> List[int]:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < disappear[v] and d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    res=[]\n    for d in dist:\n      if d != math.inf:\n        res.append(d)\n      else:\n        res.append(-1)\n    return res\n", "tests": ["def test_minimumTime():\n    solution = Solution()\n    assert solution.minimumTime(3, [[0, 2, 2], [1, 2, 1]], [math.inf, math.inf, 5]) == [0, -1, math.inf]", "def test_minimumTime():\n    solution = Solution()\n    assert solution.minimumTime(4, [[0,1,2],[0,2,3],[1,3,4]], [7,5,6]) == [0,-1,-1,-1]", "def test_minimumTime():\n    solution = Solution()\n    assert solution.minimumTime(3, [[0, 1, 2], [1, 2, 3]], [math.inf, math.inf, 5]) == [-1, -1, math.inf]", "```python\ndef test_minimumTime():\n    solution = Solution()\n    assert solution.minimumTime(4, [[0,1,2],[0,2,3],[1,2,1]], [math.inf, 2, math.inf, math.inf]) == [-1, 0, -1, -1]\n```"]}
{"task_num": 3123, "task_title": "Find Edges in Shortest Paths", "func_name": "findAnswer", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findAnswer(self, n: int, edges: List[List[int]]) -> List[bool]:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    from0 = self._dijkstra(graph, 0)\n    from1 = self._dijkstra(graph, n - 1)\n    return [from0[u] + w + from1[v] == from0[-1] or from0[v] + w + from1[u] == from0[-1] for u, v, w in edges]\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int) -> List[int]:\n    dist = [10**9] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist\n", "tests": ["```python\ndef test_findAnswer():\n    solution = Solution()\n    edges = [[0,1,4], [0,7,8], [1,2,9], [1,6,14], [2,3,10], [2,8,15], [6,3,11], [7,3,13]]\n    assert solution.findAnswer(9, edges) == [True, True, False, True, True, True, True, True]\n```\nIn this test case, we use a graph with 9 nodes and the given edges. The result is expected to be a boolean array where each element corresponds to an edge in the `edges` list. We assert that the output of `findAnswer()` for these inputs is `[True, True, False, True, True, True, True, True]`. This test case follows the target execution path by including edges with varying weights and connections.", "def test_findAnswer():\n    solution = Solution()\n    edges = [[0, 1, 2], [0, 2, 3], [1, 2, 4]]\n    assert solution.findAnswer(3, edges) == [True, True, False]", "def test_findAnswer():\n    solution = Solution()\n    assert solution.findAnswer(4, [[0, 2, 5], [0, 1, 10], [1, 3, 15], [2, 3, 2]]) == [False, True, True, False]", "def test_findAnswer():\n    solution = Solution()\n    assert solution.findAnswer(5, [[0,1,2], [1,2,3], [2,4,1], [1,4,2], [3,4,4]]) == [False, True, False, False, False]\n    graph = [[] for _ in range(5)]\n    graph[0].append((1, 2))\n    graph[1].append((0, 2))\n    graph[1].append((4, 1))\n    graph[4].append((1, 1))\n    graph[4].append((3, 4))\n    graph[3].append((4, 4))"]}
