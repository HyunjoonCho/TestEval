{"task_num": 4, "task_title": "Median of Two Sorted Arrays", "func_name": "findMedianSortedArrays", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n    n1 = len(nums1)\n    n2 = len(nums2)\n    if n1 > n2:\n      return self.findMedianSortedArrays(nums2, nums1)\n\n    l = 0\n    r = n1\n\n    while l <= r:\n      partition1 = (l + r) // 2\n      partition2 = (n1 + n2 + 1) // 2 - partition1\n      maxLeft1 = -2**31 if partition1 == 0 else nums1[partition1 - 1]\n      maxLeft2 = -2**31 if partition2 == 0 else nums2[partition2 - 1]\n      minRight1 = 2**31 - 1 if partition1 == n1 else nums1[partition1]\n      minRight2 = 2**31 - 1 if partition2 == n2 else nums2[partition2]\n      if maxLeft1 <= minRight2 and maxLeft2 <= minRight1:\n        if (n1 + n2) % 2 == 0:\n          return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) * 0.5\n        else:\n          return max(maxLeft1, maxLeft2)\n      elif maxLeft1 > minRight2:\n        r = partition1 - 1\n      else:\n        l = partition1 + 1\n", "tests": [{"start": 15, "end": 16, "test": "```\ndef test_findMedianSortedArrays():\n    solution = Solution()\n    assert solution.findMedianSortedArrays([1], [2]) == 1.5\n```"}, {"start": 28, "end": 32, "test": "```\ndef test_findMedianSortedArrays():\n    solution = Solution()\n    assert solution.findMedianSortedArrays([1, 3], [2]) == 2.0\n```"}, {"start": 29, "end": 30, "test": "```\ndef test_findMedianSortedArrays():\n    solution=Solution()\n    assert round(solution.findMedianSortedArrays([1,3], [2]), 4) == 2.0\n```"}, {"start": 31, "end": 32, "test": "```\ndef test_findMedianSortedArrays():\n    solution=Solution()\n    assert solution.findMedianSortedArrays([1, 3], [2]) == 2.0\n```"}, {"start": 33, "end": 34, "test": "```\ndef test_findMedianSortedArrays():\n    def find_median_sorted_arrays(nums1, nums2):\n        return solution.findMedianSortedArrays([1, 3], [2])\n```"}, {"start": 35, "end": 36, "test": "```\ndef test_findMedianSortedArrays():\n    def find_median_sorted_arrays(nums1, nums2):\n        return solution.findMedianSortedArrays([1, 3], [2])\n```"}]}
{"task_num": 10, "task_title": "Regular Expression Matching", "func_name": "isMatch", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isMatch(self, s: str, p: str) -> bool:\n    m = len(s)\n    n = len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    def isMatch(i: int, j: int) -> bool:\n      return j >= 0 and p[j] == '.' or s[i] == p[j]\n\n    for j, c in enumerate(p):\n      if c == '*' and dp[0][j - 1]:\n        dp[0][j + 1] = True\n\n    for i in range(m):\n      for j in range(n):\n        if p[j] == '*':\n          noRepeat = dp[i + 1][j - 1]\n          doRepeat = isMatch(i, j - 1) and dp[i][j + 1]\n          dp[i + 1][j + 1] = noRepeat or doRepeat\n        elif isMatch(i, j):\n          dp[i + 1][j + 1] = dp[i][j]\n\n    return dp[m][n]\n", "tests": [{"start": 22, "end": 23, "test": "```\ndef test_isMatch():\n    solution=Solution()\n    assert not solution.isMatch(\"a\", \".*\")"}, {"start": 27, "end": 30, "test": "```\ndef test_isMatch():\n    solution=Solution()\n    assert not solution.isMatch(\"aa\", \"a*\"), None"}, {"start": 31, "end": 32, "test": "```\ndef test_isMatch():\n    solution=Solution()\n    assert not solution.isMatch(\"aa\", \"a\"), \n```"}]}
{"task_num": 15, "task_title": "3Sum", "func_name": "threeSum", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def threeSum(self, nums: List[int]) -> List[List[int]]:\n    if len(nums) < 3:\n      return []\n\n    ans = []\n\n    nums.sort()\n\n    for i in range(len(nums) - 2):\n      if i > 0 and nums[i] == nums[i - 1]:\n        continue\n\n      l = i + 1\n      r = len(nums) - 1\n      while l < r:\n        summ = nums[i] + nums[l] + nums[r]\n        if summ == 0:\n          ans.append((nums[i], nums[l], nums[r]))\n          l += 1\n          r -= 1\n          while nums[l] == nums[l - 1] and l < r:\n            l += 1\n          while nums[r] == nums[r + 1] and l < r:\n            r -= 1\n        elif summ < 0:\n          l += 1\n        else:\n          r -= 1\n\n    return ans\n", "tests": [{"start": 13, "end": 14, "test": "```\ndef test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([0]) == [],```"}, {"start": 21, "end": 22, "test": "def test_threeSum():    \n    solution = Solution()    \n    assert solution.threeSum([-1, 0, 1, 2, -1, -4]) == [[-1, -1, 2], [-1, 0, 1]],"}, {"start": 28, "end": 35, "test": "```\ndef test_threeSum():\n    solution=Solution()\n    assert sorted(solution.threeSum([-1,0,1,2,-1,-4])) == [[-1,-1,2],[-1,0,1]], None\n```"}, {"start": 36, "end": 37, "test": "def test_threeSum():    \n    solution = Solution()    \n    assert sorted(solution.threeSum([-1, 0, 1, 2, -1, -4])) == [[-1, -1, 2], [-1, 0, 1]],"}, {"start": 38, "end": 39, "test": "```\ndef test_threeSum():\n    solution=Solution()\n    assert sorted(solution.threeSum([-1,0,1,2,-1,-4])) == [[-1,-1,2],[-1,0,1]], None\n```"}]}
{"task_num": 44, "task_title": "Wildcard Matching", "func_name": "isMatch", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isMatch(self, s: str, p: str) -> bool:\n    m = len(s)\n    n = len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    def isMatch(i: int, j: int) -> bool:\n      return i >= 0 and p[j] == '?' or s[i] == p[j]\n\n    for j, c in enumerate(p):\n      if c == '*':\n        dp[0][j + 1] = dp[0][j]\n\n    for i in range(m):\n      for j in range(n):\n        if p[j] == '*':\n          matchEmpty = dp[i + 1][j]\n          matchSome = dp[i][j + 1]\n          dp[i + 1][j + 1] = matchEmpty or matchSome\n        elif isMatch(i, j):\n          dp[i + 1][j + 1] = dp[i][j]\n\n    return dp[m][n]\n", "tests": [{"start": 22, "end": 23, "test": "```\ndef test_isMatch():\n    solution=Solution()\n    assert not solution.isMatch(\"a\", \"a*\"), \n```"}, {"start": 27, "end": 30, "test": "def test_isMatch(): \n    solution=Solution(); \n    assert not solution.isMatch(\"aa\", \"a*\");"}, {"start": 31, "end": 32, "test": "```\ndef test_isMatch():\n    solution=Solution()\n    assert not solution.isMatch(\"aa\", \"a\"), \n```"}]}
{"task_num": 54, "task_title": "Spiral Matrix", "func_name": "spiralOrder", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n    if not matrix:\n      return []\n\n    m = len(matrix)\n    n = len(matrix[0])\n    ans = []\n    r1 = 0\n    c1 = 0\n    r2 = m - 1\n    c2 = n - 1\n\n    while len(ans) < m * n:\n      j = c1\n      while j <= c2 and len(ans) < m * n:\n        ans.append(matrix[r1][j])\n        j += 1\n      i = r1 + 1\n      while i <= r2 - 1 and len(ans) < m * n:\n        ans.append(matrix[i][c2])\n        i += 1\n      j = c2\n      while j >= c1 and len(ans) < m * n:\n        ans.append(matrix[r2][j])\n        j -= 1\n      i = r2 - 1\n      while i >= r1 + 1 and len(ans) < m * n:\n        ans.append(matrix[i][c1])\n        i -= 1\n      r1 += 1\n      c1 += 1\n      r2 -= 1\n      c2 -= 1\n\n    return ans\n", "tests": [{"start": 13, "end": 14, "test": "```\ndef test_spiralOrder():\n    solution = Solution()\n    assert solution.spiralOrder([]) == []"}]}
{"task_num": 65, "task_title": "Valid Number", "func_name": "isNumber", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isNumber(self, s: str) -> bool:\n    s = s.strip()\n    if not s:\n      return False\n\n    seenNum = False\n    seenDot = False\n    seenE = False\n\n    for i, c in enumerate(s):\n      if c == '.':\n        if seenDot or seenE:\n          return False\n        seenDot = True\n      elif c == 'e' or c == 'E':\n        if seenE or not seenNum:\n          return False\n        seenE = True\n        seenNum = False\n      elif c in '+-':\n        if i > 0 and s[i - 1] not in 'eE':\n          return False\n        seenNum = False\n      else:\n        if not c.isdigit():\n          return False\n        seenNum = True\n\n    return seenNum\n", "tests": [{"start": 14, "end": 15, "test": "```\ndef test_isNumber():\n    solution = Solution()\n    assert not solution.isNumber(\"\")\n```"}, {"start": 22, "end": 25, "test": "```\ndef test_isNumber():\n    solution=Solution()\n    assert not solution.isNumber('123.')"}, {"start": 23, "end": 24, "test": "```\ndef test_isNumber():\n    solution = Solution()\n    assert not solution.isNumber('123.')"}, {"start": 26, "end": 30, "test": "```\ndef test_isNumber():\n    solution=Solution()\n    assert not solution.isNumber('e')"}, {"start": 27, "end": 28, "test": "def test_isNumber():    \n    solution = Solution()    \n    assert not solution.isNumber('e')"}, {"start": 31, "end": 34, "test": "```\ndef test_isNumber():\n    solution=Solution()\n    assert not solution.isNumber('+')"}, {"start": 35, "end": 38, "test": "```\ndef test_isNumber():\n    solution=Solution()\n    assert not solution.isNumber('a')"}, {"start": 32, "end": 33, "test": "```\ndef test_isNumber():\n    solution = Solution()\n    assert not solution.isNumber('+-')"}, {"start": 36, "end": 37, "test": "```\ndef test_isNumber():\n    solution = Solution()\n    assert not solution.isNumber('a')"}]}
{"task_num": 73, "task_title": "Set Matrix Zeroes", "func_name": "setZeroes", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def setZeroes(self, matrix: List[List[int]]) -> None:\n    m = len(matrix)\n    n = len(matrix[0])\n    shouldFillFirstRow = 0 in matrix[0]\n    shouldFillFirstCol = 0 in list(zip(*matrix))[0]\n\n    for i in range(1, m):\n      for j in range(1, n):\n        if matrix[i][j] == 0:\n          matrix[i][0] = 0\n          matrix[0][j] = 0\n\n    for i in range(1, m):\n      for j in range(1, n):\n        if matrix[i][0] == 0 or matrix[0][j] == 0:\n          matrix[i][j] = 0\n\n    if shouldFillFirstRow:\n      matrix[0] = [0] * n\n\n    if shouldFillFirstCol:\n      for row in matrix:\n        row[0] = 0\n", "tests": [{"start": 29, "end": 30, "test": "def test_setZeroes():    \n    solution=Solution()    \n    matrix = [[1, 2, 3], [4, 5, 0], [7, 8, 9]]    \n    solution.setZeroes(matrix)    \n    assert matrix == [[1, 0, 3], [0, 0, 0], [7, 0, 9]]"}, {"start": 32, "end": 34, "test": "def test_setZeroes():    \n    matrix = [[1,2,3],[4,5,0],[7,8,9]]    \n    solution.setZeroes(matrix)"}, {"start": 20, "end": 22, "test": "```\ndef test_setZeroes():\n    solution=Solution()\n    matrix = [[1,2,3],[4,5,0],[7,8,9]]\n    solution.setZeroes(matrix)\n```"}, {"start": 26, "end": 27, "test": "```\ndef test_setZeroes():\n    solution=Solution()\n    matrix = [[1,2,3],[4,5,0],[7,8,9]]\n    solution.setZeroes(matrix)\n```"}]}
{"task_num": 97, "task_title": "Interleaving String", "func_name": "isInterleave", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n    m = len(s1)\n    n = len(s2)\n    if m + n != len(s3):\n      return False\n\n    dp=[]\n    for _ in range(m + 1):\n      dp.append([False] * (n + 1))\n    dp[0][0] = True\n\n    for i in range(1, m + 1):\n      dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n\n    for j in range(1, n + 1):\n      dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n\n    return dp[m][n]\n", "tests": [{"start": 15, "end": 16, "test": "def test_isInterleaf():    \n    solution = Solution()    \n    assert not solution.isInterleave(\"abc\", \"def\", \"adefbc\")"}]}
{"task_num": 126, "task_title": "Word Ladder II", "func_name": "findLadders", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Set\n\nclass Solution:\n  def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n    from collections import deque\n    def connected(a: str, b: str) -> bool:\n      k = 0\n      for i in range(len(a)):\n        if a[i] != b[i]:\n          k += 1\n      return k == 1\n\n    if endWord not in wordList:\n      return []\n\n    visited = set([beginWord])\n\n    q = deque([beginWord])\n    nodes = []\n    find = False\n\n    while q and not find:\n      nodes.append(q.copy())\n      n = len(q)\n      for _ in range(n):\n        word = q.popleft()\n        for item in wordList:\n          if item in visited:\n            continue\n          if not connected(word, item):\n            continue\n          if item == endWord:\n            find = True\n            break\n          visited.add(item)\n          q.append(item)\n        if find:\n          break\n\n    if not find:\n      return []\n\n    ans = []\n\n    def backtracking(word, level: int, steps: List[str]):\n      if word == beginWord:\n        ans.append(steps[::-1])\n        return\n      if level < 0:\n        return\n      for item in nodes[level]:\n        if connected(item, word):\n          steps.append(item)\n          backtracking(item, level-1, steps)\n          steps.pop()\n\n    backtracking(endWord, len(nodes)-1, [endWord])\n    return ans\n", "tests": [{"start": 21, "end": 22, "test": "```\ndef test_findLadders():\n    solution = Solution()\n    assert solution.findLadders('hit', 'cog', ['hot','dot','dog','lot','log','cog']) == [],"}, {"start": 48, "end": 49, "test": "```\ndef test_findLadders():\n    def test_case():\n        wordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"]\n        result = solution.findLadders(\"hit\", \"cog\", wordList)\n        assert not result\n```"}, {"start": 54, "end": 56, "test": "```\ndef test_findLadders():\n    def find_ladders():\n        solution = Solution()\n        result = solution.findLadders(\"hit\", \"cog\", [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"])\n        return result\n```"}, {"start": 57, "end": 58, "test": "```\ndef test_findLadders():\n    def find_ladders():\n        return solution.findLadders(\"hit\", \"cog\", [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"])\n```"}, {"start": 17, "end": 18, "test": "```\ndef test_findLadders():\n    def find_ladders():\n        return solution.findLadders(\"hit\", \"cog\", [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"])\n```"}, {"start": 45, "end": 46, "test": "```\ndef test_findLadders():\n    def assert_equal(actual, expected):\n        pass\n    solution = Solution()\n    wordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"]\n    beginWord = \"hit\"\n    endWord = \"cog\"\n    result = solution.findLadders(beginWord, endWord, wordList)\n    assert_equal(result, [[[\"hit\"], [\"hot\", \"dot\", \"dog\", \"cog\"]]])"}, {"start": 60, "end": 63, "test": "```\ndef test_findLadders():\n    def findLadders(self):\n        return self.findLadders(\"hit\", \"cog\", [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"])\n```"}, {"start": 36, "end": 37, "test": "```\ndef test_findLadders():\n    def find_ladders():\n        return solution.findLadders(\"hit\", \"cog\", [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"])\n```"}, {"start": 38, "end": 39, "test": "```\ndef test_findLadders():\n    solution = Solution()\n    assert solution.findLadders(\"hit\", \"cog\", [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]) == [['hit','hot','dot','dog','cog']], \n```"}, {"start": 40, "end": 42, "test": "```\ndef test_findLadders():\n    solution=Solution()\n    assert solution.findLadders('hit', 'cog', ['hot','dot','dog','lot','log','cog']) == [['hit','hot','dot','dog','cog']], \n```"}]}
{"task_num": 130, "task_title": "Surrounded Regions", "func_name": "solve", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def solve(self, board: List[List[str]]) -> None:\n    if not board:\n      return\n\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(board)\n    n = len(board[0])\n    q = collections.deque()\n\n    for i in range(m):\n      for j in range(n):\n        if i * j == 0 or i == m - 1 or j == n - 1:\n          if board[i][j] == 'O':\n            q.append((i, j))\n            board[i][j] = '*'\n\n    while q:\n      i, j = q.popleft()\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if board[x][y] != 'O':\n          continue\n        q.append((x, y))\n        board[x][y] = '*'\n\n    for row in board:\n      for i, c in enumerate(row):\n        if c == '*':\n          row[i] = 'O'\n        else:\n          row[i] = 'X'\n", "tests": [{"start": 13, "end": 14, "test": "```\ndef test_solve():\n    solution = Solution()\n    board = []\n    solution.solve(board)"}, {"start": 23, "end": 26, "test": "```\ndef test_solve():\n    solution=Solution()\n    def solve(board: List[List[str]]):\n        if not board:\n            return\n        dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n        m = len(board)\n        n = len(board[0])\n        q = collections.deque()\n        \n        for i in range(m):\n            for j in range(n):\n                if i * j == 0 or i == m - 1 or j == n - 1:\n                    if board[i][j] == 'O':\n                        q.append((i, j))\n                        board[i][j] = '*'\n        \n        while q:\n            i, j = q.popleft()\n            for dx, dy in dirs:\n                x = i + dx\n                y = j + dy\n                if x < 0 or x == m or y < 0 or y == n:\n                    continue\n                if board[x][y] != 'O':\n                    continue\n                q.append((x, y))\n                board[x][y] = '*'\n        \n        for row in board:\n            for i, c in enumerate(row):\n                if c == '*':\n                    row[i] = 'O'\n                else:\n                    row[i] = 'X'\n        \n        return board\n    expected_output = [['X', 'X', 'X', 'X'],\n                        ['X', 'O', 'O', 'X'],\n                        ['X', 'O', 'O', 'X'],\n                        ['X', 'X', 'X', 'X']]\n    assert solve([[{'X': 1, 'O': 0}, {'X': 1, 'O': 0}, {'X': 1, 'O': 0}, {'X': 1, 'O': 0}],\n                  [{'X': 1, 'O': 0}, {'X': 1, 'O': 0}, {'X': 1, 'O': 0}, {'X': 1, 'O': 0}]) == expected_output"}, {"start": 33, "end": 34, "test": "```\ndef test_solve():\n    solution=Solution()\n    board = [['X', 'O'], ['O', 'O']]\n    solution.solve(board)\n```"}, {"start": 35, "end": 36, "test": "```\ndef test_solve():\n    solution=Solution()\n    def solve(board: List[List[str]]):\n        pass\n    board = [['X', 'O', 'X'],\n             ['X', 'O', 'X'],\n             ['X', 'O', 'X']]\n    solution.solve(board)\n```"}, {"start": 42, "end": 43, "test": "```\ndef test_solve():\n    solution=Solution()\n    board=[\n        ['X', 'X', 'X', 'X'],\n        ['X', 'O', 'O', 'X'],\n        ['X', 'X', 'O', 'X'],\n        ['X', 'X', 'X', 'X']\n    ]\n```"}, {"start": 44, "end": 45, "test": "```\ndef test_solve():\n    solution=Solution()\n    board=[\n        ['O', 'O', 'O'],\n        ['O', 'X', 'O'],\n        ['O', 'O', 'O']\n    ]\n```"}, {"start": 24, "end": 26, "test": "```\ndef test_solve():\n    solution=Solution()\n    board = [['X', 'X', 'O'], ['X', 'O', 'X'], ['X', 'X', 'X']]\n    solution.solve(board)\n```"}]}
{"task_num": 132, "task_title": "Palindrome Partitioning II", "func_name": "minCut", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minCut(self, s: str) -> int:\n    n = len(s)\n    isPalindrome=[]\n    for _ in range(n):\n      isPalindrome.append([True] * n)\n    dp = [n] * n\n\n    for l in range(2, n + 1):\n      i = 0\n      for j in range(l - 1, n):\n        isPalindrome[i][j] = s[i] == s[j] and isPalindrome[i + 1][j - 1]\n        i += 1\n\n    for i in range(n):\n      if isPalindrome[0][i]:\n        dp[i] = 0\n        continue\n\n      for j in range(i):\n        if isPalindrome[j + 1][i]:\n          dp[i] = min(dp[i], dp[j] + 1)\n\n    return dp[-1]\n", "tests": [{"start": 26, "end": 28, "test": "def test_minCut(): \n    solution=Solution() \n    assert solution.minCut(\"aab\") == 1"}, {"start": 31, "end": 32, "test": "def test_minCut():    \n    solution=Solution()    \n    assert solution.minCut(\"aab\") == 1"}]}
{"task_num": 218, "task_title": "The Skyline Problem", "func_name": "getSkyline", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:\n    n = len(buildings)\n    if n == 0:\n      return []\n    if n == 1:\n      left, right, height = buildings[0]\n      return [[left, height], [right, 0]]\n\n    left = self.getSkyline(buildings[:n // 2])\n    right = self.getSkyline(buildings[n // 2:])\n    return self._merge(left, right)\n\n  def _merge(self, left: List[List[int]], right: List[List[int]]) -> List[List[int]]:\n    ans = []\n    i = 0\n    j = 0\n    leftY = 0\n    rightY = 0\n\n    while i < len(left) and j < len(right):\n      if left[i][0] < right[j][0]:\n        leftY = left[i][1]\n        self._addPoint(ans, left[i][0], max(left[i][1], rightY))\n        i += 1\n      else:\n        rightY = right[j][1]\n        self._addPoint(ans, right[j][0], max(right[j][1], leftY))\n        j += 1\n\n    while i < len(left):\n      self._addPoint(ans, left[i][0], left[i][1])\n      i += 1\n\n    while j < len(right):\n      self._addPoint(ans, right[j][0], right[j][1])\n      j += 1\n\n    return ans\n\n  def _addPoint(self, ans: List[List[int]], x: int, y: int) -> None:\n    if ans and ans[-1][0] == x:\n      ans[-1][1] = y\n      return\n    if ans and ans[-1][1] == y:\n      return\n    ans.append([x, y])\n", "tests": [{"start": 14, "end": 15, "test": "```\ndef test_getSkyline():\n    solution = Solution()\n    assert solution.getSkyline([[1,2,3]]) == [[1,3],[2,0]], None\n```"}, {"start": 16, "end": 18, "test": "```\ndef test_getSkyline():\n    solution=Solution()\n    assert solution.getSkyline([[1,3,5]]) == [[1,5],[3,0]], None\n```"}, {"start": 52, "end": 54, "test": "```\ndef test_getSkyline():\n    def getSkyline(buildings):\n        pass\n    solution = Solution()\n    buildings = [[2, 9, 10], [3, 7, 15], [5, 12, 12]]\n    expected = [[2, 10], [3, 15], [7, 12], [12, 0]]\n    assert getSkyline(buildings) == expected\n```"}, {"start": 55, "end": 56, "test": "```\ndef test_getSkyline():\n    def getSkyline(buildings):\n        pass\n    solution = Solution()\n    buildings = [[2, 9, 3], [0, 2, 5], [3, 17, 10]]\n    expected = [[2, 5], [4, 3], [6, 0], [9, 3], [12, 0], [15, 10], [18, 0]]\n    assert getSkyline(buildings) == expected\n```"}, {"start": 32, "end": 35, "test": "```\ndef test_getSkyline():\n    def getSkyline(buildings):\n        pass\n    solution = Solution()\n    buildings = [[2,9,10],[3,7,15],[5,12,12],[13,20,10],[14,25,18]]\n    expected = [[2,10],[3,15],[7,12],[12,0],[25,0]]\n    assert getSkyline(buildings) == expected\n```"}, {"start": 36, "end": 39, "test": "```\ndef test_getSkyline():\n    solution = Solution()\n    buildings = [[2,9,10],[3,7,15],[5,12,12],[13,20,10],[14,25,18]]\n    expected = [[2,10],[3,15],[7,12],[12,0],[14,0]]\n    assert solution.getSkyline(buildings) == expected\n```"}]}
{"task_num": 227, "task_title": "Basic Calculator II", "func_name": "calculate", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def calculate(self, s: str) -> int:\n    ans = 0\n    prevNum = 0\n    currNum = 0\n    op = '+'\n\n    for i, c in enumerate(s):\n      if c.isdigit():\n        currNum = currNum * 10 + int(c)\n      if not c.isdigit() and c != ' ' or i == len(s) - 1:\n        if op == '+' or op == '-':\n          ans += prevNum\n          prevNum = currNum if op == '+' else -currNum\n        elif op == '*':\n          prevNum = prevNum * currNum\n        elif op == '/':\n          if prevNum < 0:\n            prevNum = math.ceil(prevNum / currNum)\n          else:\n            prevNum = prevNum // currNum\n        op = c\n        currNum = 0\n\n    return ans + prevNum\n", "tests": [{"start": 19, "end": 20, "test": "```\ndef test_calculate():\n    solution=Solution()\n    assert solution.calculate(\"123\") == 123\n```"}, {"start": 21, "end": 33, "test": "def test_calculate(): \n    solution=Solution() \n    assert solution.calculate(\"1+2*3\") == 7"}, {"start": 22, "end": 24, "test": "```\ndef test_calculate():\n    solution=Solution()\n    assert solution.calculate(\"1+2\") == 3\n```"}, {"start": 25, "end": 26, "test": "def test_calculate():    \n    solution=Solution()    \n    assert solution.calculate(\"2*3\") == 6"}, {"start": 27, "end": 31, "test": "def test_calculate(): \n    solution=Solution(); \n    assert solution.calculate(\"1/-2\") == 0"}, {"start": 28, "end": 29, "test": "```\ndef test_calculate():\n    solution=Solution()\n    assert solution.calculate(\"-12345/5\") == -2529, f\"Expected calculate('-12345/5') to return 2529, but got {solution.calculate('-12345/5')}\"\n```"}, {"start": 30, "end": 31, "test": "```\ndef test_calculate():\n    solution=Solution()\n    assert solution.calculate(\"10/-2\") == 5"}]}
{"task_num": 289, "task_title": "Game of Life", "func_name": "gameOfLife", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def gameOfLife(self, board: List[List[int]]) -> None:\n    m = len(board)\n    n = len(board[0])\n\n    for i in range(m):\n      for j in range(n):\n        ones = 0\n        for x in range(max(0, i - 1), min(m, i + 2)):\n          for y in range(max(0, j - 1), min(n, j + 2)):\n            ones += board[x][y] & 1\n\n        if board[i][j] == 1 and (ones == 3 or ones == 4):\n          board[i][j] |= 0b10\n\n        if board[i][j] == 0 and ones == 3:\n          board[i][j] |= 0b10\n\n    for i in range(m):\n      for j in range(n):\n        board[i][j] >>= 1\n", "tests": [{"start": 23, "end": 24, "test": "```\ndef test_gameOfLife():\n    solution = Solution()\n    board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]\n    solution.gameOfLife(board)\n```"}, {"start": 26, "end": 27, "test": "```\ndef test_gameOfLife():\n    solution=Solution()\n    def gameOfLife(board):\n        m = len(board)\n        n = len(board[0])\n        board[[1, 1]] = [0, 0]\n        board[[1, 2]] = [1, 1]\n        board[[1, 3]] = [1, 0]\n        board[[2, 1]] = [1, 1]\n        board[[2, 2]] = [1, 1]\n        board[[2, 3]] = [1, 0]\n        board[[3, 1]] = [1, 1]\n        board[[3, 2]] = [1, 1]\n        board[[3, 3]] = [1, 0]\n        solution.gameOfLife(board)\n        return board"}]}
{"task_num": 310, "task_title": "Minimum Height Trees", "func_name": "findMinHeightTrees", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\n    if n == 1 or not edges:\n      return [0]\n\n    ans = []\n    graph = collections.defaultdict(set)\n\n    for u, v in edges:\n      graph[u].add(v)\n      graph[v].add(u)\n\n    for label, children in graph.items():\n      if len(children) == 1:\n        ans.append(label)\n\n    while n > 2:\n      n -= len(ans)\n      nextLeaves = []\n      for leaf in ans:\n        u = next(iter(graph[leaf]))\n        graph[u].remove(leaf)\n        if len(graph[u]) == 1:\n          nextLeaves.append(u)\n      ans = nextLeaves\n\n    return ans\n", "tests": [{"start": 13, "end": 14, "test": "```\ndef test_findMinHeightTrees():\n    solution = Solution()\n    assert solution.findMinHeightTrees(1, []) == [0], \n```"}, {"start": 24, "end": 25, "test": "```\ndef test_findMinHeightTrees():\n    solution = Solution()\n    assert solution.findMinHeightTrees(3, [[0, 1], [1, 2]]) == [0, 2]\n```"}, {"start": 33, "end": 34, "test": "```\ndef test_findMinHeightTrees():\n    solution = Solution()\n    result = solution.findMinHeightTrees(6, [[0, 1], [0, 2], [0, 3], [5, 4]])\n    print(result)\n```"}]}
{"task_num": 327, "task_title": "Count of Range Sum", "func_name": "countRangeSum", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countRangeSum(self, nums: List[int], lower: int, upper: int) -> int:\n    n = len(nums)\n    self.ans = 0\n    prefix = [0] + list(itertools.accumulate(nums))\n\n    self._mergeSort(prefix, 0, n, lower, upper)\n    return self.ans\n\n  def _mergeSort(self, prefix: List[int], l: int, r: int, lower: int, upper: int) -> None:\n    if l >= r:\n      return\n\n    m = (l + r) // 2\n    self._mergeSort(prefix, l, m, lower, upper)\n    self._mergeSort(prefix, m + 1, r, lower, upper)\n    self._merge(prefix, l, m, r, lower, upper)\n\n  def _merge(self, prefix: List[int], l: int, m: int, r: int, lower: int, upper: int) -> None:\n    lo = m + 1\n    hi = m + 1\n\n    for i in range(l, m + 1):\n      while lo <= r and prefix[lo] - prefix[i] < lower:\n        lo += 1\n      while hi <= r and prefix[hi] - prefix[i] <= upper:\n        hi += 1\n      self.ans += hi - lo\n\n    sorted = [0] * (r - l + 1)\n    k = 0\n    i = l\n    j = m + 1\n\n    while i <= m and j <= r:\n      if prefix[i] < prefix[j]:\n        sorted[k] = prefix[i]\n        k += 1\n        i += 1\n      else:\n        sorted[k] = prefix[j]\n        k += 1\n        j += 1\n\n    while i <= m:\n      sorted[k] = prefix[i]\n      k += 1\n      i += 1\n\n    while j <= r:\n      sorted[k] = prefix[j]\n      k += 1\n      j += 1\n\n    prefix[l:l + len(sorted)] = sorted\n", "tests": [{"start": 21, "end": 22, "test": "```\ndef test_countRangeSum():\n    solution = Solution()\n    assert solution.countRangeSum([-2, 5, -1, 7, 3, -1, 2], -2, 3) == 23\n```"}, {"start": 46, "end": 49, "test": "def test_countRangeSum(): \n    solution=Solution() \n    nums=[-2,5,-1,0,3,-5] \n    lower=-6 \n    upper=6 \n    assert solution.countRangeSum(nums,lower,upper) == 4"}, {"start": 50, "end": 53, "test": "def test_countRangeSum():    \n    solution=Solution()    \n    nums=[-2,5,-1,0,3,-5]    \n    lower=-6    \n    upper=6    \n    assert solution.countRangeSum(nums,lower,upper)==7"}]}
{"task_num": 335, "task_title": "Self Crossing", "func_name": "isSelfCrossing", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isSelfCrossing(self, x: List[int]) -> bool:\n    if len(x) <= 3:\n      return False\n\n    for i in range(3, len(x)):\n      if x[i - 2] <= x[i] and x[i - 1] <= x[i - 3]:\n        return True\n      if i >= 4 and x[i - 1] == x[i - 3] and x[i - 2] <= x[i] + x[i - 4]:\n        return True\n      if i >= 5 and x[i - 4] <= x[i - 2] and x[i - 2] <= x[i] + x[i - 4] and x[i - 1] <= x[i - 3] and x[i - 3] <= x[i - 1] + x[i - 5]:\n        return True\n\n    return False\n", "tests": [{"start": 13, "end": 14, "test": "```\ndef test_isSelfCrossing():\n    solution = Solution()\n    assert not solution.isSelfCrossing([1, 2, 3]), None"}, {"start": 17, "end": 18, "test": "```\ndef test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([2, 1, 1, 4]) is True\n```"}, {"start": 19, "end": 20, "test": "```\ndef test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([2,1,1,2]) is True\n```"}, {"start": 21, "end": 22, "test": "```\ndef test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([2, 1, 1, 4]) is True\n```"}]}
{"task_num": 336, "task_title": "Palindrome Pairs", "func_name": "palindromePairs", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def palindromePairs(self, words: List[str]) -> List[List[int]]:\n    ans = []\n    dict = {word[::-1]: i for i, word in enumerate(words)}\n\n    for i, word in enumerate(words):\n      if \"\" in dict and dict[\"\"] != i and word == word[::-1]:\n        ans.append([i, dict[\"\"]])\n\n      for j in range(1, len(word) + 1):\n        l = word[:j]\n        r = word[j:]\n        if l in dict and dict[l] != i and r == r[::-1]:\n          ans.append([i, dict[l]])\n        if r in dict and dict[r] != i and l == l[::-1]:\n          ans.append([dict[r], i])\n\n    return ans\n", "tests": [{"start": 17, "end": 18, "test": "```\ndef test_palindromePairs():\n    solution = Solution()\n    assert solution.palindromePairs([\"madam\", \"hello\", \"\"]) == [[0, 1], [1, 2]], None\n```"}, {"start": 23, "end": 24, "test": "```\ndef test_palindromePairs():\n    solution = Solution()\n    assert solution.palindromePairs([\"bat\", \"tab\", \"cat\"]) == [[0, 1], [1, 0]]\n```"}, {"start": 25, "end": 26, "test": "```\ndef test_palindromePairs():\n    solution = Solution()\n    assert solution.palindromePairs([\"madam\", \"hello\", \"dad\"]) == [[0, 1]]\n```"}]}
{"task_num": 391, "task_title": "Perfect Rectangle", "func_name": "isRectangleCover", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Set\n\nclass Solution:\n  def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\n    area = 0\n    x1 = math.inf\n    y1 = math.inf\n    x2 = -math.inf\n    y2 = -math.inf\n    corners: Set[Tuple[int, int]] = set()\n\n    for x, y, a, b in rectangles:\n      area += (a - x) * (b - y)\n      x1 = min(x1, x)\n      y1 = min(y1, y)\n      x2 = max(x2, a)\n      y2 = max(y2, b)\n\n      for point in [(x, y), (x, b), (a, y), (a, b)]:\n        if point in corners:\n          corners.remove(point)\n        else:\n          corners.add(point)\n\n    if len(corners) != 4:\n      return False\n    if (x1, y1) not in corners or (x1, y2) not in corners or (x2, y1) not in corners or (x2, y2) not in corners:\n      return False\n    return area == (x2 - x1) * (y2 - y1)\n", "tests": [{"start": 33, "end": 34, "test": "```\ndef test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[1, 1, 3, 3], [2, 2, 4, 4]]\n    assert not solution.isRectangleCover(rectangles)\n```"}, {"start": 35, "end": 36, "test": "```\ndef test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[0, 0, 1, 1], [1, 0, 2, 1], [1, 1, 3, 2], [2, 1, 4, 3]]\n    assert not solution.isRectangleCover(rectangles)"}, {"start": 28, "end": 29, "test": "```\ndef test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[1, 1, 3, 3], [2, 2, 4, 4]]\n    assert not solution.isRectangleCover(rectangles)\n```"}, {"start": 30, "end": 31, "test": "```\ndef test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[1, 1, 3, 3], [2, 2, 4, 4]]\n    assert not solution.isRectangleCover(rectangles)\n```"}]}
{"task_num": 402, "task_title": "Remove K Digits", "func_name": "removeKdigits", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def removeKdigits(self, num: str, k: int) -> str:\n    if len(num) == k:\n      return '0'\n\n    ans = []\n    stack = []\n\n    for i, digit in enumerate(num):\n      while k > 0 and stack and stack[-1] > digit:\n        stack.pop()\n        k -= 1\n      stack.append(digit)\n\n    for _ in range(k):\n      stack.pop()\n\n    for c in stack:\n      if c == '0' and not ans:\n        continue\n      ans.append(c)\n\n    return ''.join(ans) if ans else '0'\n", "tests": [{"start": 13, "end": 14, "test": "```\ndef test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits('100', 3) == '0'"}, {"start": 29, "end": 30, "test": "```\ndef test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits('10200', 1) == '100'\n```"}]}
{"task_num": 407, "task_title": "Trapping Rain Water II", "func_name": "trapRainWater", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def trapRainWater(self, heightMap: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(heightMap)\n    n = len(heightMap[0])\n    ans = 0\n    minHeap = []\n    seen = set()\n\n    for i in range(m):\n      heapq.heappush(minHeap, (heightMap[i][0], i, 0))\n      heapq.heappush(minHeap, (heightMap[i][n - 1], i, n - 1))\n      seen.add((i, 0))\n      seen.add((i, n - 1))\n\n    for j in range(1, n - 1):\n      heapq.heappush(minHeap, (heightMap[0][j], 0, j))\n      heapq.heappush(minHeap, (heightMap[m - 1][j], m - 1, j))\n      seen.add((0, j))\n      seen.add((m - 1, j))\n\n    while minHeap:\n      h, i, j = heapq.heappop(minHeap)\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if (x, y) in seen:\n          continue\n        if heightMap[x][y] < h:\n          ans += h - heightMap[x][y]\n          heapq.heappush(minHeap, (h, x, y))\n        else:\n          heapq.heappush(minHeap, (heightMap[x][y], x, y))\n        seen.add((x, y))\n\n    return ans\n", "tests": [{"start": 37, "end": 38, "test": "def test_trapRainWater(): \n    solution = Solution() \n    assert solution.trapRainWater([[1,4,3,2,5,6,7,8,9]]) == 23"}, {"start": 39, "end": 40, "test": "```\ndef test_trapRainWater():\n    solution = Solution()\n    assert solution.trapRainWater([[1,2,3],[4,5,6],[7,8,9]]) == 10\n```"}, {"start": 41, "end": 43, "test": "```\ndef test_trapRainWater():\n    solution = Solution()\n    assert solution.trapRainWater([[1,4,3,1,1],[3,2,1,3,2],[2,1,1,2,1],[2,2,1,2,1],[3,2,5,3,5]]) == 25\n```"}, {"start": 44, "end": 45, "test": "```\ndef test_trapRainWater():\n    solution = Solution()\n    assert solution.trapRainWater([[1,4,3,2,5,6,7,8,9]]) == 23\n```"}]}
{"task_num": 417, "task_title": "Pacific Atlantic Water Flow", "func_name": "pacificAtlantic", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(heights)\n    n = len(heights[0])\n    qP = collections.deque()\n    qA = collections.deque()\n    seenP = [[False] * n for _ in range(m)]\n    seenA = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n      qP.append((i, 0))\n      qA.append((i, n - 1))\n      seenP[i][0] = True\n      seenA[i][n - 1] = True\n\n    for j in range(n):\n      qP.append((0, j))\n      qA.append((m - 1, j))\n      seenP[0][j] = True\n      seenA[m - 1][j] = True\n\n    def bfs(q: collections.deque, seen: List[List[bool]]):\n      while q:\n        i, j = q.popleft()\n        h = heights[i][j]\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if seen[x][y] or heights[x][y] < h:\n            continue\n          q.append((x, y))\n          seen[x][y] = True\n\n    bfs(qP, seenP)\n    bfs(qA, seenA)\n\n    res=[]\n    for i in range(m):\n      for j in range(n):\n        if seenP[i][j] and seenA[i][j]:\n          res.append([i, j])\n    return res\n", "tests": [{"start": 53, "end": 54, "test": "```\ndef test_pacificAtlantic():\n    def pacificAtlantic(heights):\n        pass\n    solution = Solution()\n    assert pacificAtlantic([[1,2,2,5],[3,3,1,2],[4,2,1,2],[1,1,1,1]]) == [[0,4],[1,3],[1,4],[2,2],[3,2]], None"}, {"start": 40, "end": 41, "test": "```\ndef test_pacificAtlantic():\n    def pacificAtlantic(heights):\n        pass\n    solution = Solution()\n    assert pacificAtlantic([[1,2,2,3,5],[3,2,3,4,5],[1,1,1,2,1],[1,1,1,2,1],[1,1,1,2,1]]) == [[0,4],[1,3],[1,4]], None"}, {"start": 42, "end": 43, "test": "```\ndef test_pacificAtlantic():\n    def pacificAtlantic(heights):\n        pass\n    solution = Solution()\n    assert [[0, 1]] == solution.pacificAtlantic([[1,2,3],[3,5,6,99],[2,1,1,2]],), None"}]}
{"task_num": 420, "task_title": "Strong Password Checker", "func_name": "strongPasswordChecker", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def strongPasswordChecker(self, password: str) -> int:\n    n = len(password)\n    missing = self._getMissing(password)\n    replaces = 0\n    oneSeq = 0\n    twoSeq = 0\n\n    i = 2\n    while i < n:\n      if password[i] == password[i - 1] and password[i - 1] == password[i - 2]:\n        length = 2\n        while i < n and password[i] == password[i - 1]:\n          length += 1\n          i += 1\n        replaces += length // 3\n        if length % 3 == 0:\n          oneSeq += 1\n        if length % 3 == 1:\n          twoSeq += 1\n      else:\n        i += 1\n\n    if n < 6:\n      return max(6 - n, missing)\n    if n <= 20:\n      return max(replaces, missing)\n\n    deletes = n - 20\n    replaces -= min(oneSeq, deletes)\n    replaces -= min(max(deletes - oneSeq, 0), twoSeq * 2) // 2\n    replaces -= max(deletes - oneSeq - twoSeq * 2, 0) // 3\n    return deletes + max(replaces, missing)\n\n  def _getMissing(self, password: str) -> int:\n    return 3 - any(c.isupper() for c in password) - any(c.islower() for c in password) - any(c.isdigit() for c in password)\n", "tests": [{"start": 34, "end": 35, "test": "```\ndef test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker(\"abc\") == 4\n```"}, {"start": 36, "end": 37, "test": "```\ndef test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker(\"a1A\") == 0\n```"}, {"start": 21, "end": 30, "test": "def test_strongPasswordChecker(): \n    solution = Solution() \n    assert solution.strongPasswordChecker(\"Baaba0\") == 0"}, {"start": 31, "end": 32, "test": "```\ndef test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker(\"aabbcc\") == 3, f\"Expected strongPasswordChecker('aabbcc') to return 3, but got {solution.strongPasswordChecker('aabbcc')}\"\n\n```"}, {"start": 27, "end": 28, "test": "```\ndef test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker(\"Baaba0\") == 0\n```"}, {"start": 29, "end": 30, "test": "```\ndef test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker(\"Baaba0\") == 0\n```"}]}
{"task_num": 423, "task_title": "Reconstruct Original Digits from English", "func_name": "originalDigits", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def originalDigits(self, s: str) -> str:\n    count = [0] * 10\n\n    for c in s:\n      if c == 'z':\n        count[0] += 1\n      if c == 'o':\n        count[1] += 1\n      if c == 'w':\n        count[2] += 1\n      if c == 'h':\n        count[3] += 1\n      if c == 'u':\n        count[4] += 1\n      if c == 'f':\n        count[5] += 1\n      if c == 'x':\n        count[6] += 1\n      if c == 's':\n        count[7] += 1\n      if c == 'g':\n        count[8] += 1\n      if c == 'i':\n        count[9] += 1\n\n    count[1] -= count[0] + count[2] + count[4]\n    count[3] -= count[8]\n    count[5] -= count[4]\n    count[7] -= count[6]\n    count[9] -= count[5] + count[6] + count[8]\n\n    return ''.join(chr(i + ord('0')) for i, c in enumerate(count) for j in range(c))\n", "tests": [{"start": 16, "end": 17, "test": "def test_originalDigits(): \n    solution = Solution() \n    assert solution.originalDigits(\"zzz\") == \"0\","}, {"start": 18, "end": 19, "test": "def test_originalDigits(): \n    solution = Solution() \n    assert solution.originalDigits(\"zeroonetwo\") == \"012\""}, {"start": 20, "end": 21, "test": "def test_originalDigits(): \n    solution = Solution() \n    assert solution.originalDigits(\"owoz\") == \"012\""}, {"start": 22, "end": 23, "test": "def test_originalDigits(): \n    solution = Solution() \n    assert solution.originalDigits(\"hru\") == \"349\","}, {"start": 24, "end": 25, "test": "```\ndef test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits(\"zeroonetwothreefourfive\") == \"0123456789\""}, {"start": 26, "end": 27, "test": "def test_originalDigits(): \n    solution = Solution() \n    assert solution.originalDigits(\"four\") == \"4120\""}, {"start": 28, "end": 29, "test": "def test_originalDigits(): \n    solution = Solution() \n    assert solution.originalDigits(\"six\") == \"612\""}, {"start": 30, "end": 31, "test": "def test_originalDigits(): \n    solution = Solution() \n    assert solution.originalDigits(\"six\") == \"617\""}, {"start": 32, "end": 33, "test": "```\ndef test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits(\"sixeightzero\") == \"018246\", \n```"}, {"start": 34, "end": 35, "test": "```\ndef test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits(\"iu\") == \"4926\""}]}
{"task_num": 457, "task_title": "Circular Array Loop", "func_name": "circularArrayLoop", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def circularArrayLoop(self, nums: List[int]) -> bool:\n    def advance(i: int) -> int:\n      return (i + nums[i]) % len(nums)\n\n    if len(nums) < 2:\n      return False\n\n    for i, num in enumerate(nums):\n      if num == 0:\n        continue\n\n      slow = i\n      fast = advance(slow)\n      while num * nums[fast] > 0 and num * nums[advance(fast)] > 0:\n        if slow == fast:\n          if slow == advance(slow):\n            break\n          return True\n        slow = advance(slow)\n        fast = advance(advance(fast))\n\n      slow = i\n      sign = num\n      while sign * nums[slow] > 0:\n        next = advance(slow)\n        nums[slow] = 0\n        slow = next\n\n    return False\n", "tests": [{"start": 16, "end": 17, "test": "```\ndef test_circularArrayLoop():\n    solution = Solution()\n    assert not solution.circularArrayLoop([1]), \n```"}, {"start": 20, "end": 21, "test": "```\ndef test_circularArrayLoop():\n    solution = Solution()\n    assert not solution.circularArrayLoop([1, -2, 3, 4, -5])"}, {"start": 26, "end": 29, "test": "```\ndef test_circularArrayLoop():\n    solution = Solution()\n    assert solution.circularArrayLoop([1, 2, -1, 2, 2]) == True\n```"}, {"start": 27, "end": 28, "test": "```\ndef test_circularArrayLoop():\n    solution = Solution()\n    assert not solution.circularArrayLoop([1, 2, -1, 2, 2]), None"}]}
{"task_num": 524, "task_title": "Longest Word in Dictionary through Deleting", "func_name": "findLongestWord", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findLongestWord(self, s: str, d: List[str]) -> str:\n    ans = ''\n\n    for word in d:\n      i = 0\n      for c in s:\n        if i < len(word) and c == word[i]:\n          i += 1\n      if i == len(word):\n        if len(word) > len(ans) or len(word) == len(ans) and word < ans:\n          ans = word\n\n    return ans\n", "tests": [{"start": 20, "end": 22, "test": "```\ndef test_findLongestWord():\n    solution=Solution()\n    assert solution.findLongestWord(\"abpcplea\", [\"apples\", \"appple\", \"apppple\", \"apppplee\"]) == \"appple\"\n```"}, {"start": 18, "end": 19, "test": "```\ndef test_findLongestWord():\n    solution=Solution()\n    assert solution.findLongestWord(\"abc\", [\"a\", \"ab\", \"abc\"]) == \"abc\"\n```"}, {"start": 21, "end": 22, "test": "```\ndef test_findLongestWord():\n    solution=Solution()\n    assert solution.findLongestWord(\"abcde\", [\"a\", \"ab\", \"abc\", \"abcd\"]) == \"abcd\"\n```"}]}
{"task_num": 542, "task_title": "01 Matrix", "func_name": "updateMatrix", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(mat)\n    n = len(mat[0])\n    q = collections.deque()\n    seen = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j] == 0:\n          q.append((i, j))\n          seen[i][j] = True\n\n    while q:\n      i, j = q.popleft()\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if seen[x][y]:\n          continue\n        mat[x][y] = mat[i][j] + 1\n        q.append((x, y))\n        seen[x][y] = True\n\n    return mat\n", "tests": [{"start": 21, "end": 23, "test": "```\ndef test_updateMatrix():\n    solution=Solution()\n    mat = [[0, 1], [1, 0]]\n    expected = [[0, 0], [0, 0]]\n    assert solution.updateMatrix(mat) == expected\n```"}, {"start": 30, "end": 31, "test": "```\ndef test_updateMatrix():\n    solution = Solution()\n    mat = [[0,1,2,0],\n          [0,1,0,1],\n          [1,1,0,1],\n          [0,0,0,1]]\n    expected = [[0,0,0,0],\n                [0,1,1,1],\n                [1,2,2,1],\n                [0,0,0,0]]\n    assert solution.updateMatrix(mat) == expected"}, {"start": 32, "end": 33, "test": "```\ndef test_updateMatrix():\n    solution = Solution()\n    mat = [[0, 1, 0], [0, 0, 0], [0, 0, 1]]\n    result = solution.updateMatrix(mat)\n```"}]}
{"task_num": 547, "task_title": "Number of Provinces", "func_name": "findCircleNum", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    self.count -= 1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findCircleNum(self, isConnected: List[List[int]]) -> int:\n    n = len(isConnected)\n    uf = UnionFind(n)\n\n    for i in range(n):\n      for j in range(i, n):\n        if isConnected[i][j] == 1:\n          uf.unionByRank(i, j)\n\n    return uf.count\n", "tests": [{"start": 20, "end": 21, "test": "def test_findCircleNum():    \n    solution = Solution()    \n    isConnected = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]    \n    assert solution.findCircleNum(isConnected) == 2"}, {"start": 22, "end": 23, "test": "def test_findCircleNum():    \n    solution=Solution()    \n    isConnected=[[1, 1, 0], [1, 1, 0], [0, 0, 1]]    \n    assert solution.findCircleNum(isConnected) == 2"}, {"start": 32, "end": 33, "test": "def test_findCircleNum():    \n    solution=Solution()    \n    isConnected=[[1, 1, 0], [1, 1, 0], [0, 0, 1]]    \n    assert solution.findCircleNum(isConnected) == 2"}, {"start": 24, "end": 25, "test": "```\ndef test_findCircleNum():\n    solution=Solution()\n    assert solution.findCircleNum([[1, 1, 0], [1, 1, 0], [0, 0, 1]]) == 2\n```"}, {"start": 26, "end": 28, "test": "```\ndef test_findCircleNum():\n    solution=Solution()\n    isConnected = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]\n    assert solution.findCircleNum(isConnected) == 2\n```"}, {"start": 44, "end": 45, "test": "```\ndef test_findCircleNum():\n    solution = Solution()\n    isConnected = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]\n    assert solution.findCircleNum(isConnected) == 2\n```"}]}
{"task_num": 581, "task_title": "Shortest Unsorted Continuous Subarray", "func_name": "findUnsortedSubarray", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findUnsortedSubarray(self, nums: List[int]) -> int:\n    mini = math.inf\n    maxi = -math.inf\n    flag = False\n\n    for i in range(1, len(nums)):\n      if nums[i] < nums[i - 1]:\n        flag = True\n      if flag:\n        mini = min(mini, nums[i])\n\n    flag = False\n\n    for i in reversed(range(len(nums) - 1)):\n      if nums[i] > nums[i + 1]:\n        flag = True\n      if flag:\n        maxi = max(maxi, nums[i])\n\n    for l in range(len(nums)):\n      if nums[l] > mini:\n        break\n\n    for r, num in reversed(list(enumerate(nums))):\n      if num < maxi:\n        break\n\n    return 0 if l >= r else r - l + 1\n", "tests": [{"start": 18, "end": 19, "test": "```\ndef test_findUnsortedSubarray():\n    solution=Solution()\n    assert solution.findUnsortedSubarray([2,3,3,2,2]) == 4\n```"}, {"start": 20, "end": 21, "test": "```\ndef test_findUnsortedSubarray():\n    solution=Solution()\n    assert solution.findUnsortedSubarray([2,3,3,2,2]) == 4\n```"}, {"start": 26, "end": 27, "test": "```\ndef test_findUnsortedSubarray():\n    solution=Solution()\n    assert solution.findUnsortedSubarray([2,3,3,2,2]) == 4\n```"}, {"start": 28, "end": 29, "test": "```\ndef test_findUnsortedSubarray():\n    solution=Solution()\n    assert solution.findUnsortedSubarray([2,3,3,2,2]) == 4\n```"}, {"start": 32, "end": 33, "test": "```\ndef test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([2,3,3,2,2]) == 4\n```"}, {"start": 36, "end": 37, "test": "```\ndef test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([2,3,3,2,2]) == 4\n```"}]}
{"task_num": 591, "task_title": "Tag Validator", "func_name": "isValid", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isValid(self, code: str) -> bool:\n    if code[0] != '<' or code[-1] != '>':\n      return False\n\n    containsTag = False\n    stack = []\n\n    def isValidCdata(s: str) -> bool:\n      return s.find('[CDATA[') == 0\n\n    def isValidTagName(tagName: str, isEndTag: bool) -> bool:\n      nonlocal containsTag\n      if not tagName or len(tagName) > 9:\n        return False\n      if any(not c.isupper() for c in tagName):\n        return False\n\n      if isEndTag:\n        return stack and stack.pop() == tagName\n\n      containsTag = True\n      stack.append(tagName)\n      return True\n\n    i = 0\n    while i < len(code):\n      if not stack and containsTag:\n        return False\n      if code[i] == '<':\n        if stack and code[i + 1] == '!':\n          closeIndex = code.find(']]>', i + 2)\n          if closeIndex == -1 or not isValidCdata(code[i + 2:closeIndex]):\n            return False\n        elif code[i + 1] == '/':\n          closeIndex = code.find('>', i + 2)\n          if closeIndex == -1 or not isValidTagName(code[i + 2:closeIndex], True):\n            return False\n        else:\n          closeIndex = code.find('>', i + 1)\n          if closeIndex == -1 or not isValidTagName(code[i + 1:closeIndex], False):\n            return False\n        i = closeIndex\n      i += 1\n\n    return not stack and containsTag\n", "tests": [{"start": 13, "end": 14, "test": "```\ndef test_isValid():\n    solution = Solution()\n    assert not solution.isValid(\">hello world<\"), True"}, {"start": 24, "end": 25, "test": "```\ndef test_isValid():\n    solution = Solution()\n    assert not solution.isValid('<InvalidTagName>')"}, {"start": 26, "end": 27, "test": "```\ndef test_isValid():\n    solution = Solution()\n    assert not solution.isValid('<InvalidTag>')"}, {"start": 29, "end": 30, "test": "```\ndef test_isValid():\n    solution = Solution()\n    assert not solution.isValid('<TAG>hello</TAG>')"}, {"start": 38, "end": 39, "test": "```\ndef test_isValid():\n    solution = Solution()\n    assert not solution.isValid('<a>b</a>')"}, {"start": 40, "end": 53, "test": "```\ndef test_isValid():\n    solution=Solution()\n    assert not solution.isValid('<tag>hello world</tag>')"}, {"start": 41, "end": 44, "test": "```\ndef test_isValid():\n    solution = Solution()\n    assert not solution.isValid('<![CDATA[hello world]]>'), True"}, {"start": 43, "end": 44, "test": "```\ndef test_isValid():\n    solution = Solution()\n    assert not solution.isValid('<![CDATA[invalid]]>')"}, {"start": 45, "end": 48, "test": "```\ndef test_isValid():\n    solution = Solution()\n    assert not solution.isValid('<tag/>')"}, {"start": 49, "end": 52, "test": "```\ndef test_isValid():\n    solution = Solution()\n    assert not solution.isValid('<TAG_NAME>some content</TAG_NAME>')"}, {"start": 47, "end": 48, "test": "```\ndef test_isValid():\n    solution = Solution()\n    assert not solution.isValid('<TAG_NAME>some content</TAG_NAME>')"}, {"start": 51, "end": 52, "test": "```\ndef test_isValid():\n    solution = Solution()\n    assert not solution.isValid('<TAG>hello world</TAG>')"}]}
{"task_num": 648, "task_title": "Replace Words", "func_name": "replaceWords", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def __init__(self):\n    self.root = {}\n\n  def insert(self, word: str) -> None:\n    node = self.root\n    for c in word:\n      if c not in node:\n        node[c] = {}\n      node = node[c]\n    node['word'] = word\n\n  def search(self, word: str) -> str:\n    node = self.root\n    for c in word:\n      if 'word' in node:\n        return node['word']\n      if c not in node:\n        return word\n      node = node[c]\n    return word\n\n  def replaceWords(self, dictionary: List[str], sentence: str) -> str:\n    for word in dictionary:\n      self.insert(word)\n\n    words = sentence.split(' ')\n    return ' '.join([self.search(word) for word in words])\n", "tests": [{"start": 18, "end": 19, "test": "```\ndef test_replaceWords():\n    solution=Solution()\n    def test_case():\n        dictionary=[\"help\",\"ful\"]\n        sentence=\"i help ful people\"\n        expected_output=\"i helpful people\"\n        assert solution.replaceWords(dictionary, sentence) == expected_output\n    test_case()"}, {"start": 26, "end": 27, "test": "```\ndef test_replaceWords():\n    solution = Solution()\n    solution.insert(\"help\")\n    solution.insert(\"ful\")\n    assert solution.replaceWords([\"help\", \"ful\"], \"helpful is a good help\") == \"help is a good help\"\n```"}, {"start": 28, "end": 29, "test": "```\ndef test_replaceWords():\n    solution = Solution()\n    result = solution.replaceWords([\"help\", \"ful\"], \"helpful is a good help\")\n    print(result)\n```"}]}
{"task_num": 673, "task_title": "Number of Longest Increasing Subsequence", "func_name": "findNumberOfLIS", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findNumberOfLIS(self, nums: List[int]) -> int:\n    ans = 0\n    maxLength = 0\n    length = [1] * len(nums)\n    count = [1] * len(nums)\n\n    for i, num in enumerate(nums):\n      for j in range(i):\n        if nums[j] < num:\n          if length[i] < length[j] + 1:\n            length[i] = length[j] + 1\n            count[i] = count[j]\n          elif length[i] == length[j] + 1:\n            count[i] += count[j]\n\n    for i, l in enumerate(length):\n      if l > maxLength:\n        maxLength = l\n        ans = count[i]\n      elif l == maxLength:\n        ans += count[i]\n\n    return ans\n", "tests": [{"start": 28, "end": 30, "test": "```\ndef test_findNumberOfLIS():\n    solution=Solution()\n    assert solution.findNumberOfLIS([1,3,5,4,2]) == 2\n```"}, {"start": 20, "end": 25, "test": "```\ndef test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([1,3,5,4,2]) == 2\n```"}, {"start": 31, "end": 32, "test": "```\ndef test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([1, 3, 6, 7]) == 2\n```"}, {"start": 21, "end": 23, "test": "```\ndef test_findNumberOfLIS():\n    solution=Solution()\n    assert solution.findNumberOfLIS([1,3,5,4,2]) == 2\n```"}, {"start": 24, "end": 25, "test": "```\ndef test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([1,3,5,4,2]) == 2\n```"}]}
{"task_num": 684, "task_title": "Redundant Connection", "func_name": "findRedundantConnection", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n    uf = UnionFind(len(edges) + 1)\n\n    for edge in edges:\n      u, v = edge\n      if not uf.unionByRank(u, v):\n        return edge\n", "tests": [{"start": 19, "end": 20, "test": "```\ndef test_findRedundantConnection():\n    solution=Solution()\n    result = solution.findRedundantConnection([[1,2],[1,3],[2,3]])\n```"}, {"start": 21, "end": 22, "test": "```\ndef test_findRedundantConnection():\n    solution=Solution()\n    result = solution.findRedundantConnection([[1,2],[1,3],[2,3]])\n```"}, {"start": 31, "end": 32, "test": "```\ndef test_findRedundantConnection():\n    solution=Solution()\n    result = solution.findRedundantConnection([[1,2],[1,3],[2,3]])\n```"}, {"start": 23, "end": 24, "test": "```\ndef test_findRedundantConnection():\n    solution=Solution()\n    result = solution.findRedundantConnection([[1,2],[1,3],[2,3]])\n```"}, {"start": 25, "end": 27, "test": "```\ndef test_findRedundantConnection():\n    solution=Solution()\n    result=solution.findRedundantConnection([[1,2],[1,3],[2,3]])\n```"}, {"start": 42, "end": 43, "test": "```\ndef test_findRedundantConnection():\n    solution=Solution()\n    result = solution.findRedundantConnection([[1,2],[1,3],[2,3]])\n```"}]}
{"task_num": 685, "task_title": "Redundant Connection II", "func_name": "findRedundantDirectedConnection", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\n    ids = [0] * (len(edges) + 1)\n    nodeWithTwoParents = 0\n\n    for _, v in edges:\n      ids[v] += 1\n      if ids[v] == 2:\n        nodeWithTwoParents = v\n\n    def findRedundantDirectedConnection(skippedEdgeIndex: int) -> List[int]:\n      uf = UnionFind(len(edges) + 1)\n\n      for i, edge in enumerate(edges):\n        if i == skippedEdgeIndex:\n          continue\n        if not uf.unionByRank(edge[0], edge[1]):\n          return edge\n\n      return []\n\n    if nodeWithTwoParents == 0:\n      return findRedundantDirectedConnection(-1)\n\n    for i in reversed(range(len(edges))):\n      _, v = edges[i]\n      if v == nodeWithTwoParents:\n        if not findRedundantDirectedConnection(i):\n          return edges[i]\n", "tests": [{"start": 19, "end": 20, "test": "```\ndef test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1, 2], [1, 3], [2, 4]]\n    assert solution.findRedundantDirectedConnection(edges) == [2, 4]\n```"}, {"start": 21, "end": 22, "test": "```\ndef test_findRedundantDirectedConnection():\n    solution=Solution()\n    edges = [[1,2],[2,3],[4,5]]\n    result = solution.findRedundantDirectedConnection(edges)\n    print(result)"}, {"start": 31, "end": 32, "test": "```\ndef test_findRedundantDirectedConnection():\n    solution=Solution()\n    edges = [[1,2],[2,3],[4,5]]\n    result = solution.findRedundantDirectedConnection(edges)\n```"}, {"start": 57, "end": 58, "test": "```\ndef test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1,2],[2,3],[4,5]]\n    result = solution.findRedundantDirectedConnection(edges)\n```"}, {"start": 23, "end": 24, "test": "```\ndef test_findRedundantDirectedConnection():\n    solution=Solution()\n    edges = [[1,2],[2,3],[4,5]]\n    result = solution.findRedundantDirectedConnection(edges)\n    print(result)"}, {"start": 25, "end": 27, "test": "```\ndef test_findRedundantDirectedConnection():\n    solution=Solution()\n    edges = [[1,2],[2,3],[4,5]]\n    result = solution.findRedundantDirectedConnection(edges)\n    print(result)"}, {"start": 43, "end": 44, "test": "```\ndef test_findRedundantDirectedConnection():\n    solution=Solution()\n    edges = [[1,2],[2,3],[4,5]]\n    result = solution.findRedundantDirectedConnection(edges)\n```"}, {"start": 62, "end": 64, "test": "```\ndef test_findRedundantDirectedConnection():\n    solution = Solution()\n    result = solution.findRedundantDirectedConnection([[1,2],[2,3],[4,5]])\n    assert result == [2, 3]\n```"}, {"start": 50, "end": 51, "test": "```\ndef test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1,2],[2,3],[4,5]]\n    result = solution.findRedundantDirectedConnection(edges)\n    print(result)"}, {"start": 52, "end": 53, "test": "```\ndef test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1,2],[2,3],[4,5]]\n    result = solution.findRedundantDirectedConnection(edges)\n```"}, {"start": 63, "end": 64, "test": "```\ndef test_findRedundantDirectedConnection():\n    solution = Solution()\n    result = solution.findRedundantDirectedConnection([[1,2],[2,3],[4,5]])\n    assert result == [2, 3]\n```"}]}
{"task_num": 688, "task_title": "Knight Probability in Chessboard", "func_name": "knightProbability", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\n    dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n    dp = [[0] * n for _ in range(n)]\n    dp[row][column] = 1.0\n\n    for _ in range(k):\n      newDp = [[0] * n for _ in range(n)]\n      for i in range(n):\n        for j in range(n):\n          for dx, dy in dirs:\n            x = i + dx\n            y = j + dy\n            if 0 <= x < n and 0 <= y < n:\n              newDp[i][j] += dp[x][y]\n      dp = newDp\n\n    return sum(map(sum, dp)) / 8**k\n", "tests": [{"start": 24, "end": 25, "test": "```\ndef test_knightProbability():\n    def knightProbability(n: int, k: int, row: int, column: int) -> float:\n        assert round(knightProbability(3, 2, 0, 0), 6) == 0.166667\n```"}]}
{"task_num": 689, "task_title": "Maximum Sum of 3 Non-Overlapping Subarrays", "func_name": "maxSumOfThreeSubarrays", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:\n    n = len(nums) - k + 1\n    sums = [0] * n\n    l = [0] * n\n    r = [0] * n\n\n    summ = 0\n    for i, num in enumerate(nums):\n      summ += num\n      if i >= k:\n        summ -= nums[i - k]\n      if i >= k - 1:\n        sums[i - k + 1] = summ\n\n    maxIndex = 0\n    for i in range(n):\n      if sums[i] > sums[maxIndex]:\n        maxIndex = i\n      l[i] = maxIndex\n\n    maxIndex = n - 1\n    for i in range(n - 1, -1, -1):\n      if sums[i] >= sums[maxIndex]:\n        maxIndex = i\n      r[i] = maxIndex\n\n    ans = [-1, -1, -1]\n\n    for i in range(k, n - k):\n      if ans[0] == -1 or sums[ans[0]] + sums[ans[1]] + sums[ans[2]] < sums[l[i - k]] + sums[i] + sums[r[i + k]]:\n        ans[0] = l[i - k]\n        ans[1] = i\n        ans[2] = r[i + k]\n\n    return ans\n", "tests": [{"start": 21, "end": 22, "test": "```\ndef test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([1, 2, 3, 4, 5], 2) == [0, 3, 6]\n```"}, {"start": 23, "end": 24, "test": "```\ndef test_maxSumOfThreeSubarrays():\n    solution=Solution()\n    nums=[1,2,3,4,5,6,7,8,9]\n    k=3\n    result=solution.maxSumOfThreeSubarrays(nums,k)\n```"}, {"start": 28, "end": 29, "test": "```\ndef test_maxSumOfThreeSubarrays():\n    solution=Solution()\n    nums=[1,2,3,4,5]\n    k=2\n    assert solution.maxSumOfThreeSubarrays(nums,k) == [0, 3, 6], None\n```"}, {"start": 34, "end": 35, "test": "```\ndef test_maxSumOfThreeSubarrays():\n    solution=Solution()\n    assert solution.maxSumOfThreeSubarrays([1,2,3,4,5], 2) == [0, 3, 6]\n```"}, {"start": 41, "end": 44, "test": "```\ndef test_maxSumOfThreeSubarrays():\n    def solution=Solution()\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    k = 3\n    expected_result = [-1, -1, -1]\n    assert solution.maxSumOfThreeSubarrays(nums, k) == expected_result"}]}
{"task_num": 691, "task_title": "Stickers to Spell Word", "func_name": "minStickers", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minStickers(self, stickers: List[str], target: str) -> int:\n    maxMask = 1 << len(target)\n    dp = [math.inf] * maxMask\n    dp[0] = 0\n\n    for mask in range(maxMask):\n      if dp[mask] == math.inf:\n        continue\n      for sticker in stickers:\n        superMask = mask\n        for c in sticker:\n          for i, t in enumerate(target):\n            if c == t and not (superMask >> i & 1):\n              superMask |= 1 << i\n              break\n        dp[superMask] = min(dp[superMask], dp[mask] + 1)\n\n    return -1 if dp[-1] == math.inf else dp[-1]\n", "tests": [{"start": 18, "end": 19, "test": "```\ndef test_minStickers():\n    solution = Solution()\n    assert solution.minStickers([\"cat\", \"bat\", \"hat\"], \"abch\") == 3, f\"Expected minStickers(['cat', 'bat', 'hat'], 'abch') to return 3, but got {solution.minStickers(['cat', 'bat', 'hat'], 'abch')}"}, {"start": 24, "end": 26, "test": "```\ndef test_minStickers():\n    solution = Solution()\n    assert solution.minStickers([\"cat\", \"bat\", \"hat\"], \"abch\") == 3\n```"}]}
{"task_num": 722, "task_title": "Remove Comments", "func_name": "removeComments", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def removeComments(self, source: List[str]) -> List[str]:\n    ans = []\n    commenting = False\n    modified = ''\n\n    for line in source:\n      i = 0\n      while i < len(line):\n        if i + 1 == len(line):\n          if not commenting:\n            modified += line[i]\n          i += 1\n          break\n        twoChars = line[i:i + 2]\n        if twoChars == '/*' and not commenting:\n          commenting = True\n          i += 2\n        elif twoChars == '*/' and commenting:\n          commenting = False\n          i += 2\n        elif twoChars == '//':\n          if not commenting:\n            break\n          else:\n            i += 2\n        else:\n          if not commenting:\n            modified += line[i]\n          i += 1\n      if modified and not commenting:\n        ans.append(modified)\n        modified = ''\n\n    return ans\n", "tests": [{"start": 41, "end": 43, "test": "```\ndef test_removeComments():\n    solution=Solution()\n    def test_input():\n        return [\"//\", \"/* This is a comment */\", \"// This is also a comment\", \"This line has no comments\"]\n```"}, {"start": 20, "end": 24, "test": "```\ndef test_removeComments():\n    solution = Solution()\n    source = [\"// This is a comment\", \"int x = 5;\", \"/* This is a block comment */\"]\n    expected_output = [\"int x = 5;\"]\n    assert solution.removeComments(source) == expected_output"}, {"start": 26, "end": 28, "test": "```\ndef test_removeComments():\n    solution=Solution()\n    source=[\"// This is a line comment\"]\n    result=solution.removeComments(source)\n    assert result==[\"\"]"}, {"start": 21, "end": 22, "test": "```\ndef test_removeComments():\n    solution = Solution()\n    assert solution.removeComments([\"// comment\", \"/* this is a block comment */\", \"// another comment\"]) == [\"\"]"}, {"start": 29, "end": 31, "test": "```\ndef test_removeComments():\n    solution=Solution()\n    assert solution.removeComments([\"// comment\", \"/* this is a block comment */\", \"// another line comment\"]) == [\"\"], \n```"}, {"start": 32, "end": 36, "test": "```\ndef test_removeComments():\n    solution = Solution()\n    source = [\"// This is a line comment\", \"/* This is a block comment */\"]\n    expected_output = [\"This is a line comment\"]\n    assert solution.removeComments(source) == expected_output\n```"}, {"start": 37, "end": 40, "test": "```\ndef test_removeComments():\n    solution = Solution()\n    assert solution.removeComments([\"// comment\", \"/* this is a block comment */\", \"// another line comment\"]) == [\"\"]"}, {"start": 33, "end": 34, "test": "```\ndef test_removeComments():\n    solution = Solution()\n    source = [\"// This is a line comment\", \"/* This is a block comment */\", \"This is not commented\"]\n    result = solution.removeComments([source[0], source[1], source[2]])\n    assert result == [\"This is not commented\"]"}, {"start": 35, "end": 36, "test": "```\ndef test_removeComments():\n    solution = Solution()\n    result = solution.removeComments([\"//hello\", \"/*this is a block comment*/\", \"//world\"])\n    assert result == [\"hello\"]"}, {"start": 38, "end": 39, "test": "```\ndef test_removeComments():\n    def removeComments(source):\n        solution = Solution()\n        return solution.removeComments(source)\n    \n    assert removeComments([\"//Hello\", \"world /*\", \"This is a line comment.*/\"]) == [\"world \"]"}]}
{"task_num": 730, "task_title": "Count Different Palindromic Subsequences", "func_name": "countPalindromicSubsequences", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countPalindromicSubsequences(self, s: str) -> int:\n    kMod = 1_000_000_007\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n      dp[i][i] = 1\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        if s[i] == s[j]:\n          lo = i + 1\n          hi = j - 1\n          while lo <= hi and s[lo] != s[i]:\n            lo += 1\n          while lo <= hi and s[hi] != s[i]:\n            hi -= 1\n          if lo > hi:\n            dp[i][j] = dp[i + 1][j - 1] * 2 + 2\n          elif lo == hi:\n            dp[i][j] = dp[i + 1][j - 1] * 2 + 1\n          else:\n            dp[i][j] = dp[i + 1][j - 1] * 2 - dp[lo + 1][hi - 1]\n        else:\n          dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1]\n        dp[i][j] = (dp[i][j] + kMod) % kMod\n\n    return dp[0][n - 1]\n", "tests": [{"start": 23, "end": 35, "test": "def test_countPalindromicSubsequences(): \n    solution = Solution() \n    assert solution.countPalindromicSubsequences(\"aba\") % 1000000007 == 6"}, {"start": 36, "end": 37, "test": "def test_countPalindromicSubsequences(): \n    def solution_test(s: str) -> int: \n        return (solution.countPalindromicSubsequences(\"abaca\") + 1000000007) % 1000000007"}, {"start": 30, "end": 31, "test": "```\ndef test_countPalindromicSubsequences():\n    def solution_test(s: str) -> int:\n        return solution.countPalindromicSubsequences(s)\n    assert solution_test(\"abaca\") == 11\n```"}, {"start": 32, "end": 33, "test": "```\ndef test_countPalindromicSubsequences():\n    def test_case():\n        s = \"aba\"\n        assert solution.countPalindromicSubsequences(s) % 1_000_000_007 == 6\n```"}, {"start": 34, "end": 35, "test": "```\ndef test_countPalindromicSubsequences():\n    def test_case():\n        s = \"aab\"\n        assert (solution.countPalindromicSubsequences(s) % 1_000_000_007 == 4)\n```"}]}
{"task_num": 735, "task_title": "Asteroid Collision", "func_name": "asteroidCollision", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def asteroidCollision(self, asteroids: List[int]) -> List[int]:\n    stack = []\n\n    for a in asteroids:\n      if a > 0:\n        stack.append(a)\n      else:\n        while stack and stack[-1] > 0 and stack[-1] < -a:\n          stack.pop()\n        if not stack or stack[-1] < 0:\n          stack.append(a)\n        elif stack[-1] == -a:\n          stack.pop()\n        else:\n          pass\n\n    return stack\n", "tests": [{"start": 16, "end": 17, "test": "def test_asteroidCollision(): \n    solution = Solution() \n    assert solution.asteroidCollision([5]) == [5]"}, {"start": 18, "end": 26, "test": "```\ndef test_asteroidCollision():\n    def asteroid_collision(asteroids):\n        solution = Solution()\n        return solution.asteroidCollision([1, -1])\n```"}, {"start": 21, "end": 22, "test": "```\ndef test_asteroidCollision():\n    solution = Solution()\n    assert solution.asteroidCollision([-2,1,-3]) == [-3], None\n```"}, {"start": 23, "end": 24, "test": "```\ndef test_asteroidCollision():\n    solution = Solution()\n    assert solution.asteroidCollision([-2, 1, -2]) == [-2], \n```"}, {"start": 25, "end": 26, "test": "```\ndef test_asteroidCollision():\n    def asteroid_collision(asteroids):\n        return solution.asteroidCollision([1, -3, 2])\n```"}]}
{"task_num": 743, "task_title": "Network Delay Time", "func_name": "networkDelayTime", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in times:\n      graph[u - 1].append((v - 1, w))\n\n    return self._dijkstra(graph, k - 1)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int) -> int:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    maxDist = max(dist)\n    return maxDist if maxDist != math.inf else -1\n", "tests": [{"start": 28, "end": 29, "test": "```\ndef test_networkDelayTime():\n    solution = Solution()\n    times = [[2,1,1],[3,2,1],[4,3,1]]\n    n = 4\n    k = 2\n    assert solution.networkDelayTime(times, n, k) == 2"}, {"start": 31, "end": 33, "test": "```\ndef test_networkDelayTime():\n    solution=Solution()\n    times = [[2,1,1],[2,3,1],[3,4,1]]\n    n = 4\n    k = 2\n    assert solution.networkDelayTime(times,n,k) == 2"}]}
{"task_num": 770, "task_title": "Basic Calculator IV", "func_name": "basicCalculatorIV", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Poly:\n  def __init__(self, term: str = None, coef: int = None):\n    if term and coef:\n      self.terms = collections.Counter({term: coef})\n    else:\n      self.terms = collections.Counter()\n\n  def __add__(self, other):\n    for term, coef in other.terms.items():\n      self.terms[term] += coef\n    return self\n\n  def __sub__(self, other):\n    for term, coef in other.terms.items():\n      self.terms[term] -= coef\n    return self\n\n  def __mul__(self, other):\n    res = Poly()\n    for a, aCoef in self.terms.items():\n      for b, bCoef in other.terms.items():\n        res.terms[self._merge(a, b)] += aCoef * bCoef\n    return res\n\n  def toList(self) -> List[str]:\n    for term in list(self.terms.keys()):\n      if not self.terms[term]:\n        del self.terms[term]\n\n    def cmp(term: str) -> tuple:\n      if term == '1':\n        return (0,)\n      var = term.split('*')\n      return (-len(var), term)\n\n    def concat(term: str) -> str:\n      if term == '1':\n        return str(self.terms[term])\n      return str(self.terms[term]) + '*' + term\n\n    terms = list(self.terms.keys())\n    terms.sort(key=cmp)\n    return [concat(term) for term in terms]\n\n  def _merge(self, a: str, b: str) -> str:\n    if a == '1':\n      return b\n    if b == '1':\n      return a\n    res = []\n    A = a.split('*')\n    B = b.split('*')\n    i = 0\n    j = 0\n    while i < len(A) and j < len(B):\n      if A[i] < B[j]:\n        res.append(A[i])\n        i += 1\n      else:\n        res.append(B[j])\n        j += 1\n    return '*'.join(res + A[i:] + B[j:])\n\n\nclass Solution:\n  def basicCalculatorIV(self, expression: str, evalvars: List[str], evalints: List[int]) -> List[str]:\n    tokens = list(self._getTokens(expression))\n    evalMap = {a: b for a, b in zip(evalvars, evalints)}\n\n    for i, token in enumerate(tokens):\n      if token in evalMap:\n        tokens[i] = str(evalMap[token])\n\n    postfix = self._infixToPostfix(tokens)\n    return self._evaluate(postfix).toList()\n\n  def _getTokens(self, s: str) -> Iterator[str]:\n    i = 0\n    for j, c in enumerate(s):\n      if c == ' ':\n        if i < j:\n          yield s[i:j]\n        i = j + 1\n      elif c in '()+-*':\n        if i < j:\n          yield s[i:j]\n        yield c\n        i = j + 1\n    if i < len(s):\n      yield s[i:]\n\n  def _infixToPostfix(self, tokens: List[str]) -> List[str]:\n    postfix = []\n    ops = []\n\n    def precedes(prevOp: str, currOp: str) -> bool:\n      if prevOp == '(':\n        return False\n      return prevOp == '*' or currOp in '+-'\n\n    for token in tokens:\n      if token == '(':\n        ops.append(token)\n      elif token == ')':\n        while ops[-1] != '(':\n          postfix.append(ops.pop())\n        ops.pop()\n      elif token in '+-*':\n        while ops and precedes(ops[-1], token):\n          postfix.append(ops.pop())\n        ops.append(token)\n      else:\n        postfix.append(token)\n    return postfix + ops[::-1]\n\n  def _evaluate(self, postfix: List[str]) -> Poly:\n    polys: List[Poly] = []\n    for token in postfix:\n      if token in '+-*':\n        b = polys.pop()\n        a = polys.pop()\n        if token == '+':\n          polys.append(a + b)\n        elif token == '-':\n          polys.append(a - b)\n        else:\n          polys.append(a * b)\n      elif token.lstrip('-').isnumeric():\n        polys.append(Poly(\"1\", int(token)))\n      else:\n        polys.append(Poly(token, 1))\n    return polys[0]\n", "tests": [{"start": 13, "end": 14, "test": "```\ndef test_basicCalculatorIV():\n    solution=Solution()\n    assert solution.basicCalculatorIV(\"e + 8 - a + 5\", [\"e\"], [1]) == [\"-1*a\",\"14\"]\n```"}, {"start": 15, "end": 16, "test": "```\ndef test_basicCalculatorIV():\n    solution=Solution()\n    assert solution.basicCalculatorIV(\"e + 8 - a + 5\", [\"e\"], [1]) == [\"-1*a\",\"14\"]\n```"}, {"start": 56, "end": 57, "test": "```\ndef test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV(\"e + 8 - a + 5\", [\"e\"], [1]) == [\"-1*a\",\"14\"]\n```"}, {"start": 58, "end": 59, "test": "```\ndef test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV(\"e + 8 - a + 5\", [\"e\"], [1]) == [\"-1*a\",\"14\"]\n```"}, {"start": 99, "end": 100, "test": "```\ndef test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV(\"e + 8 - a + 5\", [\"e\"], [1]) == [\"-1*a\",\"14\"]\n```"}, {"start": 37, "end": 38, "test": "```\ndef test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV(\"e + 8 - a + 5\", [\"e\"], [1]) == [\"-1*a\",\"14\"]\n```"}, {"start": 41, "end": 42, "test": "```\ndef test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV(\"e + 8 - a + 5\", [\"e\"], [1]) == [\"-1*a\",\"14\"]\n```"}, {"start": 47, "end": 48, "test": "```\ndef test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV(\"e + 8 - a + 5\", [\"e\"], [1]) == [\"-1*a\",\"14\"]"}, {"start": 66, "end": 68, "test": "```\ndef test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV(\"e + 8 - a + 5\", [\"e\"], [1]) == [\"-1*a\",\"14\"]\n```"}, {"start": 69, "end": 71, "test": "```\ndef test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV(\"e + 8 - a + 5\", [\"e\"], [1]) == [\"-1*a\",\"14\"]\n```"}, {"start": 81, "end": 82, "test": "```\ndef test_basicCalculatorIV():\n    solution=Solution()\n    expression=\"e + 8 - a + 5\"\n    evalvars=[\"e\"]\n    evalints=[1]\n    expected_output=[\"-1*a\",\"14\"]\n    assert solution.basicCalculatorIV(expression,evalvars,evalints).toList()==expected_output\n```"}, {"start": 90, "end": 93, "test": "```\ndef test_basicCalculatorIV():\n    solution=Solution()\n    assert solution.basicCalculatorIV(\"e + 8 - a + 5\", [\"e\"], [1]) == [\"-1*a\",\"14\"]\n```"}, {"start": 107, "end": 108, "test": "```\ndef test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV(\"e + 8 - a + 5\", [\"e\"], [1]) == [\"-1*a\",\"14\"]\n```"}, {"start": 112, "end": 113, "test": "```\ndef test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV(\"e + 8 - a + 5\", [\"e\"], [1]) == [\"-1*a\",\"14\"]\n```"}, {"start": 129, "end": 137, "test": "```\ndef test_basicCalculatorIV():\n    solution = Solution()\n    expression = \"e + 8 - a + 5\"\n    evalvars = [\"e\", \"a\"]\n    evalints = [1, 2]\n    expected_output = [\"-2*a+7\"]\n    assert solution.basicCalculatorIV(expression, evalvars, evalints).toList() == expected_output\n```"}, {"start": 91, "end": 92, "test": "```\ndef test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV(\"e + 8 - a + 5\", [\"e\"], [1]) == [\"-1*a\",\"14\"]\n```"}, {"start": 94, "end": 98, "test": "```\ndef test_basicCalculatorIV():\n    solution=Solution()\n    assert solution.basicCalculatorIV(\"e + 8 - a + 5\", [\"e\"], [1]) == [\"-1*a\",\"14\"]\n```"}, {"start": 114, "end": 117, "test": "```\ndef test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV(\"e + 8 - a + 5\", [\"e\"], [1]) == [\"-1*a\",\"14\"]\n```"}, {"start": 132, "end": 133, "test": "```\ndef test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV(\"e + 8 - a + 5\", [\"e\"], [1]) == [\"-1*a\",\"14\"]\n```"}, {"start": 138, "end": 139, "test": "```\ndef test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV(\"e + 8 - a + 5\", [\"e\"], [1]) == [\"-1*a\",\"14\"]\n```"}, {"start": 140, "end": 141, "test": "```\ndef test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV(\"e + 8 - a + 5\", [\"e\"], [1]) == [\"-1*a\",\"14\"]\n```"}, {"start": 95, "end": 96, "test": "```\ndef test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV(\"e + 8 - a + 5\", [\"e\"], [1]) == [\"-1*a\",\"14\"]\n```"}, {"start": 118, "end": 121, "test": "```\ndef test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV(\"e + 8 - a + 5\", [\"e\"], [1]) == [\"-1*a\",\"14\"]\n```"}, {"start": 122, "end": 123, "test": "```\ndef test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV(\"e + 8 - a + 5\", [\"e\"], [1]) == [\"-1*a\",\"14\"]\n```"}, {"start": 134, "end": 135, "test": "```\ndef test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV(\"e + 8 - a + 5\", [\"e\"], [1]) == [\"-1*a\",\"14\"]\n```"}, {"start": 136, "end": 137, "test": "```\ndef test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV(\"e + 8 - a + 5\", [\"e\"], [1]) == [\"-1*a\",\"14\"]\n```"}]}
{"task_num": 777, "task_title": "Swap Adjacent in LR String", "func_name": "canTransform", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def canTransform(self, start: str, end: str) -> bool:\n    if start.replace('X', '') != end.replace('X', ''):\n      return False\n\n    i = 0\n    j = 0\n\n    while i < len(start) and j < len(end):\n      while i < len(start) and start[i] == 'X':\n        i += 1\n      while j < len(end) and end[j] == 'X':\n        j += 1\n      if i == len(start) and j == len(end):\n        return True\n      if i == len(start) or j == len(end):\n        return False\n      if start[i] == 'L' and i < j:\n        return False\n      if start[i] == 'R' and i > j:\n        return False\n      i += 1\n      j += 1\n\n    return True\n", "tests": [{"start": 13, "end": 14, "test": "def test_canTransform(): \n    solution = Solution() \n    assert not solution.canTransform(\"L\", \"R\")"}, {"start": 24, "end": 25, "test": "def test_canTransform():    \n    solution = Solution()    \n    assert solution.canTransform(\"X\", \"X\")"}, {"start": 26, "end": 27, "test": "def test_canTransform():    \n    solution = Solution()    \n    assert not solution.canTransform('LRX', 'RXL')"}, {"start": 28, "end": 29, "test": "def test_canTransform():    \n    solution = Solution()    \n    assert not solution.canTransform('LRX', 'RXL')"}, {"start": 30, "end": 31, "test": "def test_canTransform():    \n    solution = Solution()    \n    assert not solution.canTransform('RX', 'LX')"}]}
{"task_num": 782, "task_title": "Transform to Chessboard", "func_name": "movesToChessboard", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def movesToChessboard(self, board: List[List[int]]) -> int:\n    n = len(board)\n\n    for i in range(n):\n      for j in range(n):\n        if board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]:\n          return -1\n\n    rowSum = sum(board[0])\n    colSum = sum(board[i][0] for i in range(n))\n\n    if rowSum != n // 2 and rowSum != (n + 1) // 2:\n      return -1\n    if colSum != n // 2 and colSum != (n + 1) // 2:\n      return -1\n\n    rowSwaps = sum(board[i][0] == (i & 1) for i in range(n))\n    colSwaps = sum(board[0][i] == (i & 1) for i in range(n))\n\n    if n & 1:\n      if rowSwaps & 1:\n        rowSwaps = n - rowSwaps\n      if colSwaps & 1:\n        colSwaps = n - colSwaps\n    else:\n      rowSwaps = min(rowSwaps, n - rowSwaps)\n      colSwaps = min(colSwaps, n - colSwaps)\n\n    return (rowSwaps + colSwaps) // 2\n", "tests": [{"start": 23, "end": 24, "test": "```\ndef test_movesToChessboard():\n    solution = Solution()\n    assert solution.movesToChessboard([[0, 1, 1], [1, 0, 1], [1, 1, 0]]) == -1\n```"}, {"start": 25, "end": 26, "test": "```\ndef test_movesToChessboard():\n    solution = Solution()\n    assert solution.movesToChessboard([[0, 1, 1], [1, 0, 1], [1, 1, 0]]) == -1\n```"}, {"start": 31, "end": 35, "test": "def test_movesToChessboard(): \n    solution=Solution(); \n    assert solution.movesToChessboard([[0, 1], [1, 0]]) == 2"}, {"start": 36, "end": 38, "test": "```\ndef test_movesToChessboard():\n    def solution(board):\n        n = len(board)\n        for i in range(n):\n            for j in range(n):\n                if board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]:\n                    return -1\n        rowSum = sum(board[0])\n        colSum = sum(board[i][0] for i in range(n))\n        if rowSum != n // 2 and rowSum != (n + 1) // 2:\n            return -1\n        if colSum != n // 2 and colSum != (n + 1) // 2:\n            return -1\n        rowSwaps = sum(board[i][0] == (i & 1) for i in range(n))\n        colSwaps = sum(board[0][i] == (i & 1) for i in range(n))\n        if n & 1:\n            if rowSwaps & 1:\n                rowSwaps = n - rowSwaps\n            if colSwaps & 1:\n                colSwaps = n - colSwaps\n        else:\n            rowSwaps = min(rowSwaps, n - rowSwaps)\n            colSwaps = min(colSwaps, n - colSwaps)\n        return (rowSwaps + colSwaps) // 2\n\n    assert solution([[0,1],[1,0]]) == 2"}, {"start": 32, "end": 33, "test": "```\ndef test_movesToChessboard():\n    solution=Solution()\n    assert solution.movesToChessboard([[0, 1, 0, 1], [1, 1, 1, 1], [0, 1, 0, 1], [1, 1, 1, 1]]) == 2\n```"}, {"start": 34, "end": 35, "test": "```\ndef test_movesToChessboard():\n    solution=Solution()\n    assert solution.movesToChessboard([[0, 1], [1, 0]]) == 2\n```"}, {"start": 17, "end": 18, "test": "```\ndef test_movesToChessboard():\n    solution = Solution()\n    assert solution.movesToChessboard([[0, 1], [1, 0]]) == -1\n```"}]}
{"task_num": 786, "task_title": "K-th Smallest Prime Fraction", "func_name": "kthSmallestPrimeFraction", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\n    n = len(arr)\n    ans = [0, 1]\n    l = 0\n    r = 1\n\n    while True:\n      m = (l + r) / 2\n      ans[0] = 0\n      count = 0\n      j = 1\n\n      for i in range(n):\n        while j < n and arr[i] > m * arr[j]:\n          j += 1\n        count += n - j\n        if j == n:\n          break\n        if ans[0] * arr[j] < ans[1] * arr[i]:\n          ans[0] = arr[i]\n          ans[1] = arr[j]\n\n      if count < k:\n        l = m\n      elif count > k:\n        r = m\n      else:\n        return ans\n", "tests": [{"start": 34, "end": 35, "test": "```\ndef test_kthSmallestPrimeFraction():\n    def test_case():\n        arr = [1, 2, 3, 5, 7]\n        k = 4\n        return solution.kthSmallestPrimeFraction(arr, k) == [1, 3]\n\n    assert test_case() is True"}, {"start": 28, "end": 29, "test": "```\ndef test_kthSmallestPrimeFraction():\n    def kthSmallestPrimeFraction(arr: List[int], k: int) -> List[int]:\n        return [1, 2]\n```"}, {"start": 30, "end": 32, "test": "```\ndef test_kthSmallestPrimeFraction():\n    def kthSmallestPrimeFraction(arr: List[int], k: int) -> List[int]:\n        return [2, 3]\n```"}, {"start": 36, "end": 37, "test": "```\ndef test_kthSmallestPrimeFraction():\n    def test_case():\n        arr = [1, 2, 3, 5, 7]\n        k = 4\n        return solution.kthSmallestPrimeFraction(arr, k) == [1, 3]\n\n    assert test_case() is True"}, {"start": 38, "end": 39, "test": "```\ndef test_kthSmallestPrimeFraction():\n    def kthSmallestPrimeFraction(arr: List[int], k: int) -> List[int]:\n        solution = Solution()\n        return solution.kthSmallestPrimeFraction([1, 2, 3, 5, 7, 11, 13, 17, 19], 4)\n```"}]}
{"task_num": 787, "task_title": "Cheapest Flights Within K Stops", "func_name": "findCheapestPrice", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in flights:\n      graph[u].append((v, w))\n\n    return self._dijkstra(graph, src, dst, k)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, k: int) -> int:\n    dist=[]\n    for i in range(len(graph)):\n      dist.append([math.inf for _ in range(k + 2)])\n\n    dist[src][k + 1] = 0\n    minHeap = [(dist[src][k + 1], src, k + 1)]\n\n    while minHeap:\n      d, u, stops = heapq.heappop(minHeap)\n      if u == dst:\n        return d\n      if stops == 0 or d > dist[u][stops]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v][stops - 1]:\n          dist[v][stops - 1] = d + w\n          heapq.heappush(minHeap, (dist[v][stops - 1], v, stops - 1))\n\n    return -1\n", "tests": [{"start": 30, "end": 31, "test": "```\ndef test_findCheapestPrice():\n    solution=Solution()\n    assert solution.findCheapestPrice(3, [[0,1,100],[1,2,500]], 0, 2, 1) == 200\n```"}, {"start": 32, "end": 33, "test": "```\ndef test_findCheapestPrice():\n    solution=Solution()\n    assert solution.findCheapestPrice(3, [[0,1,100],[1,2,500]], 0, 2, 1) == 200\n```"}, {"start": 35, "end": 37, "test": "def test_findCheapestPrice(): \n    solution=Solution() \n    assert solution.findCheapestPrice(3, [[0,1,100],[1,2,500],[0,2,200]], 0, 2, 1) == 200"}]}
{"task_num": 794, "task_title": "Valid Tic-Tac-Toe State", "func_name": "validTicTacToe", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def validTicTacToe(self, board: List[str]) -> bool:\n    def isWin(c: str) -> bool:\n      return any(row.count(c) == 3 for row in board) or any(row.count(c) == 3 for row in list(zip(*board))) or all(board[i][i] == c for i in range(3)) or all(board[i][2 - i] == c for i in range(3))\n\n    countX = sum(row.count('X') for row in board)\n    countO = sum(row.count('O') for row in board)\n\n    if countX < countO or countX - countO > 1:\n      return False\n    if isWin('X') and countX == countO or isWin('O') and countX != countO:\n      return False\n\n    return True\n", "tests": [{"start": 19, "end": 20, "test": "```\ndef test_validTicTacToe():\n    solution = Solution()\n    assert not solution.validTicTacToe([['X', 'O', ' '], [' ', 'O', 'X'], [' ', ' ', ' ']])\n```"}, {"start": 21, "end": 22, "test": "```\ndef test_validTicTacToe():\n    def solution(board: List[str]) -> bool:\n        return board == [\n            \"X O X\",\n            \"O X O\",\n            \"  X O\"\n        ]\n```"}]}
{"task_num": 805, "task_title": "Split Array With Same Average", "func_name": "splitArraySameAverage", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def splitArraySameAverage(self, nums: List[int]) -> bool:\n    n = len(nums)\n    summ = sum(nums)\n    if not any(i * summ % n == 0 for i in range(1, n // 2 + 1)):\n      return False\n\n    sums = [set() for _ in range(n // 2 + 1)]\n    sums[0].add(0)\n\n    for num in nums:\n      for i in range(n // 2, 0, -1):\n        for val in sums[i - 1]:\n          sums[i].add(num + val)\n\n    for i in range(1, n // 2 + 1):\n      if i * summ % n == 0 and i * summ // n in sums[i]:\n        return True\n\n    return False\n", "tests": [{"start": 15, "end": 16, "test": "```\ndef test_splitArraySameAverage():\n    solution = Solution()\n    assert not solution.splitArraySameAverage([5]), None"}, {"start": 27, "end": 28, "test": "```\ndef test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([1, 2, 3, 4, 5]) == True\n```"}]}
{"task_num": 815, "task_title": "Bus Routes", "func_name": "numBusesToDestination", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:\n    if source == target:\n      return 0\n\n    graph = collections.defaultdict(list)\n    usedBuses = set()\n\n    for i in range(len(routes)):\n      for route in routes[i]:\n        graph[route].append(i)\n\n    ans = 0\n    q = collections.deque([source])\n\n    while q:\n      ans += 1\n      for _ in range(len(q)):\n        for bus in graph[q.popleft()]:\n          if bus in usedBuses:\n            continue\n          usedBuses.add(bus)\n          for nextRoute in routes[bus]:\n            if nextRoute == target:\n              return ans\n            q.append(nextRoute)\n\n    return -1\n", "tests": [{"start": 13, "end": 14, "test": "```\ndef test_numBusesToDestination():\n    solution = Solution()\n    assert solution.numBusesToDestination([[1,2,3],[4,5,6]], 0, 0) == 0\n```"}, {"start": 30, "end": 31, "test": "```\ndef test_numBusesToDestination():\n    solution = Solution()\n    assert solution.numBusesToDestination([[1, 2, 3], [4, 5, 6]], 0, 5) == 2\n```"}, {"start": 34, "end": 35, "test": "```\ndef test_numBusesToDestination():\n    solution = Solution()\n    assert solution.numBusesToDestination([[1, 2, 3], [4, 5, 6]], 0, 5) == 2\n```"}]}
{"task_num": 838, "task_title": "Push Dominoes", "func_name": "pushDominoes", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def pushDominoes(self, dominoes: str) -> str:\n    ans = list(dominoes)\n    L = -1\n    R = -1\n\n    for i in range(len(dominoes) + 1):\n      if i == len(dominoes) or dominoes[i] == 'R':\n        if L < R:\n          while R < i:\n            ans[R] = 'R'\n            R += 1\n        R = i\n      elif dominoes[i] == 'L':\n        if R < L or (L, R) == (-1, -1):\n          if (L, R) == (-1, -1):\n            L += 1\n          while L < i:\n            ans[L] = 'L'\n            L += 1\n        else:\n          l = R + 1\n          r = i - 1\n          while l < r:\n            ans[l] = 'R'\n            ans[r] = 'L'\n            l += 1\n            r -= 1\n        L = i\n\n    return ''.join(ans)\n", "tests": [{"start": 18, "end": 23, "test": "def test_pushDominoes(): \n    solution=Solution() \n    assert ''.join(solution.pushDominoes('L.R...R')) == 'RR.L...',"}, {"start": 19, "end": 22, "test": "def test_pushDominoes(): \n    solution=Solution() \n    assert solution.pushDominoes('L.R...LR') == 'RR.LL', None"}, {"start": 24, "end": 39, "test": "def test_pushDominoes(): \n    solution=Solution() \n    assert solution.pushDominoes('L.R...R') == 'LL.RRR', None"}, {"start": 25, "end": 30, "test": "def test_pushDominoes(): \n    solution=Solution() \n    assert solution.pushDominoes('LL.RR') == 'LLLLRRRR'"}, {"start": 31, "end": 38, "test": "def test_pushDominoes(): \n    solution=Solution() \n    assert ''.join(solution.pushDominoes('L.R...R')) == 'RR.LL', None"}, {"start": 26, "end": 27, "test": "def test_pushDominoes():    \n    solution = Solution()    \n    assert solution.pushDominoes('L.R...R') == 'RR.LL', None"}]}
{"task_num": 845, "task_title": "Longest Mountain in Array", "func_name": "longestMountain", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def longestMountain(self, arr: List[int]) -> int:\n    ans = 0\n    i = 0\n\n    while i + 1 < len(arr):\n      while i + 1 < len(arr) and arr[i] == arr[i + 1]:\n        i += 1\n\n      increasing = 0\n      decreasing = 0\n\n      while i + 1 < len(arr) and arr[i] < arr[i + 1]:\n        increasing += 1\n        i += 1\n\n      while i + 1 < len(arr) and arr[i] > arr[i + 1]:\n        decreasing += 1\n        i += 1\n\n      if increasing > 0 and decreasing > 0:\n        ans = max(ans, increasing + decreasing + 1)\n\n    return ans\n", "tests": [{"start": 31, "end": 32, "test": "```\ndef test_longestMountain():\n    def assertEqual(actual, expected):\n        if actual != expected:\n            raise AssertionError(f\"Expected {expected}, but got {actual}\")\n    \n    solution = Solution()\n    arr = [2,3,5,4,7]\n    assertEqual(solution.longestMountain(arr), 3)"}]}
{"task_num": 854, "task_title": "K-Similar Strings", "func_name": "kSimilarity", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def kSimilarity(self, s1: str, s2: str) -> int:\n    ans = 0\n    q = collections.deque([s1])\n    seen = {s1}\n\n    while q:\n      for _ in range(len(q)):\n        curr = q.popleft()\n        if curr == s2:\n          return ans\n        for child in self._getChildren(curr, s2):\n          if child in seen:\n            continue\n          q.append(child)\n          seen.add(child)\n      ans += 1\n\n    return -1\n\n  def _getChildren(self, curr: str, target: str) -> List[str]:\n    children = []\n    s = list(curr)\n    i = 0\n    while curr[i] == target[i]:\n      i += 1\n\n    for j in range(i + 1, len(s)):\n      if s[j] == target[i]:\n        s[i], s[j] = s[j], s[i]\n        children.append(''.join(s))\n        s[i], s[j] = s[j], s[i]\n\n    return children\n", "tests": [{"start": 39, "end": 42, "test": "```\ndef test_kSimilarity():\n    solution=Solution()\n    assert solution.kSimilarity(\"abac\", \"cab\") == 2\n```"}, {"start": 20, "end": 21, "test": "```\ndef test_kSimilarity():\n    solution = Solution()\n    assert solution.kSimilarity(\"abc\", \"cab\") == 1\n```"}, {"start": 23, "end": 24, "test": "```\ndef test_kSimilarity():\n    solution = Solution()\n    assert solution.kSimilarity(\"abc\", \"cab\") == 1\n```"}]}
{"task_num": 861, "task_title": "Score After Flipping Matrix", "func_name": "matrixScore", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def matrixScore(self, grid: List[List[int]]) -> int:\n    for row in grid:\n      if row[0] == 0:\n        self._flip(row)\n\n    for j, col in enumerate(list(zip(*grid))):\n      if sum(col) * 2 < len(grid):\n        self._flipCol(grid, j)\n\n    return sum(self._binary(row) for row in grid)\n\n  def _flip(self, row: List[int]) -> None:\n    for i in range(len(row)):\n      row[i] ^= 1\n\n  def _flipCol(self, grid: List[List[int]], j: int) -> None:\n    for i in range(len(grid)):\n      grid[i][j] ^= 1\n\n  def _binary(self, row: List[int]) -> int:\n    res = row[0]\n    for j in range(1, len(row)):\n      res = res * 2 + row[j]\n    return res\n", "tests": [{"start": 14, "end": 15, "test": "```\ndef test_matrixScore():\n    solution = Solution()\n    grid = [[1,0,1],[0,0,1],[1,1,1]]\n    assert solution.matrixScore(grid) == 8\n```"}, {"start": 18, "end": 19, "test": "```\ndef test_matrixScore():\n    solution = Solution()\n    grid = [[0,1,1],[1,1,1],[1,0,0]]\n    assert solution.matrixScore(grid) == 8\n```"}]}
{"task_num": 866, "task_title": "Prime Palindrome", "func_name": "primePalindrome", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def primePalindrome(self, n: int) -> int:\n    def getPalindromes(n: int):\n      length = n // 2\n      for i in range(10**(length - 1), 10**length):\n        s = str(i)\n        for j in range(10):\n          yield int(s + str(j) + s[::-1])\n\n    def isPrime(num: int) -> bool:\n      for i in range(2, int(num**0.5 + 1)):\n        if num % i == 0:\n          return False\n      return True\n\n    if n <= 2:\n      return 2\n    if n == 3:\n      return 3\n    if n <= 5:\n      return 5\n    if n <= 7:\n      return 7\n    if n <= 11:\n      return 11\n\n    nLength = len(str(n))\n\n    while True:\n      for num in getPalindromes(nLength):\n        if num >= n and isPrime(num):\n          return num\n      nLength += 1\n", "tests": [{"start": 26, "end": 27, "test": "```\ndef test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(1) == 2, \"Test failed\"\n```"}, {"start": 28, "end": 29, "test": "```\ndef test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(3) == 3, \"Test failed for input 3\"\n```"}, {"start": 30, "end": 31, "test": "```\ndef test_primePalindrome():\n    def assertEqual(expected, actual):\n        if expected != actual:\n            raise AssertionError(f\"Expected {expected}, but got {actual}\")\n    \n    solution = Solution()\n    assertEqual(5, solution.primePalindrome(5))\n```"}, {"start": 32, "end": 33, "test": "```\ndef test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(6) == 7, \"Expected prime palindrome 7 for input 6\"\n```"}, {"start": 34, "end": 35, "test": "```\ndef test_primePalindrome():\n    def test_case():\n        assert solution.primePalindrome(11) == 11, \"Test case failed\"\n    test_case()"}, {"start": 22, "end": 23, "test": "```\ndef test_primePalindrome():\n    def test_case():\n        assert solution.primePalindrome(2) == 2\n    test_case()"}, {"start": 41, "end": 42, "test": "```\ndef test_primePalindrome():\n    def test_case():\n        assert solution.primePalindrome(2) == 2\n```"}]}
{"task_num": 882, "task_title": "Reachable Nodes In Subdivided Graph", "func_name": "reachableNodes", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def reachableNodes(self, edges: List[List[int]], maxMoves: int, n: int) -> int:\n    graph = [[] for _ in range(n)]\n    dist = [maxMoves + 1] * n\n\n    for u, v, cnt in edges:\n      graph[u].append((v, cnt))\n      graph[v].append((u, cnt))\n\n    reachableNodes = self._dijkstra(graph, 0, maxMoves, dist)\n    reachableSubnodes = 0\n\n    for u, v, cnt in edges:\n      a = 0 if dist[u] > maxMoves else min(maxMoves - dist[u], cnt)\n      b = 0 if dist[v] > maxMoves else min(maxMoves - dist[v], cnt)\n      reachableSubnodes += min(a + b, cnt)\n\n    return reachableNodes + reachableSubnodes\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, maxMoves: int, dist: List[int]) -> int:\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if dist[u] >= maxMoves:\n        break\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        newDist = d + w + 1\n        if newDist < dist[v]:\n          dist[v] = newDist\n          heapq.heappush(minHeap, (newDist, v))\n\n    return sum(d <= maxMoves for d in dist)\n", "tests": [{"start": 36, "end": 37, "test": "```\ndef test_reachableNodes():\n    solution = Solution()\n    assert solution.reachableNodes([[0, 1, 2], [1, 2, 3]], 4, 3) == 5\n```"}, {"start": 38, "end": 39, "test": "```\ndef test_reachableNodes():\n    solution = Solution()\n    assert solution.reachableNodes([[0, 1, 2], [1, 2, 3]], 4, 3) == 5\n```"}, {"start": 42, "end": 44, "test": "```\ndef test_reachableNodes():\n    solution=Solution()\n    edges = [[0,1,2],[1,2,3]]\n    maxMoves = 4\n    n = 3\n    assert solution.reachableNodes(edges, maxMoves, n) == 5\n```"}]}
{"task_num": 909, "task_title": "Snakes and Ladders", "func_name": "snakesAndLadders", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def snakesAndLadders(self, board: List[List[int]]) -> int:\n    n = len(board)\n    ans = 0\n    q = collections.deque([1])\n    seen = set()\n    A = [0] * (1 + n * n)\n\n    for i in range(n):\n      for j in range(n):\n        if n - i & 1 :\n          A[(n - 1 - i) * n + (j + 1)] = board[i][j]\n        else:\n          A[(n - 1 - i) * n + (n - j)] = board[i][j]\n\n    while q:\n      ans += 1\n      for _ in range(len(q)):\n        curr = q.popleft()\n        for next in range(curr + 1, min(curr + 6, n * n) + 1):\n          dest = A[next] if A[next] > 0 else next\n          if dest == n * n:\n            return ans\n          if dest in seen:\n            continue\n          q.append(dest)\n          seen.add(dest)\n\n    return -1\n", "tests": [{"start": 21, "end": 22, "test": "```\ndef test_snakesAndLadders():\n    solution=Solution()\n    assert solution.snakesAndLadders([[0,3,-1],[4,2,1]]) == 5\n```"}, {"start": 23, "end": 24, "test": "```\ndef test_snakesAndLadders():\n    solution=Solution()\n    assert solution.snakesAndLadders([[1,4],[-1,3]]) == 2\n```"}, {"start": 32, "end": 33, "test": "```\ndef test_snakesAndLadders():\n    def snakes_and_ladders(board):\n        solution = Solution()\n        assert solution.snakesAndLadders(board) == 5, f\"Expected snakesAndLadders({board}) to return 5, but got {solution.snakesAndLadders(board)}\"\n```"}, {"start": 34, "end": 35, "test": "```\ndef test_snakesAndLadders():\n    def snakes_and_ladders(board):\n        pass\n    solution = Solution()\n    assert snakes_and_ladders([[1, 4], [-1, 3]]) == 2, f\"Expected snakes_and_ladders([[1, 4], [-1, 3]]) to return 2, but got {snakes_and_ladders([[1, 4], [-1, 3]])}\"\n```"}]}
{"task_num": 913, "task_title": "Cat and Mouse", "func_name": "catMouseGame", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import IntEnum\n\n\nclass State(IntEnum):\n  kDraw = 0\n  kMouseWin = 1\n  kCatWin = 2\n\n\nclass Solution:\n  def catMouseGame(self, graph: List[List[int]]) -> int:\n    n = len(graph)\n    states = [[[0] * 2 for i in range(n)] for j in range(n)]\n    outDegree = [[[0] * 2 for i in range(n)] for j in range(n)]\n    q = collections.deque()\n\n    for cat in range(n):\n      for mouse in range(n):\n        outDegree[cat][mouse][0] = len(graph[mouse])\n        outDegree[cat][mouse][1] = len(graph[cat]) - graph[cat].count(0)\n\n    for cat in range(1, n):\n      for move in range(2):\n        states[cat][0][move] = int(State.kMouseWin)\n        q.append((cat, 0, move, int(State.kMouseWin)))\n        states[cat][cat][move] = int(State.kCatWin)\n        q.append((cat, cat, move, int(State.kCatWin)))\n\n    while q:\n      cat, mouse, move, state = q.popleft()\n      if cat == 2 and mouse == 1 and move == 0:\n        return state\n      prevMove = move ^ 1\n      for prev in graph[cat if prevMove else mouse]:\n        prevCat = prev if prevMove else cat\n        if prevCat == 0:\n          continue\n        prevMouse = mouse if prevMove else prev\n        if states[prevCat][prevMouse][prevMove]:\n          continue\n        if prevMove == 0 and state == int(State.kMouseWin) or \\\n                prevMove == 1 and state == int(State.kCatWin):\n          states[prevCat][prevMouse][prevMove] = state\n          q.append((prevCat, prevMouse, prevMove, state))\n        else:\n          outDegree[prevCat][prevMouse][prevMove] -= 1\n          if outDegree[prevCat][prevMouse][prevMove] == 0:\n            states[prevCat][prevMouse][prevMove] = state\n            q.append((prevCat, prevMouse, prevMove, state))\n\n    return states[2][1][0]\n", "tests": [{"start": 41, "end": 42, "test": "```\ndef test_catMouseGame():\n    def test_case():\n        graph = [[1, 2], [0, 3], [4], [5]]\n        assert catMouseGame(graph) == 0\n```"}, {"start": 46, "end": 47, "test": "```\ndef test_catMouseGame():\n    graph = [[1,2],[0,3]]\n    assert catMouseGame(graph) == 0\n```"}, {"start": 49, "end": 50, "test": "```\ndef test_catMouseGame():\n    def cat_mouse_game(graph):\n        return 0\n    assert cat_mouse_game([[1,2],[0,3]]) == 0\n```"}, {"start": 51, "end": 54, "test": "```\ndef test_catMouseGame():\n    solution=Solution()\n    assert solution.catMouseGame([[1, 2], [0, 3]]) == 0\n```"}, {"start": 55, "end": 59, "test": "```\ndef test_catMouseGame():\n    solution=Solution()\n    assert solution.catMouseGame([[1, 2], [0, 3]]) == 0\n```"}, {"start": 57, "end": 59, "test": "```\ndef test_catMouseGame():\n    solution=Solution()\n    assert solution.catMouseGame([[1, 2], [0, 3], [4], [5]]) == 0\n```"}]}
{"task_num": 923, "task_title": "3Sum With Multiplicity", "func_name": "threeSumMulti", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def threeSumMulti(self, arr: List[int], target: int) -> int:\n    kMod = 1_000_000_007\n    ans = 0\n    count = collections.Counter(arr)\n\n    for i, x in count.items():\n      for j, y in count.items():\n        k = target - i - j\n        if k not in count:\n          continue\n        if i == j and j == k:\n          ans = (ans + x * (x - 1) * (x - 2) // 6) % kMod\n        elif i == j and j != k:\n          ans = (ans + x * (x - 1) // 2 * count[k]) % kMod\n        elif i < j and j < k:\n          ans = (ans + x * y * count[k]) % kMod\n\n    return ans % kMod\n", "tests": [{"start": 20, "end": 21, "test": "```\ndef test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([1, 2, 3], 6) % 1000000007 == 8\n```"}, {"start": 22, "end": 23, "test": "```\ndef test_threeSumMulti():\n    solution=Solution()\n    assert solution.threeSumMulti([1,1,2,3,4], 5) == 8\n```"}, {"start": 24, "end": 25, "test": "```\ndef test_threeSumMulti():\n    solution=Solution()\n    assert solution.threeSumMulti([1,1,2,2,3,3,4,4,5,5], 10) == 6\n```"}, {"start": 26, "end": 27, "test": "```\ndef test_threeSumMulti():\n    solution=Solution()\n    assert solution.threeSumMulti([1, 2, 3, 4], 10) == 8\n```"}]}
{"task_num": 927, "task_title": "Three Equal Parts", "func_name": "threeEqualParts", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def threeEqualParts(self, arr: List[int]) -> List[int]:\n    ones = sum(a == 1 for a in arr)\n\n    if ones == 0:\n      return [0, len(arr) - 1]\n    if ones % 3 != 0:\n      return [-1, -1]\n\n    k = ones // 3\n    i = 0\n\n    for i in range(len(arr)):\n      if arr[i] == 1:\n        first = i\n        break\n\n    gapOnes = k\n\n    for j in range(i + 1, len(arr)):\n      if arr[j] == 1:\n        gapOnes -= 1\n        if gapOnes == 0:\n          second = j\n          break\n\n    gapOnes = k\n\n    for i in range(j + 1, len(arr)):\n      if arr[i] == 1:\n        gapOnes -= 1\n        if gapOnes == 0:\n          third = i\n          break\n\n    while third < len(arr) and arr[first] == arr[second] == arr[third]:\n      first += 1\n      second += 1\n      third += 1\n\n    if third == len(arr):\n      return [first - 1, second]\n    return [-1, -1]\n", "tests": [{"start": 15, "end": 16, "test": "def test_threeEqualParts():    \n    solution = Solution()    \n    assert solution.threeEqualParts([0]) == [0, 0], f\"Expected solution.threeEqualParts([0]) to return [0, 0] but got {solution.threeEqualParts([0])}\""}, {"start": 17, "end": 18, "test": "```\ndef test_threeEqualParts():\n    solution = Solution()\n    assert solution.threeEqualParts([0, 1, 1, 0, 1]) == [-1, -1], f\"Expected [-1, -1] but got {solution.threeEqualParts([0, 1, 1, 0, 1])}\"\n```"}, {"start": 51, "end": 52, "test": "```\ndef test_threeEqualParts():\n    solution = Solution()\n    assert solution.threeEqualParts([0,1,1,1,1,0,1]) == [2, 5]\n```"}, {"start": 24, "end": 26, "test": "def test_threeEqualParts():    \n    solution=Solution()    \n    arr=[0,0,1,1,1]    \n    assert solution.threeEqualParts(arr) == [2,4], None"}, {"start": 31, "end": 35, "test": "```\ndef test_threeEqualParts():\n    arr = [1,0,1,1,1]\n    result = solution.threeEqualParts(arr)\n```"}, {"start": 40, "end": 44, "test": "```\ndef test_threeEqualParts():\n    arr = [1,0,1,0,1]\n    result = solution.threeEqualParts(arr)\n```"}, {"start": 33, "end": 35, "test": "```\ndef test_threeEqualParts():\n    solution=Solution()\n    assert solution.threeEqualParts([1,0,1,1,1,0,0,1]) == [2, 5]\n```"}, {"start": 42, "end": 44, "test": "```\ndef test_threeEqualParts():\n    solution=Solution()\n    assert solution.threeEqualParts([1,0,1,1,1,0,1]) == [2, 5]\n```"}]}
{"task_num": 935, "task_title": "Knight Dialer", "func_name": "knightDialer", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def knightDialer(self, n: int) -> int:\n    dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n    kMod = 1_000_000_007\n\n    dp = [[1] * 3 for _ in range(4)]\n    dp[3][0] = dp[3][2] = 0\n\n    for _ in range(n - 1):\n      newDp = [[0] * 3 for _ in range(4)]\n      for i in range(4):\n        for j in range(3):\n          if (i, j) in ((3, 0), (3, 2)):\n            continue\n          for dx, dy in dirs:\n            x = i + dx\n            y = j + dy\n            if x < 0 or x >= 4 or y < 0 or y >= 3:\n              continue\n            if (x, y) in ((3, 0), (3, 2)):\n              continue\n            newDp[x][y] = (newDp[x][y] + dp[i][j]) % kMod\n      dp = newDp\n\n    return sum(map(sum, dp)) % kMod\n", "tests": [{"start": 23, "end": 24, "test": "def test_knightDialer():    \n    def knightDialer(n: int) -> int:\n        dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n        kMod = 1_000_000_007\n        dp = [[1] * 3 for _ in range(4)]\n        dp[3][0] = dp[3][2] = 0\n        return sum(map(sum, dp)) % kMod\n    solution=Solution()\n    assert knightDialer(1) == 9"}, {"start": 28, "end": 29, "test": "def test_knightDialer(): \n    solution = Solution() \n    assert solution.knightDialer(1) == 4, solution.knightDialer(1)"}, {"start": 30, "end": 31, "test": "def test_knightDialer():    \n    def knightDialer(n: int) -> int:\n        dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n        kMod = 1_000_000_007\n        dp = [[1] * 3 for _ in range(4)]\n        dp[3][0] = dp[3][2] = 0\n        return sum(map(sum, dp)) % kMod"}]}
{"task_num": 939, "task_title": "Minimum Area Rectangle", "func_name": "minAreaRect", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minAreaRect(self, points: List[List[int]]) -> int:\n    ans = math.inf\n    xToYs = collections.defaultdict(set)\n\n    for x, y in points:\n      xToYs[x].add(y)\n\n    for i in range(len(points)):\n      for j in range(i):\n        x1, y1 = points[i]\n        x2, y2 = points[j]\n        if x1 == x2 or y1 == y2:\n          continue\n        if y2 in xToYs[x1] and y1 in xToYs[x2]:\n          ans = min(ans, abs(x1 - x2) * abs(y1 - y2))\n\n    return ans if ans < math.inf else 0\n", "tests": [{"start": 23, "end": 24, "test": "```\ndef test_minAreaRect():\n    solution = Solution()\n    assert solution.minAreaRect([[0, 1], [1, 3], [3, 1], [1, 2]]) == 4\n```"}, {"start": 25, "end": 26, "test": "```\ndef test_minAreaRect():\n    solution=Solution()\n    points = [[0,1],[1,3],[3,1],[1,1],[2,2]]\n    assert solution.minAreaRect(points) == 4\n```"}]}
{"task_num": 952, "task_title": "Largest Component Size by Common Factor", "func_name": "largestComponentSize", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def largestComponentSize(self, nums: List[int]) -> int:\n    ans = 0\n    uf = UnionFind(max(nums) + 1)\n    count = collections.Counter()\n\n    for num in nums:\n      for x in range(2, int(math.sqrt(num) + 1)):\n        if num % x == 0:\n          uf.unionByRank(num, x)\n          uf.unionByRank(num, num // x)\n\n    for num in nums:\n      numRoot = uf.find(num)\n      count[numRoot] += 1\n      ans = max(ans, count[numRoot])\n\n    return ans\n", "tests": [{"start": 19, "end": 20, "test": "```\ndef test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([2, 3]) == 1\n```"}, {"start": 21, "end": 22, "test": "```\ndef test_largestComponentSize():\n    solution=Solution()\n    assert solution.largestComponentSize([4,13,16]) == 4\n```"}, {"start": 30, "end": 31, "test": "def test_largestComponentSize():    \n    solution=Solution()    \n    nums=[4,8,15,3,9]    \n    assert solution.largestComponentSize(nums)==2"}, {"start": 23, "end": 24, "test": "```\ndef test_largestComponentSize():\n    solution=Solution()\n    assert solution.largestComponentSize([2, 3, 6, 9]) == 4\n```"}, {"start": 25, "end": 27, "test": "```\ndef test_largestComponentSize():\n    solution=Solution()\n    assert solution.largestComponentSize([4,13,16]) == 4\n```"}, {"start": 43, "end": 45, "test": "```\ndef test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([4, 8, 15, 3, 9]) == 4\n```"}]}
{"task_num": 963, "task_title": "Minimum Area Rectangle II", "func_name": "minAreaFreeRect", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\nfrom math import sqrt\n\nclass Solution:\n  def minAreaFreeRect(self, points: List[List[int]]) -> float:\n    ans = math.inf\n    centerToPoints = collections.defaultdict(list)\n\n    for ax, ay in points:\n      for bx, by in points:\n        center = ((ax + bx) / 2, (ay + by) / 2)\n        centerToPoints[center].append((ax, ay, bx, by))\n\n    def dist(px: int, py: int, qx: int, qy: int) -> float:\n      return (px - qx)**2 + (py - qy)**2\n\n    for points in centerToPoints.values():\n      for ax, ay, _, _ in points:\n        for cx, cy, dx, dy in points:\n          if (cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0:\n            squaredArea = dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy)\n            if squaredArea > 0:\n              ans = min(ans, squaredArea)\n\n    return 0 if ans == math.inf else sqrt(ans)\n", "tests": [{"start": 28, "end": 31, "test": "```\ndef test_minAreaFreeRect():\n    solution=Solution()\n    assert round(solution.minAreaFreeRect([[0,0],[1,1]]),5) == 1.0\n```"}, {"start": 30, "end": 31, "test": "```\ndef test_minAreaFreeRect():\n    solution=Solution()\n    points = [[1,2],[3,4],[5,6]]\n    assert round(solution.minAreaFreeRect(points), 5) == 0.0\n```"}]}
{"task_num": 990, "task_title": "Satisfiability of Equality Equations", "func_name": "equationsPossible", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n\n  def union(self, u: int, v: int) -> None:\n    self.id[self.find(u)] = self.find(v)\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def equationsPossible(self, equations: List[str]) -> bool:\n    uf = UnionFind(26)\n\n    for x, op, _, y in equations:\n      if op == '=':\n        uf.union(ord(x) - ord('a'), ord(y) - ord('a'))\n\n    for x, op, _, y in equations:\n      if op == '!':\n        if uf.find(ord(x) - ord('a')) == uf.find(ord(y) - ord('a')):\n          return False\n    return True\n", "tests": [{"start": 19, "end": 20, "test": "```\ndef test_equationsPossible():\n    solution=Solution()\n    assert not solution.equationsPossible([\"a!=b\", \"b==c\"])"}, {"start": 29, "end": 30, "test": "```\ndef test_equationsPossible():\n    solution = Solution()\n    assert not solution.equationsPossible([\"a==b\", \"b!=c\"])"}, {"start": 33, "end": 35, "test": "```\ndef test_equationsPossible():\n    solution = Solution()\n    assert not solution.equationsPossible([\"a!=b\", \"b==c\"])"}, {"start": 34, "end": 35, "test": "```\ndef test_equationsPossible():\n    solution = Solution()\n    assert not solution.equationsPossible([\"a!=b\", \"b==c\"])"}]}
{"task_num": 999, "task_title": "Available Captures for Rook", "func_name": "numRookCaptures", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numRookCaptures(self, board: List[List[str]]) -> int:\n    ans = 0\n\n    for i in range(8):\n      for j in range(8):\n        if board[i][j] == 'R':\n          i0 = i\n          j0 = j\n\n    for d in [[1, 0], [0, 1], [-1, 0], [0, -1]]:\n      i = i0 + d[0]\n      j = j0 + d[1]\n      while 0 <= i < 8 and 0 <= j < 8:\n        if board[i][j] == 'p':\n          ans += 1\n        if board[i][j] != '.':\n          break\n        i += d[0]\n        j += d[1]\n\n    return ans\n", "tests": [{"start": 17, "end": 19, "test": "def test_numRookCaptures(): \n    solution=Solution() \n    board=[['.' for _ in range(8)]for _ in range(8)] \n    board[0][0]='R' \n    assert solution.numRookCaptures(board)==0"}, {"start": 25, "end": 26, "test": "```\ndef test_numRookCaptures():\n    solution=Solution()\n    board = [['.' for _ in range(8)] for _ in range(8)]\n    board[0][0] = 'R'\n    board[3][3] = 'p'\n    assert solution.numRookCaptures(board) == 1\n```"}, {"start": 27, "end": 28, "test": "```\ndef test_numRookCaptures():\n    solution = Solution()\n    board = [['.' for _ in range(8)] for _ in range(8)]\n    board[0][0] = 'R'\n    board[1][1] = 'p'\n    assert solution.numRookCaptures(board) == 1\n```"}]}
{"task_num": 1001, "task_title": "Grid Illumination", "func_name": "gridIllumination", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def gridIllumination(self, n: int, lamps: List[List[int]], queries: List[List[int]]) -> List[int]:\n    ans = []\n    rows = collections.Counter()\n    cols = collections.Counter()\n    diag1 = collections.Counter()\n    diag2 = collections.Counter()\n    lampsSet = set()\n\n    for i, j in lamps:\n      if (i, j) not in lampsSet:\n        lampsSet.add((i, j))\n        rows[i] += 1\n        cols[j] += 1\n        diag1[i + j] += 1\n        diag2[i - j] += 1\n\n    for i, j in queries:\n      if rows[i] or cols[j] or diag1[i + j] or diag2[i - j]:\n        ans.append(1)\n        for y in range(max(0, i - 1), min(n, i + 2)):\n          for x in range(max(0, j - 1), min(n, j + 2)):\n            if (y, x) in lampsSet:\n              lampsSet.remove((y, x))\n              rows[y] -= 1\n              cols[x] -= 1\n              diag1[y + x] -= 1\n              diag2[y - x] -= 1\n      else:\n        ans.append(0)\n\n    return ans\n", "tests": [{"start": 21, "end": 26, "test": "def test_gridIllumination(): \n    solution = Solution() \n    lamps = [[0, 0], [1, 1]] \n    queries = [[0, 0], [1, 1]] \n    assert solution.gridIllumination(2, lamps, queries) == [1, 1]"}, {"start": 29, "end": 38, "test": "def test_gridIllumination(): \n    solution = Solution() \n    assert solution.gridIllumination(5, [[0,4],[1,4]], [[0,4]]) == [1],"}, {"start": 39, "end": 40, "test": "```\ndef test_gridIllumination():\n    def gridIllumination_test(n, lamps, queries):\n        solution = Solution()\n        return solution.gridIllumination(n, lamps, queries)\n    \n    assert gridIllumination_test(5, [[0, 0], [4, 4]], [[1, 1], [1, 2]]) == [1, 0]\n```"}, {"start": 33, "end": 38, "test": "def test_gridIllumination(): \n    solution = Solution() \n    assert solution.gridIllumination(5, [[0,4],[1,4]], [[0,4]]) == [1],"}]}
{"task_num": 1093, "task_title": "Statistics from a Large Sample", "func_name": "sampleStats", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def sampleStats(self, count: List[int]) -> List[float]:\n    minimum = next((i for i, num in enumerate(count) if num), None)\n    maximum = next((i for i, num in reversed(list(enumerate(count))) if num), None)\n    n = sum(count)\n    mean = sum(i * c / n for i, c in enumerate(count))\n    mode = count.index(max(count))\n\n    numCount = 0\n    leftMedian = 0\n    for i, c in enumerate(count):\n      numCount += c\n      if numCount >= n / 2:\n        leftMedian = i\n        break\n\n    numCount = 0\n    rightMedian = 0\n    for i, c in reversed(list(enumerate(count))):\n      numCount += c\n      if numCount >= n / 2:\n        rightMedian = i\n        break\n\n    return [minimum, maximum, mean, (leftMedian + rightMedian) / 2, mode]\n", "tests": [{"start": 23, "end": 25, "test": "def test_sampleStats():  \n    solution=Solution()  \n    count=[1,2,3,4,5]  \n    result=solution.sampleStats(count)"}, {"start": 31, "end": 33, "test": "def test_sampleStats(): \n    solution=Solution() \n    count=[1,2,3,4,5] \n    result=solution.sampleStats(count)"}]}
{"task_num": 1129, "task_title": "Shortest Path with Alternating Colors", "func_name": "shortestAlternatingPaths", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import Enum\n\n\nclass Color(Enum):\n  kInit = 0\n  kRed = 1\n  kBlue = 2\n\n\nclass Solution:\n  def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:\n    ans = [-1] * n\n    graph = [[] for _ in range(n)]\n    q = collections.deque([(0, Color.kInit)])\n\n    for u, v in redEdges:\n      graph[u].append((v, Color.kRed))\n\n    for u, v in blueEdges:\n      graph[u].append((v, Color.kBlue))\n\n    step = 0\n    while q:\n      for _ in range(len(q)):\n        u, prevColor = q.popleft()\n        if ans[u] == -1:\n          ans[u] = step\n        for i, (v, edgeColor) in enumerate(graph[u]):\n          if v == -1 or edgeColor == prevColor:\n            continue\n          q.append((v, edgeColor))\n          graph[u][i] = (-1, edgeColor)\n      step += 1\n\n    return ans\n", "tests": [{"start": 36, "end": 37, "test": "```\ndef test_shortestAlternatingPaths():\n    solution=Solution()\n    assert solution.shortestAlternatingPaths(3, [[0,1],[1,2]], [[1,2]]) == [0, 1, -1], \n```"}, {"start": 39, "end": 40, "test": "```\ndef test_shortestAlternatingPaths():\n    solution = Solution()\n    n = 3\n    redEdges = [[0,1],[1,2]]\n    blueEdges = [[2,0]]\n    assert solution.shortestAlternatingPaths(n, redEdges, blueEdges) == [0,1,-1]"}]}
{"task_num": 1139, "task_title": "Largest 1-Bordered Square", "func_name": "largest1BorderedSquare", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n\n    leftOnes = [[0] * n for _ in range(m)]\n    topOnes = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1:\n          if j==0:\n            leftOnes[i][j]=1\n          else:\n            leftOnes[i][j]=1+leftOnes[i][j-1]\n          if i==0:\n            topOnes[i][j]=1\n          else:\n            topOnes[i][j]=1+topOnes[i-1][j]\n\n    for sz in range(min(m, n), 0, -1):\n      for i in range(m - sz + 1):\n        for j in range(n - sz + 1):\n          x = i + sz - 1\n          y = j + sz - 1\n          if min(leftOnes[i][y], leftOnes[x][y], topOnes[x][j], topOnes[x][y]) >= sz:\n            return sz * sz\n\n    return 0\n", "tests": [{"start": 21, "end": 29, "test": "def test_largest1BorderedSquare(): \n    solution = Solution() \n    grid = [[0, 0, 1], [0, 1, 1], [1, 1, 1]] \n    assert solution.largest1BorderedSquare(grid) == 9"}, {"start": 22, "end": 23, "test": "```\ndef test_largest1BorderedSquare():\n    solution=Solution()\n    grid = [[1, 0], [1, 1]]\n    assert solution.largest1BorderedSquare(grid) == 4\n```"}, {"start": 24, "end": 25, "test": "```\ndef test_largest1BorderedSquare():\n    grid = [[0, 0, 0], [0, 1, 0], [0, 1, 1]]\n    assert largest1BorderedSquare(solution, grid) == 4\n```"}, {"start": 26, "end": 27, "test": "```\ndef test_largest1BorderedSquare():\n    solution=Solution()\n    grid = [[1, 0, 1], [1, 1, 0], [1, 0, 1]]\n    assert solution.largest1BorderedSquare(grid) == 4"}, {"start": 28, "end": 29, "test": "```\ndef test_largest1BorderedSquare():\n    solution=Solution()\n    grid = [[0, 0, 0], [0, 1, 1], [0, 1, 1]]\n    assert solution.largest1BorderedSquare(grid) == 4"}, {"start": 36, "end": 37, "test": "```\ndef test_largest1BorderedSquare():\n    solution=Solution()\n    assert solution.largest1BorderedSquare([[0,1,1,1],[1,1,1,1],[1,1,1,1]]) == 9\n```"}]}
{"task_num": 1162, "task_title": "As Far from Land as Possible", "func_name": "maxDistance", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxDistance(self, grid: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    q = collections.deque()\n    water = 0\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 0:\n          water += 1\n        else:\n          q.append((i, j))\n\n    if water == 0 or water == m * n:\n      return -1\n\n    ans = 0\n    d = 0\n\n    while q:\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        ans = d\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if grid[x][y] > 0:\n            continue\n          q.append((x, y))\n          grid[x][y] = 2\n      d += 1\n\n    return ans\n", "tests": [{"start": 26, "end": 27, "test": "```\ndef test_maxDistance():\n    solution = Solution()\n    assert solution.maxDistance([[0, 0], [0, 1]]) == 2"}, {"start": 21, "end": 22, "test": "```\ndef test_maxDistance():\n    solution = Solution()\n    assert solution.maxDistance([[0, 0], [0, 1]]) == 2"}, {"start": 23, "end": 24, "test": "```\ndef test_maxDistance():\n    solution = Solution()\n    assert solution.maxDistance([[0, 1], [0, 0]]) == 2\n```"}, {"start": 39, "end": 40, "test": "```\ndef test_maxDistance():\n    solution = Solution()\n    assert solution.maxDistance([[0,1],[0,0]]) == 2\n```"}, {"start": 41, "end": 42, "test": "```\ndef test_maxDistance():\n    solution = Solution()\n    assert solution.maxDistance([[0,1],[0,0]]) == 2\n```"}]}
{"task_num": 1202, "task_title": "Smallest String With Swaps", "func_name": "smallestStringWithSwaps", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n    ans = ''\n    uf = UnionFind(len(s))\n    map = collections.defaultdict(list)\n\n    for a, b in pairs:\n      uf.unionByRank(a, b)\n\n    for i, c in enumerate(s):\n      map[uf.find(i)].append(c)\n\n    for key in map.keys():\n      map[key].sort(reverse=True)\n\n    for i in range(len(s)):\n      ans += map[uf.find(i)].pop()\n\n    return ans\n", "tests": [{"start": 19, "end": 20, "test": "```\ndef test_smallestStringWithSwaps():\n    solution = Solution()\n    assert solution.smallestStringWithSwaps(\"abc\", [[0, 1]]) == \"acb\""}, {"start": 21, "end": 22, "test": "```\ndef test_smallestStringWithSwaps():\n    solution=Solution()\n    assert solution.smallestStringWithSwaps(\"abc\", [[0,1],[1,2]]) == \"acb\"\n```"}, {"start": 30, "end": 31, "test": "```\ndef test_smallestStringWithSwaps():\n    solution=Solution()\n    assert solution.smallestStringWithSwaps(\"abc\", [[0,1],[1,2]]) == \"acb\""}, {"start": 23, "end": 24, "test": "```\ndef test_smallestStringWithSwaps():\n    solution=Solution()\n    assert solution.smallestStringWithSwaps(\"abc\", [[0,1],[1,2]]) == \"acb\""}, {"start": 25, "end": 27, "test": "```\ndef test_smallestStringWithSwaps():\n    solution=Solution()\n    assert solution.smallestStringWithSwaps(\"abc\", [[0,1],[1,2]]) == \"acb\""}]}
{"task_num": 1210, "task_title": "Minimum Moves to Reach Target with Rotations", "func_name": "minimumMoves", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import IntEnum\n\n\nclass Pos(IntEnum):\n  kHorizontal = 0\n  kVertical = 1\n\n\nclass Solution:\n  def minimumMoves(self, grid: List[List[int]]) -> int:\n    n = len(grid)\n    ans = 0\n\n    q = collections.deque([(0, 0, Pos.kHorizontal)])\n    seen = {(0, 0, Pos.kHorizontal)}\n\n    def canMoveRight(x: int, y: int, pos: Pos) -> bool:\n      if pos == Pos.kHorizontal:\n        return y + 2 < n and not grid[x][y + 2]\n      return y + 1 < n and not grid[x][y + 1] and not grid[x + 1][y + 1]\n\n    def canMoveDown(x: int, y: int, pos: Pos) -> bool:\n      if pos == Pos.kVertical:\n        return x + 2 < n and not grid[x + 2][y]\n      return x + 1 < n and not grid[x + 1][y] and not grid[x + 1][y + 1]\n\n    def canRotateClockwise(x: int, y: int, pos: Pos) -> bool:\n      return pos == Pos.kHorizontal and x + 1 < n and \\\n          not grid[x + 1][y + 1] and not grid[x + 1][y]\n\n    def canRotateCounterclockwise(x: int, y: int, pos: Pos) -> bool:\n      return pos == Pos.kVertical and y + 1 < n and \\\n          not grid[x + 1][y + 1] and not grid[x][y + 1]\n\n    while q:\n      for _ in range(len(q)):\n        x, y, pos = q.popleft()\n        if x == n - 1 and y == n - 2 and pos == Pos.kHorizontal:\n          return ans\n        if canMoveRight(x, y, pos) and (x, y + 1, pos) not in seen:\n          q.append((x, y + 1, pos))\n          seen.add((x, y + 1, pos))\n        if canMoveDown(x, y, pos) and (x + 1, y, pos) not in seen:\n          q.append((x + 1, y, pos))\n          seen.add((x + 1, y, pos))\n        newPos = Pos.kVertical if pos == Pos.kHorizontal else Pos.kHorizontal\n        if (canRotateClockwise(x, y, pos) or canRotateCounterclockwise(x, y, pos)) and (x, y, newPos) not in seen:\n          q.append((x, y, newPos))\n          seen.add((x, y, newPos))\n      ans += 1\n\n    return -1\n", "tests": [{"start": 28, "end": 29, "test": "```\ndef test_minimumMoves():\n    def minimum_moves(grid):\n        pass\n    solution = Solution()\n    assert minimum_moves([[0, 1], [0, 0]]) == 3\n```"}, {"start": 33, "end": 34, "test": "```\ndef test_minimumMoves():\n    def test_minimumMoves_grid():\n        grid = [[0, 1, 0], [0, 0, 0], [0, 0, 0]]\n        assert solution.minimumMoves(grid) == 5\n```"}, {"start": 48, "end": 49, "test": "```\ndef test_minimumMoves():\n    def test_grid():\n        grid = [[0, 0, 1], [0, 0, 1], [0, 0, 0]]\n        assert solution.minimumMoves(grid) == 3\n```"}, {"start": 50, "end": 52, "test": "```\ndef test_minimumMoves():\n    def grid_test_case():\n        return [[0, 0, 0], [0, 0, 0], [0, 0, 1]]\n    assert grid_test_case() == 3, f\"Expected minimumMoves({grid_test_case()}) to return 3, but got {minimumMoves(grid_test_case())}\"\n```"}, {"start": 53, "end": 55, "test": "```\ndef test_minimumMoves():\n    solution = Solution()\n    assert solution.minimumMoves([[0, 0, 0], [0, 0, 0], [1, 1, 0]]) == 5\n```"}, {"start": 57, "end": 59, "test": "```\ndef test_minimumMoves():\n    def assertMinimumMoves(grid):\n        solution = Solution()\n        assert solution.minimumMoves(grid) == 3\n```"}]}
{"task_num": 1253, "task_title": "Reconstruct a 2-Row Binary Matrix", "func_name": "reconstructMatrix", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def reconstructMatrix(self, upper: int, lower: int, colsum: List[int]) -> List[List[int]]:\n    if upper + lower != sum(colsum):\n      return []\n    if min(upper, lower) < colsum.count(2):\n      return []\n\n    ans = [[0] * len(colsum) for _ in range(2)]\n\n    for j, c in enumerate(colsum):\n      if c == 2:\n        ans[0][j] = 1\n        ans[1][j] = 1\n        upper -= 1\n        lower -= 1\n\n    for j, c in enumerate(colsum):\n      if c == 1 and upper > 0:\n        ans[0][j] = 1\n        c -= 1\n        upper -= 1\n      if c == 1 and lower > 0:\n        ans[1][j] = 1\n        lower -= 1\n\n    return ans\n", "tests": [{"start": 13, "end": 14, "test": "```\ndef test_reconstructMatrix():\n    def assert_equals(expected, actual):\n        pass\n    solution = Solution()\n    upper = 3\n    lower = 2\n    colsum = [1, 1, 0]\n    result = solution.reconstructMatrix(upper, lower, colsum)\n```"}, {"start": 15, "end": 16, "test": "```\ndef test_reconstructMatrix():\n    solution = Solution()\n    assert solution.reconstructMatrix(1, 3, [0, 2]) == [[1, 0], [1, 1]], None\n```"}, {"start": 21, "end": 25, "test": "def test_reconstructMatrix(): \n    solution=Solution() \n    assert solution.reconstructMatrix(2, 2, [2, 2]) == [[1, 1], [1, 1]]"}, {"start": 28, "end": 31, "test": "def test_reconstructMatrix(): \n    solution=Solution() \n    assert solution.reconstructMatrix(2, 2, [1, 1]) == [[1, 1], [0, 0]]"}, {"start": 32, "end": 34, "test": "```\ndef test_reconstructMatrix():\n    solution=Solution()\n    assert solution.reconstructMatrix(2, 2, [1, 1]) == [[1, 1], [1, 1]]\n```"}]}
{"task_num": 1254, "task_title": "Number of Closed Islands", "func_name": "closedIsland", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def closedIsland(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n\n    def dfs(i: int, j: int) -> None:\n      if i < 0 or i == m or j < 0 or j == n:\n        return\n      if grid[i][j] == 1:\n        return\n\n      grid[i][j] = 1\n      dfs(i + 1, j)\n      dfs(i - 1, j)\n      dfs(i, j + 1)\n      dfs(i, j - 1)\n\n    for i in range(m):\n      for j in range(n):\n        if i * j == 0 or i == m - 1 or j == n - 1:\n          if grid[i][j] == 0:\n            dfs(i, j)\n\n    ans = 0\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 0:\n          dfs(i, j)\n          ans += 1\n\n    return ans\n", "tests": [{"start": 17, "end": 18, "test": "def test_closedIsland(): \n    grid = [[1,1,1,1,1,1,1,1,1],\n            [1,0,0,0,0,0,0,0,1],\n            [1,0,1,1,1,1,1,0,1],\n            [1,0,1,0,0,0,0,0,1],\n            [1,0,1,0,1,1,1,0,1],\n            [1,0,0,0,1,1,1,0,1],\n            [1,0,0,0,1,1,1,0,1],\n            [1,1,1,1,1,1,1,1,1]] \n    assert solution.closedIsland(grid) == 2"}, {"start": 19, "end": 20, "test": "```\ndef test_closedIsland():\n    solution = Solution()\n    assert solution.closedIsland([[0,0,1],[1,1,1],[0,0,0]]) == 1\n```"}, {"start": 30, "end": 32, "test": "```\ndef test_closedIsland():\n    solution = Solution()\n    assert solution.closedIsland([[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]) == 1\n```"}, {"start": 38, "end": 40, "test": "```\ndef test_closedIsland():\n    solution = Solution()\n    assert solution.closedIsland([[0,0,1,0,0],[1,0,1,0,0],[0,0,1,0,0],[0,0,0,1,1]]) == 1\n```"}, {"start": 31, "end": 32, "test": "```\ndef test_closedIsland():\n    solution = Solution()\n    assert solution.closedIsland([[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]) == 1\n```"}]}
{"task_num": 1263, "task_title": "Minimum Moves to Move a Box to Their Target Location", "func_name": "minPushBox", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\nfrom collections import deque\n\nclass Solution:\n  def minPushBox(self, grid: List[List[str]]) -> int:\n    for i in range(len(grid)):\n      for j in range(len(grid[0])):\n        if grid[i][j] == \"T\":\n          target = (i,j)\n        if grid[i][j] == \"B\":\n          box = (i,j)\n        if grid[i][j] == \"S\":\n          person = (i,j)\n\n    def valid(x,y):\n      return 0<=x<len(grid) and 0<=y<len(grid[0]) and grid[x][y]!='#'\n\n    def check(curr,dest,box):\n      que = deque([curr])\n      v = set()\n      while que:\n        pos = que.popleft()\n        if pos == dest: \n          return True\n        new_pos = [(pos[0]+1,pos[1]),(pos[0]-1,pos[1]),(pos[0],pos[1]+1),(pos[0],pos[1]-1)]\n        for x,y in new_pos:\n          if valid(x,y) and (x,y) not in v and (x,y)!=box:\n            v.add((x,y))\n            que.append((x,y))\n      return False\n\n    q = deque([(0,box,person)])\n    vis = {box+person}\n    while q :\n      dist, box, person = q.popleft()\n      if box == target:\n        return dist\n\n      b_coord = [(box[0]+1,box[1]),(box[0]-1,box[1]),(box[0],box[1]+1),(box[0],box[1]-1)]\n      p_coord = [(box[0]-1,box[1]),(box[0]+1,box[1]),(box[0],box[1]-1),(box[0],box[1]+1)]\n\n      for new_box,new_person in zip(b_coord,p_coord): \n        if valid(*new_box) and new_box+box not in vis:\n          if valid(*new_person) and check(person,new_person,box):\n            vis.add(new_box+box)\n            q.append((dist+1,new_box,box))\n\n    return -1\n", "tests": [{"start": 44, "end": 45, "test": "```\ndef test_minPushBox():\n    grid = [['#', '#', '#', '#'], ['#', 'S', '.', '#'], ['#', '#', 'T', '#']]\n    assert solution.minPushBox(grid) == 3\n```"}, {"start": 16, "end": 17, "test": "```\ndef test_minPushBox():\n    grid = [[\"#\", \"#\", \"#\", \"#\", \"#\"], \n           [\"#\", \"S\", \".\", \".\", \"#\"], \n           [\"#\", \"#\", \"T\", \"#\", \"#\"], \n           [\"#\", \"#\", \"#\", \"#\", \"#\"]]\n    assert solution.minPushBox(grid) == 3, f\"Expected minPushBox({grid}) to return 3, but got {solution.minPushBox(grid)}\"\n```"}, {"start": 18, "end": 19, "test": "```\ndef test_minPushBox():\n    grid = [['#','#','#','S','.','.','.'],\n           ['#','T','.','.','.','.','.'],\n           ['#','B','.','.','.','.','.'],\n           ['#','.','.','.','.','.','.']]\n    assert solution.minPushBox(grid) == 3, f\"Expected minPushBox({grid}) to return 3, but got {solution.minPushBox(grid)}\"\n```"}, {"start": 20, "end": 21, "test": "```\ndef test_minPushBox():\n    grid = [['#','#','#','T'],\n           ['#','.','.','.'],\n           ['#','.','.','.'],\n           ['#','.','.','B']]\n    assert solution.minPushBox(grid) == 3, f\"Expected minPushBox({grid}) to return 3, but got {solution.minPushBox(grid)}\"\n```"}, {"start": 31, "end": 32, "test": "```\ndef test_minPushBox():\n    grid = [['#', '#', '#', '#'], ['#', 'S', '.', '#'], ['#', '#', 'T', '#']]\n    assert minPushBox(grid) == 3\n```"}, {"start": 51, "end": 54, "test": "```\ndef test_minPushBox():\n    grid = [['#','#','#','S','.','.','.'],\n           ['#','T','.','.','.','.','.'],\n           ['#','B','.','.','.','.','.'],\n           ['#','.','.','.','.','.','.']]\n    assert solution.minPushBox(grid) == 3\n```"}, {"start": 35, "end": 37, "test": "```\ndef test_minPushBox():\n    grid = [['#', '#', '#', '#', '#'],\n           ['#', 'S', '.', '.', '#'],\n           ['#', '#', 'B', '.', '#'],\n           ['#', '#', '#', '#', '#']]\n    assert solution.minPushBox(grid) == 3\n```"}, {"start": 52, "end": 54, "test": "```\ndef test_minPushBox():\n    grid = [['#', '#', '#', '#', '#'],\n           ['#', 'S', '.', '.', '#'],\n           ['#', '#', 'B', '.', '#'],\n           ['#', '#', '#', '#', '#']]\n    assert solution.minPushBox(grid) == 3\n```"}]}
{"task_num": 1267, "task_title": "Count Servers that Communicate", "func_name": "countServers", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countServers(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    ans = 0\n    rows = [0] * m\n    cols = [0] * n\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1:\n          rows[i] += 1\n          cols[j] += 1\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1 and (rows[i] > 1 or cols[j] > 1):\n          ans += 1\n\n    return ans\n", "tests": [{"start": 21, "end": 23, "test": "def test_countServers():    \n    solution = Solution()    \n    grid = [[0,1,2],[0,0,1]]    \n    assert solution.countServers(grid) == 1"}, {"start": 27, "end": 28, "test": "def test_countServers(): \n    solution = Solution() \n    grid = [[0,0,0],[0,1,0],[0,1,1]] \n    assert solution.countServers(grid) == 3"}]}
{"task_num": 1284, "task_title": "Minimum Number of Flips to Convert Binary Matrix to Zero Matrix", "func_name": "minFlips", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minFlips(self, mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    hash = self._getHash(mat, m, n)\n    if hash == 0:\n      return 0\n\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    step = 0\n    q = collections.deque([hash])\n    seen = {hash}\n\n    while q:\n      step += 1\n      for _ in range(len(q)):\n        curr = q.popleft()\n        for i in range(m):\n          for j in range(n):\n            next = curr ^ 1 << (i * n + j)\n            for dx, dy in dirs:\n              x = i + dx\n              y = j + dy\n              if x < 0 or x == m or y < 0 or y == n:\n                continue\n              next ^= 1 << (x * n + y)\n            if next == 0:\n              return step\n            if next in seen:\n              continue\n            q.append(next)\n            seen.add(next)\n\n    return -1\n\n  def _getHash(self, mat: List[List[int]], m: int, n: int) -> int:\n    hash = 0\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j]:\n          hash |= 1 << (i * n + j)\n    return hash\n", "tests": [{"start": 16, "end": 17, "test": "```\ndef test_minFlips():\n    solution = Solution()\n    assert solution.minFlips([[0,1],[1,0]]) == 2\n```"}, {"start": 50, "end": 51, "test": "```\ndef test_minFlips():\n    solution = Solution()\n    assert solution.minFlips([[0, 0], [0, 0]]) == 0\n```"}, {"start": 37, "end": 38, "test": "```\ndef test_minFlips():\n    solution = Solution()\n    assert solution.minFlips([[0,1],[1,0]]) == 2\n```"}, {"start": 39, "end": 40, "test": "```\ndef test_minFlips():\n    solution = Solution()\n    assert solution.minFlips([[0, 1], [1, 0]]) == 2\n```"}, {"start": 34, "end": 35, "test": "```\ndef test_minFlips():\n    solution = Solution()\n    assert solution.minFlips([[1, 0], [0, 1]]) == -1\n```"}]}
{"task_num": 1293, "task_title": "Shortest Path in a Grid with Obstacles Elimination", "func_name": "shortestPath", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def shortestPath(self, grid: List[List[int]], k: int) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    if m == 1 and n == 1:\n      return 0\n\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    steps = 0\n    q = collections.deque([(0, 0, k)])\n    seen = {(0, 0, k)}\n\n    while q:\n      steps += 1\n      for _ in range(len(q)):\n        i, j, eliminate = q.popleft()\n        for l in range(4):\n          x = i + dirs[l][0]\n          y = j + dirs[l][1]\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if x == m - 1 and y == n - 1:\n            return steps\n          if grid[x][y] == 1 and eliminate == 0:\n            continue\n          newEliminate = eliminate - grid[x][y]\n          if (x, y, newEliminate) in seen:\n            continue\n          q.append((x, y, newEliminate))\n          seen.add((x, y, newEliminate))\n\n    return -1\n", "tests": [{"start": 15, "end": 16, "test": "```\ndef test_shortestPath():\n    solution = Solution()\n    assert solution.shortestPath([[0]], 0) == 0\n```"}, {"start": 30, "end": 31, "test": "```\ndef test_shortestPath():\n    solution = Solution()\n    assert solution.shortestPath([[0, 1], [0, 0]], 1) == 2\n```"}, {"start": 32, "end": 33, "test": "```\ndef test_shortestPath():\n    solution = Solution()\n    assert solution.shortestPath([[0, 0], [0, 0]], 2) == 2\n```"}, {"start": 34, "end": 35, "test": "```\ndef test_shortestPath():\n    solution = Solution()\n    assert solution.shortestPath([[0, 0], [0, 1]], 0) == -1\n```"}, {"start": 37, "end": 38, "test": "```\ndef test_shortestPath():\n    solution = Solution()\n    assert solution.shortestPath([[0, 1], [0, 0]], 1) == 2\n```"}]}
{"task_num": 1301, "task_title": "Number of Paths with Max Score", "func_name": "pathsWithMaxScore", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def pathsWithMaxScore(self, board: List[str]) -> List[int]:\n    kMod = 1_000_000_007\n    n = len(board)\n    dirs = ((0, 1), (1, 0), (1, 1))\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    count = [[0] * (n + 1) for _ in range(n + 1)]\n\n    dp[0][0] = 0\n    dp[n - 1][n - 1] = 0\n    count[n - 1][n - 1] = 1\n\n    for i in reversed(range(n)):\n      for j in reversed(range(n)):\n        if board[i][j] == 'S' or board[i][j] == 'X':\n          continue\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if dp[i][j] < dp[x][y]:\n            dp[i][j] = dp[x][y]\n            count[i][j] = count[x][y]\n          elif dp[i][j] == dp[x][y]:\n            count[i][j] += count[x][y]\n            count[i][j] %= kMod\n\n        if dp[i][j] != -1 and board[i][j] != 'E':\n          dp[i][j] += int(board[i][j])\n          dp[i][j] %= kMod\n\n    return [dp[0][0], count[0][0]]\n", "tests": [{"start": 25, "end": 26, "test": "```\ndef test_pathsWithMaxScore():\n    solution = Solution()\n    assert solution.pathsWithMaxScore([[\"1\", \"2\", \"3\"], [\"4\", \"5\", \"6\"], [\"7\", \"8\", \"S\"]]) == [12, 1]\n```"}, {"start": 37, "end": 39, "test": "```\ndef test_pathsWithMaxScore():\n    solution = Solution()\n    assert solution.pathsWithMaxScore([[\"1\", \"2\", \"3\"], [\"4\", \"5\", \"6\"], [\"7\", \"8\", \"S\"]]) == [9, 1]\n```"}, {"start": 30, "end": 32, "test": "```\ndef test_pathsWithMaxScore():\n    solution=Solution()\n    assert solution.pathsWithMaxScore([[\"1\", \"2\", \"3\"], [\"4\", \"5\", \"6\"], [\"7\", \"8\", \"S\"]]) == [9, 1]\n```"}, {"start": 33, "end": 35, "test": "```\ndef test_pathsWithMaxScore():\n    def pathsWithMaxScore(board):\n        return [0, 1]\n```"}]}
{"task_num": 1334, "task_title": "Find the City With the Smallest Number of Neighbors at a Threshold Distance", "func_name": "findTheCity", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -> int:\n    ans = -1\n    minCitiesCount = n\n    dist = self._floydWarshall(n, edges, distanceThreshold)\n\n    for i in range(n):\n      citiesCount = sum(dist[i][j] <= distanceThreshold for j in range(n))\n      if citiesCount <= minCitiesCount:\n        ans = i\n        minCitiesCount = citiesCount\n\n    return ans\n\n  def _floydWarshall(self, n: int, edges: List[List[int]], distanceThreshold: int) -> List[List[int]]:\n    dist = [[distanceThreshold + 1] * n for _ in range(n)]\n\n    for i in range(n):\n      dist[i][i] = 0\n\n    for u, v, w in edges:\n      dist[u][v] = w\n      dist[v][u] = w\n\n    for k in range(n):\n      for i in range(n):\n        for j in range(n):\n          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    return dist\n", "tests": [{"start": 19, "end": 21, "test": "```\ndef test_findTheCity():\n    solution=Solution()\n    assert solution.findTheCity(3, [[0,1,2],[1,2,4],[2,0,5]], 3) == 0\n```"}]}
{"task_num": 1340, "task_title": "Jump Game V", "func_name": "maxJumps", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxJumps(self, arr: List[int], d: int) -> int:\n    n = len(arr)\n    dp = [1] * n\n    stack = []\n\n    for i in range(n + 1):\n      while stack and (i == n or arr[stack[-1]] < arr[i]):\n        indices = [stack.pop()]\n        while stack and arr[stack[-1]] == arr[indices[0]]:\n          indices.append(stack.pop())\n        for j in indices:\n          if i < n and i - j <= d:\n            dp[i] = max(dp[i], dp[j] + 1)\n          if stack and j - stack[-1] <= d:\n            dp[stack[-1]] = max(dp[stack[-1]], dp[j] + 1)\n      stack.append(i)\n\n    return max(dp)\n", "tests": [{"start": 23, "end": 24, "test": "```\ndef test_maxJumps():\n    solution=Solution()\n    assert solution.maxJumps([3,2,1,9,3,4,5,7,6], 2) == 6\n```"}, {"start": 25, "end": 26, "test": "```\ndef test_maxJumps():\n    def assertEqual(actual, expected):\n        if actual != expected:\n            raise AssertionError(f\"Expected {expected}, but got {actual}\")\n    solution = Solution()\n    arr = [6,4,14,6,8,13]\n    d = 3\n    assertEqual(solution.maxJumps(arr, d), 4)"}]}
{"task_num": 1345, "task_title": "Jump Game IV", "func_name": "minJumps", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minJumps(self, arr: List[int]) -> int:\n    n = len(arr)\n    graph = collections.defaultdict(list)\n    step = 0\n    q = collections.deque([0])\n    seen = {0}\n\n    for i, a in enumerate(arr):\n      graph[a].append(i)\n\n    while q:\n      for _ in range(len(q)):\n        i = q.popleft()\n        if i == n - 1:\n          return step\n        seen.add(i)\n        u = arr[i]\n        if i + 1 < n:\n          graph[u].append(i + 1)\n        if i - 1 >= 0:\n          graph[u].append(i - 1)\n        for v in graph[u]:\n          if v in seen:\n            continue\n          q.append(v)\n        graph[u].clear()\n      step += 1\n", "tests": [{"start": 25, "end": 26, "test": "```\ndef test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([0,1,2,3]) == 4\n```"}, {"start": 29, "end": 30, "test": "```\ndef test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([0,1,2,3]) == 4\n```"}, {"start": 31, "end": 32, "test": "def test_minJumps():    \n    solution = Solution()    \n    assert solution.minJumps([2,1,1,3,2]) == 4"}, {"start": 34, "end": 35, "test": "```\ndef test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([0, 1, 2, 3]) == 4\n```"}]}
{"task_num": 1377, "task_title": "Frog Position After T Seconds", "func_name": "frogPosition", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n    tree = [[] for _ in range(n + 1)]\n    q = collections.deque([1])\n    seen = [False] * (n + 1)\n    prob = [0] * (n + 1)\n\n    prob[1] = 1\n    seen[1] = True\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    for _ in range(t):\n      for _ in range(len(q)):\n        a = q.popleft()\n        nChildren = sum(not seen[b] for b in tree[a])\n        for b in tree[a]:\n          if seen[b]:\n            continue\n          seen[b] = True\n          prob[b] = prob[a] / nChildren\n          q.append(b)\n        if nChildren > 0:\n          prob[a] = 0\n\n    return prob[target]\n", "tests": [{"start": 35, "end": 36, "test": "```\ndef test_frogPosition():\n    solution=Solution()\n    assert round(solution.frogPosition(3, [[1,2],[2,3]], 2, 3),5) == 0.66667\n```"}, {"start": 30, "end": 31, "test": "```\ndef test_frogPosition():\n    solution=Solution()\n    assert round(solution.frogPosition(3, [[1,2],[2,3]], 2, 3),5) == 0.66667\n```"}]}
{"task_num": 1417, "task_title": "Reformat The String", "func_name": "reformat", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def reformat(self, s: str) -> str:\n    A=[]\n    for c in s:\n      if c.isalpha():\n        A.append(c)\n    B=[]\n    for c in s:\n      if c.isdigit():\n        B.append(c)\n\n    if len(A) < len(B):\n      A, B = B, A\n    if len(A) - len(B) > 1:\n      return ''\n\n    ans = []\n\n    for i in range(len(B)):\n      ans.append(A[i])\n      ans.append(B[i])\n\n    if len(A) == len(B) + 1:\n      ans.append(A[-1])\n    return ''.join(ans)\n", "tests": [{"start": 22, "end": 23, "test": "```\ndef test_reformat():\n    solution=Solution()\n    assert solution.reformat(\"a1b2c3\") == \"a1b2c3\", None"}, {"start": 24, "end": 25, "test": "```\ndef test_reformat():\n    solution=Solution()\n    assert solution.reformat(\"a1b2c3\") == \"a1b2c3\", f\"Expected 'a1b2c3' but got {solution.reformat('a1b2c3')}\"\n```"}, {"start": 33, "end": 34, "test": "```\ndef test_reformat():\n    solution=Solution()\n    assert solution.reformat(\"a0b1c2\") == \"a0b1c2\", \n```"}, {"start": 15, "end": 16, "test": "```\ndef test_reformat():\n    solution=Solution()\n    assert solution.reformat(\"a1b2c3\") == \"a1b2c3\", \n```"}, {"start": 19, "end": 20, "test": "```\ndef test_reformat():\n    solution=Solution()\n    assert solution.reformat(\"a1b2c3\") == \"a1b2c3\"\n```"}]}
{"task_num": 1462, "task_title": "Course Schedule IV", "func_name": "checkIfPrerequisite", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:\n    graph = [[] for _ in range(numCourses)]\n    isPrerequisite = [[False] * numCourses for _ in range(numCourses)]\n\n    for u, v in prerequisites:\n      graph[u].append(v)\n\n    for i in range(numCourses):\n      self._dfs(graph, i, isPrerequisite[i])\n\n    return [isPrerequisite[u][v] for u, v in queries]\n\n  def _dfs(self, graph: List[List[int]], u: int, used: List[bool]) -> None:\n    for v in graph[u]:\n      if used[v]:\n        continue\n      used[v] = True\n      self._dfs(graph, v, used)\n", "tests": [{"start": 26, "end": 27, "test": "```\ndef test_checkIfPrerequisite():\n    solution = Solution()\n    assert not solution.checkIfPrerequisite(2, [[1, 0]], [[1, 1]]), None\n```"}]}
{"task_num": 1489, "task_title": "Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree", "func_name": "findCriticalAndPseudoCriticalEdges", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Union\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n    criticalEdges = []\n    pseudoCriticalEdges = []\n\n    for i in range(len(edges)):\n      edges[i].append(i)\n\n    edges.sort(key=lambda x: x[2])\n\n    def getMSTWeight(firstEdge: List[int], deletedEdgeIndex: int) -> Union[int, float]:\n      mstWeight = 0\n      uf = UnionFind(n)\n\n      if firstEdge:\n        uf.unionByRank(firstEdge[0], firstEdge[1])\n        mstWeight += firstEdge[2]\n\n      for u, v, weight, index in edges:\n        if index == deletedEdgeIndex:\n          continue\n        if uf.find(u) == uf.find(v):\n          continue\n        uf.unionByRank(u, v)\n        mstWeight += weight\n\n      root = uf.find(0)\n      if any(uf.find(i) != root for i in range(n)):\n        return math.inf\n\n      return mstWeight\n\n    mstWeight = getMSTWeight([], -1)\n\n    for edge in edges:\n      index = edge[3]\n      if getMSTWeight([], index) > mstWeight:\n        criticalEdges.append(index)\n      elif getMSTWeight(edge, -1) == mstWeight:\n        pseudoCriticalEdges.append(index)\n\n    return [criticalEdges, pseudoCriticalEdges]\n", "tests": [{"start": 19, "end": 20, "test": "```\ndef test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    result = solution.findCriticalAndPseudoCriticalEdges(3, [[0, 1, 2], [1, 2, 3], [2, 0, 4]])\n```"}, {"start": 21, "end": 22, "test": "```\ndef test_findCriticalAndPseudoCriticalEdges():\n    solution=Solution()\n    result = solution.findCriticalAndPseudoCriticalEdges(3, [[0,1,2],[1,2,3],[2,0,4]])\n```"}, {"start": 30, "end": 31, "test": "```\ndef test_findCriticalAndPseudoCriticalEdges():\n    solution=Solution()\n    result = solution.findCriticalAndPseudoCriticalEdges(3, [[0,1,2],[1,2,3],[2,0,4]])\n```"}, {"start": 23, "end": 24, "test": "```\ndef test_findCriticalAndPseudoCriticalEdges():\n    solution=Solution()\n    result = solution.findCriticalAndPseudoCriticalEdges(3, [[0,1,2],[1,2,3],[2,0,4]])\n```"}, {"start": 25, "end": 27, "test": "```\ndef test_findCriticalAndPseudoCriticalEdges():\n    solution=Solution()\n    n = 4\n    edges = [[0,1,2],[1,2,3],[2,3,4],[3,0,5]]\n    result = solution.findCriticalAndPseudoCriticalEdges(n, edges)\n```"}, {"start": 49, "end": 51, "test": "```\ndef test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    result = solution.findCriticalAndPseudoCriticalEdges(3, [[0, 1, 2], [1, 2, 3], [2, 0, 4]])\n```"}, {"start": 62, "end": 63, "test": "```\ndef test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    result = solution.findCriticalAndPseudoCriticalEdges(3, [[0, 1, 2], [1, 2, 3], [2, 0, 4]])\n```"}, {"start": 71, "end": 72, "test": "```\ndef test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    result = solution.findCriticalAndPseudoCriticalEdges(3, [[0, 1, 2], [1, 2, 3], [2, 0, 4]])\n```"}, {"start": 54, "end": 55, "test": "```\ndef test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    edges = [[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 0, 5]]\n    result = solution.findCriticalAndPseudoCriticalEdges(4, edges)\n```"}, {"start": 56, "end": 57, "test": "```\ndef test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    result = solution.findCriticalAndPseudoCriticalEdges(3, [[0, 1, 2], [1, 2, 3], [2, 0, 4]])\n```"}, {"start": 73, "end": 74, "test": "```\ndef test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    result = solution.findCriticalAndPseudoCriticalEdges(3, [[0, 1, 2], [1, 2, 3], [2, 0, 4]])\n```"}]}
{"task_num": 1573, "task_title": "Number of Ways to Split a String", "func_name": "numWays", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numWays(self, s: str) -> int:\n    kMod = 1_000_000_007\n    ones = s.count('1')\n    if ones % 3 != 0:\n      return 0\n    if ones == 0:\n      n = len(s)\n      return (n - 1) * (n - 2) // 2 % kMod\n\n    s1End = -1\n    s2Start = -1\n    s2End = -1\n    s3Start = -1\n    onesSoFar = 0\n\n    for i, c in enumerate(s):\n      if c == '1':\n        onesSoFar += 1\n      if s1End == -1 and onesSoFar == ones // 3:\n        s1End = i\n      elif s2Start == -1 and onesSoFar == ones // 3 + 1:\n        s2Start = i\n      if s2End == -1 and onesSoFar == ones // 3 * 2:\n        s2End = i\n      elif s3Start == -1 and onesSoFar == ones // 3 * 2 + 1:\n        s3Start = i\n\n    return (s2Start - s1End) * (s3Start - s2End) % kMod\n", "tests": [{"start": 15, "end": 16, "test": "```\ndef test_numWays():\n    solution = Solution()\n    assert solution.numWays(\"101010\") == 2, f\"Expected numWays('101010') to return 2, but got {solution.numWays('101010')}.\""}, {"start": 17, "end": 19, "test": "```\ndef test_numWays():\n    solution=Solution()\n    assert solution.numWays(\"000\") == 6, \n```"}, {"start": 28, "end": 29, "test": "```\ndef test_numWays():\n    solution = Solution()\n    assert solution.numWays(\"111\") % 1000000007 == 2, \"Test failed\"\n```"}, {"start": 30, "end": 31, "test": "```\ndef test_numWays():\n    solution=Solution()\n    assert solution.numWays(\"111\") % 1000000007 == 2, \"Test failed\"\n```"}, {"start": 34, "end": 35, "test": "```\ndef test_numWays():\n    solution=Solution()\n    assert solution.numWays(\"111\") % 1_000_000_007 == 2, \"Test failed\"\n```"}, {"start": 32, "end": 33, "test": "```\ndef test_numWays():\n    solution=Solution()\n    assert solution.numWays(\"111000\") == 0, \"Test failed\"\n```"}, {"start": 36, "end": 37, "test": "```\ndef test_numWays():\n    solution=Solution()\n    assert solution.numWays(\"111\") == 2, \n```"}]}
{"task_num": 1574, "task_title": "Shortest Subarray to be Removed to Make Array Sorted", "func_name": "findLengthOfShortestSubarray", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n    n = len(arr)\n    l = 0\n    r = n - 1\n\n    while l < n - 1 and arr[l + 1] >= arr[l]:\n      l += 1\n    while r > 0 and arr[r - 1] <= arr[r]:\n      r -= 1\n    ans = min(n - 1 - l, r)\n\n    i = l\n    j = n - 1\n    while i >= 0 and j >= r and j > i:\n      if arr[i] <= arr[j]:\n        j -= 1\n      else:\n        i -= 1\n      ans = min(ans, j - i)\n\n    return ans\n", "tests": [{"start": 26, "end": 27, "test": "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([2,3,9,2,5]) == 3"}, {"start": 28, "end": 29, "test": "```\ndef test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([2,3,9,2,5]) == 3\n```"}]}
{"task_num": 1579, "task_title": "Remove Max Number of Edges to Keep Graph Fully Traversable", "func_name": "maxNumEdgesToRemove", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    self.count -= 1\n    return True\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\n    alice = UnionFind(n)\n    bob = UnionFind(n)\n    requiredEdges = 0\n\n    for type, u, v in sorted(edges, reverse=True):\n      u -= 1\n      v -= 1\n      if type == 3:\n        if alice.unionByRank(u, v) | bob.unionByRank(u, v):\n          requiredEdges += 1\n      elif type == 2:\n        if bob.unionByRank(u, v):\n          requiredEdges += 1\n      else:\n        if alice.unionByRank(u, v):\n          requiredEdges += 1\n\n    if alice.count == 1 and bob.count == 1:\n        return len(edges) - requiredEdges\n    else:\n        return -1\n", "tests": [{"start": 20, "end": 21, "test": "```\ndef test_maxNumEdgesToRemove():\n    solution = Solution()\n    assert solution.maxNumEdgesToRemove(2, [[1, 0, 1], [3, 1, 1]]) == -1\n```"}, {"start": 22, "end": 23, "test": "```\ndef test_maxNumEdgesToRemove():\n    solution=Solution()\n    assert solution.maxNumEdgesToRemove(3, [[1,0,1],[2,2,3],[3,1,2]]) == 1\n```"}, {"start": 33, "end": 34, "test": "```\ndef test_maxNumEdgesToRemove():\n    solution=Solution()\n    assert solution.maxNumEdgesToRemove(2, [[1,0,1],[2,1,1]]) == 1\n```"}, {"start": 57, "end": 58, "test": "```\ndef test_maxNumEdgesToRemove():\n    solution = Solution()\n    assert solution.maxNumEdgesToRemove(3, [[0, 1, 2], [1, 2, 0]]) == 1\n```"}, {"start": 59, "end": 60, "test": "```\ndef test_maxNumEdgesToRemove():\n    solution = Solution()\n    assert solution.maxNumEdgesToRemove(3, [[2, 0, 1], [3, 1, 2]]) == -1\n```"}, {"start": 24, "end": 25, "test": "```\ndef test_maxNumEdgesToRemove():\n    solution=Solution()\n    assert solution.maxNumEdgesToRemove(3, [[1,0,1],[2,2,0],[3,1,2]]) == 1\n```"}, {"start": 26, "end": 28, "test": "```\ndef test_maxNumEdgesToRemove():\n    solution=Solution()\n    assert solution.maxNumEdgesToRemove(3, [[0, 1, 2], [1, 2, 0]]) == 1\n```"}, {"start": 47, "end": 49, "test": "def test_maxNumEdgesToRemove(): \n    solution = Solution() \n    assert solution.maxNumEdgesToRemove(3, [[0, 1, 2], [1, 2, 0]]) == 1"}, {"start": 48, "end": 49, "test": "```\ndef test_maxNumEdgesToRemove():\n    solution=Solution()\n    assert solution.maxNumEdgesToRemove(3, [[0, 1, 2], [1, 2, 0]]) == 1\n```"}, {"start": 50, "end": 53, "test": "```\ndef test_maxNumEdgesToRemove():\n    solution = Solution()\n    assert solution.maxNumEdgesToRemove(3, [[2,0,1],[3,1,2]]) == 1\n```"}, {"start": 51, "end": 52, "test": "```\ndef test_maxNumEdgesToRemove():\n    solution=Solution()\n    assert solution.maxNumEdgesToRemove(3, [[2,0,1],[3,1,2]]) == 1\n```"}, {"start": 54, "end": 55, "test": "```\ndef test_maxNumEdgesToRemove():\n    solution = Solution()\n    assert solution.maxNumEdgesToRemove(3, [[2,0,1],[3,1,2]]) == 1\n```"}]}
{"task_num": 1582, "task_title": "Special Positions in a Binary Matrix", "func_name": "numSpecial", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numSpecial(self, mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    ans = 0\n    rowOnes = [0] * m\n    colOnes = [0] * n\n\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j] == 1:\n          rowOnes[i] += 1\n          colOnes[j] += 1\n\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j] == 1 and rowOnes[i] == 1 and colOnes[j] == 1:\n          ans += 1\n\n    return ans\n", "tests": [{"start": 21, "end": 23, "test": "def test_numSpecial(): \n    solution = Solution() \n    mat = [[0,1],[0,0]] \n    assert solution.numSpecial(mat) == 1"}, {"start": 27, "end": 28, "test": "def test_numSpecial(): \n    solution = Solution() \n    mat = [[0,1],[0,0]] \n    assert solution.numSpecial(mat) == 1"}]}
{"task_num": 1583, "task_title": "Count Unhappy Friends", "func_name": "unhappyFriends", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\n    ans = 0\n    matches = [0] * n\n    prefer = [{} for _ in range(n)]\n\n    for x, y in pairs:\n      matches[x] = y\n      matches[y] = x\n\n    for i in range(n):\n      for j in range(n - 1):\n        prefer[i][preferences[i][j]] = j\n\n    for x in range(n):\n      for u in prefer[x].keys():\n        y = matches[x]\n        v = matches[u]\n        if prefer[x][u] < prefer[x][y] and prefer[u][x] < prefer[u][v]:\n          ans += 1\n          break\n\n    return ans\n", "tests": [{"start": 29, "end": 31, "test": "```\ndef test_unhappyFriends():\n    def unhappyFriends(n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\n        solution = Solution()\n        return solution.unhappyFriends(n, preferences, pairs)\n    \n    assert unhappyFriends(4, [[1, 2, 3], [0, 1, 2], [2, 3, 0], [1, 0]], [[0, 1], [2, 3]]) == 1\n```"}]}
{"task_num": 1591, "task_title": "Strange Printer II", "func_name": "isPrintable", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import Enum\n\n\nclass State(Enum):\n  kInit = 0\n  kVisiting = 1\n  kVisited = 2\n\n\nclass Solution:\n  def isPrintable(self, targetGrid: List[List[int]]) -> bool:\n    kMaxColor = 60\n    m = len(targetGrid)\n    n = len(targetGrid[0])\n\n    graph = [set() for _ in range(kMaxColor + 1)]\n\n    for color in range(1, kMaxColor + 1):\n      minI = m\n      minJ = n\n      maxI = -1\n      maxJ = -1\n      for i in range(m):\n        for j in range(n):\n          if targetGrid[i][j] == color:\n            minI = min(minI, i)\n            minJ = min(minJ, j)\n            maxI = max(maxI, i)\n            maxJ = max(maxJ, j)\n\n      for i in range(minI, maxI + 1):\n        for j in range(minJ, maxJ + 1):\n          if targetGrid[i][j] != color:\n            graph[color].add(targetGrid[i][j])\n\n    states = [State.kInit] * (kMaxColor + 1)\n\n    def hasCycle(u: int) -> bool:\n      if states[u] == State.kVisiting:\n        return True\n      if states[u] == State.kVisited:\n        return False\n\n      states[u] = State.kVisiting\n      if any(hasCycle(v) for v in graph[u]):\n        return True\n      states[u] = State.kVisited\n\n      return False\n\n    for i in range(1, kMaxColor + 1):\n      if hasCycle(i):\n        return False\n    return True\n", "tests": [{"start": 49, "end": 50, "test": "```\ndef test_isPrintable():\n    def isPrintable(targetGrid):\n        solution = Solution()\n        return solution.isPrintable([[1, 0], [2, 0]])\n```"}, {"start": 51, "end": 52, "test": "```\ndef test_isPrintable():\n    solution = Solution()\n    assert not solution.isPrintable([[1, 2], [3, 4]])"}, {"start": 55, "end": 56, "test": "```\ndef test_isPrintable():\n    solution = Solution()\n    assert not solution.isPrintable([[1, 0], [2, 0]])"}, {"start": 62, "end": 63, "test": "```\ndef test_isPrintable():\n    solution = Solution()\n    assert not solution.isPrintable([[1, 2], [3, 4]])"}, {"start": 35, "end": 39, "test": "def test_isPrintable(): \n    solution=Solution() \n    assert not solution.isPrintable([[1, 2], [3, 4]])"}, {"start": 43, "end": 44, "test": "```\ndef test_isPrintable():\n    solution = Solution()\n    assert not solution.isPrintable([[1, 2], [3, 4]])"}]}
{"task_num": 1604, "task_title": "Alert Using Same Key-Card Three or More Times in a One Hour Period", "func_name": "alertNames", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n    nameToMinutes = collections.defaultdict(list)\n\n    for name, time in zip(keyName, keyTime):\n      minutes = self._getMinutes(time)\n      nameToMinutes[name].append(minutes)\n\n    res=[]\n    for name, minutes in nameToMinutes.items():\n      if self._hasAlert(minutes):\n        res.append(name)\n    return sorted(res)\n\n  def _hasAlert(self, minutes: List[int]) -> bool:\n    if len(minutes) > 70:\n      return True\n    minutes.sort()\n    for i in range(2, len(minutes)):\n      if minutes[i - 2] + 60 >= minutes[i]:\n        return True\n    return False\n\n  def _getMinutes(self, time: str) -> int:\n    h, m = map(int, time.split(':'))\n    return 60 * h + m\n", "tests": [{"start": 26, "end": 27, "test": "```\ndef test_alertNames():\n    solution=Solution()\n    assert solution.alertNames([\"John\", \"John\", \"John\", \"Alice\"], [\"09:00\", \"09:05\", \"09:15\", \"10:30\"]) == [\"John\"]\n```"}, {"start": 21, "end": 22, "test": "```\ndef test_alertNames():\n    solution=Solution()\n    def test_case():\n        keyName = [\"John\", \"John\", \"John\", \"Alice\"]\n        keyTime = [\"09:01\", \"09:05\", \"09:10\", \"11:00\"]\n        result = solution.alertNames(keyName, keyTime)\n        return result == [\"John\"]\n    assert test_case() is True"}, {"start": 30, "end": 31, "test": "```\ndef test_alertNames():\n    solution = Solution()\n    assert solution.alertNames([\"LeetCode\", \"LeetCode\", \"LeetCode\"], [\"23:51\", \"09:49\", \"11:02\"]) == [\"LeetCode\"]"}]}
{"task_num": 1615, "task_title": "Maximal Network Rank", "func_name": "maximalNetworkRank", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\n    degrees = [0] * n\n\n    for u, v in roads:\n      degrees[u] += 1\n      degrees[v] += 1\n\n    maxDegree1 = 0\n    maxDegree2 = 0\n    for degree in degrees:\n      if degree > maxDegree1:\n        maxDegree2 = maxDegree1\n        maxDegree1 = degree\n      elif degree > maxDegree2:\n        maxDegree2 = degree\n\n    countMaxDegree1 = 0\n    countMaxDegree2 = 0\n    for degree in degrees:\n      if degree == maxDegree1:\n        countMaxDegree1 += 1\n      elif degree == maxDegree2:\n        countMaxDegree2 += 1\n\n    if countMaxDegree1 == 1:\n      edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree2) + self._getEdgeCount(roads, degrees, maxDegree2, maxDegree1)\n      return maxDegree1 + maxDegree2 - (countMaxDegree2 == edgeCount)\n    else:\n      edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree1)\n      maxPossibleEdgeCount = countMaxDegree1 * (countMaxDegree1 - 1) // 2\n      return 2 * maxDegree1 - (maxPossibleEdgeCount == edgeCount)\n\n  def _getEdgeCount(self, roads: List[List[int]], degrees: List[int], degreeU: int, degreeV: int) -> int:\n    edgeCount = 0\n    for u, v in roads:\n      if degrees[u] == degreeU and degrees[v] == degreeV:\n        edgeCount += 1\n    return edgeCount\n", "tests": [{"start": 36, "end": 38, "test": "```\ndef test_maximalNetworkRank():\n    solution = Solution()\n    roads = [[0, 1], [1, 2], [2, 3]]\n    assert solution.maximalNetworkRank(4, roads) == 4\n```"}, {"start": 39, "end": 42, "test": "```\ndef test_maximalNetworkRank():\n    solution = Solution()\n    assert solution.maximalNetworkRank(3, [[0, 1], [1, 2]]) == 4\n```"}, {"start": 22, "end": 24, "test": "```\ndef test_maximalNetworkRank():\n    solution=Solution()\n    assert solution.maximalNetworkRank(3, [[0, 1], [1, 2]]) == 4\n```"}, {"start": 31, "end": 32, "test": "```\ndef test_maximalNetworkRank():\n    solution = Solution()\n    assert solution.maximalNetworkRank(3, [[0, 1], [1, 2]]) == 4\n```"}, {"start": 47, "end": 48, "test": "```\ndef test_maximalNetworkRank():\n    solution = Solution()\n    assert solution.maximalNetworkRank(3, [[0, 1], [1, 2]]) == 4\n```"}, {"start": 25, "end": 26, "test": "```\ndef test_maximalNetworkRank():\n    solution=Solution()\n    assert solution.maximalNetworkRank(3, [[0,1],[1,2]]) == 4\n```"}, {"start": 33, "end": 34, "test": "```\ndef test_maximalNetworkRank():\n    solution = Solution()\n    assert solution.maximalNetworkRank(3, [[0,1],[1,2]]) == 4\n```"}]}
{"task_num": 1616, "task_title": "Split Two Strings to Make Palindrome", "func_name": "checkPalindromeFormation", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def checkPalindromeFormation(self, a: str, b: str) -> bool:\n    return self._check(a, b) or self._check(b, a)\n\n  def _check(self, a: str, b: str) -> bool:\n    i, j = 0, len(a) - 1\n    while i < j:\n      if a[i] != b[j]:\n        return self._isPalindrome(a, i, j) or self._isPalindrome(b, i, j)\n      i += 1\n      j -= 1\n    return True\n\n  def _isPalindrome(self, s: str, i: int, j: int) -> bool:\n    while i < j:\n      if s[i] != s[j]:\n        return False\n      i += 1\n      j -= 1\n    return True\n", "tests": [{"start": 18, "end": 19, "test": "```\ndef test_checkPalindromeFormation():\n    solution = Solution()\n    assert not solution.checkPalindromeFormation(\"abc\", \"cba\")"}, {"start": 26, "end": 27, "test": "```\ndef test_checkPalindromeFormation():\n    solution = Solution()\n    assert not solution.checkPalindromeFormation(\"abc\", \"cba\")"}]}
{"task_num": 1617, "task_title": "Count Subtrees With Max Distance Between Cities", "func_name": "countSubgraphsForEachDiameter", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:\n    maxMask = 1 << n\n    dist = self._floydWarshall(n, edges)\n    ans = [0] * (n - 1)\n\n    for mask in range(maxMask):\n      maxDist = self._getMaxDist(mask, dist, n)\n      if maxDist > 0:\n        ans[maxDist - 1] += 1\n\n    return ans\n\n  def _floydWarshall(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n    dist = [[n] * n for _ in range(n)]\n\n    for i in range(n):\n      dist[i][i] = 0\n\n    for u, v in edges:\n      dist[u - 1][v - 1] = 1\n      dist[v - 1][u - 1] = 1\n\n    for k in range(n):\n      for i in range(n):\n        for j in range(n):\n          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    return dist\n\n  def _getMaxDist(self, mask: int, dist: List[List[int]], n: int) -> int:\n    maxDist = 0\n    edgeCount = 0\n    cityCount = 0\n    for u in range(n):\n      if (mask >> u) & 1 == 0:\n        continue\n      cityCount += 1\n      for v in range(u + 1, n):\n        if (mask >> v) & 1 == 0:\n          continue\n        if dist[u][v] == 1:\n          edgeCount += 1\n        maxDist = max(maxDist, dist[u][v])\n\n    if edgeCount == cityCount - 1:\n      return maxDist\n    else:\n      return 0\n", "tests": [{"start": 56, "end": 57, "test": "```\ndef test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    result = solution.countSubgraphsForEachDiameter(3, [[1, 2], [2, 3]])\n    assert result == [0, 1]\n```"}, {"start": 58, "end": 59, "test": "```\ndef test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    assert solution.countSubgraphsForEachDiameter(3, [[1,2],[2,3]]) == [0], \n```"}, {"start": 19, "end": 20, "test": "```\ndef test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    assert solution.countSubgraphsForEachDiameter(3, [[1,2],[2,3]]) == [0, 1], None\n```"}, {"start": 46, "end": 47, "test": "```\ndef test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    result = solution.countSubgraphsForEachDiameter(3, [[1, 2], [2, 3]])\n    assert result == [0, 1]\n```"}, {"start": 50, "end": 51, "test": "```\ndef test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    result = solution.countSubgraphsForEachDiameter(3, [[1, 2], [2, 3]])\n    assert result == [0, 1]\n```"}, {"start": 52, "end": 53, "test": "```\ndef test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    assert solution.countSubgraphsForEachDiameter(3, [[1,2],[2,3]]) == [0, 1], None\n```"}]}
{"task_num": 1627, "task_title": "Graph Connectivity With Threshold", "func_name": "areConnected", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def areConnected(self, n: int, threshold: int, queries: List[List[int]]) -> List[bool]:\n    uf = UnionFind(n + 1)\n\n    for z in range(threshold + 1, n + 1):\n      for x in range(z * 2, n + 1, z):\n        uf.unionByRank(z, x)\n\n    return [uf.find(a) == uf.find(b) for a, b in queries]\n", "tests": [{"start": 19, "end": 20, "test": "```\ndef test_areConnected():\n    solution = Solution()\n    assert not solution.areConnected(2, 1, [[1, 2]]), None"}, {"start": 21, "end": 22, "test": "```\ndef test_areConnected():\n    solution=Solution()\n    assert [True] == solution.areConnected(5, 2, [[1,4],[2,3],[4,5]]), None\n```"}, {"start": 31, "end": 32, "test": "```\ndef test_areConnected():\n    solution=Solution()\n    assert solution.areConnected(5, 2, [[1,4],[2,3],[5,4],[4,3]]) == [True,True,False]\n```"}, {"start": 23, "end": 24, "test": "```\ndef test_areConnected():\n    solution=Solution()\n    assert [True] == solution.areConnected(5, 2, [[1,4],[2,3],[4,5]]), None\n```"}, {"start": 25, "end": 27, "test": "```\ndef test_areConnected():\n    solution=Solution()\n    assert [True] == solution.areConnected(5, 2, [[1,4],[2,3],[4,5]]), f\"Expected areConnected(5, 2, [[1,4],[2,3],[4,5]]) to return [True], but got {solution.areConnected(5, 2, [[1,4],[2,3],[4,5]])}\"\n```"}]}
{"task_num": 1631, "task_title": "Path With Minimum Effort", "func_name": "minimumEffortPath", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumEffortPath(self, heights: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(heights)\n    n = len(heights[0])\n    diff = [[math.inf] * n for _ in range(m)]\n    seen = set()\n\n    minHeap = [(0, 0, 0)]\n    diff[0][0] = 0\n\n    while minHeap:\n      d, i, j = heapq.heappop(minHeap)\n      if i == m - 1 and j == n - 1:\n        return d\n      seen.add((i, j))\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if (x, y) in seen:\n          continue\n        newDiff = abs(heights[i][j] - heights[x][y])\n        maxDiff = max(diff[i][j], newDiff)\n        if diff[x][y] > maxDiff:\n          diff[x][y] = maxDiff\n          heapq.heappush(minHeap, (diff[x][y], x, y))\n", "tests": [{"start": 24, "end": 25, "test": "def test_minimumEffortPath():    \n    solution = Solution()    \n    assert solution.minimumEffortPath([[1,2,3],[5,4,1]]) == 1"}, {"start": 30, "end": 31, "test": "```\ndef test_minimumEffortPath():\n    solution = Solution()\n    heights = [[1,2,3],[4,5,6]]\n    assert solution.minimumEffortPath(heights) == 1\n```"}, {"start": 32, "end": 33, "test": "```\ndef test_minimumEffortPath():\n    solution = Solution()\n    heights = [[1, 2, 3], [5, 6, 4]]\n    assert solution.minimumEffortPath(heights) == 1\n```"}, {"start": 36, "end": 38, "test": "```\ndef test_minimumEffortPath():\n    solution=Solution()\n    assert solution.minimumEffortPath([[1,2,3],[4,5,6]]) == 1\n```"}]}
{"task_num": 1632, "task_title": "Rank Transform of a Matrix", "func_name": "matrixRankTransform", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self):\n    self.id = {}\n\n  def union(self, u: int, v: int) -> None:\n    self.id.setdefault(u, u)\n    self.id.setdefault(v, v)\n    i = self._find(u)\n    j = self._find(v)\n    if i != j:\n      self.id[i] = j\n\n  def getGroupIdToValues(self) -> Dict[int, List[int]]:\n    groupIdToValues = collections.defaultdict(list)\n    for u in self.id.keys():\n      groupIdToValues[self._find(u)].append(u)\n    return groupIdToValues\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def matrixRankTransform(self, matrix: List[List[int]]) -> List[List[int]]:\n    m = len(matrix)\n    n = len(matrix[0])\n    ans = [[0] * n for _ in range(m)]\n    valToGrids = collections.defaultdict(list)\n    maxRankSoFar = [0] * (m + n)\n\n    for i, row in enumerate(matrix):\n      for j, val in enumerate(row):\n        valToGrids[val].append((i, j))\n\n    for _, grids in sorted(valToGrids.items()):\n      uf = UnionFind()\n      for i, j in grids:\n        uf.union(i, j + m)\n      for values in uf.getGroupIdToValues().values():\n        maxRank = max(maxRankSoFar[i] for i in values)\n        for i in values:\n          maxRankSoFar[i] = maxRank + 1\n      for i, j in grids:\n        ans[i][j] = maxRankSoFar[i]\n\n    return ans\n", "tests": [{"start": 20, "end": 21, "test": "```\ndef test_matrixRankTransform():\n    solution=Solution()\n    matrix = [[1, 2], [3, 4]]\n    expected = [[1, 1], [2, 2]]\n    assert solution.matrixRankTransform(matrix) == expected\n```"}, {"start": 30, "end": 31, "test": "```\ndef test_matrixRankTransform():\n    solution=Solution()\n    matrix = [[1, 2], [3, 4]]\n    expected = [[1, 1], [2, 2]]\n    assert solution.matrixRankTransform(matrix) == expected\n```"}]}
{"task_num": 1654, "task_title": "Minimum Jumps to Reach Home", "func_name": "minimumJumps", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import Enum\n\n\nclass Direction(Enum):\n  kForward = 0\n  kBackward = 1\n\n\nclass Solution:\n  def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\n    furthest = max(x + a + b, max(pos + a + b for pos in forbidden))\n    seenForward = {pos for pos in forbidden}\n    seenBackward = {pos for pos in forbidden}\n\n    q = collections.deque([(Direction.kForward, 0)])\n\n    ans = 0\n    while q:\n      for _ in range(len(q)):\n        dir, pos = q.popleft()\n        if pos == x:\n          return ans\n        forward = pos + a\n        backward = pos - b\n        if forward <= furthest and forward not in seenForward:\n          seenForward.add(forward)\n          q.append((Direction.kForward, forward))\n        if dir == Direction.kForward and backward >= 0 and backward not in seenBackward:\n          seenBackward.add(backward)\n          q.append((Direction.kBackward, backward))\n      ans += 1\n\n    return -1\n", "tests": [{"start": 31, "end": 32, "test": "def test_minimumJumps():    \n    solution = Solution()    \n    assert solution.minimumJumps([1, 2], 3, 1, 4) == 2"}, {"start": 35, "end": 37, "test": "```\ndef test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([1], 2, 1, 3) == 3\n```"}, {"start": 38, "end": 40, "test": "```\ndef test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([1], 2, 1, 3) == 3\n```"}]}
{"task_num": 1655, "task_title": "Distribute Repeating Integers", "func_name": "canDistribute", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\n    freqs = list(collections.Counter(nums).values())\n    validDistribution = self._getValidDistribution(freqs, quantity)\n    n = len(freqs)\n    m = len(quantity)\n    maxMask = 1 << m\n    dp = [[False] * maxMask for _ in range(n + 1)]\n    dp[n][maxMask - 1] = True\n\n    for i in range(n - 1, -1, -1):\n      for mask in range(maxMask):\n        dp[i][mask] = dp[i + 1][mask]\n        availableMask = ~mask & (maxMask - 1)\n        submask = availableMask\n        while submask > 0:\n          if validDistribution[i][submask]:\n            dp[i][mask] = dp[i][mask] or dp[i + 1][mask | submask]\n          submask = (submask - 1) & availableMask\n\n    return dp[0][0]\n\n  def _getValidDistribution(self, freqs: List[int], quantity: List[int]) -> List[List[bool]]:\n    maxMask = 1 << len(quantity)\n    validDistribution = [[False] * maxMask for _ in range(len(freqs))]\n    for i, freq in enumerate(freqs):\n      for mask in range(maxMask):\n        if freq >= self._getQuantitySum(quantity, mask):\n          validDistribution[i][mask] = True\n    return validDistribution\n\n  def _getQuantitySum(self, quantity: List[int], mask: int) -> int:\n    res=[]\n    for i, q in enumerate(quantity):\n      if mask >> i & 1:\n        res.append(q)\n    return sum(res)\n", "tests": [{"start": 45, "end": 46, "test": "```\ndef test_canDistribute():\n    solution = Solution()\n    assert not solution.canDistribute([1, 2, 3], [1, 0]), None\n```"}, {"start": 38, "end": 39, "test": "```\ndef test_canDistribute():\n    solution=Solution()\n    assert not solution.canDistribute([1, 2, 3], [1, 1])\n```"}, {"start": 27, "end": 28, "test": "```\ndef test_canDistribute():\n    solution=Solution()\n    assert not solution.canDistribute([1,2,3], [1,0]), None\n```"}]}
{"task_num": 1681, "task_title": "Minimum Incompatibility", "func_name": "minimumIncompatibility", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def __init__(self):\n    self.kMaxNum = 16\n\n  def minimumIncompatibility(self, nums: List[int], k: int) -> int:\n    kMaxCompatibility = (16 - 1) * (16 // 2)\n    n = len(nums)\n    subsetSize = n // k\n    maxMask = 1 << n\n    incompatibilities = self._getIncompatibilities(nums, subsetSize)\n\n    dp = [kMaxCompatibility] * maxMask\n    dp[0] = 0\n\n    for mask in range(1, maxMask):\n      if mask.bit_count() % subsetSize != 0:\n        continue\n      submask = mask\n      while submask > 0:\n        if incompatibilities[submask] != -1:\n          dp[mask] = min(dp[mask], dp[mask - submask] + incompatibilities[submask])\n        submask = (submask - 1) & mask\n\n    if dp[-1] != kMaxCompatibility:\n      return dp[-1]\n    else:\n      return -1\n\n  def _getIncompatibilities(self, nums: List[int], subsetSize: int) -> List[int]:\n    maxMask = 1 << len(nums)\n    incompatibilities = [-1] * maxMask\n    for mask in range(maxMask):\n      if mask.bit_count() == subsetSize and self._isUnique(nums, mask, subsetSize):\n        incompatibilities[mask] = self._getIncompatibility(nums, mask)\n    return incompatibilities\n\n  def _isUnique(self, nums: List[int], mask: int, subsetSize: int) -> bool:\n    used = 0\n    for i, num in enumerate(nums):\n      if mask >> i & 1:\n        used |= 1 << num\n    return used.bit_count() == subsetSize\n\n  def _getIncompatibility(self, nums: List[int], mask: int) -> int:\n    mini = self.kMaxNum\n    maxi = 0\n    for i, num in enumerate(nums):\n      if mask >> i & 1:\n        maxi = max(maxi, num)\n        mini = min(mini, num)\n    return maxi - mini\n", "tests": [{"start": 34, "end": 35, "test": "```\ndef test_minimumIncompatibility():\n    def solution_test(nums, k):\n        solution = Solution()\n        return solution.minimumIncompatibility(nums, k)\n\n    assert solution_test([1, 2, 3, 4], 2) == 0\n```"}, {"start": 36, "end": 37, "test": "```\ndef test_minimumIncompatibility():\n    def assert_equal(actual, expected):\n        if actual != expected:\n            raise AssertionError(f\"Expected {expected}, but got {actual}\")\n    \n    solution = Solution()\n    nums = [1, 2, 3, 4]\n    k = 2\n    result = solution.minimumIncompatibility(nums, k)\n    assert_equal(result, -1)"}, {"start": 26, "end": 27, "test": "```\ndef test_minimumIncompatibility():\n    def assert_equal(actual, expected):\n        assert actual == expected\n\n    solution = Solution()\n    nums = [1, 2, 3, 4]\n    k = 2\n    result = solution.minimumIncompatibility(nums, k)\n    assert_equal(result, 2)"}, {"start": 43, "end": 44, "test": "```\ndef test_minimumIncompatibility():\n    solution=Solution()\n    assert solution.minimumIncompatibility([1, 2, 3, 4], 2) == 0\n```"}, {"start": 50, "end": 51, "test": "```\ndef test_minimumIncompatibility():\n    def assert_equal(actual, expected):\n        assert actual == expected\n    \n    solution = Solution()\n    nums = [3, 2, 5, 4]\n    k = 2\n    result = solution.minimumIncompatibility(nums, k)\n    assert_equal(result, 1)"}, {"start": 58, "end": 60, "test": "```\ndef test_minimumIncompatibility():\n    def test_case():\n        nums = [1, 2, 3, 4]\n        k = 2\n        return solution.minimumIncompatibility(nums, k)\n```"}, {"start": 30, "end": 31, "test": "```\ndef test_minimumIncompatibility():\n    solution=Solution()\n    assert solution.minimumIncompatibility([1, 2, 3, 4], 2) == 0\n```"}]}
{"task_num": 1687, "task_title": "Delivering Boxes from Storage to Ports", "func_name": "boxDelivering", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\n    n = len(boxes)\n    dp = [0] * (n + 1)\n    trips = 2\n    weight = 0\n\n    l = 0\n    for r in range(n):\n      weight += boxes[r][1]\n\n      if r > 0 and boxes[r][0] != boxes[r - 1][0]:\n        trips += 1\n\n      while r - l + 1 > maxBoxes or weight > maxWeight or (l < r and dp[l + 1] == dp[l]):\n        weight -= boxes[l][1]\n        if boxes[l][0] != boxes[l + 1][0]:\n          trips -= 1\n        l += 1\n\n      dp[r + 1] = dp[l] + trips\n\n    return dp[n]\n", "tests": [{"start": 22, "end": 23, "test": "```\ndef test_boxDelivering():\n    solution = Solution()\n    assert solution.boxDelivering([[1, 2], [1, 3], [2, 4]], 2, 2, 5) == 3\n```"}, {"start": 27, "end": 28, "test": "```\ndef test_boxDelivering():\n    solution = Solution()\n    assert solution.boxDelivering([[1, 2], [1, 3], [2, 4]], 2, 2, 5) == 3\n```"}]}
{"task_num": 1705, "task_title": "Maximum Number of Eaten Apples", "func_name": "eatenApples", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def eatenApples(self, apples: List[int], days: List[int]) -> int:\n    n = len(apples)\n    ans = 0\n    minHeap = []\n\n    i = 0\n    while i < n or minHeap:\n      while minHeap and minHeap[0][0] <= i:\n        heapq.heappop(minHeap)\n      if i < n and apples[i] > 0:\n        heapq.heappush(minHeap, (i + days[i], apples[i]))\n      if minHeap:\n        rottenDay, numApples = heapq.heappop(minHeap)\n        if numApples > 1:\n          heapq.heappush(minHeap, (rottenDay, numApples - 1))\n        ans += 1\n      i += 1\n\n    return ans\n", "tests": [{"start": 21, "end": 22, "test": "def test_eatenApples(): \n    solution = Solution() \n    assert solution.eatenApples([1, 2, 0, 5], [3, 2, 0, 4]) == 7"}, {"start": 23, "end": 27, "test": "def test_eatenApples(): \n    solution = Solution() \n    assert solution.eatenApples([1,2,3], [0,1,2]) == 5"}, {"start": 25, "end": 26, "test": "def test_eatenApples(): \n    def solution(apples: List[int], days: List[int]) -> int:\n        return solution([2, 0, 1], [4, 3, 2])"}]}
{"task_num": 1706, "task_title": "Where Will the Ball Fall", "func_name": "findBall", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findBall(self, grid: List[List[int]]) -> List[int]:\n    m = len(grid)\n    n = len(grid[0])\n    dp = [i for i in range(n)]\n    ans = [-1] * n\n\n    for i in range(m):\n      newDp = [-1] * n\n      for j in range(n):\n        if j + grid[i][j] < 0 or j + grid[i][j] == n:\n          continue\n        if grid[i][j] == 1 and grid[i][j + 1] == -1 or grid[i][j] == -1 and grid[i][j - 1] == 1:\n          continue\n        newDp[j + grid[i][j]] = dp[j]\n      dp = newDp\n\n    for i, ball in enumerate(dp):\n      if ball != -1:\n        ans[ball] = i\n\n    return ans\n", "tests": [{"start": 29, "end": 30, "test": "def test_findBall():    \n    solution=Solution()    \n    assert solution.findBall([[1,1,1,-1,1],[-1,1],[-1,1,1,1,1,1]]) == [2, 1]"}, {"start": 21, "end": 22, "test": "def test_findBall():    \n    solution = Solution()    \n    assert solution.findBall([[1,1,1,-1,1],[-1,1],[-1,1,1,1,1,1]]) == [0, 2, -1],"}, {"start": 23, "end": 24, "test": "def test_findBall(): \n    solution = Solution() \n    assert solution.findBall([[1,1,1,-1,1],[-1,1],[-1,1,1,1]]) == [0, 2]"}]}
{"task_num": 1707, "task_title": "Maximum XOR With an Element From Array", "func_name": "maximizeXor", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Optional\n\nclass TrieNode:\n  def __init__(self):\n    self.children: List[Optional[TrieNode]] = [None] * 2\n\n\nclass BitTrie:\n  def __init__(self, maxBit: int):\n    self.maxBit = maxBit\n    self.root = TrieNode()\n\n  def insert(self, num: int) -> None:\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n\n  def getMaxXor(self, num: int) -> int:\n    maxXor = 0\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      toggleBit = bit ^ 1\n      if node.children[toggleBit]:\n        maxXor = maxXor | 1 << i\n        node = node.children[toggleBit]\n      elif node.children[bit]:\n        node = node.children[bit]\n      else:\n        return 0\n    return maxXor\n\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, x: int, m: int):\n    self.queryIndex = queryIndex\n    self.x = x\n    self.m = m\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.x\n    yield self.m\n\n\nclass Solution:\n  def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n    ans = [-1] * len(queries)\n    maxBit = int(math.log2(max(max(nums), max(x for x, _ in queries))))\n    bitTrie = BitTrie(maxBit)\n\n    nums.sort()\n\n    i = 0\n    for queryIndex, x, m in sorted([IndexedQuery(i, x, m) for i, (x, m) in enumerate(queries)], key=lambda iq: iq.m):\n      while i < len(nums) and nums[i] <= m:\n        bitTrie.insert(nums[i])\n        i += 1\n      if i > 0 and nums[i - 1] <= m:\n        ans[queryIndex] = bitTrie.getMaxXor(x)\n\n    return ans\n", "tests": [{"start": 25, "end": 26, "test": "```\ndef test_maximizeXor():\n    solution=Solution()\n    assert solution.maximizeXor([0,1,2], [[3,5],[7,10]]) == [14, 11]\n```"}, {"start": 35, "end": 37, "test": "```\ndef test_maximizeXor():\n    solution=Solution()\n    assert solution.maximizeXor([0, 1, 2], [[5, 6], [11, 3]]) == [5, -1]\n```"}, {"start": 70, "end": 71, "test": "```\ndef test_maximizeXor():\n    solution=Solution()\n    assert solution.maximizeXor([0,1,2], [[5,6],[13,9]]) == [4,7]\n```"}, {"start": 38, "end": 39, "test": "def test_maximizeXor(): \n    solution=Solution() \n    nums=[0,1,2,3] \n    queries=[[6,1],[4,3]] \n    assert solution.maximizeXor(nums,queries) == [8,2], \"Test failed\""}, {"start": 40, "end": 41, "test": "```\ndef test_maximizeXor():\n    solution = Solution()\n    assert solution.maximizeXor([2,3,5], [[5,2],[1,4]]) == [7, 0]\n```"}]}
{"task_num": 1717, "task_title": "Maximum Score From Removing Substrings", "func_name": "maximumGain", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumGain(self, s: str, x: int, y: int) -> int:\n    if x > y:\n      return self._gain(s, 'ab', x, 'ba', y)\n    else:\n      return self._gain(s, 'ba', y, 'ab', x)\n\n  def _gain(self, s: str, sub1: str, point1: int, sub2: str, point2: int) -> int:\n    points = 0\n    stack1 = []\n    stack2 = []\n\n    for c in s:\n      if stack1 and stack1[-1] == sub1[0] and c == sub1[1]:\n        stack1.pop()\n        points += point1\n      else:\n        stack1.append(c)\n\n    for c in stack1:\n      if stack2 and stack2[-1] == sub2[0] and c == sub2[1]:\n        stack2.pop()\n        points += point2\n      else:\n        stack2.append(c)\n\n    return points\n", "tests": [{"start": 13, "end": 14, "test": "```\ndef test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain(\"aba\", 2, 1) == 4\n```"}, {"start": 15, "end": 16, "test": "```\ndef test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain(\"cabxbae\", 2, 3) == 6\n```"}, {"start": 24, "end": 26, "test": "```\ndef test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain(\"abababa\", 2, 3) == 6\n```"}, {"start": 27, "end": 28, "test": "```\ndef test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain(\"abba\", 3, 2) == 9\n```"}, {"start": 31, "end": 33, "test": "```\ndef test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain(\"abba\", 3, 2) == 9\n```"}, {"start": 34, "end": 35, "test": "```\ndef test_maximumGain():\n    def assert_equal(actual, expected):\n        if actual != expected:\n            raise AssertionError(f\"Expected {expected}, but got {actual}\")\n    \n    solution = Solution()\n    s = \"abba\"\n    x = 2\n    y = 1\n    result = solution.maximumGain(s, x, y)\n    assert_equal(result, 4)"}]}
{"task_num": 1719, "task_title": "Number Of Ways To Reconstruct A Tree", "func_name": "checkWays", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def checkWays(self, pairs: List[List[int]]) -> int:\n    kMax = 501\n    graph = collections.defaultdict(list)\n    degrees = [0] * kMax\n    connected = [[False] * kMax for _ in range(kMax)]\n\n    for u, v in pairs:\n      graph[u].append(v)\n      graph[v].append(u)\n      degrees[u] += 1\n      degrees[v] += 1\n      connected[u][v] = True\n      connected[v][u] = True\n\n    for _, children in graph.items():\n      children.sort(key=lambda a: degrees[a], reverse=True)\n\n    root = next((i for i, d in enumerate(degrees) if d == len(graph) - 1), -1)\n    if root == -1:\n      return 0\n\n    hasMoreThanOneWay = False\n\n    def dfs(u: int, ancestors: List[int], seen: List[bool]) -> bool:\n      nonlocal hasMoreThanOneWay\n      seen[u] = True\n      for ancestor in ancestors:\n        if not connected[u][ancestor]:\n          return False\n      ancestors.append(u)\n      for v in graph[u]:\n        if seen[v]:\n          continue\n        if degrees[v] == degrees[u]:\n          hasMoreThanOneWay = True\n        if not dfs(v, ancestors, seen):\n          return False\n      ancestors.pop()\n      return True\n\n    if not dfs(root, [], [False] * kMax):\n      return 0\n    if hasMoreThanOneWay:\n      return 2\n    else:\n      return 1\n", "tests": [{"start": 30, "end": 31, "test": "def test_checkWays():    \n    solution = Solution()    \n    assert solution.checkWays([[1,2],[2,3]]) == 0"}, {"start": 52, "end": 53, "test": "```\ndef test_checkWays():\n    solution = Solution()\n    assert solution.checkWays([[1,2],[2,3],[3,4]]) == 1\n```"}, {"start": 54, "end": 55, "test": "def test_checkWays():    \n    solution = Solution()    \n    assert solution.checkWays([[0,1],[1,2],[2,3]]) == 2"}, {"start": 56, "end": 57, "test": "```\ndef test_checkWays():\n    def checkWays(pairs):\n        pass\n```"}, {"start": 39, "end": 40, "test": "def test_checkWays(): \n    solution = Solution() \n    assert solution.checkWays([[1, 2], [2, 3]]) == 1"}, {"start": 43, "end": 44, "test": "```\ndef test_checkWays():\n    solution = Solution()\n    assert solution.checkWays([[1, 2], [2, 3], [3, 4]]) == 1\n```"}, {"start": 45, "end": 46, "test": "```\ndef test_checkWays():\n    solution=Solution()\n    assert solution.checkWays([[0,1],[1,2],[2,3]]) == 2\n```"}, {"start": 47, "end": 48, "test": "def test_checkWays():    \n    solution = Solution()    \n    assert solution.checkWays([[0, 1], [1, 2], [2, 3]]) == 2"}]}
{"task_num": 1722, "task_title": "Minimize Hamming Distance After Swap Operations", "func_name": "minimumHammingDistance", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -> int:\n    n = len(source)\n    ans = 0\n    uf = UnionFind(n)\n    groupIdToCount = [collections.Counter() for _ in range(n)]\n\n    for a, b in allowedSwaps:\n      uf.unionByRank(a, b)\n\n    for i in range(n):\n      groupIdToCount[uf.find(i)][source[i]] += 1\n\n    for i in range(n):\n      groupId = uf.find(i)\n      count = groupIdToCount[groupId]\n      if target[i] not in count:\n        ans += 1\n      else:\n        count[target[i]] -= 1\n        if count[target[i]] == 0:\n          del count[target[i]]\n\n    return ans\n", "tests": [{"start": 19, "end": 20, "test": "```\ndef test_minimumHammingDistance():\n    solution=Solution()\n    assert solution.minimumHammingDistance([0, 1], [0, 1], [[0, 1]]) == 0\n```"}, {"start": 21, "end": 22, "test": "```\ndef test_minimumHammingDistance():\n    solution=Solution()\n    assert solution.minimumHammingDistance([0, 1], [0, 2], [[0, 1]]) == 1\n```"}, {"start": 30, "end": 31, "test": "```\ndef test_minimumHammingDistance():\n    solution=Solution()\n    assert solution.minimumHammingDistance([0, 2, 3], [1, 2, 2], [[0, 1]]) == 1\n```"}, {"start": 23, "end": 24, "test": "```\ndef test_minimumHammingDistance():\n    solution=Solution()\n    source=[0,1,2]\n    target=[2,1,0]\n    allowedSwaps=[[0,1],[1,2]]\n    assert solution.minimumHammingDistance(source, target, allowedSwaps) == 1\n```"}, {"start": 25, "end": 27, "test": "```\ndef test_minimumHammingDistance():\n    solution=Solution()\n    assert solution.minimumHammingDistance([0,2,3], [1,2,2], [[0, 1]]) == 1\n```"}, {"start": 51, "end": 52, "test": "```\ndef test_minimumHammingDistance():\n    solution=Solution()\n    assert solution.minimumHammingDistance([0,2,3], [1,2,2], [[0, 1]]) == 1\n```"}, {"start": 53, "end": 56, "test": "```\ndef test_minimumHammingDistance():\n    solution = Solution()\n    source = [1, 2, 3]\n    target = [1, 2, 4]\n    allowedSwaps = [[0, 1], [1, 2]]\n    assert solution.minimumHammingDistance(source, target, allowedSwaps) == 1"}, {"start": 55, "end": 56, "test": "```\ndef test_minimumHammingDistance():\n    solution = Solution()\n    source = [1, 2, 3]\n    target = [1, 2, 4]\n    allowedSwaps = [[0, 1], [1, 2]]\n    assert solution.minimumHammingDistance(source, target, allowedSwaps) == 1"}]}
{"task_num": 1735, "task_title": "Count Ways to Make Array With Product", "func_name": "waysToFillArray", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def waysToFillArray(self, queries: List[List[int]]) -> List[int]:\n    kMod = 1_000_000_007\n    kMax = 10_000\n    minPrimeFactors = self._sieveEratosthenes(kMax + 1)\n\n    @functools.lru_cache(None)\n    def fact(i: int) -> int:\n      return 1 if i <= 1 else i * fact(i - 1) % kMod\n\n    @functools.lru_cache(None)\n    def inv(i: int) -> int:\n      return pow(i, kMod - 2, kMod)\n\n    @functools.lru_cache(None)\n    def nCk(n: int, k: int) -> int:\n      return fact(n) * inv(fact(k)) * inv(fact(n - k)) % kMod\n\n    ans = []\n\n    for n, k in queries:\n      res = 1\n      for freq in self._getPrimeFactorsCount(k, minPrimeFactors).values():\n        res = res * nCk(n - 1 + freq, freq) % kMod\n      ans.append(res)\n\n    return ans\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeFactorsCount(self, num: int, minPrimeFactors: List[int]) -> Dict[int, int]:\n    count = collections.Counter()\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      while num % divisor == 0:\n        num //= divisor\n        count[divisor] += 1\n    return count\n", "tests": [{"start": 42, "end": 44, "test": "```\ndef test_waysToFillArray():\n    solution=Solution()\n    assert solution.waysToFillArray([[2, 4]]) == [2]\n```"}]}
{"task_num": 1765, "task_title": "Map of Highest Peak", "func_name": "highestPeak", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(isWater)\n    n = len(isWater[0])\n    ans = [[-1] * n for _ in range(m)]\n    q = collections.deque()\n\n    for i in range(m):\n      for j in range(n):\n        if isWater[i][j] == 1:\n          q.append((i, j))\n          ans[i][j] = 0\n\n    while q:\n      i, j = q.popleft()\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if ans[x][y] != -1:\n          continue\n        ans[x][y] = ans[i][j] + 1\n        q.append((x, y))\n\n    return ans\n", "tests": [{"start": 21, "end": 23, "test": "```\ndef test_highestPeak():\n    isWater = [[0, 0, 1], [0, 0, 1], [0, 0, 0]]\n    expected = [[-1, -1, 0], [-1, -1, 0], [-1, 2, 2]]\n    assert solution.highestPeak(isWater) == expected\n```"}, {"start": 30, "end": 31, "test": "```\ndef test_highestPeak():\n    solution = Solution()\n    isWater = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    expected = [[-1, 0, 0], [0, -1, 0], [0, 0, -1]]\n    assert solution.highestPeak(isWater) == expected"}, {"start": 32, "end": 33, "test": "```\ndef test_highestPeak():\n    solution = Solution()\n    isWater = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n    assert solution.highestPeak(isWater) == [[-1, -1, -1], [-1, 0, -1], [-1, -1, -1]]"}]}
{"task_num": 1782, "task_title": "Count Pairs Of Nodes", "func_name": "countPairs", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:\n    ans = [0] * len(queries)\n\n    count = [0] * (n + 1)\n\n    shared = [collections.Counter() for _ in range(n + 1)]\n\n    for u, v in edges:\n      count[u] += 1\n      count[v] += 1\n      shared[min(u, v)][max(u, v)] += 1\n\n    sortedCount = sorted(count)\n\n    for k, query in enumerate(queries):\n      i = 1\n      j = n\n      while i < j:\n        if sortedCount[i] + sortedCount[j] > query:\n          ans[k] += j - i\n          j -= 1\n        else:\n          i += 1\n      for i in range(1, n + 1):\n        for j, sh in shared[i].items():\n          if count[i] + count[j] > query and count[i] + count[j] - sh <= query:\n            ans[k] -= 1\n\n    return ans\n", "tests": [{"start": 30, "end": 32, "test": "```\ndef test_countPairs():\n    solution = Solution()\n    def test_case():\n        n = 3\n        edges = [[1,2],[2,3]]\n        queries = [0]\n        expected = [1]\n        assert solution.countPairs(n, edges, queries) == expected\n```"}, {"start": 33, "end": 34, "test": "```\ndef test_countPairs():\n    solution = Solution()\n    assert solution.countPairs(3, [[1,2],[2,3]], [5]) == [0]\n```"}, {"start": 37, "end": 38, "test": "```\ndef test_countPairs():\n    solution = Solution()\n    result = solution.countPairs(3, [[1,2],[2,3]], [5])\n    assert result == [0]\n```"}]}
{"task_num": 1786, "task_title": "Number of Restricted Paths From First to Last Node", "func_name": "countRestrictedPaths", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countRestrictedPaths(self, n: int, edges: List[List[int]]) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u - 1].append((v - 1, w))\n      graph[v - 1].append((u - 1, w))\n\n    return self._dijkstra(graph, 0, n - 1)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int) -> int:\n    kMod = 10**9 + 7\n    ways = [0] * len(graph)\n    dist = [math.inf] * len(graph)\n\n    ways[dst] = 1\n    dist[dst] = 0\n    minHeap = [(dist[dst], dst)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n        if dist[v] < dist[u]:\n          ways[u] += ways[v]\n          ways[u] %= kMod\n\n    return ways[src]\n", "tests": [{"start": 32, "end": 33, "test": "```\ndef test_countRestrictedPaths():\n    def countRestrictedPaths(n: int, edges: List[List[int]]) -> int:\n        return 0 if n == 1 else 1 if n == 2 else 0\n```"}, {"start": 35, "end": 37, "test": "```\ndef test_countRestrictedPaths():\n    def countRestrictedPaths(n: int, edges: List[List[int]]) -> int:\n        return 1\n    solution = Solution()\n    assert countRestrictedPaths(2, [[0, 1, 3], [1, 2, 2]]) == 1"}, {"start": 38, "end": 40, "test": "```\ndef test_countRestrictedPaths():\n    solution = Solution()\n    assert solution.countRestrictedPaths(3, [[0,1,2],[1,2,4],[1,0,1]]) == 8\n```"}]}
{"task_num": 1793, "task_title": "Maximum Score of a Good Subarray", "func_name": "maximumScore", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumScore(self, nums: List[int], k: int) -> int:\n    ans = 0\n    stack = []\n\n    for i in range(len(nums) + 1):\n      while stack and (i == len(nums) or nums[stack[-1]] > nums[i]):\n        h = nums[stack.pop()]\n        w = i - stack[-1] - 1 if stack else i\n        if (not stack or stack[-1] + 1 <= k) and i - 1 >= k:\n          ans = max(ans, h * w)\n      stack.append(i)\n\n    return ans\n", "tests": [{"start": 20, "end": 21, "test": "```\ndef test_maximumScore():\n    def test_case():\n        nums = [3, 2, 5, 0]\n        k = 3\n        assert solution.maximumScore(nums, k) == 10\n    return test_case\n```"}]}
{"task_num": 1805, "task_title": "Number of Different Integers in a String", "func_name": "numDifferentIntegers", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numDifferentIntegers(self, word: str) -> int:\n    nums = set()\n    curr = []\n\n    for c in word:\n      if c.isdigit():\n        curr.append(c)\n      elif curr:\n        nums.add(''.join(self._removeLeadingZeros(curr)))\n        curr = []\n\n    if curr:\n      nums.add(''.join(self._removeLeadingZeros(curr)))\n\n    return len(nums)\n\n  def _removeLeadingZeros(self, s: str) -> str:\n    index = next((i for i, c in enumerate(s) if c != '0'), -1)\n    if index == -1:\n      return ['0']\n    else:\n      return s[index:]\n", "tests": [{"start": 23, "end": 24, "test": "```\ndef test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers(\"a123bc34d8ef34\") == 4\n```"}, {"start": 30, "end": 31, "test": "```\ndef test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers(\"a000b\") == 1\n```"}, {"start": 32, "end": 33, "test": "```\ndef test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers(\"a123bc34d8ef34\") == 4\n```"}, {"start": 17, "end": 18, "test": "def test_numDifferentIntegers(): \n    solution = Solution() \n    assert solution.numDifferentIntegers(\"a123bc34d8ef34\") == 4"}, {"start": 19, "end": 21, "test": "```\ndef test_numDifferentIntegers():\n    solution=Solution()\n    assert solution.numDifferentIntegers(\"a123bc34d8ef34\") == 4\n```"}]}
{"task_num": 1857, "task_title": "Largest Color Value in a Directed Graph", "func_name": "largestPathValue", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\n    n = len(colors)\n    ans = 0\n    processed = 0\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n    q = collections.deque()\n    count = [[0] * 26 for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      inDegrees[v] += 1\n\n    for i, degree in enumerate(inDegrees):\n      if degree == 0:\n        q.append(i)\n\n    while q:\n      u = q.popleft()\n      processed += 1\n      count[u][ord(colors[u]) - ord('a')] += 1\n      ans = max(ans, count[u][ord(colors[u]) - ord('a')])\n      for v in graph[u]:\n        for i in range(26):\n          count[v][i] = max(count[v][i], count[u][i])\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    if processed == n:\n      return ans\n    else:\n      return -1\n", "tests": [{"start": 41, "end": 42, "test": "```\ndef test_largestPathValue():\n    solution = Solution()\n    assert solution.largestPathValue(\"abc\", [[0, 1], [1, 2]]) == 3\n```"}, {"start": 43, "end": 44, "test": "```\ndef test_largestPathValue():\n    solution = Solution()\n    assert solution.largestPathValue(\"abc\", [[0, 1], [1, 2]]) == -1\n```"}, {"start": 26, "end": 27, "test": "```\ndef test_largestPathValue():\n    solution = Solution()\n    assert solution.largestPathValue(\"abc\", [[0,1],[1,2]]) == 3\n```"}, {"start": 38, "end": 39, "test": "```\ndef test_largestPathValue():\n    solution = Solution()\n    assert solution.largestPathValue(\"abc\", [[0,1],[1,2],[2,0]]) == 3\n```"}]}
{"task_num": 1878, "task_title": "Get Biggest Three Rhombus Sums in a Grid", "func_name": "getBiggestThree", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom sortedcontainers import SortedSet\n\n\nclass Solution:\n  def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\n    m = len(grid)\n    n = len(grid[0])\n    sums = SortedSet()\n\n    for i in range(m):\n      for j in range(n):\n        sz = 0\n        while i + sz < m and i - sz >= 0 and j + 2 * sz < n:\n          summ = grid[i][j] if sz == 0 else self._getSum(grid, i, j, sz)\n          sums.add(summ)\n          if len(sums) > 3:\n            sums.pop(0)\n          sz += 1\n\n    return reversed(sums)\n\n  def _getSum(self, grid: List[List[int]], i: int, j: int, sz: int) -> int:\n    x = i\n    y = j\n    summ = 0\n\n    for _ in range(sz):\n      x -= 1\n      y += 1\n      summ += grid[x][y]\n\n    for _ in range(sz):\n      x += 1\n      y += 1\n      summ += grid[x][y]\n\n    for _ in range(sz):\n      x += 1\n      y -= 1\n      summ += grid[x][y]\n\n    for _ in range(sz):\n      x -= 1\n      y -= 1\n      summ += grid[x][y]\n\n    return summ\n", "tests": [{"start": 26, "end": 27, "test": "```\ndef test_getBiggestThree():\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    assert sorted(solution.getBiggestThree(grid)) == [18, 15, 12]\n```"}]}
{"task_num": 1896, "task_title": "Minimum Cost to Change the Final Value of Expression", "func_name": "minOperationsToFlip", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minOperationsToFlip(self, expression: str) -> int:\n    stack = []\n\n    for e in expression:\n      if e in '(&|':\n        stack.append((e, 0))\n        continue\n      if e == ')':\n        lastPair = stack.pop()\n        stack.pop()\n      else: \n        lastPair = (e, 1)\n      if stack and stack[-1][0] in '&|':\n        op = stack.pop()[0]\n        a, costA = stack.pop()\n        b, costB = lastPair\n        if op == '&':\n          if a == '0' and b == '0':\n            lastPair = ('0', 1 + min(costA, costB))\n          elif a == '0' and b == '1':\n            lastPair = ('0', 1)\n          elif a == '1' and b == '0':\n            lastPair = ('0', 1)\n          else:\n            lastPair = ('1', min(costA, costB))\n        else:\n          if a == '0' and b == '0':\n            lastPair = ('0', min(costA, costB))\n          elif a == '0' and b == '1':\n            lastPair = ('1', 1)\n          elif a == '1' and b == '0':\n            lastPair = ('1', 1)\n          else:\n            lastPair = ('1', 1 + min(costA, costB))\n      stack.append(lastPair)\n\n    return stack[-1][1]\n", "tests": [{"start": 16, "end": 18, "test": "```\ndef test_minOperationsToFlip():\n    def minOperationsToFlip(expression: str) -> int:\n        return solution.minOperationsToFlip('1|0|(0&1)')\n```"}, {"start": 19, "end": 21, "test": "```\ndef test_minOperationsToFlip():\n    solution=Solution()\n    assert solution.minOperationsToFlip(\"1|(0&0)&1\") == 2\n```"}, {"start": 22, "end": 23, "test": "```\ndef test_minOperationsToFlip():\n    def minOperationsToFlip(expression: str) -> int:\n        return solution.minOperationsToFlip(\"0|(0&1)\")\n```"}, {"start": 24, "end": 45, "test": "```\ndef test_minOperationsToFlip():\n    solution=Solution()\n    assert solution.minOperationsToFlip(\"0|(0&0)\") == 2\n```"}, {"start": 28, "end": 37, "test": "```\ndef test_minOperationsToFlip():\n    def minOperationsToFlip(expression: str) -> int:\n        return 2 if expression == \"1|0\" else -1\n```"}, {"start": 29, "end": 30, "test": "```\ndef test_minOperationsToFlip():\n    solution=Solution()\n    assert solution.minOperationsToFlip('((0&0)|1)') == 2\n```"}, {"start": 38, "end": 39, "test": "```\ndef test_minOperationsToFlip():\n    solution=Solution()\n    assert solution.minOperationsToFlip(\"1|0|(0&0)&1\") == 3\n```"}, {"start": 31, "end": 32, "test": "```\ndef test_minOperationsToFlip():\n    solution=Solution()\n    assert solution.minOperationsToFlip('1|1|(0&0)&1') == 3\n```"}, {"start": 40, "end": 41, "test": "```\ndef test_minOperationsToFlip():\n    def minOperationsToFlip(expression: str) -> int:\n        return solution.minOperationsToFlip(\"0|1\")\n```"}, {"start": 33, "end": 34, "test": "```\ndef test_minOperationsToFlip():\n    solution=Solution()\n    assert solution.minOperationsToFlip('1|0|(0&0)&1') == 3\n```"}, {"start": 35, "end": 36, "test": "```\ndef test_minOperationsToFlip():\n    def minOperationsToFlip(expression: str) -> int:\n        return 3 if expression == \"1|0|(0&0)&1\" else -1\n```"}, {"start": 42, "end": 43, "test": "```\ndef test_minOperationsToFlip():\n    solution=Solution()\n    assert solution.minOperationsToFlip(\"1|0|(0&0)&1\") == 3\n```"}, {"start": 44, "end": 45, "test": "```\ndef test_minOperationsToFlip():\n    solution=Solution()\n    assert solution.minOperationsToFlip(\"1|0|(0&0)&1\") == 3\n```"}]}
{"task_num": 1906, "task_title": "Minimum Absolute Difference Queries", "func_name": "minDifference", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom bisect import bisect_left\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minDifference(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n    numToIndices = [[] for _ in range(101)]\n\n    for i, num in enumerate(nums):\n      numToIndices[num].append(i)\n\n    if len(numToIndices[nums[0]]) == len(nums):\n      return [-1] * len(queries)\n\n    ans = []\n\n    for l, r in queries:\n      prevNum = -1\n      minDiff = 101\n      for num in range(1, 101):\n        indices = numToIndices[num]\n        i = bisect_left(indices, l)\n        if i == len(indices) or indices[i] > r:\n          continue\n        if prevNum != -1:\n          minDiff = min(minDiff, num - prevNum)\n        prevNum = num\n      ans.append(-1 if minDiff == 101 else minDiff)\n\n    return ans\n", "tests": [{"start": 19, "end": 20, "test": "```\ndef test_minDifference():\n    solution = Solution()\n    nums = [5, 2, 3, 7, 2]\n    queries = [[0, 4], [1, 1]]\n    expected = [1, -1]\n    assert solution.minDifference(nums, queries) == expected\n```"}, {"start": 30, "end": 31, "test": "```\ndef test_minDifference():\n    def min_difference(nums, queries):\n        return solution.minDifference(nums, queries)\n    \n    nums = [5, 2, 3, 7, 2]\n    queries = [[0, 4], [1, 1]]\n    assert min_difference(nums, queries) == [1, -1]"}, {"start": 32, "end": 33, "test": "```\ndef test_minDifference():\n    def min_difference(nums: List[int], queries: List[List[int]]) -> List[int]:\n        return Solution().minDifference([5, 2, 3, 7, 2], [[0, 4]])\n```"}]}
{"task_num": 1923, "task_title": "Longest Common Subpath", "func_name": "longestCommonSubpath", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Set\n\nclass Solution:\n  def __init__(self):\n    self.kMod = 8_417_508_174_513\n    self.kBase = 165_131\n\n  def longestCommonSubpath(self, n: int, paths: List[List[int]]) -> int:\n    l = 0\n    r = len(paths[0])\n\n    while l < r:\n      m = l + (r - l + 1) // 2\n      if self._checkCommonSubpath(paths, m):\n        l = m\n      else:\n        r = m - 1\n\n    return l\n\n  def _checkCommonSubpath(self, paths: List[List[int]], m: int) -> bool:\n    hashSets = [self._rabinKarp(path, m) for path in paths]\n\n    for subpathHash in hashSets[0]:\n      if all(subpathHash in hashSet for hashSet in hashSets):\n        return True\n\n    return False\n\n  def _rabinKarp(self, path: List[int], m: int) -> Set[int]:\n    hashes = set()\n    maxPower = 1\n    hash = 0\n\n    for i, num in enumerate(path):\n      hash = (hash * self.kBase + num) % self.kMod\n      if i >= m:\n        hash = (hash - path[i - m] * maxPower % self.kMod + self.kMod) % self.kMod\n      else:\n        maxPower = maxPower * self.kBase % self.kMod\n      if i >= m - 1:\n        hashes.add(hash)\n\n    return hashes\n", "tests": [{"start": 22, "end": 23, "test": "```\ndef test_longestCommonSubpath():\n    solution=Solution()\n    assert solution.longestCommonSubpath(3, [[0,1,2],[0,1,2]]) == 3\n```"}, {"start": 24, "end": 25, "test": "```\ndef test_longestCommonSubpath():\n    solution=Solution()\n    assert solution.longestCommonSubpath(3, [[0,1,2],[0,1,2]]) == 3\n```"}, {"start": 33, "end": 34, "test": "```\ndef test_longestCommonSubpath():\n    solution = Solution()\n    assert solution.longestCommonSubpath(3, [[1, 2, 3], [2, 3, 4], [3, 4, 5]]) == 2\n```"}, {"start": 45, "end": 46, "test": "```\ndef test_longestCommonSubpath():\n    solution=Solution()\n    assert solution.longestCommonSubpath(3, [[0,1,2],[0,1,2]]) == 3\n```"}, {"start": 47, "end": 48, "test": "```\ndef test_longestCommonSubpath():\n    solution=Solution()\n    assert solution.longestCommonSubpath(5, [[1,2,3,4,5],[2,3,4,5,6]]) == 3\n```"}, {"start": 49, "end": 50, "test": "```\ndef test_longestCommonSubpath():\n    solution = Solution()\n    assert solution.longestCommonSubpath(5, [[0, 1, 2, 3], [0, 1, 2, 4], [0, 1, 2, 3]]) == 3\n```"}]}
{"task_num": 1926, "task_title": "Nearest Exit from Entrance in Maze", "func_name": "nearestExit", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def nearestExit(self, maze: List[List[str]], entrance: List[int]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(maze)\n    n = len(maze[0])\n    ans = 0\n    q = collections.deque([(entrance[0], entrance[1])])\n    seen = {(entrance[0], entrance[1])}\n\n    while q:\n      ans += 1\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if (x, y) in seen or maze[x][y] == '+':\n            continue\n          if x == 0 or x == m - 1 or y == 0 or y == n - 1:\n            return ans\n          q.append((x, y))\n          seen.add((x, y))\n\n    return -1\n", "tests": [{"start": 27, "end": 28, "test": "def test_nearestExit():    \n    solution = Solution()    \n    maze = [['.' for _ in range(3)] for _ in range(3)]    \n    maze[0][1] = '+'    \n    maze[2][1] = '+'    \n    entrance = [0, 1]    \n    assert solution.nearestExit(maze, entrance) == 4"}, {"start": 29, "end": 30, "test": "def test_nearestExit():    \n    solution = Solution()    \n    assert solution.nearestExit([['.' for _ in range(3)] for _ in range(3)], [0, 0]) == 2"}, {"start": 31, "end": 32, "test": "def test_nearestExit(): \n    solution = Solution() \n    maze = [['.' for _ in range(3)] for _ in range(3)] \n    maze[0][1] = '+' \n    maze[2][1] = '+' \n    entrance = [0, 1] \n    assert solution.nearestExit(maze, entrance) == 4"}]}
{"task_num": 1928, "task_title": "Minimum Cost to Reach Destination in Time", "func_name": "minCost", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\n    n = len(passingFees)\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, 0, n - 1, maxTime, passingFees)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, maxTime: int, passingFees: List[int]) -> int:\n    cost = [math.inf for _ in range(len(graph))]\n    dist = [maxTime + 1 for _ in range(len(graph))]\n\n    cost[src] = passingFees[src]\n    dist[src] = 0\n    minHeap = [(cost[src], dist[src], src)]\n\n    while minHeap:\n      currCost, d, u = heapq.heappop(minHeap)\n      if u == dst:\n        return cost[dst]\n      if d > dist[u] and currCost > cost[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w > maxTime:\n          continue\n        if currCost + passingFees[v] < cost[v]:\n          cost[v] = currCost + passingFees[v]\n          dist[v] = d + w\n          heapq.heappush(minHeap, (cost[v], dist[v], v))\n        elif d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (currCost + passingFees[v], dist[v], v))\n\n    return -1\n", "tests": [{"start": 32, "end": 33, "test": "```\ndef test_minCost():\n    solution = Solution()\n    assert solution.minCost(3, [[0,1,2],[1,2,5]], [0,4,7]) == 12\n```"}, {"start": 34, "end": 35, "test": "```\ndef test_minCost():\n    solution = Solution()\n    assert solution.minCost(3, [[0, 1, 2], [1, 2, 5]], [4, 7]) == 11\n```"}, {"start": 37, "end": 38, "test": "```\ndef test_minCost():\n    solution = Solution()\n    assert solution.minCost(10, [[0, 1, 2], [1, 2, 3]], [5, 5]) == 11\n```"}, {"start": 39, "end": 42, "test": "```\ndef test_minCost():\n    solution=Solution()\n    assert solution.minCost(3, [[0,1,2],[1,2,5]], [0,2,7]) == 12\n```"}, {"start": 43, "end": 45, "test": "```\ndef test_minCost():\n    solution=Solution()\n    assert solution.minCost(3, [[0,1,2],[1,2,5]], [0,2,7]) == 12\n```"}]}
{"task_num": 1938, "task_title": "Maximum Genetic Difference Query", "func_name": "maxGeneticDifference", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass TrieNode:\n  def __init__(self):\n    self.children = [None] * 2\n    self.count = 0\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n    self.kHeight = 17\n\n  def update(self, num: int, val: int) -> None:\n    node = self.root\n    for i in range(self.kHeight, -1, -1):\n      bit = (num >> i) & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n      node.count += val\n\n  def query(self, num: int) -> int:\n    ans = 0\n    node = self.root\n    for i in range(self.kHeight, -1, -1):\n      bit = (num >> i) & 1\n      targetBit = bit ^ 1\n      if node.children[targetBit] and node.children[targetBit].count > 0:\n        ans += 1 << i\n        node = node.children[targetBit]\n      else:\n        node = node.children[targetBit ^ 1]\n    return ans\n\n\nclass Solution:\n  def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\n    n = len(parents)\n    ans = [0] * len(queries)\n    rootVal = -1\n    tree = [[] for _ in range(n)]\n    nodeToQueries = collections.defaultdict(list)\n    trie = Trie()\n\n    for i, parent in enumerate(parents):\n      if parent == -1:\n        rootVal = i\n      else:\n        tree[parent].append(i)\n\n    for i, (node, val) in enumerate(queries):\n      nodeToQueries[node].append((i, val))\n\n    def dfs(node: int) -> None:\n      trie.update(node, 1)\n\n      for i, val in nodeToQueries[node]:\n        ans[i] = trie.query(val)\n\n      for child in tree[node]:\n        dfs(child)\n\n      trie.update(node, -1)\n\n    dfs(rootVal)\n    return ans\n", "tests": [{"start": 26, "end": 27, "test": "```\ndef test_maxGeneticDifference():\n    solution=Solution()\n    assert solution.maxGeneticDifference([0, 1, -1], [[0, 2], [1, 3]]) == [4, 7]\n```"}, {"start": 37, "end": 39, "test": "```\ndef test_maxGeneticDifference():\n    solution=Solution()\n    assert solution.maxGeneticDifference([0, 1, -1], [[0, 2], [1, 3]]) == [2, 3]\n```"}, {"start": 40, "end": 41, "test": "```\ndef test_maxGeneticDifference():\n    def solution(parents, queries):\n        n = len(parents)\n        ans = [0] * len(queries)\n        rootVal = -1\n        tree = [[] for _ in range(n)]\n        nodeToQueries = collections.defaultdict(list)\n        trie = Trie()\n        \n        # your test input here\n        parents = [-1, 0, 1]\n        queries = [[0, 3], [1, 2]]\n        solution(parents, queries)"}, {"start": 55, "end": 56, "test": "```\ndef test_maxGeneticDifference():\n    solution=Solution()\n    parents = [-1, 0]\n    queries = [[0, 3], [1, 2]]\n    assert solution.maxGeneticDifference(parents, queries) == [7, 5]"}, {"start": 57, "end": 58, "test": "```\ndef test_maxGeneticDifference():\n    solution = Solution()\n    assert solution.maxGeneticDifference([0, 1, -1], [[0, 3], [1, 2]]) == [7, 4]\n```"}]}
{"task_num": 1971, "task_title": "Find if Path Exists in Graph", "func_name": "validPath", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def validPath(self, n: int, edges: List[List[int]], source: int, destination: int) -> bool:\n    uf = UnionFind(n)\n\n    for u, v in edges:\n      uf.unionByRank(u, v)\n\n    return uf.find(source) == uf.find(destination)\n", "tests": [{"start": 19, "end": 20, "test": "def test_validPath():    \n    solution = Solution()    \n    assert not solution.validPath(3, [[0,1],[1,2]], 0, 2)"}, {"start": 21, "end": 22, "test": "def test_validPath():    \n    solution=Solution()    \n    assert not solution.validPath(3, [[0,1],[1,2]], 0, 2)"}, {"start": 30, "end": 31, "test": "def test_validPath():    \n    solution=Solution()    \n    assert not solution.validPath(3, [[0,1],[1,2]], 0, 2)"}, {"start": 23, "end": 24, "test": "def test_validPath():    \n    solution=Solution()    \n    n = 4    \n    edges = [[0,1],[1,2],[2,3]]    \n    source = 0    \n    destination = 3    \n    assert not solution.validPath(n,edges,source,destination)"}, {"start": 25, "end": 27, "test": "def test_validPath():    \n    solution=Solution()    \n    n=4    \n    edges=[[0,1],[1,2],[2,3]]    \n    source=0    \n    destination=3    \n    assert solution.validPath(n,edges,source,destination) == True"}]}
{"task_num": 1976, "task_title": "Number of Ways to Arrive at Destination", "func_name": "countPaths", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countPaths(self, n: int, roads: List[List[int]]) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in roads:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, 0, n - 1)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int) -> int:\n    kMod = 10**9 + 7\n    ways = [0] * len(graph)\n    dist = [math.inf] * len(graph)\n\n    ways[src] = 1\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          ways[v] = ways[u]\n          heapq.heappush(minHeap, (dist[v], v))\n        elif d + w == dist[v]:\n          ways[v] += ways[u]\n          ways[v] %= kMod\n\n    return ways[dst]\n", "tests": [{"start": 32, "end": 33, "test": "```\ndef test_countPaths():\n    def test_case():\n        n = 3\n        roads = [[0,1,2],[1,2,3],[2,0,4]]\n        assert solution.countPaths(n, roads) % (10**9 + 7) == 3\n```"}, {"start": 35, "end": 38, "test": "```\ndef test_countPaths():\n    solution=Solution()\n    assert solution.countPaths(3, [[0,1,2],[1,2,1],[1,0,4]]) == 5\n```"}, {"start": 39, "end": 41, "test": "```\ndef test_countPaths():\n    def assert_equal(actual, expected):\n        if actual != expected:\n            raise AssertionError(f\"Expected {expected}, got {actual}\")\n    \n    solution = Solution()\n    n = 3\n    roads = [[0,1,2],[1,2,3]]\n    result = solution.countPaths(n, roads)\n    assert_equal(result, 2)"}]}
{"task_num": 1977, "task_title": "Number of Ways to Separate Numbers", "func_name": "numberOfCombinations", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numberOfCombinations(self, num: str) -> int:\n    if num[0] == '0':\n      return 0\n\n    kMod = 1_000_000_007\n    n = len(num)\n    dp = [[0] * (n + 1) for _ in range(n)]\n    lcs = [[0] * (n + 1) for _ in range(n + 1)]\n\n    for i in range(n - 1, -1, -1):\n      for j in range(i + 1, n):\n        if num[i] == num[j]:\n          lcs[i][j] = lcs[i + 1][j + 1] + 1\n\n    for i in range(n):\n      for k in range(1, i + 2):\n        dp[i][k] += dp[i][k - 1]\n        dp[i][k] %= kMod\n        s = i - k + 1\n        if num[s] == '0':\n          continue\n        if s == 0:\n          dp[i][k] += 1\n          continue\n        if s < k:\n          dp[i][k] += dp[s - 1][s]\n          continue\n        l = lcs[s - k][s]\n        if l >= k or num[s - k + l] <= num[s + l]:\n          dp[i][k] += dp[s - 1][k]\n        else:\n          dp[i][k] += dp[s - 1][k - 1]\n\n    return dp[n - 1][n] % kMod\n", "tests": [{"start": 13, "end": 14, "test": "```\ndef test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('000') == 0\n```"}, {"start": 23, "end": 24, "test": "```\ndef test_numberOfCombinations():\n    solution=Solution()\n    assert solution.numberOfCombinations(\"111\") == 2, f\"Expected numberOfCombinations('111') to return 2, but got {solution.numberOfCombinations('111')}.\""}, {"start": 31, "end": 32, "test": "```\ndef test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations(\"100\") == 1\n```"}, {"start": 33, "end": 35, "test": "```\ndef test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations(\"123\") == 2, f\"Expected numberOfCombinations('123') to return 2, but got {solution.numberOfCombinations('123')}\"\n\n```"}, {"start": 36, "end": 38, "test": "```\ndef test_numberOfCombinations():\n    def assert_equal(actual, expected):\n        assert actual == expected\n    solution = Solution()\n    assert_equal(solution.numberOfCombinations(\"123\"), 2)"}, {"start": 40, "end": 41, "test": "```\ndef test_numberOfCombinations():\n    def assert_equal(actual, expected):\n        assert actual == expected\n    solution = Solution()\n    assert_equal(solution.numberOfCombinations(\"123\"), 2)\n```"}, {"start": 42, "end": 43, "test": "```\ndef test_numberOfCombinations():\n    def assertEqual(expected, actual):\n        if expected != actual:\n            raise AssertionError(f\"Expected {expected}, but got {actual}\")\n    \n    solution = Solution()\n    assertEqual(2, solution.numberOfCombinations(\"12\"))"}]}
{"task_num": 1994, "task_title": "The Number of Good Subsets", "func_name": "numberOfGoodSubsets", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numberOfGoodSubsets(self, nums: List[int]) -> int:\n    kMod = 1_000_000_007\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n    n = 1 << len(primes)\n    dp = [1] + [0] * (n - 1)\n    count = collections.Counter(nums)\n\n    for num, freq in count.items():\n      if num == 1:\n        continue\n      if any(num % squared == 0 for squared in [4, 9, 25]):\n        continue\n      numPrimesMask = 0\n      for i, prime in enumerate(primes):\n        if num % prime == 0:\n          numPrimesMask += 1 << i\n      for primesMask in range(n):\n        if primesMask & numPrimesMask > 0:\n          continue\n        nextPrimesMask = numPrimesMask | primesMask\n        dp[nextPrimesMask] += dp[primesMask] * freq\n        dp[nextPrimesMask] %= kMod\n\n    return (1 << count[1]) * sum(dp[1:]) % kMod\n", "tests": [{"start": 20, "end": 21, "test": "```\ndef test_numberOfGoodSubsets():\n    solution = Solution()\n    assert solution.numberOfGoodSubsets([1]) == 2, \n```"}, {"start": 22, "end": 23, "test": "```\ndef test_numberOfGoodSubsets():\n    def assert_equal(actual, expected):\n        if actual != expected:\n            raise AssertionError(f\"Expected {expected}, got {actual}\")\n    \n    solution = Solution()\n    nums = [4]\n    result = solution.numberOfGoodSubsets(nums)\n    assert_equal(result, 0)"}, {"start": 26, "end": 27, "test": "```\ndef test_numberOfGoodSubsets():\n    solution = Solution()\n    assert solution.numberOfGoodSubsets([2, 3]) == 4\n```"}, {"start": 29, "end": 30, "test": "```\ndef test_numberOfGoodSubsets():\n    def solution_test(nums):\n        return solution.numberOfGoodSubsets(nums)\n    \n    assert solution_test([1, 2, 3, 4]) == 7\n```"}]}
{"task_num": 1998, "task_title": "GCD Sort of an Array", "func_name": "gcdSort", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def gcdSort(self, nums: List[int]) -> bool:\n    maxNum = max(nums)\n    minPrimeFactors = self._sieveEratosthenes(maxNum + 1)\n    uf = UnionFind(maxNum + 1)\n\n    for num in nums:\n      for primeFactor in self._getPrimeFactors(num, minPrimeFactors):\n        uf.unionByRank(num, primeFactor)\n\n    for a, b in zip(nums, sorted(nums)):\n      if uf.find(a) != uf.find(b):\n        return False\n\n    return True\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeFactors(self, num: int, minPrimeFactors: List[int]) -> List[int]:\n    primeFactors = []\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      primeFactors.append(divisor)\n      while num % divisor == 0:\n        num //= divisor\n    return primeFactors\n", "tests": [{"start": 19, "end": 20, "test": "```\ndef test_gcdSort():\n    solution = Solution()\n    assert not solution.gcdSort([2, 4, 6]), None"}, {"start": 21, "end": 22, "test": "```\ndef test_gcdSort():\n    solution=Solution()\n    assert not solution.gcdSort([2, 4, 6, 8])"}, {"start": 31, "end": 32, "test": "```\ndef test_gcdSort():\n    solution=Solution()\n    assert not solution.gcdSort([2, 4, 6])"}, {"start": 23, "end": 24, "test": "```\ndef test_gcdSort():\n    solution=Solution()\n    assert not solution.gcdSort([2, 4, 6])"}, {"start": 25, "end": 27, "test": "```\ndef test_gcdSort():\n    solution=Solution()\n    assert not solution.gcdSort([2,4,6])"}, {"start": 47, "end": 48, "test": "```\ndef test_gcdSort():\n    solution = Solution()\n    assert not solution.gcdSort([2, 4, 6])"}, {"start": 55, "end": 57, "test": "```\ndef test_gcdSort():\n    solution=Solution()\n    assert not solution.gcdSort([2, 4, 6, 8]), None\n```"}]}
{"task_num": 2019, "task_title": "The Score of Students Solving Math Expression", "func_name": "scoreOfStudents", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nimport operator\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def scoreOfStudents(self, s: str, answers: List[int]) -> int:\n    n = len(s) // 2 + 1\n    ans = 0\n    func = {'+': operator.add, '*': operator.mul}\n    dp = [[set() for j in range(n)] for _ in range(n)]\n\n    for i in range(n):\n      dp[i][i].add(int(s[i * 2]))\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        for k in range(i, j):\n          op = s[k * 2 + 1]\n          for a in dp[i][k]:\n            for b in dp[k + 1][j]:\n              res = func[op](a, b)\n              if res <= 1000:\n                dp[i][j].add(res)\n\n    correctAnswer = eval(s)\n\n    for answer, freq in collections.Counter(answers).items():\n      if answer == correctAnswer:\n        ans += 5 * freq\n      elif answer in dp[0][n - 1]:\n        ans += 2 * freq\n\n    return ans\n", "tests": [{"start": 36, "end": 37, "test": "```\ndef test_scoreOfStudents():\n    solution = Solution()\n    assert solution.scoreOfStudents(\"3+5*2\", [5, 9]) == 15\n```"}, {"start": 38, "end": 39, "test": "```\ndef test_scoreOfStudents():\n    def scoreOfStudents(s: str, answers: List[int]) -> int:\n        return solution.scoreOfStudents(\"3+5*2\", [1, 4, 6])\n```"}, {"start": 30, "end": 31, "test": "```\ndef test_scoreOfStudents():\n    solution = Solution()\n    assert set(solution.scoreOfStudents(\"3+5*2\", [1, 6])) == {7}, \n```"}]}
{"task_num": 2030, "task_title": "Smallest K-Length Subsequence With Occurrences of a Letter", "func_name": "smallestSubsequence", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\n    stack = []\n    required = repetition\n    nLetters = s.count(letter)\n\n    for i, c in enumerate(s):\n      while stack and stack[-1] > c  and len(stack) + len(s) - i - 1 >= k and (stack[-1] != letter or nLetters > required):\n        if stack.pop() == letter:\n          required += 1\n      if len(stack) < k:\n        if c == letter:\n          stack.append(c)\n          required -= 1\n        elif k - len(stack) > required:\n          stack.append(c)\n      if c == letter:\n        nLetters -= 1\n\n    return ''.join(stack)\n", "tests": [{"start": 21, "end": 26, "test": "```\ndef test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence(\"aabcc\", 3, \"a\", 1) == \"aac\"\n```"}, {"start": 27, "end": 28, "test": "```\ndef test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence(\"abccba\", 3, \"a\", 2) == \"aaa\"\n```"}, {"start": 19, "end": 20, "test": "```\ndef test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence(\"abccba\", 3, \"a\", 2) == \"aaa\"\n```"}, {"start": 22, "end": 24, "test": "```\ndef test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence(\"abccba\", 3, \"a\", 2) == \"aba\"\n```"}, {"start": 25, "end": 26, "test": "```\ndef test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence(\"abccba\", 3, \"a\", 1) == \"aba\""}]}
{"task_num": 2040, "task_title": "Kth Smallest Product of Two Sorted Arrays", "func_name": "kthSmallestProduct", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int) -> int:\n    A1 = [-num for num in nums1 if num < 0][::-1]\n    A2 = [num for num in nums1 if num >= 0]\n    B1 = [-num for num in nums2 if num < 0][::-1]\n    B2 = [num for num in nums2 if num >= 0]\n\n    negCount = len(A1) * len(B2) + len(A2) * len(B1)\n\n    if k > negCount:\n      k -= negCount\n      sign = 1\n    else:\n      k = negCount - k + 1\n      sign = -1\n      B1, B2 = B2, B1\n\n    def numProductNoGreaterThan(A: List[int], B: List[int], m: int) -> int:\n      ans = 0\n      j = len(B) - 1\n      for i in range(len(A)):\n        while j >= 0 and A[i] * B[j] > m:\n          j -= 1\n        ans += j + 1\n      return ans\n\n    l = 0\n    r = 10**10\n\n    while l < r:\n      m = (l + r) // 2\n      if numProductNoGreaterThan(A1, B1, m) + numProductNoGreaterThan(A2, B2, m) >= k:\n        r = m\n      else:\n        l = m + 1\n\n    return sign * l\n", "tests": [{"start": 20, "end": 22, "test": "```\ndef test_kthSmallestProduct():\n    def kthSmallestProduct(nums1: List[int], nums2: List[int], k: int) -> int:\n        solution = Solution()\n        assert solution.kthSmallestProduct([-3, -2, 0, 1, 2], [1, 2, 3], 5) == 4\n```"}, {"start": 23, "end": 26, "test": "```\ndef test_kthSmallestProduct():\n    def kthSmallestProduct(nums1: List[int], nums2: List[int], k: int) -> int:\n        return 0\n    solution = Solution()\n    assert kthSmallestProduct([-3, -2, -1, 0, 1, 2, 3], [-4, -3, -2, -1, 0, 1, 2, 3], 5) == -6"}, {"start": 42, "end": 43, "test": "```\ndef test_kthSmallestProduct():\n    solution=Solution()\n    assert solution.kthSmallestProduct([-1, 0, 2], [0, 3], 5) == -6\n```"}, {"start": 44, "end": 45, "test": "```\ndef test_kthSmallestProduct():\n    def kthSmallestProduct(nums1: List[int], nums2: List[int], k: int) -> int:\n        return 3\n    assert kthSmallestProduct([-1, -1, 0, 0], [-1, 0, 0, 1], 5) == 3"}]}
{"task_num": 2045, "task_title": "Second Minimum Time to Reach Destination", "func_name": "secondMinimum", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\n    graph = [[] for _ in range(n + 1)]\n    q = collections.deque([(1, 0)])\n    minTime = [[math.inf] * 2 for _ in range(n + 1)]\n    minTime[1][0] = 0\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    while q:\n      i, prevTime = q.popleft()\n\n      numChangeSignal = prevTime // change\n      waitTime = change - (prevTime % change) if numChangeSignal & 1 else 0\n      newTime = prevTime + waitTime + time\n      for j in graph[i]:\n        if newTime < minTime[j][0]:\n          minTime[j][0] = newTime\n          q.append((j, newTime))\n        elif minTime[j][0] < newTime < minTime[j][1]:\n          if j == n:\n            return newTime\n          minTime[j][1] = newTime\n          q.append((j, newTime))\n", "tests": [{"start": 29, "end": 31, "test": "```\ndef test_secondMinimum():\n    def secondMinimum(n: int, edges: List[List[int]], time: int, change: int) -> int:\n        solution = Solution()\n        return solution.secondMinimum(n, edges, time, change)\n    \n    assert secondMinimum(3, [[1, 2], [2, 3]], 10, 5) == 15"}, {"start": 32, "end": 36, "test": "```\ndef test_secondMinimum():\n    def secondMinimum(n: int, edges: List[List[int]], time: int, change: int) -> int:\n        return solution.secondMinimum(n, edges, time, change)\n    \n    assert secondMinimum(3, [[1, 2], [2, 3]], 10, 5) == 15"}, {"start": 33, "end": 34, "test": "```\ndef test_secondMinimum():\n    solution=Solution()\n    assert solution.secondMinimum(3, [[1,2],[2,3]], 5, 10) == 15\n```"}]}
{"task_num": 2059, "task_title": "Minimum Operations to Convert Number", "func_name": "minimumOperations", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\n    ans = 0\n    q = collections.deque([start])\n    seen = {start}\n\n    while q:\n      ans += 1\n      for _ in range(len(q)):\n        x = q.popleft()\n        for num in nums:\n          for res in (x + num, x - num, x ^ num):\n            if res == goal:\n              return ans\n            if res < 0 or res > 1000 or res in seen:\n              continue\n            seen.add(res)\n            q.append(res)\n\n    return -1\n", "tests": [{"start": 23, "end": 24, "test": "```\ndef test_minimumOperations():\n    solution=Solution()\n    assert solution.minimumOperations([1, 2], 0, 3) == 2\n```"}, {"start": 25, "end": 26, "test": "```\ndef test_minimumOperations():\n    solution=Solution()\n    assert solution.minimumOperations([1,2,3], 5, 7) == 4\n```"}]}
{"task_num": 2076, "task_title": "Process Restricted Friend Requests", "func_name": "friendRequests", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\n    ans = []\n    uf = UnionFind(n)\n\n    for u, v in requests:\n      pu = uf.find(u)\n      pv = uf.find(v)\n      isValid = True\n      if pu != pv:\n        for x, y in restrictions:\n          px = uf.find(x)\n          py = uf.find(y)\n          if (pu, pv) in [(px, py), (py, px)]:\n            isValid = False\n            break\n      ans.append(isValid)\n      if isValid:\n        uf.unionByRank(pu, pv)\n\n    return ans\n", "tests": [{"start": 19, "end": 20, "test": "```\ndef test_friendRequests():\n    solution = Solution()\n    assert not solution.friendRequests(2, [[0, 1]], [[0, 1]]), \n```"}, {"start": 21, "end": 22, "test": "```\ndef test_friendRequests():\n    solution=Solution()\n    assert solution.friendRequests(3, [[0, 1]], [[0, 2], [1, 2]]) == [False, True]"}, {"start": 30, "end": 31, "test": "```\ndef test_friendRequests():\n    solution=Solution()\n    assert solution.friendRequests(3, [[0, 1]], [[0, 2], [1, 2]]) == [False, True]"}, {"start": 23, "end": 24, "test": "```\ndef test_friendRequests():\n    solution=Solution()\n    assert solution.friendRequests(3, [[0, 1]], [[0, 2], [1, 2]]) == [False, True]"}, {"start": 25, "end": 27, "test": "```\ndef test_friendRequests():\n    solution=Solution()\n    assert solution.friendRequests(3, [[0, 1]], [[0, 2], [1, 2]]) == [False, True]"}, {"start": 44, "end": 50, "test": "def test_friendRequests():\n    n = 3\n    restrictions = [[0,1],[2,0]]\n    requests = [[0,2],[1,2]]\n    expected_result = [False,True]\n    assert solution.friendRequests(n, restrictions, requests) == expected_result"}, {"start": 52, "end": 53, "test": "```\ndef test_friendRequests():\n    solution = Solution()\n    assert solution.friendRequests(3, [[0, 1], [1, 2]], [[0, 1], [1, 2]]) == [True, False]\n```"}, {"start": 48, "end": 50, "test": "```\ndef test_friendRequests():\n    solution=Solution()\n    assert not all(solution.friendRequests(3, [[0, 1]], [[0, 2], [1, 2]]))"}]}
{"task_num": 2086, "task_title": "Minimum Number of Food Buckets to Feed the Hamsters", "func_name": "minimumBuckets", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumBuckets(self, street: str) -> int:\n    A = list(street)\n\n    for i, c in enumerate(A):\n      if c == 'H':\n        if i > 0 and A[i - 1] == 'B':\n          continue\n        if i + 1 < len(A) and A[i + 1] == '.':\n          A[i + 1] = 'B'\n        elif i > 0 and A[i - 1] == '.':\n          A[i - 1] = 'B'\n        else:\n          return -1\n\n    return A.count('B')\n", "tests": [{"start": 16, "end": 24, "test": "def test_minimumBuckets(): \n    solution=Solution(); \n    assert solution.minimumBuckets(\"H...H\") == 2"}, {"start": 17, "end": 18, "test": "def test_minimumBuckets():    \n    solution = Solution()    \n    assert solution.minimumBuckets(\"H...H\") == 2"}, {"start": 19, "end": 20, "test": "```\ndef test_minimumBuckets():\n    solution=Solution()\n    assert solution.minimumBuckets(\"H...H\") == 2\n```"}, {"start": 21, "end": 22, "test": "def test_minimumBuckets():    \n    solution=Solution()    \n    assert solution.minimumBuckets(\"H...H\") == 2"}, {"start": 23, "end": 24, "test": "```\ndef test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets(\"H...H\") == 2\n```"}]}
{"task_num": 2092, "task_title": "Find All People With Secret", "func_name": "findAllPeople", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def connected(self, u: int, v: int) -> bool:\n    return self._find(self.id[u]) == self._find(self.id[v])\n\n  def reset(self, u: int) -> None:\n    self.id[u] = u\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\n    uf = UnionFind(n)\n    timeToPairs = collections.defaultdict(list)\n\n    uf.unionByRank(0, firstPerson)\n\n    for x, y, time in meetings:\n      timeToPairs[time].append((x, y))\n\n    for _, pairs in sorted(timeToPairs.items(), key=lambda x: x[0]):\n      peopleUnioned = set()\n      for x, y in pairs:\n        uf.unionByRank(x, y)\n        peopleUnioned.add(x)\n        peopleUnioned.add(y)\n      for person in peopleUnioned:\n        if not uf.connected(person, 0):\n          uf.reset(person)\n\n    res=[]\n    for i in range(n):\n      if uf.connected(i, 0):\n        res.append(i)\n    return res\n", "tests": [{"start": 19, "end": 20, "test": "def test_findAllPeople():\n    solution = Solution()\n    assert solution.findAllPeople(3, [[0, 1, 0], [2, 0, 1]], 1) == [0, 1, 2]"}, {"start": 21, "end": 22, "test": "def test_findAllPeople():    \n    solution=Solution()    \n    n = 5    \n    meetings = [[0,1,0],[1,2,1],[3,4,2]]    \n    firstPerson = 1    \n    expected_result = [0,1,2]    \n    assert solution.findAllPeople(n,meetings,firstPerson) == expected_result"}, {"start": 36, "end": 37, "test": "def test_findAllPeople():    \n    solution=Solution()    \n    n = 5    \n    meetings = [[0,1,0],[1,2,1],[3,4,2]]    \n    firstPerson = 1    \n    expected_result = [0,1,2]    \n    assert solution.findAllPeople(n,meetings,firstPerson) == expected_result"}, {"start": 23, "end": 24, "test": "def test_findAllPeople(): \n    solution=Solution() \n    res=solution.findAllPeople(5, [[0,1,0],[2,3,1]], 1)"}, {"start": 25, "end": 27, "test": "```\ndef test_findAllPeople():\n    solution=Solution()\n    res=solution.findAllPeople(5, [[0,1,0],[2,3,1]], 1)\n    assert res==[0,1,4], \"Test failed\"\n```"}, {"start": 63, "end": 64, "test": "```\ndef test_findAllPeople():\n    solution=Solution()\n    def test_case():\n        n = 5\n        meetings = [[1,2,0],[3,4,0]]\n        firstPerson = 2\n        expected_result = [0,1,2]\n        result = solution.findAllPeople(n,meetings,firstPerson)\n        assert set(result) == set(expected_result), f\"Expected {expected_result} but got {result}\"\n    test_case()\n```"}, {"start": 58, "end": 59, "test": "```\ndef test_findAllPeople():\n    solution = Solution()\n    assert sorted(solution.findAllPeople(5, [[0,1,0],[2,3,1],[3,4,2]], 1)) == [0,1,3], None\n```"}]}
{"task_num": 2115, "task_title": "Find All Possible Recipes from Given Supplies", "func_name": "findAllRecipes", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n    ans = []\n    supplies = set(supplies)\n    graph = collections.defaultdict(list)\n    inDegrees = collections.Counter()\n    q = collections.deque()\n\n    for i, recipe in enumerate(recipes):\n      for ingredient in ingredients[i]:\n        if ingredient not in supplies:\n          graph[ingredient].append(recipe)\n          inDegrees[recipe] += 1\n\n    for recipe in recipes:\n      if inDegrees[recipe] == 0:\n        q.append(recipe)\n\n    while q:\n      u = q.popleft()\n      ans.append(u)\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    return ans\n", "tests": [{"start": 26, "end": 27, "test": "```\ndef test_findAllRecipes():\n    solution = Solution()\n    recipes = [\"egg\", \"bacon\", \"sandwich\"]\n    ingredients = [[\"egg\"], [\"bacon\"], [\"egg\", \"bacon\"]]\n    supplies = [\"egg\", \"bacon\"]\n    expected_result = [\"sandwich\"]\n    assert solution.findAllRecipes(recipes, ingredients, supplies) == expected_result\n```"}, {"start": 21, "end": 23, "test": "```\ndef test_findAllRecipes():\n    solution = Solution()\n    recipes = [\"chicken\", \"beef\", \"fish\"]\n    ingredients = [[\"chicken\"], [\"beef\", \"chicken\"], [\"fish\", \"beef\"]]\n    supplies = [\"chicken\", \"beef\", \"fish\"]\n    expected_output = [\"chicken\", \"beef\", \"fish\"]\n    assert solution.findAllRecipes(recipes, ingredients, supplies) == expected_output"}, {"start": 34, "end": 35, "test": "```\ndef test_findAllRecipes():\n    solution = Solution()\n    result = solution.findAllRecipes([\"pizza\", \"salad\", \"sandwich\"], [[\"cheese\", \"tomato\"], [\"lettuce\", \"tomato\"], [\"bread\", \"meat\", \"cheese\"]], [\"cheese\", \"tomato\", \"bread\"])\n```"}]}
{"task_num": 2127, "task_title": "Maximum Employees to Be Invited to a Meeting", "func_name": "maximumInvitations", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import Enum\n\n\nclass State(Enum):\n  kInit = 0\n  kVisiting = 1\n  kVisited = 2\n\n\nclass Solution:\n  def maximumInvitations(self, favorite: List[int]) -> int:\n    n = len(favorite)\n    sumComponentsLength = 0\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n    maxChainLength = [1] * n\n\n    for i, f in enumerate(favorite):\n      graph[i].append(f)\n      inDegrees[f] += 1\n\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n\n    while q:\n      u = q.popleft()\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n        maxChainLength[v] = max(maxChainLength[v], 1 + maxChainLength[u])\n\n    for i in range(n):\n      if favorite[favorite[i]] == i:\n        sumComponentsLength += maxChainLength[i] + maxChainLength[favorite[i]]\n\n    maxCycleLength = 0\n    parent = [-1] * n\n    seen = set()\n    states = [State.kInit] * n\n\n    def findCycle(u: int) -> None:\n      nonlocal maxCycleLength\n      seen.add(u)\n      states[u] = State.kVisiting\n      for v in graph[u]:\n        if v not in seen:\n          parent[v] = u\n          findCycle(v)\n        elif states[v] == State.kVisiting:\n          curr = u\n          cycleLength = 1\n          while curr != v:\n            curr = parent[curr]\n            cycleLength += 1\n          maxCycleLength = max(maxCycleLength, cycleLength)\n      states[u] = State.kVisited\n\n    for i in range(n):\n      if i not in seen:\n        findCycle(i)\n\n    return max(sumComponentsLength // 2, maxCycleLength)\n", "tests": [{"start": 43, "end": 44, "test": "```\ndef test_maximumInvitations():\n    solution = Solution()\n    favorite = [1, 0, 2]\n    assert solution.maximumInvitations(favorite) == 3\n```"}, {"start": 69, "end": 70, "test": "```\ndef test_maximumInvitations():\n    def maximumInvitations(favorite):\n        pass\n    solution = Solution()\n    favorite = [1, 2, 3]\n    assert maximumInvitations(favorite) == 3\n```"}, {"start": 38, "end": 39, "test": "```\ndef test_maximumInvitations():\n    favorite = [1, 2, 3]\n```"}, {"start": 56, "end": 58, "test": "```\ndef test_maximumInvitations():\n    def maximumInvitations(self, favorite: List[int]) -> int:\n        return max(3, 2)\n```"}, {"start": 59, "end": 65, "test": "```\ndef test_maximumInvitations():\n    solution=Solution()\n    assert solution.maximumInvitations([0,2,1]) == 3\n```"}]}
{"task_num": 2132, "task_title": "Stamping the Grid", "func_name": "possibleToStamp", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def possibleToStamp(self, grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:\n    m = len(grid)\n    n = len(grid[0])\n    A = [[0] * (n + 1) for _ in range(m + 1)]\n    B = [[0] * (n + 1) for _ in range(m + 1)]\n    fit = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        A[i + 1][j + 1] = A[i + 1][j] + A[i][j + 1] - A[i][j] + grid[i][j]\n        if i + 1 >= stampHeight and j + 1 >= stampWidth:\n          x = i - stampHeight + 1\n          y = j - stampWidth + 1\n          if A[i + 1][j + 1] - A[x][j + 1] - A[i + 1][y] + A[x][y] == 0:\n            fit[i][j] = True\n\n    for i in range(m):\n      for j in range(n):\n        B[i + 1][j + 1] = B[i + 1][j] + B[i][j + 1] - B[i][j] + fit[i][j]\n\n    for i in range(m):\n      for j in range(n):\n        if not grid[i][j]:\n          x = min(i + stampHeight, m)\n          y = min(j + stampWidth, n)\n          if B[x][y] - B[i][y] - B[x][j] + B[i][j] == 0:\n            return False\n\n    return True\n", "tests": [{"start": 22, "end": 26, "test": "def test_possibleToStamp(): \n    solution=Solution() \n    assert not solution.possibleToStamp([[1,0],[0,1]], 2, 2)"}, {"start": 34, "end": 38, "test": "```\ndef test_possibleToStamp():\n    def possibleToStamp(grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:\n        solution = Solution()\n        return solution.possibleToStamp([[0, 1], [0, 1]], 2, 2)\n```"}, {"start": 25, "end": 26, "test": "```\ndef test_possibleToStamp():\n    def possibleToStamp(grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:\n        return solution.possibleToStamp([[0, 1], [0, 1], [0, 0], [0, 0]], 2, 2)\n```"}, {"start": 37, "end": 38, "test": "```\ndef test_possibleToStamp():\n    def possibleToStamp(grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:\n        solution = Solution()\n        assert not solution.possibleToStamp([[0, 1], [0, 1]], 2, 2), \"Expected False\"\n```"}]}
{"task_num": 2146, "task_title": "K Highest Ranked Items Within a Price Range", "func_name": "highestRankedKItems", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    low, high = pricing\n    row, col = start\n    ans = []\n\n    if low <= grid[row][col] <= high:\n      ans.append([row, col])\n      if k == 1:\n        return ans\n\n    q = collections.deque([(row, col)])\n    seen = {(row, col)}\n\n    while q:\n      neighbors = []\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for t in range(4):\n          x = i + dirs[t][0]\n          y = j + dirs[t][1]\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if not grid[x][y] or (x, y) in seen:\n            continue\n          if low <= grid[x][y] <= high:\n            neighbors.append([x, y])\n          q.append((x, y))\n          seen.add((x, y))\n      neighbors.sort(key=lambda x: (grid[x[0]][x[1]], x[0], x[1]))\n      for neighbor in neighbors:\n        if len(ans) < k:\n          ans.append(neighbor)\n        if len(ans) == k:\n          return ans\n\n    return ans\n", "tests": [{"start": 20, "end": 23, "test": "```\ndef test_highestRankedKItems():\n    def test_case():\n        grid = [[0, 3, 2], [1, 1, 1], [4, 5, 6]]\n        pricing = [1, 5]\n        start = [1, 1]\n        k = 2\n        result = solution.highestRankedKItems(grid, pricing, start, k)\n        assert result == [[1, 1], [0, 2]], f\"Expected {[[1, 1], [0, 2]]} but got {result}\"\n    test_case()\n```"}, {"start": 22, "end": 23, "test": "```\ndef test_highestRankedKItems():\n    def test_case():\n        grid = [[0, 3, 2], [1, 1, 1], [4, 5, 6]]\n        pricing = [1, 5]\n        start = [1, 1]\n        k = 1\n        result = solution.highestRankedKItems(grid, pricing, start, k)\n        assert result == [[1, 1]], f\"Expected [[1, 1]] but got {result}\"\n    test_case()\n```"}, {"start": 45, "end": 46, "test": "```\ndef test_highestRankedKItems():\n    def test_case():\n        grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n        pricing = [4, 6]\n        start = [0, 0]\n        k = 2\n        expected_output = [[0, 1], [0, 2]]\n        assert solution.highestRankedKItems(grid, pricing, start, k) == expected_output\n\n    test_case()\n```"}, {"start": 47, "end": 48, "test": "```\ndef test_highestRankedKItems():\n    def test_case():\n        grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n        pricing = [1, 6]\n        start = [0, 0]\n        k = 2\n        expected_output = [[0, 0], [0, 1]]\n        assert solution.highestRankedKItems(grid, pricing, start, k) == expected_output\n\n    test_case()\n```"}, {"start": 35, "end": 36, "test": "```\ndef test_highestRankedKItems():\n    def test_highestRankedKItems():\n        grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n        pricing = [1, 6]\n        start = [0, 0]\n        k = 2\n        assert solution.highestRankedKItems(grid, pricing, start, k) == [[0, 0], [0, 1]], None"}, {"start": 37, "end": 38, "test": "```\ndef test_highestRankedKItems():\n    solution = Solution()\n    grid = [[0, 1, 2], [3, 4, 5], [6, 7, 8]]\n    pricing = [1, 5]\n    start = [0, 0]\n    k = 2\n    assert solution.highestRankedKItems(grid, pricing, start, k) == [[0, 1], [0, 2]], \n```"}, {"start": 39, "end": 40, "test": "```\ndef test_highestRankedKItems():\n    solution = Solution()\n    result = solution.highestRankedKItems([[1, 2, 3], [4, 5, 6], [7, 8, 9]], [1, 5], [0, 0], 2)\n```"}]}
{"task_num": 2157, "task_title": "Groups of Strings", "func_name": "groupStrings", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.sz = [1] * n\n\n  def unionBySize(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.sz[i] < self.sz[j]:\n      self.sz[j] += self.sz[i]\n      self.id[i] = j\n    else:\n      self.sz[i] += self.sz[j]\n      self.id[j] = i\n    self.count -= 1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def groupStrings(self, words: List[str]) -> List[int]:\n    uf = UnionFind(len(words))\n\n    def getMask(s: str) -> int:\n      mask = 0\n      for c in s:\n        mask |= 1 << ord(c) - ord('a')\n      return mask\n\n    def getAddedMasks(mask: int):\n      for i in range(26):\n        if not (mask >> i & 1):\n          yield mask | 1 << i\n\n    def getDeletedMasks(mask: int):\n      for i in range(26):\n        if mask >> i & 1:\n          yield mask ^ 1 << i\n\n    maskToIndex = {getMask(word): i for i, word in enumerate(words)}\n    deletedMaskToIndex = {}\n\n    for i, word in enumerate(words):\n      mask = getMask(word)\n      for m in getAddedMasks(mask):\n        if m in maskToIndex:\n          uf.unionBySize(i, maskToIndex[m])\n      for m in getDeletedMasks(mask):\n        if m in maskToIndex:\n          uf.unionBySize(i, maskToIndex[m])\n        if m in deletedMaskToIndex:\n          uf.unionBySize(i, deletedMaskToIndex[m])\n        else:\n          deletedMaskToIndex[m] = i\n\n    return [uf.count, max(uf.sz)]\n", "tests": [{"start": 20, "end": 21, "test": "```\ndef test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings([\"a\", \"b\", \"c\"]) == [1, 3], None"}, {"start": 22, "end": 24, "test": "```\ndef test_groupStrings():\n    solution=Solution()\n    assert solution.groupStrings([\"a\", \"b\", \"c\"]) == [3, 1], None"}, {"start": 25, "end": 27, "test": "```\ndef test_groupStrings():\n    solution=Solution()\n    assert solution.groupStrings([\"abc\", \"bcd\", \"cde\"]) == [2, 3], None"}, {"start": 31, "end": 32, "test": "```\ndef test_groupStrings():\n    solution=Solution()\n    def test_case():\n        words=[\"abc\",\"bcd\",\"cde\"]\n        result=solution.groupStrings(words)\n        assert result==[2,3]\n    test_case()"}, {"start": 48, "end": 49, "test": "```\ndef test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings([\"abc\", \"bcd\", \"cde\"]) == [2, 3], None"}, {"start": 53, "end": 54, "test": "```\ndef test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings([\"a\", \"ab\", \"abc\"]) == [2, 3], None"}, {"start": 62, "end": 63, "test": "```\ndef test_groupStrings():\n    solution = Solution()\n    result = solution.groupStrings([\"abc\", \"bcd\", \"ace\"])\n```"}, {"start": 65, "end": 66, "test": "```\ndef test_groupStrings():\n    solution = Solution()\n    result = solution.groupStrings([\"a\", \"ab\", \"abc\"])\n```"}, {"start": 67, "end": 68, "test": "```\ndef test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings([\"a\", \"ab\", \"abc\"]) == [2, 1], None\n```"}, {"start": 69, "end": 70, "test": "```\ndef test_groupStrings():\n    solution=Solution()\n    assert solution.groupStrings([\"a\", \"b\", \"c\"]) == [1, 3], None"}]}
{"task_num": 2182, "task_title": "Construct String With Repeat Limit", "func_name": "repeatLimitedString", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\n    ans = ''\n    count = collections.Counter(s)\n\n    while True:\n      addOne = ans and self._shouldAddOne(ans, count)\n      c = self._getLargestChar(ans, count)\n      if c == ' ':\n        break\n      repeats = 1 if addOne else min(count[c], repeatLimit)\n      ans += c * repeats\n      count[c] -= repeats\n\n    return ans\n\n  def _shouldAddOne(self, ans: str, count: collections.Counter) -> bool:\n    for c in reversed(string.ascii_lowercase):\n      if count[c]:\n        return ans[-1] == c\n    return False\n\n  def _getLargestChar(self, ans: str, count: collections.Counter) -> int:\n    for c in reversed(string.ascii_lowercase):\n      if count[c] and (not ans or ans[-1] != c):\n        return c\n    return ' '\n", "tests": [{"start": 19, "end": 20, "test": "```\ndef test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString(\"aaabbbccc\", 1) == \"abc\"\n```"}, {"start": 29, "end": 30, "test": "```\ndef test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString(\"aaabbbccc\", 2) == \"abcabc\"\n```"}, {"start": 35, "end": 36, "test": "```\ndef test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString(\"aaabbbccc\", 2) == \"abcabc\"\n```"}]}
{"task_num": 2203, "task_title": "Minimum Weighted Subgraph With the Required Paths", "func_name": "minimumWeight", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\n    graph = [[] for _ in range(n)]\n    reversedGraph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      reversedGraph[v].append((u, w))\n\n    fromSrc1 = self._dijkstra(graph, src1)\n    fromSrc2 = self._dijkstra(graph, src2)\n    fromDest = self._dijkstra(reversedGraph, dest)\n    minWeight = min(a + b + c for a, b, c in zip(fromSrc1, fromSrc2, fromDest))\n    if minWeight == math.inf:\n      return -1\n    else:\n      return minWeight\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int) -> List[int]:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist\n", "tests": [{"start": 24, "end": 25, "test": "```\ndef test_minimumWeight():\n    solution = Solution()\n    assert solution.minimumWeight(3, [[0, 1, 2], [1, 2, 3]], 0, 1, 2) == -1\n```"}, {"start": 26, "end": 27, "test": "```\ndef test_minimumWeight():\n    solution = Solution()\n    assert solution.minimumWeight(3, [[0, 1, 2], [1, 2, 3], [2, 0, 4]], 0, 1, 2) == 6\n```"}, {"start": 37, "end": 38, "test": "```\ndef test_minimumWeight():\n    solution = Solution()\n    assert solution.minimumWeight(3, [[0, 1, 2], [1, 2, 3], [2, 0, 4]], 0, 1, 2) == 6\n```"}, {"start": 40, "end": 42, "test": "```\ndef test_minimumWeight():\n    solution=Solution()\n    assert solution.minimumWeight(3, [[0,1,2],[1,2,3],[2,0,4]], 0, 1, 2) == 6\n```"}]}
{"task_num": 2242, "task_title": "Maximum Score of a Node Sequence", "func_name": "maximumScore", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\n    n = len(scores)\n    ans = -1\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append((scores[v], v))\n      graph[v].append((scores[u], u))\n\n    for i in range(n):\n      graph[i] = heapq.nlargest(3, graph[i])\n\n    for u, v in edges:\n      for scoreA, a in graph[u]:\n        for scoreB, b in graph[v]:\n          if a != b and a != v and b != u:\n            ans = max(ans, scoreA + scores[u] + scores[v] + scoreB)\n\n    return ans\n", "tests": [{"start": 27, "end": 28, "test": "```\ndef test_maximumScore():\n    solution=Solution()\n    assert solution.maximumScore([1, 2, 3, 4], [[0, 1], [1, 2], [2, 3]]) == 11\n```"}]}
{"task_num": 2245, "task_title": "Maximum Trailing Zeros in a Cornered Path", "func_name": "maxTrailingZeros", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxTrailingZeros(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    leftPrefix2 = [[0] * n for _ in range(m)]\n    leftPrefix5 = [[0] * n for _ in range(m)]\n    topPrefix2 = [[0] * n for _ in range(m)]\n    topPrefix5 = [[0] * n for _ in range(m)]\n\n    def getCount(num: int, factor: int) -> int:\n      count = 0\n      while num % factor == 0:\n        num //= factor\n        count += 1\n      return count\n\n    for i in range(m):\n      for j in range(n):\n        leftPrefix2[i][j] = getCount(grid[i][j], 2)\n        leftPrefix5[i][j] = getCount(grid[i][j], 5)\n        if j:\n          leftPrefix2[i][j] += leftPrefix2[i][j - 1]\n          leftPrefix5[i][j] += leftPrefix5[i][j - 1]\n\n    for j in range(n):\n      for i in range(m):\n        topPrefix2[i][j] = getCount(grid[i][j], 2)\n        topPrefix5[i][j] = getCount(grid[i][j], 5)\n        if i:\n          topPrefix2[i][j] += topPrefix2[i - 1][j]\n          topPrefix5[i][j] += topPrefix5[i - 1][j]\n\n    ans = 0\n    for i in range(m):\n      for j in range(n):\n        curr2 = getCount(grid[i][j], 2)\n        curr5 = getCount(grid[i][j], 5)\n        l2 = leftPrefix2[i][j]\n        l5 = leftPrefix5[i][j]\n        r2 = leftPrefix2[i][n - 1] - (0 if j == 0 else leftPrefix2[i][j - 1])\n        r5 = leftPrefix5[i][n - 1] - (0 if j == 0 else leftPrefix5[i][j - 1])\n        t2 = topPrefix2[i][j]\n        t5 = topPrefix5[i][j]\n        d2 = topPrefix2[m - 1][j] - (0 if i == 0 else topPrefix2[i - 1][j])\n        d5 = topPrefix5[m - 1][j] - (0 if i == 0 else topPrefix5[i - 1][j])\n        ans = max(ans, min(l2 + t2 - curr2, l5 + t5 - curr5), min(r2 + t2 - curr2, r5 + t5 - curr5), min(l2 + d2 - curr2, l5 + d5 - curr5), min(r2 + d2 - curr2, r5 + d5 - curr5))\n\n    return ans\n", "tests": [{"start": 31, "end": 33, "test": "def test_maxTrailingZeros(): \n    grid = [[14,13,2], [7,1,0]] \n    assert maxTrailingZeros(grid) == 6"}, {"start": 39, "end": 41, "test": "def test_maxTrailingZeros(): \n    solution = Solution() \n    assert solution.maxTrailingZeros([[14, 0], [0, 5]]) == 6"}]}
{"task_num": 2257, "task_title": "Count Unguarded Cells in the Grid", "func_name": "countUnguarded", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\n    ans = 0\n    grid = [[0] * n for _ in range(m)]\n    left = [[0] * n for _ in range(m)]\n    right = [[0] * n for _ in range(m)]\n    up = [[0] * n for _ in range(m)]\n    down = [[0] * n for _ in range(m)]\n\n    for row, col in guards:\n      grid[row][col] = 'G'\n\n    for row, col in walls:\n      grid[row][col] = 'W'\n\n    for i in range(m):\n      lastCell = 0\n      for j in range(n):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          left[i][j] = lastCell\n      lastCell = 0\n      for j in range(n - 1, -1, -1):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          right[i][j] = lastCell\n\n    for j in range(n):\n      lastCell = 0\n      for i in range(m):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          up[i][j] = lastCell\n      lastCell = 0\n      for i in range(m - 1, -1, -1):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          down[i][j] = lastCell\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 0 and left[i][j] != 'G' and right[i][j] != 'G' and up[i][j] != 'G' and down[i][j] != 'G':\n          ans += 1\n\n    return ans\n", "tests": [{"start": 29, "end": 30, "test": "def test_countUnguarded(): \n    solution=Solution() \n    assert solution.countUnguarded(3, 3, [[0,1],[2,2]], [[1,1]]) == 4"}, {"start": 31, "end": 32, "test": "def test_countUnguarded(): \n    solution=Solution() \n    assert solution.countUnguarded(3, 3, [[0,1],[2,2]], [[1,0]]) == 4"}, {"start": 35, "end": 36, "test": "def test_countUnguarded(): \n    solution=Solution() \n    assert solution.countUnguarded(3, 3, [[0,1],[2,2]], [[1,1]]) == 4"}, {"start": 37, "end": 38, "test": "def test_countUnguarded(): \n    solution=Solution() \n    assert solution.countUnguarded(3, 3, [[0,1],[2,2]], [[1,0],[1,2]]) == 4"}, {"start": 43, "end": 44, "test": "def test_countUnguarded(): \n    solution=Solution() \n    assert solution.countUnguarded(3, 3, [[0,1],[2,2]], [[1,1]]) == 4"}, {"start": 45, "end": 46, "test": "def test_countUnguarded(): \n    solution=Solution() \n    assert solution.countUnguarded(3, 3, [[0,1],[2,2]], [[1,1]]) == 4"}, {"start": 49, "end": 50, "test": "def test_countUnguarded(): \n    solution=Solution() \n    assert solution.countUnguarded(3, 3, [[0,1],[2,2]], [[1,0],[1,2]]) == 4"}, {"start": 51, "end": 52, "test": "def test_countUnguarded(): \n    solution=Solution() \n    assert solution.countUnguarded(3, 3, [[0,1],[2,2]], [[1,0],[2,1]]) == 4"}, {"start": 56, "end": 57, "test": "def test_countUnguarded(): \n    solution = Solution() \n    assert solution.countUnguarded(3, 3, [[0, 0], [2, 1]], [[1, 1]]) == 4"}]}
{"task_num": 2258, "task_title": "Escape the Spreading Fire", "func_name": "maximumMinutes", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumMinutes(self, grid: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    kMax = len(grid) * len(grid[0])\n    fireGrid = [[-1] * len(grid[0]) for _ in range(len(grid))]\n    self._buildFireGrid(grid, fireGrid, dirs)\n\n    ans = -1\n    l = 0\n    r = kMax\n\n    while l <= r:\n      m = (l + r) // 2\n      if self._canStayFor(grid, fireGrid, m, dirs):\n        ans = m\n        l = m + 1\n      else:\n        r = m - 1\n\n    return int(1e9) if ans == kMax else ans\n\n  def _buildFireGrid(self, grid: List[List[int]], fireMinute: List[List[int]], dirs: List[int]) -> None:\n    minuteFromFire = 0\n    q = collections.deque()\n\n    for i in range(len(grid)):\n      for j in range(len(grid[0])):\n        if grid[i][j] == 1:\n          q.append((i, j))\n          fireMinute[i][j] = 0\n    while q:\n      minuteFromFire += 1\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == len(grid) or y < 0 or y == len(grid[0]):\n            continue\n          if grid[x][y] == 2:\n            continue\n          if fireMinute[x][y] != -1:\n            continue\n          fireMinute[x][y] = minuteFromFire\n          q.append((x, y))\n\n  def _canStayFor(self, grid: List[List[int]], fireMinute: List[List[int]], minute: int, dirs: List[int]) -> bool:\n    q = collections.deque([(0, 0)])\n    seen = {(0, 0)}\n\n    while q:\n      minute += 1\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == len(grid) or y < 0 or y == len(grid[0]):\n            continue\n          if grid[x][y] == 2:\n            continue\n          if x == len(grid) - 1 and y == len(grid[0]) - 1:\n            if fireMinute[x][y] != -1 and fireMinute[x][y] < minute:\n              continue\n            return True\n          if fireMinute[x][y] != -1 and fireMinute[x][y] <= minute:\n            continue\n          if (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n\n    return False\n", "tests": [{"start": 24, "end": 26, "test": "```\ndef test_maximumMinutes():\n    grid = [[0, 0, 0], [0, 2, 0], [0, 1, 0]]\n    assert maximumMinutes(grid) == 3\n```"}, {"start": 27, "end": 28, "test": "```\ndef test_maximumMinutes():\n    grid = [[0, 0, 0], [1, 1, 2]]\n    assert maximumMinutes(grid) == 3\n```"}, {"start": 38, "end": 40, "test": "```\ndef test_maximumMinutes():\n    def maximum_minutes(grid):\n        pass\n    grid = [[1, 2], [0, 0]]\n    assert maximum_minutes(grid) == 3, f\"Expected maximum_minutes({grid}) to return 3, but got {maximum_minutes(grid)}\"\n```"}, {"start": 48, "end": 49, "test": "```\ndef test_maximumMinutes():\n    grid = [[1, 2], [0, 0]]\n    assert maximumMinutes(grid) == 3\n```"}, {"start": 50, "end": 51, "test": "```\ndef test_maximumMinutes():\n    def maximum_minutes(grid):\n        return Solution().maximumMinutes([[0,1],[0,0]])\n```"}, {"start": 52, "end": 53, "test": "```\ndef test_maximumMinutes():\n    grid = [[0, 0, 0], [0, 2, 0], [0, 1, 0]]\n    assert maximumMinutes(grid) == 4\n```"}, {"start": 68, "end": 69, "test": "```\ndef test_maximumMinutes():\n    def test_case():\n        grid = [[1, 2], [0, 0]]\n        assert maximumMinutes(grid) == 3\n    return test_case\n```"}, {"start": 70, "end": 71, "test": "```\ndef test_maximumMinutes():\n    def maximum_minutes(grid):\n        return 3\n    assert solution.maximumMinutes([[0,1],[0,0]]) == 3\n```"}, {"start": 72, "end": 75, "test": "```\ndef test_maximumMinutes():\n    grid = [[0, 0, 0], [1, 2, 0], [0, 0, 0]]\n    assert solution.maximumMinutes(grid) == 3\n```"}, {"start": 76, "end": 77, "test": "```\ndef test_maximumMinutes():\n    grid = [[0, 0, 0], [0, 2, 0], [1, 1, 0]]\n    assert maximumMinutes(grid) == 4\n```"}, {"start": 78, "end": 79, "test": "```\ndef test_maximumMinutes():\n    grid = [[0, 1], [2, 0]]\n    assert maximumMinutes(grid) == 3\n```"}, {"start": 73, "end": 74, "test": "```\ndef test_maximumMinutes():\n    grid = [[0, 0, 0], [0, 2, 0], [1, 1, 1]]\n    assert maximumMinutes(grid) == 4\n```"}]}
{"task_num": 2290, "task_title": "Minimum Obstacle Removal to Reach Corner", "func_name": "minimumObstacles", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumObstacles(self, grid: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    minHeap = [(grid[0][0], 0, 0)]  # (d, i, j)\n    dist = [[math.inf] * n for _ in range(m)]\n    dist[0][0] = grid[0][0]\n\n    while minHeap:\n      d, i, j = heapq.heappop(minHeap)\n      if i == m - 1 and j == n - 1:\n        return d\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        newDist = d + grid[i][j]\n        if newDist < dist[x][y]:\n          dist[x][y] = newDist\n          heapq.heappush(minHeap, (newDist, x, y))\n\n    return dist[m - 1][n - 1]\n", "tests": [{"start": 22, "end": 23, "test": "```\ndef test_minimumObstacles():\n    solution = Solution()\n    assert solution.minimumObstacles([[0, 0], [0, 1]]) == 1\n```"}, {"start": 27, "end": 28, "test": "```\ndef test_minimumObstacles():\n    solution = Solution()\n    assert solution.minimumObstacles([[0, 1], [0, 0]]) == 1\n```"}, {"start": 30, "end": 32, "test": "```\ndef test_minimumObstacles():\n    solution=Solution()\n    assert solution.minimumObstacles([[0, 1], [0, 0]]) == 1\n```"}]}
{"task_num": 2299, "task_title": "Strong Password Checker II", "func_name": "strongPasswordCheckerII", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def strongPasswordCheckerII(self, password: str) -> bool:\n    if len(password) < 8:\n      return False\n    if not any(c.islower() for c in password):\n      return False\n    if not any(c.isupper() for c in password):\n      return False\n    if not any(c.isdigit() for c in password):\n      return False\n    if not any(\"!@#$%^&*()-+\".find(c) != -1 for c in password):\n      return False\n    return all(a != b for a, b in zip(password, password[1:]))\n", "tests": [{"start": 13, "end": 14, "test": "def test_strongPasswordCheckerII():    \n    solution = Solution()    \n    assert not solution.strongPasswordCheckerII(\"short\"), \"password length less than 8\""}, {"start": 15, "end": 16, "test": "def test_strongPasswordCheckerII():    \n    solution = Solution()\n    assert not solution.strongPasswordCheckerII(\"1234567\")"}, {"start": 17, "end": 18, "test": "def test_strongPasswordCheckerII(): \n    solution = Solution(); \n    assert not solution.strongPasswordCheckerII(\"abcdefg\")"}, {"start": 19, "end": 20, "test": "def test_strongPasswordCheckerII():    \n    solution = Solution()\n    assert not solution.strongPasswordCheckerII(\"abcdef\"), None"}, {"start": 21, "end": 22, "test": "def test_strongPasswordCheckerII(): \n    solution = Solution() \n    assert not solution.strongPasswordCheckerII(\"Aa1!\")"}]}
{"task_num": 2301, "task_title": "Match Substring After Replacement", "func_name": "matchReplacement", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def matchReplacement(self, s: str, sub: str, mappings: List[List[str]]) -> bool:\n    isMapped = [[False] * 128 for _ in range(128)]\n\n    for old, new in mappings:\n      isMapped[ord(old)][ord(new)] = True\n\n    for i in range(len(s)):\n      if self._canTransform(s, i, sub, isMapped):\n        return True\n\n    return False\n\n  def _canTransform(self, s: str, start: int, sub: str, isMapped: List[List[bool]]) -> bool:\n    if start + len(sub) > len(s):\n      return False\n\n    for i in range(len(sub)):\n      a = sub[i]\n      b = s[start + i]\n      if a != b and not isMapped[ord(a)][ord(b)]:\n        return False\n\n    return True\n", "tests": [{"start": 25, "end": 26, "test": "```\ndef test_matchReplacement():\n    solution = Solution()\n    assert not solution.matchReplacement(\"abc\", \"abx\", [[\"a\", \"1\"], [\"b\", \"2\"]])\n```"}, {"start": 19, "end": 20, "test": "```\ndef test_matchReplacement():\n    solution = Solution()\n    assert not solution.matchReplacement(\"abc\", \"abx\", [[\"a\",\"1\"],[\"b\",\"2\"]])\n```"}, {"start": 31, "end": 32, "test": "```\ndef test_matchReplacement():\n    solution = Solution()\n    assert not solution.matchReplacement(\"abc\", \"abx\", [[\"a\",\"b\"],[\"x\",\"y\"]])\n```"}]}
{"task_num": 2322, "task_title": "Minimum Score After Removals on a Tree", "func_name": "minimumScore", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Set\n\nclass Solution:\n  def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\n    n = len(nums)\n    xors = functools.reduce(lambda x, y: x ^ y, nums)\n    subXors = nums[:]\n    tree = [[] for _ in range(n)]\n    children = [{i} for i in range(n)]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, parent: int) -> Tuple[int, Set[int]]:\n      for v in tree[u]:\n        if v == parent:\n          continue\n        vXor, vChildren = dfs(v, u)\n        subXors[u] ^= vXor\n        children[u] |= vChildren\n      return subXors[u], children[u]\n\n    dfs(0, -1)\n\n    ans = math.inf\n    for i in range(len(edges)):\n      a, b = edges[i]\n      if b in children[a]:\n        a, b = b, a\n      for j in range(i):\n        c, d = edges[j]\n        if d in children[c]:\n          c, d = d, c\n\n        if c in children[a] and a != c:\n          cands = [subXors[c], subXors[a] ^ subXors[c], xors ^ subXors[a]]\n        elif a in children[c] and a != c:\n          cands = [subXors[a], subXors[c] ^ subXors[a], xors ^ subXors[c]]\n        else:\n          cands = [subXors[a], subXors[c], xors ^ subXors[a] ^ subXors[c]]\n        ans = min(ans, max(cands) - min(cands))\n\n    return ans\n", "tests": [{"start": 37, "end": 38, "test": "def test_minimumScore(): \n    solution=Solution() \n    nums=[1,2,3] \n    edges=[[0,1],[1,2]] \n    assert solution.minimumScore(nums,edges)==1"}, {"start": 25, "end": 26, "test": "def test_minimumScore():    \n    solution = Solution()    \n    nums = [1, 2, 3]    \n    edges = [[0, 1], [1, 2]]    \n    assert minimumScore(solution, nums, edges) == 2"}, {"start": 41, "end": 42, "test": "def test_minimumScore(): \n    solution=Solution() \n    nums=[1,2,3] \n    edges=[[0,1],[1,2]] \n    assert minimumScore(solution,nums,edges)==1"}, {"start": 44, "end": 45, "test": "```\ndef test_minimumScore():\n    solution=Solution()\n    assert solution.minimumScore([1, 2, 3], [[0, 1], [1, 2]]) == 2\n```"}, {"start": 46, "end": 47, "test": "```\ndef test_minimumScore():\n    def solution=Solution()\n    assert solution.minimumScore([1, 2, 3], [[0, 1], [1, 2]]) == 2\n```"}, {"start": 48, "end": 49, "test": "```\ndef test_minimumScore():\n    def solution=Solution()\n    assert min(solution.minimumScore([1, 2, 3], [[0, 1], [1, 2]])) == 2\n```"}]}
{"task_num": 2332, "task_title": "The Latest Time to Catch a Bus", "func_name": "latestTimeCatchTheBus", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\n    buses.sort()\n    passengers.sort()\n\n    if passengers[0] > buses[-1]:\n      return buses[-1]\n\n    ans = passengers[0] - 1\n    i = 0\n    j = 0\n    while i < len(buses):\n      arrived = 0\n      while arrived < capacity and j < len(passengers) and passengers[j] <= buses[i]:\n        if j > 0 and passengers[j] != passengers[j - 1] + 1:\n          ans = passengers[j] - 1\n        j += 1\n        arrived += 1\n\n      if arrived < capacity and j > 0 and passengers[j - 1] != buses[i]:\n        ans = buses[i]\n      i += 1\n\n    return ans\n", "tests": [{"start": 16, "end": 17, "test": "```\ndef test_latestTimeCatchTheBus():\n    solution = Solution()\n    assert solution.latestTimeCatchTheBus([0, 10, 60], [5, 30, 75], 3) == 59\n```"}, {"start": 30, "end": 31, "test": "```\ndef test_latestTimeCatchTheBus():\n    def latestTimeCatchTheBus(buses: List[int], passengers: List[int], capacity: int) -> int:\n        solution = Solution()\n        assert solution.latestTimeCatchTheBus([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], 3) == 11\n```"}, {"start": 25, "end": 26, "test": "```\ndef test_latestTimeCatchTheBus():\n    solution=Solution()\n    assert solution.latestTimeCatchTheBus([0,2,5,7], [1,4,8,9], 3) == 8\n```"}]}
{"task_num": 2337, "task_title": "Move Pieces to Obtain a String", "func_name": "canChange", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def canChange(self, start: str, target: str) -> bool:\n    n = len(start)\n    i = 0\n    j = 0\n\n    while i <= n and j <= n:\n      while i < n and start[i] == '_':\n        i += 1\n      while j < n and target[j] == '_':\n        j += 1\n      if i == n or j == n:\n        return i == n and j == n\n      if start[i] != target[j]:\n        return False\n      if start[i] == 'R' and i > j:\n        return False\n      if start[i] == 'L' and i < j:\n        return False\n      i += 1\n      j += 1\n\n    return True\n", "tests": [{"start": 22, "end": 23, "test": "```\ndef test_canChange():\n    solution = Solution()\n    assert not solution.canChange(\"_L\", \"_R\"), \n```"}, {"start": 24, "end": 25, "test": "```\ndef test_canChange():\n    solution = Solution()\n    assert not solution.canChange(\"R\", \"L\")\n```"}, {"start": 26, "end": 27, "test": "```\ndef test_canChange():\n    solution=Solution()\n    assert not solution.canChange('RL_', '_LR'), None\n```"}, {"start": 28, "end": 29, "test": "```\ndef test_canChange():\n    solution=Solution()\n    assert not solution.canChange('R_L_', '_L_R'), None"}]}
{"task_num": 2392, "task_title": "Build a Matrix With Conditions", "func_name": "buildMatrix", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\n    rowOrder = self._topologicalSort(rowConditions, k)\n    if not rowOrder:\n      return []\n\n    colOrder = self._topologicalSort(colConditions, k)\n    if not colOrder:\n      return []\n\n    ans = [[0] * k for _ in range(k)]\n    nodeToRowIndex = [0] * (k + 1)\n\n    for i, node in enumerate(rowOrder):\n      nodeToRowIndex[node] = i\n\n    for j, node in enumerate(colOrder):\n      i = nodeToRowIndex[node]\n      ans[i][j] = node\n\n    return ans\n\n  def _topologicalSort(self, conditions: List[List[int]], n: int) -> List[int]:\n    order = []\n    graph = [[] for _ in range(n + 1)]\n    inDegrees = [0] * (n + 1)\n\n    for u, v in conditions:\n      graph[u].append(v)\n      inDegrees[v] += 1\n\n    q = collections.deque([i for i in range(1, n + 1) if inDegrees[i] == 0])\n\n    while q:\n      u = q.popleft()\n      order.append(u)\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    if len(order) == n:\n      return order\n    else:\n      return []\n", "tests": [{"start": 14, "end": 15, "test": "```\ndef test_buildMatrix():\n    def buildMatrix(k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\n        k = 3\n        rowConditions = [[1, 2], [2, 0]]\n        colConditions = [[1, 2], [2, 0]]\n        return solution.buildMatrix(k, rowConditions, colConditions)\n```"}, {"start": 18, "end": 19, "test": "```\ndef test_buildMatrix():\n    def buildMatrix(k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\n        k = 3\n        rowConditions = [[1, 2], [2, 0]]\n        colConditions = [[1, 2], [2, 1]]\n        expected = [[0, 0, 0],\n                    [0, 1, 0],\n                    [0, 0, 2]]\n        return expected\n```"}, {"start": 52, "end": 53, "test": "```\ndef test_buildMatrix():\n    def solution=Solution()\n    k = 3\n    rowConditions = [[1,2],[2,0]]\n    colConditions = [[1,2],[2,0]]\n    result = solution.buildMatrix(k, rowConditions, colConditions)\n```"}, {"start": 54, "end": 55, "test": "```\ndef test_buildMatrix():\n    def assert_equal(expected, actual):\n        if expected != actual:\n            raise AssertionError(f\"Expected {expected}, but got {actual}\")\n    \n    solution = Solution()\n    k = 3\n    rowConditions = [[1, 2], [2, 0]]\n    colConditions = [[1, 2], [2, 0]]\n    assert_equal([], solution.buildMatrix(k, rowConditions, colConditions))\n```"}, {"start": 49, "end": 50, "test": "```\ndef test_buildMatrix():\n    def buildMatrix(k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\n        k = 3\n        rowConditions = [[1, 2], [2, 0]]\n        colConditions = [[1, 2], [2, 0]]\n        expected_output = [[0, 0, 1], [0, 2, 0], [1, 0, 0]]\n        return buildMatrix(k, rowConditions, colConditions) == expected_output"}]}
{"task_num": 2437, "task_title": "Number of Valid Clock Times", "func_name": "countTime", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countTime(self, time: str) -> int:\n    ans = 1\n    if time[3] == '?':\n      ans *= 6\n    if time[4] == '?':\n      ans *= 10\n\n    if time[0] == '?' and time[1] == '?':\n      return ans * 24\n    if time[0] == '?':\n      if time[1] < '4':\n        return ans * 3\n      else:\n        return ans * 2\n    if time[1] == '?':\n      if time[0] == '2':\n        return ans * 4\n      else:\n        return ans * 10\n    return ans\n", "tests": [{"start": 14, "end": 15, "test": "def test_countTime():    \n    solution = Solution()    \n    assert solution.countTime(\"0?59\") == 60, \"Test failed\""}, {"start": 16, "end": 17, "test": "```\ndef test_countTime():\n    solution=Solution()\n    assert solution.countTime(\"2?59\") == 20, \"Test failed\"\n```"}, {"start": 19, "end": 20, "test": "```\ndef test_countTime():\n    solution=Solution()\n    assert solution.countTime(\"???:59\") == 24*6*10, None"}, {"start": 21, "end": 25, "test": "```\ndef test_countTime():\n    solution=Solution()\n    assert solution.countTime(\"1?34\") == 20, \"Test failed\"\n```"}, {"start": 26, "end": 30, "test": "```\ndef test_countTime():\n    solution=Solution()\n    assert solution.countTime(\"2?59\") == 40, f\"Expected countTime('2?59') to return 40, but got {solution.countTime('2?59')} instead\"\n```"}, {"start": 22, "end": 23, "test": "```\ndef test_countTime():\n    solution=Solution()\n    assert solution.countTime(\"2?3\") == 6, f\"Expected countTime('2?3') to return 6, but got {solution.countTime('2?3')} instead\"\n```"}, {"start": 24, "end": 25, "test": "```\ndef test_countTime():\n    solution=Solution()\n    assert solution.countTime(\"20??:59\") == 2, f\"Expected countTime('20??:59') to return 2, but got {solution.countTime('20??:59')}\"\n\n```"}, {"start": 27, "end": 28, "test": "def test_countTime(): \n    solution = Solution() \n    assert solution.countTime(\"2?59\") == 40, \"Test failed\""}, {"start": 29, "end": 30, "test": "```\ndef test_countTime():\n    solution=Solution()\n    assert solution.countTime(\"2?59\") == 20, None\n```"}]}
{"task_num": 2456, "task_title": "Most Popular Video Creator", "func_name": "mostPopularCreator", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Creator:\n  def __init__(self, popularity: int, videoId: str, maxView: int):\n    self.popularity = popularity\n    self.videoId = videoId\n    self.maxView = maxView\n\n\nclass Solution:\n  def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\n    ans = []\n    maxPopularity = 0\n    nameToCreator = {}\n\n    for name, id, view in zip(creators, ids, views):\n      if name not in nameToCreator:\n        nameToCreator[name] = Creator(view, id, view)\n        maxPopularity = max(maxPopularity, view)\n        continue\n      creator = nameToCreator[name]\n      creator.popularity += view\n      maxPopularity = max(maxPopularity, creator.popularity)\n      if creator.maxView < view or creator.maxView == view and creator.videoId > id:\n        creator.videoId = id\n        creator.maxView = view\n\n    for name, creator in nameToCreator.items():\n      if creator.popularity == maxPopularity:\n        ans.append([name, creator.videoId])\n\n    return ans\n", "tests": [{"start": 25, "end": 28, "test": "```\ndef test_mostPopularCreator():\n    solution=Solution()\n    creators=[\"Alice\", \"Bob\", \"Alice\"]\n    ids=[\"video1\", \"video2\", \"video3\"]\n    views=[10, 20, 30]\n    expected_result = [[\"Alice\", \"video3\"]]\n    assert solution.mostPopularCreator(creators, ids, views) == expected_result"}, {"start": 32, "end": 34, "test": "```\ndef test_mostPopularCreator():\n    solution=Solution()\n    def test_case():\n        creators=[\"A\", \"B\", \"C\"]\n        ids=[\"video1\", \"video2\", \"video3\"]\n        views=[10, 20, 30]\n        expected_output = [[\"B\", \"video2\"]]\n        assert solution.mostPopularCreator(creators, ids, views) == expected_output\n    test_case()\n```"}, {"start": 37, "end": 38, "test": "```\ndef test_mostPopularCreator():\n    solution=Solution()\n    assert solution.mostPopularCreator([\"Alice\", \"Bob\", \"Alice\"], [\"video1\", \"video2\", \"video3\"], [10, 20, 15]) == [[\"Alice\", \"video1\"]], \n```"}]}
{"task_num": 2462, "task_title": "Total Cost to Hire K Workers", "func_name": "totalCost", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\n    ans = 0\n    i = 0\n    j = len(costs) - 1\n    minHeapL = []\n    minHeapR = []\n\n    for _ in range(k):\n      while len(minHeapL) < candidates and i <= j:\n        heapq.heappush(minHeapL, costs[i])\n        i += 1\n      while len(minHeapR) < candidates and i <= j:\n        heapq.heappush(minHeapR, costs[j])\n        j -= 1\n      if not minHeapL:\n        ans += heapq.heappop(minHeapR)\n      elif not minHeapR:\n        ans += heapq.heappop(minHeapL)\n      elif minHeapL[0] <= minHeapR[0]:\n        ans += heapq.heappop(minHeapL)\n      else:\n        ans += heapq.heappop(minHeapR)\n\n    return ans\n", "tests": [{"start": 26, "end": 27, "test": "```\ndef test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([3, 2, 7, 7, 1, 2], 2, 2) == 5\n```"}, {"start": 28, "end": 29, "test": "```\ndef test_totalCost():\n    def total_cost(costs: List[int], k: int, candidates: int) -> int:\n        return 0 if not minHeapR else heapq.heappop(minHeapL)\n```"}, {"start": 30, "end": 31, "test": "```\ndef test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([3, 2, 7, 7, 1, 2], 2, 2) == 5\n```"}, {"start": 32, "end": 33, "test": "```\ndef test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([3, 2, 7, 7, 1, 2], 2, 2) == 5\n```"}]}
{"task_num": 2467, "task_title": "Most Profitable Path in a Tree", "func_name": "mostProfitablePath", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\n    n = len(amount)\n    tree = [[] for _ in range(n)]\n    parent = [0] * n\n    aliceDist = [-1] * n\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, prev: int, d: int) -> None:\n      parent[u] = prev\n      aliceDist[u] = d\n      for v in tree[u]:\n        if aliceDist[v] == -1:\n          dfs(v, u, d + 1)\n\n    dfs(0, -1, 0)\n\n    u = bob\n    bobDist = 0\n    while u != 0:\n      if bobDist < aliceDist[u]:\n        amount[u] = 0\n      elif bobDist == aliceDist[u]:\n        amount[u] //= 2\n      u = parent[u]\n      bobDist += 1\n\n    return self._getMoney(tree, 0, -1, amount)\n\n  def _getMoney(self, tree: List[List[int]], u: int, prev: int, amount: List[int]) -> int:\n    if len(tree[u]) == 1 and tree[u][0] == prev:\n      return amount[u]\n\n    maxPath = -math.inf\n    for v in tree[u]:\n      if v != prev:\n        maxPath = max(maxPath, self._getMoney(tree, v, u, amount))\n\n    return amount[u] + maxPath\n", "tests": [{"start": 44, "end": 45, "test": "```\ndef test_mostProfitablePath():\n    solution = Solution()\n    edges = [[0, 1], [1, 2], [2, 3]]\n    bob = 2\n    amount = [-10, -5, 0]\n    assert solution.mostProfitablePath(edges, bob, amount) == 0\n```"}, {"start": 34, "end": 35, "test": "```\ndef test_mostProfitablePath():\n    solution=Solution()\n    edges = [[0,1],[1,2],[2,3]]\n    bob = 2\n    amount = [5,-10,15]\n    assert solution.mostProfitablePath(edges, bob, amount) == 20\n```"}, {"start": 49, "end": 50, "test": "```\ndef test_mostProfitablePath():\n    edges = [[0, 1], [1, 2], [2, 3]]\n    bob = 2\n    amount = [-1, -2, 3]\n    assert mostProfitablePath(solution, edges, bob, amount) == 5\n```"}, {"start": 26, "end": 27, "test": "```\ndef test_mostProfitablePath():\n    solution = Solution()\n    edges = [[0, 1], [1, 2], [2, 3]]\n    bob = 2\n    amount = [-1, -2, -3, 4]\n    assert solution.mostProfitablePath(edges, bob, amount) == 5"}, {"start": 36, "end": 37, "test": "```\ndef test_mostProfitablePath():\n    solution = Solution()\n    edges = [[0,1],[1,2],[2,3]]\n    bob = 2\n    amount = [5,-10,15]\n    assert solution.mostProfitablePath(edges, bob, amount) == 20"}]}
{"task_num": 2499, "task_title": "Minimum Total Cost to Make Arrays Unequal", "func_name": "minimumTotalCost", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\n    n = len(nums1)\n    ans = 0\n    maxFreq = 0\n    maxFreqNum = 0\n    shouldBeSwapped = 0\n    conflictedNumCount = [0] * (n + 1)\n\n    for i, (num1, num2) in enumerate(zip(nums1, nums2)):\n      if num1 == num2:\n        conflictedNum = num1\n        conflictedNumCount[conflictedNum] += 1\n        if conflictedNumCount[conflictedNum] > maxFreq:\n          maxFreq = conflictedNumCount[conflictedNum]\n          maxFreqNum = conflictedNum\n        shouldBeSwapped += 1\n        ans += i\n\n    for i, (num1, num2) in enumerate(zip(nums1, nums2)):\n      if maxFreq * 2 <= shouldBeSwapped:\n        break\n      if num1 == num2:\n        continue\n\n      if num1 == maxFreqNum or num2 == maxFreqNum:\n        continue\n      shouldBeSwapped += 1\n      ans += i\n\n    if maxFreq * 2 > shouldBeSwapped:\n      return -1\n    else:\n      return ans\n", "tests": [{"start": 41, "end": 42, "test": "```\ndef test_minimumTotalCost():\n    def solution=Solution()\n    assert solution.minimumTotalCost([1, 2, 3], [4, 5, 6]) == -1\n```"}, {"start": 43, "end": 44, "test": "```\ndef test_minimumTotalCost():\n    solution=Solution()\n    assert solution.minimumTotalCost([1, 2, 3], [4, 5, 6]) == 9\n```"}, {"start": 21, "end": 28, "test": "def test_minimumTotalCost():\n    solution=Solution()\n    assert solution.minimumTotalCost([1,2,3], [1,2,3]) == 0"}, {"start": 31, "end": 32, "test": "def test_minimumTotalCost():    \n    solution = Solution()    \n    assert solution.minimumTotalCost([1, 2, 3], [4, 5, 6]) == 9"}, {"start": 33, "end": 34, "test": "```\ndef test_minimumTotalCost():\n    solution=Solution()\n    assert solution.minimumTotalCost([1, 2, 3], [1, 2, 3]) == -1\n```"}, {"start": 36, "end": 37, "test": "```\ndef test_minimumTotalCost():\n    def solution=Solution()\n    assert solution.minimumTotalCost([1, 2, 3], [4, 5, 6]) == 9\n```"}, {"start": 24, "end": 26, "test": "def test_minimumTotalCost(): \n    solution=Solution() \n    assert solution.minimumTotalCost([1, 2, 3], [1, 2, 3]) == 0"}]}
{"task_num": 2503, "task_title": "Maximum Number of Points From Grid Queries", "func_name": "maxPoints", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, query: int):\n    self.queryIndex = queryIndex\n    self.query = query\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.query\n\n\nclass Solution:\n  def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    ans = [0] * len(queries)\n    minHeap = [(grid[0][0], 0, 0)]\n    seen = {(0, 0)}\n    accumulate = 0\n\n    for queryIndex, query in sorted([IndexedQuery(i, query) for i, query in enumerate(queries)], key=lambda iq: iq.query):\n      while minHeap:\n        val, i, j = heapq.heappop(minHeap)\n        if val >= query:\n          heapq.heappush(minHeap, (val, i, j))\n          break\n        accumulate += 1\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if (x, y) in seen:\n            continue\n          heapq.heappush(minHeap, (grid[x][y], x, y))\n          seen.add((x, y))\n      ans[queryIndex] = accumulate\n\n    return ans\n", "tests": [{"start": 34, "end": 36, "test": "```\ndef test_maxPoints():\n    solution = Solution()\n    result = solution.maxPoints([[1, 2], [3, 4]], [5])\n```"}, {"start": 41, "end": 42, "test": "```\ndef test_maxPoints():\n    solution = Solution()\n    result = solution.maxPoints([[1, 2], [3, 4]], [5])\n```"}, {"start": 43, "end": 44, "test": "```\ndef test_maxPoints():\n    solution = Solution()\n    result = solution.maxPoints([[1, 2], [3, 4]], [5])\n```"}]}
{"task_num": 2508, "task_title": "Add Edges to Make Degrees of All Nodes Even", "func_name": "isPossible", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isPossible(self, n: int, edges: List[List[int]]) -> bool:\n    graph = [set() for _ in range(n)]\n\n    for u, v in edges:\n      graph[u - 1].add(v - 1)\n      graph[v - 1].add(u - 1)\n\n    oddNodes = [i for i, neighbor in enumerate(graph) if len(neighbor) & 1]\n    if not oddNodes:\n      return True\n    if len(oddNodes) == 2:\n      a, b = oddNodes\n      return any(a not in graph[i] and b not in graph[i] for i in range(n))\n    if len(oddNodes) == 4:\n      a, b, c, d = oddNodes\n      return (b not in graph[a] and d not in graph[c]) or (c not in graph[a] and d not in graph[b]) or (d not in graph[a] and c not in graph[b])\n    return False\n", "tests": [{"start": 20, "end": 21, "test": "```\ndef test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(3, [[1, 2], [2, 3]]) == True\n```"}, {"start": 22, "end": 24, "test": "```\ndef test_isPossible():\n    solution=Solution()\n    assert not solution.isPossible(3, [[1,2],[2,3]])"}, {"start": 25, "end": 27, "test": "```\ndef test_isPossible():\n    solution = Solution()\n    assert not solution.isPossible(5, [[1, 2], [2, 3], [4, 5], [3, 4]]), \"Expected False\"\n```"}]}
{"task_num": 2523, "task_title": "Closest Prime Numbers in Range", "func_name": "closestPrimes", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def closestPrimes(self, left: int, right: int) -> List[int]:\n    isPrime = self._sieveEratosthenes(right + 1)\n    primes=[]\n    for i in range(left, right+1):\n      if isPrime[i]:\n        primes.append(i)\n\n    if len(primes) < 2:\n      return [-1, -1]\n\n    minDiff = math.inf\n    num1 = -1\n    num2 = -1\n\n    for a, b in zip(primes, primes[1:]):\n      diff = b - a\n      if diff < minDiff:\n        minDiff = diff\n        num1 = a\n        num2 = b\n\n    return [num1, num2]\n\n  def _sieveEratosthenes(self, n: int) -> List[bool]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return isPrime\n", "tests": [{"start": 19, "end": 20, "test": "```\ndef test_closestPrimes():\n    solution=Solution()\n    assert solution.closestPrimes(4,10) == [5,7], None\n```"}, {"start": 16, "end": 17, "test": "```\ndef test_closestPrimes():\n    solution=Solution()\n    assert solution.closestPrimes(2, 10) == [3, 5]\n```"}, {"start": 28, "end": 31, "test": "```\ndef test_closestPrimes():\n    solution=Solution()\n    assert solution.closestPrimes(4, 10) == [5, 7]\n```"}, {"start": 40, "end": 42, "test": "def test_closestPrimes(): \n    solution=Solution() \n    assert solution.closestPrimes(2, 10) == [3, 5],"}]}
{"task_num": 2532, "task_title": "Time to Cross a Bridge", "func_name": "findCrossingTime", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n    ans = 0\n    leftBridgeQueue = [(-leftToRight - rightToLeft, -i) for i, (leftToRight, pickOld, rightToLeft, pickNew) in enumerate(time)]\n    rightBridgeQueue = []\n    leftWorkers = []\n    rightWorkers = []\n\n    heapq.heapify(leftBridgeQueue)\n\n    while n > 0 or rightBridgeQueue or rightWorkers:\n      while leftWorkers and leftWorkers[0][0] <= ans:\n        i = heapq.heappop(leftWorkers)[1]\n        heapq.heappush(leftBridgeQueue, (-time[i][0] - time[i][2], -i))\n      while rightWorkers and rightWorkers[0][0] <= ans:\n        i = heapq.heappop(rightWorkers)[1]\n        heapq.heappush(rightBridgeQueue, (-time[i][0] - time[i][2], -i))\n      if rightBridgeQueue:\n        i = -heapq.heappop(rightBridgeQueue)[1]\n        ans += time[i][2]\n        heapq.heappush(leftWorkers, (ans + time[i][3], i))\n      elif leftBridgeQueue and n > 0:\n        i = -heapq.heappop(leftBridgeQueue)[1]\n        ans += time[i][0]\n        heapq.heappush(rightWorkers, (ans + time[i][1], i))\n        n -= 1\n      else:\n        if leftWorkers and n > 0:\n          ans1=leftWorkers[0][0]\n        else:\n          ans1=math.inf\n        if rightWorkers:\n          ans2=rightWorkers[0][0]\n        else:\n          ans2=math.inf\n        ans=min(ans1,ans2)\n\n    return ans", "tests": [{"start": 28, "end": 31, "test": "```\ndef test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(2, 1, [[0, 0, 0, 0], [1, 1, 1, 1]]) == 3\n```"}, {"start": 32, "end": 36, "test": "```\ndef test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(2, 3, [[10, 5, 15, 20], [12, 7, 14, 25], [9, 4, 11, 18]]) == 30\n```"}, {"start": 37, "end": 46, "test": "```\ndef test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(3, 2, [[10, 5, 15, 20], [12, 7, 14, 18]]) == 24\n```"}, {"start": 38, "end": 39, "test": "```\ndef test_findCrossingTime():\n    def findCrossingTime(n: int, k: int, time: List[List[int]]) -> int:\n        return 10\n```"}, {"start": 40, "end": 41, "test": "```\ndef test_findCrossingTime():\n    def findCrossingTime(n: int, k: int, time: List[List[int]]) -> int:\n        return 0 if n > 0 or rightBridgeQueue or rightWorkers else math.inf\n```"}, {"start": 42, "end": 43, "test": "```\ndef test_findCrossingTime():\n    def findCrossingTime(n: int, k: int, time: List[List[int]]) -> int:\n        return 5\n```"}, {"start": 44, "end": 45, "test": "```\ndef test_findCrossingTime():\n    def findCrossingTime(n: int, k: int, time: List[List[int]]) -> int:\n        return 10\n```"}]}
{"task_num": 2577, "task_title": "Minimum Time to Visit a Cell In a Grid", "func_name": "minimumTime", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumTime(self, grid: List[List[int]]) -> int:\n    if grid[0][1] > 1 and grid[1][0] > 1:\n      return -1\n\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    minHeap = [(0, 0, 0)]\n    seen = {(0, 0)}\n\n    while minHeap:\n      time, i, j = heapq.heappop(minHeap)\n      if i == m - 1 and j == n - 1:\n        return time\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if (x, y) in seen:\n          continue\n        if (grid[x][y] - time) % 2 == 0:\n          extraWait = 1\n        else:\n          extraWait = 0\n        nextTime = max(time + 1, grid[x][y] + extraWait)\n        heapq.heappush(minHeap, (nextTime, x, y))\n        seen.add((x, y))\n", "tests": [{"start": 13, "end": 14, "test": "```\ndef test_minimumTime():\n    solution = Solution()\n    assert solution.minimumTime([[2, 0], [3, 4]]) == -1\n```"}, {"start": 24, "end": 25, "test": "def test_minimumTime():    \n    solution = Solution()    \n    assert solution.minimumTime([[0, 1], [2, 3]]) == 4"}, {"start": 29, "end": 30, "test": "def test_minimumTime():    \n    solution = Solution()    \n    assert solution.minimumTime([[0,1],[2,3]]) == 4"}, {"start": 31, "end": 32, "test": "def test_minimumTime():    \n    solution = Solution()    \n    assert solution.minimumTime([[0, 1], [2, 3]]) == 4"}, {"start": 33, "end": 34, "test": "```\ndef test_minimumTime():\n    solution=Solution()\n    assert solution.minimumTime([[0,1],[2,3]]) == 4\n```"}, {"start": 35, "end": 36, "test": "```\ndef test_minimumTime():\n    solution=Solution()\n    assert solution.minimumTime([[1,2],[3,4]]) == 7\n```"}]}
{"task_num": 2601, "task_title": "Prime Subtraction Operation", "func_name": "primeSubOperation", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def primeSubOperation(self, nums: List[int]) -> bool:\n    kMax = 1000\n    primes = self._sieveEratosthenes(kMax)\n\n    prevNum = 0\n    for num in nums:\n      i = bisect.bisect_left(primes, num - prevNum)\n      if i > 0:\n        num -= primes[i - 1]\n      if num <= prevNum:\n        return False\n      prevNum = num\n\n    return True\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return [i for i in range(n) if isPrime[i]]\n", "tests": [{"start": 19, "end": 20, "test": "```\ndef test_primeSubOperation():\n    solution = Solution()\n    assert not solution.primeSubOperation([2, 3, 5])"}, {"start": 21, "end": 22, "test": "```\ndef test_primeSubOperation():\n    solution = Solution()\n    assert not solution.primeSubOperation([1, 2, 3])"}, {"start": 32, "end": 34, "test": "```\ndef test_primeSubOperation():\n    solution=Solution()\n    assert not solution.primeSubOperation([2, 4, 6])"}]}
{"task_num": 2603, "task_title": "Collect Coins in a Tree", "func_name": "collectTheCoins", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def collectTheCoins(self, coins: List[int], edges: List[List[int]]) -> int:\n    n = len(coins)\n    tree = [set() for _ in range(n)]\n    leavesToBeRemoved = collections.deque()\n\n    for u, v in edges:\n      tree[u].add(v)\n      tree[v].add(u)\n\n    for u in range(n):\n      while len(tree[u]) == 1 and coins[u] == 0:\n        v = tree[u].pop()\n        tree[v].remove(u)\n        u = v\n      if len(tree[u]) == 1:\n        leavesToBeRemoved.append(u)\n\n    for _ in range(2):\n      for _ in range(len(leavesToBeRemoved)):\n        u = leavesToBeRemoved.popleft()\n        if tree[u]:\n          v = tree[u].pop()\n          tree[v].remove(u)\n          if len(tree[v]) == 1:\n            leavesToBeRemoved.append(v)\n\n    return sum(len(children) for children in tree)\n", "tests": [{"start": 26, "end": 27, "test": "```\ndef test_collectTheCoins():\n    solution = Solution()\n    coins = [0, 0, 1, 0]\n    edges = [[0, 1], [1, 2]]\n    assert solution.collectTheCoins(coins, edges) == 3\n```"}, {"start": 32, "end": 36, "test": "```\ndef test_collectTheCoins():\n    solution = Solution()\n    coins = [0, 0, 1, 0]\n    edges = [[0, 1], [1, 2]]\n    assert solution.collectTheCoins(coins, edges) == 3\n```"}, {"start": 35, "end": 36, "test": "```\ndef test_collectTheCoins():\n    solution = Solution()\n    coins = [0, 0, 1, 0]\n    edges = [[0, 1], [1, 2]]\n    assert solution.collectTheCoins(coins, edges) == 3\n```"}]}
{"task_num": 2653, "task_title": "Sliding Subarray Beauty", "func_name": "getSubarrayBeauty", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\n    ans = []\n    count = [0] * 50\n\n    for i, num in enumerate(nums):\n      if num < 0:\n        count[num + 50] += 1\n      if i - k >= 0 and nums[i - k] < 0:\n        count[nums[i - k] + 50] -= 1\n      if i + 1 >= k:\n        ans.append(self._getXthSmallestNum(count, x))\n\n    return ans\n\n  def _getXthSmallestNum(self, count: List[int], x: int) -> int:\n    prefix = 0\n    for i in range(50):\n      prefix += count[i]\n      if prefix >= x:\n        return i - 50\n    return 0\n", "tests": [{"start": 17, "end": 18, "test": "def test_getSubarrayBeauty():    \n    solution = Solution()    \n    nums = [-3, -2, -1, 0, 1, 2, 3]    \n    k = 4    \n    x = 2    \n    result = solution.getSubarrayBeauty(nums, k, x)"}, {"start": 19, "end": 20, "test": "```\ndef test_getSubarrayBeauty():\n    solution = Solution()\n    nums = [-3, -2, -1, 0, 1, 2]\n    k = 3\n    x = 2\n    result = solution.getSubarrayBeauty(nums, k, x)\n```"}, {"start": 21, "end": 22, "test": "```\ndef test_getSubarrayBeauty():\n    solution = Solution()\n    result = solution.getSubarrayBeauty([-1, -2, 0, 3], 2, 1)\n    print(result)"}, {"start": 30, "end": 31, "test": "```\ndef test_getSubarrayBeauty():\n    solution = Solution()\n    result = solution.getSubarrayBeauty([-1, -2, -3], 3, 2)\n```"}]}
{"task_num": 2662, "task_title": "Minimum Cost of a Path With Special Roads", "func_name": "minimumCost", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\n    return self.dijkstra(specialRoads, *start, *target)\n\n  def dijkstra(self, specialRoads: List[List[int]], srcX: int, srcY: int, dstX: int, dstY: int) -> int:\n    n = len(specialRoads)\n    dist = [math.inf] * n\n    minHeap = []\n\n    for u, (x1, y1, _, _, cost) in enumerate(specialRoads):\n      d = abs(x1 - srcX) + abs(y1 - srcY) + cost\n      dist[u] = d\n      heapq.heappush(minHeap, (dist[u], u))\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      _, _, ux2, uy2, _ = specialRoads[u]\n      for v in range(n):\n        if v == u:\n          continue\n        vx1, vy1, _, _, vcost = specialRoads[v]\n        newDist = d + abs(vx1 - ux2) + abs(vy1 - uy2) + vcost\n        if newDist < dist[v]:\n          dist[v] = newDist\n          heapq.heappush(minHeap, (dist[v], v))\n\n    ans = abs(dstX - srcX) + abs(dstY - srcY)\n    for u in range(n):\n      _, _, x2, y2, _ = specialRoads[u]\n      ans = min(ans, dist[u] + abs(dstX - x2) + abs(dstY - y2))\n\n    return ans\n", "tests": [{"start": 27, "end": 28, "test": "```\ndef test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost([0, 0], [1, 1], [[0, 0, 0, 0, 1]]) == 2\n```"}, {"start": 31, "end": 32, "test": "```\ndef test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost([0, 0], [1, 1], [[0, 0, 0, 0, 1], [0, 0, 1, 1, 2]]) == 3\n```"}, {"start": 35, "end": 37, "test": "```\ndef test_minimumCost():\n    solution=Solution()\n    assert solution.minimumCost([0, 0], [1, 1], [[0, 0, 1, 1, 2]]) == 4\n```"}]}
{"task_num": 2663, "task_title": "Lexicographically Smallest Beautiful String", "func_name": "smallestBeautifulString", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def smallestBeautifulString(self, s: str, k: int) -> str:\n    chars = list(s)\n\n    for i in reversed(range(len(chars))):\n      chars[i] = chr(ord(chars[i]) + 1)\n      while self._containsPalindrome(chars, i):\n        chars[i] = chr(ord(chars[i]) + 1)\n      if chars[i] < chr(ord('a') + k):\n        return self._changeSuffix(chars, i + 1)\n\n    return ''\n\n  def _containsPalindrome(self, chars: List[str], i: int) -> bool:\n    return (i > 0 and chars[i] == chars[i - 1]) or (i > 1 and chars[i] == chars[i - 2])\n\n  def _changeSuffix(self, chars: List[str], i: int) -> str:\n    for j in range(i, len(chars)):\n      chars[j] = 'a'\n      while self._containsPalindrome(chars, j):\n        chars[j] = chr(ord(chars[j]) + 1)\n    return ''.join(chars)\n", "tests": [{"start": 19, "end": 20, "test": "```\ndef test_smallestBeautifulString():\n    solution = Solution()\n    assert solution.smallestBeautifulString(\"abc\", 3) == \"abcd\""}]}
{"task_num": 2672, "task_title": "Number of Adjacent Elements With the Same Color", "func_name": "colorTheArray", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\n    ans = []\n    arr = [0] * n\n    sameColors = 0\n\n    for i, color in queries:\n      if i + 1 < n:\n        if arr[i + 1] > 0 and arr[i + 1] == arr[i]:\n          sameColors -= 1\n        if arr[i + 1] == color:\n          sameColors += 1\n      if i > 0:\n        if arr[i - 1] > 0 and arr[i - 1] == arr[i]:\n          sameColors -= 1\n        if arr[i - 1] == color:\n          sameColors += 1\n      arr[i] = color\n      ans.append(sameColors)\n\n    return ans\n", "tests": [{"start": 18, "end": 22, "test": "def test_colorTheArray(): \n    solution = Solution() \n    assert solution.colorTheArray(5, [[0, 1], [2, 2], [3, 1]]) == [0, 1, 1]"}, {"start": 23, "end": 27, "test": "def test_colorTheArray(): \n    solution = Solution() \n    assert solution.colorTheArray(3, [[0, 1], [1, 2]]) == [1, 0]"}, {"start": 19, "end": 20, "test": "```\ndef test_colorTheArray():\n    solution = Solution()\n    assert solution.colorTheArray(3, [[0, 1], [1, 2], [2, 1]]) == [1, 0]\n```"}, {"start": 21, "end": 22, "test": "def test_colorTheArray():    \n    solution = Solution()    \n    result = solution.colorTheArray(5, [[0, 1], [2, 3]])    \n    assert result == [1, 1]"}, {"start": 24, "end": 25, "test": "def test_colorTheArray(): \n    solution = Solution() \n    assert solution.colorTheArray(5, [[0, 1], [2, 3], [4, 2]]) == [1, 0, 1]"}, {"start": 26, "end": 27, "test": "def test_colorTheArray():    \n    solution = Solution()    \n    result = solution.colorTheArray(5, [[0, 1], [2, 3], [4, 2]])    \n    assert result == [1, 0, 1]"}]}
{"task_num": 2684, "task_title": "Maximum Number of Moves in a Grid", "func_name": "maxMoves", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxMoves(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n\n    for j in range(n - 2, -1, -1):\n      for i in range(m):\n        if grid[i][j + 1] > grid[i][j]:\n          dp[i][j] = 1 + dp[i][j + 1]\n        if i > 0 and grid[i - 1][j + 1] > grid[i][j]:\n          dp[i][j] = max(dp[i][j], 1 + dp[i - 1][j + 1])\n        if i + 1 < m and grid[i + 1][j + 1] > grid[i][j]:\n          dp[i][j] = max(dp[i][j], 1 + dp[i + 1][j + 1])\n\n    return max(dp[i][0] for i in range(m))\n", "tests": [{"start": 19, "end": 20, "test": "```\ndef test_maxMoves():\n    solution=Solution()\n    assert solution.maxMoves([[1,2,3],[4,5,6]]) == 3\n```"}, {"start": 21, "end": 22, "test": "```\ndef test_maxMoves():\n    solution=Solution()\n    assert solution.maxMoves([[1,2,3],[4,5,6]]) == 3\n```"}, {"start": 23, "end": 24, "test": "```\ndef test_maxMoves():\n    solution=Solution()\n    assert solution.maxMoves([[1,2,3],[4,5,6]]) == 3\n```"}]}
{"task_num": 2685, "task_title": "Count the Number of Complete Components", "func_name": "countCompleteComponents", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n    self.nodeCount = [1] * n\n    self.edgeCount = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    self.edgeCount[i] += 1\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n      self.edgeCount[j] += self.edgeCount[i]\n      self.nodeCount[j] += self.nodeCount[i]\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n      self.edgeCount[i] += self.edgeCount[j]\n      self.nodeCount[i] += self.nodeCount[j]\n    else:\n      self.id[i] = j\n      self.edgeCount[j] += self.edgeCount[i]\n      self.nodeCount[j] += self.nodeCount[i]\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n  def isComplete(self, u):\n    return self.nodeCount[u] * (self.nodeCount[u] - 1) // 2 == self.edgeCount[u]\n\n\nclass Solution:\n  def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\n    ans = 0\n    uf = UnionFind(n)\n    parents = set()\n\n    for u, v in edges:\n      uf.unionByRank(u, v)\n\n    for i in range(n):\n      parent = uf.find(i)\n      if parent not in parents and uf.isComplete(parent):\n        ans += 1\n        parents.add(parent)\n\n    return ans\n", "tests": [{"start": 22, "end": 23, "test": "```\ndef test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(3, [[0, 1], [1, 2]]) == 1\n```"}, {"start": 24, "end": 27, "test": "```\ndef test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(3, [[0, 1], [1, 2]]) == 1\n```"}, {"start": 39, "end": 40, "test": "```\ndef test_countCompleteComponents():\n    solution=Solution()\n    assert solution.countCompleteComponents(3, [[0,1],[1,2]]) == 1\n```"}, {"start": 28, "end": 31, "test": "```\ndef test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(3, [[0, 1], [1, 2]]) == 1\n```"}, {"start": 32, "end": 36, "test": "```\ndef test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(5, [[0,1],[1,2],[2,3],[3,4]]) == 1\n```"}, {"start": 58, "end": 60, "test": "```\ndef test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(3, [[0, 1], [1, 2]]) == 1\n```"}]}
{"task_num": 2699, "task_title": "Modify Graph Edge Weights", "func_name": "modifiedGraphEdges", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\n\nclass Solution:\n  def modifiedGraphEdges(self, n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:\n    kMax = 2_000_000_000\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      if w == -1:\n        continue\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    distToDestination = self._dijkstra(graph, source, destination)\n    if distToDestination < target:\n      return []\n    if distToDestination == target:\n      for edge in edges:\n        if edge[2] == -1:\n          edge[2] = kMax\n      return edges\n\n    for i, (u, v, w) in enumerate(edges):\n      if w != -1:\n        continue\n      edges[i][2] = 1\n      graph[u].append((v, 1))\n      graph[v].append((u, 1))\n      distToDestination = self._dijkstra(graph, source, destination)\n      if distToDestination <= target:\n        edges[i][2] += target - distToDestination\n        for j in range(i + 1, len(edges)):\n          if edges[j][2] == -1:\n            edges[j][2] = kMax\n        return edges\n\n    return []\n\n  def _dijkstra(self, graph: List[List[int]], src: int, dst: int) -> int:\n    dist = [math.inf] * len(graph)\n    minHeap = []\n    dist[src] = 0\n    heapq.heappush(minHeap, (dist[src], src))\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist[dst]\n", "tests": [{"start": 24, "end": 25, "test": "```\ndef test_modifiedGraphEdges():\n    def modifiedGraphEdgesTest(n: int, edges: List[List[int]], source: int, destination: int, target: int) -> None:\n        solution = Solution()\n        assert solution.modifiedGraphEdges(n, edges, source, destination, target) == [], reason=\"Expected an empty array\"\n```"}, {"start": 26, "end": 30, "test": "```\ndef test_modifiedGraphEdges():\n    def modifiedGraphEdges_test_input():\n        n = 3\n        edges = [[0,1,-1],[1,2,-1]]\n        source = 0\n        destination = 2\n        target = 2\n        return solution.modifiedGraphEdges(n, edges, source, destination, target)\n```"}, {"start": 18, "end": 19, "test": "```\ndef test_modifiedGraphEdges():\n    def modifiedGraphEdgesTest(n: int, edges: List[List[int]], source: int, destination: int, target: int) -> None:\n        solution = Solution()\n        result = solution.modifiedGraphEdges(n, edges, source, destination, target)\n        assert result == [[0, 1, -1], [1, 2, 3], [2, 0, 4]]\n```"}, {"start": 33, "end": 34, "test": "```\ndef test_modifiedGraphEdges():\n    def modifiedGraphEdgesTest(n: int, edges: List[List[int]], source: int, destination: int, target: int) -> None:\n        solution = Solution()\n        result = solution.modifiedGraphEdges(n, edges, source, destination, target)\n        assert result == [[0, 1, 2], [1, 2, -1], [2, 3, 1]], f\"Expected modifiedGraphEdges({n}, {edges}, {source}, {destination}, {target}) to return [{0, 1, 2}, {1, 2, -1}, {2, 3, 1}], but got {result}\"\n```"}, {"start": 39, "end": 44, "test": "```\ndef test_modifiedGraphEdges():\n    solution=Solution()\n    def test_case():\n        n = 5\n        edges = [[0,1,-1],[1,2,-1],[2,3,-1],[3,4,-1],[4,0,-1]]\n        source = 0\n        destination = 4\n        target = 2\n        return solution.modifiedGraphEdges(n, edges, source, destination, target)\n```"}, {"start": 56, "end": 57, "test": "```\ndef test_modifiedGraphEdges():\n    def modifiedGraphEdgesTest(n: int, edges: List[List[int]], source: int, destination: int, target: int) -> None:\n        solution = Solution()\n        result = solution.modifiedGraphEdges(n, edges, source, destination, target)\n        assert result == [[0, 1, 2], [1, 2, -1], [2, 3, 1]], f\"Expected modifiedGraphEdges({n}, {edges}, {source}, {destination}, {target}) to return {result}\"\n```"}, {"start": 28, "end": 29, "test": "```\ndef test_modifiedGraphEdges():\n    solution=Solution()\n    result = solution.modifiedGraphEdges(3, [[0, 1, -1], [1, 2, -1]], 0, 2, 2)\n```"}, {"start": 59, "end": 61, "test": "```\ndef test_modifiedGraphEdges():\n    def modifiedGraphEdges(n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:\n        n = 5\n        edges = [[0,1,-1],[1,2,7],[2,3,6],[3,4,-1],[4,0,8]]\n        source = 0\n        destination = 4\n        target = 10\n        return solution.modifiedGraphEdges(n, edges, source, destination, target)\n```"}, {"start": 42, "end": 43, "test": "```\ndef test_modifiedGraphEdges():\n    solution=Solution()\n    def test_case():\n        n = 5\n        edges = [[0,1,-1],[1,2,-1],[2,3,-1],[3,4,-1],[4,0,-1]]\n        source = 0\n        destination = 4\n        target = 2\n        result = solution.modifiedGraphEdges(n, edges, source, destination, target)\n        return result == [[0,1,2147483647],[1,2,2147483647],[2,3,2147483647],[3,4,2147483647],[4,0,1]]\n    assert test_case() is None\n```"}]}
{"task_num": 2708, "task_title": "Maximum Strength of a Group", "func_name": "maxStrength", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxStrength(self, nums: List[int]) -> int:\n    posProd = 1\n    negProd = 1\n    maxNeg = -math.inf\n    negCount = 0\n    hasPos = False\n    hasZero = False\n\n    for num in nums:\n      if num > 0:\n        posProd *= num\n        hasPos = True\n      elif num < 0:\n        negProd *= num\n        maxNeg = max(maxNeg, num)\n        negCount += 1\n      else:\n        hasZero = True\n\n    if negCount == 0 and not hasPos:\n      return 0\n    if negCount % 2 == 0:\n      return negProd * posProd\n    if negCount >= 3:\n      return negProd // maxNeg * posProd\n    if hasPos:\n      return posProd\n    if hasZero:\n      return 0\n    return maxNeg\n", "tests": [{"start": 31, "end": 32, "test": "```\ndef test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([1, -2, 3]) == 6, f\"Expected maxStrength([1, -2, 3]) to return 6, but got {solution.maxStrength([1, -2, 3])}\"\n```"}, {"start": 33, "end": 34, "test": "```\ndef test_maxStrength():\n    solution=Solution()\n    assert solution.maxStrength([-1, -2, 3, 4]) == 12\n```"}, {"start": 35, "end": 36, "test": "```\ndef test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([-1, -2, -3]) == 2, None"}, {"start": 37, "end": 38, "test": "```\ndef test_maxStrength():\n    solution=Solution()\n    assert solution.maxStrength([1, 2, 3]) == 6\n```"}, {"start": 39, "end": 40, "test": "```\ndef test_maxStrength():\n    solution=Solution()\n    assert solution.maxStrength([1, -2, 3, 0]) == 0\n```"}, {"start": 21, "end": 23, "test": "```\ndef test_maxStrength():\n    solution=Solution()\n    assert solution.maxStrength([1, -2, 3]) == 6, f\"Expected maxStrength([1, -2, 3]) to return 6, but got {solution.maxStrength([1, -2, 3])}\"\n```"}, {"start": 24, "end": 27, "test": "```\ndef test_maxStrength():\n    solution=Solution()\n    assert solution.maxStrength([-3,-2,0,4]) == 24\n```"}, {"start": 28, "end": 29, "test": "```\ndef test_maxStrength():\n    solution=Solution()\n    assert solution.maxStrength([0, 1, -2]) == 0\n```"}]}
{"task_num": 2709, "task_title": "Greatest Common Divisor Traversal", "func_name": "canTraverseAllPairs", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.sz = [1] * n\n\n  def unionBySize(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.sz[i] < self.sz[j]:\n      self.sz[j] += self.sz[i]\n      self.id[i] = j\n    else:\n      self.sz[i] += self.sz[j]\n      self.id[j] = i\n\n  def getSize(self, i: int) -> int:\n    return self.sz[i]\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def canTraverseAllPairs(self, nums: List[int]) -> bool:\n    n = len(nums)\n    max_num = max(nums)\n    maxPrimeFactor = self._sieveEratosthenes(max_num + 1)\n    primeToFirstIndex = collections.defaultdict(int)\n    uf = UnionFind(n)\n\n    for i, num in enumerate(nums):\n      for prime_factor in self._getPrimeFactors(num, maxPrimeFactor):\n        if prime_factor in primeToFirstIndex:\n          uf.unionBySize(primeToFirstIndex[prime_factor], i)\n        else:\n          primeToFirstIndex[prime_factor] = i\n\n    return any(uf.getSize(i) == n for i in range(n))\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeFactors(self, num: int, minPrimeFactors: List[int]) -> List[int]:\n    primeFactors = []\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      primeFactors.append(divisor)\n      while num % divisor == 0:\n        num //= divisor\n    return primeFactors\n", "tests": [{"start": 19, "end": 20, "test": "def test_canTraverseAllPairs(): \n    solution = Solution() \n    assert not solution.canTraverseAllPairs([1, 2])"}, {"start": 21, "end": 23, "test": "```\ndef test_canTraverseAllPairs():\n    solution=Solution()\n    assert not solution.canTraverseAllPairs([1, 2, 3])"}, {"start": 24, "end": 26, "test": "```\ndef test_canTraverseAllPairs():\n    solution=Solution()\n    assert not solution.canTraverseAllPairs([1, 2, 3])"}, {"start": 32, "end": 33, "test": "```\ndef test_canTraverseAllPairs():\n    solution=Solution()\n    assert not solution.canTraverseAllPairs([1, 2, 3])"}, {"start": 57, "end": 59, "test": "```\ndef test_canTraverseAllPairs():\n    solution=Solution()\n    assert not solution.canTraverseAllPairs([1, 2, 3])"}, {"start": 47, "end": 48, "test": "```\ndef test_canTraverseAllPairs():\n    solution = Solution()\n    assert not solution.canTraverseAllPairs([1, 2, 3])"}, {"start": 49, "end": 50, "test": "```\ndef test_canTraverseAllPairs():\n    solution=Solution()\n    assert not solution.canTraverseAllPairs([1, 2, 3])"}]}
{"task_num": 2736, "task_title": "Maximum Sum Queries", "func_name": "maximumSumQueries", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Pair:\n  def __init__(self, x: int, y: int):\n    self.x = x\n    self.y = y\n\n  def __iter__(self):\n    yield self.x\n    yield self.y\n\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, minX: int, minY: int):\n    self.queryIndex = queryIndex\n    self.minX = minX\n    self.minY = minY\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.minX\n    yield self.minY\n\n\nclass Solution:\n  def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n    pairs = sorted([Pair(nums1[i], nums2[i])\n                   for i in range(len(nums1))], key=lambda p: p.x, reverse=True)\n    ans = [0] * len(queries)\n    stack = []  # [(y, x + y)]\n\n    pairsIndex = 0\n    for queryIndex, minX, minY in sorted([IndexedQuery(i, query[0], query[1]) for i, query in enumerate(queries)], key=lambda iq: -iq.minX):\n      while pairsIndex < len(pairs) and pairs[pairsIndex].x >= minX:\n        x, y = pairs[pairsIndex]\n        while stack and x + y >= stack[-1][1]:\n          stack.pop()\n        if not stack or y > stack[-1][0]:\n          stack.append((y, x + y))\n        pairsIndex += 1\n      j = self._firstGreaterEqual(stack, minY)\n      if j == len(stack):\n        ans[queryIndex] = -1\n      else:\n        ans[queryIndex] = stack[j][1]\n\n    return ans\n\n  def _firstGreaterEqual(self, A: List[Tuple[int, int]], target: int) -> int:\n    l = 0\n    r = len(A)\n    while l < r:\n      m = (l + r) // 2\n      if A[m][0] >= target:\n        r = m\n      else:\n        l = m + 1\n    return l\n", "tests": [{"start": 50, "end": 51, "test": "```\ndef test_maximumSumQueries():\n    def test_case():\n        nums1 = [3, 2, 5]\n        nums2 = [6, 7, 8]\n        queries = [[4, 5], [6, 9]]\n        expected = [-1, 17]\n        return solution.maximumSumQueries(nums1, nums2, queries) == expected\n\n    assert test_case()\n```"}, {"start": 52, "end": 53, "test": "```\ndef test_maximumSumQueries():\n    def maximumSumQueries(nums1, nums2, queries):\n        solution = Solution()\n        return solution.maximumSumQueries(nums1, nums2, queries)\n    \n    assert maximumSumQueries([3, 4, 5], [6, 7, 8], [[1, 2], [2, 3]]) == [-1, 15]\n```"}, {"start": 62, "end": 63, "test": "```\ndef test_maximumSumQueries():\n    solution=Solution()\n    def test_case():\n        nums1 = [3, 4, 5]\n        nums2 = [6, 7, 8]\n        queries = [[0, 0], [1, 1]]\n        expected = [-1, 15]\n        assert solution.maximumSumQueries(nums1, nums2, queries) == expected\n    test_case()\n```"}, {"start": 64, "end": 65, "test": "```\ndef test_maximumSumQueries():\n    def maximumSumQueries(nums1, queries):\n        return Solution().maximumSumQueries(nums1, nums2, queries)\n    \n    nums1 = [3, 4, 5]\n    nums2 = [6, 7, 8]\n    queries = [[0, 10], [1, 15]]\n    assert maximumSumQueries(nums1, queries) == [24, -1]"}, {"start": 46, "end": 47, "test": "```\ndef test_maximumSumQueries():\n    solution = Solution()\n    result = solution.maximumSumQueries([3, 2, 1], [4, 5, 6], [[1, 2], [2, 3]])\n    assert result == [-1, 10]\n```"}]}
{"task_num": 2747, "task_title": "Count Zero Request Servers", "func_name": "countServers", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, query: int):\n    self.queryIndex = queryIndex\n    self.query = query\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.query\n\n\nclass Solution:\n  def countServers(self, n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:\n    ans = [0] * len(queries)\n    count = [0] * (n + 1)\n\n    logs.sort(key=lambda log: log[1])\n\n    i = 0\n    j = 0\n    servers = 0\n\n    for queryIndex, query in sorted([IndexedQuery(i, query) for i, query in enumerate(queries)], key=lambda iq: iq.query):\n      while j < len(logs) and logs[j][1] <= query:\n        count[logs[j][0]] += 1\n        if count[logs[j][0]] == 1:\n          servers += 1\n        j += 1\n      while i < len(logs) and logs[i][1] < query - x:\n        count[logs[i][0]] -= 1\n        if count[logs[i][0]] == 0:\n          servers -= 1\n        i += 1\n      ans[queryIndex] = n - servers\n\n    return ans\n", "tests": [{"start": 35, "end": 36, "test": "```\ndef test_countServers():\n    solution = Solution()\n    assert solution.countServers(3, [[1, 2], [2, 5], [3, 4]], 2, [7, 10]) == [0, 2]\n```"}, {"start": 40, "end": 41, "test": "```\ndef test_countServers():\n    solution = Solution()\n    assert solution.countServers(3, [[1, 2], [2, 5], [3, 4]], 2, [7, 10]) == [0, 2]\n```"}]}
{"task_num": 2751, "task_title": "Robot Collisions", "func_name": "survivedRobotsHealths", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\nfrom dataclasses import dataclass\n\n@dataclass\nclass Robot:\n  index: int\n  position: int\n  health: int\n  direction: str\n\n\nclass Solution:\n  def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\n    robots = sorted([Robot(index, position, health, direction) for index, (position, health, direction) in enumerate(zip(positions, healths, directions))], key=lambda robot: robot.position)\n    stack: List[Robot] = []\n\n    for robot in robots:\n      if robot.direction == 'R':\n        stack.append(robot)\n        continue\n      while stack and stack[-1].direction == 'R' and robot.health > 0:\n        if stack[-1].health == robot.health:\n          stack.pop()\n          robot.health = 0\n        elif stack[-1].health < robot.health:\n          stack.pop()\n          robot.health -= 1\n        else:\n          stack[-1].health -= 1\n          robot.health = 0\n      if robot.health > 0:\n        stack.append(robot)\n\n    stack.sort(key=lambda robot: robot.index)\n    return [robot.health for robot in stack]\n", "tests": [{"start": 26, "end": 28, "test": "```\ndef test_survivedRobotsHealths():\n    solution = Solution()\n    assert solution.survivedRobotsHealths([0, 1], [5, 3], ['R', 'L']) == [4]\n```"}, {"start": 39, "end": 40, "test": "```\ndef test_survivedRobotsHealths():\n    solution = Solution()\n    assert solution.survivedRobotsHealths([0, 1], [5, 3], ['R', 'L']) == [4]\n```"}, {"start": 30, "end": 32, "test": "```\ndef test_survivedRobotsHealths():\n    solution=Solution()\n    assert solution.survivedRobotsHealths([1,2,3], [5,4,3], ['R','L','R']) == [0, 0]\n```"}, {"start": 33, "end": 35, "test": "```\ndef test_survivedRobotsHealths():\n    def survivedRobotsHealths(positions, healths, directions):\n        return [robot.health for robot in solution.survivedRobotsHealths([0, 1], [5, 3], ['R', 'L'])]\n```"}, {"start": 36, "end": 38, "test": "```\ndef test_survivedRobotsHealths():\n    def survivedRobotsHealths(positions, healths, directions):\n        return [1, 2, 0]\n    positions = [0, 1, 2]\n    healths = [3, 2, 1]\n    directions = ['R', 'L', 'R']\n    assert survivedRobotsHealths(positions, healths, directions) == [1, 2, 0]"}]}
{"task_num": 2812, "task_title": "Find the Safest Path in a Grid", "func_name": "maximumSafenessFactor", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumSafenessFactor(self, grid: List[List[int]]) -> int:\n    self.dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    n = len(grid)\n    distToThief = self._getDistToThief(grid)\n\n    def hasValidPath(safeness: int) -> bool:\n      if distToThief[0][0] < safeness:\n        return False\n\n      q = collections.deque([(0, 0)])\n      seen = {(0, 0)}\n\n      while q:\n        i, j = q.popleft()\n        if distToThief[i][j] < safeness:\n          continue\n        if i == n - 1 and j == n - 1:\n          return True\n        for dx, dy in self.dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == n or y < 0 or y == n:\n            continue\n          if (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n\n      return False\n\n    return bisect.bisect_left(range(n * 2), True, key=lambda m: not hasValidPath(m)) - 1\n\n  def _getDistToThief(self, grid: List[List[int]]) -> List[List[int]]:\n    n = len(grid)\n    distToThief = [[0] * n for _ in range(n)]\n    q = collections.deque()\n    seen = set()\n\n    for i in range(n):\n      for j in range(n):\n        if grid[i][j] == 1:\n          q.append((i, j))\n          seen.add((i, j))\n\n    dist = 0\n    while q:\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        distToThief[i][j] = dist\n        for dx, dy in self.dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == n or y < 0 or y == n:\n            continue\n          if (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n      dist += 1\n\n    return distToThief\n", "tests": [{"start": 18, "end": 19, "test": "```\ndef test_maximumSafenessFactor():\n    solution = Solution()\n    assert solution.maximumSafenessFactor([[1, 0], [0, 0]]) == 2\n```"}, {"start": 26, "end": 27, "test": "```\ndef test_maximumSafenessFactor():\n    solution = Solution()\n    assert solution.maximumSafenessFactor([[0, 1], [0, 0]]) == 2\n```"}, {"start": 28, "end": 29, "test": "```\ndef test_maximumSafenessFactor():\n    def solution(grid):\n        pass\n    solution = Solution()\n    grid = [[0, 0], [1, 1]]\n    assert solution.maximumSafenessFactor(grid) == 2\n```"}, {"start": 52, "end": 54, "test": "```\ndef test_maximumSafenessFactor():\n    solution = Solution()\n    assert solution.maximumSafenessFactor([[0, 1], [0, 0]]) == 2\n```"}, {"start": 33, "end": 34, "test": "```\ndef test_maximumSafenessFactor():\n    def maximumSafenessFactor(grid):\n        pass\n    solution = Solution()\n    grid = [[0, 1], [0, 0]]\n    assert maximumSafenessFactor(grid) == 2\n```"}, {"start": 35, "end": 36, "test": "```\ndef test_maximumSafenessFactor():\n    solution = Solution()\n    assert solution.maximumSafenessFactor([[0, 1], [0, 0]]) == 2\n```"}, {"start": 64, "end": 65, "test": "```\ndef test_maximumSafenessFactor():\n    def maximum_safeness_factor(grid):\n        return Solution().maximumSafenessFactor(grid)\n    \n    grid = [[0, 1], [0, 0]]\n    assert maximum_safeness_factor(grid) == 2\n```"}, {"start": 66, "end": 67, "test": "```\ndef test_maximumSafenessFactor():\n    def grid():\n        return [[0, 1], [0, 0]]\n    solution = Solution()\n    assert solution.maximumSafenessFactor(grid()) == 2\n```"}]}
{"task_num": 2818, "task_title": "Apply Operations to Maximize Score", "func_name": "maximumScore", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumScore(self, nums: List[int], k: int) -> int:\n    kMod = 1_000_000_007\n    n = len(nums)\n    ans = 1\n    minPrimeFactors = self._sieveEratosthenes(max(nums) + 1)\n    primeScores = [self._getPrimeScore(num, minPrimeFactors) for num in nums]\n    left = [-1] * n\n    right = [n] * n\n    stack = []\n\n    for i in reversed(range(n)):\n      while stack and primeScores[stack[-1]] <= primeScores[i]:\n        left[stack.pop()] = i\n      stack.append(i)\n\n    stack = []\n\n    for i in range(n):\n      while stack and primeScores[stack[-1]] < primeScores[i]:\n        right[stack.pop()] = i\n      stack.append(i)\n\n    numAndIndexes = [(num, i) for i, num in enumerate(nums)]\n\n    def modPow(x: int, n: int) -> int:\n      if n == 0:\n        return 1\n      if n & 1:\n        return x * modPow(x, n - 1) % kMod\n      return modPow(x * x % kMod, n // 2)\n\n    for num, i in sorted(numAndIndexes, key=lambda x: (-x[0], x[1])):\n      rangeCount = (i - left[i]) * (right[i] - i)\n      actualCount = min(rangeCount, k)\n      k -= actualCount\n      ans *= modPow(num, actualCount)\n      ans %= kMod\n\n    return ans\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeScore(self, num: int, minPrimeFactors: List[int]) -> int:\n    primeFactors = set()\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      primeFactors.add(divisor)\n      while num % divisor == 0:\n        num //= divisor\n    return len(primeFactors)\n", "tests": [{"start": 37, "end": 38, "test": "```\ndef test_maximumScore():\n    def test_case():\n        nums = [2, 3, 4]\n        k = 1\n        assert solution.maximumScore(nums, k) == 6, f\"Expected maximumScore({nums}, {k}) to return 6, but got {solution.maximumScore(nums, k)}\"\n    test_case()\n```"}, {"start": 39, "end": 40, "test": "```\ndef test_maximumScore():\n    def maximumScore(self):\n        nums = [2, 3, 4]\n        k = 2\n        return self.maximumScore(nums, k)\n```"}, {"start": 55, "end": 57, "test": "```\ndef test_maximumScore():\n    def maximumScore(nums: List[int], k: int) -> int:\n        assert maximumScore([2, 3, 4, 5, 6], 1) == 12\n```"}]}
{"task_num": 2836, "task_title": "Maximize Value of Function in a Ball Passing Game", "func_name": "getMaxFunctionValue", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:\n    n = len(receiver)\n    m = int(math.log2(k)) + 1\n    ans = 0\n    jump = [[0] * m for _ in range(n)]\n    summ = [[0] * m for _ in range(n)]\n\n    for i in range(n):\n      jump[i][0] = receiver[i]\n      summ[i][0] = receiver[i]\n\n    for j in range(1, m):\n      for i in range(n):\n        midNode = jump[i][j - 1]\n        jump[i][j] = jump[midNode][j - 1]\n        summ[i][j] = summ[i][j - 1] + summ[midNode][j - 1]\n\n    for i in range(n):\n      currSum = i\n      currPos = i\n      for j in range(m):\n        if (k >> j) & 1 == 1:\n          currSum += summ[currPos][j]\n          currPos = jump[currPos][j]\n      ans = max(ans, currSum)\n\n    return ans\n", "tests": [{"start": 33, "end": 35, "test": "```\ndef test_getMaxFunctionValue():\n    solution=Solution()\n    assert solution.getMaxFunctionValue([1, 2, 3], 4) == 9\n```"}]}
{"task_num": 2844, "task_title": "Minimum Operations to Make a Special Number", "func_name": "minimumOperations", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumOperations(self, num: str) -> int:\n    n = len(num)\n    seenFive = False\n    seenZero = False\n\n    for i in range(n - 1, -1, -1):\n      if seenZero and num[i] == '0':\n        return n - i - 2\n      if seenZero and num[i] == '5':\n        return n - i - 2\n      if seenFive and num[i] == '2':\n        return n - i - 2\n      if seenFive and num[i] == '7':\n        return n - i - 2\n      seenZero = seenZero or num[i] == '0'\n      seenFive = seenFive or num[i] == '5'\n\n    if seenZero:\n      return n - 1\n    else:\n      return n\n", "tests": [{"start": 29, "end": 30, "test": "```\ndef test_minimumOperations():\n    def assert_equal(actual, expected):\n        assert actual == expected\n\n    solution = Solution()\n    num = \"250\"\n    assert_equal(solution.minimumOperations(num), 2)\n```"}, {"start": 31, "end": 32, "test": "```\ndef test_minimumOperations():\n    def assert_equal(actual, expected):\n        if actual != expected:\n            raise AssertionError(f\"Expected {expected}, got {actual}\")\n    \n    solution = Solution()\n    num = \"25\"\n    assert_equal(solution.minimumOperations(num), 0)\n```"}, {"start": 18, "end": 19, "test": "```\ndef test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations(\"250\") == 1, \"Test case failed\"\n```"}, {"start": 20, "end": 21, "test": "```\ndef test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations(\"205\") == 3\n```"}, {"start": 22, "end": 23, "test": "```\ndef test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations(\"2520\") == 3\n```"}, {"start": 24, "end": 25, "test": "```\ndef test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations(\"257\") == 3\n```"}]}
{"task_num": 2846, "task_title": "Minimum Edge Weight Equilibrium Queries in a Tree", "func_name": "minOperationsQueries", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minOperationsQueries(self, n: int, edges: List[List[int]], queries: List[List[int]]) -> List[int]:\n    kMax = 26\n    m = int(math.log2(n)) + 1\n    ans = []\n    graph = [[] for _ in range(n)]\n    jump = [[0] * m for _ in range(n)]\n    count = [[] for _ in range(n)]\n    depth = [0] * n\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    def dfs(u: int, prev: int, d: int):\n      if prev != -1:\n        jump[u][0] = prev\n      depth[u] = d\n      for v, w in graph[u]:\n        if v == prev:\n          continue\n        count[v] = count[u][:]\n        count[v][w] += 1\n        dfs(v, u, d + 1)\n\n    count[0] = [0] * (kMax + 1)\n    dfs(0, -1, 0)\n\n    for j in range(1, m):\n      for i in range(n):\n        jump[i][j] = jump[jump[i][j - 1]][j - 1]\n\n    def getLCA(u: int, v: int) -> int:\n      if depth[u] > depth[v]:\n        return getLCA(v, u)\n      for j in range(m):\n        if depth[v] - depth[u] >> j & 1:\n          v = jump[v][j]\n      if u == v:\n        return u\n      for j in range(m - 1, -1, -1):\n        if jump[u][j] != jump[v][j]:\n          u = jump[u][j]\n          v = jump[v][j]\n      return jump[v][0]\n\n    for u, v in queries:\n      lca = getLCA(u, v)\n      numEdges = depth[u] + depth[v] - 2 * depth[lca]\n      maxFreq = max(count[u][j] + count[v][j] - 2 * count[lca][j] for j in range(1, kMax + 1))\n      ans.append(numEdges - maxFreq)\n\n    return ans\n", "tests": [{"start": 26, "end": 27, "test": "```\ndef test_minOperationsQueries():\n    solution=Solution()\n    assert solution.minOperationsQueries(5, [[0, 1, 3], [1, 2, 2], [2, 3, 1]], [[0, 1], [1, 4]]) == [3, 2]\n```"}, {"start": 44, "end": 45, "test": "```\ndef test_minOperationsQueries():\n    solution = Solution()\n    assert solution.minOperationsQueries(5, [[0, 1, 3], [1, 2, 2], [2, 3, 1]], [[0, 4]]) == [3]\n```"}, {"start": 49, "end": 50, "test": "```\ndef test_minOperationsQueries():\n    solution = Solution()\n    assert solution.minOperationsQueries(3, [[0, 1, 2], [1, 2, 1]], [[0, 1], [1, 2]]) == [1, 0]\n```"}, {"start": 30, "end": 31, "test": "```\ndef test_minOperationsQueries():\n    solution = Solution()\n    assert solution.minOperationsQueries(5, [[0, 1, 3], [1, 2, 2], [2, 3, 1]], [[0, 1], [1, 4]]) == [3, 2]\n```"}, {"start": 47, "end": 48, "test": "```\ndef test_minOperationsQueries():\n    solution=Solution()\n    assert solution.minOperationsQueries(7, [[0,1,5],[0,2,3],[1,2,6]], [[0,1],[2,4]]) == [5, 14], \n```"}, {"start": 52, "end": 54, "test": "```\ndef test_minOperationsQueries():\n    solution=Solution()\n    assert solution.minOperationsQueries(7, [[0,1,5],[0,2,3],[1,2,6]], [[0,1],[2,4]]) == [5, 7], \n```"}]}
{"task_num": 2850, "task_title": "Minimum Moves to Spread Stones Over Grid", "func_name": "minimumMoves", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumMoves(self, grid: List[List[int]]) -> int:\n    if sum(row.count(0) for row in grid) == 0:\n      return 0\n\n    ans = math.inf\n\n    for i in range(3):\n      for j in range(3):\n        if grid[i][j] == 0:\n          for x in range(3):\n            for y in range(3):\n              if grid[x][y] > 1:\n                grid[x][y] -= 1\n                grid[i][j] += 1\n                ans = min(ans, abs(x - i) + abs(y - j) + self.minimumMoves(grid))\n                grid[x][y] += 1\n                grid[i][j] -= 1\n\n    return ans\n", "tests": [{"start": 13, "end": 14, "test": "def test_minimumMoves():    \n    solution = Solution()    \n    assert solution.minimumMoves([[1, 1, 1], [1, 0, 1], [1, 1, 1]]) == 2"}, {"start": 20, "end": 28, "test": "```\ndef test_minimumMoves():\n    solution = Solution()\n    assert solution.minimumMoves([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) == 5\n```"}, {"start": 23, "end": 28, "test": "```\ndef test_minimumMoves():\n    solution = Solution()\n    assert solution.minimumMoves([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) == 4\n```"}]}
{"task_num": 2851, "task_title": "String Transformation", "func_name": "numberOfWays", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numberOfWays(self, s: str, t: str, k: int) -> int:\n    kMod = 1_000_000_007\n    n = len(s)\n    negOnePowK = 1 if k % 2 == 0 else -1  # (-1)^k\n    z = self._zFunction(s + t + t)\n\n    indices = [i - n for i in range(n, n + n) if z[i] >= n]\n    dp = [0] * 2\n    dp[1] = (pow(n - 1, k, kMod) - negOnePowK) * pow(n, kMod - 2, kMod)\n    dp[0] = dp[1] + negOnePowK\n    res = 0\n    for index in indices:\n      if index == 0:\n        res += dp[0]\n      else: \n        res += dp[1]\n    return res % kMod\n\n\n  def _zFunction(self, s: str) -> List[int]:\n    n = len(s)\n    z = [0] * n\n    l = 0\n    r = 0\n    for i in range(1, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l])\n      while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n    return z\n", "tests": [{"start": 24, "end": 25, "test": "```\ndef test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays(\"abc\", \"cab\", 2) == 3\n```"}, {"start": 26, "end": 27, "test": "```\ndef test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays(\"abc\", \"cab\", 2) % 1000000007 == 3\n```"}, {"start": 37, "end": 38, "test": "```\ndef test_numberOfWays():\n    solution=Solution()\n    assert solution.numberOfWays(\"abc\", \"cab\", 2) == 3\n```"}, {"start": 41, "end": 43, "test": "```\ndef test_numberOfWays():\n    solution=Solution()\n    assert solution.numberOfWays(\"abc\", \"cab\", 2) == 3\n```"}]}
{"task_num": 2876, "task_title": "Count Visited Nodes in a Directed Graph", "func_name": "countVisitedNodes", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countVisitedNodes(self, edges: List[int]) -> List[int]:\n    n = len(edges)\n    ans = [0] * n\n    inDegrees = [0] * n\n    seen = [False] * n\n    stack = []\n\n    for v in edges:\n      inDegrees[v] += 1\n\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n\n    while q:\n      u = q.popleft()\n      inDegrees[edges[u]] -= 1\n      if inDegrees[edges[u]] == 0:\n        q.append(edges[u])\n      stack.append(u)\n      seen[u] = True\n\n    for i in range(n):\n      if not seen[i]:\n        self._fillCycle(edges, i, seen, ans)\n\n    while stack:\n      u = stack.pop()\n      ans[u] = ans[edges[u]] + 1\n\n    return ans\n\n  def _fillCycle(self, edges: List[int], start: int, seen: List[bool], ans: List[int]) -> None:\n    cycleLength = 0\n    u = start\n    while not seen[u]:\n      cycleLength += 1\n      seen[u] = True\n      u = edges[u]\n    ans[start] = cycleLength\n    u = edges[start]\n    while u != start:\n      ans[u] = cycleLength\n      u = edges[u]\n", "tests": [{"start": 27, "end": 28, "test": "```\ndef test_countVisitedNodes():\n    solution = Solution()\n    edges = [0,1,2,3,4]\n    expected = [1,2,2,1,1]\n    assert solution.countVisitedNodes(edges) == expected\n```"}, {"start": 33, "end": 34, "test": "```\ndef test_countVisitedNodes():\n    def test_case():\n        edges = [0, 1, 2, 3, 4]\n        result = solution.countVisitedNodes(edges)\n        assert result == [1, 2, 2, 3, 4]\n\n    test_case()\n```"}]}
{"task_num": 2901, "task_title": "Longest Unequal Adjacent Groups Subsequence II", "func_name": "getWordsInLongestSubsequence", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def getWordsInLongestSubsequence(self, words: List[str], groups: List[int]) -> List[str]:\n    ans = []\n    n=len(words)\n    dp = [1] * n\n    prev = [-1] * n\n\n    for i in range(1, n):\n      for j in range(i):\n        if groups[i] == groups[j]:\n          continue\n        if len(words[i]) != len(words[j]):\n          continue\n        if sum(a != b for a, b in zip(words[i], words[j])) != 1:\n          continue\n        if dp[i] < dp[j] + 1:\n          dp[i] = dp[j] + 1\n          prev[i] = j\n\n    index = dp.index(max(dp))\n    while index != -1:\n      ans.append(words[index])\n      index = prev[index]\n\n    return ans[::-1]\n", "tests": [{"start": 20, "end": 21, "test": "def test_getWordsInLongestSubsequence():    \n    solution=Solution()    \n    words=[\"abc\",\"bcd\",\"cde\"]    \n    groups=[0,1,2]    \n    assert solution.getWordsInLongestSubsequence(words,groups) == [\"abc\",\"bcd\",\"cde\"],"}, {"start": 22, "end": 23, "test": "def test_getWordsInLongestSubsequence():    \n    solution=Solution()    \n    words=[\"abc\",\"abcd\",\"bcd\"]    \n    groups=[0,1,2]    \n    assert solution.getWordsInLongestSubsequence(words,groups) == [\"bcd\"]"}, {"start": 24, "end": 25, "test": "```\ndef test_getWordsInLongestSubsequence():\n    solution=Solution()\n    def getWordsInLongestSubsequence(words: List[str], groups: List[int]) -> List[str]:\n        return solution.getWordsInLongestSubsequence([\"abc\", \"abcd\", \"bcd\"], [0, 1, 1])\n```"}, {"start": 26, "end": 28, "test": "```\ndef test_getWordsInLongestSubsequence():\n    solution=Solution()\n    def getWordsInLongestSubsequence(words: List[str], groups: List[int]) -> List[str]:\n        return solution.getWordsInLongestSubsequence([\"abc\", \"abcd\", \"bcd\"], [0, 1, 1])\n```"}]}
{"task_num": 2904, "task_title": "Shortest and Lexicographically Smallest Beautiful String", "func_name": "shortestBeautifulSubstring", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def shortestBeautifulSubstring(self, s: str, k: int) -> str:\n    bestLeft = -1\n    minLength = len(s) + 1\n    ones = 0\n\n    l = 0\n    for r, c in enumerate(s):\n      if c == '1':\n        ones += 1\n      while ones == k:\n        if r - l + 1 < minLength:\n          bestLeft = l\n          minLength = r - l + 1\n        elif r - l + 1 == minLength and s[l:l + minLength] < s[bestLeft:bestLeft + minLength]:\n          bestLeft = l\n        if s[l] == '1':\n          ones -= 1\n        l += 1\n\n    if bestLeft == -1:\n      return \"\"\n    else:\n      return s[bestLeft:bestLeft + minLength]\n", "tests": [{"start": 31, "end": 32, "test": "```\ndef test_shortestBeautifulSubstring():\n    solution=Solution()\n    assert solution.shortestBeautifulSubstring(\"0\", 1) == \"\", \n```"}, {"start": 33, "end": 34, "test": "```\ndef test_shortestBeautifulSubstring():\n    solution=Solution()\n    assert solution.shortestBeautifulSubstring(\"11001100\", 2) == \"10\"\n```"}, {"start": 19, "end": 20, "test": "```\ndef test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring(\"110111\", 2) == \"11\"\n```"}, {"start": 22, "end": 24, "test": "```\ndef test_shortestBeautifulSubstring():\n    solution=Solution()\n    assert solution.shortestBeautifulSubstring(\"110111\", 2) == \"11\"\n```"}, {"start": 27, "end": 28, "test": "```\ndef test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring(\"110011001100\", 2) == \"10101\"\n```"}, {"start": 25, "end": 26, "test": "```\ndef test_shortestBeautifulSubstring():\n    solution=Solution()\n    assert solution.shortestBeautifulSubstring(\"1101110111\", 2) == \"11\"\n```"}]}
{"task_num": 2911, "task_title": "Minimum Changes to Make K Semi-palindromes", "func_name": "minimumChanges", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumChanges(self, s: str, k: int) -> int:\n    n = len(s)\n    factors = self._getFactors(n)\n    cost = self._getCost(s, n, factors)\n    dp = [[n] * (k + 1) for _ in range(n + 1)]\n\n    dp[n][0] = 0\n\n    for i in range(n - 1, -1, -1):\n      for j in range(1, k + 1):\n        for l in range(i + 1, n):\n          dp[i][j] = min(dp[i][j], dp[l + 1][j - 1] + cost[i][l])\n\n    return dp[0][k]\n\n  def _getFactors(self, n: int) -> List[List[int]]:\n    factors = [[1] for _ in range(n + 1)]\n    for d in range(2, n):\n      for i in range(d * 2, n + 1, d):\n        factors[i].append(d)\n    return factors\n\n  def _getCost(self, s: str, n: int, factors: List[List[int]]) -> List[List[int]]:\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n      for j in range(i + 1, n):\n        length = j - i + 1\n        minCost = length\n        for d in factors[length]:\n          minCost = min(minCost, self._getCostD(s, i, j, d))\n        cost[i][j] = minCost\n    return cost\n\n  def _getCostD(self, s: str, i: int, j: int, d: int) -> int:\n    cost = 0\n    for offset in range(d):\n      l = i + offset\n      r = j - d + 1 + offset\n      while l < r:\n        if s[l] != s[r]:\n          cost += 1\n        l += d\n        r -= d\n    return cost\n", "tests": [{"start": 51, "end": 52, "test": "```\ndef test_minimumChanges():\n    solution = Solution()\n    assert solution.minimumChanges(\"abcabc\", 3) == 2\n```"}]}
{"task_num": 2932, "task_title": "Maximum Strong Pair XOR I", "func_name": "maximumStrongPairXor", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Optional\n\nclass TrieNode:\n  def __init__(self):\n    self.children: List[Optional[TrieNode]] = [None] * 2\n    self.min = math.inf\n    self.max = -math.inf\n\n\nclass BitTrie:\n  def __init__(self, maxBit: int):\n    self.maxBit = maxBit\n    self.root = TrieNode()\n\n  def insert(self, num: int) -> None:\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n      node.min = min(node.min, num)\n      node.max = max(node.max, num)\n\n  def getMaxXor(self, x: int) -> int:\n    maxXor = 0\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = x >> i & 1\n      toggleBit = bit ^ 1\n      if node.children[toggleBit] and node.children[toggleBit].max > x and node.children[toggleBit].min <= 2 * x:\n        maxXor = maxXor | 1 << i\n        node = node.children[toggleBit]\n      elif node.children[bit]:\n        node = node.children[bit]\n      else:\n        return 0\n    return maxXor\n\n\nclass Solution:\n  def maximumStrongPairXor(self, nums: List[int]) -> int:\n    maxNum = max(nums)\n    maxBit = int(math.log2(maxNum))\n    bitTrie = BitTrie(maxBit)\n\n    for num in nums:\n      bitTrie.insert(num)\n\n    return max(bitTrie.getMaxXor(num) for num in nums)\n", "tests": [{"start": 27, "end": 28, "test": "```\ndef test_maximumStrongPairXor():\n    solution=Solution()\n    assert solution.maximumStrongPairXor([8, 6]) == 7\n```"}, {"start": 39, "end": 41, "test": "```\ndef test_maximumStrongPairXor():\n    solution=Solution()\n    assert solution.maximumStrongPairXor([8, 6]) == 7\n```"}, {"start": 42, "end": 43, "test": "```\ndef test_maximumStrongPairXor():\n    solution=Solution()\n    assert solution.maximumStrongPairXor([8, 3]) == 7\n```"}, {"start": 44, "end": 45, "test": "```\ndef test_maximumStrongPairXor():\n    solution = Solution()\n    assert solution.maximumStrongPairXOR([8, 28]) == 14\n```"}]}
{"task_num": 2940, "task_title": "Find Building Where Alice and Bob Can Meet", "func_name": "leftmostBuildingQueries", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, a: int, b: int):\n    self.queryIndex = queryIndex\n    self.a = a\n    self.b = b\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.a\n    yield self.b\n\n\nclass Solution:\n  def leftmostBuildingQueries(self, heights: List[int], queries: List[List[int]]) -> List[int]:\n    ans = [-1] * len(queries)\n    stack = []\n\n    heightsIndex = len(heights) - 1\n    for queryIndex, a, b in sorted([IndexedQuery(i, min(a, b), max(a, b)) for i, (a, b) in enumerate(queries)], key=lambda iq: -iq.b):\n      if a == b or heights[a] < heights[b]:\n        ans[queryIndex] = b\n      else:\n        while heightsIndex > b:\n          while stack and heights[stack[-1]] <= heights[heightsIndex]:\n            stack.pop()\n          stack.append(heightsIndex)\n          heightsIndex -= 1\n        j = self._lastGreater(stack, a, heights)\n        if j != -1:\n          ans[queryIndex] = stack[j]\n\n    return ans\n\n  def _lastGreater(self, A: List[int], target: int, heights: List[int]):\n    l = -1\n    r = len(A) - 1\n    while l < r:\n      m = (l + r + 1) // 2\n      if heights[A[m]] > heights[target]:\n        l = m\n      else:\n        r = m - 1\n    return l\n", "tests": [{"start": 30, "end": 31, "test": "```\ndef test_leftmostBuildingQueries():\n    solution=Solution()\n    result = solution.leftmostBuildingQueries([1, 2, 3], [[0, 1], [1, 2]])\n```"}, {"start": 32, "end": 40, "test": "```\ndef test_leftmostBuildingQueries():\n    solution=Solution()\n    assert solution.leftmostBuildingQueries([3, 2, 1], [[0, 1], [2, 2]]) == [-1, 0]\n```"}, {"start": 49, "end": 50, "test": "```\ndef test_leftmostBuildingQueries():\n    def leftmost_building_queries(heights, queries):\n        return Solution().leftmostBuildingQueries(heights, queries)\n    \n    assert leftmost_building_queries([1, 2, 3], [[0, 1], [1, 2]]) == [-1, 1]\n```"}, {"start": 51, "end": 52, "test": "```\ndef test_leftmostBuildingQueries():\n    def leftmost_building_queries(heights, queries):\n        return Solution().leftmostBuildingQueries(heights, queries)\n    \n    assert leftmost_building_queries([1, 2, 3], [[0, 1], [1, 2]]) == [-1, 1]\n```"}, {"start": 39, "end": 40, "test": "```\ndef test_leftmostBuildingQueries():\n    def leftmostBuildingQueries(heights, queries):\n        solution = Solution()\n        return solution.leftmostBuildingQueries(heights, queries)\n    \n    assert leftmostBuildingQueries([1, 2, 3], [[0, 1], [1, 2]]) == [-1, 1]\n```"}]}
{"task_num": 2948, "task_title": "Make Lexicographically Smallest Array by Swapping Elements", "func_name": "lexicographicallySmallestArray", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def lexicographicallySmallestArray(self, nums: List[int], limit: int) -> List[int]:\n    ans = [0] * len(nums)\n    numAndIndexes = sorted([(num, i) for i, num in enumerate(nums)])\n    numAndIndexesGroups: List[List[Tuple[int, int]]] = []\n\n    for numAndIndex in numAndIndexes:\n      if not numAndIndexesGroups or numAndIndex[0] - numAndIndexesGroups[-1][-1][0] > limit:\n        numAndIndexesGroups.append([numAndIndex])\n      else:\n        numAndIndexesGroups[-1].append(numAndIndex)\n\n    for numAndIndexesGroup in numAndIndexesGroups:\n      sortedNums = [num for num, _ in numAndIndexesGroup]\n      sortedIndices = sorted([index for _, index in numAndIndexesGroup])\n      for num, index in zip(sortedNums, sortedIndices):\n        ans[index] = num\n\n    return ans\n", "tests": [{"start": 18, "end": 19, "test": "```\ndef test_lexicographicallySmallestArray():\n    solution=Solution()\n    assert solution.lexicographicallySmallestArray([1, 2, 3], 0) == [0, 1, 2]\n```"}, {"start": 20, "end": 21, "test": "```\ndef test_lexicographicallySmallestArray():\n    solution = Solution()\n    assert solution.lexicographicallySmallestArray([2, 10, 3], 1) == [2, 2, 10]\n```"}]}
{"task_num": 2953, "task_title": "Count Complete Substrings", "func_name": "countCompleteSubstrings", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countCompleteSubstrings(self, word: str, k: int) -> int:\n    uniqueLetters = len(set(word))\n    return sum(self._countCompleteStrings(word, k, windowSize) for windowSize in range(k, k * uniqueLetters + 1, k))\n\n  def _countCompleteStrings(self, word: str, k: int, windowSize: int) -> int:\n    res = 0\n    countLetters = 0\n    count = collections.Counter()\n\n    for i, c in enumerate(word):\n      count[c] += 1\n      countLetters += 1\n      if i > 0 and abs(ord(c) - ord(word[i - 1])) > 2:\n        count = collections.Counter()\n        count[c] += 1\n        countLetters = 1\n      if countLetters == windowSize + 1:\n        count[word[i - windowSize]] -= 1\n        countLetters -= 1\n      if countLetters == windowSize:\n        res += all(freq == 0 or freq == k for freq in count.values())\n\n    return res\n", "tests": [{"start": 24, "end": 27, "test": "def test_countCompleteSubstrings(): \n    solution=Solution() \n    assert solution.countCompleteSubstrings(\"abcabc\", 2) == 3"}, {"start": 28, "end": 30, "test": "```\ndef test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings(\"abcabc\", 2) == 3\n```"}, {"start": 31, "end": 32, "test": "```\ndef test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings(\"abccba\", 1) == 3\n```"}]}
{"task_num": 2959, "task_title": "Number of Possible Sets of Closing Branches", "func_name": "numberOfSets", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:\n    return sum(self._floydWarshall(n, maxDistance, roads, mask) <= maxDistance for mask in range(1 << n))\n\n  def _floydWarshall(self, n: int, maxDistanceThreshold: int, roads: List[List[int]], mask: int) -> List[List[int]]:\n    maxDistance = 0\n    dist = [[maxDistanceThreshold + 1] * n for _ in range(n)]\n\n    for i in range(n):\n      if mask >> i & 1:\n        dist[i][i] = 0\n\n    for u, v, w in roads:\n      if mask >> u & 1 and mask >> v & 1:\n        dist[u][v] = min(dist[u][v], w)\n        dist[v][u] = min(dist[v][u], w)\n\n    for k in range(n):\n      if mask >> k & 1:\n        for i in range(n):\n          if mask >> i & 1:\n            for j in range(n):\n              if mask >> j & 1:\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    for i in range(n):\n      if mask >> i & 1:\n        for j in range(i + 1, n):\n          if mask >> j & 1:\n            maxDistance = max(maxDistance, dist[i][j])\n\n    return maxDistance\n", "tests": [{"start": 20, "end": 21, "test": "```\ndef test_numberOfSets():\n    solution=Solution()\n    assert solution.numberOfSets(3, 2, [[0,1,4],[1,2,5]]) == 8\n```"}, {"start": 24, "end": 26, "test": "```\ndef test_numberOfSets():\n    def numberOfSets(self):\n        n = 3\n        maxDistance = 2\n        roads = [[0,1,1],[1,2,1]]\n        return self.numberOfSets(n, maxDistance, roads)\n```"}, {"start": 29, "end": 34, "test": "def test_numberOfSets():\n    solution=Solution()\n    assert solution.numberOfSets(3, 2, [[0,1,4],[1,2,5]]) == 8"}, {"start": 37, "end": 40, "test": "```\ndef test_numberOfSets():\n    def assert_equal(actual, expected):\n        assert actual == expected\n    solution = Solution()\n    assert_equal(solution.numberOfSets(3, 2, [[0,1,4],[1,2,5]]), 8)"}, {"start": 31, "end": 34, "test": "```\ndef test_numberOfSets():\n    def assert_equal(actual, expected):\n        if actual != expected:\n            raise AssertionError(f\"Expected {expected}, but got {actual}\")\n    \n    solution = Solution()\n    n = 3\n    maxDistance = 2\n    roads = [[0,1,1],[1,2,1]]\n    assert_equal(solution.numberOfSets(n, maxDistance, roads), 4)"}, {"start": 39, "end": 40, "test": "```\ndef test_numberOfSets():\n    def assert_equal(actual, expected):\n        assert actual == expected\n    solution = Solution()\n    assert_equal(solution.numberOfSets(3, 2, [[0,1,4],[1,2,5]]), 8)"}, {"start": 33, "end": 34, "test": "```\ndef test_numberOfSets():\n    def numberOfSets(self):\n        n = 3\n        maxDistance = 2\n        roads = [[0,1,1],[1,2,1]]\n        return self.numberOfSets(n, maxDistance, roads)\n```"}]}
{"task_num": 2973, "task_title": "Find Number of Coins to Place in Tree Nodes", "func_name": "placedCoins", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass ChildCost:\n  def __init__(self, cost: int):\n    self.numNodes = 1\n    self.maxPosCosts = [cost] if cost > 0 else []\n    self.minNegCosts = [cost] if cost < 0 else []\n\n  def update(self, childCost: 'ChildCost') -> None:\n    self.numNodes += childCost.numNodes\n    self.maxPosCosts.extend(childCost.maxPosCosts)\n    self.minNegCosts.extend(childCost.minNegCosts)\n    self.maxPosCosts.sort(reverse=True)\n    self.minNegCosts.sort()\n    self.maxPosCosts = self.maxPosCosts[:3]\n    self.minNegCosts = self.minNegCosts[:2]\n\n  def maxProduct(self) -> int:\n    if self.numNodes < 3:\n      return 1\n    if not self.maxPosCosts:\n      return 0\n    res = 0\n    if len(self.maxPosCosts) == 3:\n      res = self.maxPosCosts[0] * self.maxPosCosts[1] * self.maxPosCosts[2]\n    if len(self.minNegCosts) == 2:\n      res = max(res, self.minNegCosts[0] * self.minNegCosts[1] * self.maxPosCosts[0])\n    return res\n\n\nclass Solution:\n  def placedCoins(self, edges: List[List[int]], cost: List[int]) -> List[int]:\n    n = len(cost)\n    ans = [0] * n\n    tree = [[] for _ in range(n)]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, prev: int) -> None:\n      res = ChildCost(cost[u])\n      for v in tree[u]:\n        if v != prev:\n          res.update(dfs(v, u))\n      ans[u] = res.maxProduct()\n      return res\n\n    dfs(0, -1)\n    return ans\n", "tests": [{"start": 27, "end": 28, "test": "```\ndef test_placedCoins():\n    solution = Solution()\n    assert solution.placedCoins([[0, 1], [1, 2]], [1, -1]) == [1, 1]\n```"}, {"start": 29, "end": 30, "test": "```\ndef test_placedCoins():\n    solution = Solution()\n    edges = [[0,1],[1,2],[2,3]]\n    cost = [1,-1,0,1]\n    expected = [0, 1, 0, 1]\n    assert solution.placedCoins(edges, cost) == expected\n```"}, {"start": 32, "end": 33, "test": "```\ndef test_placedCoins():\n    solution=Solution()\n    assert solution.placedCoins([[0, 1], [1, 2]], [3, -4]) == [2, 0]\n```"}, {"start": 34, "end": 35, "test": "```\ndef test_placedCoins():\n    def edges(): return [[0, 1], [1, 2]]\n    def cost(): return [-3, -2, 1]\n    solution = Solution()\n    assert solution.placedCoins(edges(), cost()) == [0, 1, 1], f\"Expected {cost()} to return {solution.placedCoins(edges(), cost())} but got {solution.placedCoins(edges(), cost())}\"\n```"}, {"start": 52, "end": 53, "test": "```\ndef test_placedCoins():\n    def edges_and_cost():\n        return [[0, 1], [1, 2], [2, 3], [3, 4]]\n    cost = [5, -10, 7, -8, 9]\n    solution=Solution()\n    result = solution.placedCoins(edges_and_cost(), cost)\n```"}]}
{"task_num": 2976, "task_title": "Minimum Cost to Convert String I", "func_name": "minimumCost", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n    ans = 0\n    dist = [[math.inf] * 26 for _ in range(26)]\n\n    for a, b, c in zip(original, changed, cost):\n      u = ord(a) - ord('a')\n      v = ord(b) - ord('a')\n      dist[u][v] = min(dist[u][v], c)\n\n    for k in range(26):\n      for i in range(26):\n        if dist[i][k] < math.inf:\n          for j in range(26):\n            if dist[k][j] < math.inf:\n              dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    for s, t in zip(source, target):\n      if s == t:\n        continue\n      u = ord(s) - ord('a')\n      v = ord(t) - ord('a')\n      if dist[u][v] == math.inf:\n        return -1\n      ans += dist[u][v]\n\n    return ans\n", "tests": [{"start": 29, "end": 30, "test": "```\ndef test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost(\"abc\", \"adc\", [\"a\", \"b\", \"c\"], [\"a\", \"d\", \"c\"], [1, 2, 3]) == 4\n```"}, {"start": 33, "end": 34, "test": "```\ndef test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost(\"abc\", \"adc\", [\"a\", \"b\", \"c\"], [\"a\", \"d\", \"c\"], [1, 2, 3]) == 4\n```"}, {"start": 23, "end": 26, "test": "```\ndef test_minimumCost():\n    solution=Solution()\n    assert solution.minimumCost(\"abc\", \"adc\", [\"a\", \"b\", \"c\"], [\"a\", \"d\", \"c\"], [1, 2, 3]) == 4\n```"}, {"start": 25, "end": 26, "test": "```\ndef test_minimumCost():\n    solution=Solution()\n    assert solution.minimumCost(\"abc\", \"adc\", [\"a\",\"b\",\"c\"],[\"a\",\"d\",\"c\"],[1,2,3])==5\n```"}]}
{"task_num": 2977, "task_title": "Minimum Cost to Convert String II", "func_name": "minimumCost", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n    subLengths = set(len(s) for s in original)\n    subToId = self._getSubToId(original, changed)\n    subCount = len(subToId)\n    dist = [[math.inf for _ in range(subCount)] for _ in range(subCount)]\n    dp = [math.inf for _ in range(len(source) + 1)]\n\n    for a, b, c in zip(original, changed, cost):\n      u = subToId[a]\n      v = subToId[b]\n      dist[u][v] = min(dist[u][v], c)\n\n    for k in range(subCount):\n      for i in range(subCount):\n        if dist[i][k] < math.inf:\n          for j in range(subCount):\n            if dist[k][j] < math.inf:\n              dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    dp[0] = 0\n\n    for i, (s, t) in enumerate(zip(source, target)):\n      if dp[i] == math.inf:\n        continue\n      if s == t:\n        dp[i + 1] = min(dp[i + 1], dp[i])\n      for subLength in subLengths:\n        if i + subLength > len(source):\n          continue\n        subSource = source[i:i + subLength]\n        subTarget = target[i:i + subLength]\n        if subSource not in subToId or subTarget not in subToId:\n          continue\n        u = subToId[subSource]\n        v = subToId[subTarget]\n        if dist[u][v] != math.inf:\n          dp[i + subLength] = min(dp[i + subLength], dp[i] + dist[u][v])\n\n    if dp[len(source)] == math.inf:\n      return -1\n    else:\n      return dp[len(source)]\n\n  def _getSubToId(self, original: str, changed: str) -> Dict[str, int]:\n    subToId = {}\n    for s in original + changed:\n      if s not in subToId:\n        subToId[s] = len(subToId)\n    return subToId\n", "tests": [{"start": 50, "end": 51, "test": "```\ndef test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost(\"abc\", \"adc\", [\"ab\", \"c\"], [\"ad\", \"c\"], [2, 0]) == -1\n```"}, {"start": 52, "end": 53, "test": "```\ndef test_minimumCost():\n    def assert_equal(actual, expected):\n        assert actual == expected\n    solution = Solution()\n    source = \"abc\"\n    target = \"adc\"\n    original = [\"a\", \"b\", \"c\"]\n    changed = [\"a\", \"d\", \"c\"]\n    cost = [1, 2, 3]\n    result = solution.minimumCost(source, target, original, changed, cost)\n    assert_equal(result, 4)"}, {"start": 34, "end": 35, "test": "```\ndef test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost(\"abc\", \"adc\", [\"ab\", \"c\"], [\"ad\", \"c\"], [1, 0]) == 1\n```"}, {"start": 36, "end": 37, "test": "```\ndef test_minimumCost():\n    solution=Solution()\n    assert solution.minimumCost(\"abc\", \"abc\", [\"a\", \"b\", \"c\"], [\"a\", \"b\", \"c\"], [1, 2, 3]) == 6\n```"}, {"start": 58, "end": 59, "test": "```\ndef test_minimumCost():\n    solution=Solution()\n    assert solution.minimumCost(\"abc\", \"adc\", [\"ab\", \"c\"], [\"ad\", \"c\"], [1, 0]) == 1\n```"}, {"start": 26, "end": 29, "test": "```\ndef test_minimumCost():\n    solution=Solution()\n    assert solution.minimumCost(\"abc\", \"adc\", [\"ab\", \"cd\"], [\"ad\", \"dc\"], [1, 2]) == 3\n```"}, {"start": 39, "end": 40, "test": "```\ndef test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost(\"abc\", \"adc\", [\"ab\", \"c\"], [\"ad\", \"c\"], [1, 0]) == 1\n```"}, {"start": 43, "end": 44, "test": "```\ndef test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost(\"abc\", \"adc\", [\"ab\", \"c\"], [\"ad\", \"c\"], [1, 0]) == 1\n```"}, {"start": 47, "end": 48, "test": "```\ndef test_minimumCost():\n    solution=Solution()\n    assert solution.minimumCost(\"abc\", \"adc\", [\"ab\", \"c\"], [\"ad\", \"c\"], [1, 0]) == 1\n```"}, {"start": 28, "end": 29, "test": "```\ndef test_minimumCost():\n    solution=Solution()\n    assert solution.minimumCost(\"abc\", \"adc\", [\"ab\", \"c\"], [\"ad\", \"c\"], [1, 0]) == 1\n```"}]}
{"task_num": 2983, "task_title": "Palindrome Rearrangement Queries", "func_name": "canMakePalindromeQueries", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n    n = len(s)\n    mirroredDiffs = self._getMirroredDiffs(s)\n    counts = self._getCounts(s)\n    ans = []\n\n    def subtractArrays(a: List[int], b: List[int]):\n      return [x - y for x, y in zip(a, b)]\n\n    for a, b, c, d in queries:\n      b += 1\n      d += 1\n      ra = n - a\n      rb = n - b\n      rc = n - c\n      rd = n - d\n\n      if (min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0) or (n // 2 > max(b, rc) and mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0):\n        ans.append(False)\n      else:\n        leftRangeCount = subtractArrays(counts[b], counts[a])\n        rightRangeCount = subtractArrays(counts[d], counts[c])\n        if a > rd:\n          rightRangeCount = subtractArrays(\n              rightRangeCount, subtractArrays(counts[min(a, rc)], counts[rd]))\n        if rc > b:\n          rightRangeCount = subtractArrays(\n              rightRangeCount, subtractArrays(counts[rc], counts[max(b, rd)]))\n        if c > rb:\n          leftRangeCount = subtractArrays(\n              leftRangeCount, subtractArrays(counts[min(c, ra)], counts[rb]))\n        if ra > d:\n          leftRangeCount = subtractArrays(\n              leftRangeCount, subtractArrays(counts[ra], counts[max(d, rb)]))\n        ans.append(min(leftRangeCount) >= 0\n                   and min(rightRangeCount) >= 0\n                   and leftRangeCount == rightRangeCount)\n\n    return ans\n\n  def _getMirroredDiffs(self, s: str) -> List[int]:\n    diffs = [0]\n    for i, j in zip(range(len(s)), reversed(range(len(s)))):\n      if i >= j:\n        break\n      diffs.append(diffs[-1] + (s[i] != s[j]))\n    return diffs\n\n  def _getCounts(self, s: str) -> List[List[int]]:\n    count = [0] * 26\n    counts = [count.copy()]\n    for c in s:\n      count[ord(c) - ord('a')] += 1\n      counts.append(count.copy())\n    return counts\n", "tests": [{"start": 29, "end": 30, "test": "def test_canMakePalindromeQueries():\n    solution = Solution()\n    assert not solution.canMakePalindromeQueries(\"abcba\", [[1,2,3,4]]), None"}, {"start": 31, "end": 48, "test": "def test_canMakePalindromeQueries(): \n    solution = Solution() \n    s = \"abcba\" \n    queries = [[0, 2, 3, 4], [1, 3, 5, 6]] \n    expected_result = [True, False] \n    assert solution.canMakePalindromeQueries(s, queries) == expected_result"}, {"start": 55, "end": 56, "test": "```\ndef test_canMakePalindromeQueries():\n    def canMakePalindromeQueries(s, queries):\n        return [\n            (s == \"abccba\" and [True]) or\n            (s == \"abcddcba\" and [False])\n        ]\n```"}, {"start": 34, "end": 36, "test": "```\ndef test_canMakePalindromeQueries():\n    def canMakePalindromeQueries(s: str, queries: List[List[int]]) -> bool:\n        return solution.canMakePalindromeQueries(s, [[1, 2, 3, 4]])\n```"}, {"start": 37, "end": 39, "test": "```\ndef test_canMakePalindromeQueries():\n    def canMakePalindromeQueries(s: str, queries: List[List[int]]) -> bool:\n        return solution.canMakePalindromeQueries(s, [[1, 2, 3, 4]])\n```"}, {"start": 40, "end": 42, "test": "```\ndef test_canMakePalindromeQueries():\n    def canMakePalindromeQueries(s: str, queries: List[List[int]]) -> bool:\n        return solution.canMakePalindromeQueries(s, [[1, 2, 3, 4]])\n```"}, {"start": 43, "end": 45, "test": "```\ndef test_canMakePalindromeQueries():\n    def canMakePalindromeQueries(s: str, queries: List[List[int]]) -> bool:\n        return solution.canMakePalindromeQueries(s, [[1, 2, 3, 4]])\n```"}]}
{"task_num": 3001, "task_title": "Minimum Moves to Capture The Queen", "func_name": "minMovesToCaptureTheQueen", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minMovesToCaptureTheQueen(self, a: int, b: int, c: int, d: int, e: int, f: int) -> int:\n    if a == e:\n      if c == a and (b < d < f or b > d > f):\n        return 2\n      else:\n        return 1\n    if b == f:\n      if d == f and (a < c < e or a > c > e):\n        return 2\n      else:\n        return 1\n    if c + d == e + f:\n      if a + b == c + d and (c < a < e or c > a > e):\n        return 2\n      else:\n        return 1\n    if c - d == e - f:\n      if a - b == c - d and (c < a < e or c > a > e):\n        return 2\n      else:\n        return 1\n    return 2\n", "tests": [{"start": 13, "end": 17, "test": "def test_minMovesToCaptureTheQueen(): \n    solution = Solution() \n    assert solution.minMovesToCaptureTheQueen(1, 2, 1, 2, 7, 8) == 2"}, {"start": 18, "end": 22, "test": "def test_minMovesToCaptureTheQueen(): \n    solution = Solution() \n    assert solution.minMovesToCaptureTheQueen(2, 3, 4, 5, 6, 7) == 1"}, {"start": 23, "end": 27, "test": "def test_minMovesToCaptureTheQueen(): \n    solution = Solution() \n    assert solution.minMovesToCaptureTheQueen(2, 3, 4, 5, 6, 7) == 1"}, {"start": 28, "end": 32, "test": "def test_minMovesToCaptureTheQueen(): \n    solution = Solution() \n    assert solution.minMovesToCaptureTheQueen(2, 3, 4, 5, 6, 7) == 1"}, {"start": 14, "end": 15, "test": "```\ndef test_minMovesToCaptureTheQueen():\n    solution=Solution()\n    assert solution.minMovesToCaptureTheQueen(1, 3, 1, 4, 5, 7) == 2\n```"}, {"start": 16, "end": 17, "test": "```\ndef test_minMovesToCaptureTheQueen():\n    solution=Solution()\n    assert solution.minMovesToCaptureTheQueen(0, 0, 2, 3, 4, 5) == 1\n```"}, {"start": 19, "end": 20, "test": "```\ndef test_minMovesToCaptureTheQueen():\n    solution=Solution()\n    assert solution.minMovesToCaptureTheQueen(1, 3, 4, 5, 2, 6) == 2\n```"}, {"start": 21, "end": 22, "test": "```\ndef test_minMovesToCaptureTheQueen():\n    solution=Solution()\n    assert solution.minMovesToCaptureTheQueen(2,3,4,5,6,7) == 1\n```"}, {"start": 24, "end": 25, "test": "```\ndef test_minMovesToCaptureTheQueen():\n    solution=Solution()\n    assert solution.minMovesToCaptureTheQueen(1, 3, 4, 5, 2, 6) == 2\n```"}, {"start": 26, "end": 27, "test": "```\ndef test_minMovesToCaptureTheQueen():\n    solution=Solution()\n    assert solution.minMovesToCaptureTheQueen(2, 3, 4, 5, 6, 7) == 1\n```"}, {"start": 29, "end": 30, "test": "```\ndef test_minMovesToCaptureTheQueen():\n    solution=Solution()\n    assert solution.minMovesToCaptureTheQueen(1, 3, 4, 5, 2, 6) == 2\n```"}, {"start": 31, "end": 32, "test": "```\ndef test_minMovesToCaptureTheQueen():\n    def minMovesToCaptureTheQueen(a: int, b: int, c: int, d: int, e: int, f: int) -> int:\n        return 1\n```"}]}
{"task_num": 3006, "task_title": "Find Beautiful Indices in the Given Array I", "func_name": "beautifulIndices", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def beautifulIndices(self, s: str, a: str, b: str, k: int) -> List[int]:\n    ans = []\n    indicesA = self._kmp(s, a)\n    indicesB = self._kmp(s, b)\n    indicesBIndex = 0\n\n    for i in indicesA:\n      while indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i < -k:\n        indicesBIndex += 1\n      if indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i <= k:\n        ans.append(i)\n\n    return ans\n\n  def _kmp(self, s: str, pattern: str) -> List[int]:\n    def getLPS(pattern: str) -> List[int]:\n      lps = [0] * len(pattern)\n      j = 0\n      for i in range(1, len(pattern)):\n        while j > 0 and pattern[j] != pattern[i]:\n          j = lps[j - 1]\n        if pattern[i] == pattern[j]:\n          lps[i] = j + 1\n          j += 1\n      return lps\n\n    res = []\n    lps = getLPS(pattern)\n    i = 0\n    j = 0\n    while i < len(s):\n      if s[i] == pattern[j]:\n        i += 1\n        j += 1\n        if j == len(pattern):\n          res.append(i - j)\n          j = lps[j - 1]\n      elif j != 0:\n        j = lps[j - 1]\n      else:\n        i += 1\n    return res\n", "tests": [{"start": 21, "end": 22, "test": "```\ndef test_beautifulIndices():\n    solution = Solution()\n    assert sorted(solution.beautifulIndices(\"abcba\", \"aba\", \"bcb\", 2)) == [0, 3], None\n```"}, {"start": 43, "end": 48, "test": "```\ndef test_beautifulIndices():\n    solution=Solution()\n    assert sorted(solution.beautifulIndices(\"abcba\", \"aba\", \"bcb\", 2)) == [0, 3], None\n```"}, {"start": 33, "end": 35, "test": "```\ndef test_beautifulIndices():\n    solution=Solution()\n    assert sorted(solution.beautifulIndices(\"abcba\", \"aba\", \"bcb\", 2)) == [0, 3], None\n```"}, {"start": 46, "end": 48, "test": "```\ndef test_beautifulIndices():\n    solution=Solution()\n    assert sorted(solution.beautifulIndices(\"abcba\", \"aba\", \"bcb\", 2)) == [0, 3], None\n```"}, {"start": 49, "end": 50, "test": "```\ndef test_beautifulIndices():\n    def beautiful_indices(s: str, a: str, b: str, k: int) -> List[int]:\n        return [0, 2, 4]\n    assert beautiful_indices(\"abacaba\", \"aba\", \"ba\", 1) == [0, 2, 4], f\"Expected {beautiful_indices('abacaba', 'aba', 'ba', 1)} but got {beautiful_indices('abacaba', 'aba', 'ba', 1)}\"\n```"}, {"start": 51, "end": 52, "test": "```\ndef test_beautifulIndices():\n    solution = Solution()\n    assert sorted(solution.beautifulIndices(\"abcba\", \"aba\", \"bcb\", 2)) == [0, 3], None\n```"}]}
{"task_num": 3029, "task_title": "Minimum Time to Revert Word to Initial State I", "func_name": "minimumTimeToInitialState", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumTimeToInitialState(self, word: str, k: int) -> int:\n    n = len(word)\n    maxOps = (n - 1) // k + 1\n    z = self._zFunction(word)\n\n    for ans in range(1, maxOps):\n      if z[ans * k] >= n - ans * k:\n        return ans\n\n    return maxOps\n\n  def _zFunction(self, s: str) -> List[int]:\n    n = len(s)\n    z = [0] * n\n    l = 0\n    r = 0\n    for i in range(1, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l])\n      while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n    return z\n", "tests": [{"start": 18, "end": 19, "test": "```\ndef test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState(\"abc\", 1) == 2\n```"}, {"start": 29, "end": 30, "test": "```\ndef test_minimumTimeToInitialState():\n    solution=Solution()\n    assert solution.minimumTimeToInitialState(\"abc\", 1) == 2\n```"}, {"start": 33, "end": 35, "test": "```\ndef test_minimumTimeToInitialState():\n    solution=Solution()\n    assert solution.minimumTimeToInitialState(\"abac\", 3) == 2\n```"}]}
{"task_num": 3030, "task_title": "Find the Grid of Region Average", "func_name": "resultGrid", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def resultGrid(self, image: List[List[int]], threshold: int) -> List[List[int]]:\n    m = len(image)\n    n = len(image[0])\n    sums = [[0] * n for _ in range(m)]\n    counts = [[0] * n for _ in range(m)]\n\n    for i in range(m - 2):\n      for j in range(n - 2):\n        if self._isRegion(image, i, j, threshold):\n          subgridSum = sum(image[x][y] for x in range(i, i + 3) for y in range(j, j + 3))\n          for x in range(i, i + 3):\n            for y in range(j, j + 3):\n              sums[x][y] += subgridSum // 9\n              counts[x][y] += 1\n\n    for i in range(m):\n      for j in range(n):\n        if counts[i][j] > 0:\n          image[i][j] = sums[i][j] // counts[i][j]\n\n    return image\n\n  def _isRegion(self, image: List[List[int]], i: int, j: int, threshold: int) -> bool:\n    for x in range(i, i + 3):\n      for y in range(j, j + 3):\n        if x > i and abs(image[x][y] - image[x - 1][y]) > threshold:\n          return False\n        if y > j and abs(image[x][y] - image[x][y - 1]) > threshold:\n          return False\n    return True\n", "tests": [{"start": 20, "end": 25, "test": "def test_resultGrid(): \n    solution = Solution() \n    image = [[0, 0, 0, 0], [0, 255, 255, 0], [0, 255, 0, 0], [0, 0, 0, 0]] \n    threshold = 1 \n    result = solution.resultGrid(image, threshold)"}, {"start": 29, "end": 30, "test": "```\ndef test_resultGrid():\n    solution=Solution()\n    image = [[1,2,3],[4,5,6],[7,8,9]]\n    threshold = 1\n    result = solution.resultGrid(image, threshold)\n```"}, {"start": 37, "end": 38, "test": "```\ndef test_resultGrid():\n    solution = Solution()\n    result = solution.resultGrid([[0, 1, 2], [3, 4, 5], [6, 7, 8]], 1)\n```"}, {"start": 39, "end": 40, "test": "```\ndef test_resultGrid():\n    solution = Solution()\n    result = solution.resultGrid([[0, 1, 2], [3, 4, 5], [6, 7, 8]], 1)\n```"}]}
{"task_num": 3043, "task_title": "Find the Length of the Longest Common Prefix", "func_name": "longestCommonPrefix", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass TrieNode:\n  def __init__(self):\n    self.children: Dict[str, TrieNode] = {}\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def insert(self, word: str) -> None:\n    node: TrieNode = self.root\n    for c in word:\n      node = node.children.setdefault(c, TrieNode())\n    node.isWord = True\n\n  def search(self, word: str) -> int:\n    prefixLength = 0\n    node = self.root\n    for c in word:\n      if c not in node.children:\n        break\n      node = node.children[c]\n      prefixLength += 1\n    return prefixLength\n\n\nclass Solution:\n  def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:\n    trie = Trie()\n\n    for num in arr1:\n      trie.insert(str(num))\n\n    return max(trie.search(str(num)) for num in arr2)\n", "tests": [{"start": 30, "end": 31, "test": "def test_longestCommonPrefix():    \n    solution = Solution()    \n    assert solution.longestCommonPrefix([123, 456], [789, 101]) == 0"}]}
{"task_num": 3044, "task_title": "Most Frequent Prime", "func_name": "mostFrequentPrime", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def mostFrequentPrime(self, mat: List[List[int]]) -> int:\n    dirs = ((1, 0), (1, -1), (0, -1), (-1, -1),\n            (-1, 0), (-1, 1), (0, 1), (1, 1))\n    m = len(mat)\n    n = len(mat[0])\n    count = collections.Counter()\n\n    def isPrime(num: int) -> bool:\n      return not any(num % i == 0 for i in range(2, int(num**0.5 + 1)))\n\n    for i in range(m):\n      for j in range(n):\n        for dx, dy in dirs:\n          num = 0\n          x = i\n          y = j\n          while 0 <= x < m and 0 <= y < n:\n            num = num * 10 + mat[x][y]\n            if num > 10 and isPrime(num):\n              count[num] += 1\n            x += dx\n            y += dy\n\n    if not count.items():\n      return -1\n    return max(count.items(), key=lambda x: (x[1], x[0]))[0]\n", "tests": [{"start": 35, "end": 36, "test": "```\ndef test_mostFrequentPrime():\n    solution = Solution()\n    mat = [[1, 2], [3, 4]]\n    assert solution.mostFrequentPrime(mat) == -1\n```"}, {"start": 30, "end": 31, "test": "```\ndef test_mostFrequentPrime():\n    solution = Solution()\n    mat = [[1, 2, 3], [4, 5, 6]]\n    assert solution.mostFrequentPrime(mat) == 23\n```"}]}
{"task_num": 3072, "task_title": "Distribute Elements Into Two Arrays II", "func_name": "resultArray", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass FenwickTree:\n  def __init__(self, n: int):\n    self.sums = [0] * (n + 1)\n\n  def update(self, i: int, delta: int) -> None:\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def resultArray(self, nums: List[int]) -> List[int]:\n    arr1 = []\n    arr2 = []\n    ranks = self._getRanks(nums)\n    tree1 = FenwickTree(len(ranks))\n    tree2 = FenwickTree(len(ranks))\n\n    def add(num: int, arr: List[int], tree: FenwickTree) -> None:\n      arr.append(num)\n      tree.update(ranks[num], 1)\n\n    add(nums[0], arr1, tree1)\n    add(nums[1], arr2, tree2)\n\n    for i in range(2, len(nums)):\n      greaterCount1 = len(arr1) - tree1.get(ranks[nums[i]])\n      greaterCount2 = len(arr2) - tree2.get(ranks[nums[i]])\n      if greaterCount1 > greaterCount2:\n        add(nums[i], arr1, tree1)\n      elif greaterCount1 < greaterCount2:\n        add(nums[i], arr2, tree2)\n      elif len(arr1) > len(arr2):\n        add(nums[i], arr2, tree2)\n      else:\n        add(nums[i], arr1, tree1)\n\n    return arr1 + arr2\n\n  def _getRanks(self, nums: List[int]) -> Dict[int, int]:\n    ranks = collections.Counter()\n    rank = 0\n    for num in sorted(set(nums)):\n      rank += 1\n      ranks[num] = rank\n    return ranks\n", "tests": [{"start": 50, "end": 51, "test": "```\ndef test_resultArray():\n    solution = Solution()\n    result = solution.resultArray([1, 3, 4, 5, 6])\n```"}, {"start": 52, "end": 53, "test": "```\ndef test_resultArray():\n    solution = Solution()\n    result = solution.resultArray([1, 3, 5, 4, 2])\n```"}, {"start": 54, "end": 55, "test": "```\ndef test_resultArray():\n    solution = Solution()\n    result = solution.resultArray([1, 3, 4, 5, 6])\n```"}, {"start": 56, "end": 57, "test": "```\ndef test_resultArray():\n    solution = Solution()\n    assert solution.resultArray([1, 2, 3, 4, 5]) == [1, 2, 3, 5], None\n```"}]}
{"task_num": 3095, "task_title": "Shortest Subarray With OR at Least K I", "func_name": "minimumSubarrayLength", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumSubarrayLength(self, nums: List[int], k: int) -> int:\n    ans = len(nums) + 1\n    ors = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, num in enumerate(nums):\n      ors = self._orNum(ors, num, count)\n      while ors >= k and l <= r:\n        ans = min(ans, r - l + 1)\n        ors = self._undoOrNum(ors, nums[l], count)\n        l += 1\n\n    return -1 if ans == len(nums) + 1 else ans\n\n  def _orNum(self, ors: int, num: int, count: Dict[int, int]) -> int:\n    for i in range(30):\n      if num >> i & 1:\n        count[i] += 1\n        if count[i] == 1:\n          ors += 1 << i\n    return ors\n\n  def _undoOrNum(self, ors: int, num: int, count: Dict[int, int]) -> int:\n    for i in range(30):\n      if num >> i & 1:\n        count[i] -= 1\n        if count[i] == 0:\n          ors -= 1 << i\n    return ors\n", "tests": [{"start": 29, "end": 32, "test": "```\ndef test_minimumSubarrayLength():\n    solution = Solution()\n    assert solution.minimumSubarrayLength([0, 1], 2) == 3\n```"}, {"start": 37, "end": 40, "test": "```\ndef test_minimumSubarrayLength():\n    solution = Solution()\n    assert solution.minimumSubarrayLength([3,2,4], 5) == 3\n```"}, {"start": 31, "end": 32, "test": "```\ndef test_minimumSubarrayLength():\n    solution = Solution()\n    assert solution.minimumSubarrayLength([0, 1], 2) == 3\n```"}, {"start": 39, "end": 40, "test": "```\ndef test_minimumSubarrayLength():\n    solution = Solution()\n    assert solution.minimumSubarrayLength([3,5,6], 7) == 2\n```"}]}
{"task_num": 3102, "task_title": "Minimize Manhattan Distances", "func_name": "minimumDistance", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumDistance(self, points: List[List[int]]) -> int:\n    i, j = self._maxManhattanDistance(points, -1)\n    xi, yi = self._maxManhattanDistance(points, i)\n    xj, yj = self._maxManhattanDistance(points, j)\n    return min(self._manhattan(points, xi, yi), self._manhattan(points, xj, yj))\n\n  def _maxManhattanDistance(self, points: List[List[int]], excludedIndex: int) -> int:\n    minSum = math.inf\n    maxSum = -math.inf\n    minDiff = math.inf\n    maxDiff = -math.inf\n    minSumIndex = -1\n    maxSumIndex = -1\n    minDiffIndex = -1\n    maxDiffIndex = -1\n\n    for i, (x, y) in enumerate(points):\n      if i == excludedIndex:\n        continue\n      summ = x + y\n      diff = x - y\n      if summ < minSum:\n        minSum = summ\n        minSumIndex = i\n      if summ > maxSum:\n        maxSum = summ\n        maxSumIndex = i\n      if diff < minDiff:\n        minDiff = diff\n        minDiffIndex = i\n      if diff > maxDiff:\n        maxDiff = diff\n        maxDiffIndex = i\n\n    if maxSum - minSum >= maxDiff - minDiff:\n      return [minSumIndex, maxSumIndex]\n    else:\n      return [minDiffIndex, maxDiffIndex]\n\n  def _manhattan(self, points: List[List[int]], i: int, j: int) -> int:\n    return abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n", "tests": [{"start": 46, "end": 47, "test": "```\ndef test_minimumDistance():\n    points = [[0, 0], [1, 1], [-1, -1]]\n    assert minimumDistance(points) == 2\n```"}, {"start": 48, "end": 49, "test": "```\ndef test_minimumDistance():\n    points = [[0, 3], [1, 2], [5, 0], [6, 7]]\n    assert minimumDistance(points) == [1, 3]\n```"}, {"start": 29, "end": 30, "test": "```\ndef test_minimumDistance():\n    solution = Solution()\n    points = [[0, 0], [1, 1], [2, 2]]\n    assert solution.minimumDistance(points) == 3\n```"}, {"start": 33, "end": 35, "test": "```\ndef test_minimumDistance():\n    points = [[0, 0], [1, 1], [-1, -1]]\n    assert minimumDistance(points) == 2\n```"}, {"start": 36, "end": 38, "test": "```\ndef test_minimumDistance():\n    points = [[0, 0], [1, 1], [2, 2]]\n    assert minimumDistance(points) == 3\n```"}, {"start": 39, "end": 41, "test": "```\ndef test_minimumDistance():\n    points = [[0, 3], [1, 2], [5, -1]]\n    assert minimumDistance(points) == 4\n```"}, {"start": 42, "end": 44, "test": "```\ndef test_minimumDistance():\n    points = [[0, 0], [1, 1], [-1, -1]]\n    assert minimumDistance(points) == 2\n```"}]}
{"task_num": 3108, "task_title": "Minimum Cost Walk in Weighted Graph", "func_name": "minimumCost", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n    self.weight = [(1 << 17) - 1] * n\n\n  def unionByRank(self, u: int, v: int, w: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    newWeight = self.weight[i] & self.weight[j] & w\n    self.weight[i] = newWeight\n    self.weight[j] = newWeight\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def getMinCost(self, u: int, v: int) -> int:\n    if u == v:\n      return 0\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return self.weight[i]\n    else:\n      return -1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def minimumCost(self, n: int, edges: List[List[int]], query: List[List[int]]) -> List[int]:\n    uf = UnionFind(n)\n\n    for u, v, w in edges:\n      uf.unionByRank(u, v, w)\n\n    return [uf.getMinCost(u, v) for u, v in query]\n", "tests": [{"start": 23, "end": 24, "test": "```\ndef test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost(3, [[0, 1, 2], [1, 2, 3]], [[0, 2]]) == [2]\n```"}, {"start": 25, "end": 26, "test": "```\ndef test_minimumCost():\n    solution=Solution()\n    n = 4\n    edges = [[0,1,3],[1,2,5],[2,3,2]]\n    query = [[0,1],[1,2],[2,0]]\n    expected_result = [3,-1,3]\n    assert solution.minimumCost(n,edges,query) == expected_result"}, {"start": 34, "end": 35, "test": "```\ndef test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost(3, [[0,1,2],[1,2,3]], [[0,2]]) == [0], \n```"}, {"start": 38, "end": 39, "test": "```\ndef test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost(3, [[0, 1, 2], [1, 2, 3]], [[0, 2]]) == [6]\n```"}, {"start": 40, "end": 41, "test": "```\ndef test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost(3, [[0, 1, 2], [1, 2, 3]], [[0, 2]]) == [-1]\n```"}, {"start": 44, "end": 45, "test": "```\ndef test_minimumCost():\n    solution=Solution()\n    assert solution.minimumCost(3, [[0,1,2],[1,2,3]], [[0,2]]) == [6], \n```"}, {"start": 27, "end": 28, "test": "```\ndef test_minimumCost():\n    solution=Solution()\n    n = 4\n    edges = [[0,1,3],[1,2,5],[2,3,2]]\n    query = [[0,1],[1,2],[2,0]]\n    expected = [3,-1,3]\n    assert solution.minimumCost(n,edges,query) == expected"}, {"start": 29, "end": 31, "test": "```\ndef test_minimumCost():\n    solution=Solution()\n    n = 3\n    edges = [[0,1,2],[1,2,1]]\n    query = [[0,2],[1,2]]\n    expected_result = [2,-1]\n    assert solution.minimumCost(n,edges,query) == expected_result"}]}
{"task_num": 3112, "task_title": "Minimum Time to Visit Disappearing Nodes", "func_name": "minimumTime", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, 0, disappear)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, disappear: List[int]) -> List[int]:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < disappear[v] and d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    res=[]\n    for d in dist:\n      if d != math.inf:\n        res.append(d)\n      else:\n        res.append(-1)\n    return res\n", "tests": [{"start": 29, "end": 30, "test": "```\ndef test_minimumTime():\n    solution=Solution()\n    assert solution.minimumTime(3, [[0,1,2],[1,2,5]], [0,2]) == [0, 4, -1]\n```"}, {"start": 38, "end": 39, "test": "```\ndef test_minimumTime():\n    solution=Solution()\n    assert solution.minimumTime(3, [[0,1,2],[1,2,5]], [0,2]) == [0, 4, -1]\n```"}, {"start": 40, "end": 41, "test": "```\ndef test_minimumTime():\n    solution=Solution()\n    assert solution.minimumTime(3, [[0, 1, 2], [1, 2, 5]], [0, 1]) == [-1, -1, 4]\n```"}, {"start": 32, "end": 34, "test": "```\ndef test_minimumTime():\n    solution=Solution()\n    n = 3\n    edges = [[0,1,2],[1,2,5]]\n    disappear = [0,3]\n    result = solution.minimumTime(n,edges,disappear)\n```"}]}
{"task_num": 3123, "task_title": "Find Edges in Shortest Paths", "func_name": "findAnswer", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findAnswer(self, n: int, edges: List[List[int]]) -> List[bool]:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    from0 = self._dijkstra(graph, 0)\n    from1 = self._dijkstra(graph, n - 1)\n    return [from0[u] + w + from1[v] == from0[-1] or from0[v] + w + from1[u] == from0[-1] for u, v, w in edges]\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int) -> List[int]:\n    dist = [10**9] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist\n", "tests": [{"start": 31, "end": 32, "test": "```\ndef test_findAnswer():\n    solution = Solution()\n    result = solution.findAnswer(3, [[0, 1, 2], [1, 2, 1], [2, 0, 4]])\n    assert result == [True, True, False]\n```"}, {"start": 34, "end": 36, "test": "```\ndef test_findAnswer():\n    solution=Solution()\n    assert solution.findAnswer(3, [[0,1,4],[2,0,5],[1,2,1]]) == [True,True,False]\n```"}]}
