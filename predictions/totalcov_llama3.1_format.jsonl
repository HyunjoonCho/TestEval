{"task_num": 4, "task_title": "Median of Two Sorted Arrays", "func_name": "findMedianSortedArrays", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n    n1 = len(nums1)\n    n2 = len(nums2)\n    if n1 > n2:\n      return self.findMedianSortedArrays(nums2, nums1)\n\n    l = 0\n    r = n1\n\n    while l <= r:\n      partition1 = (l + r) // 2\n      partition2 = (n1 + n2 + 1) // 2 - partition1\n      maxLeft1 = -2**31 if partition1 == 0 else nums1[partition1 - 1]\n      maxLeft2 = -2**31 if partition2 == 0 else nums2[partition2 - 1]\n      minRight1 = 2**31 - 1 if partition1 == n1 else nums1[partition1]\n      minRight2 = 2**31 - 1 if partition2 == n2 else nums2[partition2]\n      if maxLeft1 <= minRight2 and maxLeft2 <= minRight1:\n        if (n1 + n2) % 2 == 0:\n          return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) * 0.5\n        else:\n          return max(maxLeft1, maxLeft2)\n      elif maxLeft1 > minRight2:\n        r = partition1 - 1\n      else:\n        l = partition1 + 1\n", "tests": ["def test_findMedianSortedArrays():\n    solution = Solution()\n    nums1 = [1, 3]\n    nums2 = [2]\n    assert abs(solution.findMedianSortedArrays(nums1, nums2) - 2.0) < 1e-06", "def test_findMedianSortedArrays():\n    solution = Solution()\n    nums1 = [2]\n    nums2 = [1, 3]\n    assert abs(solution.findMedianSortedArrays(nums1, nums2) - 2.0) < 1e-06", "def test_findMedianSortedArrays():\n    solution = Solution()\n    nums1 = [1]\n    nums2 = [2, 3]\n    assert abs(solution.findMedianSortedArrays(nums1, nums2) - 2.0) < 1e-06", "def test_findMedianSortedArrays():\n    solution = Solution()\n    nums1 = [2, 3]\n    nums2 = [4]\n    assert abs(solution.findMedianSortedArrays(nums1, nums2) - 2.5) < 1e-06", "def test_findMedianSortedArrays():\n    solution = Solution()\n    nums1 = [1, 2]\n    nums2 = []\n    assert abs(solution.findMedianSortedArrays(nums1, nums2) - 1.0) < 1e-06", "def test_findMedianSortedArrays():\n    solution = Solution()\n    nums1 = []\n    nums2 = [1]\n    assert abs(solution.findMedianSortedArrays(nums1, nums2) - 1.0) < 1e-06", "def test_findMedianSortedArrays():\n    solution = Solution()\n    nums1 = []\n    nums2 = [1, 3]\n    assert abs(solution.findMedianSortedArrays(nums1, nums2) - 2.0) < 1e-06", "def test_findMedianSortedArrays():\n    solution = Solution()\n    nums1 = [2 ** 31 - 1]\n    nums2 = [-2 ** 31 + 1]\n    assert abs(solution.findMedianSortedArrays(nums1, nums2) - (2 ** 31 - 2 ** 32 + 0.5)) < 1e-06", "def test_findMedianSortedArrays():\n    solution = Solution()\n    nums1 = [2 ** 31 - 1, 2 ** 32]\n    nums2 = [-2 ** 31 + 1, -2 ** 32 + 1]\n    assert abs(solution.findMedianSortedArrays(nums1, nums2) - (2 ** 32 - 0.5)) < 1e-06", "def test_findMedianSortedArrays():\n    solution = Solution()\n    nums1 = [2 ** 31 - 1] * 1000000\n    nums2 = [-2 ** 31 + 1]\n    assert abs(solution.findMedianSortedArrays(nums1, nums2) - (2 ** 32 - 0.5)) < 1e-06", "def test_findMedianSortedArrays():\n    solution = Solution()\n    nums1 = [-2 ** 31 + 1]\n    nums2 = [2 ** 31 - 1] * 1000000\n    assert abs(solution.findMedianSortedArrays(nums1, nums2) - (2 ** 32 - 0.5)) < 1e-06", "def test_findMedianSortedArrays():\n    solution = Solution()\n    nums1 = [1] * 1000000\n    nums2 = []\n    assert abs(solution.findMedianSortedArrays(nums1, nums2) - (1 + 0.5)) < 1e-06", "def test_findMedianSortedArrays():\n    solution = Solution()\n    nums1 = [2 ** 31 - 1] * 1000000\n    nums2 = [-2 ** 32]\n    assert abs(solution.findMedianSortedArrays(nums1, nums2) - 2 ** 32) < 1e-06", "def test_findMedianSortedArrays():\n    solution = Solution()\n    nums1 = [2 ** 31 - 1] * 1000000 + [2 ** 32]\n    nums2 = [-2 ** 32] * 1000000\n    assert abs(solution.findMedianSortedArrays(nums1, nums2) - 2 ** 32) < 1e-06", "def test_findMedianSortedArrays():\n    solution = Solution()\n    nums1 = [2 ** 32] * 500000 + [-2 ** 31]\n    nums2 = [-2 ** 32] * 1000000\n    assert abs(solution.findMedianSortedArrays(nums1, nums2) - 2 ** 32) < 1e-06", "def test_findMedianSortedArrays():\n    solution = Solution()\n    nums1 = [2 ** 32] * 499999 + [-2 ** 31]\n    nums2 = [-2 ** 32] * 1000000\n    assert abs(solution.findMedianSortedArrays(nums1, nums2) - 2 ** 32) < 1e-06", "def test_findMedianSortedArrays():\n    solution = Solution()\n    nums1 = [2 ** 31 - 1] * 1000000 + [-2 ** 32]\n    nums2 = []\n    assert abs(solution.findMedianSortedArrays(nums1, nums2) - 2 ** 32) < 1e-06", "def test_findMedianSortedArrays():\n    solution = Solution()\n    nums1 = [2 ** 32] * 500000 + [-2 ** 31]\n    nums2 = []\n    assert abs(solution.findMedianSortedArrays(nums1, nums2) - 2 ** 32) < 1e-06", "def test_findMedianSortedArrays():\n    solution = Solution()\n    nums1 = [-2 ** 31 + 1] * 1000000\n    nums2 = [2 ** 31 - 1]\n    assert abs(solution.findMedianSortedArrays(nums1, nums2) - (2 ** 32 - 0.5)) < 1e-06", "def test_findMedianSortedArrays():\n    solution = Solution()\n    nums1 = [2 ** 31 - 1] * 1000000 + [2]\n    nums2 = [-2 ** 32] * 500000 + [3]\n    assert abs(solution.findMedianSortedArrays(nums1, nums2) - 2.5) < 1e-06"]}
{"task_num": 10, "task_title": "Regular Expression Matching", "func_name": "isMatch", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isMatch(self, s: str, p: str) -> bool:\n    m = len(s)\n    n = len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    def isMatch(i: int, j: int) -> bool:\n      return j >= 0 and p[j] == '.' or s[i] == p[j]\n\n    for j, c in enumerate(p):\n      if c == '*' and dp[0][j - 1]:\n        dp[0][j + 1] = True\n\n    for i in range(m):\n      for j in range(n):\n        if p[j] == '*':\n          noRepeat = dp[i + 1][j - 1]\n          doRepeat = isMatch(i, j - 1) and dp[i][j + 1]\n          dp[i + 1][j + 1] = noRepeat or doRepeat\n        elif isMatch(i, j):\n          dp[i + 1][j + 1] = dp[i][j]\n\n    return dp[m][n]\n", "tests": ["def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('aa', 'a') == False", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('aaa', 'a*') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('abc', 'a.b.c') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('abc', 'a.*c') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('', 'a*') == False", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('a', '.*') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('abc', 'a*b.c') == False", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('abc', 'a.*b.c') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('a', '.*') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('aaa', '.*') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('ab', '.*') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('a', '.*') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('abc', '.*a') == False", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('ab', '.*a') == False", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('aaa', 'a*b') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('aab', 'c*a*b') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('aaaa', 'a*a*a*a') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('aaa', 'a*a') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('aaa', 'a*a') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('aaa', 'a*a') == True"]}
{"task_num": 15, "task_title": "3Sum", "func_name": "threeSum", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def threeSum(self, nums: List[int]) -> List[List[int]]:\n    if len(nums) < 3:\n      return []\n\n    ans = []\n\n    nums.sort()\n\n    for i in range(len(nums) - 2):\n      if i > 0 and nums[i] == nums[i - 1]:\n        continue\n\n      l = i + 1\n      r = len(nums) - 1\n      while l < r:\n        summ = nums[i] + nums[l] + nums[r]\n        if summ == 0:\n          ans.append((nums[i], nums[l], nums[r]))\n          l += 1\n          r -= 1\n          while nums[l] == nums[l - 1] and l < r:\n            l += 1\n          while nums[r] == nums[r + 1] and l < r:\n            r -= 1\n        elif summ < 0:\n          l += 1\n        else:\n          r -= 1\n\n    return ans\n", "tests": ["def test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([-1, 0, 1, 2, -1, -4]) == [[-1, -1, 2], [-1, 0, 1]]", "def test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([0, 0, 0]) == [[0, 0, 0]]", "def test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([1, 2, 3]) == []", "def test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([3, -2, 1, 0]) == [[-2, 0, 3]]", "def test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([0, 0, 0])", "def test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([0] * 10) == []", "def test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([-5, -3, 0, 1, 2]) == [[-5, 0, 5], [-3, 0, 3]]", "def test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([1, 1, -2]) == []", "def test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([1, 1, -2, 0]) == [[-2, 0, 2]]", "def test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([1, -2, 1]) == []", "def test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([1, -2, 0]) == []", "def test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([-2, -1, 0]) == []", "def test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([0, -1, 1]) == [[-1, 0, 1]]", "def test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([0, 0, -1]) == [[-1, 0, 1]]", "def test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([0, 1, -1]) == [[-1, 0, 1]]", "def test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([0]) == []", "def test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([]) == []", "def test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([0] * 3) == []", "def test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([0] * 5) == []", "def test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([0] * 10) == []"]}
{"task_num": 44, "task_title": "Wildcard Matching", "func_name": "isMatch", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isMatch(self, s: str, p: str) -> bool:\n    m = len(s)\n    n = len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    def isMatch(i: int, j: int) -> bool:\n      return i >= 0 and p[j] == '?' or s[i] == p[j]\n\n    for j, c in enumerate(p):\n      if c == '*':\n        dp[0][j + 1] = dp[0][j]\n\n    for i in range(m):\n      for j in range(n):\n        if p[j] == '*':\n          matchEmpty = dp[i + 1][j]\n          matchSome = dp[i][j + 1]\n          dp[i + 1][j + 1] = matchEmpty or matchSome\n        elif isMatch(i, j):\n          dp[i + 1][j + 1] = dp[i][j]\n\n    return dp[m][n]\n", "tests": ["def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('aa', '*') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('', 'a?b') == False", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('aaa', 'a*b') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('abc', 'a?b*c') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('abcdef', 'a*d*e*f*g*h*i*j*k*l*m*n*o*p*q*r*s*t*u*v*w*x*y*z*a*b*c') == False", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('a', '.*') == False", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('ab', 'a*') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('abc', 'a*b*c') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('xyz', 'x.*z') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('a', '*') == False", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('', '?') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('a?b', '?') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('?', 'b?') == False", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('ab', '.*') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('aaa', 'aa') == False", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('abc', 'a.*b') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('abc', 'a.*c') == False", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('ab', '?*') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('ab', '.*') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('a', '.*') == True"]}
{"task_num": 54, "task_title": "Spiral Matrix", "func_name": "spiralOrder", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n    if not matrix:\n      return []\n\n    m = len(matrix)\n    n = len(matrix[0])\n    ans = []\n    r1 = 0\n    c1 = 0\n    r2 = m - 1\n    c2 = n - 1\n\n    while len(ans) < m * n:\n      j = c1\n      while j <= c2 and len(ans) < m * n:\n        ans.append(matrix[r1][j])\n        j += 1\n      i = r1 + 1\n      while i <= r2 - 1 and len(ans) < m * n:\n        ans.append(matrix[i][c2])\n        i += 1\n      j = c2\n      while j >= c1 and len(ans) < m * n:\n        ans.append(matrix[r2][j])\n        j -= 1\n      i = r2 - 1\n      while i >= r1 + 1 and len(ans) < m * n:\n        ans.append(matrix[i][c1])\n        i -= 1\n      r1 += 1\n      c1 += 1\n      r2 -= 1\n      c2 -= 1\n\n    return ans\n", "tests": ["def test_spiralOrder():\n    solution = Solution()\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    assert solution.spiralOrder(matrix) == [1, 2, 3, 6, 9, 8, 7, 4, 5]", "def test_spiralOrder():\n    solution = Solution()\n    matrix = []\n    assert solution.spiralOrder(matrix) == []", "def test_spiralOrder():\n    solution = Solution()\n    matrix = [[5]]\n    assert solution.spiralOrder(matrix) == [5]", "def test_spiralOrder():\n    solution = Solution()\n    matrix = [[1, 2], [4, 3]]\n    assert solution.spiralOrder(matrix) == [1, 2, 3, 4]", "def test_spiralOrder():\n    solution = Solution()\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 1]]\n    assert solution.spiralOrder(matrix) == [1, 2, 3, 6, 9, 8, 7, 4, 5]", "def test_spiralOrder():\n    solution = Solution()\n    matrix = [[1] * 1000 for _ in range(1000)]\n    result = solution.spiralOrder(matrix)", "def test_spiralOrder():\n    solution = Solution()\n    matrix = [[-1, -2], [-4, -3]]\n    assert solution.spiralOrder(matrix) == [-1, -2, -3, -4]", "def test_spiralOrder():\n    solution = Solution()\n    matrix = [[10]]\n    assert solution.spiralOrder(matrix) == [10]", "def test_spiralOrder():\n    solution = Solution()\n    matrix = [[0, 2], [4, 3]]\n    assert solution.spiralOrder(matrix) == [0, 2, 3, 4]", "def test_spiralOrder():\n    solution = Solution()\n    matrix = [[-1, -2], [4, 5]]\n    assert solution.spiralOrder(matrix) == [-1, -2, 4, 5]", "def test_spiralOrder():\n    solution = Solution()\n    matrix = [[1] * 1000 for _ in range(1000)]\n    result = solution.spiralOrder(matrix)", "def test_spiralOrder():\n    solution = Solution()\n    matrix = [[-1, 0], [4, -3]]\n    assert solution.spiralOrder(matrix) == [-1, 0, -3, 4]", "def test_spiralOrder():\n    solution = Solution()\n    matrix = [[1, 'a'], ['b', 3]]\n    assert solution.spiralOrder(matrix) == [1, 'a', 3, 'b']", "def test_spiralOrder():\n    solution = Solution()\n    matrix = [[None] * 3 for _ in range(3)]\n    assert solution.spiralOrder(matrix) == []", "def test_spiralOrder_invalid_input():\n  solution = Solution()\n  matrix = \"not a list\"\n  try:\n    solution.spiralOrder(matrix)", "def test_spiralOrder():\n    solution = Solution()\n    matrix = [[1, 'a'], ['b', 3]]\n    assert solution.spiralOrder(matrix) == [1, 'a', 3, 'b']", "def test_spiralOrder_none_matrix():\n  solution = Solution()\n  matrix = None\n  try:\n    solution.spiralOrder(matrix)", "def test_spiralOrder():\n    solution = Solution()\n    matrix = [[1.0, 2], [4, 3.5]]\n    assert solution.spiralOrder(matrix) == [1.0, 2, 3.5, 4]", "def test_spiralOrder():\n    solution = Solution()\n    matrix = [[1 + 2j, 2], [4, 3 + 5j]]\n    assert solution.spiralOrder(matrix) == [1 + 2j, 2, 3 + 5j, 4]", "def test_spiralOrder_matrix_with_nan():\n  solution = Solution()\n  matrix = [[float('nan'), 2], [4, float('inf')]]\n  try:\n    solution.spiralOrder(matrix)"]}
{"task_num": 65, "task_title": "Valid Number", "func_name": "isNumber", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isNumber(self, s: str) -> bool:\n    s = s.strip()\n    if not s:\n      return False\n\n    seenNum = False\n    seenDot = False\n    seenE = False\n\n    for i, c in enumerate(s):\n      if c == '.':\n        if seenDot or seenE:\n          return False\n        seenDot = True\n      elif c == 'e' or c == 'E':\n        if seenE or not seenNum:\n          return False\n        seenE = True\n        seenNum = False\n      elif c in '+-':\n        if i > 0 and s[i - 1] not in 'eE':\n          return False\n        seenNum = False\n      else:\n        if not c.isdigit():\n          return False\n        seenNum = True\n\n    return seenNum\n", "tests": ["def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('0') == True, f\"Expected: {True}, Actual: {solution.isNumber('0')}\"", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('-12345.6789e+10') == True, f\"Expected: {True}, Actual: {solution.isNumber('-12345.6789e+10')}\"", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('12345e-12') == True, f\"Expected: {True}, Actual: {solution.isNumber('12345e-12')}\"", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('+0.') == False, f\"Expected: {False}, Actual: {solution.isNumber('+0.')}\"", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('e') == False, f\"Expected: {False}, Actual: {solution.isNumber('e')}\"", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('-0.12345678901234567890123456789') == False, f\"Expected: {False}, Actual: {solution.isNumber('-0.12345678901234567890123456789')}\"", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('99999e1000') == False, f\"Expected: {False}, Actual: {solution.isNumber('99999e1000')}\"", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('-3.14e-10') == True, f\"Expected: {True}, Actual: {solution.isNumber('-3.14e-10')}\"", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('12345.6789e') == False, f\"Expected: {False}, Actual: {solution.isNumber('12345.6789e')}\"", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('-12345+6789') == False, f\"Expected: {False}, Actual: {solution.isNumber('-12345+6789')}\"", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('0e10') == True, f\"Expected: {True}, Actual: {solution.isNumber('0e10')}\"", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('-12345.') == False, f\"Expected: {False}, Actual: {solution.isNumber('-12345.')}\"", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('+12345678901234567890123456789') == False, f\"Expected: {False}, Actual: {solution.isNumber('+12345678901234567890123456789')}\"", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('12345e10.') == False, f\"Expected: {False}, Actual: {solution.isNumber('12345e10.')}\"", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('123') == True, f\"Expected: {True}, Actual: {solution.isNumber('123')}\"", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('-3') == True, f\"Expected: {True}, Actual: {solution.isNumber('-3')}\"", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('1e10') == True, f\"Expected: {True}, Actual: {solution.isNumber('1e10')}\"", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('+.12345678901234567890123456789') == False, f\"Expected: {False}, Actual: {solution.isNumber('+.12345678901234567890123456789')}\"", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('12345.6789e+10.') == False, f\"Expected: {False}, Actual: {solution.isNumber('12345.6789e+10.')}\"", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('12345') == True, f\"Expected: {True}, Actual: {solution.isNumber('12345')}\""]}
{"task_num": 73, "task_title": "Set Matrix Zeroes", "func_name": "setZeroes", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def setZeroes(self, matrix: List[List[int]]) -> None:\n    m = len(matrix)\n    n = len(matrix[0])\n    shouldFillFirstRow = 0 in matrix[0]\n    shouldFillFirstCol = 0 in list(zip(*matrix))[0]\n\n    for i in range(1, m):\n      for j in range(1, n):\n        if matrix[i][j] == 0:\n          matrix[i][0] = 0\n          matrix[0][j] = 0\n\n    for i in range(1, m):\n      for j in range(1, n):\n        if matrix[i][0] == 0 or matrix[0][j] == 0:\n          matrix[i][j] = 0\n\n    if shouldFillFirstRow:\n      matrix[0] = [0] * n\n\n    if shouldFillFirstCol:\n      for row in matrix:\n        row[0] = 0\n", "tests": ["def test_setZeroes():\n    solution = Solution()\n    matrix = [[1, 1, 1], [1, 0, 1]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[0, 1, 3], [4, 5, 2], [1, 3, 0]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[1, 2], [0, 4]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[1, 0], [2, 3]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[1, 1], [1, 1]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[1, 0, 3], [4, 5, 2], [0, 7, 8]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[0, 1], [2, 3]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[0, 5, 0], [4, 0, 2]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[1, 0], [2, 3]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[1, 2, 3], [4, 5, 0]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[1, 0, 3], [4, 5, 2]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[1, 2, 3], [0, 5, 6]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[1, 2, 3], [5, 0, 6]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[1, 2, 0], [5, 6, 7]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[1, 0], [2, 3]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[0, 1], [2, 3]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[5, 6], [7, 0]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[1, 2], [0, 4]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[1, 0], [2, 3]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[5, 6], [0, 7]]\n    solution.setZeroes(matrix)"]}
{"task_num": 97, "task_title": "Interleaving String", "func_name": "isInterleave", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n    m = len(s1)\n    n = len(s2)\n    if m + n != len(s3):\n      return False\n\n    dp=[]\n    for _ in range(m + 1):\n      dp.append([False] * (n + 1))\n    dp[0][0] = True\n\n    for i in range(1, m + 1):\n      dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n\n    for j in range(1, n + 1):\n      dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n\n    return dp[m][n]\n", "tests": ["def test_isInterleave():\n\n    def check(s1, s2, s3):\n        return Solution().isInterleave(s1, s2, s3)\n    assert not check('aabcc', 'dbbca', 'aadbbcbcac')", "def test_isInterleave():\n\n    def check(s1, s2, s3):\n        return Solution().isInterleave(s1, s2, s3)\n    assert not check('', 'dbbca', '')\n    assert not check('a', '', 'aa')\n    assert check('aabcc', 'dbbca', 'aadbbcbcac')", "def test_isInterleave():\n\n    def check(s1, s2, s3):\n        return Solution().isInterleave(s1, s2, s3)\n    assert not check('aabcc', 'dbbca', '')\n    assert not check('', '', 'aaa')\n    assert check('a', 'a', 'aa')", "def test_isInterleave():\n\n    def check(s1, s2, s3):\n        return Solution().isInterleave(s1, s2, s3)\n    assert not check('aabcc', 'dbbca', 'aadbb')\n    assert check('', '', '')\n    assert check('a' * 1000, 'a' * 1000, 'a' * 2000)", "def test_isInterleave():\n\n    def check(s1, s2, s3):\n        return Solution().isInterleave(s1, s2, s3)\n    assert not check('abc', 'defg', 'abcdefg')\n    assert check('a', 'b', 'ab')\n    assert not check('aaa', 'aab', 'abb')", "def test_isInterleave():\n\n    def check(s1, s2, s3):\n        return Solution().isInterleave(s1, s2, s3)\n    assert not check('a' * 1000 + 'b', 'c' * 1000, 'abc' * 1001)", "def test_isInterleave():\n\n    def check(s1, s2, s3):\n        return Solution().isInterleave(s1, s2, s3)\n    assert not check('a', 'b' * 1000, 'ab')", "def test_isInterleave():\n\n    def check(s1, s2, s3):\n        return Solution().isInterleave(s1, s2, s3)\n    assert not check('a', 'b' * 1000 + 'c', 'abc')", "def test_isInterleave():\n\n    def check(s1, s2, s3):\n        return Solution().isInterleave(s1, s2, s3)\n    assert not check('a', 'b' * 1000 + 'c', 'abc')\n    assert not check('', '', '')\n    assert not check('aaa', 'aab', 'abb')", "def test_isInterleave():\n\n    def check(s1, s2, s3):\n        return Solution().isInterleave(s1, s2, s3)\n    assert not check('abc', 'cde', '')\n    assert check('a', '', 'a')\n    assert check('', 'b', 'b')", "def test_isInterleave():\n\n    def check(s1, s2, s3):\n        return Solution().isInterleave(s1, s2, s3)\n    assert not check('abc', 'cde', 'adcbec')\n    assert check('', '', '')\n    assert check('a' * 1000, 'b' * 1000, 'ab' * 2000)", "def test_isInterleave():\n\n    def check(s1, s2, s3):\n        return Solution().isInterleave(s1, s2, s3)\n    assert not check('abc', 'cde', 'acebd')\n    assert check('', '', '')\n    assert not check('aaa', 'aab', 'abbca')", "def test_isInterleave():\n\n    def check(s1, s2, s3):\n        return Solution().isInterleave(s1, s2, s3)\n    assert not check('abc', 'cde', 'acebd')\n    assert check('', '', '')\n    assert not check('aaa', 'aab', 'abca')", "def test_isInterleave():\n\n    def check(s1, s2, s3):\n        return Solution().isInterleave(s1, s2, s3)\n    assert not check('aaa', 'aab', 'abca')\n    assert check('a' * 1000 + 'b', 'c' * 1000, 'abc' * 1001)", "def test_isInterleave():\n\n    def check(s1, s2, s3):\n        return Solution().isInterleave(s1, s2, s3)\n    assert not check('aaa', 'aab', '')\n    assert not check('', '', 'abc')\n    assert check('a' * 1000 + 'b', 'c' * 999, 'ab' * 1999)", "def test_isInterleave():\n\n    def check(s1, s2, s3):\n        return Solution().isInterleave(s1, s2, s3)\n    assert not check('', 'a' * 1000 + 'b', 'ab')\n    assert not check('aaa', '', 'aba')", "def test_isInterleave():\n\n    def check(s1, s2, s3):\n        return Solution().isInterleave(s1, s2, s3)\n    assert not check('a', 'b' * 999 + 'c', 'abc')\n    assert check('', '', '')\n    assert not check('aaa', 'aab', 'abca')", "def test_isInterleave():\n\n    def check(s1, s2, s3):\n        return Solution().isInterleave(s1, s2, s3)\n    assert not check('abc', 'cde', 'acebd')\n    assert not check('aaa', '', '')\n    assert check('a' * 1000 + 'b', 'c' * 999, 'ab' * 1999)", "def test_isInterleave():\n\n    def check(s1, s2, s3):\n        return Solution().isInterleave(s1, s2, s3)\n    assert not check('aaa', 'aab', '')\n    assert check('', '', '')\n    assert not check('abc', 'cde', 'acebd')", "def test_isInterleave():\n\n    def check(s1, s2, s3):\n        return Solution().isInterleave(s1, s2, s3)\n    assert not check('abc', 'cde', '')\n    assert check('', '', '')\n    assert check('a' * 1000 + 'b', 'c' * 999, 'ab' * 1999)"]}
{"task_num": 126, "task_title": "Word Ladder II", "func_name": "findLadders", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Set\n\nclass Solution:\n  def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n    from collections import deque\n    def connected(a: str, b: str) -> bool:\n      k = 0\n      for i in range(len(a)):\n        if a[i] != b[i]:\n          k += 1\n      return k == 1\n\n    if endWord not in wordList:\n      return []\n\n    visited = set([beginWord])\n\n    q = deque([beginWord])\n    nodes = []\n    find = False\n\n    while q and not find:\n      nodes.append(q.copy())\n      n = len(q)\n      for _ in range(n):\n        word = q.popleft()\n        for item in wordList:\n          if item in visited:\n            continue\n          if not connected(word, item):\n            continue\n          if item == endWord:\n            find = True\n            break\n          visited.add(item)\n          q.append(item)\n        if find:\n          break\n\n    if not find:\n      return []\n\n    ans = []\n\n    def backtracking(word, level: int, steps: List[str]):\n      if word == beginWord:\n        ans.append(steps[::-1])\n        return\n      if level < 0:\n        return\n      for item in nodes[level]:\n        if connected(item, word):\n          steps.append(item)\n          backtracking(item, level-1, steps)\n          steps.pop()\n\n    backtracking(endWord, len(nodes)-1, [endWord])\n    return ans\n", "tests": ["def test_findLadders(self):\n    solution = Solution()\n    wordList = ['hot', 'dot', 'dog', 'lot', 'log', 'cog']\n    self.assertEqual(len(solution.findLadders('hit', 'cog', wordList)), 6)", "def test_findLadders(self):\n    solution = Solution()\n    wordList = []\n    self.assertEqual(len(solution.findLadders('hit', 'cog', wordList)), 0)", "def test_findLadders(self):\n    solution = Solution()\n    wordList = ['hot', 'dot', 'dog']\n    self.assertEqual(len(solution.findLadders('hit', 'cog', wordList)), 0)", "def test_findLadders(self):\n    solution = Solution()\n    wordList = ['hot', 'dot', 'dog']\n    self.assertEqual(len(solution.findLadders('cog', 'cog', wordList)), 0)", "def test_findLadders(self):\n    solution = Solution()\n    wordList = ['hot', 'dot', 'dog', 'lot', 'log', 'cog'] * 10000\n    self.assertEqual(len(solution.findLadders('hit', 'cog', wordList)), 1)", "def test_findLadders(self):\n    solution = Solution()\n    wordList = ['hot', 'dot', 'dog']\n    self.assertEqual(len(solution.findLadders('hit', 'cog', wordList)), 0)", "def test_findLadders(self):\n    solution = Solution()\n    wordList = ['hot']\n    self.assertEqual(len(solution.findLadders('hit', 'cog', wordList)), 0)", "def test_findLadders(self):\n    solution = Solution()\n    wordList = ['hot', 'dot', 'dog']\n    self.assertEqual(len(solution.findLadders('hit', 'dot', wordList)), 0)", "def test_findLadders(self):\n    solution = Solution()\n    wordList = ['hot', 'dot', 'dog']\n    self.assertEqual(len(solution.findLadders('hit', 'hit', wordList)), 1)", "def test_findLadders(self):\n    solution = Solution()\n    wordList = ['hot', 'dot', 'dog']\n    self.assertEqual(len(solution.findLadders('hit', 'cog', wordList)), 1)", "def test_findLadders(self):\n    solution = Solution()\n    wordList = ['hot', 'dot', 'dog']\n    self.assertEqual(len(solution.findLadders('', 'cog', wordList)), 0)", "def test_findLadders(self):\n    solution = Solution()\n    wordList = ['hot', 'dot', 'cog']\n    self.assertEqual(len(solution.findLadders('hit', 'hot', wordList)), 1)", "def test_findLadders(self):\n    solution = Solution()\n    wordList = ['hot', 'dot', 'dog']\n    self.assertEqual(len(solution.findLadders('abcdefghijklmnopqrstuvwxyz', 'cog', wordList)), 0)", "def test_findLadders(self):\n    solution = Solution()\n    wordList = []\n    self.assertEqual(len(solution.findLadders('hit', 'cog', wordList)), 0)", "def test_findLadders(self):\n    solution = Solution()\n    wordList = ['hot', 'dot', 'dog']\n    with self.assertRaises(TypeError):\n        solution.findLadders('hit', None, wordList)", "def test_findLadders(self):\n    solution = Solution()\n    wordList = None\n    with self.assertRaises(TypeError):\n        solution.findLadders('hit', 'cog', wordList)", "def test_findLadders(self):\n    solution = Solution()\n    wordList = ['hot', 'dot', 'dog']\n    with self.assertRaises(TypeError):\n        solution.findLadders(None, 'cog', wordList)", "def test_findLadders(self):\n    solution = Solution()\n    wordList = ['hot', 'dot', 'dog']\n    with self.assertRaises(TypeError):\n        solution.findLadders(123, 'cog', wordList)", "def test_findLadders(self):\n    solution = Solution()\n    wordList = ['hot', 'dot', 'dog']\n    with self.assertRaises(TypeError):\n        solution.findLadders('hit', 123, wordList)", "def test_findLadders(self):\n    solution = Solution()\n    wordList = ['hot', 'dot', 'dog']\n    self.assertEqual(len(solution.findLadders('', '', wordList)), 0)"]}
{"task_num": 130, "task_title": "Surrounded Regions", "func_name": "solve", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def solve(self, board: List[List[str]]) -> None:\n    if not board:\n      return\n\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(board)\n    n = len(board[0])\n    q = collections.deque()\n\n    for i in range(m):\n      for j in range(n):\n        if i * j == 0 or i == m - 1 or j == n - 1:\n          if board[i][j] == 'O':\n            q.append((i, j))\n            board[i][j] = '*'\n\n    while q:\n      i, j = q.popleft()\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if board[x][y] != 'O':\n          continue\n        q.append((x, y))\n        board[x][y] = '*'\n\n    for row in board:\n      for i, c in enumerate(row):\n        if c == '*':\n          row[i] = 'O'\n        else:\n          row[i] = 'X'\n", "tests": ["def test_solve(self):\n    board = [['X', 'X', 'X', 'X'], ['X', 'O', 'O', 'X'], ['X', 'X', 'O', 'X'], ['X', 'O', 'X', 'X']]\n    solution = Solution()\n    solution.solve(board)", "def test_solve(self):\n    board = []\n    solution = Solution()\n    solution.solve(board)", "def test_solve(self):\n    board = [['O']]\n    solution = Solution()\n    solution.solve(board)", "def test_solve(self):\n    board = [['X', 'X', 'X'], ['X', 'O', 'X'], ['X', 'X', 'X']]\n    solution = Solution()\n    solution.solve(board)", "def test_solve(self):\n    board = [['X', 'X', 'X'], ['X', 'X', 'X'], ['X', 'X', 'X']]\n    solution = Solution()\n    solution.solve(board)", "def test_solve(self):\n    board = [['O' for _ in range(20)] for _ in range(20)]\n    solution = Solution()\n    solution.solve(board)", "def test_solve(self):\n    board = [['O', 'O', 'O'], ['X', 'O', 'X'], ['O', 'O', 'O']]\n    solution = Solution()\n    solution.solve(board)", "def test_solve(self):\n    board = [['X', 'X'], ['X', 'O']]\n    solution = Solution()\n    solution.solve(board)", "def test_solve(self):\n    board = [['O', 'X'], ['O', 'X']]\n    solution = Solution()\n    solution.solve(board)", "def test_solve(self):\n    board = [['O', 'O'], ['O', 'O']]\n    solution = Solution()\n    solution.solve(board)", "def test_solve(self):\n    board = [['O', 'O'], ['O', 'O']]\n    solution = Solution()\n    solution.solve(board)", "def test_solve(self):\n    board = [['X', 'O'], ['X', '', 'X']]\n    solution = Solution()\n    solution.solve(board)", "def test_solve(self):\n    board = [['X', 'O'], ['X', 'O']]\n    solution = Solution()\n    solution.solve(board)", "def test_solve(self):\n    board = [['O' for _ in range(50)] for _ in range(50)]\n    solution = Solution()\n    solution.solve(board)", "def test_solve(self):\n    board = [['X', 'O', 'X'], ['O', 'O', 'O'], ['X', 'O', 'X']]\n    solution = Solution()\n    solution.solve(board)", "def test_solve(self):\n    board = [['O', 'X', 'O'], ['O', 'O', 'O'], ['O', 'X', 'O']]\n    solution = Solution()\n    solution.solve(board)", "def test_solve(self):\n    board = [['X', 'O', 'X'], ['O', 'O', 'O'], ['O', 'X', 'O']]\n    solution = Solution()\n    solution.solve(board)", "def test_solve(self):\n    board = [['X', 'O', 'X'], ['X', 'O', 'X'], ['O', 'O', 'O']]\n    solution = Solution()\n    solution.solve(board)", "def test_solve(self):\n    board = [['O' for _ in range(20)] for _ in range(20)]\n    solution = Solution()\n    solution.solve(board)", "def test_solve(self):\n    board = [['X' for _ in range(20)] for _ in range(20)]\n    solution = Solution()\n    solution.solve(board)"]}
{"task_num": 132, "task_title": "Palindrome Partitioning II", "func_name": "minCut", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minCut(self, s: str) -> int:\n    n = len(s)\n    isPalindrome=[]\n    for _ in range(n):\n      isPalindrome.append([True] * n)\n    dp = [n] * n\n\n    for l in range(2, n + 1):\n      i = 0\n      for j in range(l - 1, n):\n        isPalindrome[i][j] = s[i] == s[j] and isPalindrome[i + 1][j - 1]\n        i += 1\n\n    for i in range(n):\n      if isPalindrome[0][i]:\n        dp[i] = 0\n        continue\n\n      for j in range(i):\n        if isPalindrome[j + 1][i]:\n          dp[i] = min(dp[i], dp[j] + 1)\n\n    return dp[-1]\n", "tests": ["def test_minCut():\n    solution = Solution()\n    assert solution.minCut('ab') == 1", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('aab') == 1", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('a') == 0", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('abba') == 2", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('abcdcba') == 4", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('racecar') == 0", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('abccba') == 0", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('aabbcc') == 2", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('aaaaaa') == 0", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('abccba') == 0", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('abcddcba') == 2", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('abcddcba') == 2", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('abcd') == 3", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('abbaaa') == 1", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('aabbccdd') == 4", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('abccbab') == 2", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('abccbaaa') == 2", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('abccbaaaab') == 3", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('babad') == 1", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('cbbd') == 2"]}
{"task_num": 218, "task_title": "The Skyline Problem", "func_name": "getSkyline", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:\n    n = len(buildings)\n    if n == 0:\n      return []\n    if n == 1:\n      left, right, height = buildings[0]\n      return [[left, height], [right, 0]]\n\n    left = self.getSkyline(buildings[:n // 2])\n    right = self.getSkyline(buildings[n // 2:])\n    return self._merge(left, right)\n\n  def _merge(self, left: List[List[int]], right: List[List[int]]) -> List[List[int]]:\n    ans = []\n    i = 0\n    j = 0\n    leftY = 0\n    rightY = 0\n\n    while i < len(left) and j < len(right):\n      if left[i][0] < right[j][0]:\n        leftY = left[i][1]\n        self._addPoint(ans, left[i][0], max(left[i][1], rightY))\n        i += 1\n      else:\n        rightY = right[j][1]\n        self._addPoint(ans, right[j][0], max(right[j][1], leftY))\n        j += 1\n\n    while i < len(left):\n      self._addPoint(ans, left[i][0], left[i][1])\n      i += 1\n\n    while j < len(right):\n      self._addPoint(ans, right[j][0], right[j][1])\n      j += 1\n\n    return ans\n\n  def _addPoint(self, ans: List[List[int]], x: int, y: int) -> None:\n    if ans and ans[-1][0] == x:\n      ans[-1][1] = y\n      return\n    if ans and ans[-1][1] == y:\n      return\n    ans.append([x, y])\n", "tests": ["def test_getSkyline():\n\n    def getSkyline(buildings):\n        n = len(buildings)\n        if n == 0:\n            return []\n        if n == 1:\n            (left, right, height) = buildings[0]\n            return [[left, height], [right, 0]]\n        left = getSkyline(buildings[:n // 2])\n        right = getSkyline(buildings[n // 2:])\n        return merge(left, right)\n\n    def merge(left: List[List[int]], right: List[List[int]]) -> List[List[int]]:\n        ans = []\n        i = 0\n        j = 0\n        leftY = 0\n        rightY = 0\n        while i < len(left) and j < len(right):\n            if left[i][0] < right[j][0]:\n                leftY = left[i][1]\n                addPoint(ans, left[i][0], max(left[i][1], rightY))\n                i += 1\n            else:\n                rightY = right[j][1]\n                addPoint(ans, right[j][0], max(right[j][1], leftY))\n                j += 1\n        while i < len(left):\n            addPoint(ans, left[i][0], left[i][1])\n            i += 1\n        while j < len(right):\n            addPoint(ans, right[j][0], right[j][1])\n            j += 1\n        return ans\n\n    def addPoint(ans: List[List[int]], x: int, y: int) -> None:\n        if ans and ans[-1][0] == x:\n            ans[-1][1] = y\n            return\n        if ans and ans[-1][1] == y:\n            return\n        ans.append([x, y])\n    solution = Solution()\n    print(getSkyline([[2, 9, 10], [3, 7, 15], [5, 12, 12]]))", "def test_getSkyline():\n    solution = Solution()\n    print(getSkyline([[2, 9, 10], [4, 5, 15], [8, 12, 12]]))", "def test_getSkyline():\n    solution = Solution()\n    print(getSkyline([[0, 2, 3], [2, 5, 3]]))", "def test_getSkyline():\n    solution = Solution()\n    print(getSkyline([[1, 4, 10], [2, 3, 9], [8, 12, 12]]))", "def test_getSkyline():\n    solution = Solution()\n    print(getSkyline([]))", "def test_getSkyline():\n    solution = Solution()\n    print(getSkyline([[0, 2, 3], [5, 8, 12]]))", "def test_getSkyline():\n    solution = Solution()\n    print(getSkyline([[0, 2, 3], [0, 5, 8]]))", "def test_getSkyline():\n    solution = Solution()\n    print(getSkyline([[1, 1, 1], [2, 2, 3]]))", "def test_getSkyline():\n    solution = Solution()\n    print(getSkyline([[1, 4, 10], [2, 3, 9]]))", "def test_getSkyline():\n    solution = Solution()\n    print(getSkyline([[1, 4, 10], [2, 5, 3], [6, 7, 9]]))", "def test_getSkyline():\n    solution = Solution()\n    print(getSkyline([[1, 4, 10], [2, 5, 3], [6, 7, 9], [8, 9, 12]]))", "def test_getSkyline():\n    solution = Solution()\n    print(getSkyline([[1, 4, 10], [2, 3, 9]]))\n    print(getSkyline([]))\n    print(getSkyline([[0, 2, 3], [5, 8, 12]]))", "def test_getSkyline():\n    solution = Solution()\n    print(getSkyline([[1, 4, 10], [2, 3, 9]]))\n    print(getSkyline([]))\n    print(getSkyline([[0, 2, 3], [5, 8, 12]]))\n    print(getSkyline([[1, 1, 1], [2, 2, 3]]))", "def test_getSkyline():\n    solution = Solution()\n    print(getSkyline([[1, 4, 10], [2, 3, 9]]))\n    print(getSkyline([]))\n    print(getSkyline([[0, 2, 3], [5, 8, 12]]))\n    print(getSkyline([[1, 1, 1], [2, 2, 3]]))\n    print(getSkyline([[2, 9, 10], [4, 5, 15], [8, 12, 12]]))", "def test_getSkyline():\n    solution = Solution()\n    print(getSkyline([[1, 4, 10], [2, 3, 9]]))\n    print(getSkyline([]))\n    print(getSkyline([[0, 2, 3], [5, 8, 12]]))\n    print(getSkyline([[1, 1, 1], [2, 2, 3]]))\n    print(getSkyline([[2, 9, 10], [4, 5, 15], [8, 12, 12]]))\n    print(getSkyline([[1, 4, 10], [2, 5, 3], [6, 7, 9], [8, 9, 12]]))", "def test_getSkyline():\n    solution = Solution()\n    print(getSkyline([[1, 4, 10], [2, 3, 9]]))\n    print(getSkyline([]))\n    print(getSkyline([[0, 2, 3], [5, 8, 12]]))\n    print(getSkyline([[1, 1, 1], [2, 2, 3]]))\n    print(getSkyline([[2, 9, 10], [4, 5, 15], [8, 12, 12]]))\n    print(getSkyline([[1, 4, 10], [2, 5, 3], [6, 7, 9], [8, 9, 12]]))\n    print(getSkyline([[0, 2, 3], [0, 5, 8]]))", "def test_getSkyline():\n    solution = Solution()\n    print(getSkyline([[1, 4, 10], [2, 3, 9]]))\n    print(getSkyline([]))\n    print(getSkyline([[0, 2, 3], [5, 8, 12]]))\n    print(getSkyline([[1, 1, 1], [2, 2, 3]]))\n    print(getSkyline([[2, 9, 10], [4, 5, 15], [8, 12, 12]]))\n    print(getSkyline([[1, 4, 10], [2, 5, 3], [6, 7, 9], [8, 9, 12]]))\n    print(getSkyline([[0, 2, 3], [0, 5, 8]]))\n    print(getSkyline([[1, 2, 3], [2, 3, 4]]))", "def test_getSkyline():\n    solution = Solution()\n    print(getSkyline([[1, 4, 10], [2, 3, 9]]))\n    print(getSkyline([]))\n    print(getSkyline([[0, 2, 3], [5, 8, 12]]))\n    print(getSkyline([[1, 1, 1], [2, 2, 3]]))\n    print(getSkyline([[2, 9, 10], [4, 5, 15], [8, 12, 12]]))\n    print(getSkyline([[1, 4, 10], [2, 5, 3], [6, 7, 9], [8, 9, 12]]))\n    print(getSkyline([[0, 2, 3], [0, 5, 8]]))\n    print(getSkyline([[1, 2, 3], [2, 3, 4]]))\n    print(getSkyline([[10, 20, 30], [15, 25, 35]]))", "def test_getSkyline():\n    solution = Solution()\n    print(getSkyline([[1, 4, 10], [2, 3, 9]]))\n    print(getSkyline([]))\n    print(getSkyline([[0, 2, 3], [5, 8, 12]]))\n    print(getSkyline([[1, 1, 1], [2, 2, 3]]))\n    print(getSkyline([[2, 9, 10], [4, 5, 15], [8, 12, 12]]))\n    print(getSkyline([[1, 4, 10], [2, 5, 3], [6, 7, 9], [8, 9, 12]]))\n    print(getSkyline([[0, 2, 3], [0, 5, 8]]))\n    print(getSkyline([[1, 2, 3], [2, 3, 4]]))\n    print(getSkyline([[10, 20, 30], [15, 25, 35]]))\n    print(getSkyline([[100000, 200000, 300000], [150000, 250000, 350000]]))", "def test_getSkyline():\n    solution = Solution()\n    print(getSkyline([[1, 4, 10], [2, 3, 9]]))\n    print(getSkyline([]))\n    print(getSkyline([[0, 2, 3], [5, 8, 12]]))\n    print(getSkyline([[1, 1, 1], [2, 2, 3]]))\n    print(getSkyline([[2, 9, 10], [4, 5, 15], [8, 12, 12]]))\n    print(getSkyline([[1, 4, 10], [2, 5, 3], [6, 7, 9], [8, 9, 12]]))\n    print(getSkyline([[0, 2, 3], [0, 5, 8]]))\n    print(getSkyline([[1, 2, 3], [2, 3, 4]]))\n    print(getSkyline([[10, 20, 30], [15, 25, 35]]))\n    print(getSkyline([[100000, 200000, 300000], [150000, 250000, 350000]]))\n    print(getSkyline([[0, 1, 1], [1, 2, 3]]))"]}
{"task_num": 227, "task_title": "Basic Calculator II", "func_name": "calculate", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def calculate(self, s: str) -> int:\n    ans = 0\n    prevNum = 0\n    currNum = 0\n    op = '+'\n\n    for i, c in enumerate(s):\n      if c.isdigit():\n        currNum = currNum * 10 + int(c)\n      if not c.isdigit() and c != ' ' or i == len(s) - 1:\n        if op == '+' or op == '-':\n          ans += prevNum\n          prevNum = currNum if op == '+' else -currNum\n        elif op == '*':\n          prevNum = prevNum * currNum\n        elif op == '/':\n          if prevNum < 0:\n            prevNum = math.ceil(prevNum / currNum)\n          else:\n            prevNum = prevNum // currNum\n        op = c\n        currNum = 0\n\n    return ans + prevNum\n", "tests": ["def test_calculate():\n    solution = Solution()\n    assert solution.calculate('3+2*2') == 7", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('3/2') == 1", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('-3+2*2') == 1", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('3*2+5') == 11", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('') == 0", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('123') == 123", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('3-2*2') == -1", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('2147483647+1') == 2147483648", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('3/0') == 2147483647", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('-3+2*2-1') == -4", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('123456+789012') == 91246815", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('0123') == 123", "def test_calculate_invalid_input():\n    solution = Solution()\n    try:\n        solution.calculate(\"abc\")", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('-3-2*2') == -7", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('3*(2+1)') == 9", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('3 + 2 * 2') == 7", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('2147483647/2') == 1073741823", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('2147483647-1') == 2147483646", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('-3/2') == -1", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('3*2+5.5') == 16"]}
{"task_num": 289, "task_title": "Game of Life", "func_name": "gameOfLife", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def gameOfLife(self, board: List[List[int]]) -> None:\n    m = len(board)\n    n = len(board[0])\n\n    for i in range(m):\n      for j in range(n):\n        ones = 0\n        for x in range(max(0, i - 1), min(m, i + 2)):\n          for y in range(max(0, j - 1), min(n, j + 2)):\n            ones += board[x][y] & 1\n\n        if board[i][j] == 1 and (ones == 3 or ones == 4):\n          board[i][j] |= 0b10\n\n        if board[i][j] == 0 and ones == 3:\n          board[i][j] |= 0b10\n\n    for i in range(m):\n      for j in range(n):\n        board[i][j] >>= 1\n", "tests": ["def test_gameOfLife(self):\n    board = [[0, 1, 0], [0, 0, 1], [1, 1, 1], [0, 0, 0]]\n    solution = Solution()\n    solution.gameOfLife(board)", "def test_gameOfLife(self):\n    board = [[1, 0, 1], [0, 1, 0], [0, 0, 0]]\n    solution = Solution()\n    solution.gameOfLife(board)", "def test_gameOfLife(self):\n    board = [[1, 0], [0, 1]]\n    solution = Solution()\n    solution.gameOfLife(board)", "def test_gameOfLife(self):\n    board = [[1] * 5 + [0] + [1] * 3]\n    solution = Solution()\n    solution.gameOfLife(board)", "def test_gameOfLife(self):\n    board = [[0] * 5 + [1] + [0] * 3]\n    solution = Solution()\n    solution.gameOfLife(board)", "def test_gameOfLife(self):\n    board = [[0] * 5]\n    solution = Solution()\n    solution.gameOfLife(board)", "def test_gameOfLife(self):\n    board = [[1] * 3 + [0] + [1] * 3]\n    solution = Solution()\n    solution.gameOfLife(board)", "def test_gameOfLife(self):\n    board = [[1] * 4]\n    solution = Solution()\n    solution.gameOfLife(board)", "def test_gameOfLife(self):\n    board = [[0, 1], [2, 3]]\n    solution = Solution()\n    with self.assertRaises(TypeError):\n        solution.gameOfLife(board)", "def test_gameOfLife(self):\n    board = [[0]]\n    solution = Solution()\n    with self.assertRaises(ValueError):\n        solution.gameOfLife(board)", "def test_gameOfLife(self):\n    board = []\n    solution = Solution()\n    with self.assertRaises(ValueError):\n        solution.gameOfLife(board)", "def test_gameOfLife(self):\n    board = [[1] * 1000 + [0] + [1] * 3]\n    solution = Solution()\n    with self.assertRaises(MemoryError):\n        solution.gameOfLife(board)", "def test_gameOfLife(self):\n    board = [[1] * 10000]\n    solution = Solution()\n    with self.assertRaises(MemoryError):\n        solution.gameOfLife(board)", "def test_gameOfLife(self):\n    board = [[1] * 50000 + [0] + [1] * 3]\n    solution = Solution()\n    with self.assertRaises(MemoryError):\n        solution.gameOfLife(board)", "def test_gameOfLife(self):\n    board = [[1] * 2 ** 16 + [0] + [1] * 3]\n    solution = Solution()\n    with self.assertRaises(MemoryError):\n        solution.gameOfLife(board)", "def test_gameOfLife(self):\n    board = [[1] * 1000000]\n    solution = Solution()\n    with self.assertRaises(MemoryError):\n        solution.gameOfLife(board)", "def test_gameOfLife(self):\n    board = [[1] * 10000000]\n    solution = Solution()\n    with self.assertRaises(MemoryError):\n        solution.gameOfLife(board)", "def test_gameOfLife(self):\n    board = [[1] * 20000000]\n    solution = Solution()\n    with self.assertRaises(MemoryError):\n        solution.gameOfLife(board)", "def test_gameOfLife(self):\n    board = [[1] * 30000000]\n    solution = Solution()\n    with self.assertRaises(MemoryError):\n        solution.gameOfLife(board)", "def test_gameOfLife(self):\n    board = [[1] * 2 ** 32]\n    solution = Solution()\n    with self.assertRaises(MemoryError):\n        solution.gameOfLife(board)"]}
{"task_num": 310, "task_title": "Minimum Height Trees", "func_name": "findMinHeightTrees", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\n    if n == 1 or not edges:\n      return [0]\n\n    ans = []\n    graph = collections.defaultdict(set)\n\n    for u, v in edges:\n      graph[u].add(v)\n      graph[v].add(u)\n\n    for label, children in graph.items():\n      if len(children) == 1:\n        ans.append(label)\n\n    while n > 2:\n      n -= len(ans)\n      nextLeaves = []\n      for leaf in ans:\n        u = next(iter(graph[leaf]))\n        graph[u].remove(leaf)\n        if len(graph[u]) == 1:\n          nextLeaves.append(u)\n      ans = nextLeaves\n\n    return ans\n", "tests": ["def test_findMinHeightTrees():\n    solution = Solution()\n    n = 4\n    edges = [[1, 0], [1, 2], [1, 3]]\n    expected = [1]\n    actual = solution.findMinHeightTrees(n, edges)\n    assert set(actual) == set(expected), f'Expected {expected} but got {actual}'", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 6\n    edges = [[3, 0], [3, 1], [3, 2], [0, 4], [4, 5]]\n    expected = [3]\n    actual = solution.findMinHeightTrees(n, edges)\n    assert set(actual) == set(expected), f'Expected {expected} but got {actual}'", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1], [1, 2]]\n    expected = [0, 1, 2]\n    actual = solution.findMinHeightTrees(n, edges)\n    assert set(actual) == set(expected), f'Expected {expected} but got {actual}'", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 1\n    edges = []\n    expected = [0]\n    actual = solution.findMinHeightTrees(n, edges)\n    assert set(actual) == set(expected), f'Expected {expected} but got {actual}'", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1], [0, 2], [3, 4]]\n    expected = [3, 4]\n    actual = solution.findMinHeightTrees(n, edges)\n    assert set(actual) == set(expected), f'Expected {expected} but got {actual}'", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 0\n    edges = []\n    expected = []\n    actual = solution.findMinHeightTrees(n, edges)\n    assert set(actual) == set(expected), f'Expected {expected} but got {actual}'", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1], [2, 3]]\n    expected = [0, 1]\n    actual = solution.findMinHeightTrees(n, edges)\n    assert set(actual) == set(expected), f'Expected {expected} but got {actual}'", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 7\n    edges = [[0, 1], [0, 2], [0, 3], [4, 5], [4, 6]]\n    expected = [0]\n    actual = solution.findMinHeightTrees(n, edges)\n    assert set(actual) == set(expected), f'Expected {expected} but got {actual}'", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 2\n    edges = [[0, 1]]\n    expected = [0, 1]\n    actual = solution.findMinHeightTrees(n, edges)\n    assert set(actual) == set(expected), f'Expected {expected} but got {actual}'", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1], [0, 2], [3, 4]]\n    expected = [0]\n    actual = solution.findMinHeightTrees(n, edges)\n    assert set(actual) == set(expected), f'Expected {expected} but got {actual}'", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 6\n    edges = [[0, 1], [0, 2], [3, 4], [3, 5]]\n    expected = [3]\n    actual = solution.findMinHeightTrees(n, edges)\n    assert set(actual) == set(expected), f'Expected {expected} but got {actual}'", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1], [1, 2]]\n    expected = [0]\n    actual = solution.findMinHeightTrees(n, edges)\n    assert set(actual) == set(expected), f'Expected {expected} but got {actual}'", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1], [2, 3]]\n    expected = [0]\n    actual = solution.findMinHeightTrees(n, edges)\n    assert set(actual) == set(expected), f'Expected {expected} but got {actual}'", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 7\n    edges = [[0, 1], [0, 2], [3, 4], [5, 6]]\n    expected = [0]\n    actual = solution.findMinHeightTrees(n, edges)\n    assert set(actual) == set(expected), f'Expected {expected} but got {actual}'", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 1\n    edges = []\n    expected = [0]\n    actual = solution.findMinHeightTrees(n, edges)\n    assert set(actual) == set(expected), f'Expected {expected} but got {actual}'", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 8\n    edges = [[0, 1], [0, 2], [3, 4], [5, 6], [7, 0]]\n    expected = [0]\n    actual = solution.findMinHeightTrees(n, edges)\n    assert set(actual) == set(expected), f'Expected {expected} but got {actual}'", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 9\n    edges = [[0, 1], [2, 3], [4, 5], [6, 7]]\n    expected = [4]\n    actual = solution.findMinHeightTrees(n, edges)\n    assert set(actual) == set(expected), f'Expected {expected} but got {actual}'", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 10\n    edges = [[0, 1], [2, 3], [4, 5], [6, 7]]\n    expected = [4]\n    actual = solution.findMinHeightTrees(n, edges)\n    assert set(actual) == set(expected), f'Expected {expected} but got {actual}'", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 10\n    edges = [[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]\n    expected = [0]\n    actual = solution.findMinHeightTrees(n, edges)\n    assert set(actual) == set(expected), f'Expected {expected} but got {actual}'", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 11\n    edges = [[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]\n    expected = [0]\n    actual = solution.findMinHeightTrees(n, edges)\n    assert set(actual) == set(expected), f'Expected {expected} but got {actual}'"]}
{"task_num": 327, "task_title": "Count of Range Sum", "func_name": "countRangeSum", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countRangeSum(self, nums: List[int], lower: int, upper: int) -> int:\n    n = len(nums)\n    self.ans = 0\n    prefix = [0] + list(itertools.accumulate(nums))\n\n    self._mergeSort(prefix, 0, n, lower, upper)\n    return self.ans\n\n  def _mergeSort(self, prefix: List[int], l: int, r: int, lower: int, upper: int) -> None:\n    if l >= r:\n      return\n\n    m = (l + r) // 2\n    self._mergeSort(prefix, l, m, lower, upper)\n    self._mergeSort(prefix, m + 1, r, lower, upper)\n    self._merge(prefix, l, m, r, lower, upper)\n\n  def _merge(self, prefix: List[int], l: int, m: int, r: int, lower: int, upper: int) -> None:\n    lo = m + 1\n    hi = m + 1\n\n    for i in range(l, m + 1):\n      while lo <= r and prefix[lo] - prefix[i] < lower:\n        lo += 1\n      while hi <= r and prefix[hi] - prefix[i] <= upper:\n        hi += 1\n      self.ans += hi - lo\n\n    sorted = [0] * (r - l + 1)\n    k = 0\n    i = l\n    j = m + 1\n\n    while i <= m and j <= r:\n      if prefix[i] < prefix[j]:\n        sorted[k] = prefix[i]\n        k += 1\n        i += 1\n      else:\n        sorted[k] = prefix[j]\n        k += 1\n        j += 1\n\n    while i <= m:\n      sorted[k] = prefix[i]\n      k += 1\n      i += 1\n\n    while j <= r:\n      sorted[k] = prefix[j]\n      k += 1\n      j += 1\n\n    prefix[l:l + len(sorted)] = sorted\n", "tests": ["def test_countRangeSum(self):\n    solution = Solution()\n    nums = [5, 1, 23, 12]\n    lower = -10\n    upper = 20\n    self.assertEqual(solution.countRangeSum(nums, lower, upper), 8)", "def test_countRangeSum():\n    solution = Solution()\n    nums = [-10, 20, -30, 40]\n    lower = -1000\n    upper = 1000\n    self.assertEqual(solution.countRangeSum(nums, lower, upper), 1)", "def test_countRangeSum():\n    solution = Solution()\n    nums = []\n    lower = -10\n    upper = 20\n    self.assertEqual(solution.countRangeSum(nums, lower, upper), 0)", "def test_countRangeSum():\n    solution = Solution()\n    nums = [5]\n    lower = -10\n    upper = 20\n    self.assertEqual(solution.countRangeSum(nums, lower, upper), 1)", "def test_countRangeSum():\n    solution = Solution()\n    nums = [10 ** 6] * 1000\n    lower = -2 * 10 ** 9\n    upper = 2 * 10 ** 9\n    self.assertEqual(solution.countRangeSum(nums, lower, upper), len(nums))", "def test_countRangeSum():\n    solution = Solution()\n    nums = [10 ** 6] * 1000\n    lower = -2 * 10 ** 9 - 1\n    upper = 2 * 10 ** 9\n    self.assertEqual(solution.countRangeSum(nums, lower, upper), len(nums))", "def test_countRangeSum():\n    solution = Solution()\n    nums = [10 ** 6] * 1000\n    lower = -2 * 10 ** 9\n    upper = -2 * 10 ** 9\n    self.assertEqual(solution.countRangeSum(nums, lower, upper), 0)", "def test_countRangeSum():\n    solution = Solution()\n    nums = [1]\n    lower = 0\n    upper = 0\n    self.assertEqual(solution.countRangeSum(nums, lower, upper), 1)", "def test_countRangeSum():\n    solution = Solution()\n    nums = [10 ** 6] * 1000\n    lower = None\n    upper = 2 * 10 ** 9\n    with self.assertRaises(ValueError):\n        solution.countRangeSum(nums, lower, upper)", "def test_countRangeSum():\n    solution = Solution()\n    nums = [10 ** 6] * 1000\n    lower = -2 * 10 ** 9\n    upper = 'a'\n    with self.assertRaises(TypeError):\n        solution.countRangeSum(nums, lower, upper)", "def test_countRangeSum():\n    solution = Solution()\n    nums = [10 ** 6] * 1000\n    lower = -float('inf')\n    upper = 2 * 10 ** 9\n    with self.assertRaises(ValueError):\n        solution.countRangeSum(nums, lower, upper)", "def test_countRangeSum():\n    solution = Solution()\n    nums = [10 ** 6] * 1000\n    lower = -2 * 10 ** 9\n    upper = float('inf')\n    with self.assertRaises(ValueError):\n        solution.countRangeSum(nums, lower, upper)", "def test_countRangeSum():\n    solution = Solution()\n    nums = [1, 2, 3, 4]\n    lower = -10\n    upper = 20\n    self.assertEqual(solution.countRangeSum(nums, lower, upper), 12)", "def test_countRangeSum():\n    solution = Solution()\n    nums = [4, 3, 2, 1]\n    lower = -10\n    upper = 20\n    self.assertEqual(solution.countRangeSum(nums, lower, upper), 12)", "def test_countRangeSum():\n    solution = Solution()\n    nums = [1, 1, 2, 2]\n    lower = -10\n    upper = 20\n    self.assertEqual(solution.countRangeSum(nums, lower, upper), 16)", "def test_countRangeSum():\n    solution = Solution()\n    nums = [-1, -2, 3, 4]\n    lower = -10\n    upper = 20\n    self.assertEqual(solution.countRangeSum(nums, lower, upper), 7)", "def test_countRangeSum():\n    solution = Solution()\n    nums = [10 ** 6] * 1000\n    lower = -2 * 10 ** 9\n    upper = 2 * 10 ** 18\n    self.assertEqual(solution.countRangeSum(nums, lower, upper), len(nums))", "def test_countRangeSum():\n    solution = Solution()\n    nums = [1.5, 2.3, 3.4]\n    lower = -10.0\n    upper = 20.0\n    self.assertEqual(solution.countRangeSum(nums, lower, upper), 12)", "def test_countRangeSum():\n    solution = Solution()\n    nums = [-1, 0, -2, 3]\n    lower = -10\n    upper = 20\n    self.assertEqual(solution.countRangeSum(nums, lower, upper), 7)", "def test_countRangeSum():\n    solution = Solution()\n    nums = [1, 2, 3, 4]\n    lower = -10\n    upper = 20\n    self.assertEqual(solution.countRangeSum(nums, lower, upper), 12)"]}
{"task_num": 335, "task_title": "Self Crossing", "func_name": "isSelfCrossing", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isSelfCrossing(self, x: List[int]) -> bool:\n    if len(x) <= 3:\n      return False\n\n    for i in range(3, len(x)):\n      if x[i - 2] <= x[i] and x[i - 1] <= x[i - 3]:\n        return True\n      if i >= 4 and x[i - 1] == x[i - 3] and x[i - 2] <= x[i] + x[i - 4]:\n        return True\n      if i >= 5 and x[i - 4] <= x[i - 2] and x[i - 2] <= x[i] + x[i - 4] and x[i - 1] <= x[i - 3] and x[i - 3] <= x[i - 1] + x[i - 5]:\n        return True\n\n    return False\n", "tests": ["def test_isSelfCrossing():\n    solution = Solution()\n    x = [1, 2, 3, 4]\n    assert solution.isSelfCrossing(x) == True", "def test_isSelfCrossing():\n    solution = Solution()\n    x = [1, 1, 2]\n    assert solution.isSelfCrossing(x) == False", "def test_isSelfCrossing():\n    solution = Solution()\n    x = [1, 2, 1, 2]\n    assert solution.isSelfCrossing(x) == True", "def test_isSelfCrossing():\n    solution = Solution()\n    x = [3, 1, 5, 4]\n    assert solution.isSelfCrossing(x) == True", "def test_isSelfCrossing():\n    solution = Solution()\n    x = [1, 3, 4, 2, 1, 2]\n    assert solution.isSelfCrossing(x) == False", "def test_isSelfCrossing():\n    solution = Solution()\n    x = [1, 2, 3, 4, 5]\n    assert not solution.isSelfCrossing(x)", "def test_isSelfCrossing():\n    solution = Solution()\n    x = [2, 3, 5]\n    assert not solution.isSelfCrossing(x)", "def test_isSelfCrossing():\n    solution = Solution()\n    x = [1, 3, 2]\n    assert not solution.isSelfCrossing(x)", "def test_isSelfCrossing():\n    solution = Solution()\n    x = [1, 2, 3, 4, 5, 6]\n    assert not solution.isSelfCrossing(x)", "def test_isSelfCrossing():\n    solution = Solution()\n    x = [1, 1, 2, 3]\n    assert not solution.isSelfCrossing(x)", "def test_isSelfCrossing():\n    solution = Solution()\n    x = [1]\n    assert not solution.isSelfCrossing(x)", "def test_isSelfCrossing():\n    solution = Solution()\n    x = [2]\n    assert not solution.isSelfCrossing(x)", "def test_isSelfCrossing():\n    solution = Solution()\n    x = [1]\n    assert not solution.isSelfCrossing(x)", "def test_isSelfCrossing():\n    solution = Solution()\n    x = [1, 2, 3]\n    assert not solution.isSelfCrossing(x)", "def test_isSelfCrossing():\n    solution = Solution()\n    x = [1, 3]\n    assert not solution.isSelfCrossing(x)", "def test_isSelfCrossing():\n    solution = Solution()\n    x = [1, 2]\n    assert not solution.isSelfCrossing(x)", "def test_isSelfCrossing():\n    solution = Solution()\n    x = [1, 4, 3]\n    assert not solution.isSelfCrossing(x)", "def test_isSelfCrossing():\n    solution = Solution()\n    x = [1, 4, 2, 3]\n    assert solution.isSelfCrossing(x)", "def test_isSelfCrossing():\n    solution = Solution()\n    x = [1, 4, 2, 3]\n    assert not solution.isSelfCrossing(x)", "def test_isSelfCrossing():\n    solution = Solution()\n    x = [1, 3, 4, 2]\n    assert not solution.isSelfCrossing(x)"]}
{"task_num": 336, "task_title": "Palindrome Pairs", "func_name": "palindromePairs", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def palindromePairs(self, words: List[str]) -> List[List[int]]:\n    ans = []\n    dict = {word[::-1]: i for i, word in enumerate(words)}\n\n    for i, word in enumerate(words):\n      if \"\" in dict and dict[\"\"] != i and word == word[::-1]:\n        ans.append([i, dict[\"\"]])\n\n      for j in range(1, len(word) + 1):\n        l = word[:j]\n        r = word[j:]\n        if l in dict and dict[l] != i and r == r[::-1]:\n          ans.append([i, dict[l]])\n        if r in dict and dict[r] != i and l == l[::-1]:\n          ans.append([dict[r], i])\n\n    return ans\n", "tests": ["def test_palindromePairs():\n    solution = Solution()\n\n    def helper():\n        assert solution.palindromePairs(['abcd', 'dcba', 'ac']) == [[0, 1], [0, 2]]", "def test_palindromePairs():\n    solution = Solution()\n\n    def helper():\n        assert solution.palindromePairs(['a', 'b']) == []", "def test_palindromePairs():\n    solution = Solution()\n\n    def helper():\n        assert solution.palindromePairs(['madam']) == []", "def test_palindromePairs():\n    solution = Solution()\n\n    def helper():\n        assert solution.palindromePairs(['ab', 'ba']) == [[0, 1], [1, 0]]", "def test_palindromePairs():\n    solution = Solution()\n\n    def helper():\n        assert solution.palindromePairs(['racingcar', 'racecar']) == [[0, 1]]", "def test_palindromePairs():\n    solution = Solution()\n\n    def helper():\n        assert solution.palindromePairs(['abc', 'cba']) == [[0, 1]]", "def test_palindromePairs():\n    solution = Solution()\n\n    def helper():\n        assert solution.palindromePairs(['ab', 'baa']) == [[0, 1], [1, 0]]", "def test_palindromePairs():\n    solution = Solution()\n\n    def helper():\n        assert solution.palindromePairs(['a', 'a']) == [[0, 1], [1, 0]]", "def test_palindromePairs():\n    solution = Solution()\n\n    def helper():\n        assert solution.palindromePairs([''])[0] == [0, 1]", "def test_palindromePairs():\n    solution = Solution()\n\n    def helper():\n        assert solution.palindromePairs(['abcd', 'dcba']) == [[0, 1]]", "def test_palindromePairs():\n    solution = Solution()\n\n    def helper():\n        assert solution.palindromePairs(['racecar', 'racing']) == [[0, 1]]", "def test_palindromePairs():\n    solution = Solution()\n\n    def helper():\n        assert solution.palindromePairs(['abba', 'aba']) == [[0, 1], [1, 0]]", "def test_palindromePairs():\n    solution = Solution()\n\n    def helper():\n        assert solution.palindromePairs(['madam', 'dad']) == [[0, 1], [1, 0]]", "def test_palindromePairs():\n    solution = Solution()\n\n    def helper():\n        assert solution.palindromePairs(['hello', 'hhlol']) == [[0, 1]]", "def test_palindromePairs():\n    solution = Solution()\n\n    def helper():\n        assert solution.palindromePairs(['r', 'r']) == [[0, 1], [1, 0]]", "def test_palindromePairs():\n    solution = Solution()\n\n    def helper():\n        assert solution.palindromePairs(['ab', 'baa']) == [[0, 1]]", "def test_palindromePairs():\n    solution = Solution()\n\n    def helper():\n        assert solution.palindromePairs(['abc', 'bcaa']) == [[0, 1]]", "def test_palindromePairs():\n    solution = Solution()\n\n    def helper():\n        assert solution.palindromePairs(['aba', 'bba']) == [[0, 1], [1, 0]]", "def test_palindromePairs():\n    solution = Solution()\n\n    def helper():\n        assert solution.palindromePairs(['madam', 'dad', 'mom']) == [[0, 1], [1, 2]]", "def test_palindromePairs():\n    solution = Solution()\n\n    def helper():\n        assert solution.palindromePairs(['racecar', 'racingcar', 'madam']) == [[0, 1], [1, 2]]"]}
{"task_num": 391, "task_title": "Perfect Rectangle", "func_name": "isRectangleCover", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Set\n\nclass Solution:\n  def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\n    area = 0\n    x1 = math.inf\n    y1 = math.inf\n    x2 = -math.inf\n    y2 = -math.inf\n    corners: Set[Tuple[int, int]] = set()\n\n    for x, y, a, b in rectangles:\n      area += (a - x) * (b - y)\n      x1 = min(x1, x)\n      y1 = min(y1, y)\n      x2 = max(x2, a)\n      y2 = max(y2, b)\n\n      for point in [(x, y), (x, b), (a, y), (a, b)]:\n        if point in corners:\n          corners.remove(point)\n        else:\n          corners.add(point)\n\n    if len(corners) != 4:\n      return False\n    if (x1, y1) not in corners or (x1, y2) not in corners or (x2, y1) not in corners or (x2, y2) not in corners:\n      return False\n    return area == (x2 - x1) * (y2 - y1)\n", "tests": ["def test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[0, 1, 1, 3], [1, 3, 2, 4], [1, 1, 2, 2], [1, 2, 2, 3]]\n    assert solution.isRectangleCover(rectangles)", "def test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[0, 0, 2, 2], [1, 1, 3, 3]]\n    assert not solution.isRectangleCover(rectangles)", "def test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[0, 1, 3, 2]]\n    assert not solution.isRectangleCover(rectangles)", "def test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[0, 0, 1, 1], [0, 0, 2, 2]]\n    assert not solution.isRectangleCover(rectangles)", "def test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[-1, -2, 4, 5], [3, 4, 7, 8]]\n    assert not solution.isRectangleCover(rectangles)", "def test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[-1, -1, 4, 5], [3, 3, 7, 8]]\n    assert not solution.isRectangleCover(rectangles)", "def test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[0, 1, 2, 4], [0, 3, 1, 4]]\n    assert not solution.isRectangleCover(rectangles)", "def test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[0, 0, 4, 3], [1, 2, 6, 5]]\n    assert not solution.isRectangleCover(rectangles)", "def test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[0, 0, 4, 3], [2, 1, 6, 5]]\n    assert not solution.isRectangleCover(rectangles)", "def test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[0, 0, 2, 3], [1, 1, 4, 5]]\n    assert not solution.isRectangleCover(rectangles)", "def test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[0, 0, 1, 1], [2, 2, 3, 3]]\n    assert not solution.isRectangleCover(rectangles)", "def test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[-1, -2, 5, 6], [3, 4, 7, 8]]\n    assert solution.isRectangleCover(rectangles)", "def test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[0, 2, 3, 4], [1, 3, 5, 6]]\n    assert not solution.isRectangleCover(rectangles)", "def test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[0, 1, 4, 3], [2, 3, 6, 5]]\n    assert not solution.isRectangleCover(rectangles)", "def test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[1, 2, 3, 4], [2, 3, 5, 6]]\n    assert not solution.isRectangleCover(rectangles)", "def test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[1, 0, 3, 2], [0, 2, 4, 3]]\n    assert not solution.isRectangleCover(rectangles)", "def test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[1, 0, 3, 2], [0, 1, 4, 3]]\n    assert not solution.isRectangleCover(rectangles)", "def test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[-1, -1, 4, 5], [3, 3, 7, 8], [-2, 0, 6, 3]]\n    assert not solution.isRectangleCover(rectangles)", "def test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[0, 1, 2, 3], [4, 5, 6, 7]]\n    assert not solution.isRectangleCover(rectangles)", "def test_isRectangleCover():\n    solution = Solution()\n    rectangles = [[0, 1, 5, 6], [2, 3, 7, 8]]\n    assert not solution.isRectangleCover(rectangles)"]}
{"task_num": 402, "task_title": "Remove K Digits", "func_name": "removeKdigits", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def removeKdigits(self, num: str, k: int) -> str:\n    if len(num) == k:\n      return '0'\n\n    ans = []\n    stack = []\n\n    for i, digit in enumerate(num):\n      while k > 0 and stack and stack[-1] > digit:\n        stack.pop()\n        k -= 1\n      stack.append(digit)\n\n    for _ in range(k):\n      stack.pop()\n\n    for c in stack:\n      if c == '0' and not ans:\n        continue\n      ans.append(c)\n\n    return ''.join(ans) if ans else '0'\n", "tests": ["def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits('1432219', 3) == '1219'", "def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits('10', 2) == '0'", "def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits('0', 1) == '0'", "def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits('987654321', 8) == '0'", "def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits('123456789', 1) == '12'", "def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits('1999999999', 7) == '19'", "def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits('999', 2) == '9'", "def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits('10000', 4) == '0'", "def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits('123456789012345', 15) == '0'", "def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits('99999', 6) == '0'", "def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits('100', 1) == '10'", "def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits('121', 1) == '12'", "def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits('123456789012345', 1) == '12'", "def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits('987654321', 1) == '9'", "def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits('1234', 2) == '12'", "def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits('1123', 2) == '12'", "def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits('123456789', 6) == '12'", "def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits('11111', 1) == '1111'", "def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits('9', 2) == '0'", "def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits('9999', 4) == '0'"]}
{"task_num": 407, "task_title": "Trapping Rain Water II", "func_name": "trapRainWater", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def trapRainWater(self, heightMap: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(heightMap)\n    n = len(heightMap[0])\n    ans = 0\n    minHeap = []\n    seen = set()\n\n    for i in range(m):\n      heapq.heappush(minHeap, (heightMap[i][0], i, 0))\n      heapq.heappush(minHeap, (heightMap[i][n - 1], i, n - 1))\n      seen.add((i, 0))\n      seen.add((i, n - 1))\n\n    for j in range(1, n - 1):\n      heapq.heappush(minHeap, (heightMap[0][j], 0, j))\n      heapq.heappush(minHeap, (heightMap[m - 1][j], m - 1, j))\n      seen.add((0, j))\n      seen.add((m - 1, j))\n\n    while minHeap:\n      h, i, j = heapq.heappop(minHeap)\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if (x, y) in seen:\n          continue\n        if heightMap[x][y] < h:\n          ans += h - heightMap[x][y]\n          heapq.heappush(minHeap, (h, x, y))\n        else:\n          heapq.heappush(minHeap, (heightMap[x][y], x, y))\n        seen.add((x, y))\n\n    return ans\n", "tests": ["def test_trapRainWater():\n\n    def check_result(heightMap, expected):\n        solution = Solution()\n        result = solution.trapRainWater(heightMap)", "def test_trapRainWater():\n\n    def check_result(heightMap, expected):\n        solution = Solution()\n        result = solution.trapRainWater(heightMap)", "def test_trapRainWater():\n\n    def check_result(heightMap, expected):\n        solution = Solution()\n        result = solution.trapRainWater(heightMap)", "def test_trapRainWater():\n\n    def check_result(heightMap, expected):\n        solution = Solution()\n        result = solution.trapRainWater(heightMap)", "def test_trapRainWater():\n\n    def check_result(heightMap, expected):\n        solution = Solution()\n        result = solution.trapRainWater(heightMap)", "def test_trapRainWater():\n\n    def check_result(heightMap, expected):\n        solution = Solution()\n        result = solution.trapRainWater(heightMap)", "def test_trapRainWater():\n\n    def check_result(heightMap, expected):\n        solution = Solution()\n        result = solution.trapRainWater(heightMap)", "def test_trapRainWater():\n\n    def check_result(heightMap, expected):\n        solution = Solution()\n        result = solution.trapRainWater(heightMap)", "def test_trapRainWater():\n\n    def check_result(heightMap, expected):\n        solution = Solution()\n        result = solution.trapRainWater(heightMap)", "def test_trapRainWater():\n\n    def check_result(heightMap, expected):\n        solution = Solution()\n        result = solution.trapRainWater(heightMap)", "def test_trapRainWater():\n\n    def check_result(heightMap, expected):\n        solution = Solution()\n        result = solution.trapRainWater(heightMap)", "def test_trapRainWater():\n\n    def check_result(heightMap, expected):\n        solution = Solution()\n        result = solution.trapRainWater(heightMap)", "def test_trapRainWater():\n\n    def check_result(heightMap, expected):\n        solution = Solution()\n        result = solution.trapRainWater(heightMap)", "def test_trapRainWater():\n\n    def check_result(heightMap, expected):\n        solution = Solution()\n        result = solution.trapRainWater(heightMap)", "def test_trapRainWater():\n\n    def check_result(heightMap, expected):\n        solution = Solution()\n        result = solution.trapRainWater(heightMap)", "def test_trapRainWater():\n\n    def check_result(heightMap, expected):\n        solution = Solution()\n        result = solution.trapRainWater(heightMap)", "def test_trapRainWater():\n\n    def check_result(heightMap, expected):\n        solution = Solution()\n        result = solution.trapRainWater(heightMap)", "def test_trapRainWater():\n\n    def check_result(heightMap, expected):\n        solution = Solution()\n        result = solution.trapRainWater(heightMap)", "def test_trapRainWater():\n\n    def check_result(heightMap, expected):\n        solution = Solution()\n        result = solution.trapRainWater(heightMap)", "def test_trapRainWater():\n\n    def check_result(heightMap, expected):\n        solution = Solution()\n        result = solution.trapRainWater(heightMap)"]}
{"task_num": 417, "task_title": "Pacific Atlantic Water Flow", "func_name": "pacificAtlantic", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(heights)\n    n = len(heights[0])\n    qP = collections.deque()\n    qA = collections.deque()\n    seenP = [[False] * n for _ in range(m)]\n    seenA = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n      qP.append((i, 0))\n      qA.append((i, n - 1))\n      seenP[i][0] = True\n      seenA[i][n - 1] = True\n\n    for j in range(n):\n      qP.append((0, j))\n      qA.append((m - 1, j))\n      seenP[0][j] = True\n      seenA[m - 1][j] = True\n\n    def bfs(q: collections.deque, seen: List[List[bool]]):\n      while q:\n        i, j = q.popleft()\n        h = heights[i][j]\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if seen[x][y] or heights[x][y] < h:\n            continue\n          q.append((x, y))\n          seen[x][y] = True\n\n    bfs(qP, seenP)\n    bfs(qA, seenA)\n\n    res=[]\n    for i in range(m):\n      for j in range(n):\n        if seenP[i][j] and seenA[i][j]:\n          res.append([i, j])\n    return res\n", "tests": ["def test_pacificAtlantic():\n\n    class Solution:\n\n        def pacificAtlantic(self, heights):\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            m = len(heights)\n            n = len(heights[0])\n            qP = collections.deque()\n            qA = collections.deque()\n            seenP = [[False] * n for _ in range(m)]\n            seenA = [[False] * n for _ in range(m)]\n            for i in range(m):\n                qP.append((i, 0))\n                qA.append((i, n - 1))\n                seenP[i][0] = True\n                seenA[i][n - 1] = True\n            for j in range(n):\n                qP.append((0, j))\n                qA.append((m - 1, j))\n                seenP[0][j] = True\n                seenA[m - 1][j] = True\n\n            def bfs(q: collections.deque, seen: List[List[bool]]):\n                while q:\n                    (i, j) = q.popleft()\n                    h = heights[i][j]\n                    for (dx, dy) in dirs:\n                        x = i + dx\n                        y = j + dy\n                        if x < 0 or x == m or y < 0 or (y == n):\n                            continue\n                        if seen[x][y] or heights[x][y] < h:\n                            continue\n                        q.append((x, y))\n                        seen[x][y] = True\n            bfs(qP, seenP)\n            bfs(qA, seenA)\n            res = []\n            for i in range(m):\n                for j in range(n):\n                    if seenP[i][j] and seenA[i][j]:\n                        res.append([i, j])\n            return res\n    solution = Solution()\n    print(solution.pacificAtlantic([[1, 2, 2, 3, 5], [3, 2, 3, 4, 4], [2, 4, 5, 3, 1], [6, 7, 1, 4, 5], [5, 1, 1, 2, 4]]))", "def test_pacificAtlantic():\n\n    class Solution:\n\n        def pacificAtlantic(self, heights):\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            m = len(heights)\n            n = len(heights[0])\n            qP = collections.deque()\n            qA = collections.deque()\n            seenP = [[False] * n for _ in range(m)]\n            seenA = [[False] * n for _ in range(m)]\n            for i in range(m):\n                qP.append((i, 0))\n                qA.append((i, n - 1))\n                seenP[i][0] = True\n                seenA[i][n - 1] = True\n            for j in range(n):\n                qP.append((0, j))\n                qA.append((m - 1, j))\n                seenP[0][j] = True\n                seenA[m - 1][j] = True\n\n            def bfs(q: collections.deque, seen: List[List[bool]]):\n                while q:\n                    (i, j) = q.popleft()\n                    h = heights[i][j]\n                    for (dx, dy) in dirs:\n                        x = i + dx\n                        y = j + dy\n                        if x < 0 or x == m or y < 0 or (y == n):\n                            continue\n                        if seen[x][y] or heights[x][y] < h:\n                            continue\n                        q.append((x, y))\n                        seen[x][y] = True\n            bfs(qP, seenP)\n            bfs(qA, seenA)\n            res = []\n            for i in range(m):\n                for j in range(n):\n                    if seenP[i][j] and seenA[i][j]:\n                        res.append([i, j])\n            return res\n    solution = Solution()\n    print(solution.pacificAtlantic([[1, 1, 1], [1, 0, 1], [1, 0, 1]]))", "def test_pacificAtlantic():\n\n    class Solution:\n\n        def pacificAtlantic(self, heights):\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            m = len(heights)\n            n = len(heights[0])\n            qP = collections.deque()\n            qA = collections.deque()\n            seenP = [[False] * n for _ in range(m)]\n            seenA = [[False] * n for _ in range(m)]\n            for i in range(m):\n                qP.append((i, 0))\n                seenP[i][0] = True\n            for j in range(n):\n                qA.append((m - 1, j))\n                seenA[m - 1][j] = True\n\n            def bfs(q: collections.deque, seen: List[List[bool]]):\n                while q:\n                    (i, j) = q.popleft()\n                    h = heights[i][j]\n                    for (dx, dy) in dirs:\n                        x = i + dx\n                        y = j + dy\n                        if x < 0 or x == m or y < 0 or (y == n):\n                            continue\n                        if seen[x][y] or heights[x][y] < h:\n                            continue\n                        q.append((x, y))\n                        seen[x][y] = True\n            bfs(qP, seenP)\n            bfs(qA, seenA)\n            res = []\n            for i in range(m):\n                for j in range(n):\n                    if seenP[i][j] and seenA[i][j]:\n                        res.append([i, j])\n            return res\n    solution = Solution()\n    print(solution.pacificAtlantic([[1, 2], [3, 4]]))", "def test_pacificAtlantic():\n\n    class Solution:\n\n        def pacificAtlantic(self, heights):\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            m = len(heights)\n            n = len(heights[0])\n            qP = collections.deque()\n            qA = collections.deque()\n            seenP = [[False] * n for _ in range(m)]\n            seenA = [[False] * n for _ in range(m)]\n            for i in range(m):\n                qP.append((i, 0))\n                qA.append((i, n - 1))\n            for j in range(n):\n                seenP[0][j] = True\n                seenA[m - 1][j] = True\n\n            def bfs(q: collections.deque, seen: List[List[bool]]):\n                while q:\n                    (i, j) = q.popleft()\n                    h = heights[i][j]\n                    for (dx, dy) in dirs:\n                        x = i + dx\n                        y = j + dy\n                        if x < 0 or x == m or y < 0 or (y == n):\n                            continue\n                        if seen[x][y] or heights[x][y] >= h:\n                            continue\n                        q.append((x, y))\n                        seen[x][y] = True\n            bfs(qP, seenP)\n            bfs(qA, seenA)\n            res = []\n            for i in range(m):\n                for j in range(n):\n                    if seenP[i][j] and seenA[i][j]:\n                        res.append([i, j])\n            return res\n    solution = Solution()\n    print(solution.pacificAtlantic([[2, 1], [1, 2]]))", "def test_pacificAtlantic():\n\n    class Solution:\n\n        def pacificAtlantic(self, heights):\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            m = len(heights)\n            n = len(heights[0])\n            qP = collections.deque()\n            qA = collections.deque()\n            seenP = [[False] * n for _ in range(m)]\n            seenA = [[False] * n for _ in range(m)]\n            for i in range(1, m - 1):\n                qP.append((i, 0))\n                qA.append((i, n - 1))\n            for j in range(n):\n                seenP[0][j] = True\n                seenA[m - 1][j] = True\n\n            def bfs(q: collections.deque, seen: List[List[bool]]):\n                while q:\n                    (i, j) = q.popleft()\n                    h = heights[i][j]\n                    for (dx, dy) in dirs:\n                        x = i + dx\n                        y = j + dy\n                        if x < 0 or x == m or y < 0 or (y == n):\n                            continue\n                        if seen[x][y] or heights[x][y] < h:\n                            continue\n                        q.append((x, y))\n                        seen[x][y] = True\n            bfs(qP, seenP)\n            bfs(qA, seenA)\n            res = []\n            for i in range(m):\n                for j in range(n):\n                    if seenP[i][j] and seenA[i][j]:\n                        res.append([i, j])\n            return res\n    solution = Solution()\n    print(solution.pacificAtlantic([[1, 2, 2, 3, 5], [3, 2, 3, 4, 4], [2, 4, 5, 3, 1], [6, 7, 1, 4, 5], [5, 1, 1, 2, 4]]))", "def test_pacificAtlantic():\n\n    class Solution:\n\n        def pacificAtlantic(self, heights):\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            m = len(heights)\n            n = len(heights[0])\n            qP = collections.deque()\n            qA = collections.deque()\n            seenP = [[False] * n for _ in range(m)]\n            seenA = [[False] * n for _ in range(m)]\n            for i in range(1, m - 1):\n                qP.append((i, 0))\n                qA.append((i, n - 1))\n            for j in range(n - 1):\n                seenP[0][j] = True\n                seenA[m - 1][j] = True\n\n            def bfs(q: collections.deque, seen: List[List[bool]]):\n                while q:\n                    (i, j) = q.popleft()\n                    h = heights[i][j]\n                    for (dx, dy) in dirs:\n                        x = i + dx\n                        y = j + dy\n                        if x < 0 or x == m or y < 0 or (y == n):\n                            continue\n                        if seen[x][y] or heights[x][y] >= h:\n                            continue\n                        q.append((x, y))\n                        seen[x][y] = True\n            bfs(qP, seenP)\n            bfs(qA, seenA)\n            res = []\n            for i in range(m):\n                for j in range(n):\n                    if seenP[i][j] and seenA[i][j]:\n                        res.append([i, j])\n            return res\n    solution = Solution()\n    print(solution.pacificAtlantic([[1, 1], [2, 2]]))", "def test_pacificAtlantic():\n\n    class Solution:\n\n        def pacificAtlantic(self, heights):\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            m = len(heights)\n            n = len(heights[0])\n            qP = collections.deque()\n            qA = collections.deque()\n            seenP = [[False] * n for _ in range(m)]\n            seenA = [[False] * n for _ in range(m)]\n            for i in range(m - 1):\n                qP.append((i, n - 1))\n            for j in range(n - 1):\n                seenP[m - 1][j] = True\n\n            def bfs(q: collections.deque, seen: List[List[bool]]):\n                while q:\n                    (i, j) = q.popleft()\n                    h = heights[i][j]\n                    for (dx, dy) in dirs:\n                        x = i + dx\n                        y = j + dy\n                        if x < 0 or x == m or y < 0 or (y == n):\n                            continue\n                        if seen[x][y] or heights[x][y] < h:\n                            continue\n                        q.append((x, y))\n                        seen[x][y] = True\n            bfs(qP, seenP)\n            res = []\n            for i in range(m):\n                for j in range(n - 1):\n                    if seenP[i][j] and (not seenA[i][j]):\n                        res.append([i, j])\n            return res\n    solution = Solution()\n    print(solution.pacificAtlantic([[3, 2, 0], [0, 0, 1], [2, 0, 3]]))", "def test_pacificAtlantic():\n\n    class Solution:\n\n        def pacificAtlantic(self, heights):\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            m = len(heights)\n            n = len(heights[0])\n            qP = collections.deque()\n            seenP = [[False] * n for _ in range(m)]\n            for i in range(m):\n                qP.append((i, 0))\n\n            def bfs(q: collections.deque, seen: List[List[bool]]):\n                while q:\n                    (i, j) = q.popleft()\n                    h = heights[i][j]\n                    for (dx, dy) in dirs:\n                        x = i + dx\n                        y = j + dy\n                        if x < 0 or x == m or y < 0 or (y == n):\n                            continue\n                        if seen[x][y] or heights[x][y] >= h:\n                            continue\n                        q.append((x, y))\n                        seen[x][y] = True\n            bfs(qP, seenP)\n            res = []\n            for i in range(m):\n                for j in range(n - 1):\n                    if not seenP[i][j]:\n                        res.append([i, j])\n            return res\n    solution = Solution()\n    print(solution.pacificAtlantic([[3, 2, 0], [0, 0, 1], [2, 0, 3]]))", "def test_pacificAtlantic():\n\n    class Solution:\n\n        def pacificAtlantic(self, heights):\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            m = len(heights)\n            n = len(heights[0])\n            qP = collections.deque()\n            seenA = [[False] * n for _ in range(m)]\n            for i in range(n - 1):\n                qP.append((m - 1, i))\n\n            def bfs(q: collections.deque, seen: List[List[bool]]):\n                while q:\n                    (i, j) = q.popleft()\n                    h = heights[i][j]\n                    for (dx, dy) in dirs:\n                        x = i + dx\n                        y = j + dy\n                        if x < 0 or x == m or y < 0 or (y == n):\n                            continue\n                        if seen[x][y] or heights[x][y] >= h:\n                            continue\n                        q.append((x, y))\n                        seen[x][y] = True\n            bfs(qP, seenA)\n            res = []\n            for i in range(m):\n                for j in range(n - 1):\n                    if not seenA[i][j]:\n                        res.append([i, j])\n            return res\n    solution = Solution()\n    print(solution.pacificAtlantic([[3, 2, 0], [0, 0, 1], [2, 0, 3]]))", "def test_pacificAtlantic():\n\n    class Solution:\n\n        def pacificAtlantic(self, heights):\n            m = len(heights)\n            n = len(heights[0])\n            seenP = [[False] * n for _ in range(m)]\n            seenA = [[False] * n for _ in range(m)]\n            for i in range(m - 1):\n                qP.append((i, n - 1))\n                qA.append((i, n - 1))\n\n            def bfs(q: collections.deque, seen: List[List[bool]]):\n                while q:\n                    (i, j) = q.popleft()\n                    h = heights[i][j]\n                    for (dx, dy) in dirs:\n                        x = i + dx\n                        y = j + dy\n                        if 0 <= x < m and 0 <= y < n:\n                            if seen[x][y] or heights[x][y] >= h:\n                                continue\n                            q.append((x, y))\n                            seen[x][y] = True\n            bfs(qP, seenP)\n            bfs(qA, seenA)\n            res = []\n            for i in range(m):\n                for j in range(n - 1):\n                    if seenP[i][j] and (not seenA[i][j]):\n                        res.append([i, j])\n            return res\n    solution = Solution()\n    print(solution.pacificAtlantic([[3, 2, 0], [0, 0, 1], [2, 0, 3]]))", "def test_pacificAtlantic():\n\n    class Solution:\n\n        def pacificAtlantic(self, heights):\n            m = len(heights)\n            n = len(heights[0])\n            seenP = [[False] * n for _ in range(m)]\n            seenA = [[False] * n for _ in range(m)]\n            for i in range(n - 1):\n                qP.append((m - 1, i))\n                qA.append((m - 1, i))\n\n            def bfs(q: collections.deque, seen: List[List[bool]]):\n                while q:\n                    (i, j) = q.popleft()\n                    h = heights[i][j]\n                    for (dx, dy) in dirs:\n                        x = i + dx\n                        y = j + dy\n                        if 0 <= x < m and 0 <= y < n:\n                            if seen[x][y] or heights[x][y] >= h:\n                                continue\n                            q.append((x, y))\n                            seen[x][y] = True\n            bfs(qP, seenP)\n            bfs(qA, seenA)\n            res = []\n            for i in range(m):\n                for j in range(n - 1):\n                    if not seenP[i][j]:\n                        res.append([i, j])\n            return res\n    solution = Solution()\n    print(solution.pacificAtlantic([[2, 1], [1, 2]]))", "def test_pacificAtlantic():\n\n    class Solution:\n\n        def pacificAtlantic(self, heights):\n            m = len(heights)\n            n = len(heights[0])\n            seenP = [[False] * n for _ in range(m)]\n            seenA = [[False] * n for _ in range(m)]\n            for i in range(n - 1):\n                qP.append((m - 1, i))\n                qA.append((m - 1, i))\n\n            def bfs(q: collections.deque, seen: List[List[bool]]):\n                while q:\n                    (i, j) = q.popleft()\n                    h = heights[i][j]\n                    for (dx, dy) in dirs:\n                        x = i + dx\n                        y = j + dy\n                        if 0 <= x < m and 0 <= y < n:\n                            if seen[x][y] or heights[x][y] >= h:\n                                continue\n                            q.append((x, y))\n                            seen[x][y] = True\n            bfs(qP, seenP)\n            bfs(qA, seenA)\n            res = []\n            for i in range(m):\n                for j in range(n - 1):\n                    if not (seenP[i][j] and seenA[i][j]):\n                        res.append([i, j])\n            return res\n    solution = Solution()\n    print(solution.pacificAtlantic([[3, 2, 0], [0, 0, 1], [2, 0, 3]]))", "def test_pacificAtlantic():\n\n    class Solution:\n\n        def pacificAtlantic(self, heights):\n            m = len(heights)\n            n = len(heights[0])\n            seenP = [[False] * n for _ in range(m)]\n            seenA = [[False] * n for _ in range(m)]\n            for i in range(n - 1):\n                qP.append((m - 1, i))\n                qA.append((m - 1, i))\n\n            def bfs(q: collections.deque, seen: List[List[bool]]):\n                while q:\n                    (i, j) = q.popleft()\n                    h = heights[i][j]\n                    for (dx, dy) in dirs:\n                        x = i + dx\n                        y = j + dy\n                        if 0 <= x < m and 0 <= y < n:\n                            if seen[x][y] or heights[x][y] >= h:\n                                continue\n                            q.append((x, y))\n                            seen[x][y] = True\n            bfs(qP, seenP)\n            bfs(qA, seenA)\n            res = []\n            for i in range(m):\n                for j in range(n - 1):\n                    if not (seenP[i][j] and seenA[i][j]):\n                        res.append([i, j])\n            return res\n    solution = Solution()\n    print(solution.pacificAtlantic([[3, 2, 0], [0, 0, 1], [2, 0, 3]]))", "def test_pacificAtlantic():\n\n    class Solution:\n\n        def pacificAtlantic(self, heights):\n            m = len(heights)\n            n = len(heights[0])\n            seenP = [[False] * n for _ in range(m)]\n            seenA = [[False] * n for _ in range(m)]\n            for i in range(n - 1):\n                qP.append((m - 1, i))\n                qA.append((m - 1, i))\n\n            def bfs(q: collections.deque, seen: List[List[bool]]):\n                while q:\n                    (i, j) = q.popleft()\n                    h = heights[i][j]\n                    for (dx, dy) in dirs:\n                        x = i + dx\n                        y = j + dy\n                        if 0 <= x < m and 0 <= y < n:\n                            if seen[x][y] or heights[x][y] >= h:\n                                continue\n                            q.append((x, y))\n                            seen[x][y] = True\n            bfs(qP, seenP)\n            bfs(qA, seenA)\n            res = []\n            for i in range(m):\n                for j in range(n - 1):\n                    if seenP[i][j] and (not seenA[i][j]) or (not seenP[i][j] and seenA[i][j]):\n                        res.append([i, j])\n            return res\n    solution = Solution()\n    print(solution.pacificAtlantic([[3, 2, 0], [0, 0, 1], [2, 0, 3]]))", "def test_pacificAtlantic():\n\n    class Solution:\n\n        def pacificAtlantic(self, heights):\n            m = len(heights)\n            n = len(heights[0])\n            seenP = [[False] * n for _ in range(m)]\n            seenA = [[False] * n for _ in range(m)]\n            for i in range(n - 1):\n                qP.append((m - 1, i))\n                qA.append((0, i))\n\n            def bfs(q: collections.deque, seen: List[List[bool]]):\n                while q:\n                    (i, j) = q.popleft()\n                    h = heights[i][j]\n                    for (dx, dy) in dirs:\n                        x = i + dx\n                        y = j + dy\n                        if 0 <= x < m and 0 <= y < n:\n                            if seen[x][y] or heights[x][y] >= h:\n                                continue\n                            q.append((x, y))\n                            seen[x][y] = True\n            bfs(qP, seenP)\n            bfs(qA, seenA)\n            res = []\n            for i in range(m):\n                for j in range(n - 1):\n                    if seenP[i][j] and seenA[i][j]:\n                        res.append([i, j])\n            return res\n    solution = Solution()\n    print(solution.pacificAtlantic([[3, 2, 0], [0, 0, 1], [2, 0, 3]]))", "def test_pacificAtlantic():\n\n    class Solution:\n\n        def pacificAtlantic(self, heights):\n            m = len(heights)\n            n = len(heights[0])\n            seenP = [[False] * n for _ in range(m)]\n            seenA = [[False] * n for _ in range(m)]\n            for i in range(n - 1):\n                qP.append((m - 1, i))\n                qA.append((0, i))\n\n            def bfs(q: collections.deque, seen: List[List[bool]]):\n                while q:\n                    (i, j) = q.popleft()\n                    h = heights[i][j]\n                    for (dx, dy) in dirs:\n                        x = i + dx\n                        y = j + dy\n                        if 0 <= x < m and 0 <= y < n:\n                            if seen[x][y] or heights[x][y] >= h:\n                                continue\n                            q.append((x, y))\n                            seen[x][y] = True\n            bfs(qP, seenP)\n            bfs(qA, seenA)\n            res = []\n            for i in range(m):\n                for j in range(n - 1):\n                    if not seenP[i][j] or not seenA[i][j]:\n                        res.append([i, j])\n            return res\n    solution = Solution()\n    print(solution.pacificAtlantic([[3, 2, 0], [0, 0, 1], [2, 0, 3]]))", "def test_pacificAtlantic():\n\n    class Solution:\n\n        def pacificAtlantic(self, heights):\n            m = len(heights)\n            n = len(heights[0])\n            seenP = [[False] * n for _ in range(m)]\n            seenA = [[False] * n for _ in range(m)]\n            for i in range(n - 1):\n                qP.append((m - 1, i))\n                qA.append((0, i))\n\n            def bfs(q: collections.deque, seen: List[List[bool]]):\n                while q:\n                    (i, j) = q.popleft()\n                    h = heights[i][j]\n                    for (dx, dy) in dirs:\n                        x = i + dx\n                        y = j + dy\n                        if 0 <= x < m and 0 <= y < n:\n                            if seen[x][y] or heights[x][y] >= h:\n                                continue\n                            q.append((x, y))\n                            seen[x][y] = True\n            bfs(qP, seenP)\n            bfs(qA, seenA)\n            res = []\n            for i in range(m):\n                for j in range(n - 1):\n                    if seenP[i][j] and (not seenA[i][j]) or (not seenP[i][j] and seenA[i][j]):\n                        res.append([i, j])\n            return res\n    solution = Solution()\n    print(solution.pacificAtlantic([[3, 2, 0], [0, 1, 0], [2, 4, 1]]))", "def test_pacificAtlantic():\n\n    class Solution:\n\n        def pacificAtlantic(self, heights):\n            m = len(heights)\n            n = len(heights[0])\n            seenP = [[False] * n for _ in range(m)]\n            seenA = [[False] * n for _ in range(m)]\n            for i in range(n - 1):\n                qP.append((m - 1, i))\n                qA.append((0, i))\n\n            def bfs(q: collections.deque, seen: List[List[bool]]):\n                while q:\n                    (i, j) = q.popleft()\n                    h = heights[i][j]\n                    for (dx, dy) in dirs:\n                        x = i + dx\n                        y = j + dy\n                        if 0 <= x < m and 0 <= y < n:\n                            if seen[x][y] or heights[x][y] >= h:\n                                continue\n                            q.append((x, y))\n                            seen[x][y] = True\n            bfs(qP, seenP)\n            bfs(qA, seenA)\n            res = []\n            for i in range(m):\n                for j in range(n - 1):\n                    if not seenP[i][j] or seenA[i][j]:\n                        res.append([i, j])\n            return res\n    solution = Solution()\n    print(solution.pacificAtlantic([[2, 0, 0], [0, 2, 0], [0, 0, 2]]))", "def test_pacificAtlantic():\n\n    class Solution:\n\n        def pacificAtlantic(self, heights):\n            m = len(heights)\n            n = len(heights[0])\n            seenP = [[False] * n for _ in range(m)]\n            seenA = [[False] * n for _ in range(m)]\n            for i in range(n - 1):\n                qP.append((m - 1, i))\n                qA.append((0, i))\n\n            def bfs(q: collections.deque, seen: List[List[bool]]):\n                while q:\n                    (i, j) = q.popleft()\n                    h = heights[i][j]\n                    for (dx, dy) in dirs:\n                        x = i + dx\n                        y = j + dy\n                        if 0 <= x < m and 0 <= y < n:\n                            if seen[x][y] or heights[x][y] >= h:\n                                continue\n                            q.append((x, y))\n                            seen[x][y] = True\n            bfs(qP, seenP)\n            bfs(qA, seenA)\n            res = []\n            for i in range(m):\n                for j in range(n - 1):\n                    if seenP[i][j] and seenA[i][j] or (not seenP[i][j] and (not seenA[i][j])):\n                        res.append([i, j])\n            return res\n    solution = Solution()\n    print(solution.pacificAtlantic([[0, 2, 3], [1, 4, 5], [6, 7, 8]]))", "def test_pacificAtlantic():\n\n    class Solution:\n\n        def pacificAtlantic(self, heights):\n            m = len(heights)\n            n = len(heights[0])\n            seenP = [[False] * n for _ in range(m)]\n            seenA = [[False] * n for _ in range(m)]\n            for i in range(n - 1):\n                qP.append((m - 1, i))\n                qA.append((0, i))\n\n            def bfs(q: collections.deque, seen: List[List[bool]]):\n                while q:\n                    (i, j) = q.popleft()\n                    h = heights[i][j]\n                    for (dx, dy) in dirs:\n                        x = i + dx\n                        y = j + dy\n                        if 0 <= x < m and 0 <= y < n:\n                            if seen[x][y] or heights[x][y] >= h:\n                                continue\n                            q.append((x, y))\n                            seen[x][y] = True\n            bfs(qP, seenP)\n            bfs(qA, seenA)\n            res = []\n            for i in range(m):\n                for j in range(n - 1):\n                    if seenP[i][j] and seenA[i][j] or (not seenP[i][j] and (not seenA[i][j])):\n                        res.append([i, j])\n            return res\n    solution = Solution()\n    print(solution.pacificAtlantic([[3, 2, 0], [0, 1, 0], [2, 4, 1]]))"]}
{"task_num": 420, "task_title": "Strong Password Checker", "func_name": "strongPasswordChecker", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def strongPasswordChecker(self, password: str) -> int:\n    n = len(password)\n    missing = self._getMissing(password)\n    replaces = 0\n    oneSeq = 0\n    twoSeq = 0\n\n    i = 2\n    while i < n:\n      if password[i] == password[i - 1] and password[i - 1] == password[i - 2]:\n        length = 2\n        while i < n and password[i] == password[i - 1]:\n          length += 1\n          i += 1\n        replaces += length // 3\n        if length % 3 == 0:\n          oneSeq += 1\n        if length % 3 == 1:\n          twoSeq += 1\n      else:\n        i += 1\n\n    if n < 6:\n      return max(6 - n, missing)\n    if n <= 20:\n      return max(replaces, missing)\n\n    deletes = n - 20\n    replaces -= min(oneSeq, deletes)\n    replaces -= min(max(deletes - oneSeq, 0), twoSeq * 2) // 2\n    replaces -= max(deletes - oneSeq - twoSeq * 2, 0) // 3\n    return deletes + max(replaces, missing)\n\n  def _getMissing(self, password: str) -> int:\n    return 3 - any(c.isupper() for c in password) - any(c.islower() for c in password) - any(c.isdigit() for c in password)\n", "tests": ["def test_strongPasswordChecker():\n    solution = Solution()\n    print(solution.strongPasswordChecker('A'))", "def test_strongPasswordChecker():\n    solution = Solution()\n    print(solution.strongPasswordChecker('aB1'))", "def test_strongPasswordChecker():\n    solution = Solution()\n    print(solution.strongPasswordChecker('abcdefghi'))", "def test_strongPasswordChecker():\n    solution = Solution()\n    print(solution.strongPasswordChecker('Baaabb0'))", "def test_strongPasswordChecker():\n    solution = Solution()\n    print(solution.strongPasswordChecker('aabbcc'))", "def test_strongPasswordChecker():\n    solution = Solution()\n    print(solution.strongPasswordChecker('12345678901234567890'))", "def test_strongPasswordChecker():\n    solution = Solution()\n    print(solution.strongPasswordChecker('aA1'))", "def test_strongPasswordChecker():\n    solution = Solution()\n    print(solution.strongPasswordChecker('Baaa0'))", "def test_strongPasswordChecker():\n    solution = Solution()\n    print(solution.strongPasswordChecker('BAAA0'))", "def test_strongPasswordChecker():\n    solution = Solution()\n    print(solution.strongPasswordChecker('abc123ABC'))", "def test_strongPasswordChecker():\n    solution = Solution()\n    print(solution.strongPasswordChecker('Baaaabbb'))", "def test_strongPasswordChecker():\n    solution = Solution()\n    print(solution.strongPasswordChecker('aabbccdd'))", "def test_strongPasswordChecker():\n    solution = Solution()\n    print(solution.strongPasswordChecker('AaBbCc123'))", "def test_strongPasswordChecker():\n    solution = Solution()\n    print(solution.strongPasswordChecker('Baaabb0B'))", "def test_strongPasswordChecker():\n    solution = Solution()\n    print(solution.strongPasswordChecker('Baaabb0Ba'))", "def test_strongPasswordChecker():\n    solution = Solution()\n    print(solution.strongPasswordChecker('Baaabb0Baab'))", "def test_strongPasswordChecker():\n    solution = Solution()\n    print(solution.strongPasswordChecker('Baaabb0Baab123'))", "def test_strongPasswordChecker():\n    solution = Solution()\n    print(solution.strongPasswordChecker('Baaabb0Baab123456'))", "def test_strongPasswordChecker():\n    solution = Solution()\n    print(solution.strongPasswordChecker('Baaabb0Baab123456789012345'))", "def test_strongPasswordChecker():\n    solution = Solution()\n    print(solution.strongPasswordChecker('Baaabb0Baab123456789012345678901234567890'))"]}
{"task_num": 423, "task_title": "Reconstruct Original Digits from English", "func_name": "originalDigits", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def originalDigits(self, s: str) -> str:\n    count = [0] * 10\n\n    for c in s:\n      if c == 'z':\n        count[0] += 1\n      if c == 'o':\n        count[1] += 1\n      if c == 'w':\n        count[2] += 1\n      if c == 'h':\n        count[3] += 1\n      if c == 'u':\n        count[4] += 1\n      if c == 'f':\n        count[5] += 1\n      if c == 'x':\n        count[6] += 1\n      if c == 's':\n        count[7] += 1\n      if c == 'g':\n        count[8] += 1\n      if c == 'i':\n        count[9] += 1\n\n    count[1] -= count[0] + count[2] + count[4]\n    count[3] -= count[8]\n    count[5] -= count[4]\n    count[7] -= count[6]\n    count[9] -= count[5] + count[6] + count[8]\n\n    return ''.join(chr(i + ord('0')) for i, c in enumerate(count) for j in range(c))\n", "tests": ["def test_originalDigits():\n\n    def check(s, expected):\n        result = solution.originalDigits(s)", "def test_originalDigits():\n\n    def check(s, expected):\n        result = solution.originalDigits(s)", "def test_originalDigits():\n\n    def check(s, expected):\n        result = solution.originalDigits(s)", "def test_originalDigits():\n\n    def check(s, expected):\n        result = solution.originalDigits(s)", "def test_originalDigits():\n\n    def check(s, expected):\n        result = solution.originalDigits(s)", "def test_originalDigits():\n\n    def check(s, expected):\n        result = solution.originalDigits(s)", "def test_originalDigits():\n\n    def check(s, expected):\n        result = solution.originalDigits(s)", "def test_originalDigits():\n\n    def check(s, expected):\n        result = solution.originalDigits(s)", "def test_originalDigits():\n\n    def check(s, expected):\n        result = solution.originalDigits(s)", "def test_originalDigits():\n\n    def check(s, expected):\n        result = solution.originalDigits(s)", "def test_originalDigits():\n\n    def check(s, expected):\n        result = solution.originalDigits(s)", "def test_originalDigits():\n\n    def check(s, expected):\n        result = solution.originalDigits(s)", "def test_originalDigits():\n\n    def check(s, expected):\n        result = solution.originalDigits(s)", "def test_originalDigits():\n\n    def check(s, expected):\n        result = solution.originalDigits(s)", "def test_originalDigits():\n\n    def check(s, expected):\n        result = solution.originalDigits(s)", "def test_originalDigits():\n\n    def check(s, expected):\n        result = solution.originalDigits(s)", "def test_originalDigits():\n\n    def check(s, expected):\n        result = solution.originalDigits(s)", "def test_originalDigits():\n\n    def check(s, expected):\n        result = solution.originalDigits(s)", "def test_originalDigits():\n\n    def check(s, expected):\n        result = solution.originalDigits(s)", "def test_originalDigits():\n\n    def check(s, expected):\n        result = solution.originalDigits(s)"]}
{"task_num": 457, "task_title": "Circular Array Loop", "func_name": "circularArrayLoop", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def circularArrayLoop(self, nums: List[int]) -> bool:\n    def advance(i: int) -> int:\n      return (i + nums[i]) % len(nums)\n\n    if len(nums) < 2:\n      return False\n\n    for i, num in enumerate(nums):\n      if num == 0:\n        continue\n\n      slow = i\n      fast = advance(slow)\n      while num * nums[fast] > 0 and num * nums[advance(fast)] > 0:\n        if slow == fast:\n          if slow == advance(slow):\n            break\n          return True\n        slow = advance(slow)\n        fast = advance(advance(fast))\n\n      slow = i\n      sign = num\n      while sign * nums[slow] > 0:\n        next = advance(slow)\n        nums[slow] = 0\n        slow = next\n\n    return False\n", "tests": ["    def test_circularArrayLoop(self):\n        nums = [2, -1, 1, 2, 2]\n        self.assertTrue(Solution().circularArrayLoop(nums))\n\nif __name__ == '__main__':\n    unittest.main()", "    def test_circularArrayLoop_single_element(self):\n        nums = [1]\n        self.assertFalse(Solution().circularArrayLoop(nums))\n\nif __name__ == '__main__':\n    unittest.main()", "    def test_circularArrayLoop_all_positive(self):\n        nums = [1, 2, 3]\n        self.assertTrue(Solution().circularArrayLoop(nums))", "    def test_circularArrayLoop_all_negative(self):\n        nums = [-1, -2, -3]\n        self.assertFalse(Solution().circularArrayLoop(nums))", "    def test_circularArrayLoop_no_cycle(self):\n        nums = [1, -2, 3]\n        self.assertFalse(Solution().circularArrayLoop(nums))", "    def test_circularArrayLoop_zero(self):\n        nums = [0]\n        self.assertFalse(Solution().circularArrayLoop(nums))", "    def test_circularArrayLoop_empty_array(self):\n        nums = []\n        self.assertFalse(Solution().circularArrayLoop(nums))", "    def test_circularArrayLoop_single_zero(self):\n        nums = [0, 1]\n        self.assertFalse(Solution().circularArrayLoop(nums))", "    def test_circularArrayLoop_consecutive_zeroes(self):\n        nums = [0, 0, 1]\n        self.assertFalse(Solution().circularArrayLoop(nums))", "    def test_circularArrayLoop_all_zeros(self):\n        nums = [0] * 1000\n        self.assertFalse(Solution().circularArrayLoop(nums))", "    def test_circularArrayLoop_large_array(self):\n        nums = list(range(-1000, 1001))\n        self.assertFalse(Solution().circularArrayLoop(nums))", "    def test_circularArrayLoop_mixed_signs(self):\n        nums = [1, -2, 3, -4]\n        self.assertTrue(Solution().circularArrayLoop(nums))", "    def test_circularArrayLoop_long_cycle(self):\n        nums = [1] * 1000 + [-1]\n        self.assertTrue(Solution().circularArrayLoop(nums))", "    def test_circularArrayLoop_no_change(self):\n        nums = [1, -2, 3, -4]\n        self.assertTrue(Solution().circularArrayLoop(nums))", "    def test_circularArrayLoop_alternating_cycle(self):\n        nums = [1, -2, 1, -2]\n        self.assertTrue(Solution().circularArrayLoop(nums))", "    def test_circularArrayLoop_repeating_cycle(self):\n        nums = [1, 2, 3, 4, 5, 6]\n        self.assertTrue(Solution().circularArrayLoop(nums))", "    def test_circularArrayLoop_negative_cycle(self):\n        nums = [-1, -2, -3, -4]\n        self.assertFalse(Solution().circularArrayLoop(nums))", "    def test_circularArrayLoop_large_negative_cycle(self):\n        nums = [-1000] * 1001\n        self.assertFalse(Solution().circularArrayLoop(nums))", "    def test_circularArrayLoop_zeroes_and_non_zero(self):\n        nums = [0, -2, 3, 4]\n        self.assertFalse(Solution().circularArrayLoop(nums))", "    def test_circularArrayLoop_only_two_elements(self):\n        nums = [1, -2]\n        self.assertFalse(Solution().circularArrayLoop(nums))"]}
{"task_num": 524, "task_title": "Longest Word in Dictionary through Deleting", "func_name": "findLongestWord", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findLongestWord(self, s: str, d: List[str]) -> str:\n    ans = ''\n\n    for word in d:\n      i = 0\n      for c in s:\n        if i < len(word) and c == word[i]:\n          i += 1\n      if i == len(word):\n        if len(word) > len(ans) or len(word) == len(ans) and word < ans:\n          ans = word\n\n    return ans\n", "tests": ["def test_findLongestWord():\n\n    def findLongestWord(self, s: str, d: List[str]) -> str:\n        ans = ''\n        for word in d:\n            i = 0\n            for c in s:\n                if i < len(word) and c == word[i]:\n                    i += 1\n            if i == len(word):\n                if len(word) > len(ans) or (len(word) == len(ans) and word < ans):\n                    ans = word\n        return ans\nsolution = Solution()\nprint(solution.findLongestWord('abpcplea', ['ale', 'apple', 'monkey', 'plea']))", "def test_findLongestWord():\n\n    def findLongestWord(self, s: str, d: List[str]) -> str:\n        ans = ''\n        for word in d:\n            i = 0\n            for c in s:\n                if i < len(word) and c == word[i]:\n                    i += 1\n            if i == len(word):\n                if len(word) > len(ans) or (len(word) == len(ans) and word < ans):\n                    ans = word\n        return ans\nsolution = Solution()\nprint(solution.findLongestWord('socialmedia', ['mediasocial', 'social', 'sociable']))", "def test_findLongestWord():\n\n    def findLongestWord(self, s: str, d: List[str]) -> str:\n        ans = ''\n        for word in d:\n            i = 0\n            for c in s:\n                if i < len(word) and c == word[i]:\n                    i += 1\n            if i == len(word):\n                if len(word) > len(ans) or (len(word) == len(ans) and word < ans):\n                    ans = word\n        return ans\nsolution = Solution()\nprint(solution.findLongestWord('', ['a', 'b']))", "def test_findLongestWord():\n\n    def findLongestWord(self, s: str, d: List[str]) -> str:\n        ans = ''\n        for word in d:\n            i = 0\n            for c in s:\n                if i < len(word) and c == word[i]:\n                    i += 1\n            if i == len(word):\n                if len(word) > len(ans) or (len(word) == len(ans) and word < ans):\n                    ans = word\n        return ans\nsolution = Solution()\nprint(solution.findLongestWord('apple', ['apple', 'banana', 'cherry']))", "def test_findLongestWord():\n\n    def findLongestWord(self, s: str, d: List[str]) -> str:\n        ans = ''\n        for word in d:\n            i = 0\n            for c in s:\n                if i < len(word) and c == word[i]:\n                    i += 1\n            if i == len(word):\n                if len(word) > len(ans) or (len(word) == len(ans) and word < ans):\n                    ans = word\n        return ans\nsolution = Solution()\nprint(solution.findLongestWord('a', ['a', 'aa']))", "def test_findLongestWord():\n\n    def findLongestWord(self, s: str, d: List[str]) -> str:\n        ans = ''\n        for word in d:\n            i = 0\n            for c in s:\n                if i < len(word) and c == word[i]:\n                    i += 1\n            if i == len(word):\n                if len(word) > len(ans) or (len(word) == len(ans) and word < ans):\n                    ans = word\n        return ans\nsolution = Solution()\nprint(solution.findLongestWord('aabc', ['ab', 'bac', 'bca']))", "def test_findLongestWord():\n\n    def findLongestWord(self, s: str, d: List[str]) -> str:\n        ans = ''\n        for word in d:\n            i = 0\n            for c in s:\n                if i < len(word) and c == word[i]:\n                    i += 1\n            if i == len(word):\n                if len(word) > len(ans) or (len(word) == len(ans) and word < ans):\n                    ans = word\n        return ans\nsolution = Solution()\nprint(solution.findLongestWord('ab', ['ba', 'bc']))", "def test_findLongestWord():\n\n    def findLongestWord(self, s: str, d: List[str]) -> str:\n        ans = ''\n        for word in d:\n            i = 0\n            for c in s:\n                if i < len(word) and c == word[i]:\n                    i += 1\n            if i == len(word):\n                if len(word) > len(ans) or (len(word) == len(ans) and word < ans):\n                    ans = word\n        return ans\nsolution = Solution()\nprint(solution.findLongestWord('a', ['a', 'b']))", "def test_findLongestWord():\n\n    def findLongestWord(self, s: str, d: List[str]) -> str:\n        ans = ''\n        for word in d:\n            i = 0\n            for c in s:\n                if i < len(word) and c == word[i]:\n                    i += 1\n            if i == len(word):\n                if len(word) > len(ans) or (len(word) == len(ans) and word < ans):\n                    ans = word\n        return ans\nsolution = Solution()\nprint(solution.findLongestWord('abcdefghijklmnopqrstuvwxyz', ['a', 'b', 'c']))", "def test_findLongestWord():\n\n    def findLongestWord(self, s: str, d: List[str]) -> str:\n        ans = ''\n        for word in d:\n            i = 0\n            for c in s:\n                if i < len(word) and c == word[i]:\n                    i += 1\n            if i == len(word):\n                if len(word) > len(ans) or (len(word) == len(ans) and word < ans):\n                    ans = word\n        return ans\nsolution = Solution()\nprint(solution.findLongestWord('abcde', ['a', 'b', 'c']))", "def test_findLongestWord():\n\n    def findLongestWord(self, s: str, d: List[str]) -> str:\n        ans = ''\n        for word in d:\n            i = 0\n            for c in s:\n                if i < len(word) and c == word[i]:\n                    i += 1\n            if i == len(word):\n                if len(word) > len(ans) or (len(word) == len(ans) and word < ans):\n                    ans = word\n        return ans\nsolution = Solution()\nprint(solution.findLongestWord('abc', ['ab', 'bc']))", "def test_findLongestWord():\n\n    def findLongestWord(self, s: str, d: List[str]) -> str:\n        ans = ''\n        for word in d:\n            i = 0\n            for c in s:\n                if i < len(word) and c == word[i]:\n                    i += 1\n            if i == len(word):\n                if len(word) > len(ans) or (len(word) == len(ans) and word < ans):\n                    ans = word\n        return ans\nsolution = Solution()\nprint(solution.findLongestWord('aaaaaa', ['a', 'aa', 'aaa']))", "def test_findLongestWord():\n\n    def findLongestWord(self, s: str, d: List[str]) -> str:\n        ans = ''\n        for word in d:\n            i = 0\n            for c in s:\n                if i < len(word) and c == word[i]:\n                    i += 1\n            if i == len(word):\n                if len(word) > len(ans) or (len(word) == len(ans) and word < ans):\n                    ans = word\n        return ans\nsolution = Solution()\nprint(solution.findLongestWord('aaaaa', ['aa', 'aaa']))", "def test_findLongestWord():\n\n    def findLongestWord(self, s: str, d: List[str]) -> str:\n        ans = ''\n        for word in d:\n            i = 0\n            for c in s:\n                if i < len(word) and c == word[i]:\n                    i += 1\n            if i == len(word):\n                if len(word) > len(ans) or (len(word) == len(ans) and word < ans):\n                    ans = word\n        return ans\nsolution = Solution()\nprint(solution.findLongestWord('bba', ['a', 'b', 'c']))", "def test_findLongestWord():\n\n    def findLongestWord(self, s: str, d: List[str]) -> str:\n        ans = ''\n        for word in d:\n            i = 0\n            for c in s:\n                if i < len(word) and c == word[i]:\n                    i += 1\n            if i == len(word):\n                if len(word) > len(ans) or (len(word) == len(ans) and word < ans):\n                    ans = word\n        return ans\nsolution = Solution()\nprint(solution.findLongestWord('abcde', ['c', 'b', 'a']))", "def test_findLongestWord():\n\n    def findLongestWord(self, s: str, d: List[str]) -> str:\n        ans = ''\n        for word in d:\n            i = 0\n            for c in s:\n                if i < len(word) and c == word[i]:\n                    i += 1\n            if i == len(word):\n                if len(word) > len(ans) or (len(word) == len(ans) and word < ans):\n                    ans = word\n        return ans\nsolution = Solution()\nprint(solution.findLongestWord('a', ['aaa', 'aa']))", "def test_findLongestWord():\n\n    def findLongestWord(self, s: str, d: List[str]) -> str:\n        ans = ''\n        for word in d:\n            i = 0\n            for c in s:\n                if i < len(word) and c == word[i]:\n                    i += 1\n            if i == len(word):\n                if len(word) > len(ans) or (len(word) == len(ans) and word < ans):\n                    ans = word\n        return ans\nsolution = Solution()\nprint(solution.findLongestWord('aabbcc', ['ab', 'bc', 'ac']))", "def test_findLongestWord():\n\n    def findLongestWord(self, s: str, d: List[str]) -> str:\n        ans = ''\n        for word in d:\n            i = 0\n            for c in s:\n                if i < len(word) and c == word[i]:\n                    i += 1\n            if i == len(word):\n                if len(word) > len(ans) or (len(word) == len(ans) and word < ans):\n                    ans = word\n        return ans\nsolution = Solution()\nprint(solution.findLongestWord('abcde', ['a', 'b', 'c']))", "def test_findLongestWord():\n\n    def findLongestWord(self, s: str, d: List[str]) -> str:\n        ans = ''\n        for word in d:\n            i = 0\n            for c in s:\n                if i < len(word) and c == word[i]:\n                    i += 1\n            if i == len(word):\n                if len(word) > len(ans) or (len(word) == len(ans) and word < ans):\n                    ans = word\n        return ans\nsolution = Solution()\nprint(solution.findLongestWord('abbc', ['ba', 'ac']))", "def test_findLongestWord():\n\n    def findLongestWord(self, s: str, d: List[str]) -> str:\n        ans = ''\n        for word in d:\n            i = 0\n            for c in s:\n                if i < len(word) and c == word[i]:\n                    i += 1\n            if i == len(word):\n                if len(word) > len(ans) or (len(word) == len(ans) and word < ans):\n                    ans = word\n        return ans\nsolution = Solution()\nprint(solution.findLongestWord('abbcc', ['abc', 'bcc']))"]}
{"task_num": 542, "task_title": "01 Matrix", "func_name": "updateMatrix", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(mat)\n    n = len(mat[0])\n    q = collections.deque()\n    seen = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j] == 0:\n          q.append((i, j))\n          seen[i][j] = True\n\n    while q:\n      i, j = q.popleft()\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if seen[x][y]:\n          continue\n        mat[x][y] = mat[i][j] + 1\n        q.append((x, y))\n        seen[x][y] = True\n\n    return mat\n", "tests": ["def test_updateMatrix():\n\n    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:\n        dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n        m = len(mat)\n        n = len(mat[0])\n        q = collections.deque()\n        seen = [[False] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if mat[i][j] == 0:\n                    q.append((i, j))\n                    seen[i][j] = True\n        while q:\n            (i, j) = q.popleft()\n            for (dx, dy) in dirs:\n                x = i + dx\n                y = j + dy\n                if x < 0 or x == m or y < 0 or (y == n):\n                    continue\n                if seen[x][y]:\n                    continue\n                mat[x][y] = mat[i][j] + 1\n                q.append((x, y))\n                seen[x][y] = True\n        return mat\nsolution = Solution()\nmat = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\nassert solution.updateMatrix(mat) == [[0, 0, 0], [0, 1, 0], [0, 0, 0]]", "def test_updateMatrix():\n\n    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:\n        dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n        m = len(mat)\n        n = len(mat[0])\n        q = collections.deque()\n        seen = [[False] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if mat[i][j] == 0:\n                    q.append((i, j))\n                    seen[i][j] = True\n        while q:\n            (i, j) = q.popleft()\n            for (dx, dy) in dirs:\n                x = i + dx\n                y = j + dy\n                if x < 0 or x == m or y < 0 or (y == n):\n                    continue\n                if seen[x][y]:\n                    continue\n                mat[x][y] = mat[i][j] + 1\n                q.append((x, y))\n                seen[x][y] = True\n        return mat\nsolution = Solution()\nmat = [[1, 1, 1], [0, 1, 1], [0, 0, 0]]\nassert solution.updateMatrix(mat) == [[2, 2, 2], [0, 1, 1], [0, 0, 0]]", "def test_updateMatrix():\n\n    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:\n        dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n        m = len(mat)\n        n = len(mat[0])\n        q = collections.deque()\n        seen = [[False] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if mat[i][j] == 0:\n                    q.append((i, j))\n                    seen[i][j] = True\n        while q:\n            (i, j) = q.popleft()\n            for (dx, dy) in dirs:\n                x = i + dx\n                y = j + dy\n                if x < 0 or x == m or y < 0 or (y == n):\n                    continue\n                if seen[x][y]:\n                    continue\n                mat[x][y] = mat[i][j] + 1\n                q.append((x, y))\n                seen[x][y] = True\n        return mat\nsolution = Solution()\nmat = [[1, 1, 0], [1, 1, 0], [0, 0, 0]]\nassert solution.updateMatrix(mat) == [[2, 2, 1], [2, 2, 1], [0, 0, 0]]", "def test_updateMatrix():\n\n    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:\n        dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n        m = len(mat)\n        n = len(mat[0])\n        q = collections.deque()\n        seen = [[False] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if mat[i][j] == 0:\n                    q.append((i, j))\n                    seen[i][j] = True\n        while q:\n            (i, j) = q.popleft()\n            for (dx, dy) in dirs:\n                x = i + dx\n                y = j + dy\n                if x < 0 or x == m or y < 0 or (y == n):\n                    continue\n                if seen[x][y]:\n                    continue\n                mat[x][y] = mat[i][j] + 1\n                q.append((x, y))\n                seen[x][y] = True\n        return mat\nsolution = Solution()\nmat = [[0]]\nassert solution.updateMatrix(mat) == [[0]]", "def test_updateMatrix():\n\n    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:\n        dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n        m = len(mat)\n        n = len(mat[0])\n        q = collections.deque()\n        seen = [[False] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if mat[i][j] == 0:\n                    q.append((i, j))\n                    seen[i][j] = True\n        while q:\n            (i, j) = q.popleft()\n            for (dx, dy) in dirs:\n                x = i + dx\n                y = j + dy\n                if x < 0 or x == m or y < 0 or (y == n):\n                    continue\n                if seen[x][y]:\n                    continue\n                mat[x][y] = mat[i][j] + 1\n                q.append((x, y))\n                seen[x][y] = True\n        return mat\nsolution = Solution()\nmat = [[0, 0], [0, 1]]\nassert solution.updateMatrix(mat) == [[0, 1], [0, 2]]", "def test_updateMatrix():\n\n    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:\n        dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n        m = len(mat)\n        n = len(mat[0])\n        q = collections.deque()\n        seen = [[False] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if mat[i][j] == 0:\n                    q.append((i, j))\n                    seen[i][j] = True\n        while q:\n            (i, j) = q.popleft()\n            for (dx, dy) in dirs:\n                x = i + dx\n                y = j + dy\n                if x < 0 or x == m or y < 0 or (y == n):\n                    continue\n                if seen[x][y]:\n                    continue\n                mat[x][y] = mat[i][j] + 1\n                q.append((x, y))\n                seen[x][y] = True\n        return mat\nsolution = Solution()\nmat = [[2]]\nassert solution.updateMatrix(mat) == [[0]]", "def test_updateMatrix():\n\n    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:\n        dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n        m = len(mat)\n        n = len(mat[0])\n        q = collections.deque()\n        seen = [[False] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if mat[i][j] == 0:\n                    q.append((i, j))\n                    seen[i][j] = True\n        while q:\n            (i, j) = q.popleft()\n            for (dx, dy) in dirs:\n                x = i + dx\n                y = j + dy\n                if x < 0 or x == m or y < 0 or (y == n):\n                    continue\n                if seen[x][y]:\n                    continue\n                mat[x][y] = mat[i][j] + 1\n                q.append((x, y))\n                seen[x][y] = True\n        return mat\nsolution = Solution()\nmat = [[2, 2], [0, 1]]\nassert solution.updateMatrix(mat) == [[3, 3], [0, 2]]", "def test_updateMatrix():\n\n    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:\n        dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n        m = len(mat)\n        n = len(mat[0])\n        q = collections.deque()\n        seen = [[False] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if mat[i][j] == 0:\n                    q.append((i, j))\n                    seen[i][j] = True\n        while q:\n            (i, j) = q.popleft()\n            for (dx, dy) in dirs:\n                x = i + dx\n                y = j + dy\n                if x < 0 or x == m or y < 0 or (y == n):\n                    continue\n                if seen[x][y]:\n                    continue\n                mat[x][y] = mat[i][j] + 1\n                q.append((x, y))\n                seen[x][y] = True\n        return mat\nsolution = Solution()\nmat = [[2, 2, 0], [1, 1, 0]]\nassert solution.updateMatrix(mat) == [[3, 3, 1], [2, 2, 1]]", "def test_updateMatrix():\n\n    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:\n        dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n        m = len(mat)\n        n = len(mat[0])\n        q = collections.deque()\n        seen = [[False] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if mat[i][j] == 0:\n                    q.append((i, j))\n                    seen[i][j] = True\n        while q:\n            (i, j) = q.popleft()\n            for (dx, dy) in dirs:\n                x = i + dx\n                y = j + dy\n                if x < 0 or x == m or y < 0 or (y == n):\n                    continue\n                if seen[x][y]:\n                    continue\n                mat[x][y] = mat[i][j] + 1\n                q.append((x, y))\n                seen[x][y] = True\n        return mat\nsolution = Solution()\nmat = [[2, 2], [2, 0]]\nassert solution.updateMatrix(mat) == [[3, 2]]", "def test_updateMatrix():\n\n    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:\n        dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n        m = len(mat)\n        n = len(mat[0])\n        q = collections.deque()\n        seen = [[False] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if mat[i][j] == 0:\n                    q.append((i, j))\n                    seen[i][j] = True\n        while q:\n            (i, j) = q.popleft()\n            for (dx, dy) in dirs:\n                x = i + dx\n                y = j + dy\n                if x < 0 or x == m or y < 0 or (y == n):\n                    continue\n                if seen[x][y]:\n                    continue\n                mat[x][y] = mat[i][j] + 1\n                q.append((x, y))\n                seen[x][y] = True\n        return mat\nsolution = Solution()\nmat = [[1, 2], [0, 2]]\nassert solution.updateMatrix(mat) == [[2, 3], [0, 2]]", "def test_updateMatrix():\n\n    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:\n        dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n        m = len(mat)\n        n = len(mat[0])\n        q = collections.deque()\n        seen = [[False] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if mat[i][j] == 0:\n                    q.append((i, j))\n                    seen[i][j] = True\n        while q:\n            (i, j) = q.popleft()\n            for (dx, dy) in dirs:\n                x = i + dx\n                y = j + dy\n                if x < 0 or x == m or y < 0 or (y == n):\n                    continue\n                if seen[x][y]:\n                    continue\n                mat[x][y] = mat[i][j] + 1\n                q.append((x, y))\n                seen[x][y] = True\n        return mat\nsolution = Solution()\nmat = [[2, 2, 0], [2, 2, 0]]\nassert solution.updateMatrix(mat) == [[3, 3, 1], [3, 3, 1]]", "def test_updateMatrix():\n\n    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:\n        dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n        m = len(mat)\n        n = len(mat[0])\n        q = collections.deque()\n        seen = [[False] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if mat[i][j] == 0:\n                    q.append((i, j))\n                    seen[i][j] = True\n        while q:\n            (i, j) = q.popleft()\n            for (dx, dy) in dirs:\n                x = i + dx\n                y = j + dy\n                if x < 0 or x == m or y < 0 or (y == n):\n                    continue\n                if seen[x][y]:\n                    continue\n                mat[x][y] = mat[i][j] + 1\n                q.append((x, y))\n                seen[x][y] = True\n        return mat\nsolution = Solution()\nmat = [[2, 2, 0], [2, 1, 0]]\nassert solution.updateMatrix(mat) == [[3, 3, 1], [4, 2, 1]]", "def test_updateMatrix():\n\n    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:\n        dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n        m = len(mat)\n        n = len(mat[0])\n        q = collections.deque()\n        seen = [[False] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if mat[i][j] == 0:\n                    q.append((i, j))\n                    seen[i][j] = True\n        while q:\n            (i, j) = q.popleft()\n            for (dx, dy) in dirs:\n                x = i + dx\n                y = j + dy\n                if x < 0 or x == m or y < 0 or (y == n):\n                    continue\n                if seen[x][y]:\n                    continue\n                mat[x][y] = mat[i][j] + 1\n                q.append((x, y))\n                seen[x][y] = True\n        return mat\nsolution = Solution()\nmat = [[2, 2, 0], [0, 2, 0]]\nassert solution.updateMatrix(mat) == [[3, 3, 1], [1, 3, 1]]", "def test_updateMatrix():\n\n    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:\n        dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n        m = len(mat)\n        n = len(mat[0])\n        q = collections.deque()\n        seen = [[False] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if mat[i][j] == 0:\n                    q.append((i, j))\n                    seen[i][j] = True\n        while q:\n            (i, j) = q.popleft()\n            for (dx, dy) in dirs:\n                x = i + dx\n                y = j + dy\n                if x < 0 or x == m or y < 0 or (y == n):\n                    continue\n                if seen[x][y]:\n                    continue\n                mat[x][y] = mat[i][j] + 1\n                q.append((x, y))\n                seen[x][y] = True\n        return mat\nsolution = Solution()\nmat = [[2, 2, 0], [2, 2, 0]]\nassert solution.updateMatrix(mat) == [[3, 3, 1], [3, 3, 1]]", "def test_updateMatrix():\n\n    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:\n        dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n        m = len(mat)\n        n = len(mat[0])\n        q = collections.deque()\n        seen = [[False] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if mat[i][j] == 0:\n                    q.append((i, j))\n                    seen[i][j] = True\n        while q:\n            (i, j) = q.popleft()\n            for (dx, dy) in dirs:\n                x = i + dx\n                y = j + dy\n                if x < 0 or x == m or y < 0 or (y == n):\n                    continue\n                if seen[x][y]:\n                    continue\n                mat[x][y] = mat[i][j] + 1\n                q.append((x, y))\n                seen[x][y] = True\n        return mat\nsolution = Solution()\nmat = [[2, 2, 0], [2, 1, 0]]\nassert solution.updateMatrix(mat) == [[3, 3, 1], [4, 2, 1]]", "def test_updateMatrix():\n    mat = [[1, 1, 1], [1, 1, 1]]\n    expected_mat = [[2, 2, 2], [2, 2, 2]]\n    solution = Solution()\n    actual_mat = solution.updateMatrix(mat)", "def test_updateMatrix():\n    mat = [[1, 1, 0], [1, 1, 1]]\n    expected_mat = [[1, 1, 1], [1, 1, 1]]\n    solution = Solution()\n    actual_mat = solution.updateMatrix(mat)", "def test_updateMatrix():\n    mat = [[1, 0], [1, 1]]\n    expected_mat = [[1, 1], [2, 2]]\n    solution = Solution()\n    actual_mat = solution.updateMatrix(mat)", "def test_updateMatrix():\n    mat = [[1, 1], [1, 1]]\n    expected_mat = [[1, 2], [2, 3]]\n    solution = Solution()\n    actual_mat = solution.updateMatrix(mat)", "def test_updateMatrix():\n    mat = [[1, 0, 1], [1, 1, 0], [3, 4, 5]]\n    expected_mat = [[2, 1, 2], [2, 1, 2], [3, 4, 5]]\n    solution = Solution()\n    actual_mat = solution.updateMatrix(mat)"]}
{"task_num": 547, "task_title": "Number of Provinces", "func_name": "findCircleNum", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    self.count -= 1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findCircleNum(self, isConnected: List[List[int]]) -> int:\n    n = len(isConnected)\n    uf = UnionFind(n)\n\n    for i in range(n):\n      for j in range(i, n):\n        if isConnected[i][j] == 1:\n          uf.unionByRank(i, j)\n\n    return uf.count\n", "tests": ["def test_findCircleNum(self):\n    isConnected = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]\n    self.assertEqual(solution.findCircleNum(isConnected), 2)", "def test_findCircleNum():\n    isConnected = [[], [1]]\n    self.assertEqual(solution.findCircleNum(isConnected), 2)", "def test_findCircleNum():\n    isConnected = [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\n    self.assertEqual(solution.findCircleNum(isConnected), 1)", "def test_findCircleNum():\n    isConnected = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n    self.assertEqual(solution.findCircleNum(isConnected), 3)", "def test_findCircleNum():\n    isConnected = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    self.assertEqual(solution.findCircleNum(isConnected), 3)", "def test_findCircleNum():\n    isConnected = [[1]]\n    self.assertEqual(solution.findCircleNum(isConnected), 1)", "def test_findCircleNum():\n    isConnected = []\n    with self.assertRaises(IndexError):\n        solution.findCircleNum(isConnected)", "def test_findCircleNum():\n    isConnected = [[1]]\n    with self.assertRaises(TypeError):\n        solution.findCircleNum(isConnected[0])", "def test_findCircleNum():\n    isConnected = 'hello'\n    with self.assertRaises(TypeError):\n        solution.findCircleNum(isConnected)", "def test_findCircleNum():\n    isConnected = [[1 if i != j else 0 for j in range(100)] for i in range(100)]\n    self.assertLessEqual(solution.findCircleNum(isConnected), 100)", "def test_findCircleNum():\n    isConnected = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]\n    self.assertEqual(solution.findCircleNum(isConnected), 2)", "def test_findCircleNum():\n    isConnected = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]\n    self.assertEqual(solution.findCircleNum(isConnected), 3)", "def test_findCircleNum():\n    isConnected = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]\n    self.assertEqual(solution.findCircleNum(isConnected), 2)", "def test_findCircleNum():\n    isConnected = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    self.assertEqual(solution.findCircleNum(isConnected), 3)", "def test_findCircleNum():\n    isConnected = [[1], [0], [0]]\n    self.assertEqual(solution.findCircleNum(isConnected), 2)", "def test_findCircleNum():\n    isConnected = [[0, 1, 0], [1, 0, 0], [0, 0, 1]]\n    self.assertEqual(solution.findCircleNum(isConnected), 3)", "def test_findCircleNum():\n    isConnected = [[1]]\n    self.assertEqual(solution.findCircleNum(isConnected), 1)", "def test_findCircleNum():\n    isConnected = [[1], [1, 1]]\n    with self.assertRaises(ValueError):\n        solution.findCircleNum(isConnected)", "def test_findCircleNum():\n    isConnected = [[1], [1, 1]]\n    with self.assertRaises(ValueError):\n        solution.findCircleNum(isConnected)", "def test_findCircleNum():\n    isConnected = [[-1, 1, -1], [-1, -1, 1], [1, -1, -1]]\n    with self.assertRaises(ValueError):\n        solution.findCircleNum(isConnected)"]}
{"task_num": 581, "task_title": "Shortest Unsorted Continuous Subarray", "func_name": "findUnsortedSubarray", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findUnsortedSubarray(self, nums: List[int]) -> int:\n    mini = math.inf\n    maxi = -math.inf\n    flag = False\n\n    for i in range(1, len(nums)):\n      if nums[i] < nums[i - 1]:\n        flag = True\n      if flag:\n        mini = min(mini, nums[i])\n\n    flag = False\n\n    for i in reversed(range(len(nums) - 1)):\n      if nums[i] > nums[i + 1]:\n        flag = True\n      if flag:\n        maxi = max(maxi, nums[i])\n\n    for l in range(len(nums)):\n      if nums[l] > mini:\n        break\n\n    for r, num in reversed(list(enumerate(nums))):\n      if num < maxi:\n        break\n\n    return 0 if l >= r else r - l + 1\n", "tests": ["def test_findUnsortedSubarray():\n    solution = Solution()\n\n    def assert_equals(a, b):\n        if a != b:\n            raise AssertionError(f'{a} != {b}')\n    nums = [2, 6, 4, 8, 10, 9, 15]\n    assert_equals(solution.findUnsortedSubarray(nums), 5)", "def test_findUnsortedSubarray():\n    solution = Solution()\n    nums = [1, 2, 3, 4]\n    assert_equals(solution.findUnsortedSubarray(nums), 0)", "def test_findUnsortedSubarray():\n    solution = Solution()\n    nums = [5, 4, 3, 2, 1]\n    assert_equals(solution.findUnsortedSubarray(nums), 5)", "def test_findUnsortedSubarray():\n    solution = Solution()\n    nums = [1, 2, 3]\n    assert_equals(solution.findUnsortedSubarray(nums), 0)", "def test_findUnsortedSubarray():\n    solution = Solution()\n    nums = [1]\n    assert_equals(solution.findUnsortedSubarray(nums), 0)", "def test_findUnsortedSubarray():\n    solution = Solution()\n    nums = [4, 2, 3]\n    assert_equals(solution.findUnsortedSubarray(nums), 1)", "def test_findUnsortedSubarray():\n    solution = Solution()\n    nums = [1, 2, 3, 4, 5]\n    assert_equals(solution.findUnsortedSubarray(nums), 0)", "def test_findUnsortedSubarray():\n    solution = Solution()\n    nums = [1, 2, 3, 5, 4]\n    assert_equals(solution.findUnsortedSubarray(nums), 2)", "def test_findUnsortedSubarray():\n    solution = Solution()\n    nums = [1, 2, 3, 4, 5, 6]\n    assert_equals(solution.findUnsortedSubarray(nums), 0)", "def test_findUnsortedSubarray():\n    solution = Solution()\n    nums = [6, 10, 9, 8, 7, 4, 3, 2, 1]\n    assert_equals(solution.findUnsortedSubarray(nums), 8)", "def test_findUnsortedSubarray():\n    solution = Solution()\n    nums = [6, 5, 4, 3, 2, 1]\n    assert_equals(solution.findUnsortedSubarray(nums), 6)", "def test_findUnsortedSubarray():\n    solution = Solution()\n    nums = [1, 3]\n    assert_equals(solution.findUnsortedSubarray(nums), 0)", "def test_findUnsortedSubarray():\n    solution = Solution()\n    nums = [1, 2]\n    assert_equals(solution.findUnsortedSubarray(nums), 0)", "def test_findUnsortedSubarray():\n    solution = Solution()\n    nums = [1, 2, 3, 4, 5]\n    assert_equals(solution.findUnsortedSubarray(nums), 0)", "def test_findUnsortedSubarray():\n    solution = Solution()\n    nums = [1, 2]\n    assert_equals(solution.findUnsortedSubarray(nums), 0)", "def test_findUnsortedSubarray():\n    solution = Solution()\n    nums = [1, 2]\n    assert_equals(solution.findUnsortedSubarray(nums), 0)", "def test_findUnsortedSubarray():\n    solution = Solution()\n    nums = [1, 2]\n    assert_equals(solution.findUnsortedSubarray(nums), 0)", "def test_findUnsortedSubarray():\n    solution = Solution()\n    nums = [1]\n    assert_equals(solution.findUnsortedSubarray(nums), 0)", "def test_findUnsortedSubarray():\n    solution = Solution()\n    nums = [1]\n    assert_equals(solution.findUnsortedSubarray(nums), 0)", "def test_findUnsortedSubarray():\n    solution = Solution()\n    nums = [1]\n    assert_equals(solution.findUnsortedSubarray(nums), 0)"]}
{"task_num": 591, "task_title": "Tag Validator", "func_name": "isValid", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isValid(self, code: str) -> bool:\n    if code[0] != '<' or code[-1] != '>':\n      return False\n\n    containsTag = False\n    stack = []\n\n    def isValidCdata(s: str) -> bool:\n      return s.find('[CDATA[') == 0\n\n    def isValidTagName(tagName: str, isEndTag: bool) -> bool:\n      nonlocal containsTag\n      if not tagName or len(tagName) > 9:\n        return False\n      if any(not c.isupper() for c in tagName):\n        return False\n\n      if isEndTag:\n        return stack and stack.pop() == tagName\n\n      containsTag = True\n      stack.append(tagName)\n      return True\n\n    i = 0\n    while i < len(code):\n      if not stack and containsTag:\n        return False\n      if code[i] == '<':\n        if stack and code[i + 1] == '!':\n          closeIndex = code.find(']]>', i + 2)\n          if closeIndex == -1 or not isValidCdata(code[i + 2:closeIndex]):\n            return False\n        elif code[i + 1] == '/':\n          closeIndex = code.find('>', i + 2)\n          if closeIndex == -1 or not isValidTagName(code[i + 2:closeIndex], True):\n            return False\n        else:\n          closeIndex = code.find('>', i + 1)\n          if closeIndex == -1 or not isValidTagName(code[i + 1:closeIndex], False):\n            return False\n        i = closeIndex\n      i += 1\n\n    return not stack and containsTag\n", "tests": ["def test_isValid():\n    solution = Solution()\n    print(solution.isValid('<HTML><BODY>hello</BODY></HTML>'))", "def test_isValid():\n    solution = Solution()\n    print(solution.isValid('<HTML><BODY>hello</BODY></HTML>'))", "def test_isValid():\n    solution = Solution()\n    print(solution.isValid('<HTML><BODY>hello</BODY></HTML>'))", "def test_isValid():\n    solution = Solution()\n    print(solution.isValid('<HTML><BODY>hello</BODY></HTML>'))", "def test_isValid():\n    solution = Solution()\n    print(solution.isValid('<HTML><BODY>hello</BODY></HTML>'))", "def test_isValid():\n    solution = Solution()\n    print(solution.isValid('<HTML><BODY>hello</BODY></HTML>'))", "def test_isValid():\n    solution = Solution()\n    print(solution.isValid('<HTML><BODY>hello</BODY></HTML>'))", "def test_isValid():\n    solution = Solution()\n    print(solution.isValid('<HTML><BODY>hello</BODY></HTML>'))", "def test_isValid():\n    solution = Solution()\n    print(solution.isValid('<HTML><BODY>hello</BODY></HTML>'))", "def test_isValid():\n    solution = Solution()\n    print(solution.isValid('<HTML><BODY>hello</BODY></HTML>'))", "def test_isValid():\n    solution = Solution()\n    print(solution.isValid('<HTML><BODY>hello</BODY></HTML>'))", "def test_isValid():\n    solution = Solution()\n    print(solution.isValid('<HTML><BODY>hello</BODY></HTML>'))", "def test_isValid():\n    solution = Solution()\n    print(solution.isValid('<HTML><BODY>hello</BODY></HTML>'))", "def test_isValid():\n    solution = Solution()\n    print(solution.isValid('<HTML><BODY>hello</BODY></HTML>'))", "def test_isValid():\n    solution = Solution()\n    print(solution.isValid('<HTML><BODY>hello</BODY></HTML>'))", "def test_isValid():\n    solution = Solution()\n    print(solution.isValid('<HTML><BODY>hello</BODY></HTML>'))", "def test_isValid():\n    solution = Solution()\n    print(solution.isValid('<HTML><BODY>hello</BODY></HTML>'))", "def test_isValid():\n    solution = Solution()\n    print(solution.isValid('<HTML><BODY>hello</BODY></HTML>'))", "def test_isValid():\n    solution = Solution()\n    print(solution.isValid('<HTML><BODY>hello</BODY></HTML>'))", "def test_isValid():\n    solution = Solution()\n    print(solution.isValid('<HTML><BODY>hello</BODY></HTML>'))"]}
{"task_num": 648, "task_title": "Replace Words", "func_name": "replaceWords", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def __init__(self):\n    self.root = {}\n\n  def insert(self, word: str) -> None:\n    node = self.root\n    for c in word:\n      if c not in node:\n        node[c] = {}\n      node = node[c]\n    node['word'] = word\n\n  def search(self, word: str) -> str:\n    node = self.root\n    for c in word:\n      if 'word' in node:\n        return node['word']\n      if c not in node:\n        return word\n      node = node[c]\n    return word\n\n  def replaceWords(self, dictionary: List[str], sentence: str) -> str:\n    for word in dictionary:\n      self.insert(word)\n\n    words = sentence.split(' ')\n    return ' '.join([self.search(word) for word in words])\n", "tests": ["def test_replaceWords():\n\n    def test_replaceWords_test_input1(solution):\n        solution.insert('help')\n        solution.insert('ful')\n        assert solution.replaceWords(['help', 'ful'], 'he pointing the help button is really helpful') == 'the ful button is really help'", "def test_replaceWords():\n\n    def test_replaceWords_test_input2(solution):\n        solution.insert('apple')\n        solution.insert('app')\n        assert solution.replaceWords(['apple', 'app'], 'apple is an apple') == 'is an app'", "def test_replaceWords():\n\n    def test_replaceWords_test_input3(solution):\n        solution.insert('a')\n        solution.insert('b')\n        assert solution.replaceWords(['a', 'b'], 'ab ab') == 'aa b'", "def test_replaceWords():\n\n    def test_replaceWords_test_input4(solution):\n        solution.insert('abc')\n        solution.insert('b')\n        assert solution.replaceWords(['abc', 'b'], 'ab abc') == 'a b'", "def test_replaceWords():\n\n    def test_replaceWords_test_input5(solution):\n        solution.insert('aa')\n        solution.insert('a')\n        assert solution.replaceWords(['aa', 'a'], 'aaa a') == 'a a'", "def test_replaceWords():\n\n    def test_replaceWords_test_input6(solution):\n        solution.insert('abc')\n        solution.insert('bcd')\n        assert solution.replaceWords(['abc', 'bcd'], 'ab bc cde') == 'cde'", "def test_replaceWords():\n\n    def test_replaceWords_test_input7(solution):\n        solution.insert('a')\n        solution.insert('b')\n        solution.insert('c')\n        assert solution.replaceWords(['a', 'b'], 'abc b c') == 'a a c'", "def test_replaceWords():\n\n    def test_replaceWords_test_input8(solution):\n        solution.insert('xyz')\n        assert solution.replaceWords(['', 'abc'], 'xyz') == 'xyz'", "def test_replaceWords():\n\n    def test_replaceWords_test_input9(solution):\n        solution.insert('abc')\n        assert solution.replaceWords(['', 'abc'], 'abc') == 'abc'", "def test_replaceWords():\n\n    def test_replaceWords_test_input10(solution):\n        solution.insert('a')\n        solution.insert('b')\n        assert solution.replaceWords(['', 'a'], '') == ''", "def test_replaceWords():\n\n    def test_replaceWords_test_input11(solution):\n        solution.insert('abc')\n        solution.insert('bcd')\n        assert solution.replaceWords(['', ''], 'ab bc cde') == 'ab bc cde'", "def test_replaceWords():\n\n    def test_replaceWords_test_input12(solution):\n        solution.insert('abc')\n        assert solution.replaceWords(['', ''], 'ab bc cde') == 'cde'", "def test_replaceWords():\n\n    def test_replaceWords_test_input13(solution):\n        solution.insert('abc')\n        assert solution.replaceWords(['', ''], 'ab bc cde e') == 'e'", "def test_replaceWords():\n\n    def test_replaceWords_test_input14(solution):\n        solution.insert('abc')\n        assert solution.replaceWords(['a'], 'ab bc cde') == 'b cde'", "def test_replaceWords():\n\n    def test_replaceWords_test_input15(solution):\n        solution.insert('abc')\n        solution.insert('bcd')\n        assert solution.replaceWords(['cde', ''], 'ab bc cde') == 'ab b'", "def test_replaceWords():\n\n    def test_replaceWords_test_input16(solution):\n        solution.insert('abc')\n        solution.insert('bcd')\n        assert solution.replaceWords(['cde', 'efg'], 'ab bc cde') == 'b efg'", "def test_replaceWords():\n\n    def test_replaceWords_test_input17(solution):\n        solution.insert('abc')\n        assert solution.replaceWords(['bcd', 'efg'], 'ab bc cde') == 'b b'", "def test_replaceWords():\n\n    def test_replaceWords_test_input18(solution):\n        solution.insert('abc')\n        solution.insert('bcd')\n        assert solution.replaceWords(['cde', 'b'], 'ab bc cde') == 'a b'", "def test_replaceWords():\n\n    def test_replaceWords_test_input19(solution):\n        solution.insert('abc')\n        solution.insert('bcd')\n        assert solution.replaceWords(['cde', 'a'], 'ab bc cde') == 'b b'", "def test_replaceWords():\n\n    def test_replaceWords_test_input20(solution):\n        solution.insert('abc')\n        solution.insert('bcd')\n        assert solution.replaceWords(['cde', ''], 'ab bc cde') == 'b b'"]}
{"task_num": 673, "task_title": "Number of Longest Increasing Subsequence", "func_name": "findNumberOfLIS", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findNumberOfLIS(self, nums: List[int]) -> int:\n    ans = 0\n    maxLength = 0\n    length = [1] * len(nums)\n    count = [1] * len(nums)\n\n    for i, num in enumerate(nums):\n      for j in range(i):\n        if nums[j] < num:\n          if length[i] < length[j] + 1:\n            length[i] = length[j] + 1\n            count[i] = count[j]\n          elif length[i] == length[j] + 1:\n            count[i] += count[j]\n\n    for i, l in enumerate(length):\n      if l > maxLength:\n        maxLength = l\n        ans = count[i]\n      elif l == maxLength:\n        ans += count[i]\n\n    return ans\n", "tests": ["def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([1, 3, 5, 4, 7]) == 2, 'Test case failed'", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([1, 3, 5, 4, 1, 2, 3, 7]) == 1, 'Test case failed'", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([1, 2, 4, 3, 5, 4, 7, 2]) == 2, 'Test case failed'", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([1]) == 1, 'Test case failed'", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([1, 2]) == 2, 'Test case failed'", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([1, 2, 3]) == 2, 'Test case failed'", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([1, 2, 3, 4]) == 4, 'Test case failed'", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([1, 2, 3, 4, 5]) == 5, 'Test case failed'", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([1, 2, 3, 4, 5, 6]) == 6, 'Test case failed'", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([1, 2, 3, 4, 5, 6, 7]) == 7, 'Test case failed'", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([1, 2, 4, 3, 5]) == 2, 'Test case failed'", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([1, 3, 5, 4, 7, 2]) == 2, 'Test case failed'", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([1, 3, 5, 7, 2]) == 2, 'Test case failed'", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([1, 2, 3, 5, 4]) == 2, 'Test case failed'", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([1, 2, 3, 5, 7]) == 2, 'Test case failed'", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([1, 3, 5]) == 2, 'Test case failed'", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([1, 2, 4]) == 2, 'Test case failed'", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([1, 3, 4]) == 2, 'Test case failed'", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([1, 3, 5, 4]) == 2, 'Test case failed'", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([2, 2, 2]) == 1, 'Test case failed'"]}
{"task_num": 684, "task_title": "Redundant Connection", "func_name": "findRedundantConnection", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n    uf = UnionFind(len(edges) + 1)\n\n    for edge in edges:\n      u, v = edge\n      if not uf.unionByRank(u, v):\n        return edge\n", "tests": ["def test_findRedundantConnection(self):\n\n    class Solution:\n\n        def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n            uf = UnionFind(len(edges) + 1)\n            for edge in edges:\n                (u, v) = edge\n                if not uf.unionByRank(u, v):\n                    return edge\n    solution = Solution()\n    self.assertEqual(solution.findRedundantConnection([[1, 2], [1, 3], [2, 3]]), [2, 3])", "def test_findRedundantConnection(self):\n\n    class Solution:\n\n        def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n            uf = UnionFind(len(edges) + 1)\n            for edge in edges:\n                (u, v) = edge\n                if not uf.unionByRank(u, v):\n                    return edge\n    solution = Solution()\n    self.assertEqual(solution.findRedundantConnection([[1, 3], [2, 3], [3, 4]]), [3, 4])", "def test_findRedundantConnection(self):\n\n    class Solution:\n\n        def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n            uf = UnionFind(len(edges) + 1)\n            for edge in edges:\n                (u, v) = edge\n                if not uf.unionByRank(u, v):\n                    return edge\n    solution = Solution()\n    self.assertEqual(solution.findRedundantConnection([[1, 3], [2, 4]]), [1, 3])", "def test_findRedundantConnection(self):\n\n    class Solution:\n\n        def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n            uf = UnionFind(len(edges) + 1)\n            for edge in edges:\n                (u, v) = edge\n                if not uf.unionByRank(u, v):\n                    return edge\n    solution = Solution()\n    self.assertEqual(solution.findRedundantConnection([[1, 2], [3, 4], [1, 3], [2, 3]]), [1, 3])", "def test_findRedundantConnection(self):\n\n    class Solution:\n\n        def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n            uf = UnionFind(len(edges) + 1)\n            for edge in edges:\n                (u, v) = edge\n                if not uf.unionByRank(u, v):\n                    return edge\n    solution = Solution()\n    self.assertEqual(solution.findRedundantConnection([[1, 2], [3, 4], [5, 6], [7, 8]]), [7, 8])", "def test_findRedundantConnection(self):\n\n    class Solution:\n\n        def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n            uf = UnionFind(len(edges) + 1)\n            for edge in edges:\n                (u, v) = edge\n                if not uf.unionByRank(u, v):\n                    return edge\n    solution = Solution()\n    self.assertEqual(solution.findRedundantConnection([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]), [5, 6])", "def test_findRedundantConnection(self):\n\n    class Solution:\n\n        def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n            uf = UnionFind(len(edges) + 1)\n            for edge in edges:\n                (u, v) = edge\n                if not uf.unionByRank(u, v):\n                    return edge\n    solution = Solution()\n    self.assertEqual(solution.findRedundantConnection([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]), [7, 8])", "def test_findRedundantConnection(self):\n\n    class Solution:\n\n        def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n            uf = UnionFind(len(edges) + 1)\n            for edge in edges:\n                (u, v) = edge\n                if not uf.unionByRank(u, v):\n                    return edge\n    solution = Solution()\n    self.assertEqual(solution.findRedundantConnection([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]), [7, 8])", "def test_findRedundantConnection(self):\n\n    class Solution:\n\n        def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n            uf = UnionFind(len(edges) + 1)\n            for edge in edges:\n                (u, v) = edge\n                if not uf.unionByRank(u, v):\n                    return edge\n    solution = Solution()\n    self.assertEqual(solution.findRedundantConnection([[1, 3], [2, 4], [5, 6]]), [1, 3])", "def test_findRedundantConnection(self):\n\n    class Solution:\n\n        def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n            uf = UnionFind(len(edges) + 1)\n            for edge in edges:\n                (u, v) = edge\n                if not uf.unionByRank(u, v):\n                    return edge\n    solution = Solution()\n    self.assertEqual(solution.findRedundantConnection([[1, 3], [2, 4], [5, 6], [7, 8], [9, 10]]), [9, 10])", "def test_findRedundantConnection(self):\n\n    class Solution:\n\n        def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n            uf = UnionFind(len(edges) + 1)\n            for edge in edges:\n                (u, v) = edge\n                if not uf.unionByRank(u, v):\n                    return edge\n    solution = Solution()\n    self.assertEqual(solution.findRedundantConnection([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12]]), [13, 14])", "def test_findRedundantConnection(self):\n\n    class Solution:\n\n        def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n            uf = UnionFind(len(edges) + 1)\n            for edge in edges:\n                (u, v) = edge\n                if not uf.unionByRank(u, v):\n                    return edge\n    solution = Solution()\n    self.assertEqual(solution.findRedundantConnection([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12], [13, 14]]), [15, 16])", "def test_findRedundantConnection(self):\n\n    class Solution:\n\n        def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n            uf = UnionFind(len(edges) + 1)\n            for edge in edges:\n                (u, v) = edge\n                if not uf.unionByRank(u, v):\n                    return edge\n    solution = Solution()\n    self.assertEqual(solution.findRedundantConnection([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12], [13, 14], [15, 16]]), [17, 18])", "def test_findRedundantConnection(self):\n\n    class Solution:\n\n        def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n            uf = UnionFind(len(edges) + 1)\n            for edge in edges:\n                (u, v) = edge\n                if not uf.unionByRank(u, v):\n                    return edge\n    solution = Solution()\n    self.assertEqual(solution.findRedundantConnection([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12], [13, 14], [15, 16], [17, 18]]), [19, 20])", "def test_findRedundantConnection(self):\n\n    class Solution:\n\n        def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n            uf = UnionFind(len(edges) + 1)\n            for edge in edges:\n                (u, v) = edge\n                if not uf.unionByRank(u, v):\n                    return edge\n    solution = Solution()\n    self.assertEqual(solution.findRedundantConnection([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12], [13, 14], [15, 16], [17, 18], [19, 20]]), [21, 22])", "def test_findRedundantConnection(self):\n\n    class Solution:\n\n        def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n            uf = UnionFind(len(edges) + 1)\n            for edge in edges:\n                (u, v) = edge\n                if not uf.unionByRank(u, v):\n                    return edge\n    solution = Solution()\n    self.assertEqual(solution.findRedundantConnection([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12], [13, 14], [15, 16], [17, 18], [19, 20], [21, 22]]), [23, 24])", "def test_findRedundantConnection(self):\n\n    class Solution:\n\n        def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n            uf = UnionFind(len(edges) + 1)\n            for edge in edges:\n                (u, v) = edge\n                if not uf.unionByRank(u, v):\n                    return edge\n    solution = Solution()\n    self.assertEqual(solution.findRedundantConnection([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12], [13, 14], [15, 16], [17, 18], [19, 20], [21, 22], [23, 24]]), [25, 26])", "def test_findRedundantConnection(self):\n\n    class Solution:\n\n        def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n            uf = UnionFind(len(edges) + 1)\n            for edge in edges:\n                (u, v) = edge\n                if not uf.unionByRank(u, v):\n                    return edge\n    solution = Solution()\n    self.assertEqual(solution.findRedundantConnection([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12], [13, 14], [15, 16], [17, 18], [19, 20]]), [21, 22])", "def test_findRedundantConnection(self):\n\n    class Solution:\n\n        def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n            uf = UnionFind(len(edges) + 1)\n            for edge in edges:\n                (u, v) = edge\n                if not uf.unionByRank(u, v):\n                    return edge\n    solution = Solution()\n    self.assertEqual(solution.findRedundantConnection([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]), [11, 12])", "def test_findRedundantConnection(self):\n\n    class Solution:\n\n        def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n            uf = UnionFind(len(edges) + 1)\n            for edge in edges:\n                (u, v) = edge\n                if not uf.unionByRank(u, v):\n                    return edge\n    solution = Solution()\n    self.assertEqual(solution.findRedundantConnection([[1, 3], [2, 4], [5, 6]]), [7, 8])"]}
{"task_num": 685, "task_title": "Redundant Connection II", "func_name": "findRedundantDirectedConnection", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\n    ids = [0] * (len(edges) + 1)\n    nodeWithTwoParents = 0\n\n    for _, v in edges:\n      ids[v] += 1\n      if ids[v] == 2:\n        nodeWithTwoParents = v\n\n    def findRedundantDirectedConnection(skippedEdgeIndex: int) -> List[int]:\n      uf = UnionFind(len(edges) + 1)\n\n      for i, edge in enumerate(edges):\n        if i == skippedEdgeIndex:\n          continue\n        if not uf.unionByRank(edge[0], edge[1]):\n          return edge\n\n      return []\n\n    if nodeWithTwoParents == 0:\n      return findRedundantDirectedConnection(-1)\n\n    for i in reversed(range(len(edges))):\n      _, v = edges[i]\n      if v == nodeWithTwoParents:\n        if not findRedundantDirectedConnection(i):\n          return edges[i]\n", "tests": ["def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1, 2], [1, 3], [2, 3]]\n    expected = [2, 3]\n    assert solution.findRedundantDirectedConnection(edges) == expected", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1, 3], [2, 3], [3, 4], [5, 6]]\n    expected = [5, 6]\n    assert solution.findRedundantDirectedConnection(edges) == expected", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1, 2], [2, 3], [4, 5], [1, 3]]\n    expected = [4, 5]\n    assert solution.findRedundantDirectedConnection(edges) == expected", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1, 2], [3, 4], [5, 6]]\n    expected = [1, 2]\n    assert solution.findRedundantDirectedConnection(edges) == expected", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1, 2], [2, 3]]\n    expected = []\n    assert solution.findRedundantDirectedConnection(edges) == expected", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1, 2], [2, 3], [3, 4], [5, 6]]\n    expected = [5, 6]\n    assert solution.findRedundantDirectedConnection(edges) == expected", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1, 2], [3, 4]]\n    expected = []\n    assert solution.findRedundantDirectedConnection(edges) == expected", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1, 2], [3, 4], [5, 6]]\n    expected = []\n    assert solution.findRedundantDirectedConnection(edges) == expected", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1, 2], [3, 4], [6, 7]]\n    expected = []\n    assert solution.findRedundantDirectedConnection(edges) == expected", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1, 3], [2, 4], [5, 6]]\n    expected = []\n    assert solution.findRedundantDirectedConnection(edges) == expected", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1, 3], [2, 4], [5, 6], [7, 8]]\n    expected = [7, 8]\n    assert solution.findRedundantDirectedConnection(edges) == expected", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1, 2], [3, 4], [5, 6], [7, 8]]\n    expected = [7, 8]\n    assert solution.findRedundantDirectedConnection(edges) == expected", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1, 2], [3, 4], [5, 6], [7, 8]]\n    expected = [7, 8]\n    assert solution.findRedundantDirectedConnection(edges) == expected", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1, 2], [3, 4], [5, 6]]\n    expected = [1, 2]\n    assert solution.findRedundantDirectedConnection(edges) == expected", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1, 2], [3, 4]]\n    expected = []\n    assert solution.findRedundantDirectedConnection(edges) == expected", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1, 2], [3, 4], [5, 6]]\n    expected = [1, 2]\n    assert solution.findRedundantDirectedConnection(edges) == expected", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1, 3], [2, 4]]\n    expected = []\n    assert solution.findRedundantDirectedConnection(edges) == expected", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1, 3], [2, 4]]\n    expected = [2, 4]\n    assert solution.findRedundantDirectedConnection(edges) == expected", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1, 3], [2, 4]]\n    expected = [2, 4]\n    assert solution.findRedundantDirectedConnection(edges) == expected", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1, 2], [3, 4]]\n    expected = [1, 2]\n    assert solution.findRedundantDirectedConnection(edges) == expected"]}
{"task_num": 688, "task_title": "Knight Probability in Chessboard", "func_name": "knightProbability", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\n    dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n    dp = [[0] * n for _ in range(n)]\n    dp[row][column] = 1.0\n\n    for _ in range(k):\n      newDp = [[0] * n for _ in range(n)]\n      for i in range(n):\n        for j in range(n):\n          for dx, dy in dirs:\n            x = i + dx\n            y = j + dy\n            if 0 <= x < n and 0 <= y < n:\n              newDp[i][j] += dp[x][y]\n      dp = newDp\n\n    return sum(map(sum, dp)) / 8**k\n", "tests": ["def test_knightProbability():\n    solution = Solution()\n    print(solution.knightProbability(8, 30, 0, 0))", "def test_knightProbability():\n    solution = Solution()\n    print(solution.knightProbability(3, 1, 0, 0))", "def test_knightProbability():\n    solution = Solution()\n    print(solution.knightProbability(1, 2, 0, 0))", "def test_knightProbability():\n    solution = Solution()\n    print(solution.knightProbability(64, 61, 7, 3))", "def test_knightProbability():\n    solution = Solution()\n    print(solution.knightProbability(2, 0, 1, 0))", "def test_knightProbability():\n    solution = Solution()\n    print(solution.knightProbability(100, 99, 49, 49))", "def test_knightProbability():\n    solution = Solution()\n    print(solution.knightProbability(5, 8, 4, 2))", "def test_knightProbability():\n    solution = Solution()\n    print(solution.knightProbability(1, 0, 0, 0))", "def test_knightProbability():\n    solution = Solution()\n    print(solution.knightProbability(3, 2, 1, 0))", "def test_knightProbability():\n    solution = Solution()\n    print(solution.knightProbability(8, 15, 5, 6))", "def test_knightProbability():\n    solution = Solution()\n    print(solution.knightProbability(4, 3, 0, 2))", "def test_knightProbability():\n    solution = Solution()\n    print(solution.knightProbability(16, 30, 0, 15))", "def test_knightProbability():\n    solution = Solution()\n    print(solution.knightProbability(7, 31, 3, 1))", "def test_knightProbability():\n    solution = Solution()\n    print(solution.knightProbability(1000, 999, 500, 501))", "def test_knightProbability():\n    solution = Solution()\n    print(solution.knightProbability(10000, 9999, 5000, 5001))", "def test_knightProbability():\n    solution = Solution()\n    print(solution.knightProbability(9999, 9998, 4995, 4996))", "def test_knightProbability():\n    solution = Solution()\n    print(solution.knightProbability(99999, 99998, 49995, 49996))", "def test_knightProbability():\n    solution = Solution()\n    print(solution.knightProbability(999999, 999998, 499995, 499996))", "def test_knightProbability():\n    solution = Solution()\n    print(solution.knightProbability(9999999, 9999998, 4999995, 4999996))", "def test_knightProbability():\n    solution = Solution()\n    print(solution.knightProbability(1000000, 999999, 500000, 500001))"]}
{"task_num": 689, "task_title": "Maximum Sum of 3 Non-Overlapping Subarrays", "func_name": "maxSumOfThreeSubarrays", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:\n    n = len(nums) - k + 1\n    sums = [0] * n\n    l = [0] * n\n    r = [0] * n\n\n    summ = 0\n    for i, num in enumerate(nums):\n      summ += num\n      if i >= k:\n        summ -= nums[i - k]\n      if i >= k - 1:\n        sums[i - k + 1] = summ\n\n    maxIndex = 0\n    for i in range(n):\n      if sums[i] > sums[maxIndex]:\n        maxIndex = i\n      l[i] = maxIndex\n\n    maxIndex = n - 1\n    for i in range(n - 1, -1, -1):\n      if sums[i] >= sums[maxIndex]:\n        maxIndex = i\n      r[i] = maxIndex\n\n    ans = [-1, -1, -1]\n\n    for i in range(k, n - k):\n      if ans[0] == -1 or sums[ans[0]] + sums[ans[1]] + sums[ans[2]] < sums[l[i - k]] + sums[i] + sums[r[i + k]]:\n        ans[0] = l[i - k]\n        ans[1] = i\n        ans[2] = r[i + k]\n\n    return ans\n", "tests": ["def test_maxSumOfThreeSubarrays(self):\n    nums = [1, 2, 1, 2, 6, 2, 3, 5, 1, 7, 8, 2]\n    k = 3\n    solution = Solution()\n    self.assertEqual(solution.maxSumOfThreeSubarrays(nums, k), [0, 3, 6])", "def test_maxSumOfThreeSubarrays(self):\n    nums = []\n    k = 3\n    solution = Solution()\n    self.assertEqual(solution.maxSumOfThreeSubarrays(nums, k), [-1, -1, -1])", "def test_maxSumOfThreeSubarrays(self):\n    nums = [1] * 10\n    k = len(nums)\n    solution = Solution()\n    self.assertEqual(solution.maxSumOfThreeSubarrays(nums, k), [0, 3, 6])", "def test_maxSumOfThreeSubarrays(self):\n    nums = [1] * 3\n    k = len(nums) + 10\n    solution = Solution()\n    self.assertEqual(solution.maxSumOfThreeSubarrays(nums, k), [-1, -1, -1])", "def test_maxSumOfThreeSubarrays(self):\n    nums = [10]\n    k = 3\n    solution = Solution()\n    self.assertEqual(solution.maxSumOfThreeSubarrays(nums, k), [-1, -1, -1])", "def test_maxSumOfThreeSubarrays(self):\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    k = 3\n    solution = Solution()\n    self.assertEqual(solution.maxSumOfThreeSubarrays(nums, k), [0, 3, 6])", "def test_maxSumOfThreeSubarrays(self):\n    nums = [-1, -2, -3, 4, 5, 6, 7, 8, 9]\n    k = 3\n    solution = Solution()\n    self.assertEqual(solution.maxSumOfThreeSubarrays(nums, k), [0, 3, 6])", "def test_maxSumOfThreeSubarrays(self):\n    nums = [-10, -20, -30]\n    k = 3\n    solution = Solution()\n    self.assertEqual(solution.maxSumOfThreeSubarrays(nums, k), [-1, -1, -1])", "def test_maxSumOfThreeSubarrays(self):\n    nums = [10] * 9\n    k = 3\n    solution = Solution()\n    self.assertEqual(solution.maxSumOfThreeSubarrays(nums, k), [0, 3, 6])", "def test_maxSumOfThreeSubarrays(self):\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    k = 3\n    solution = Solution()\n    self.assertEqual(solution.maxSumOfThreeSubarrays(nums, k), [0, 3, 6])", "def test_maxSumOfThreeSubarrays(self):\n    nums = [9, 8, 7, 6, 5, 4, 3, 2, 1]\n    k = 3\n    solution = Solution()\n    self.assertEqual(solution.maxSumOfThreeSubarrays(nums, k), [0, 3, 6])", "def test_maxSumOfThreeSubarrays(self):\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    k = 3\n    solution = Solution()\n    self.assertEqual(solution.maxSumOfThreeSubarrays(nums, k), [0, 3, 6])", "def test_maxSumOfThreeSubarrays(self):\n    nums = [1, 2, 3, 4, 5, 6]\n    k = 2\n    solution = Solution()\n    self.assertEqual(solution.maxSumOfThreeSubarrays(nums, k), [0, 2, -1])", "def test_maxSumOfThreeSubarrays(self):\n    nums = [1, -2, 3, -4]\n    k = 2\n    solution = Solution()\n    self.assertEqual(solution.maxSumOfThreeSubarrays(nums, k), [-1, -1, -1])", "def test_maxSumOfThreeSubarrays(self):\n    nums = [1, 2, 3]\n    k = -3\n    solution = Solution()\n    self.assertEqual(solution.maxSumOfThreeSubarrays(nums, k), [-1, -1, -1])", "def test_maxSumOfThreeSubarrays(self):\n    nums = [1, 2, 3]\n    k = len(nums) - 1\n    solution = Solution()\n    self.assertEqual(solution.maxSumOfThreeSubarrays(nums, k), [-1, -1, -1])", "def test_maxSumOfThreeSubarrays(self):\n    nums = [1000000] * 9\n    k = 3\n    solution = Solution()\n    self.assertEqual(solution.maxSumOfThreeSubarrays(nums, k), [0, 3, 6])", "def test_maxSumOfThreeSubarrays(self):\n    nums = [1.5, 2.7, 3.9, 4.1, 5.6]\n    k = 3\n    solution = Solution()\n    self.assertEqual(solution.maxSumOfThreeSubarrays(nums, k), [0, 3, 6])", "def test_maxSumOfThreeSubarrays(self):\n    nums = [1 + 2j, 2 - 3j, 3 + 4j]\n    k = 3\n    solution = Solution()\n    self.assertEqual(solution.maxSumOfThreeSubarrays(nums, k), [0, 3, 6])", "def test_maxSumOfThreeSubarrays(self):\n    nums = [1.2, 3.4, 5.6]\n    k = 2\n    solution = Solution()\n    self.assertEqual(solution.maxSumOfThreeSubarrays(nums, k), [-1, -1, -1])"]}
{"task_num": 691, "task_title": "Stickers to Spell Word", "func_name": "minStickers", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minStickers(self, stickers: List[str], target: str) -> int:\n    maxMask = 1 << len(target)\n    dp = [math.inf] * maxMask\n    dp[0] = 0\n\n    for mask in range(maxMask):\n      if dp[mask] == math.inf:\n        continue\n      for sticker in stickers:\n        superMask = mask\n        for c in sticker:\n          for i, t in enumerate(target):\n            if c == t and not (superMask >> i & 1):\n              superMask |= 1 << i\n              break\n        dp[superMask] = min(dp[superMask], dp[mask] + 1)\n\n    return -1 if dp[-1] == math.inf else dp[-1]\n", "tests": ["def test_minStickers(self):\n    solution = Solution()\n    stickers = ['with', 'example', 'science']\n    target = 'thehat'\n    self.assertEqual(solution.minStickers(stickers, target), 6)", "def test_minStickers(self):\n    solution = Solution()\n    stickers = ['hello', 'world']\n    target = 'helloworld'\n    self.assertEqual(solution.minStickers(stickers, target), 1)", "def test_minStickers(self):\n    solution = Solution()\n    stickers = ['a', 'b']\n    target = 'ab'\n    self.assertEqual(solution.minStickers(stickers, target), 2)", "def test_minStickers(self):\n    solution = Solution()\n    stickers = ['apple', 'pen']\n    target = 'banana'\n    self.assertEqual(solution.minStickers(stickers, target), -1)", "def test_minStickers(self):\n    solution = Solution()\n    stickers = ['cat', 'hat']\n    target = 'cathat'\n    self.assertEqual(solution.minStickers(stickers, target), -1)", "def test_minStickers(self):\n    solution = Solution()\n    stickers = ['a']\n    target = 'aaaa'\n    self.assertEqual(solution.minStickers(stickers, target), 4)", "def test_minStickers(self):\n    solution = Solution()\n    stickers = ['xyz', '123']\n    target = 'xyzzz123'\n    self.assertEqual(solution.minStickers(stickers, target), -1)", "def test_minStickers(self):\n    solution = Solution()\n    stickers = ['a']\n    target = ''\n    self.assertEqual(solution.minStickers(stickers, target), -1)", "def test_minStickers(self):\n    solution = Solution()\n    stickers = ['aaaaa']\n    target = 'a'\n    self.assertEqual(solution.minStickers(stickers, target), 1)", "def test_minStickers(self):\n    solution = Solution()\n    stickers = ['ab']\n    target = 'abcd'\n    self.assertEqual(solution.minStickers(stickers, target), -1)", "def test_minStickers(self):\n    solution = Solution()\n    stickers = ['aaaa', 'aa']\n    target = 'aaaa'\n    self.assertEqual(solution.minStickers(stickers, target), 1)", "def test_minStickers(self):\n    solution = Solution()\n    stickers = ['a', 'aa']\n    target = 'aaaa'\n    self.assertEqual(solution.minStickers(stickers, target), 2)", "def test_minStickers(self):\n    solution = Solution()\n    stickers = ['a']\n    target = 'b'\n    self.assertEqual(solution.minStickers(stickers, target), -1)", "def test_minStickers(self):\n    solution = Solution()\n    stickers = ['a', 'ab']\n    target = 'abcd'\n    self.assertEqual(solution.minStickers(stickers, target), -1)", "def test_minStickers(self):\n    solution = Solution()\n    stickers = ['abc']\n    target = 'abcd'\n    self.assertEqual(solution.minStickers(stickers, target), -1)", "def test_minStickers(self):\n    solution = Solution()\n    stickers = ['a', 'b']\n    target = 'abba'\n    self.assertEqual(solution.minStickers(stickers, target), -1)", "def test_minStickers(self):\n    solution = Solution()\n    stickers = ['a', 'b']\n    target = 'abc'\n    self.assertEqual(solution.minStickers(stickers, target), -1)", "def test_minStickers(self):\n    solution = Solution()\n    stickers = ['aa', 'bb']\n    target = 'ab'\n    self.assertEqual(solution.minStickers(stickers, target), -1)", "def test_minStickers(self):\n    solution = Solution()\n    stickers = ['a', 'b']\n    target = 'aaaa'\n    self.assertEqual(solution.minStickers(stickers, target), -1)", "def test_minStickers(self):\n    solution = Solution()\n    stickers = ['a']\n    target = 'aaaaaa'\n    self.assertEqual(solution.minStickers(stickers, target), -1)"]}
{"task_num": 722, "task_title": "Remove Comments", "func_name": "removeComments", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def removeComments(self, source: List[str]) -> List[str]:\n    ans = []\n    commenting = False\n    modified = ''\n\n    for line in source:\n      i = 0\n      while i < len(line):\n        if i + 1 == len(line):\n          if not commenting:\n            modified += line[i]\n          i += 1\n          break\n        twoChars = line[i:i + 2]\n        if twoChars == '/*' and not commenting:\n          commenting = True\n          i += 2\n        elif twoChars == '*/' and commenting:\n          commenting = False\n          i += 2\n        elif twoChars == '//':\n          if not commenting:\n            break\n          else:\n            i += 2\n        else:\n          if not commenting:\n            modified += line[i]\n          i += 1\n      if modified and not commenting:\n        ans.append(modified)\n        modified = ''\n\n    return ans\n", "tests": ["def test_removeComments():\n\n    class Solution:\n\n        def removeComments(self, source: List[str]) -> List[str]:\n            ans = []\n            commenting = False\n            modified = ''\n            for line in source:\n                i = 0\n                while i < len(line):\n                    if i + 1 == len(line):\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                        break\n                    twoChars = line[i:i + 2]\n                    if twoChars == '/*' and (not commenting):\n                        commenting = True\n                        i += 2\n                    elif twoChars == '*/' and commenting:\n                        commenting = False\n                        i += 2\n                    elif twoChars == '//':\n                        if not commenting:\n                            break\n                        else:\n                            i += 2\n                    else:\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                if modified and (not commenting):\n                    ans.append(modified)\n                    modified = ''\n            return ans\n    solution = Solution()\n    source = ['string s = /* Not a comment */;', 'public class Test {']\n    expected = ['public class Test {']\n    self.assertEqual(solution.removeComments(source), expected)", "def test_removeComments():\n\n    class Solution:\n\n        def removeComments(self, source: List[str]) -> List[str]:\n            ans = []\n            commenting = False\n            modified = ''\n            for line in source:\n                i = 0\n                while i < len(line):\n                    if i + 1 == len(line):\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                        break\n                    twoChars = line[i:i + 2]\n                    if twoChars == '/*' and (not commenting):\n                        commenting = True\n                        i += 2\n                    elif twoChars == '*/' and commenting:\n                        commenting = False\n                        i += 2\n                    elif twoChars == '//':\n                        if not commenting:\n                            break\n                        else:\n                            i += 2\n                    else:\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                if modified and (not commenting):\n                    ans.append(modified)\n                    modified = ''\n            return ans\n    solution = Solution()\n    source = ['// This is a comment', '/* This is also a comment */', 'public class Test { public static void main(String[] args) { /* This is another block comment */ System.out.println(\"Hello World!\"); } };']\n    expected = ['public class Test { public static void main(String[] args) { System.out.println(\"Hello World!\"); } };']\n    self.assertEqual(solution.removeComments(source), expected)", "def test_removeComments():\n\n    class Solution:\n\n        def removeComments(self, source: List[str]) -> List[str]:\n            ans = []\n            commenting = False\n            modified = ''\n            for line in source:\n                i = 0\n                while i < len(line):\n                    if i + 1 == len(line):\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                        break\n                    twoChars = line[i:i + 2]\n                    if twoChars == '/*' and (not commenting):\n                        commenting = True\n                        i += 2\n                    elif twoChars == '*/' and commenting:\n                        commenting = False\n                        i += 2\n                    elif twoChars == '//':\n                        if not commenting:\n                            break\n                        else:\n                            i += 2\n                    else:\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                if modified and (not commenting):\n                    ans.append(modified)\n                    modified = ''\n            return ans\n    solution = Solution()\n    source = ['public class Test { public static void main(String[] args) { /* This is another block comment */ System.out.println(\"Hello World!\"); int x = /* Not a comment */5; } };']\n    expected = ['public class Test { public static void main(String[] args) { System.out.println(\"Hello World!\"); int x = 5; } }']\n    self.assertEqual(solution.removeComments(source), expected)", "def test_removeComments():\n\n    class Solution:\n\n        def removeComments(self, source: List[str]) -> List[str]:\n            ans = []\n            commenting = False\n            modified = ''\n            for line in source:\n                i = 0\n                while i < len(line):\n                    if i + 1 == len(line):\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                        break\n                    twoChars = line[i:i + 2]\n                    if twoChars == '/*' and (not commenting):\n                        commenting = True\n                        i += 2\n                    elif twoChars == '*/' and commenting:\n                        commenting = False\n                        i += 2\n                    elif twoChars == '//':\n                        if not commenting:\n                            break\n                        else:\n                            i += 2\n                    else:\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                if modified and (not commenting):\n                    ans.append(modified)\n                    modified = ''\n            return ans\n    solution = Solution()\n    source = ['/* This is a block comment that spans multiple lines */', '/* This is another block comment */', 'public class Test { public static void main(String[] args) { System.out.println(\"Hello World!\"); /* This is a nested block comment */ } };']\n    expected = ['public class Test { public static void main(String[] args) { System.out.println(\"Hello World!\"); } }']\n    self.assertEqual(solution.removeComments(source), expected)", "def test_removeComments():\n\n    class Solution:\n\n        def removeComments(self, source: List[str]) -> List[str]:\n            ans = []\n            commenting = False\n            modified = ''\n            for line in source:\n                i = 0\n                while i < len(line):\n                    if i + 1 == len(line):\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                        break\n                    twoChars = line[i:i + 2]\n                    if twoChars == '/*' and (not commenting):\n                        commenting = True\n                        i += 2\n                    elif twoChars == '*/' and commenting:\n                        commenting = False\n                        i += 2\n                    elif twoChars == '//':\n                        if not commenting:\n                            break\n                        else:\n                            i += 2\n                    else:\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                if modified and (not commenting):\n                    ans.append(modified)\n                    modified = ''\n            return ans\n    solution = Solution()\n    source = ['public class Test { public static void main(String[] args) { System.out.println(\"Hello World!\"); /* This is a nested block comment */ // This is a line comment } };']\n    expected = ['public class Test { public static void main(String[] args) { System.out.println(\"Hello World!\"); } }']\n    self.assertEqual(solution.removeComments(source), expected)", "def test_removeComments():\n\n    class Solution:\n\n        def removeComments(self, source: List[str]) -> List[str]:\n            ans = []\n            commenting = False\n            modified = ''\n            for line in source:\n                i = 0\n                while i < len(line):\n                    if i + 1 == len(line):\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                        break\n                    twoChars = line[i:i + 2]\n                    if twoChars == '/*' and (not commenting):\n                        commenting = True\n                        i += 2\n                    elif twoChars == '*/' and commenting:\n                        commenting = False\n                        i += 2\n                    elif twoChars == '//':\n                        if not commenting:\n                            break\n                        else:\n                            i += 2\n                    else:\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                if modified and (not commenting):\n                    ans.append(modified)\n                    modified = ''\n            return ans\n    solution = Solution()\n    source = ['public class Test {', '  public static void main(String[] args) { System.out.println(\"Hello World!\"); /* This is a block comment */', '}']\n    expected = ['public class Test { public static void main(String[] args) { System.out.println(\"Hello World!\"); }']\n    self.assertEqual(solution.removeComments(source), expected)", "def test_removeComments():\n\n    class Solution:\n\n        def removeComments(self, source: List[str]) -> List[str]:\n            ans = []\n            commenting = False\n            modified = ''\n            for line in source:\n                i = 0\n                while i < len(line):\n                    if i + 1 == len(line):\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                        break\n                    twoChars = line[i:i + 2]\n                    if twoChars == '/*' and (not commenting):\n                        commenting = True\n                        i += 2\n                    elif twoChars == '*/' and commenting:\n                        commenting = False\n                        i += 2\n                    elif twoChars == '//':\n                        if not commenting:\n                            break\n                        else:\n                            i += 2\n                    else:\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                if modified and (not commenting):\n                    ans.append(modified)\n                    modified = ''\n            return ans\n    solution = Solution()\n    source = ['public class Test {', '  public static void main(String[] args) { System.out.println(\"Hello World!\"); /* This is a block comment */ /* This is another nested block comment */', '}']\n    expected = ['public class Test { public static void main(String[] args) { System.out.println(\"Hello World!\"); }']\n    self.assertEqual(solution.removeComments(source), expected)", "def test_removeComments():\n\n    class Solution:\n\n        def removeComments(self, source: List[str]) -> List[str]:\n            ans = []\n            commenting = False\n            modified = ''\n            for line in source:\n                i = 0\n                while i < len(line):\n                    if i + 1 == len(line):\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                        break\n                    twoChars = line[i:i + 2]\n                    if twoChars == '/*' and (not commenting):\n                        commenting = True\n                        i += 2\n                    elif twoChars == '*/' and commenting:\n                        commenting = False\n                        i += 2\n                    elif twoChars == '//':\n                        if not commenting:\n                            break\n                        else:\n                            i += 2\n                    else:\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                if modified and (not commenting):\n                    ans.append(modified)\n                    modified = ''\n            return ans\n    solution = Solution()\n    source = ['public class Test {', '  public static void main(String[] args) { System.out.println(\"Hello World!\"); /* This is a block comment */ System.out.println(\"// This is a line comment\" + \"/* This is another nested block comment */\");', '}']\n    expected = ['public class Test { public static void main(String[] args) { System.out.println(\"Hello World!\"); }']\n    self.assertEqual(solution.removeComments(source), expected)", "def test_removeComments():\n\n    class Solution:\n\n        def removeComments(self, source: List[str]) -> List[str]:\n            ans = []\n            commenting = False\n            modified = ''\n            for line in source:\n                i = 0\n                while i < len(line):\n                    if i + 1 == len(line):\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                        break\n                    twoChars = line[i:i + 2]\n                    if twoChars == '/*' and (not commenting):\n                        commenting = True\n                        i += 2\n                    elif twoChars == '*/' and commenting:\n                        commenting = False\n                        i += 2\n                    elif twoChars == '//':\n                        if not commenting:\n                            break\n                        else:\n                            i += 2\n                    else:\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                if modified and (not commenting):\n                    ans.append(modified)\n                    modified = ''\n            return ans\n    solution = Solution()\n    source = ['public class Test {', '  public static void main(String[] args) { System.out.println(\"Hello World!\"); /* This is a block comment */ /*// This is another nested block comment with line comment inside*/', '}']\n    expected = ['public class Test { public static void main(String[] args) { System.out.println(\"Hello World!\"); }']\n    self.assertEqual(solution.removeComments(source), expected)", "def test_removeComments():\n\n    class Solution:\n\n        def removeComments(self, source: List[str]) -> List[str]:\n            ans = []\n            commenting = False\n            modified = ''\n            for line in source:\n                i = 0\n                while i < len(line):\n                    if i + 1 == len(line):\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                        break\n                    twoChars = line[i:i + 2]\n                    if twoChars == '/*' and (not commenting):\n                        commenting = True\n                        i += 2\n                    elif twoChars == '*/' and commenting:\n                        commenting = False\n                        i += 2\n                    elif twoChars == '//':\n                        if not commenting:\n                            break\n                        else:\n                            i += 2\n                    else:\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                if modified and (not commenting):\n                    ans.append(modified)\n                    modified = ''\n            return ans\n    solution = Solution()\n    source = ['// This is a comment', 'public class Test { public static void main(String[] args) { System.out.println(\"Hello World!\"); /* This is a block comment */ } };']\n    expected = ['public class Test { public static void main(String[] args) { System.out.println(\"Hello World!\"); } }']\n    self.assertEqual(solution.removeComments(source), expected)", "def test_removeComments():\n\n    class Solution:\n\n        def removeComments(self, source: List[str]) -> List[str]:\n            ans = []\n            commenting = False\n            modified = ''\n            for line in source:\n                i = 0\n                while i < len(line):\n                    if i + 1 == len(line):\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                        break\n                    twoChars = line[i:i + 2]\n                    if twoChars == '/*' and (not commenting):\n                        commenting = True\n                        i += 2\n                    elif twoChars == '*/' and commenting:\n                        commenting = False\n                        i += 2\n                    elif twoChars == '//':\n                        if not commenting:\n                            break\n                        else:\n                            i += 2\n                    else:\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                if modified and (not commenting):\n                    ans.append(modified)\n                    modified = ''\n            return ans\n    solution = Solution()\n    source = ['public class Test {', '  public static void main(String[] args) { System.out.println(\"Hello World!\"); /* This is a block comment */ // This is another line comment }', '}']\n    expected = ['public class Test { public static void main(String[] args) { System.out.println(\"Hello World!\"); }']\n    self.assertEqual(solution.removeComments(source), expected)", "def test_removeComments():\n\n    class Solution:\n\n        def removeComments(self, source: List[str]) -> List[str]:\n            ans = []\n            commenting = False\n            modified = ''\n            for line in source:\n                i = 0\n                while i < len(line):\n                    if i + 1 == len(line):\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                        break\n                    twoChars = line[i:i + 2]\n                    if twoChars == '/*' and (not commenting):\n                        commenting = True\n                        i += 2\n                    elif twoChars == '*/' and commenting:\n                        commenting = False\n                        i += 2\n                    elif twoChars == '//':\n                        if not commenting:\n                            break\n                        else:\n                            i += 2\n                    else:\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                if modified and (not commenting):\n                    ans.append(modified)\n                    modified = ''\n            return ans\n    solution = Solution()\n    source = ['public class Test {', '  public static void main(String[] args) { System.out.println(\"Hello World!\"); /* This is a block comment */ // This is another line comment /* And yet another nested block comment */ }', '}']\n    expected = ['public class Test { public static void main(String[] args) { System.out.println(\"Hello World!\"); }']\n    self.assertEqual(solution.removeComments(source), expected)", "def test_removeComments():\n\n    class Solution:\n\n        def removeComments(self, source: List[str]) -> List[str]:\n            ans = []\n            commenting = False\n            modified = ''\n            for line in source:\n                i = 0\n                while i < len(line):\n                    if i + 1 == len(line):\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                        break\n                    twoChars = line[i:i + 2]\n                    if twoChars == '/*' and (not commenting):\n                        commenting = True\n                        i += 2\n                    elif twoChars == '*/' and commenting:\n                        commenting = False\n                        i += 2\n                    elif twoChars == '//':\n                        if not commenting:\n                            break\n                        else:\n                            i += 2\n                    else:\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                if modified and (not commenting):\n                    ans.append(modified)\n                    modified = ''\n            return ans\n    solution = Solution()\n    source = ['// This is a comment', 'public class Test { public static void main(String[] args) { System.out.println(\"Hello World!\"); /* This is a block comment */ // This is another line comment } };']\n    expected = ['public class Test { public static void main(String[] args) { System.out.println(\"Hello World!\"); } }']\n    self.assertEqual(solution.removeComments(source), expected)", "def test_removeComments():\n\n    class Solution:\n\n        def removeComments(self, source: List[str]) -> List[str]:\n            ans = []\n            commenting = False\n            modified = ''\n            for line in source:\n                i = 0\n                while i < len(line):\n                    if i + 1 == len(line):\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                        break\n                    twoChars = line[i:i + 2]\n                    if twoChars == '/*' and (not commenting):\n                        commenting = True\n                        i += 2\n                    elif twoChars == '*/' and commenting:\n                        commenting = False\n                        i += 2\n                    elif twoChars == '//':\n                        if not commenting:\n                            break\n                        else:\n                            i += 2\n                    else:\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                if modified and (not commenting):\n                    ans.append(modified)\n                    modified = ''\n            return ans\n    solution = Solution()\n    source = ['public class Test {', '  public static void main(String[] args) { System.out.println(\"Hello World!\"); /* This is a block comment */ // This is another line comment /* And yet another nested block comment */ }', '}']\n    expected = ['public class Test { public static void main(String[] args) { System.out.println(\"Hello World!\"); }']\n    self.assertEqual(solution.removeComments(source), expected)", "def test_removeComments():\n\n    class Solution:\n\n        def removeComments(self, source: List[str]) -> List[str]:\n            ans = []\n            commenting = False\n            modified = ''\n            for line in source:\n                i = 0\n                while i < len(line):\n                    if i + 1 == len(line):\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                        break\n                    twoChars = line[i:i + 2]\n                    if twoChars == '/*' and (not commenting):\n                        commenting = True\n                        i += 2\n                    elif twoChars == '*/' and commenting:\n                        commenting = False\n                        i += 2\n                    elif twoChars == '//':\n                        if not commenting:\n                            break\n                        else:\n                            i += 2\n                    else:\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                if modified and (not commenting):\n                    ans.append(modified)\n                    modified = ''\n            return ans\n    solution = Solution()\n    source = ['// This is a comment', 'public class Test { public static void main(String[] args) { System.out.println(\"Hello World!\"); /* This is a block comment */ // This is another line comment } };']\n    expected = ['public class Test { public static void main(String[] args) { System.out.println(\"Hello World!\"); } }']\n    self.assertEqual(solution.removeComments(source), expected)", "def test_removeComments():\n\n    class Solution:\n\n        def removeComments(self, source: List[str]) -> List[str]:\n            ans = []\n            commenting = False\n            modified = ''\n            for line in source:\n                i = 0\n                while i < len(line):\n                    if i + 1 == len(line):\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                        break\n                    twoChars = line[i:i + 2]\n                    if twoChars == '/*' and (not commenting):\n                        commenting = True\n                        i += 2\n                    elif twoChars == '*/' and commenting:\n                        commenting = False\n                        i += 2\n                    elif twoChars == '//':\n                        if not commenting:\n                            break\n                        else:\n                            i += 2\n                    else:\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                if modified and (not commenting):\n                    ans.append(modified)\n                    modified = ''\n            return ans\n    solution = Solution()\n    source = ['public class Test {', '  public static void main(String[] args) { System.out.println(\"Hello World!\"); /* This is a block comment */ // This is another line comment }', '}']\n    expected = ['public class Test { public static void main(String[] args) { System.out.println(\"Hello World!\"); }']\n    self.assertEqual(solution.removeComments(source), expected)", "def test_removeComments():\n\n    class Solution:\n\n        def removeComments(self, source: List[str]) -> List[str]:\n            ans = []\n            commenting = False\n            modified = ''\n            for line in source:\n                i = 0\n                while i < len(line):\n                    if i + 1 == len(line):\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                        break\n                    twoChars = line[i:i + 2]\n                    if twoChars == '/*' and (not commenting):\n                        commenting = True\n                        i += 2\n                    elif twoChars == '*/' and commenting:\n                        commenting = False\n                        i += 2\n                    elif twoChars == '//':\n                        if not commenting:\n                            break\n                        else:\n                            i += 2\n                    else:\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                if modified and (not commenting):\n                    ans.append(modified)\n                    modified = ''\n            return ans\n    solution = Solution()\n    source = ['public class Test {', '  public static void main(String[] args) { System.out.println(\"Hello World!\"); /* This is a block comment */ // This is another line comment /* And yet another nested block comment */ }', '}']\n    expected = ['public class Test { public static void main(String[] args) { System.out.println(\"Hello World!\"); }']\n    self.assertEqual(solution.removeComments(source), expected)", "def test_removeComments():\n\n    class Solution:\n\n        def removeComments(self, source: List[str]) -> List[str]:\n            ans = []\n            commenting = False\n            modified = ''\n            for line in source:\n                i = 0\n                while i < len(line):\n                    if i + 1 == len(line):\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                        break\n                    twoChars = line[i:i + 2]\n                    if twoChars == '/*' and (not commenting):\n                        commenting = True\n                        i += 2\n                    elif twoChars == '*/' and commenting:\n                        commenting = False\n                        i += 2\n                    elif twoChars == '//':\n                        if not commenting:\n                            break\n                        else:\n                            i += 2\n                    else:\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                if modified and (not commenting):\n                    ans.append(modified)\n                    modified = ''\n            return ans\n    solution = Solution()\n    source = ['// This is a comment', 'public class Test { public static void main(String[] args) { System.out.println(\"Hello World!\"); /* This is a block comment */ } };']\n    expected = ['public class Test { public static void main(String[] args) { System.out.println(\"Hello World!\"); } }']\n    self.assertEqual(solution.removeComments(source), expected)", "def test_removeComments():\n\n    class Solution:\n\n        def removeComments(self, source: List[str]) -> List[str]:\n            ans = []\n            commenting = False\n            modified = ''\n            for line in source:\n                i = 0\n                while i < len(line):\n                    if i + 1 == len(line):\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                        break\n                    twoChars = line[i:i + 2]\n                    if twoChars == '/*' and (not commenting):\n                        commenting = True\n                        i += 2\n                    elif twoChars == '*/' and commenting:\n                        commenting = False\n                        i += 2\n                    elif twoChars == '//':\n                        if not commenting:\n                            break\n                        else:\n                            i += 2\n                    else:\n                        if not commenting:\n                            modified += line[i]\n                        i += 1\n                if modified and (not commenting):\n                    ans.append(modified)\n                    modified = ''\n            return ans\n    solution = Solution()\n    source = ['public class Test {', '  public static void main(String[] args) { System.out.println(\"Hello World!\"); /* This is a block comment */ // This is another line comment }', '}']\n    expected = ['public class Test { public static void main(String[] args) { System.out.println(\"Hello World!\"); }']\n    self.assertEqual(solution.removeComments(source), expected)", "def test_no_comments():\n  class Solution:\n    def removeComments(self, source: List[str]) -> List[str]:\n      # implementation remains the same\n\n  solution = Solution()\n  source = [\"public class Test {\", \"  public static void main(String[] args) { System.out.println(\\\"Hello World!\\\"); }\", \"}\"]\n  expected = [\"public class Test {\", \"  public static void main(String[] args) { System.out.println(\\\"Hello World!\\\"); }\", \"}\"]\n  self.assertEqual(solution.removeComments(source), expected)"]}
{"task_num": 730, "task_title": "Count Different Palindromic Subsequences", "func_name": "countPalindromicSubsequences", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countPalindromicSubsequences(self, s: str) -> int:\n    kMod = 1_000_000_007\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n      dp[i][i] = 1\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        if s[i] == s[j]:\n          lo = i + 1\n          hi = j - 1\n          while lo <= hi and s[lo] != s[i]:\n            lo += 1\n          while lo <= hi and s[hi] != s[i]:\n            hi -= 1\n          if lo > hi:\n            dp[i][j] = dp[i + 1][j - 1] * 2 + 2\n          elif lo == hi:\n            dp[i][j] = dp[i + 1][j - 1] * 2 + 1\n          else:\n            dp[i][j] = dp[i + 1][j - 1] * 2 - dp[lo + 1][hi - 1]\n        else:\n          dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1]\n        dp[i][j] = (dp[i][j] + kMod) % kMod\n\n    return dp[0][n - 1]\n", "tests": ["def test_countPalindromicSubsequences():\n\n    class MockSolution(Solution):\n\n        def countPalindromicSubsequences(self, s: str) -> int:\n            return 0 if s == 'ab' else super().countPalindromicSubsequences(s)\n    solution = MockSolution()\n    assert solution.countPalindromicSubsequences('abcba') == (solution.countPalindromicSubsequences('a') + solution.countPalindromicSubsequences('c') - solution.countPalindromicSubsequences('b')) % (10 ** 9 + 7)", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('aba') == (2 + solution.countPalindromicSubsequences('a') * 2 - solution.countPalindromicSubsequences('aa')) % (10 ** 9 + 7)", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('aaa') == (solution.countPalindromicSubsequences('a') * 2 + 1) % (10 ** 9 + 7)", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('abacaba') == (solution.countPalindromicSubsequences('a') * solution.countPalindromicSubsequences('caba') + solution.countPalindromicSubsequences('baca')) % (10 ** 9 + 7)", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('') == 1 % (10 ** 9 + 7)", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('aabb') == (solution.countPalindromicSubsequences('aa') + solution.countPalindromicSubsequences('bb')) % (10 ** 9 + 7)", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('abcdef') == (solution.countPalindromicSubsequences('abcde') + solution.countPalindromicSubsequences('f')) % (10 ** 9 + 7)", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('abccba') == (solution.countPalindromicSubsequences('abc') + solution.countPalindromicSubsequences('cba')) % (10 ** 9 + 7)", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('aaaabbaaa') == (solution.countPalindromicSubsequences('aaaa') + solution.countPalindromicSubsequences('bbaa')) % (10 ** 9 + 7)", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('aab') == (solution.countPalindromicSubsequences('aa') + solution.countPalindromicSubsequences('b')) % (10 ** 9 + 7)", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('aaaa') == (solution.countPalindromicSubsequences('a') * solution.countPalindromicSubsequences('aaa') + 1) % (10 ** 9 + 7)", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('abc') == (solution.countPalindromicSubsequences('ab') + solution.countPalindromicSubsequences('c')) % (10 ** 9 + 7)", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('abcddcba') == (solution.countPalindromicSubsequences('abcd') + solution.countPalindromicSubsequences('dcba')) % (10 ** 9 + 7)", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('abccba') == (solution.countPalindromicSubsequences('abc') + solution.countPalindromicSubsequences('cba')) % (10 ** 9 + 7)", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('aba') == (solution.countPalindromicSubsequences('a') + solution.countPalindromicSubsequences('b') - solution.countPalindromicSubsequences('ab')) % (10 ** 9 + 7)", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('aabbcc') == (solution.countPalindromicSubsequences('ab') + solution.countPalindromicSubsequences('c')) % (10 ** 9 + 7)", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('abcddcba') == (solution.countPalindromicSubsequences('abccba') + solution.countPalindromicSubsequences('dcba')) % (10 ** 9 + 7)", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('aaa') == (solution.countPalindromicSubsequences('aa') * 2 + 1) % (10 ** 9 + 7)", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('abcdabcd') == (solution.countPalindromicSubsequences('abcd') + solution.countPalindromicSubsequences('dcba')) % (10 ** 9 + 7)", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('aaabaaa') == (solution.countPalindromicSubsequences('a') * solution.countPalindromicSubsequences('aaaaa') + 1) % (10 ** 9 + 7)"]}
{"task_num": 735, "task_title": "Asteroid Collision", "func_name": "asteroidCollision", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def asteroidCollision(self, asteroids: List[int]) -> List[int]:\n    stack = []\n\n    for a in asteroids:\n      if a > 0:\n        stack.append(a)\n      else:\n        while stack and stack[-1] > 0 and stack[-1] < -a:\n          stack.pop()\n        if not stack or stack[-1] < 0:\n          stack.append(a)\n        elif stack[-1] == -a:\n          stack.pop()\n        else:\n          pass\n\n    return stack\n", "tests": ["def test_asteroidCollision(self):\n    solution = Solution()\n    self.assertEqual(solution.asteroidCollision([5, 10, -5]), [-5])", "def test_asteroidCollision(self):\n    solution = Solution()\n    self.assertEqual(solution.asteroidCollision([8, -8]), [])", "def test_asteroidCollision(self):\n    solution = Solution()\n    self.assertEqual(solution.asteroidCollision([5, -5, 10]), [-5])", "def test_asteroidCollision(self):\n    solution = Solution()\n    self.assertEqual(solution.asteroidCollision([10, -5, -3, -5]), [-5])", "def test_asteroidCollision(self):\n    solution = Solution()\n    self.assertEqual(solution.asteroidCollision([3, -5, 0]), [-5])", "def test_asteroidCollision(self):\n    solution = Solution()\n    self.assertEqual(solution.asteroidCollision([1, -2, 1, -2]), [])", "def test_asteroidCollision(self):\n    solution = Solution()\n    self.assertEqual(solution.asteroidCollision([2, -1, 4]), [2])", "def test_asteroidCollision(self):\n    solution = Solution()\n    self.assertEqual(solution.asteroidCollision([5, -2, 5, -2]), [])", "def test_asteroidCollision(self):\n    solution = Solution()\n    self.assertEqual(solution.asteroidCollision([5, -3, -2, 8]), [-3])", "def test_asteroidCollision(self):\n    solution = Solution()\n    self.assertEqual(solution.asteroidCollision([10, -5, 5, 0]), [10])", "def test_asteroidCollision(self):\n    solution = Solution()\n    self.assertEqual(solution.asteroidCollision([10, -3, -10, 2]), [2])", "def test_asteroidCollision(self):\n    solution = Solution()\n    self.assertEqual(solution.asteroidCollision([-2, -1, 1, 2]), [])", "def test_asteroidCollision(self):\n    solution = Solution()\n    self.assertEqual(solution.asteroidCollision([5, -10, 2, 3]), [])", "def test_asteroidCollision(self):\n    solution = Solution()\n    self.assertEqual(solution.asteroidCollision([1, 2, 3, -4, -5]), [-4])", "def test_asteroidCollision(self):\n    solution = Solution()\n    self.assertEqual(solution.asteroidCollision([-2, -1, 1, 2]), [])", "def test_asteroidCollision(self):\n    solution = Solution()\n    self.assertEqual(solution.asteroidCollision([10, -5, -3, 2]), [-5])", "def test_asteroidCollision(self):\n    solution = Solution()\n    self.assertEqual(solution.asteroidCollision([5, -10, 2, 1]), [2])", "def test_asteroidCollision(self):\n    solution = Solution()\n    self.assertEqual(solution.asteroidCollision([-5, -10, -3, 2]), [])", "def test_asteroidCollision(self):\n    solution = Solution()\n    self.assertEqual(solution.asteroidCollision([1, -2, 1, -2, -3]), [-3])", "def test_asteroidCollision(self):\n    solution = Solution()\n    self.assertEqual(solution.asteroidCollision([-1, -2, 3, 4]), [3])"]}
{"task_num": 743, "task_title": "Network Delay Time", "func_name": "networkDelayTime", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in times:\n      graph[u - 1].append((v - 1, w))\n\n    return self._dijkstra(graph, k - 1)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int) -> int:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    maxDist = max(dist)\n    return maxDist if maxDist != math.inf else -1\n", "tests": ["def test_networkDelayTime(self):\n    solution = Solution()\n    times = [[2, 1, 1], [3, 2, 1], [4, 2, 1]]\n    n = 4\n    k = 2\n    self.assertEqual(solution.networkDelayTime(times, n, k), 2)", "def test_networkDelayTime(self):\n    solution = Solution()\n    times = [[1, 2, 1], [2, 3, 1], [3, 4, 1]]\n    n = 4\n    k = 1\n    self.assertEqual(solution.networkDelayTime(times, n, k), -1)", "def test_networkDelayTime(self):\n    solution = Solution()\n    times = []\n    n = 4\n    k = 1\n    self.assertEqual(solution.networkDelayTime(times, n, k), -1)", "def test_networkDelayTime(self):\n    solution = Solution()\n    times = [[1, 2, 5], [2, 3, 4], [3, 1, 2]]\n    n = 3\n    k = 1\n    self.assertEqual(solution.networkDelayTime(times, n, k), 6)", "def test_networkDelayTime(self):\n    solution = Solution()\n    times = [[1, 2, 10], [2, 3, 10]]\n    n = 3\n    k = 1\n    self.assertEqual(solution.networkDelayTime(times, n, k), 10)", "def test_networkDelayTime(self):\n    solution = Solution()\n    times = [[1, 2, 5], [2, 3, 4]]\n    n = 0\n    k = 1\n    self.assertEqual(solution.networkDelayTime(times, n, k), -1)", "def test_networkDelayTime(self):\n    solution = Solution()\n    times = []\n    n = 1\n    k = 1\n    self.assertEqual(solution.networkDelayTime(times, n, k), 0)", "def test_networkDelayTime(self):\n    solution = Solution()\n    times = [[1, 2, 10], [2, 3, 10]]\n    n = 100000\n    k = 1\n    self.assertEqual(solution.networkDelayTime(times, n, k), -1)", "def test_networkDelayTime(self):\n    solution = Solution()\n    times = [[1, 2, 5], [2, 3, 4]]\n    n = 3\n    k = 4\n    self.assertEqual(solution.networkDelayTime(times, n, k), -1)", "def test_networkDelayTime(self):\n    solution = Solution()\n    times = [[1, 2, 10], [2, 3, 5]]\n    n = 3\n    k = 3\n    self.assertEqual(solution.networkDelayTime(times, n, k), -1)", "def test_networkDelayTime(self):\n    solution = Solution()\n    times = [[1, 2, 10], [2, 3, 5]]\n    n = 1000\n    k = 100000\n    self.assertEqual(solution.networkDelayTime(times, n, k), -1)", "def test_networkDelayTime(self):\n    solution = Solution()\n    times = [[i, i + 1, 10] for i in range(100000)]\n    n = 100001\n    k = 100000\n    self.assertEqual(solution.networkDelayTime(times, n, k), -1)", "def test_networkDelayTime(self):\n    solution = Solution()\n    times = [[1, 2, 2147483647]]\n    n = 2\n    k = 1\n    self.assertEqual(solution.networkDelayTime(times, n, k), -1)", "def test_networkDelayTime(self):\n    solution = Solution()\n    times = [[1, 2, 10], [2, 3, 5]]\n    n = 3\n    k = 1\n    self.assertEqual(solution.networkDelayTime(times, n, k), 5)", "def test_networkDelayTime(self):\n    solution = Solution()\n    times = [[1, 2, 5], [2, 3, 4], [3, 1, 10]]\n    n = 3\n    k = 1\n    self.assertEqual(solution.networkDelayTime(times, n, k), -1)", "def test_networkDelayTime(self):\n    solution = Solution()\n    times = []\n    n = 100000\n    k = 1\n    self.assertEqual(solution.networkDelayTime(times, n, k), -1)", "def test_networkDelayTime(self):\n    solution = Solution()\n    times = [[1, 2, -10]]\n    n = 2\n    k = 1\n    self.assertEqual(solution.networkDelayTime(times, n, k), -1)", "def test_networkDelayTime(self):\n    solution = Solution()\n    times = [[1, 2, 10], [2, 3, 10]]\n    n = 3\n    k = 1\n    self.assertEqual(solution.networkDelayTime(times, n, k), 10)", "def test_networkDelayTime(self):\n    solution = Solution()\n    times = [[1, 2, -2147483648]]\n    n = 2\n    k = 1\n    self.assertEqual(solution.networkDelayTime(times, n, k), -1)", "def test_networkDelayTime(self):\n    solution = Solution()\n    times = [[i, i + 1, 10] for i in range(100000)]\n    n = 100001\n    k = 100000\n    self.assertEqual(solution.networkDelayTime(times, n, k), -1)"]}
{"task_num": 770, "task_title": "Basic Calculator IV", "func_name": "basicCalculatorIV", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Poly:\n  def __init__(self, term: str = None, coef: int = None):\n    if term and coef:\n      self.terms = collections.Counter({term: coef})\n    else:\n      self.terms = collections.Counter()\n\n  def __add__(self, other):\n    for term, coef in other.terms.items():\n      self.terms[term] += coef\n    return self\n\n  def __sub__(self, other):\n    for term, coef in other.terms.items():\n      self.terms[term] -= coef\n    return self\n\n  def __mul__(self, other):\n    res = Poly()\n    for a, aCoef in self.terms.items():\n      for b, bCoef in other.terms.items():\n        res.terms[self._merge(a, b)] += aCoef * bCoef\n    return res\n\n  def toList(self) -> List[str]:\n    for term in list(self.terms.keys()):\n      if not self.terms[term]:\n        del self.terms[term]\n\n    def cmp(term: str) -> tuple:\n      if term == '1':\n        return (0,)\n      var = term.split('*')\n      return (-len(var), term)\n\n    def concat(term: str) -> str:\n      if term == '1':\n        return str(self.terms[term])\n      return str(self.terms[term]) + '*' + term\n\n    terms = list(self.terms.keys())\n    terms.sort(key=cmp)\n    return [concat(term) for term in terms]\n\n  def _merge(self, a: str, b: str) -> str:\n    if a == '1':\n      return b\n    if b == '1':\n      return a\n    res = []\n    A = a.split('*')\n    B = b.split('*')\n    i = 0\n    j = 0\n    while i < len(A) and j < len(B):\n      if A[i] < B[j]:\n        res.append(A[i])\n        i += 1\n      else:\n        res.append(B[j])\n        j += 1\n    return '*'.join(res + A[i:] + B[j:])\n\n\nclass Solution:\n  def basicCalculatorIV(self, expression: str, evalvars: List[str], evalints: List[int]) -> List[str]:\n    tokens = list(self._getTokens(expression))\n    evalMap = {a: b for a, b in zip(evalvars, evalints)}\n\n    for i, token in enumerate(tokens):\n      if token in evalMap:\n        tokens[i] = str(evalMap[token])\n\n    postfix = self._infixToPostfix(tokens)\n    return self._evaluate(postfix).toList()\n\n  def _getTokens(self, s: str) -> Iterator[str]:\n    i = 0\n    for j, c in enumerate(s):\n      if c == ' ':\n        if i < j:\n          yield s[i:j]\n        i = j + 1\n      elif c in '()+-*':\n        if i < j:\n          yield s[i:j]\n        yield c\n        i = j + 1\n    if i < len(s):\n      yield s[i:]\n\n  def _infixToPostfix(self, tokens: List[str]) -> List[str]:\n    postfix = []\n    ops = []\n\n    def precedes(prevOp: str, currOp: str) -> bool:\n      if prevOp == '(':\n        return False\n      return prevOp == '*' or currOp in '+-'\n\n    for token in tokens:\n      if token == '(':\n        ops.append(token)\n      elif token == ')':\n        while ops[-1] != '(':\n          postfix.append(ops.pop())\n        ops.pop()\n      elif token in '+-*':\n        while ops and precedes(ops[-1], token):\n          postfix.append(ops.pop())\n        ops.append(token)\n      else:\n        postfix.append(token)\n    return postfix + ops[::-1]\n\n  def _evaluate(self, postfix: List[str]) -> Poly:\n    polys: List[Poly] = []\n    for token in postfix:\n      if token in '+-*':\n        b = polys.pop()\n        a = polys.pop()\n        if token == '+':\n          polys.append(a + b)\n        elif token == '-':\n          polys.append(a - b)\n        else:\n          polys.append(a * b)\n      elif token.lstrip('-').isnumeric():\n        polys.append(Poly(\"1\", int(token)))\n      else:\n        polys.append(Poly(token, 1))\n    return polys[0]\n", "tests": ["def test_basicCalculatorIV():\n    solution = Solution()\n    print(solution.basicCalculatorIV('a+b+c-d', ['a', 'b', 'c'], [2, 3, -4]))", "def test_basicCalculatorIV():\n    solution = Solution()\n    print(solution.basicCalculatorIV('(a+b)*(c+d)', ['a', 'b'], [1, 2]))", "def test_basicCalculatorIV():\n    solution = Solution()\n    print(solution.basicCalculatorIV('a*a*b+c', ['a'], [2]))", "def test_basicCalculatorIV():\n    solution = Solution()\n    print(solution.basicCalculatorIV('e+f-g', ['e', 'f'], [1, 2]))", "def test_basicCalculatorIV():\n    solution = Solution()\n    print(solution.basicCalculatorIV('0', [], [0]))", "def test_basicCalculatorIV():\n    solution = Solution()\n    print(solution.basicCalculatorIV('a*a+a', ['a'], [2]))", "def test_basicCalculatorIV():\n    solution = Solution()\n    print(solution.basicCalculatorIV('a-b+a', ['a'], [1]))", "def test_basicCalculatorIV():\n    solution = Solution()\n    print(solution.basicCalculatorIV('a+b', ['a'], [1]))", "def test_basicCalculatorIV():\n    solution = Solution()\n    print(solution.basicCalculatorIV('a*a*b', ['b'], [1]))", "def test_basicCalculatorIV():\n    solution = Solution()\n    print(solution.basicCalculatorIV('a-b-c+d', ['a'], [1]))", "def test_basicCalculatorIV():\n    solution = Solution()\n    print(solution.basicCalculatorIV('e*e-f', ['e'], [2]))", "def test_basicCalculatorIV():\n    solution = Solution()\n    print(solution.basicCalculatorIV('a*a*b+c+d-e', ['a'], [2]))", "def test_basicCalculatorIV():\n    solution = Solution()\n    print(solution.basicCalculatorIV('a*a*b*c-d+e+f-g', ['a'], [1]))", "def test_basicCalculatorIV():\n    solution = Solution()\n    print(solution.basicCalculatorIV('0+1', ['x'], [0]))", "def test_basicCalculatorIV():\n    solution = Solution()\n    print(solution.basicCalculatorIV('1+2*3', [], [0]))", "def test_basicCalculatorIV():\n    solution = Solution()\n    print(solution.basicCalculatorIV('(a+b)*(c+d)+e', ['a', 'b'], [1]))", "def test_basicCalculatorIV():\n    solution = Solution()\n    print(solution.basicCalculatorIV('a+b+c+d+e+f', ['a'], [1]))", "def test_basicCalculatorIV():\n    solution = Solution()\n    print(solution.basicCalculatorIV('e+f+g+h+i+j+k+l+m+n', ['e'], [1]))", "def test_basicCalculatorIV():\n    solution = Solution()\n    print(solution.basicCalculatorIV('a*a*b+a-a+a', ['a'], [2]))", "def test_basicCalculatorIV():\n    solution = Solution()\n    print(solution.basicCalculatorIV('0+1-2', [], [0]))"]}
{"task_num": 777, "task_title": "Swap Adjacent in LR String", "func_name": "canTransform", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def canTransform(self, start: str, end: str) -> bool:\n    if start.replace('X', '') != end.replace('X', ''):\n      return False\n\n    i = 0\n    j = 0\n\n    while i < len(start) and j < len(end):\n      while i < len(start) and start[i] == 'X':\n        i += 1\n      while j < len(end) and end[j] == 'X':\n        j += 1\n      if i == len(start) and j == len(end):\n        return True\n      if i == len(start) or j == len(end):\n        return False\n      if start[i] == 'L' and i < j:\n        return False\n      if start[i] == 'R' and i > j:\n        return False\n      i += 1\n      j += 1\n\n    return True\n", "tests": ["def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('RXXLRXRXL', 'XRLXXRRLX') == True", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('XL', 'LR') == False", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('X', 'X') == True", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('L', 'R') == False", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('XXXX', 'XXXX') == True", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('LR', 'XR') == True", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('LR', 'LX') == False", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('RXXLRXL', 'XRXLLRX') == False", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('', '') == True", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('XLX', 'LXX') == True", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('RL', 'LR') == True", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('XXLX', 'XLXX') == True", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('RX', 'XR') == True", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('LLRXLRXL', 'LXRXXRRL') == True", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('XRX', 'XXR') == False", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('RLRXLRXL', 'XRXLLRXL') == False", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('XXXXRX', 'XXRRX') == False", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('LRXLXXRXL', 'XRXXLXRX') == False", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('RXLXRXLR', 'LXRXXRLX') == True", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('RXLRXLX', 'XRLLRXL') == True"]}
{"task_num": 782, "task_title": "Transform to Chessboard", "func_name": "movesToChessboard", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def movesToChessboard(self, board: List[List[int]]) -> int:\n    n = len(board)\n\n    for i in range(n):\n      for j in range(n):\n        if board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]:\n          return -1\n\n    rowSum = sum(board[0])\n    colSum = sum(board[i][0] for i in range(n))\n\n    if rowSum != n // 2 and rowSum != (n + 1) // 2:\n      return -1\n    if colSum != n // 2 and colSum != (n + 1) // 2:\n      return -1\n\n    rowSwaps = sum(board[i][0] == (i & 1) for i in range(n))\n    colSwaps = sum(board[0][i] == (i & 1) for i in range(n))\n\n    if n & 1:\n      if rowSwaps & 1:\n        rowSwaps = n - rowSwaps\n      if colSwaps & 1:\n        colSwaps = n - colSwaps\n    else:\n      rowSwaps = min(rowSwaps, n - rowSwaps)\n      colSwaps = min(colSwaps, n - colSwaps)\n\n    return (rowSwaps + colSwaps) // 2\n", "tests": ["def test_movesToChessboard():\n    solution = Solution()\n    board = [[0, 1, 1, 0], [1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 0, 1]]\n    assert solution.movesToChessboard(board) == 2", "def test_movesToChessboard():\n    solution = Solution()\n    board = [[1, 1, 0, 0], [0, 0, 1, 1], [1, 1, 0, 0], [0, 0, 1, 1]]\n    assert solution.movesToChessboard(board) == -1", "def test_movesToChessboard():\n    solution = Solution()\n    board = [[0, 0, 1, 1], [1, 1, 0, 0], [1, 1, 0, 0], [0, 0, 1, 1]]\n    assert solution.movesToChessboard(board) == -1", "def test_movesToChessboard():\n    solution = Solution()\n    board = [[0] * 4 + [1] * 4, [0] * 2 + [1] * 2 + [0] * 2 + [1] * 2, [0, 0, 1, 1], [1, 1, 0, 0]]\n    assert solution.movesToChessboard(board) == -1", "def test_movesToChessboard():\n    solution = Solution()\n    board = [[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 1]]\n    assert solution.movesToChessboard(board) == -1", "def test_movesToChessboard():\n    solution = Solution()\n    board = [[0] * 3 + [1], [1] + [0] * 3, [0] * 4, [1] * 4]\n    assert solution.movesToChessboard(board) == -1", "def test_movesToChessboard():\n    solution = Solution()\n    board = [[0, 0, 1, 1], [0, 0, 1, 1], [1, 1, 0, 0], [1, 1, 0, 0]]\n    assert solution.movesToChessboard(board) == -1", "def test_movesToChessboard():\n    solution = Solution()\n    board = [[0] * 5, [1] + [0] * 4, [0, 1, 0, 0, 1], [0, 1, 1, 0, 1], [0, 0, 1, 1, 0]]\n    assert solution.movesToChessboard(board) == -1", "def test_movesToChessboard():\n    solution = Solution()\n    board = [[0] * 8, [1] + [0] * 7, [1, 1, 0, 0, 0, 0, 0, 1], [0, 1, 1, 0, 0, 0, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0], [0, 0, 0, 0, 1, 1, 1, 1], [1, 1, 0, 0, 1, 1, 0, 0], [0, 0, 1, 1, 0, 0, 1, 1]]\n    assert solution.movesToChessboard(board) == -1", "def test_movesToChessboard():\n    solution = Solution()\n    board = [[0] * 9, [1] + [0] * 8, [1, 0, 0, 1, 0, 0, 0, 0, 1], [0, 1, 1, 0, 1, 1, 0, 0, 1], [1, 0, 1, 0, 1, 0, 1, 1, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1], [1, 1, 0, 0, 1, 1, 0, 0, 1], [0, 0, 1, 1, 0, 0, 1, 1, 1], [1, 1, 0, 0, 0, 0, 1, 1, 0]]\n    assert solution.movesToChessboard(board) == -1", "def test_movesToChessboard():\n    solution = Solution()\n    board = [[0] * 10, [1] + [0] * 9, [1, 1, 0, 1, 0, 0, 1, 0, 0, 1], [0, 1, 1, 0, 1, 1, 0, 1, 1, 0], [1, 0, 1, 0, 1, 0, 1, 0, 1, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1], [1, 1, 0, 0, 1, 1, 0, 0, 1, 1], [0, 0, 1, 1, 0, 0, 1, 1, 0, 0], [1, 1, 0, 0, 0, 0, 1, 1, 0, 1], [0, 0, 1, 1, 1, 1, 0, 0, 1, 0]]\n    assert solution.movesToChessboard(board) == -1", "def test_movesToChessboard():\n    solution = Solution()\n    board = [[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 0], [0, 0, 1, 1]]\n    assert solution.movesToChessboard(board) == 2", "def test_movesToChessboard():\n    solution = Solution()\n    board = [[1] * 5, [0] + [1] * 4, [0, 1, 0, 0, 1], [0, 1, 1, 0, 1], [1, 0, 1, 0, 0]]\n    assert solution.movesToChessboard(board) == -1", "def test_movesToChessboard():\n    solution = Solution()\n    board = [[0, 1, 0, 0], [1, 0, 1, 0], [0, 0, 1, 1], [0, 0, 0, 1]]\n    assert solution.movesToChessboard(board) == -1", "def test_movesToChessboard():\n    solution = Solution()\n    board = [[0] * 3 + [1], [1] + [0] * 3, [1, 0, 0, 1], [0, 1, 1, 0]]\n    assert solution.movesToChessboard(board) == -1", "def test_movesToChessboard():\n    solution = Solution()\n    board = [[0] * 4 + [1], [1] + [0] * 3, [0, 1, 0, 0, 1], [1, 0, 1, 0, 0]]\n    assert solution.movesToChessboard(board) == -1", "def test_movesToChessboard():\n    solution = Solution()\n    board = [[0] * 5 + [1], [1] + [0] * 4, [1, 0, 1, 0, 0], [0, 1, 0, 1, 0], [1, 0, 1, 0, 0]]\n    assert solution.movesToChessboard(board) == -1", "def test_movesToChessboard():\n    solution = Solution()\n    board = [[0] * 6 + [1], [1] + [0] * 5, [0, 1, 0, 0, 1, 0], [1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 1, 0]]\n    assert solution.movesToChessboard(board) == -1", "def test_movesToChessboard():\n    solution = Solution()\n    board = [[0] * 7 + [1], [1] + [0] * 6, [1, 0, 1, 0, 1, 0, 0], [0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 1, 0], [1, 0, 1, 0, 1, 0, 0], [0, 1, 0, 1, 0, 1, 0]]\n    assert solution.movesToChessboard(board) == -1", "def test_movesToChessboard():\n    solution = Solution()\n    board = [[0] * 8 + [1], [1] + [0] * 7, [0, 1, 0, 0, 1, 0, 0, 0], [1, 0, 1, 0, 0, 1, 0, 0], [0, 1, 0, 1, 0, 0, 1, 0], [0, 0, 1, 0, 1, 0, 0, 1], [1, 0, 0, 1, 0, 1, 0, 0], [0, 1, 0, 0, 1, 0, 1, 0]]\n    assert solution.movesToChessboard(board) == -1"]}
{"task_num": 786, "task_title": "K-th Smallest Prime Fraction", "func_name": "kthSmallestPrimeFraction", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\n    n = len(arr)\n    ans = [0, 1]\n    l = 0\n    r = 1\n\n    while True:\n      m = (l + r) / 2\n      ans[0] = 0\n      count = 0\n      j = 1\n\n      for i in range(n):\n        while j < n and arr[i] > m * arr[j]:\n          j += 1\n        count += n - j\n        if j == n:\n          break\n        if ans[0] * arr[j] < ans[1] * arr[i]:\n          ans[0] = arr[i]\n          ans[1] = arr[j]\n\n      if count < k:\n        l = m\n      elif count > k:\n        r = m\n      else:\n        return ans\n", "tests": ["def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    arr = [1, 7, 11, 13, 17]\n    k = 18\n    print(solution.kthSmallestPrimeFraction(arr, k))", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    arr = [1, 2, 3, 4]\n    k = 3\n    print(solution.kthSmallestPrimeFraction(arr, k))", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    arr = [1, 2, 3]\n    k = 5\n    print(solution.kthSmallestPrimeFraction(arr, k))", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    arr = [1]\n    k = 2\n    print(solution.kthSmallestPrimeFraction(arr, k))", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    arr = [1, 4]\n    k = 7\n    print(solution.kthSmallestPrimeFraction(arr, k))", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    arr = [1]\n    k = 1\n    print(solution.kthSmallestPrimeFraction(arr, k))", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    arr = [1, 7]\n    k = 10\n    print(solution.kthSmallestPrimeFraction(arr, k))", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    arr = [23, 17, 13, 11]\n    k = 3\n    print(solution.kthSmallestPrimeFraction(arr, k))", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    arr = [1, 5]\n    k = 4\n    print(solution.kthSmallestPrimeFraction(arr, k))", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    arr = [7]\n    k = 2\n    print(solution.kthSmallestPrimeFraction(arr, k))", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    arr = [1]\n    k = 10000\n    print(solution.kthSmallestPrimeFraction(arr, k))", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    arr = [1, 2]\n    k = 100000\n    print(solution.kthSmallestPrimeFraction(arr, k))", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    arr = [1, 3, 5, 7]\n    k = 10\n    print(solution.kthSmallestPrimeFraction(arr, k))", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    arr = [1, 13]\n    k = 2\n    print(solution.kthSmallestPrimeFraction(arr, k))", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    arr = [1, 2]\n    k = 1000\n    print(solution.kthSmallestPrimeFraction(arr, k))", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    arr = [1]\n    k = 10000000\n    print(solution.kthSmallestPrimeFraction(arr, k))", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    arr = [1, 1000, 10000]\n    k = 100000\n    print(solution.kthSmallestPrimeFraction(arr, k))", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    arr = [1, 2, 3, 4, 5]\n    k = 1000000\n    print(solution.kthSmallestPrimeFraction(arr, k))", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    arr = [1]\n    k = 3\n    print(solution.kthSmallestPrimeFraction(arr, k))", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    arr = [1]\n    k = 10000000\n    print(solution.kthSmallestPrimeFraction(arr, k))"]}
{"task_num": 787, "task_title": "Cheapest Flights Within K Stops", "func_name": "findCheapestPrice", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in flights:\n      graph[u].append((v, w))\n\n    return self._dijkstra(graph, src, dst, k)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, k: int) -> int:\n    dist=[]\n    for i in range(len(graph)):\n      dist.append([math.inf for _ in range(k + 2)])\n\n    dist[src][k + 1] = 0\n    minHeap = [(dist[src][k + 1], src, k + 1)]\n\n    while minHeap:\n      d, u, stops = heapq.heappop(minHeap)\n      if u == dst:\n        return d\n      if stops == 0 or d > dist[u][stops]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v][stops - 1]:\n          dist[v][stops - 1] = d + w\n          heapq.heappush(minHeap, (dist[v][stops - 1], v, stops - 1))\n\n    return -1\n", "tests": ["def test_findCheapestPrice(self):\n\n    class Solution:\n\n        def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in flights:\n                graph[u].append((v, w))\n            return self._dijkstra(graph, src, dst, k)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, k: int) -> int:\n            dist = []\n            for i in range(len(graph)):\n                dist.append([math.inf for _ in range(k + 2)])\n            dist[src][k + 1] = 0\n            minHeap = [(dist[src][k + 1], src, k + 1)]\n            while minHeap:\n                (d, u, stops) = heapq.heappop(minHeap)\n                if u == dst:\n                    return d\n                if stops == 0 or d > dist[u][stops]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < dist[v][stops - 1]:\n                        dist[v][stops - 1] = d + w\n                        heapq.heappush(minHeap, (dist[v][stops - 1], v, stops - 1))\n            return -1\n    solution = Solution()\n    self.assertEqual(solution.findCheapestPrice(3, [[0, 1, 100], [1, 2, 100]], 0, 2, 1), 200)", "def test_findCheapestPrice(self):\n\n    class Solution:\n\n        def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in flights:\n                graph[u].append((v, w))\n            return self._dijkstra(graph, src, dst, k)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, k: int) -> int:\n            dist = []\n            for i in range(len(graph)):\n                dist.append([math.inf for _ in range(k + 2)])\n            dist[src][k + 1] = 0\n            minHeap = [(dist[src][k + 1], src, k + 1)]\n            while minHeap:\n                (d, u, stops) = heapq.heappop(minHeap)\n                if u == dst:\n                    return d\n                if stops == 0 or d > dist[u][stops]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < dist[v][stops - 1]:\n                        dist[v][stops - 1] = d + w\n                        heapq.heappush(minHeap, (dist[v][stops - 1], v, stops - 1))\n            return -1\n    solution = Solution()\n    self.assertEqual(solution.findCheapestPrice(3, [[0, 1, 100], [1, 2, 100]], 0, 2, 2), 200)", "def test_findCheapestPrice(self):\n\n    class Solution:\n\n        def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in flights:\n                graph[u].append((v, w))\n            return self._dijkstra(graph, src, dst, k)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, k: int) -> int:\n            dist = []\n            for i in range(len(graph)):\n                dist.append([math.inf for _ in range(k + 2)])\n            dist[src][k + 1] = 0\n            minHeap = [(dist[src][k + 1], src, k + 1)]\n            while minHeap:\n                (d, u, stops) = heapq.heappop(minHeap)\n                if u == dst:\n                    return d\n                if stops == 0 or d > dist[u][stops]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < dist[v][stops - 1]:\n                        dist[v][stops - 1] = d + w\n                        heapq.heappush(minHeap, (dist[v][stops - 1], v, stops - 1))\n            return -1\n    solution = Solution()\n    self.assertEqual(solution.findCheapestPrice(3, [[0, 1, 100], [1, 2, 100]], 0, 2, 2), 200)", "def test_findCheapestPrice(self):\n\n    class Solution:\n\n        def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in flights:\n                graph[u].append((v, w))\n            return self._dijkstra(graph, src, dst, k)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, k: int) -> int:\n            dist = []\n            for i in range(len(graph)):\n                dist.append([math.inf for _ in range(k + 2)])\n            dist[src][k + 1] = 0\n            minHeap = [(dist[src][k + 1], src, k + 1)]\n            while minHeap:\n                (d, u, stops) = heapq.heappop(minHeap)\n                if u == dst:\n                    return d\n                if stops == 0 or d > dist[u][stops]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < dist[v][stops - 1]:\n                        dist[v][stops - 1] = d + w\n                        heapq.heappush(minHeap, (dist[v][stops - 1], v, stops - 1))\n            return -1\n    solution = Solution()\n    self.assertEqual(solution.findCheapestPrice(3, [[0, 1, 100], [1, 2, 100]], 0, 2, 2), 200)", "def test_findCheapestPrice(self):\n\n    class Solution:\n\n        def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in flights:\n                graph[u].append((v, w))\n            return self._dijkstra(graph, src, dst, k)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, k: int) -> int:\n            dist = []\n            for i in range(len(graph)):\n                dist.append([math.inf for _ in range(k + 2)])\n            dist[src][k + 1] = 0\n            minHeap = [(dist[src][k + 1], src, k + 1)]\n            while minHeap:\n                (d, u, stops) = heapq.heappop(minHeap)\n                if u == dst:\n                    return d\n                if stops == 0 or d > dist[u][stops]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < dist[v][stops - 1]:\n                        dist[v][stops - 1] = d + w\n                        heapq.heappush(minHeap, (dist[v][stops - 1], v, stops - 1))\n            return -1\n    solution = Solution()\n    self.assertEqual(solution.findCheapestPrice(3, [[0, 1, -100], [1, 2, -100]], 0, 2, 2), 100)", "def test_findCheapestPrice(self):\n\n    class Solution:\n\n        def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in flights:\n                graph[u].append((v, w))\n            return self._dijkstra(graph, src, dst, k)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, k: int) -> int:\n            dist = []\n            for i in range(len(graph)):\n                dist.append([math.inf for _ in range(k + 2)])\n            dist[src][k + 1] = 0\n            minHeap = [(dist[src][k + 1], src, k + 1)]\n            while minHeap:\n                (d, u, stops) = heapq.heappop(minHeap)\n                if u == dst:\n                    return d\n                if stops == 0 or d > dist[u][stops]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < dist[v][stops - 1]:\n                        dist[v][stops - 1] = d + w\n                        heapq.heappush(minHeap, (dist[v][stops - 1], v, stops - 1))\n            return -1\n    solution = Solution()\n    self.assertEqual(solution.findCheapestPrice(3, [[0, 1, -100], [1, 2, -100]], 0, 2, 2), 100)", "def test_findCheapestPrice(self):\n\n    class Solution:\n\n        def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in flights:\n                graph[u].append((v, w))\n            return self._dijkstra(graph, src, dst, k)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, k: int) -> int:\n            dist = []\n            for i in range(len(graph)):\n                dist.append([math.inf for _ in range(k + 2)])\n            dist[src][k + 1] = 0\n            minHeap = [(dist[src][k + 1], src, k + 1)]\n            while minHeap:\n                (d, u, stops) = heapq.heappop(minHeap)\n                if u == dst:\n                    return d\n                if stops == 0 or d > dist[u][stops]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < dist[v][stops - 1]:\n                        dist[v][stops - 1] = d + w\n                        heapq.heappush(minHeap, (dist[v][stops - 1], v, stops - 1))\n            return -1\n    solution = Solution()\n    self.assertEqual(solution.findCheapestPrice(10, [[0, 1, -100], [0, 2, -100], [1, 3, -100]], 0, 9, 9), 300)", "def test_findCheapestPrice(self):\n\n    class Solution:\n\n        def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in flights:\n                graph[u].append((v, w))\n            return self._dijkstra(graph, src, dst, k)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, k: int) -> int:\n            dist = []\n            for i in range(len(graph)):\n                dist.append([math.inf for _ in range(k + 2)])\n            dist[src][k + 1] = 0\n            minHeap = [(dist[src][k + 1], src, k + 1)]\n            while minHeap:\n                (d, u, stops) = heapq.heappop(minHeap)\n                if u == dst:\n                    return d\n                if stops == 0 or d > dist[u][stops]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < dist[v][stops - 1]:\n                        dist[v][stops - 1] = d + w\n                        heapq.heappush(minHeap, (dist[v][stops - 1], v, stops - 1))\n            return -1\n    solution = Solution()\n    self.assertEqual(solution.findCheapestPrice(10, [[0, 1, -100], [6, 9, -5]], 0, 9, 2), -200)", "def test_findCheapestPrice(self):\n\n    class Solution:\n\n        def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in flights:\n                graph[u].append((v, w))\n            return self._dijkstra(graph, src, dst, k)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, k: int) -> int:\n            dist = []\n            for i in range(len(graph)):\n                dist.append([math.inf for _ in range(k + 2)])\n            dist[src][k + 1] = 0\n            minHeap = [(dist[src][k + 1], src, k + 1)]\n            while minHeap:\n                (d, u, stops) = heapq.heappop(minHeap)\n                if u == dst:\n                    return d\n                if stops == 0 or d > dist[u][stops]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < dist[v][stops - 1]:\n                        dist[v][stops - 1] = d + w\n                        heapq.heappush(minHeap, (dist[v][stops - 1], v, stops - 1))\n            return -1\n    solution = Solution()\n    self.assertEqual(solution.findCheapestPrice(10, [], 0, 9, 2), math.inf)", "def test_findCheapestPrice(self):\n\n    class Solution:\n\n        def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in flights:\n                graph[u].append((v, w))\n            return self._dijkstra(graph, src, dst, k)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, k: int) -> int:\n            dist = []\n            for i in range(len(graph)):\n                dist.append([math.inf for _ in range(k + 2)])\n            dist[src][k + 1] = 0\n            minHeap = [(dist[src][k + 1], src, k + 1)]\n            while minHeap:\n                (d, u, stops) = heapq.heappop(minHeap)\n                if u == dst:\n                    return d\n                if stops == 0 or d > dist[u][stops]:\n                    continue\n                for (v, w) in graph[u]:\n                    if w < 0:\n                        continue\n                    if d + w < dist[v][stops - 1]:\n                        dist[v][stops - 1] = d + w\n                        heapq.heappush(minHeap, (dist[v][stops - 1], v, stops - 1))\n            return -1\n    solution = Solution()\n    self.assertEqual(solution.findCheapestPrice(10, [[0, 1, -100], [6, 9, -5]], 0, 9, 2), -200)", "def test_findCheapestPrice(self):\n\n    class Solution:\n\n        def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in flights:\n                graph[u].append((v, w))\n            return self._dijkstra(graph, src, dst, k)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, k: int) -> int:\n            dist = []\n            for i in range(len(graph)):\n                dist.append([math.inf for _ in range(k + 2)])\n            dist[src][k + 1] = 0\n            minHeap = [(dist[src][k + 1], src, k + 1)]\n            while minHeap:\n                (d, u, stops) = heapq.heappop(minHeap)\n                if u == dst:\n                    return d\n                if stops == 0 or d > dist[u][stops]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < dist[v][stops - 1]:\n                        dist[v][stops - 1] = d + w\n                        heapq.heappush(minHeap, (dist[v][stops - 1], v, stops - 1))\n            return -1\n    solution = Solution()\n    flights = []\n    for i in range(100000):\n        flights.append([0, i, -10])\n    self.assertEqual(solution.findCheapestPrice(100001, flights, 0, 99999, 10000), -100010)", "def test_findCheapestPrice(self):\n\n    class Solution:\n\n        def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in flights:\n                graph[u].append((v, w))\n            return self._dijkstra(graph, src, dst, k)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, k: int) -> int:\n            dist = []\n            for i in range(len(graph)):\n                dist.append([math.inf for _ in range(k + 2)])\n            if src == dst:\n                return 0\n            dist[src][k + 1] = 0\n            minHeap = [(dist[src][k + 1], src, k + 1)]\n            while minHeap:\n                (d, u, stops) = heapq.heappop(minHeap)\n                if u == dst:\n                    return d\n                if stops == 0 or d > dist[u][stops]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < dist[v][stops - 1]:\n                        dist[v][stops - 1] = d + w\n                        heapq.heappush(minHeap, (dist[v][stops - 1], v, stops - 1))\n            return -1\n    solution = Solution()\n    self.assertEqual(solution.findCheapestPrice(10, [[0, 1, -100], [6, 9, -5]], 0, 0, 2), 0)", "def test_findCheapestPrice(self):\n\n    class Solution:\n\n        def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n            graph = [[] for _ in range(n)]\n            if not flights:\n                return -1\n            return self._dijkstra(graph, src, dst, k)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, k: int) -> int:\n            dist = []\n            for i in range(len(graph)):\n                dist.append([math.inf for _ in range(k + 2)])\n            dist[src][k + 1] = 0\n            minHeap = [(dist[src][k + 1], src, k + 1)]\n            while minHeap:\n                (d, u, stops) = heapq.heappop(minHeap)\n                if u == dst:\n                    return d\n                if stops == 0 or d > dist[u][stops]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < dist[v][stops - 1]:\n                        dist[v][stops - 1] = d + w\n                        heapq.heappush(minHeap, (dist[v][stops - 1], v, stops - 1))\n            return -1\n    solution = Solution()\n    self.assertEqual(solution.findCheapestPrice(10, [], 0, 9, 2), -1)", "def test_findCheapestPrice(self):\n\n    class Solution:\n\n        def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in flights:\n                graph[u].append((v, w))\n            return self._dijkstra(graph, src, dst, k)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, k: int) -> int:\n            dist = []\n            for i in range(len(graph)):\n                dist.append([math.inf for _ in range(k + 2)])\n            if max((max((w for (_, w) in edges)) for edges in graph)) == float('inf'):\n                return -1\n            dist[src][k + 1] = 0\n            minHeap = [(dist[src][k + 1], src, k + 1)]\n            while minHeap:\n                (d, u, stops) = heapq.heappop(minHeap)\n                if u == dst:\n                    return d\n                if stops == 0 or d > dist[u][stops]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < dist[v][stops - 1]:\n                        dist[v][stops - 1] = d + w\n                        heapq.heappush(minHeap, (dist[v][stops - 1], v, stops - 1))\n            return -1\n    solution = Solution()\n    self.assertEqual(solution.findCheapestPrice(10, [[0, 1, float('inf')]], 0, 9, 2), -1)", "def test_findCheapestPrice_negative_price(self):\n        class Solution:\n            def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n                graph = [[] for _ in range(n)]\n\n                for u, v, w in flights:\n                  graph[u].append((v, w))\n\n                return self._dijkstra(graph, src, dst, k)\n\n            def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, k: int) -> int:\n                dist=[]\n                for i in range(len(graph)):\n                  dist.append([math.inf for _ in range(k + 2)])\n\n                if any(w < 0 for _, w in edges) for edges in graph):  # Check if there are negative prices\n                    raise ValueError(\"Negative prices are not allowed\")\n\n                dist[src][k + 1] = 0\n                minHeap = [(dist[src][k + 1], src, k + 1)]\n\n                while minHeap:\n                  d, u, stops = heapq.heappop(minHeap)\n                  if u == dst:\n                    return d\n                  if stops == 0 or d > dist[u][stops]:\n                    continue\n                  for v, w in graph[u]:\n                    if d + w < dist[v][stops - 1]:\n                      dist[v][stops - 1] = d + w\n                      heapq.heappush(minHeap, (dist[v][stops - 1], v, stops - 1))\n\n                return -1\n\n        solution=Solution()\n        self.assertEqual(solution.findCheapestPrice(10, [[0,1,-100]], 0, 9, 2), -1)", "def test_findCheapestPrice(self):\n\n    class Solution:\n\n        def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in flights:\n                graph[u].append((v, w))\n            return self._dijkstra(graph, src, dst, k)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, k: int) -> int:\n            if n > 10 ** 6 or len(flights) > 10 ** 6 or k > 10 ** 6:\n                raise ValueError('Input is too large')\n            dist = []\n            for i in range(len(graph)):\n                dist.append([math.inf for _ in range(k + 2)])\n            if src == dst:\n                return 0\n            dist[src][k + 1] = 0\n            minHeap = [(dist[src][k + 1], src, k + 1)]\n            while minHeap:\n                (d, u, stops) = heapq.heappop(minHeap)\n                if u == dst:\n                    return d\n                if stops == 0 or d > dist[u][stops]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < dist[v][stops - 1]:\n                        dist[v][stops - 1] = d + w\n                        heapq.heappush(minHeap, (dist[v][stops - 1], v, stops - 1))\n            return -1\n    solution = Solution()\n    self.assertEqual(solution.findCheapestPrice(10 ** 6 + 1, [[0, 1, -100]] * 10 ** 6, 0, 9, 2), -1)", "def test_findCheapestPrice(self):\n\n    class Solution:\n\n        def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in flights:\n                graph[u].append((v, w))\n            return self._dijkstra(graph, src, dst, k)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, k: int) -> int:\n            if n > 10 ** 6 or len(flights) > 10 ** 6 or k > 10 ** 6:\n                raise ValueError('Input is too large')\n            dist = []\n            for i in range(len(graph)):\n                dist.append([math.inf for _ in range(k + 2)])\n            if src == dst:\n                return 0\n            dist[src][k + 1] = 0\n            minHeap = [(dist[src][k + 1], src, k + 1)]\n            while minHeap:\n                (d, u, stops) = heapq.heappop(minHeap)\n                if u == dst:\n                    return d\n                if stops == 0 or d > dist[u][stops]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < dist[v][stops - 1]:\n                        dist[v][stops - 1] = d + w\n                        heapq.heappush(minHeap, (dist[v][stops - 1], v, stops - 1))\n            return -1\n    solution = Solution()\n    flights = [[0, 1, -100], [0, 2, -200]]\n    self.assertEqual(solution.findCheapestPrice(10 ** 6 + 1, flights, 0, 9, 2), -1)", "def test_findCheapestPrice(self):\n\n    class Solution:\n\n        def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in flights:\n                graph[u].append((v, w))\n            return self._dijkstra(graph, src, dst, k)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, k: int) -> int:\n            if n > 10 ** 6 or len(flights) > 10 ** 6 or k > 10 ** 6:\n                raise ValueError('Input is too large')\n            dist = []\n            for i in range(len(graph)):\n                dist.append([math.inf for _ in range(k + 2)])\n            if src == dst:\n                return 0\n            dist[src][k + 1] = 0\n            minHeap = [(dist[src][k + 1], src, k + 1)]\n            while minHeap:\n                (d, u, stops) = heapq.heappop(minHeap)\n                if u == dst:\n                    return d\n                if stops == 0 or d > dist[u][stops]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < dist[v][stops - 1]:\n                        dist[v][stops - 1] = d + w\n                        heapq.heappush(minHeap, (dist[v][stops - 1], v, stops - 1))\n            return -1\n    solution = Solution()\n    self.assertEqual(solution.findCheapestPrice(10 ** 6 + 1, [], 0, 9, 2), -1)", "def test_findCheapestPrice(self):\n\n    class Solution:\n\n        def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in flights:\n                graph[u].append((v, w))\n            return self._dijkstra(graph, src, dst, k)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, k: int) -> int:\n            if n > 10 ** 6 or len(flights) > 10 ** 6 or k > 10 ** 6:\n                raise ValueError('Input is too large')\n            dist = []\n            for i in range(len(graph)):\n                dist.append([math.inf for _ in range(k + 2)])\n            if src == dst:\n                return 0\n            dist[src][k + 1] = 0\n            minHeap = [(dist[src][k + 1], src, k + 1)]\n            while minHeap:\n                (d, u, stops) = heapq.heappop(minHeap)\n                if u == dst:\n                    return d\n                if stops == 0 or d > dist[u][stops]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < dist[v][stops - 1]:\n                        dist[v][stops - 1] = d + w\n                        heapq.heappush(minHeap, (dist[v][stops - 1], v, stops - 1))\n            return -1\n    solution = Solution()\n    self.assertEqual(solution.findCheapestPrice(10 ** 6 + 1, [[0, 1, -100]], 0, 9, 0), math.inf)", "def test_findCheapestPrice(self):\n\n    class Solution:\n\n        def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in flights:\n                graph[u].append((v, w))\n            return self._dijkstra(graph, src, dst, k)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, k: int) -> int:\n            if n > 10 ** 6 or len(flights) > 10 ** 6 or k > 10 ** 6:\n                raise ValueError('Input is too large')\n            dist = []\n            for i in range(len(graph)):\n                dist.append([math.inf for _ in range(k + 2)])\n            if src == dst:\n                return 0\n            dist[src][k + 1] = 0\n            minHeap = [(dist[src][k + 1], src, k + 1)]\n            while minHeap:\n                (d, u, stops) = heapq.heappop(minHeap)\n                if u == dst:\n                    return d\n                if stops == 0 or d > dist[u][stops]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < dist[v][stops - 1]:\n                        dist[v][stops - 1] = d + w\n                        heapq.heappush(minHeap, (dist[v][stops - 1], v, stops - 1))\n            return -1\n    solution = Solution()\n    self.assertEqual(solution.findCheapestPrice(10 ** 6 + 1, [[0, 1, -100]], 0, 9, 2), -1)"]}
{"task_num": 794, "task_title": "Valid Tic-Tac-Toe State", "func_name": "validTicTacToe", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def validTicTacToe(self, board: List[str]) -> bool:\n    def isWin(c: str) -> bool:\n      return any(row.count(c) == 3 for row in board) or any(row.count(c) == 3 for row in list(zip(*board))) or all(board[i][i] == c for i in range(3)) or all(board[i][2 - i] == c for i in range(3))\n\n    countX = sum(row.count('X') for row in board)\n    countO = sum(row.count('O') for row in board)\n\n    if countX < countO or countX - countO > 1:\n      return False\n    if isWin('X') and countX == countO or isWin('O') and countX != countO:\n      return False\n\n    return True\n", "tests": ["def test_validTicTacToe():\n    solution = Solution()\n    board = ['XOX', ' XO', 'XO ']\n    assert solution.validTicTacToe(board) == False", "def test_validTicTacToe():\n    solution = Solution()\n    board = ['OOO', ' X ', '   ']\n    assert solution.validTicTacToe(board) == False", "def test_validTicTacToe():\n    solution = Solution()\n    board = ['XOX', ' O ', 'XO ']\n    assert solution.validTicTacToe(board) == True", "def test_validTicTacToe():\n    solution = Solution()\n    board = ['XXX', '   ', '   ']\n    assert solution.validTicTacToe(board) == False", "def test_validTicTacToe():\n    solution = Solution()\n    board = ['XO ', '   ', ' O ']\n    assert solution.validTicTacToe(board) == False", "def test_validTicTacToe():\n    solution = Solution()\n    board = ['XOX', ' XO', '   ']\n    assert solution.validTicTacToe(board) == True", "def test_validTicTacToe():\n    solution = Solution()\n    board = ['OO ', 'OXO', 'XO ']\n    assert solution.validTicTacToe(board) == True", "def test_validTicTacToe():\n    solution = Solution()\n    board = ['O  ', 'OXO', ' O ']\n    assert solution.validTicTacToe(board) == False", "def test_validTicTacToe():\n    solution = Solution()\n    board = ['XO ', 'OO ', '   ']\n    assert solution.validTicTacToe(board) == True", "def test_validTicTacToe():\n    solution = Solution()\n    board = ['XO ', 'OO ', ' X ']\n    assert solution.validTicTacToe(board) == False", "def test_validTicTacToe():\n    solution = Solution()\n    board = ['OX ', ' OX', 'O X']\n    assert solution.validTicTacToe(board) == False", "def test_validTicTacToe():\n    solution = Solution()\n    board = ['XOX', 'OO ', ' XO']\n    assert solution.validTicTacToe(board) == False", "def test_validTicTacToe():\n    solution = Solution()\n    board = ['XO ', 'OX ', ' O ']\n    assert solution.validTicTacToe(board) == True", "def test_validTicTacToe():\n    solution = Solution()\n    board = ['OOX', ' OX', ' XO']\n    assert solution.validTicTacToe(board) == False", "def test_validTicTacToe():\n    solution = Solution()\n    board = ['XOX', 'OO ', ' O ']\n    assert solution.validTicTacToe(board) == False", "def test_validTicTacToe():\n    solution = Solution()\n    board = ['XOX', 'XO ', 'OO ']\n    assert solution.validTicTacToe(board) == True", "def test_validTicTacToe():\n    solution = Solution()\n    board = ['OOO', 'XOX', ' O ']\n    assert solution.validTicTacToe(board) == False", "def test_validTicTacToe():\n    solution = Solution()\n    board = ['O  ', ' OX', 'OXO']\n    assert solution.validTicTacToe(board) == True", "def test_validTicTacToe():\n    solution = Solution()\n    board = ['OOX', 'OX ', ' OX']\n    assert solution.validTicTacToe(board) == False", "def test_validTicTacToe():\n    solution = Solution()\n    board = ['OXO', 'XO ', ' O ']\n    assert solution.validTicTacToe(board) == True"]}
{"task_num": 805, "task_title": "Split Array With Same Average", "func_name": "splitArraySameAverage", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def splitArraySameAverage(self, nums: List[int]) -> bool:\n    n = len(nums)\n    summ = sum(nums)\n    if not any(i * summ % n == 0 for i in range(1, n // 2 + 1)):\n      return False\n\n    sums = [set() for _ in range(n // 2 + 1)]\n    sums[0].add(0)\n\n    for num in nums:\n      for i in range(n // 2, 0, -1):\n        for val in sums[i - 1]:\n          sums[i].add(num + val)\n\n    for i in range(1, n // 2 + 1):\n      if i * summ % n == 0 and i * summ // n in sums[i]:\n        return True\n\n    return False\n", "tests": ["def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([1, 2, 3, 4, 5]) == True", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([0]) == False", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([1]) == False", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([1, 2]) == True", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([1, 1, 1]) == True", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([10]) == False", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([1, 3, 5, 2, 4]) == True", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([5, 5, 10]) == True", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([1, 5, 9]) == False", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([1, 2, 3, 4, 5]) == True", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([10, 20]) == False", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([1, 3, 5]) == False", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([5]) == False", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([1, 2, 3, 4, 5]) == True", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([]) == False", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([10 ** i for i in range(1, 10)]) == True", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([1] * 1000) == True", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([2 ** i for i in range(1, 20)]) == True", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([3 ** i for i in range(1, 15)]) == True", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([5 ** i for i in range(1, 12)]) == True"]}
{"task_num": 815, "task_title": "Bus Routes", "func_name": "numBusesToDestination", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:\n    if source == target:\n      return 0\n\n    graph = collections.defaultdict(list)\n    usedBuses = set()\n\n    for i in range(len(routes)):\n      for route in routes[i]:\n        graph[route].append(i)\n\n    ans = 0\n    q = collections.deque([source])\n\n    while q:\n      ans += 1\n      for _ in range(len(q)):\n        for bus in graph[q.popleft()]:\n          if bus in usedBuses:\n            continue\n          usedBuses.add(bus)\n          for nextRoute in routes[bus]:\n            if nextRoute == target:\n              return ans\n            q.append(nextRoute)\n\n    return -1\n", "tests": ["def test_numBusesToDestination():\n    solution = Solution()\n    routes = [[1, 2, 7], [3, 6, 9]]\n    source = 1\n    target = 6\n    assert solution.numBusesToDestination(routes, source, target) == 2", "def test_numBusesToDestination():\n    solution = Solution()\n    routes = [[1, 5], [2, 7]]\n    source = 1\n    target = 2\n    assert solution.numBusesToDestination(routes, source, target) == 0", "def test_numBusesToDestination():\n    solution = Solution()\n    routes = [[1], [2]]\n    source = 1\n    target = 3\n    assert solution.numBusesToDestination(routes, source, target) == -1", "def test_numBusesToDestination():\n    solution = Solution()\n    routes = [[5]]\n    source = 1\n    target = 5\n    assert solution.numBusesToDestination(routes, source, target) == 0", "def test_numBusesToDestination():\n    solution = Solution()\n    routes = [[1, 2, 5], [4]]\n    source = 1\n    target = 4\n    assert solution.numBusesToDestination(routes, source, target) == 1", "def test_numBusesToDestination():\n    solution = Solution()\n    routes = [[1, 2], [3, 4], [5]]\n    source = 1\n    target = 5\n    assert solution.numBusesToDestination(routes, source, target) == -1", "def test_numBusesToDestination():\n    solution = Solution()\n    routes = [[10], [20], [30]]\n    source = 10\n    target = 40\n    assert solution.numBusesToDestination(routes, source, target) == -1", "def test_numBusesToDestination():\n    solution = Solution()\n    routes = [[1], [2]]\n    source = 5\n    target = 3\n    assert solution.numBusesToDestination(routes, source, target) == -1", "def test_numBusesToDestination():\n    solution = Solution()\n    routes = [[10], [20]]\n    source = 10\n    target = 30\n    assert solution.numBusesToDestination(routes, source, target) == -1", "def test_numBusesToDestination():\n    solution = Solution()\n    routes = [[5], [10]]\n    source = 5\n    target = 20\n    assert solution.numBusesToDestination(routes, source, target) == -1", "def test_numBusesToDestination():\n    solution = Solution()\n    routes = [[5], [10]]\n    source = 20\n    target = 5\n    assert solution.numBusesToDestination(routes, source, target) == -1", "def test_numBusesToDestination():\n    solution = Solution()\n    routes = [[10, 20], [30]]\n    source = 10\n    target = 20\n    assert solution.numBusesToDestination(routes, source, target) == 0", "def test_numBusesToDestination():\n    solution = Solution()\n    routes = [[10, 20], [30]]\n    source = 20\n    target = 20\n    assert solution.numBusesToDestination(routes, source, target) == 0", "def test_numBusesToDestination():\n    solution = Solution()\n    routes = [[1, 2], [3]]\n    source = 1\n    target = 1\n    assert solution.numBusesToDestination(routes, source, target) == 0", "def test_numBusesToDestination():\n    solution = Solution()\n    routes = [[1, 2], [3]]\n    source = 3\n    target = 2\n    assert solution.numBusesToDestination(routes, source, target) == -1", "def test_numBusesToDestination():\n    solution = Solution()\n    routes = [[10], [20], [30]]\n    source = 20\n    target = 10\n    assert solution.numBusesToDestination(routes, source, target) == -1", "def test_numBusesToDestination():\n    solution = Solution()\n    routes = [[10], [20]]\n    source = 10\n    target = 30\n    assert solution.numBusesToDestination(routes, source, target) == -1", "def test_numBusesToDestination():\n    solution = Solution()\n    routes = [[5], [10]]\n    source = 20\n    target = 10\n    assert solution.numBusesToDestination(routes, source, target) == -1", "def test_numBusesToDestination():\n    solution = Solution()\n    routes = [[10, 20], [30]]\n    source = 10\n    target = 30\n    assert solution.numBusesToDestination(routes, source, target) == 2", "def test_numBusesToDestination():\n    solution = Solution()\n    routes = [[10], [20]]\n    source = 10\n    target = 30\n    assert solution.numBusesToDestination(routes, source, target) == -1"]}
{"task_num": 838, "task_title": "Push Dominoes", "func_name": "pushDominoes", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def pushDominoes(self, dominoes: str) -> str:\n    ans = list(dominoes)\n    L = -1\n    R = -1\n\n    for i in range(len(dominoes) + 1):\n      if i == len(dominoes) or dominoes[i] == 'R':\n        if L < R:\n          while R < i:\n            ans[R] = 'R'\n            R += 1\n        R = i\n      elif dominoes[i] == 'L':\n        if R < L or (L, R) == (-1, -1):\n          if (L, R) == (-1, -1):\n            L += 1\n          while L < i:\n            ans[L] = 'L'\n            L += 1\n        else:\n          l = R + 1\n          r = i - 1\n          while l < r:\n            ans[l] = 'R'\n            ans[r] = 'L'\n            l += 1\n            r -= 1\n        L = i\n\n    return ''.join(ans)\n", "tests": ["def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('RR.L') == 'RRLL'", "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('.L.R...LR.L.') == 'LL.RRLRLL'", "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('LL.RR.LLRRLL..') == 'LLLLRRRRLLL'", "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('...L.R...LR.L..') == 'LLRRLRRLLL'", "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('L.R') == 'RL'", "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('.') == '.'", "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('LR.') == 'LRL'", "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('.LR.LR.') == 'LLRRLL'", "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('...LR.LR...') == 'LLRRLL'", "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('R.L...LR...L..') == 'RRLLRRLLL'", "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('.LR.L.R..L...') == 'LLRRLRRLL'", "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('L.L.R...LR..') == 'LLRRLL'", "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('...L.R.LR.L') == 'LLRRLLRL'", "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('LR.LR...L.R..') == 'LLRRLLRR'", "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('L.R..LR...LR') == 'LLRRLLRR'", "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('...LR.LR..L.R') == 'LLRRLLRR'", "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('LR.LR...L.R..') == 'LLRRLLRR'", "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('LR.LR...L.R..') == 'LLRRLLRR'", "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('L.R.LR...LR..') == 'LLRRLLRR'", "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('R.L.R..L...LR') == 'RRLLRRLL'"]}
{"task_num": 845, "task_title": "Longest Mountain in Array", "func_name": "longestMountain", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def longestMountain(self, arr: List[int]) -> int:\n    ans = 0\n    i = 0\n\n    while i + 1 < len(arr):\n      while i + 1 < len(arr) and arr[i] == arr[i + 1]:\n        i += 1\n\n      increasing = 0\n      decreasing = 0\n\n      while i + 1 < len(arr) and arr[i] < arr[i + 1]:\n        increasing += 1\n        i += 1\n\n      while i + 1 < len(arr) and arr[i] > arr[i + 1]:\n        decreasing += 1\n        i += 1\n\n      if increasing > 0 and decreasing > 0:\n        ans = max(ans, increasing + decreasing + 1)\n\n    return ans\n", "tests": ["def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([2, 1, 4, 7, 3, 2, 5]) == 5", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([2, 2, 2]) == 0", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([2, 1, 3])", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([2, 1, 4, 3, 5, 6, 7])", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([1, 2, 3, 4, 5])", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([1, 3, 2])", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([1, 1, 2])", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([1, 4, 3, 2])", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([9, 8, 7, 6, 5])", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([1, 3, 5, 7])", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([1, 3, 5])", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([2, 4, 1])", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([2, 4, 5, 3])", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([1, 2, 3, 4, 5, 6])", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([1, 2, 3, 4, 5, 6, 7, 8, 9])", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, -1])", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([2, 5, 3, 4, 6, 8])", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, -1000000])", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([1, 3, 5, 7, 9])"]}
{"task_num": 854, "task_title": "K-Similar Strings", "func_name": "kSimilarity", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def kSimilarity(self, s1: str, s2: str) -> int:\n    ans = 0\n    q = collections.deque([s1])\n    seen = {s1}\n\n    while q:\n      for _ in range(len(q)):\n        curr = q.popleft()\n        if curr == s2:\n          return ans\n        for child in self._getChildren(curr, s2):\n          if child in seen:\n            continue\n          q.append(child)\n          seen.add(child)\n      ans += 1\n\n    return -1\n\n  def _getChildren(self, curr: str, target: str) -> List[str]:\n    children = []\n    s = list(curr)\n    i = 0\n    while curr[i] == target[i]:\n      i += 1\n\n    for j in range(i + 1, len(s)):\n      if s[j] == target[i]:\n        s[i], s[j] = s[j], s[i]\n        children.append(''.join(s))\n        s[i], s[j] = s[j], s[i]\n\n    return children\n", "tests": ["    def test_kSimilarity(self):\n        def kSimilarity(s1: str, s2: str) -> int:\n            from collections import deque, defaultdict\n            ans = 0\n            q = deque([s1])\n            seen = set([s1])\n\n            while q:\n                for _ in range(len(q)):\n                    curr = q.popleft()\n                    if curr == s2:\n                        return ans\n                    for child in self._getChildren(curr, s2):\n                        if child in seen:\n                            continue\n                        q.append(child)\n                        seen.add(child)\n                ans += 1\n\n            return -1\n\n        def _getChildren(self, curr: str, target: str) -> list[str]:\n            children = []\n            s = list(curr)\n            i = 0\n            while curr[i] == target[i]:\n              i += 1\n\n            for j in range(i + 1, len(s)):\n                if s[j] == target[i]:\n                    s[i], s[j] = s[j], s[i]\n                    children.append(''.join(s))\n                    s[i], s[j] = s[j], s[i]\n\n            return children\n\n        solution=Solution()\n        self.assertEqual(kSimilarity(\"ab\", \"ba\"), 1)", "def test_kSimilarity(self):\n    solution = Solution()\n    self.assertEqual(solution.kSimilarity('meeet', 'meete'), 2)", "def test_kSimilarity(self):\n    solution = Solution()\n    self.assertEqual(solution.kSimilarity('abcd', 'dcba'), 2)", "def test_kSimilarity(self):\n    solution = Solution()\n    self.assertEqual(solution.kSimilarity('targt', 'tagrt'), 3)", "def test_kSimilarity(self):\n    solution = Solution()\n    self.assertEqual(solution.kSimilarity('xoxox', 'oxoox'), 2)", "def test_kSimilarity(self):\n    solution = Solution()\n    self.assertEqual(solution.kSimilarity('', ''), 0)", "def test_kSimilarity(self):\n    solution = Solution()\n    self.assertEqual(solution.kSimilarity('aaa', 'bbb'), -1)", "def test_kSimilarity(self):\n    solution = Solution()\n    self.assertEqual(solution.kSimilarity('xx', 'yy'), 2)", "def test_kSimilarity(self):\n    solution = Solution()\n    self.assertEqual(solution.kSimilarity('aa', 'ab'), 1)", "def test_kSimilarity(self):\n    solution = Solution()\n    self.assertEqual(solution.kSimilarity('abcdef', 'fedcba'), 6)", "def test_kSimilarity(self):\n    solution = Solution()\n    self.assertEqual(solution.kSimilarity('aabbcc', 'cbaabc'), 4)", "def test_kSimilarity(self):\n    solution = Solution()\n    self.assertEqual(solution.kSimilarity('abcd', 'dcba'), 2)", "def test_kSimilarity(self):\n    solution = Solution()\n    self.assertEqual(solution.kSimilarity('xoxox', 'ooxox'), -1)", "def test_kSimilarity(self):\n    solution = Solution()\n    self.assertEqual(solution.kSimilarity('ab', 'ba'), 1)", "def test_kSimilarity(self):\n    solution = Solution()\n    self.assertEqual(solution.kSimilarity('abac', 'cab'), -1)", "def test_kSimilarity(self):\n    solution = Solution()\n    self.assertEqual(solution.kSimilarity('abac', 'cab'), -1)", "def test_kSimilarity(self):\n    solution = Solution()\n    self.assertEqual(solution.kSimilarity('abac', 'cab'), -1)", "def test_kSimilarity(self):\n    solution = Solution()\n    self.assertEqual(solution.kSimilarity('abac', 'cab'), -1)", "def test_kSimilarity(self):\n    solution = Solution()\n    self.assertEqual(solution.kSimilarity('abac', 'cab'), -1)", "def test_kSimilarity(self):\n    solution = Solution()\n    self.assertEqual(solution.kSimilarity('abac', 'cab'), -1)"]}
{"task_num": 861, "task_title": "Score After Flipping Matrix", "func_name": "matrixScore", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def matrixScore(self, grid: List[List[int]]) -> int:\n    for row in grid:\n      if row[0] == 0:\n        self._flip(row)\n\n    for j, col in enumerate(list(zip(*grid))):\n      if sum(col) * 2 < len(grid):\n        self._flipCol(grid, j)\n\n    return sum(self._binary(row) for row in grid)\n\n  def _flip(self, row: List[int]) -> None:\n    for i in range(len(row)):\n      row[i] ^= 1\n\n  def _flipCol(self, grid: List[List[int]], j: int) -> None:\n    for i in range(len(grid)):\n      grid[i][j] ^= 1\n\n  def _binary(self, row: List[int]) -> int:\n    res = row[0]\n    for j in range(1, len(row)):\n      res = res * 2 + row[j]\n    return res\n", "tests": ["  def test_matrixScore(self):\n    def matrixScore(grid: List[List[int]]) -> int:\n      for row in grid:\n        if row[0] == 0:\n          self._flip(row)\n\n      for j, col in enumerate(list(zip(*grid))):\n        if sum(col) * 2 < len(grid):\n          self._flipCol(grid, j)\n\n      return sum(self._binary(row) for row in grid)\n\n    solution=Solution()\n\n    grid = [\n      [0, 1, 0],\n      [1, 0, 1],\n      [0, 0, 0]\n    ]\n    self.assertEqual(matrixScore(grid), 6)", "def test_matrixScore():\n\n    def matrixScore(grid: List[List[int]]) -> int:\n        for row in grid:\n            if row[0] == 0:\n                self._flip(row)\n        for (j, col) in enumerate(list(zip(*grid))):\n            if sum(col) * 2 < len(grid):\n                self._flipCol(grid, j)\n        return sum((self._binary(row) for row in grid))\n    solution = Solution()\n    grid = [[1, 0], [0, 1]]\n    self.assertEqual(matrixScore(grid), 2)", "def test_matrixScore():\n\n    def matrixScore(grid: List[List[int]]) -> int:\n        for row in grid:\n            if row[0] == 0:\n                self._flip(row)\n        for (j, col) in enumerate(list(zip(*grid))):\n            if sum(col) * 2 < len(grid):\n                self._flipCol(grid, j)\n        return sum((self._binary(row) for row in grid))\n    solution = Solution()\n    grid = [[0, 0], [0, 0]]\n    self.assertEqual(matrixScore(grid), 1)", "def test_matrixScore():\n\n    def matrixScore(grid: List[List[int]]) -> int:\n        for row in grid:\n            if row[0] == 0:\n                self._flip(row)\n        for (j, col) in enumerate(list(zip(*grid))):\n            if sum(col) * 2 < len(grid):\n                self._flipCol(grid, j)\n        return sum((self._binary(row) for row in grid))\n    solution = Solution()\n    grid = [[1, 1], [1, 1]]\n    self.assertEqual(matrixScore(grid), 6)", "def test_matrixScore():\n\n    def matrixScore(grid: List[List[int]]) -> int:\n        for row in grid:\n            if row[0] == 0:\n                self._flip(row)\n        for (j, col) in enumerate(list(zip(*grid))):\n            if sum(col) * 2 < len(grid):\n                self._flipCol(grid, j)\n        return sum((self._binary(row) for row in grid))\n    solution = Solution()\n    grid = []\n    self.assertEqual(matrixScore(grid), 0)", "def test_matrixScore():\n\n    def matrixScore(grid: List[List[int]]) -> int:\n        for row in grid:\n            if row[0] == 0:\n                self._flip(row)\n        for (j, col) in enumerate(list(zip(*grid))):\n            if sum(col) * 2 < len(grid):\n                self._flipCol(grid, j)\n        return sum((self._binary(row) for row in grid))\n    solution = Solution()\n    grid = [[0, 1, 0]]\n    self.assertEqual(matrixScore(grid), 5)", "def test_matrixScore():\n\n    def matrixScore(grid: List[List[int]]) -> int:\n        for row in grid:\n            if row[0] == 0:\n                self._flip(row)\n        for (j, col) in enumerate(list(zip(*grid))):\n            if sum(col) * 2 < len(grid):\n                self._flipCol(grid, j)\n        return sum((self._binary(row) for row in grid))\n    solution = Solution()\n    grid = [[1], [0], [0]]\n    self.assertEqual(matrixScore(grid), 3)", "def test_matrixScore():\n\n    def matrixScore(grid: List[List[int]]) -> int:\n        for row in grid:\n            if row[0] == 0:\n                self._flip(row)\n        for (j, col) in enumerate(list(zip(*grid))):\n            if sum(col) * 2 < len(grid):\n                self._flipCol(grid, j)\n        return sum((self._binary(row) for row in grid))\n    solution = Solution()\n    grid = [[0, 1], [1, 1]]\n    self.assertEqual(matrixScore(grid), 3)", "def test_matrixScore():\n\n    def matrixScore(grid: List[List[int]]) -> int:\n        for row in grid:\n            if row[0] == 0:\n                self._flip(row)\n        for (j, col) in enumerate(list(zip(*grid))):\n            if sum(col) * 2 < len(grid):\n                self._flipCol(grid, j)\n        return sum((self._binary(row) for row in grid))\n    solution = Solution()\n    grid = [[1, 0, 1], [0, 1, 0]]\n    self.assertEqual(matrixScore(grid), 7)", "def test_matrixScore():\n\n    def matrixScore(grid: List[List[int]]) -> int:\n        for row in grid:\n            if row[0] == 0:\n                self._flip(row)\n        for (j, col) in enumerate(list(zip(*grid))):\n            if sum(col) * 2 < len(grid):\n                self._flipCol(grid, j)\n        return sum((self._binary(row) for row in grid))\n    solution = Solution()\n    grid = [[1, 0], ['a', 1]]\n    with self.assertRaises(TypeError):\n        matrixScore(grid)", "def test_matrixScore():\n\n    def matrixScore(grid: List[List[int]]) -> int:\n        for row in grid:\n            if row[0] == 0:\n                self._flip(row)\n        for (j, col) in enumerate(list(zip(*grid))):\n            if sum(col) * 2 < len(grid):\n                self._flipCol(grid, j)\n        return sum((self._binary(row) for row in grid))\n    solution = Solution()\n    grid = [[1, 0], []]\n    self.assertEqual(matrixScore(grid), 3)", "def test_matrixScore():\n\n    def matrixScore(grid: List[List[int]]) -> int:\n        for row in grid:\n            if row[0] == 0:\n                self._flip(row)\n        for (j, col) in enumerate(list(zip(*grid))):\n            if sum(col) * 2 < len(grid):\n                self._flipCol(grid, j)\n        return sum((self._binary(row) for row in grid))\n    solution = Solution()\n    grid = [[1] * 100, [0] * 100]\n    self.assertEqual(matrixScore(grid), 1 << 100)", "def test_matrixScore():\n\n    def matrixScore(grid: List[List[int]]) -> int:\n        for row in grid:\n            if row[0] == 0:\n                self._flip(row)\n        for (j, col) in enumerate(list(zip(*grid))):\n            if sum(col) * 2 < len(grid):\n                self._flipCol(grid, j)\n        return sum((self._binary(row) for row in grid))\n    solution = Solution()\n    grid = [[1] * 100 for _ in range(100)]\n    self.assertEqual(matrixScore(grid), 1 << 200)", "def test_matrixScore():\n\n    def matrixScore(grid: List[List[int]]) -> int:\n        for row in grid:\n            if row[0] == 0:\n                self._flip(row)\n        for (j, col) in enumerate(list(zip(*grid))):\n            if sum(col) * 2 < len(grid):\n                self._flipCol(grid, j)\n        return sum((self._binary(row) for row in grid))\n    solution = Solution()\n    grid = [[1, 2], [3, 0]]\n    with self.assertRaises(ValueError):\n        matrixScore(grid)", "def test_matrixScore():\n\n    def matrixScore(grid: List[List[int]]) -> int:\n        for row in grid:\n            if row[0] == 0:\n                self._flip(row)\n        for (j, col) in enumerate(list(zip(*grid))):\n            if sum(col) * 2 < len(grid):\n                self._flipCol(grid, j)\n        return sum((self._binary(row) for row in grid))\n    solution = Solution()\n    grid = [[1] * 200 for _ in range(200)]\n    self.assertEqual(matrixScore(grid), 1 << 400)", "def test_matrixScore():\n\n    def matrixScore(grid: List[List[int]]) -> int:\n        for row in grid:\n            if row[0] == 0:\n                self._flip(row)\n        for (j, col) in enumerate(list(zip(*grid))):\n            if sum(col) * 2 < len(grid):\n                self._flipCol(grid, j)\n        return sum((self._binary(row) for row in grid))\n    solution = Solution()\n    n = 15\n    grid = [[1] * n for _ in range(n)]\n    self.assertEqual(matrixScore(grid), 1 << n * n)", "def test_matrixScore():\n\n    def matrixScore(grid: List[List[int]]) -> int:\n        for row in grid:\n            if row[0] == 0:\n                self._flip(row)\n        for (j, col) in enumerate(list(zip(*grid))):\n            if sum(col) * 2 < len(grid):\n                self._flipCol(grid, j)\n        return sum((self._binary(row) for row in grid))\n    solution = Solution()\n    grid = {'a': [1, 0], 'b': [0, 1]}\n    with self.assertRaises(TypeError):\n        matrixScore(grid)", "def test_matrixScore():\n\n    def matrixScore(grid: List[List[int]]) -> int:\n        for row in grid:\n            if row[0] == 0:\n                self._flip(row)\n        for (j, col) in enumerate(list(zip(*grid))):\n            if sum(col) * 2 < len(grid):\n                self._flipCol(grid, j)\n        return sum((self._binary(row) for row in grid))\n    solution = Solution()\n    n = 20000\n    grid = [[1] * n for _ in range(n)]\n    self.assertEqual(matrixScore(grid), 1 << n * n)", "def test_matrixScore():\n\n    def matrixScore(grid: List[List[int]]) -> int:\n        for row in grid:\n            if row[0] == 0:\n                self._flip(row)\n        for (j, col) in enumerate(list(zip(*grid))):\n            if sum(col) * 2 < len(grid):\n                self._flipCol(grid, j)\n        return sum((self._binary(row) for row in grid))\n    solution = Solution()\n    grid = [[1, -1], [0, 1]]\n    with self.assertRaises(ValueError):\n        matrixScore(grid)", "def test_matrixScore():\n\n    def matrixScore(grid: List[List[int]]) -> int:\n        for row in grid:\n            if row[0] == 0:\n                self._flip(row)\n        for (j, col) in enumerate(list(zip(*grid))):\n            if sum(col) * 2 < len(grid):\n                self._flipCol(grid, j)\n        return sum((self._binary(row) for row in grid))\n    solution = Solution()\n    grid = [[1, 'a'], [0, 1]]\n    with self.assertRaises(TypeError):\n        matrixScore(grid)"]}
{"task_num": 866, "task_title": "Prime Palindrome", "func_name": "primePalindrome", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def primePalindrome(self, n: int) -> int:\n    def getPalindromes(n: int):\n      length = n // 2\n      for i in range(10**(length - 1), 10**length):\n        s = str(i)\n        for j in range(10):\n          yield int(s + str(j) + s[::-1])\n\n    def isPrime(num: int) -> bool:\n      for i in range(2, int(num**0.5 + 1)):\n        if num % i == 0:\n          return False\n      return True\n\n    if n <= 2:\n      return 2\n    if n == 3:\n      return 3\n    if n <= 5:\n      return 5\n    if n <= 7:\n      return 7\n    if n <= 11:\n      return 11\n\n    nLength = len(str(n))\n\n    while True:\n      for num in getPalindromes(nLength):\n        if num >= n and isPrime(num):\n          return num\n      nLength += 1\n", "tests": ["def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(8) == 11", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(10101) == 11111", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(4) == 5", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(2) == 2", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(99999) == 10101", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(1000000) == 1003003", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(2 * 108) == 2 * 108", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(999) == 1009", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(1) == 2", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(101) == 131", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(13) == 131", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(10000000) == 1003003", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(11111) == 13331", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(55555) == 13331", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(1234321) == 13331", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(987654321) == 1003003", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(123456789) == 13331", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(987654321) == 1003003", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(10) == 11", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(22222) == 23333"]}
{"task_num": 882, "task_title": "Reachable Nodes In Subdivided Graph", "func_name": "reachableNodes", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def reachableNodes(self, edges: List[List[int]], maxMoves: int, n: int) -> int:\n    graph = [[] for _ in range(n)]\n    dist = [maxMoves + 1] * n\n\n    for u, v, cnt in edges:\n      graph[u].append((v, cnt))\n      graph[v].append((u, cnt))\n\n    reachableNodes = self._dijkstra(graph, 0, maxMoves, dist)\n    reachableSubnodes = 0\n\n    for u, v, cnt in edges:\n      a = 0 if dist[u] > maxMoves else min(maxMoves - dist[u], cnt)\n      b = 0 if dist[v] > maxMoves else min(maxMoves - dist[v], cnt)\n      reachableSubnodes += min(a + b, cnt)\n\n    return reachableNodes + reachableSubnodes\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, maxMoves: int, dist: List[int]) -> int:\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if dist[u] >= maxMoves:\n        break\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        newDist = d + w + 1\n        if newDist < dist[v]:\n          dist[v] = newDist\n          heapq.heappush(minHeap, (newDist, v))\n\n    return sum(d <= maxMoves for d in dist)\n", "tests": ["def test_reachableNodes(self):\n    edges = [[0, 1, 2], [0, 2, 3], [1, 3, 5]]\n    maxMoves = 2\n    n = 4\n    self.assertEqual(solution.reachableNodes(edges, maxMoves, n), 15)", "def test_reachableNodes(self):\n    edges = [[0, 1, 2], [0, 2, 3], [1, 3, 5]]\n    maxMoves = 0\n    n = 4\n    self.assertEqual(solution.reachableNodes(edges, maxMoves, n), 0)", "def test_reachableNodes(self):\n    edges = [[0, 1, 2], [0, 2, 3]]\n    maxMoves = 4\n    n = 3\n    self.assertEqual(solution.reachableNodes(edges, maxMoves, n), 6)", "def test_reachableNodes(self):\n    edges = [[0, 1, 0], [2, 3, 5]]\n    maxMoves = 10\n    n = 4\n    self.assertEqual(solution.reachableNodes(edges, maxMoves, n), 9)", "def test_reachableNodes(self):\n    edges = [[0, 1, 2], [0, 2, 3]]\n    maxMoves = 5\n    n = 3\n    self.assertEqual(solution.reachableNodes(edges, maxMoves, n), 4)", "def test_reachableNodes(self):\n    edges = [[0, 1, 2], [0, 2, 3], [1, 3, 5]]\n    maxMoves = float('inf')\n    n = 4\n    self.assertEqual(solution.reachableNodes(edges, maxMoves, n), 7)", "def test_reachableNodes(self):\n    edges = []\n    maxMoves = 2\n    n = 0\n    self.assertEqual(solution.reachableNodes(edges, maxMoves, n), 0)", "def test_reachableNodes(self):\n    edges = [[0, 1, 2]]\n    maxMoves = float('inf')\n    n = 2\n    self.assertEqual(solution.reachableNodes(edges, maxMoves, n), 3)", "def test_reachableNodes(self):\n    edges = [[0, 1, 2], [2, 3, 5]]\n    maxMoves = 6\n    n = 4\n    self.assertEqual(solution.reachableNodes(edges, maxMoves, n), 8)", "def test_reachableNodes(self):\n    edges = [[0, 1, 2]]\n    maxMoves = 10\n    n = 3\n    self.assertEqual(solution.reachableNodes(edges, maxMoves, n), 4)", "def test_reachableNodes(self):\n    edges = [[0, 1, 2], [1, 2, 3]]\n    maxMoves = 5\n    n = 3\n    self.assertEqual(solution.reachableNodes(edges, maxMoves, n), 7)", "def test_reachableNodes(self):\n    edges = [[0, 1, 2]]\n    maxMoves = float('inf')\n    n = 1000000\n    self.assertEqual(solution.reachableNodes(edges, maxMoves, n), 1)", "def test_reachableNodes(self):\n    edges = [[0, 1, 2]]\n    maxMoves = 10\n    n = 10000000\n    self.assertEqual(solution.reachableNodes(edges, maxMoves, n), 10000001)", "def test_reachableNodes(self):\n    edges = [[0, 1, 2], [1, 2, 3]]\n    maxMoves = float('inf')\n    n = 10000000\n    self.assertEqual(solution.reachableNodes(edges, maxMoves, n), 2)", "def test_reachableNodes(self):\n    edges = []\n    maxMoves = float('inf')\n    n = 0\n    self.assertEqual(solution.reachableNodes(edges, maxMoves, n), 1)", "def test_reachableNodes(self):\n    edges = [[0, 1, 2], [2, 3, 5]]\n    maxMoves = 10\n    n = 10000000\n    self.assertEqual(solution.reachableNodes(edges, maxMoves, n), 11111111)", "def test_reachableNodes(self):\n    edges = [[0, 1, 2], [1, 3, 5]]\n    maxMoves = float('inf')\n    n = 4\n    self.assertEqual(solution.reachableNodes(edges, maxMoves, n), 8)", "def test_reachableNodes(self):\n    edges = [[0, 1, 2], [0, 3, 4]]\n    maxMoves = 10\n    n = 5\n    self.assertEqual(solution.reachableNodes(edges, maxMoves, n), 17)", "def test_reachableNodes(self):\n    edges = [[0, 1, 2], [1, 3, 5]]\n    maxMoves = float('inf')\n    n = 10000000\n    self.assertEqual(solution.reachableNodes(edges, maxMoves, n), 11111111)", "def test_reachableNodes(self):\n    edges = [[0, 1, 2], [3, 4, 5]]\n    maxMoves = 10\n    n = 6\n    self.assertEqual(solution.reachableNodes(edges, maxMoves, n), 23)"]}
{"task_num": 909, "task_title": "Snakes and Ladders", "func_name": "snakesAndLadders", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def snakesAndLadders(self, board: List[List[int]]) -> int:\n    n = len(board)\n    ans = 0\n    q = collections.deque([1])\n    seen = set()\n    A = [0] * (1 + n * n)\n\n    for i in range(n):\n      for j in range(n):\n        if n - i & 1 :\n          A[(n - 1 - i) * n + (j + 1)] = board[i][j]\n        else:\n          A[(n - 1 - i) * n + (n - j)] = board[i][j]\n\n    while q:\n      ans += 1\n      for _ in range(len(q)):\n        curr = q.popleft()\n        for next in range(curr + 1, min(curr + 6, n * n) + 1):\n          dest = A[next] if A[next] > 0 else next\n          if dest == n * n:\n            return ans\n          if dest in seen:\n            continue\n          q.append(dest)\n          seen.add(dest)\n\n    return -1\n", "tests": ["def test_snakesAndLadders():\n\n    class Solution:\n\n        def snakesAndLadders(self, board: List[List[int]]) -> int:\n            n = len(board)\n            ans = 0\n            q = collections.deque([1])\n            seen = set()\n            A = [0] * (1 + n * n)\n            for i in range(n):\n                for j in range(n):\n                    if n - i & 1:\n                        A[(n - 1 - i) * n + (j + 1)] = board[i][j]\n                    else:\n                        A[(n - 1 - i) * n + (n - j)] = board[i][j]\n            while q:\n                ans += 1\n                for _ in range(len(q)):\n                    curr = q.popleft()\n                    for next in range(curr + 1, min(curr + 6, n * n) + 1):\n                        dest = A[next] if A[next] > 0 else next\n                        if dest == n * n:\n                            return ans\n                        if dest in seen:\n                            continue\n                        q.append(dest)\n                        seen.add(dest)\n                return -1\n    solution = Solution()\n    board = [[1, -1], [-1, 3]]\n    assert solution.snakesAndLadders(board) == 2", "def test_snakesAndLadders():\n\n    class Solution:\n\n        def snakesAndLadders(self, board: List[List[int]]) -> int:\n            n = len(board)\n            ans = 0\n            q = collections.deque([1])\n            seen = set()\n            A = [0] * (1 + n * n)\n            for i in range(n):\n                for j in range(n):\n                    if n - i & 1:\n                        A[(n - 1 - i) * n + (j + 1)] = board[i][j]\n                    else:\n                        A[(n - 1 - i) * n + (n - j)] = board[i][j]\n            while q:\n                ans += 1\n                for _ in range(len(q)):\n                    curr = q.popleft()\n                    for next in range(curr + 1, min(curr + 6, n * n) + 1):\n                        dest = A[next] if A[next] > 0 else next\n                        if dest == n * n:\n                            return ans\n                        if dest in seen:\n                            continue\n                        q.append(dest)\n                        seen.add(dest)\n            return -1\n    solution = Solution()\n    board = [[3, -1, 5], [2, -1, 6]]\n    assert solution.snakesAndLadders(board) == 7", "def test_snakesAndLadders():\n\n    class Solution:\n\n        def snakesAndLadders(self, board: List[List[int]]) -> int:\n            n = len(board)\n            ans = 0\n            q = collections.deque([1])\n            seen = set()\n            A = [0] * (1 + n * n)\n            for i in range(n):\n                for j in range(n):\n                    if n - i & 1:\n                        A[(n - 1 - i) * n + (j + 1)] = board[i][j]\n                    else:\n                        A[(n - 1 - i) * n + (n - j)] = board[i][j]\n            while q:\n                ans += 1\n                for _ in range(len(q)):\n                    curr = q.popleft()\n                    for next in range(curr + 1, min(curr + 6, n * n) + 1):\n                        dest = A[next] if A[next] > 0 else next\n                        if dest == n * n:\n                            return ans\n                        if dest in seen:\n                            continue\n                        q.append(dest)\n                        seen.add(dest)\n            return -1\n    solution = Solution()\n    board = [[2, -1, 3], [-5, -9, -7]]\n    assert solution.snakesAndLadders(board) == -1", "def test_snakesAndLadders():\n\n    class Solution:\n\n        def snakesAndLadders(self, board: List[List[int]]) -> int:\n            n = len(board)\n            ans = 0\n            q = collections.deque([1])\n            seen = set()\n            A = [0] * (1 + n * n)\n            for i in range(n):\n                for j in range(n):\n                    if n - i & 1:\n                        A[(n - 1 - i) * n + (j + 1)] = board[i][j]\n                    else:\n                        A[(n - 1 - i) * n + (n - j)] = board[i][j]\n            while q:\n                ans += 1\n                for _ in range(len(q)):\n                    curr = q.popleft()\n                    for next in range(curr + 1, min(curr + 6, n * n) + 1):\n                        dest = A[next] if A[next] > 0 else next\n                        if dest == n * n:\n                            return ans\n                        if dest in seen:\n                            continue\n                        q.append(dest)\n                        seen.add(dest)\n            return -1\n    solution = Solution()\n    board = [[4, 7, -3], [-6, -5, -9]]\n    assert solution.snakesAndLadders(board) == 8", "def test_snakesAndLadders():\n\n    class Solution:\n\n        def snakesAndLadders(self, board: List[List[int]]) -> int:\n            n = len(board)\n            ans = 0\n            q = collections.deque([1])\n            seen = set()\n            A = [0] * (1 + n * n)\n            for i in range(n):\n                for j in range(n):\n                    if n - i & 1:\n                        A[(n - 1 - i) * n + (j + 1)] = board[i][j]\n                    else:\n                        A[(n - 1 - i) * n + (n - j)] = board[i][j]\n            while q:\n                ans += 1\n                for _ in range(len(q)):\n                    curr = q.popleft()\n                    for next in range(curr + 1, min(curr + 6, n * n) + 1):\n                        dest = A[next] if A[next] > 0 else next\n                        if dest == n * n:\n                            return ans\n                        if dest in seen:\n                            continue\n                        q.append(dest)\n                        seen.add(dest)\n            return -1\n    solution = Solution()\n    board = [[1, 2, 3], [4, -5, -6]]\n    assert solution.snakesAndLadders(board) == 0", "def test_snakesAndLadders():\n\n    class Solution:\n\n        def snakesAndLadders(self, board: List[List[int]]) -> int:\n            n = len(board)\n            ans = 0\n            q = collections.deque([1])\n            seen = set()\n            A = [0] * (1 + n * n)\n            for i in range(n):\n                for j in range(n):\n                    if n - i & 1:\n                        A[(n - 1 - i) * n + (j + 1)] = board[i][j]\n                    else:\n                        A[(n - 1 - i) * n + (n - j)] = board[i][j]\n            while q:\n                ans += 1\n                for _ in range(len(q)):\n                    curr = q.popleft()\n                    for next in range(curr + 1, min(curr + 6, n * n) + 1):\n                        dest = A[next] if A[next] > 0 else next\n                        if dest == n * n:\n                            return ans\n                        if dest in seen:\n                            continue\n                        q.append(dest)\n                        seen.add(dest)\n            return -1\n    solution = Solution()\n    board = [[5, 6, -4], [-3, 2, -9]]\n    assert solution.snakesAndLadders(board) == 8", "def test_snakesAndLadders():\n\n    class Solution:\n\n        def snakesAndLadders(self, board: List[List[int]]) -> int:\n            n = len(board)\n            ans = 0\n            q = collections.deque([1])\n            seen = set()\n            A = [0] * (1 + n * n)\n            for i in range(n):\n                for j in range(n):\n                    if n - i & 1:\n                        A[(n - 1 - i) * n + (j + 1)] = board[i][j]\n                    else:\n                        A[(n - 1 - i) * n + (n - j)] = board[i][j]\n            while q:\n                ans += 1\n                for _ in range(len(q)):\n                    curr = q.popleft()\n                    for next in range(curr + 1, min(curr + 6, n * n) + 1):\n                        dest = A[next] if A[next] > 0 else next\n                        if dest == n * n:\n                            return ans\n                        if dest in seen:\n                            continue\n                        q.append(dest)\n                        seen.add(dest)\n            return -1\n    solution = Solution()\n    board = [[3, -6, 7], [8, -5, -4]]\n    assert solution.snakesAndLadders(board) == -1", "def test_snakesAndLadders():\n\n    class Solution:\n\n        def snakesAndLadders(self, board: List[List[int]]) -> int:\n            n = len(board)\n            ans = 0\n            q = collections.deque([1])\n            seen = set()\n            A = [0] * (1 + n * n)\n            for i in range(n):\n                for j in range(n):\n                    if n - i & 1:\n                        A[(n - 1 - i) * n + (j + 1)] = board[i][j]\n                    else:\n                        A[(n - 1 - i) * n + (n - j)] = board[i][j]\n            while q:\n                ans += 1\n                for _ in range(len(q)):\n                    curr = q.popleft()\n                    for next in range(curr + 1, min(curr + 6, n * n) + 1):\n                        dest = A[next] if A[next] > 0 else next\n                        if dest == n * n:\n                            return ans\n                        if dest in seen:\n                            continue\n                        q.append(dest)\n                        seen.add(dest)\n            return -1\n    solution = Solution()\n    board = [[8, 7, -5], [4, 3, -9]]\n    assert solution.snakesAndLadders(board) == 11", "def test_snakesAndLadders():\n\n    class Solution:\n\n        def snakesAndLadders(self, board: List[List[int]]) -> int:\n            n = len(board)\n            ans = 0\n            q = collections.deque([1])\n            seen = set()\n            A = [0] * (1 + n * n)\n            for i in range(n):\n                for j in range(n):\n                    if n - i & 1:\n                        A[(n - 1 - i) * n + (j + 1)] = board[i][j]\n                    else:\n                        A[(n - 1 - i) * n + (n - j)] = board[i][j]\n            while q:\n                ans += 1\n                for _ in range(len(q)):\n                    curr = q.popleft()\n                    for next in range(curr + 1, min(curr + 6, n * n) + 1):\n                        dest = A[next] if A[next] > 0 else next\n                        if dest == n * n:\n                            return ans\n                        if dest in seen:\n                            continue\n                        q.append(dest)\n                        seen.add(dest)\n            return -1\n    solution = Solution()\n    board = [[5, 6, 7], [3, -9, -4]]\n    assert solution.snakesAndLadders(board) == 10", "def test_snakesAndLadders():\n\n    class Solution:\n\n        def snakesAndLadders(self, board: List[List[int]]) -> int:\n            n = len(board)\n            ans = 0\n            q = collections.deque([1])\n            seen = set()\n            A = [0] * (1 + n * n)\n            for i in range(n):\n                for j in range(n):\n                    if n - i & 1:\n                        A[(n - 1 - i) * n + (j + 1)] = board[i][j]\n                    else:\n                        A[(n - 1 - i) * n + (n - j)] = board[i][j]\n            while q:\n                ans += 1\n                for _ in range(len(q)):\n                    curr = q.popleft()\n                    for next in range(curr + 1, min(curr + 6, n * n) + 1):\n                        dest = A[next] if A[next] > 0 else next\n                        if dest == n * n:\n                            return ans\n                        if dest in seen:\n                            continue\n                        q.append(dest)\n                        seen.add(dest)\n            return -1\n    solution = Solution()\n    board = [[3, 5, -7], [2, 8, -9]]\n    assert solution.snakesAndLadders(board) == -1", "def test_snakesAndLadders():\n\n    class Solution:\n\n        def snakesAndLadders(self, board: List[List[int]]) -> int:\n            n = len(board)\n            ans = 0\n            q = collections.deque([1])\n            seen = set()\n            A = [0] * (1 + n * n)\n            for i in range(n):\n                for j in range(n):\n                    if n - i & 1:\n                        A[(n - 1 - i) * n + (j + 1)] = board[i][j]\n                    else:\n                        A[(n - 1 - i) * n + (n - j)] = board[i][j]\n            while q:\n                ans += 1\n                for _ in range(len(q)):\n                    curr = q.popleft()\n                    for next in range(curr + 1, min(curr + 6, n * n) + 1):\n                        dest = A[next] if A[next] > 0 else next\n                        if dest == n * n:\n                            return ans\n                        if dest in seen:\n                            continue\n                        q.append(dest)\n                        seen.add(dest)\n            return -1\n    solution = Solution()\n    board = [[2, 4, -6], [8, 3, -9]]\n    assert solution.snakesAndLadders(board) == 10", "def test_snakesAndLadders():\n\n    class Solution:\n\n        def snakesAndLadders(self, board: List[List[int]]) -> int:\n            n = len(board)\n            ans = 0\n            q = collections.deque([1])\n            seen = set()\n            A = [0] * (1 + n * n)\n            for i in range(n):\n                for j in range(n):\n                    if n - i & 1:\n                        A[(n - 1 - i) * n + (j + 1)] = board[i][j]\n                    else:\n                        A[(n - 1 - i) * n + (n - j)] = board[i][j]\n            while q:\n                ans += 1\n                for _ in range(len(q)):\n                    curr = q.popleft()\n                    for next in range(curr + 1, min(curr + 6, n * n) + 1):\n                        dest = A[next] if A[next] > 0 else next\n                        if dest == n * n:\n                            return ans\n                        if dest in seen:\n                            continue\n                        q.append(dest)\n                        seen.add(dest)\n            return -1\n    solution = Solution()\n    board = [[5, -8, 7], [3, -4, -9]]\n    assert solution.snakesAndLadders(board) == 11", "def test_snakesAndLadders():\n\n    class Solution:\n\n        def snakesAndLadders(self, board: List[List[int]]) -> int:\n            n = len(board)\n            ans = 0\n            q = collections.deque([1])\n            seen = set()\n            A = [0] * (1 + n * n)\n            for i in range(n):\n                for j in range(n):\n                    if n - i & 1:\n                        A[(n - 1 - i) * n + (j + 1)] = board[i][j]\n                    else:\n                        A[(n - 1 - i) * n + (n - j)] = board[i][j]\n            while q:\n                ans += 1\n                for _ in range(len(q)):\n                    curr = q.popleft()\n                    for next in range(curr + 1, min(curr + 6, n * n) + 1):\n                        dest = A[next] if A[next] > 0 else next\n                        if dest == n * n:\n                            return ans\n                        if dest in seen:\n                            continue\n                        q.append(dest)\n                        seen.add(dest)\n            return -1\n    solution = Solution()\n    board = [[2, 5, -8], [3, -4, 7]]\n    assert solution.snakesAndLadders(board) == 11", "def test_snakesAndLadders():\n\n    class Solution:\n\n        def snakesAndLadders(self, board: List[List[int]]) -> int:\n            n = len(board)\n            ans = 0\n            q = collections.deque([1])\n            seen = set()\n            A = [0] * (1 + n * n)\n            for i in range(n):\n                for j in range(n):\n                    if n - i & 1:\n                        A[(n - 1 - i) * n + (j + 1)] = board[i][j]\n                    else:\n                        A[(n - 1 - i) * n + (n - j)] = board[i][j]\n            while q:\n                ans += 1\n                for _ in range(len(q)):\n                    curr = q.popleft()\n                    for next in range(curr + 1, min(curr + 6, n * n) + 1):\n                        dest = A[next] if A[next] > 0 else next\n                        if dest == n * n:\n                            return ans\n                        if dest in seen:\n                            continue\n                        q.append(dest)\n                        seen.add(dest)\n            return -1\n    solution = Solution()\n    board = [[7, -5, 8], [3, -4, 2]]\n    assert solution.snakesAndLadders(board) == 9", "def test_snakesAndLadders():\n\n    class Solution:\n\n        def snakesAndLadders(self, board: List[List[int]]) -> int:\n            n = len(board)\n            ans = 0\n            q = collections.deque([1])\n            seen = set()\n            A = [0] * (1 + n * n)\n            for i in range(n):\n                for j in range(n):\n                    if n - i & 1:\n                        A[(n - 1 - i) * n + (j + 1)] = board[i][j]\n                    else:\n                        A[(n - 1 - i) * n + (n - j)] = board[i][j]\n            while q:\n                ans += 1\n                for _ in range(len(q)):\n                    curr = q.popleft()\n                    for next in range(curr + 1, min(curr + 6, n * n) + 1):\n                        dest = A[next] if A[next] > 0 else next\n                        if dest == n * n:\n                            return ans\n                        if dest in seen:\n                            continue\n                        q.append(dest)\n                        seen.add(dest)\n            return -1\n    solution = Solution()\n    board = [[4, -5, 7], [3, -9, 2]]\n    assert solution.snakesAndLadders(board) == 10", "def test_snakesAndLadders():\n\n    class Solution:\n\n        def snakesAndLadders(self, board: List[List[int]]) -> int:\n            n = len(board)\n            ans = 0\n            q = collections.deque([1])\n            seen = set()\n            A = [0] * (1 + n * n)\n            for i in range(n):\n                for j in range(n):\n                    if n - i & 1:\n                        A[(n - 1 - i) * n + (j + 1)] = board[i][j]\n                    else:\n                        A[(n - 1 - i) * n + (n - j)] = board[i][j]\n            while q:\n                ans += 1\n                for _ in range(len(q)):\n                    curr = q.popleft()\n                    for next in range(curr + 1, min(curr + 6, n * n) + 1):\n                        dest = A[next] if A[next] > 0 else next\n                        if dest == n * n:\n                            return ans\n                        if dest in seen:\n                            continue\n                        q.append(dest)\n                        seen.add(dest)\n            return -1\n    solution = Solution()\n    board = [[5, -8, 7], [-4, 3, 2]]\n    assert solution.snakesAndLadders(board) == 9", "def test_snakesAndLadders():\n\n    class Solution:\n\n        def snakesAndLadders(self, board: List[List[int]]) -> int:\n            n = len(board)\n            ans = 0\n            q = collections.deque([1])\n            seen = set()\n            A = [0] * (1 + n * n)\n            for i in range(n):\n                for j in range(n):\n                    if n - i & 1:\n                        A[(n - 1 - i) * n + (j + 1)] = board[i][j]\n                    else:\n                        A[(n - 1 - i) * n + (n - j)] = board[i][j]\n            while q:\n                ans += 1\n                for _ in range(len(q)):\n                    curr = q.popleft()\n                    for next in range(curr + 1, min(curr + 6, n * n) + 1):\n                        dest = A[next] if A[next] > 0 else next\n                        if dest == n * n:\n                            return ans\n                        if dest in seen:\n                            continue\n                        q.append(dest)\n                        seen.add(dest)\n            return -1\n    solution = Solution()\n    board = [[2, 5, -8], [3, -4, 7]]\n    assert solution.snakesAndLadders(board) == 10", "def test_snakesAndLadders():\n\n    class Solution:\n\n        def snakesAndLadders(self, board: List[List[int]]) -> int:\n            n = len(board)\n            ans = 0\n            q = collections.deque([1])\n            seen = set()\n            A = [0] * (1 + n * n)\n            for i in range(n):\n                for j in range(n):\n                    if n - i & 1:\n                        A[(n - 1 - i) * n + (j + 1)] = board[i][j]\n                    else:\n                        A[(n - 1 - i) * n + (n - j)] = board[i][j]\n            while q:\n                ans += 1\n                for _ in range(len(q)):\n                    curr = q.popleft()\n                    for next in range(curr + 1, min(curr + 6, n * n) + 1):\n                        dest = A[next] if A[next] > 0 else next\n                        if dest == n * n:\n                            return ans\n                        if dest in seen:\n                            continue\n                        q.append(dest)\n                        seen.add(dest)\n            return -1\n    solution = Solution()\n    board = [[8, -5, 2], [-4, 3, 7]]\n    assert solution.snakesAndLadders(board) == 9", "def test_snakesAndLadders():\n\n    class Solution:\n\n        def snakesAndLadders(self, board: List[List[int]]) -> int:\n            n = len(board)\n            ans = 0\n            q = collections.deque([1])\n            seen = set()\n            A = [0] * (1 + n * n)\n            for i in range(n):\n                for j in range(n):\n                    if n - i & 1:\n                        A[(n - 1 - i) * n + (j + 1)] = board[i][j]\n                    else:\n                        A[(n - 1 - i) * n + (n - j)] = board[i][j]\n            while q:\n                ans += 1\n                for _ in range(len(q)):\n                    curr = q.popleft()\n                    for next in range(curr + 1, min(curr + 6, n * n) + 1):\n                        dest = A[next] if A[next] > 0 else next\n                        if dest == n * n:\n                            return ans\n                        if dest in seen:\n                            continue\n                        q.append(dest)\n                        seen.add(dest)\n            return -1\n    solution = Solution()\n    board = [[7, 5, -4], [8, -3, 2]]\n    assert solution.snakesAndLadders(board) == 10", "def test_snakesAndLadders():\n\n    class Solution:\n\n        def snakesAndLadders(self, board: List[List[int]]) -> int:\n            n = len(board)\n            ans = 0\n            q = collections.deque([1])\n            seen = set()\n            A = [0] * (1 + n * n)\n            for i in range(n):\n                for j in range(n):\n                    if n - i & 1:\n                        A[(n - 1 - i) * n + (j + 1)] = board[i][j]\n                    else:\n                        A[(n - 1 - i) * n + (n - j)] = board[i][j]\n            while q:\n                ans += 1\n                for _ in range(len(q)):\n                    curr = q.popleft()\n                    for next in range(curr + 1, min(curr + 6, n * n) + 1):\n                        dest = A[next] if A[next] > 0 else next\n                        if dest == n * n:\n                            return ans\n                        if dest in seen:\n                            continue\n                        q.append(dest)\n                        seen.add(dest)\n            return -1\n    solution = Solution()\n    board = [[3, 7, -4], [5, 2, -9]]\n    assert solution.snakesAndLadders(board) == 8"]}
{"task_num": 913, "task_title": "Cat and Mouse", "func_name": "catMouseGame", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import IntEnum\n\n\nclass State(IntEnum):\n  kDraw = 0\n  kMouseWin = 1\n  kCatWin = 2\n\n\nclass Solution:\n  def catMouseGame(self, graph: List[List[int]]) -> int:\n    n = len(graph)\n    states = [[[0] * 2 for i in range(n)] for j in range(n)]\n    outDegree = [[[0] * 2 for i in range(n)] for j in range(n)]\n    q = collections.deque()\n\n    for cat in range(n):\n      for mouse in range(n):\n        outDegree[cat][mouse][0] = len(graph[mouse])\n        outDegree[cat][mouse][1] = len(graph[cat]) - graph[cat].count(0)\n\n    for cat in range(1, n):\n      for move in range(2):\n        states[cat][0][move] = int(State.kMouseWin)\n        q.append((cat, 0, move, int(State.kMouseWin)))\n        states[cat][cat][move] = int(State.kCatWin)\n        q.append((cat, cat, move, int(State.kCatWin)))\n\n    while q:\n      cat, mouse, move, state = q.popleft()\n      if cat == 2 and mouse == 1 and move == 0:\n        return state\n      prevMove = move ^ 1\n      for prev in graph[cat if prevMove else mouse]:\n        prevCat = prev if prevMove else cat\n        if prevCat == 0:\n          continue\n        prevMouse = mouse if prevMove else prev\n        if states[prevCat][prevMouse][prevMove]:\n          continue\n        if prevMove == 0 and state == int(State.kMouseWin) or \\\n                prevMove == 1 and state == int(State.kCatWin):\n          states[prevCat][prevMouse][prevMove] = state\n          q.append((prevCat, prevMouse, prevMove, state))\n        else:\n          outDegree[prevCat][prevMouse][prevMove] -= 1\n          if outDegree[prevCat][prevMouse][prevMove] == 0:\n            states[prevCat][prevMouse][prevMove] = state\n            q.append((prevCat, prevMouse, prevMove, state))\n\n    return states[2][1][0]\n", "tests": ["def test_catMouseGame(self):\n    solution = Solution()\n    graph = [[1, 2], [], [0, 3], []]\n    self.assertEqual(solution.catMouseGame(graph), 2)", "def test_catMouseGame(self):\n    solution = Solution()\n    graph = [[1, 2], [0], [], []]\n    self.assertEqual(solution.catMouseGame(graph), 1)", "def test_catMouseGame(self):\n    solution = Solution()\n    graph = [[1], [2, 0], []]\n    self.assertEqual(solution.catMouseGame(graph), 0)", "def test_catMouseGame(self):\n    solution = Solution()\n    graph = [[1, 2], [3], [4]]\n    self.assertEqual(solution.catMouseGame(graph), 0)", "def test_catMouseGame(self):\n    solution = Solution()\n    graph = [[0, 2], [], []]\n    self.assertEqual(solution.catMouseGame(graph), 1)", "def test_catMouseGame(self):\n    solution = Solution()\n    graph = [[1, 2], [0, 3, 4], [5], [6]]\n    self.assertEqual(solution.catMouseGame(graph), 0)", "def test_catMouseGame(self):\n    solution = Solution()\n    graph = [[1, 2, 3], [4, 5], [6, 7, 0], [], []]\n    self.assertEqual(solution.catMouseGame(graph), 2)", "def test_catMouseGame(self):\n    solution = Solution()\n    graph = [[0]]\n    self.assertEqual(solution.catMouseGame(graph), 2)", "def test_catMouseGame(self):\n    solution = Solution()\n    graph = [[1, 2], [3]]\n    self.assertEqual(solution.catMouseGame(graph), 0)", "def test_catMouseGame(self):\n    solution = Solution()\n    graph = [[], [], []]\n    self.assertEqual(solution.catMouseGame(graph), 0)", "def test_catMouseGame(self):\n    solution = Solution()\n    graph = []\n    self.assertEqual(solution.catMouseGame(graph), None)", "def test_catMouseGame(self):\n    solution = Solution()\n    graph = [[0, 1], [2], [], [2]]\n    self.assertEqual(solution.catMouseGame(graph), 1)", "def test_catMouseGame(self):\n    solution = Solution()\n    graph = [[1, 2], [0, 3], [0]]\n    self.assertEqual(solution.catMouseGame(graph), 2)", "def test_catMouseGame(self):\n    solution = Solution()\n    graph = [[1, 2], [3, 4], [5, 6], [0, 7], [8]]\n    self.assertEqual(solution.catMouseGame(graph), 0)", "def test_catMouseGame(self):\n    solution = Solution()\n    graph = [[1, 2], [0, 5, 6], [3, 4], [], [7]]\n    self.assertEqual(solution.catMouseGame(graph), 2)", "def test_catMouseGame(self):\n    solution = Solution()\n    graph = [[1, 2], [3, 4, 0], [], [5, 6], [7]]\n    self.assertEqual(solution.catMouseGame(graph), 0)", "def test_catMouseGame(self):\n    solution = Solution()\n    graph = [[1, 2], [], [0, 3], []]\n    self.assertEqual(solution.catMouseGame(graph), 2)", "def test_catMouseGame(self):\n    solution = Solution()\n    graph = [[1, 2], [0, 3], [4], [], []]\n    self.assertEqual(solution.catMouseGame(graph), 0)", "def test_catMouseGame(self):\n    solution = Solution()\n    graph = [[1, 0], [0]]\n    self.assertEqual(solution.catMouseGame(graph), 2)", "def test_catMouseGame(self):\n    solution = Solution()\n    graph = [[1, 2], [0, 3], [4, 5]]\n    self.assertEqual(solution.catMouseGame(graph), 0)"]}
{"task_num": 923, "task_title": "3Sum With Multiplicity", "func_name": "threeSumMulti", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def threeSumMulti(self, arr: List[int], target: int) -> int:\n    kMod = 1_000_000_007\n    ans = 0\n    count = collections.Counter(arr)\n\n    for i, x in count.items():\n      for j, y in count.items():\n        k = target - i - j\n        if k not in count:\n          continue\n        if i == j and j == k:\n          ans = (ans + x * (x - 1) * (x - 2) // 6) % kMod\n        elif i == j and j != k:\n          ans = (ans + x * (x - 1) // 2 * count[k]) % kMod\n        elif i < j and j < k:\n          ans = (ans + x * y * count[k]) % kMod\n\n    return ans % kMod\n", "tests": ["def test_threeSumMulti():\n    solution = Solution()\n    arr = [1, 2, 3, 4, 5]\n    target = 6\n    assert solution.threeSumMulti(arr, target) == 6", "def test_threeSumMulti():\n    solution = Solution()\n    arr = [1, 2, 3]\n    target = 6\n    assert solution.threeSumMulti(arr, target) == 0", "def test_threeSumMulti():\n    solution = Solution()\n    arr = [1, 2, 3, 4]\n    target = 7\n    assert solution.threeSumMulti(arr, target) == 9", "def test_threeSumMulti():\n    solution = Solution()\n    arr = [1, 2, 3, 4, 5]\n    target = 9\n    assert solution.threeSumMulti(arr, target) == 16", "def test_threeSumMulti():\n    solution = Solution()\n    arr = [5]\n    target = 7\n    assert solution.threeSumMulti(arr, target) == 0", "def test_threeSumMulti():\n    solution = Solution()\n    arr = [5, 5, 5]\n    target = 15\n    assert solution.threeSumMulti(arr, target) == 10", "def test_threeSumMulti():\n    solution = Solution()\n    arr = [1, 2, 3, 4, 5]\n    target = 6\n    assert solution.threeSumMulti(arr, target) == 6", "def test_threeSumMulti():\n    solution = Solution()\n    arr = [1, 2, 3]\n    target = 6\n    assert solution.threeSumMulti(arr, target) == 0", "def test_threeSumMulti():\n    solution = Solution()\n    arr = [5]\n    target = 6\n    assert solution.threeSumMulti(arr, target) == 0", "def test_threeSumMulti():\n    solution = Solution()\n    arr = [1, 1, 2, 2]\n    target = 5\n    assert solution.threeSumMulti(arr, target) == 2", "def test_threeSumMulti():\n    solution = Solution()\n    arr = [1, 1, 1]\n    target = 3\n    assert solution.threeSumMulti(arr, target) == 1", "def test_threeSumMulti():\n    solution = Solution()\n    arr = [5, 4, 3]\n    target = 12\n    assert solution.threeSumMulti(arr, target) == 0", "def test_threeSumMulti():\n    solution = Solution()\n    arr = [1, 2, 3, 4]\n    target = 9\n    assert solution.threeSumMulti(arr, target) == 6", "def test_threeSumMulti():\n    solution = Solution()\n    arr = [2, 2, 3]\n    target = 7\n    assert solution.threeSumMulti(arr, target) == 6", "def test_threeSumMulti():\n    solution = Solution()\n    arr = [5, 5]\n    target = 10\n    assert solution.threeSumMulti(arr, target) == 1", "def test_threeSumMulti():\n    solution = Solution()\n    arr = [5, 5, 2]\n    target = 12\n    assert solution.threeSumMulti(arr, target) == 7", "def test_threeSumMulti():\n    solution = Solution()\n    arr = [2, 4, 5]\n    target = 11\n    assert solution.threeSumMulti(arr, target) == 0", "def test_threeSumMulti():\n    solution = Solution()\n    arr = [1]\n    target = 2\n    assert solution.threeSumMulti(arr, target) == 0", "def test_threeSumMulti():\n    solution = Solution()\n    arr = [5]\n    target = 7\n    assert solution.threeSumMulti(arr, target) == 0", "def test_threeSumMulti():\n    solution = Solution()\n    arr = [1, 2, 3]\n    target = 5\n    assert solution.threeSumMulti(arr, target) == 2"]}
{"task_num": 927, "task_title": "Three Equal Parts", "func_name": "threeEqualParts", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def threeEqualParts(self, arr: List[int]) -> List[int]:\n    ones = sum(a == 1 for a in arr)\n\n    if ones == 0:\n      return [0, len(arr) - 1]\n    if ones % 3 != 0:\n      return [-1, -1]\n\n    k = ones // 3\n    i = 0\n\n    for i in range(len(arr)):\n      if arr[i] == 1:\n        first = i\n        break\n\n    gapOnes = k\n\n    for j in range(i + 1, len(arr)):\n      if arr[j] == 1:\n        gapOnes -= 1\n        if gapOnes == 0:\n          second = j\n          break\n\n    gapOnes = k\n\n    for i in range(j + 1, len(arr)):\n      if arr[i] == 1:\n        gapOnes -= 1\n        if gapOnes == 0:\n          third = i\n          break\n\n    while third < len(arr) and arr[first] == arr[second] == arr[third]:\n      first += 1\n      second += 1\n      third += 1\n\n    if third == len(arr):\n      return [first - 1, second]\n    return [-1, -1]\n", "tests": ["def test_threeEqualParts():\n    solution = Solution()\n    arr = [1, 1, 0]\n    assert solution.threeEqualParts(arr) == [1, 2], f'Expected [1, 2] but got {solution.threeEqualParts(arr)}'", "def test_threeEqualParts():\n    solution = Solution()\n    arr = [1, 0, 1, 1]\n    assert solution.threeEqualParts(arr) == [-1, -1], f'Expected [-1, -1] but got {solution.threeEqualParts(arr)}'", "def test_threeEqualParts():\n    solution = Solution()\n    arr = [1, 0, 1, 1, 1]\n    assert solution.threeEqualParts(arr) == [2, 3], f'Expected [2, 3] but got {solution.threeEqualParts(arr)}'", "def test_threeEqualParts():\n    solution = Solution()\n    arr = [0]\n    assert solution.threeEqualParts(arr) == [-1, -1], f'Expected [-1, -1] but got {solution.threeEqualParts(arr)}'", "def test_threeEqualParts():\n    solution = Solution()\n    arr = [1] * 1000\n    assert solution.threeEqualParts(arr) == [-1, -1], f'Expected [-1, -1] but got {solution.threeEqualParts(arr)}'", "def test_threeEqualParts():\n    solution = Solution()\n    arr = [1, 0, 1]\n    assert solution.threeEqualParts(arr) == [-1, -1], f'Expected [-1, -1] but got {solution.threeEqualParts(arr)}'", "def test_threeEqualParts():\n    solution = Solution()\n    arr = [1, 0, 1, 1, 1, 1]\n    assert solution.threeEqualParts(arr) == [2, 4], f'Expected [2, 4] but got {solution.threeEqualParts(arr)}'", "def test_threeEqualParts():\n    solution = Solution()\n    arr = [1] * 7 + [0]\n    assert solution.threeEqualParts(arr) == [-1, -1], f'Expected [-1, -1] but got {solution.threeEqualParts(arr)}'", "def test_threeEqualParts():\n    solution = Solution()\n    arr = [1] * 5 + [0] * 10 + [1]\n    assert solution.threeEqualParts(arr) == [-1, -1], f'Expected [-1, -1] but got {solution.threeEqualParts(arr)}'", "def test_threeEqualParts():\n    solution = Solution()\n    arr = [1] * 6 + [0]\n    assert solution.threeEqualParts(arr) == [-1, -1], f'Expected [-1, -1] but got {solution.threeEqualParts(arr)}'", "def test_threeEqualParts():\n    solution = Solution()\n    arr = [1] * 9 + [0]\n    assert solution.threeEqualParts(arr) == [-1, -1], f'Expected [-1, -1] but got {solution.threeEqualParts(arr)}'", "def test_threeEqualParts():\n    solution = Solution()\n    arr = [1] * 6 + [0] * 3 + [1]\n    assert solution.threeEqualParts(arr) == [5, 7], f'Expected [5, 7] but got {solution.threeEqualParts(arr)}'", "def test_threeEqualParts():\n    solution = Solution()\n    arr = [0] * 7 + [1]\n    assert solution.threeEqualParts(arr) == [-1, -1], f'Expected [-1, -1] but got {solution.threeEqualParts(arr)}'", "def test_threeEqualParts():\n    solution = Solution()\n    arr = [1, 0, 0, 1, 0, 1]\n    assert solution.threeEqualParts(arr) == [-1, -1], f'Expected [-1, -1] but got {solution.threeEqualParts(arr)}'", "def test_threeEqualParts():\n    solution = Solution()\n    arr = [0, 1, 0, 0]\n    assert solution.threeEqualParts(arr) == [-1, -1], f'Expected [-1, -1] but got {solution.threeEqualParts(arr)}'", "def test_threeEqualParts():\n    solution = Solution()\n    arr = [1] * 1000 + [0]\n    assert solution.threeEqualParts(arr) == [-1, -1], f'Expected [-1, -1] but got {solution.threeEqualParts(arr)}'", "def test_threeEqualParts():\n    solution = Solution()\n    arr = [1] * 10000 + [0]\n    assert solution.threeEqualParts(arr) == [-1, -1], f'Expected [-1, -1] but got {solution.threeEqualParts(arr)}'", "def test_threeEqualParts():\n    solution = Solution()\n    arr = [1] * 100000 + [0]\n    assert solution.threeEqualParts(arr) == [-1, -1], f'Expected [-1, -1] but got {solution.threeEqualParts(arr)}'", "def test_threeEqualParts():\n    solution = Solution()\n    arr = [1] * 1000000 + [0]\n    assert solution.threeEqualParts(arr) == [-1, -1], f'Expected [-1, -1] but got {solution.threeEqualParts(arr)}'", "def test_threeEqualParts():\n    solution = Solution()\n    arr = [0] * 10000000 + [1]\n    assert solution.threeEqualParts(arr) == [-1, -1], f'Expected [-1, -1] but got {solution.threeEqualParts(arr)}'"]}
{"task_num": 935, "task_title": "Knight Dialer", "func_name": "knightDialer", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def knightDialer(self, n: int) -> int:\n    dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n    kMod = 1_000_000_007\n\n    dp = [[1] * 3 for _ in range(4)]\n    dp[3][0] = dp[3][2] = 0\n\n    for _ in range(n - 1):\n      newDp = [[0] * 3 for _ in range(4)]\n      for i in range(4):\n        for j in range(3):\n          if (i, j) in ((3, 0), (3, 2)):\n            continue\n          for dx, dy in dirs:\n            x = i + dx\n            y = j + dy\n            if x < 0 or x >= 4 or y < 0 or y >= 3:\n              continue\n            if (x, y) in ((3, 0), (3, 2)):\n              continue\n            newDp[x][y] = (newDp[x][y] + dp[i][j]) % kMod\n      dp = newDp\n\n    return sum(map(sum, dp)) % kMod\n", "tests": ["def test_knightDialer():\n\n    class Solution:\n\n        def knightDialer(self, n: int) -> int:\n            dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n            kMod = 1000000007\n            dp = [[1] * 3 for _ in range(4)]\n            dp[3][0] = dp[3][2] = 0\n            for _ in range(n - 1):\n                newDp = [[0] * 3 for _ in range(4)]\n                for i in range(4):\n                    for j in range(3):\n                        if (i, j) in ((3, 0), (3, 2)):\n                            continue\n                        for (dx, dy) in dirs:\n                            x = i + dx\n                            y = j + dy\n                            if x < 0 or x >= 4 or y < 0 or (y >= 3):\n                                continue\n                            if (x, y) in ((3, 0), (3, 2)):\n                                continue\n                            newDp[x][y] = (newDp[x][y] + dp[i][j]) % kMod\n                dp = newDp\n            return sum(map(sum, dp)) % kMod\n    solution = Solution()\n    print(solution.knightDialer(3))", "def test_knightDialer():\n\n    class Solution:\n\n        def knightDialer(self, n: int) -> int:\n            dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n            kMod = 1000000007\n            dp = [[1] * 3 for _ in range(4)]\n            dp[3][0] = dp[3][2] = 0\n            for _ in range(n - 1):\n                newDp = [[0] * 3 for _ in range(4)]\n                for i in range(4):\n                    for j in range(3):\n                        if (i, j) in ((3, 0), (3, 2)):\n                            continue\n                        for (dx, dy) in dirs:\n                            x = i + dx\n                            y = j + dy\n                            if x < 0 or x >= 4 or y < 0 or (y >= 3):\n                                continue\n                            if (x, y) in ((3, 0), (3, 2)):\n                                continue\n                            newDp[x][y] = (newDp[x][y] + dp[i][j]) % kMod\n                dp = newDp\n            return sum(map(sum, dp)) % kMod\n    solution = Solution()\n    print(solution.knightDialer(10))", "def test_knightDialer():\n\n    class Solution:\n\n        def knightDialer(self, n: int) -> int:\n            dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n            kMod = 1000000007\n            dp = [[1] * 3 for _ in range(4)]\n            dp[3][0] = dp[3][2] = 0\n            for _ in range(n - 1):\n                newDp = [[0] * 3 for _ in range(4)]\n                for i in range(4):\n                    for j in range(3):\n                        if (i, j) in ((3, 0), (3, 2)):\n                            continue\n                        for (dx, dy) in dirs:\n                            x = i + dx\n                            y = j + dy\n                            if x < 0 or x >= 4 or y < 0 or (y >= 3):\n                                continue\n                            if (x, y) in ((3, 0), (3, 2)):\n                                continue\n                            newDp[x][y] = (newDp[x][y] + dp[i][j]) % kMod\n                dp = newDp\n            return sum(map(sum, dp)) % kMod\n    solution = Solution()\n    print(solution.knightDialer(0))", "def test_knightDialer():\n\n    class Solution:\n\n        def knightDialer(self, n: int) -> int:\n            dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n            kMod = 1000000007\n            dp = [[1] * 3 for _ in range(4)]\n            dp[3][0] = dp[3][2] = 0\n            for _ in range(n - 1):\n                newDp = [[0] * 3 for _ in range(4)]\n                for i in range(4):\n                    for j in range(3):\n                        if (i, j) in ((3, 0), (3, 2)):\n                            continue\n                        for (dx, dy) in dirs:\n                            x = i + dx\n                            y = j + dy\n                            if x < 0 or x >= 4 or y < 0 or (y >= 3):\n                                continue\n                            if (x, y) in ((3, 0), (3, 2)):\n                                continue\n                            newDp[x][y] = (newDp[x][y] + dp[i][j]) % kMod\n                dp = newDp\n            return sum(map(sum, dp)) % kMod\n    solution = Solution()\n    print(solution.knightDialer(1))", "def test_knightDialer():\n\n    class Solution:\n\n        def knightDialer(self, n: int) -> int:\n            dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n            kMod = 1000000007\n            dp = [[1] * 3 for _ in range(4)]\n            dp[3][0] = dp[3][2] = 0\n            for _ in range(n - 1):\n                newDp = [[0] * 3 for _ in range(4)]\n                for i in range(4):\n                    for j in range(3):\n                        if (i, j) in ((3, 0), (3, 2)):\n                            continue\n                        for (dx, dy) in dirs:\n                            x = i + dx\n                            y = j + dy\n                            if x < 0 or x >= 4 or y < 0 or (y >= 3):\n                                continue\n                            if (x, y) in ((3, 0), (3, 2)):\n                                continue\n                            newDp[x][y] = (newDp[x][y] + dp[i][j]) % kMod\n                dp = newDp\n            return sum(map(sum, dp)) % kMod\n    solution = Solution()\n    print(solution.knightDialer(5))", "def test_knightDialer():\n\n    class Solution:\n\n        def knightDialer(self, n: int) -> int:\n            dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n            kMod = 1000000007\n            dp = [[1] * 3 for _ in range(4)]\n            dp[3][0] = dp[3][2] = 0\n            for _ in range(n - 1):\n                newDp = [[0] * 3 for _ in range(4)]\n                for i in range(4):\n                    for j in range(3):\n                        if (i, j) in ((3, 0), (3, 2)):\n                            continue\n                        for (dx, dy) in dirs:\n                            x = i + dx\n                            y = j + dy\n                            if x < 0 or x >= 4 or y < 0 or (y >= 3):\n                                continue\n                            if (x, y) in ((3, 0), (3, 2)):\n                                continue\n                            newDp[x][y] = (newDp[x][y] + dp[i][j]) % kMod\n                dp = newDp\n            return sum(map(sum, dp)) % kMod\n    solution = Solution()\n    print(solution.knightDialer(7))", "def test_knightDialer():\n\n    class Solution:\n\n        def knightDialer(self, n: int) -> int:\n            dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n            kMod = 1000000007\n            dp = [[1] * 3 for _ in range(4)]\n            dp[3][0] = dp[3][2] = 0\n            for _ in range(n - 1):\n                newDp = [[0] * 3 for _ in range(4)]\n                for i in range(4):\n                    for j in range(3):\n                        if (i, j) in ((3, 0), (3, 2)):\n                            continue\n                        for (dx, dy) in dirs:\n                            x = i + dx\n                            y = j + dy\n                            if x < 0 or x >= 4 or y < 0 or (y >= 3):\n                                continue\n                            if (x, y) in ((3, 0), (3, 2)):\n                                continue\n                            newDp[x][y] = (newDp[x][y] + dp[i][j]) % kMod\n                dp = newDp\n            return sum(map(sum, dp)) % kMod\n    solution = Solution()\n    print(solution.knightDialer(13))", "def test_knightDialer():\n\n    class Solution:\n\n        def knightDialer(self, n: int) -> int:\n            dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n            kMod = 1000000007\n            dp = [[1] * 3 for _ in range(4)]\n            dp[3][0] = dp[3][2] = 0\n            for _ in range(n - 1):\n                newDp = [[0] * 3 for _ in range(4)]\n                for i in range(4):\n                    for j in range(3):\n                        if (i, j) in ((3, 0), (3, 2)):\n                            continue\n                        for (dx, dy) in dirs:\n                            x = i + dx\n                            y = j + dy\n                            if x < 0 or x >= 4 or y < 0 or (y >= 3):\n                                continue\n                            if (x, y) in ((3, 0), (3, 2)):\n                                continue\n                            newDp[x][y] = (newDp[x][y] + dp[i][j]) % kMod\n                dp = newDp\n            return sum(map(sum, dp)) % kMod\n    solution = Solution()\n    print(solution.knightDialer(20))", "def test_knightDialer():\n\n    class Solution:\n\n        def knightDialer(self, n: int) -> int:\n            dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n            kMod = 1000000007\n            dp = [[1] * 3 for _ in range(4)]\n            dp[3][0] = dp[3][2] = 0\n            for _ in range(n - 1):\n                newDp = [[0] * 3 for _ in range(4)]\n                for i in range(4):\n                    for j in range(3):\n                        if (i, j) in ((3, 0), (3, 2)):\n                            continue\n                        for (dx, dy) in dirs:\n                            x = i + dx\n                            y = j + dy\n                            if x < 0 or x >= 4 or y < 0 or (y >= 3):\n                                continue\n                            if (x, y) in ((3, 0), (3, 2)):\n                                continue\n                            newDp[x][y] = (newDp[x][y] + dp[i][j]) % kMod\n                dp = newDp\n            return sum(map(sum, dp)) % kMod\n    solution = Solution()\n    print(solution.knightDialer(30))", "def test_knightDialer():\n\n    class Solution:\n\n        def knightDialer(self, n: int) -> int:\n            dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n            kMod = 1000000007\n            dp = [[1] * 3 for _ in range(4)]\n            dp[3][0] = dp[3][2] = 0\n            for _ in range(n - 1):\n                newDp = [[0] * 3 for _ in range(4)]\n                for i in range(4):\n                    for j in range(3):\n                        if (i, j) in ((3, 0), (3, 2)):\n                            continue\n                        for (dx, dy) in dirs:\n                            x = i + dx\n                            y = j + dy\n                            if x < 0 or x >= 4 or y < 0 or (y >= 3):\n                                continue\n                            if (x, y) in ((3, 0), (3, 2)):\n                                continue\n                            newDp[x][y] = (newDp[x][y] + dp[i][j]) % kMod\n                dp = newDp\n            return sum(map(sum, dp)) % kMod\n    solution = Solution()\n    print(solution.knightDialer(50))", "def test_knightDialer():\n\n    class Solution:\n\n        def knightDialer(self, n: int) -> int:\n            dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n            kMod = 1000000007\n            dp = [[1] * 3 for _ in range(4)]\n            dp[3][0] = dp[3][2] = 0\n            for _ in range(n - 1):\n                newDp = [[0] * 3 for _ in range(4)]\n                for i in range(4):\n                    for j in range(3):\n                        if (i, j) in ((3, 0), (3, 2)):\n                            continue\n                        for (dx, dy) in dirs:\n                            x = i + dx\n                            y = j + dy\n                            if x < 0 or x >= 4 or y < 0 or (y >= 3):\n                                continue\n                            if (x, y) in ((3, 0), (3, 2)):\n                                continue\n                            newDp[x][y] = (newDp[x][y] + dp[i][j]) % kMod\n                dp = newDp\n            return sum(map(sum, dp)) % kMod\n    solution = Solution()\n    print(solution.knightDialer(100))", "def test_knightDialer():\n\n    class Solution:\n\n        def knightDialer(self, n: int) -> int:\n            dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n            kMod = 1000000007\n            dp = [[1] * 3 for _ in range(4)]\n            dp[3][0] = dp[3][2] = 0\n            for _ in range(n - 1):\n                newDp = [[0] * 3 for _ in range(4)]\n                for i in range(4):\n                    for j in range(3):\n                        if (i, j) in ((3, 0), (3, 2)):\n                            continue\n                        for (dx, dy) in dirs:\n                            x = i + dx\n                            y = j + dy\n                            if x < 0 or x >= 4 or y < 0 or (y >= 3):\n                                continue\n                            if (x, y) in ((3, 0), (3, 2)):\n                                continue\n                            newDp[x][y] = (newDp[x][y] + dp[i][j]) % kMod\n                dp = newDp\n            return sum(map(sum, dp)) % kMod\n    solution = Solution()\n    print(solution.knightDialer(1000))", "def test_knightDialer():\n\n    class Solution:\n\n        def knightDialer(self, n: int) -> int:\n            dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n            kMod = 1000000007\n            dp = [[1] * 3 for _ in range(4)]\n            dp[3][0] = dp[3][2] = 0\n            for _ in range(n - 1):\n                newDp = [[0] * 3 for _ in range(4)]\n                for i in range(4):\n                    for j in range(3):\n                        if (i, j) in ((3, 0), (3, 2)):\n                            continue\n                        for (dx, dy) in dirs:\n                            x = i + dx\n                            y = j + dy\n                            if x < 0 or x >= 4 or y < 0 or (y >= 3):\n                                continue\n                            if (x, y) in ((3, 0), (3, 2)):\n                                continue\n                            newDp[x][y] = (newDp[x][y] + dp[i][j]) % kMod\n                dp = newDp\n            return sum(map(sum, dp)) % kMod\n    solution = Solution()\n    print(solution.knightDialer(5000))", "def test_knightDialer():\n\n    class Solution:\n\n        def knightDialer(self, n: int) -> int:\n            dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n            kMod = 1000000007\n            dp = [[1] * 3 for _ in range(4)]\n            dp[3][0] = dp[3][2] = 0\n            for _ in range(n - 1):\n                newDp = [[0] * 3 for _ in range(4)]\n                for i in range(4):\n                    for j in range(3):\n                        if (i, j) in ((3, 0), (3, 2)):\n                            continue\n                        for (dx, dy) in dirs:\n                            x = i + dx\n                            y = j + dy\n                            if x < 0 or x >= 4 or y < 0 or (y >= 3):\n                                continue\n                            if (x, y) in ((3, 0), (3, 2)):\n                                continue\n                            newDp[x][y] = (newDp[x][y] + dp[i][j]) % kMod\n                dp = newDp\n            return sum(map(sum, dp)) % kMod\n    solution = Solution()\n    print(solution.knightDialer(10000))", "def test_knightDialer():\n\n    class Solution:\n\n        def knightDialer(self, n: int) -> int:\n            dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n            kMod = 1000000007\n            dp = [[1] * 3 for _ in range(4)]\n            dp[3][0] = dp[3][2] = 0\n            for _ in range(n - 1):\n                newDp = [[0] * 3 for _ in range(4)]\n                for i in range(4):\n                    for j in range(3):\n                        if (i, j) in ((3, 0), (3, 2)):\n                            continue\n                        for (dx, dy) in dirs:\n                            x = i + dx\n                            y = j + dy\n                            if x < 0 or x >= 4 or y < 0 or (y >= 3):\n                                continue\n                            if (x, y) in ((3, 0), (3, 2)):\n                                continue\n                            newDp[x][y] = (newDp[x][y] + dp[i][j]) % kMod\n                dp = newDp\n            return sum(map(sum, dp)) % kMod\n    solution = Solution()\n    print(solution.knightDialer(20000))", "def test_knightDialer():\n\n    class Solution:\n\n        def knightDialer(self, n: int) -> int:\n            dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n            kMod = 1000000007\n            dp = [[1] * 3 for _ in range(4)]\n            dp[3][0] = dp[3][2] = 0\n            for _ in range(n - 1):\n                newDp = [[0] * 3 for _ in range(4)]\n                for i in range(4):\n                    for j in range(3):\n                        if (i, j) in ((3, 0), (3, 2)):\n                            continue\n                        for (dx, dy) in dirs:\n                            x = i + dx\n                            y = j + dy\n                            if x < 0 or x >= 4 or y < 0 or (y >= 3):\n                                continue\n                            if (x, y) in ((3, 0), (3, 2)):\n                                continue\n                            newDp[x][y] = (newDp[x][y] + dp[i][j]) % kMod\n                dp = newDp\n            return sum(map(sum, dp)) % kMod\n    solution = Solution()\n    print(solution.knightDialer(500000))", "def test_knightDialer():\n\n    class Solution:\n\n        def knightDialer(self, n: int) -> int:\n            dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n            kMod = 1000000007\n            dp = [[1] * 3 for _ in range(4)]\n            dp[3][0] = dp[3][2] = 0\n            for _ in range(n - 1):\n                newDp = [[0] * 3 for _ in range(4)]\n                for i in range(4):\n                    for j in range(3):\n                        if (i, j) in ((3, 0), (3, 2)):\n                            continue\n                        for (dx, dy) in dirs:\n                            x = i + dx\n                            y = j + dy\n                            if x < 0 or x >= 4 or y < 0 or (y >= 3):\n                                continue\n                            if (x, y) in ((3, 0), (3, 2)):\n                                continue\n                            newDp[x][y] = (newDp[x][y] + dp[i][j]) % kMod\n                dp = newDp\n            return sum(map(sum, dp)) % kMod\n    solution = Solution()\n    print(solution.knightDialer(1000000))", "def test_knightDialer():\n\n    class Solution:\n\n        def knightDialer(self, n: int) -> int:\n            dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n            kMod = 1000000007\n            dp = [[1] * 3 for _ in range(4)]\n            dp[3][0] = dp[3][2] = 0\n            for _ in range(n - 1):\n                newDp = [[0] * 3 for _ in range(4)]\n                for i in range(4):\n                    for j in range(3):\n                        if (i, j) in ((3, 0), (3, 2)):\n                            continue\n                        for (dx, dy) in dirs:\n                            x = i + dx\n                            y = j + dy\n                            if x < 0 or x >= 4 or y < 0 or (y >= 3):\n                                continue\n                            if (x, y) in ((3, 0), (3, 2)):\n                                continue\n                            newDp[x][y] = (newDp[x][y] + dp[i][j]) % kMod\n                dp = newDp\n            return sum(map(sum, dp)) % kMod\n    solution = Solution()\n    print(solution.knightDialer(2000000))", "def test_knightDialer():\n\n    class Solution:\n\n        def knightDialer(self, n: int) -> int:\n            dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n            kMod = 1000000007\n            dp = [[1] * 3 for _ in range(4)]\n            dp[3][0] = dp[3][2] = 0\n            for _ in range(n - 1):\n                newDp = [[0] * 3 for _ in range(4)]\n                for i in range(4):\n                    for j in range(3):\n                        if (i, j) in ((3, 0), (3, 2)):\n                            continue\n                        for (dx, dy) in dirs:\n                            x = i + dx\n                            y = j + dy\n                            if x < 0 or x >= 4 or y < 0 or (y >= 3):\n                                continue\n                            if (x, y) in ((3, 0), (3, 2)):\n                                continue\n                            newDp[x][y] = (newDp[x][y] + dp[i][j]) % kMod\n                dp = newDp\n            return sum(map(sum, dp)) % kMod\n    solution = Solution()\n    print(solution.knightDialer(3000000))", "def test_knightDialer():\n\n    class Solution:\n\n        def knightDialer(self, n: int) -> int:\n            dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n            kMod = 1000000007\n            dp = [[1] * 3 for _ in range(4)]\n            dp[3][0] = dp[3][2] = 0\n            for _ in range(n - 1):\n                newDp = [[0] * 3 for _ in range(4)]\n                for i in range(4):\n                    for j in range(3):\n                        if (i, j) not in ((3, 0), (3, 2)):\n                            continue\n                        for (dx, dy) in dirs:\n                            x = i + dx\n                            y = j + dy\n                            if x < 0 or x >= 4 or y < 0 or (y >= 3):\n                                continue\n                            if (x, y) not in ((3, 0), (3, 2)):\n                                continue\n                            newDp[x][y] = (newDp[x][y] + dp[i][j]) % kMod\n                dp = newDp\n            return sum(map(sum, dp)) % kMod\n    solution = Solution()\n    print(solution.knightDialer(4000000))"]}
{"task_num": 939, "task_title": "Minimum Area Rectangle", "func_name": "minAreaRect", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minAreaRect(self, points: List[List[int]]) -> int:\n    ans = math.inf\n    xToYs = collections.defaultdict(set)\n\n    for x, y in points:\n      xToYs[x].add(y)\n\n    for i in range(len(points)):\n      for j in range(i):\n        x1, y1 = points[i]\n        x2, y2 = points[j]\n        if x1 == x2 or y1 == y2:\n          continue\n        if y2 in xToYs[x1] and y1 in xToYs[x2]:\n          ans = min(ans, abs(x1 - x2) * abs(y1 - y2))\n\n    return ans if ans < math.inf else 0\n", "tests": ["def test_minAreaRect():\n    solution = Solution()\n    points = [[1, 1], [1, 3], [3, 1], [3, 3]]\n    assert solution.minAreaRect(points) == 2", "def test_minAreaRect():\n    solution = Solution()\n    points = [[0, 0], [1, 1], [2, 2], [3, 3]]\n    assert solution.minAreaRect(points) == 36", "def test_minAreaRect():\n    solution = Solution()\n    points = [[0, 1], [2, 3], [4, 5], [6, 7]]\n    assert solution.minAreaRect(points) == 0", "def test_minAreaRect():\n    solution = Solution()\n    points = [[-1, -2], [-1, 0], [0, -2], [0, 0]]\n    assert solution.minAreaRect(points) == 4", "def test_minAreaRect():\n    solution = Solution()\n    points = [[-1, -2], [-1, 1], [0, -2], [0, 2]]\n    assert solution.minAreaRect(points) == 6", "def test_minAreaRect():\n    solution = Solution()\n    points = [[0, 1], [2, -3], [-4, -5], [-6, -7]]\n    assert solution.minAreaRect(points) == 0", "def test_minAreaRect():\n    solution = Solution()\n    points = [[-10, -10], [-5, 0], [0, 0], [10, 10]]\n    assert solution.minAreaRect(points) == 100", "def test_minAreaRect():\n    solution = Solution()\n    points = [[10, -10], [5, 0], [-10, 0], [20, 10]]\n    assert solution.minAreaRect(points) == 100", "def test_minAreaRect():\n    solution = Solution()\n    points = [[1, 0], [0, 2]]\n    assert solution.minAreaRect(points) == 4", "def test_minAreaRect():\n    solution = Solution()\n    points = [[0, -1], [2, 3], [-4, -5], [-6, 7]]\n    assert solution.minAreaRect(points) == 0", "def test_minAreaRect():\n    solution = Solution()\n    points = [[100000, -1], [99999, 0], [-99998, -2], [-99997, 1]]\n    assert solution.minAreaRect(points) == 19999800", "def test_minAreaRect():\n    solution = Solution()\n    points = [[100000, -1], [99998, 0], [-99999, -2], [-99997, 1]]\n    assert solution.minAreaRect(points) == 19999800", "def test_minAreaRect():\n    solution = Solution()\n    points = [[-100000, -1], [-99999, 0], [99998, -2], [99997, 1]]\n    assert solution.minAreaRect(points) == 19999800", "def test_minAreaRect():\n    solution = Solution()\n    points = [[0, 1], [2, -3], [-4, 5], [-6, -7]]\n    assert solution.minAreaRect(points) == 0", "def test_minAreaRect():\n    solution = Solution()\n    points = [[-10, 10000], [5, 0], [-10, 0], [20, -10000]]\n    assert solution.minAreaRect(points) == 200000000", "def test_minAreaRect():\n    solution = Solution()\n    points = [[-100000, -1000], [-99999, 0], [-99998, -2], [-99997, -1]]\n    assert solution.minAreaRect(points) == 19999800", "def test_minAreaRect():\n    solution = Solution()\n    points = [[0, 10], [0, -20], [10, 0], [-20, 0]]\n    assert solution.minAreaRect(points) == 400", "def test_minAreaRect():\n    solution = Solution()\n    points = [[-100000, -2], [-99999, -1], [-99998, 0], [-99997, 1]]\n    assert solution.minAreaRect(points) == 19999800", "def test_minAreaRect():\n    solution = Solution()\n    points = [[0, -100000], [10, 0], [-20, 0], [0, 200000]]\n    assert solution.minAreaRect(points) == 40000", "def test_minAreaRect():\n    solution = Solution()\n    points = [[-10, -2], [-5, 0], [0, 0], [10, 2]]\n    assert solution.minAreaRect(points) == 4"]}
{"task_num": 952, "task_title": "Largest Component Size by Common Factor", "func_name": "largestComponentSize", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def largestComponentSize(self, nums: List[int]) -> int:\n    ans = 0\n    uf = UnionFind(max(nums) + 1)\n    count = collections.Counter()\n\n    for num in nums:\n      for x in range(2, int(math.sqrt(num) + 1)):\n        if num % x == 0:\n          uf.unionByRank(num, x)\n          uf.unionByRank(num, num // x)\n\n    for num in nums:\n      numRoot = uf.find(num)\n      count[numRoot] += 1\n      ans = max(ans, count[numRoot])\n\n    return ans\n", "tests": ["def test_largestComponentSize():\n\n    class Solution:\n\n        def largestComponentSize(self, nums: List[int]) -> int:\n            ans = 0\n            uf = UnionFind(max(nums) + 1)\n            count = collections.Counter()\n            for num in nums:\n                for x in range(2, int(math.sqrt(num) + 1)):\n                    if num % x == 0:\n                        uf.unionByRank(num, x)\n                        uf.unionByRank(num, num // x)\n            for num in nums:\n                numRoot = uf.find(num)\n                count[numRoot] += 1\n                ans = max(ans, count[numRoot])\n            return ans\n    solution = Solution()\n    assert solution.largestComponentSize([14, 16, 4]) == 2", "def test_largestComponentSize():\n\n    class Solution:\n\n        def largestComponentSize(self, nums: List[int]) -> int:\n            ans = 0\n            uf = UnionFind(max(nums) + 1)\n            count = collections.Counter()\n            for num in nums:\n                for x in range(2, int(math.sqrt(num) + 1)):\n                    if num % x == 0:\n                        uf.unionByRank(num, x)\n                        uf.unionByRank(num, num // x)\n            for num in nums:\n                numRoot = uf.find(num)\n                count[numRoot] += 1\n                ans = max(ans, count[numRoot])\n            return ans\n    solution = Solution()\n    assert solution.largestComponentSize([1000000]) == 1", "def test_largestComponentSize():\n\n    class Solution:\n\n        def largestComponentSize(self, nums: List[int]) -> int:\n            ans = 0\n            uf = UnionFind(max(nums) + 1)\n            count = collections.Counter()\n            for num in nums:\n                for x in range(2, int(math.sqrt(num) + 1)):\n                    if num % x == 0:\n                        uf.unionByRank(num, x)\n                        uf.unionByRank(num, num // x)\n            for num in nums:\n                numRoot = uf.find(num)\n                count[numRoot] += 1\n                ans = max(ans, count[numRoot])\n            return ans\n    solution = Solution()\n    assert solution.largestComponentSize([2, 3, 4]) == 3", "def test_largestComponentSize():\n\n    class Solution:\n\n        def largestComponentSize(self, nums: List[int]) -> int:\n            ans = 0\n            uf = UnionFind(max(nums) + 1)\n            count = collections.Counter()\n            for num in nums:\n                for x in range(2, int(math.sqrt(num) + 1)):\n                    if num % x == 0:\n                        uf.unionByRank(num, x)\n                        uf.unionByRank(num, num // x)\n            for num in nums:\n                numRoot = uf.find(num)\n                count[numRoot] += 1\n                ans = max(ans, count[numRoot])\n            return ans\n    solution = Solution()\n    assert solution.largestComponentSize([7, 4, 11]) == 3", "def test_largestComponentSize():\n\n    class Solution:\n\n        def largestComponentSize(self, nums: List[int]) -> int:\n            ans = 0\n            uf = UnionFind(max(nums) + 1)\n            count = collections.Counter()\n            for num in nums:\n                for x in range(2, int(math.sqrt(num) + 1)):\n                    if num % x == 0:\n                        uf.unionByRank(num, x)\n                        uf.unionByRank(num, num // x)\n            for num in nums:\n                numRoot = uf.find(num)\n                count[numRoot] += 1\n                ans = max(ans, count[numRoot])\n            return ans\n    solution = Solution()\n    assert solution.largestComponentSize([15, 20]) == 2", "def test_largestComponentSize():\n\n    class Solution:\n\n        def largestComponentSize(self, nums: List[int]) -> int:\n            ans = 0\n            uf = UnionFind(max(nums) + 1)\n            count = collections.Counter()\n            for num in nums:\n                for x in range(2, int(math.sqrt(num) + 1)):\n                    if num % x == 0:\n                        uf.unionByRank(num, x)\n                        uf.unionByRank(num, num // x)\n            for num in nums:\n                numRoot = uf.find(num)\n                count[numRoot] += 1\n                ans = max(ans, count[numRoot])\n            return ans\n    solution = Solution()\n    assert solution.largestComponentSize([16, 32, 24]) == 2", "def test_largestComponentSize():\n\n    class Solution:\n\n        def largestComponentSize(self, nums: List[int]) -> int:\n            ans = 0\n            uf = UnionFind(max(nums) + 1)\n            count = collections.Counter()\n            for num in nums:\n                for x in range(2, int(math.sqrt(num) + 1)):\n                    if num % x == 0:\n                        uf.unionByRank(num, x)\n                        uf.unionByRank(num, num // x)\n            for num in nums:\n                numRoot = uf.find(num)\n                count[numRoot] += 1\n                ans = max(ans, count[numRoot])\n            return ans\n    solution = Solution()\n    assert solution.largestComponentSize([2, 3]) == 2", "def test_largestComponentSize():\n\n    class Solution:\n\n        def largestComponentSize(self, nums: List[int]) -> int:\n            ans = 0\n            uf = UnionFind(max(nums) + 1)\n            count = collections.Counter()\n            for num in nums:\n                for x in range(2, int(math.sqrt(num) + 1)):\n                    if num % x == 0:\n                        uf.unionByRank(num, x)\n                        uf.unionByRank(num, num // x)\n            for num in nums:\n                numRoot = uf.find(num)\n                count[numRoot] += 1\n                ans = max(ans, count[numRoot])\n            return ans\n    solution = Solution()\n    assert solution.largestComponentSize([5, 10]) == 2", "def test_largestComponentSize():\n\n    class Solution:\n\n        def largestComponentSize(self, nums: List[int]) -> int:\n            ans = 0\n            uf = UnionFind(max(nums) + 1)\n            count = collections.Counter()\n            for num in nums:\n                for x in range(2, int(math.sqrt(num) + 1)):\n                    if num % x == 0:\n                        uf.unionByRank(num, x)\n                        uf.unionByRank(num, num // x)\n            for num in nums:\n                numRoot = uf.find(num)\n                count[numRoot] += 1\n                ans = max(ans, count[numRoot])\n            return ans\n    solution = Solution()\n    assert solution.largestComponentSize([23, 35]) == 2", "def test_largestComponentSize():\n\n    class Solution:\n\n        def largestComponentSize(self, nums: List[int]) -> int:\n            ans = 0\n            uf = UnionFind(max(nums) + 1)\n            count = collections.Counter()\n            for num in nums:\n                for x in range(2, int(math.sqrt(num) + 1)):\n                    if num % x == 0:\n                        uf.unionByRank(num, x)\n                        uf.unionByRank(num, num // x)\n            for num in nums:\n                numRoot = uf.find(num)\n                count[numRoot] += 1\n                ans = max(ans, count[numRoot])\n            return ans\n    solution = Solution()\n    assert solution.largestComponentSize([1009, 13, 17]) == 3", "def test_largestComponentSize():\n\n    class Solution:\n\n        def largestComponentSize(self, nums: List[int]) -> int:\n            ans = 0\n            uf = UnionFind(max(nums) + 1)\n            count = collections.Counter()\n            for num in nums:\n                for x in range(2, int(math.sqrt(num) + 1)):\n                    if num % x == 0:\n                        uf.unionByRank(num, x)\n                        uf.unionByRank(num, num // x)\n            for num in nums:\n                numRoot = uf.find(num)\n                count[numRoot] += 1\n                ans = max(ans, count[numRoot])\n            return ans\n    solution = Solution()\n    assert solution.largestComponentSize([29, 49, 46]) == 2", "def test_largestComponentSize():\n\n    class Solution:\n\n        def largestComponentSize(self, nums: List[int]) -> int:\n            ans = 0\n            uf = UnionFind(max(nums) + 1)\n            count = collections.Counter()\n            for num in nums:\n                for x in range(2, int(math.sqrt(num) + 1)):\n                    if num % x == 0:\n                        uf.unionByRank(num, x)\n                        uf.unionByRank(num, num // x)\n            for num in nums:\n                numRoot = uf.find(num)\n                count[numRoot] += 1\n                ans = max(ans, count[numRoot])\n            return ans\n    solution = Solution()\n    assert solution.largestComponentSize([11, 22]) == 2", "def test_largestComponentSize():\n\n    class Solution:\n\n        def largestComponentSize(self, nums: List[int]) -> int:\n            ans = 0\n            uf = UnionFind(max(nums) + 1)\n            count = collections.Counter()\n            for num in nums:\n                for x in range(2, int(math.sqrt(num) + 1)):\n                    if num % x == 0:\n                        uf.unionByRank(num, x)\n                        uf.unionByRank(num, num // x)\n            for num in nums:\n                numRoot = uf.find(num)\n                count[numRoot] += 1\n                ans = max(ans, count[numRoot])\n            return ans\n    solution = Solution()\n    assert solution.largestComponentSize([61, 157]) == 2", "def test_largestComponentSize():\n\n    class Solution:\n\n        def largestComponentSize(self, nums: List[int]) -> int:\n            ans = 0\n            uf = UnionFind(max(nums) + 1)\n            count = collections.Counter()\n            for num in nums:\n                for x in range(2, int(math.sqrt(num) + 1)):\n                    if num % x == 0:\n                        uf.unionByRank(num, x)\n                        uf.unionByRank(num, num // x)\n            for num in nums:\n                numRoot = uf.find(num)\n                count[numRoot] += 1\n                ans = max(ans, count[numRoot])\n            return ans\n    solution = Solution()\n    assert solution.largestComponentSize([25, 36]) == 2", "def test_largestComponentSize():\n\n    class Solution:\n\n        def largestComponentSize(self, nums: List[int]) -> int:\n            ans = 0\n            uf = UnionFind(max(nums) + 1)\n            count = collections.Counter()\n            for num in nums:\n                for x in range(2, int(math.sqrt(num) + 1)):\n                    if num % x == 0:\n                        uf.unionByRank(num, x)\n                        uf.unionByRank(num, num // x)\n            for num in nums:\n                numRoot = uf.find(num)\n                count[numRoot] += 1\n                ans = max(ans, count[numRoot])\n            return ans\n    solution = Solution()\n    assert solution.largestComponentSize([23, 37]) == 2", "def test_largestComponentSize():\n\n    class Solution:\n\n        def largestComponentSize(self, nums: List[int]) -> int:\n            ans = 0\n            uf = UnionFind(max(nums) + 1)\n            count = collections.Counter()\n            for num in nums:\n                for x in range(2, int(math.sqrt(num) + 1)):\n                    if num % x == 0:\n                        uf.unionByRank(num, x)\n                        uf.unionByRank(num, num // x)\n            for num in nums:\n                numRoot = uf.find(num)\n                count[numRoot] += 1\n                ans = max(ans, count[numRoot])\n            return ans\n    solution = Solution()\n    assert solution.largestComponentSize([17, 19]) == 2", "def test_largestComponentSize():\n\n    class Solution:\n\n        def largestComponentSize(self, nums: List[int]) -> int:\n            ans = 0\n            uf = UnionFind(max(nums) + 1)\n            count = collections.Counter()\n            for num in nums:\n                for x in range(2, int(math.sqrt(num) + 1)):\n                    if num % x == 0:\n                        uf.unionByRank(num, x)\n                        uf.unionByRank(num, num // x)\n            for num in nums:\n                numRoot = uf.find(num)\n                count[numRoot] += 1\n                ans = max(ans, count[numRoot])\n            return ans\n    solution = Solution()\n    assert solution.largestComponentSize([13, 28]) == 2", "def test_largestComponentSize():\n\n    class Solution:\n\n        def largestComponentSize(self, nums: List[int]) -> int:\n            ans = 0\n            uf = UnionFind(max(nums) + 1)\n            count = collections.Counter()\n            for num in nums:\n                for x in range(2, int(math.sqrt(num) + 1)):\n                    if num % x == 0:\n                        uf.unionByRank(num, x)\n                        uf.unionByRank(num, num // x)\n            for num in nums:\n                numRoot = uf.find(num)\n                count[numRoot] += 1\n                ans = max(ans, count[numRoot])\n            return ans\n    solution = Solution()\n    assert solution.largestComponentSize([23, 37, 51]) == 3", "def test_largestComponentSize():\n\n    class Solution:\n\n        def largestComponentSize(self, nums: List[int]) -> int:\n            ans = 0\n            uf = UnionFind(max(nums) + 1)\n            count = collections.Counter()\n            for num in nums:\n                for x in range(2, int(math.sqrt(num) + 1)):\n                    if num % x == 0:\n                        uf.unionByRank(num, x)\n                        uf.unionByRank(num, num // x)\n            for num in nums:\n                numRoot = uf.find(num)\n                count[numRoot] += 1\n                ans = max(ans, count[numRoot])\n            return ans\n    solution = Solution()\n    assert solution.largestComponentSize([31, 61, 19]) == 3", "def test_largestComponentSize():\n\n    class Solution:\n\n        def largestComponentSize(self, nums: List[int]) -> int:\n            ans = 0\n            uf = UnionFind(max(nums) + 1)\n            count = collections.Counter()\n            for num in nums:\n                for x in range(2, int(math.sqrt(num) + 1)):\n                    if num % x == 0:\n                        uf.unionByRank(num, x)\n                        uf.unionByRank(num, num // x)\n            for num in nums:\n                numRoot = uf.find(num)\n                count[numRoot] += 1\n                ans = max(ans, count[numRoot])\n            return ans\n    solution = Solution()\n    assert solution.largestComponentSize([23, 37, 53, 67]) == 4"]}
{"task_num": 963, "task_title": "Minimum Area Rectangle II", "func_name": "minAreaFreeRect", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\nfrom math import sqrt\n\nclass Solution:\n  def minAreaFreeRect(self, points: List[List[int]]) -> float:\n    ans = math.inf\n    centerToPoints = collections.defaultdict(list)\n\n    for ax, ay in points:\n      for bx, by in points:\n        center = ((ax + bx) / 2, (ay + by) / 2)\n        centerToPoints[center].append((ax, ay, bx, by))\n\n    def dist(px: int, py: int, qx: int, qy: int) -> float:\n      return (px - qx)**2 + (py - qy)**2\n\n    for points in centerToPoints.values():\n      for ax, ay, _, _ in points:\n        for cx, cy, dx, dy in points:\n          if (cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0:\n            squaredArea = dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy)\n            if squaredArea > 0:\n              ans = min(ans, squaredArea)\n\n    return 0 if ans == math.inf else sqrt(ans)\n", "tests": ["def test_minAreaFreeRect():\n\n    class Solution:\n\n        def minAreaFreeRect(self, points: List[List[int]]) -> float:\n            ans = math.inf\n            centerToPoints = collections.defaultdict(list)\n            for (ax, ay) in points:\n                for (bx, by) in points:\n                    center = ((ax + bx) / 2, (ay + by) / 2)\n                    centerToPoints[center].append((ax, ay, bx, by))\n\n            def dist(px: int, py: int, qx: int, qy: int) -> float:\n                return (px - qx) ** 2 + (py - qy) ** 2\n            for points in centerToPoints.values():\n                for (ax, ay, _, _) in points:\n                    for (cx, cy, dx, dy) in points:\n                        if (cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0:\n                            squaredArea = dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy)\n                            if squaredArea > 0:\n                                ans = min(ans, squaredArea)\n            return 0 if ans == math.inf else sqrt(ans)\n    solution = Solution()\n    points = [[1, 2], [4, 6], [3, 7], [5, 8]]\n    assert round(solution.minAreaFreeRect(points), 5) == round(16.0, 5)", "def test_minAreaFreeRect():\n\n    class Solution:\n\n        def minAreaFreeRect(self, points: List[List[int]]) -> float:\n            ans = math.inf\n            centerToPoints = collections.defaultdict(list)\n            for (ax, ay) in points:\n                for (bx, by) in points:\n                    center = ((ax + bx) / 2, (ay + by) / 2)\n                    centerToPoints[center].append((ax, ay, bx, by))\n\n            def dist(px: int, py: int, qx: int, qy: int) -> float:\n                return (px - qx) ** 2 + (py - qy) ** 2\n            for points in centerToPoints.values():\n                for (ax, ay, _, _) in points:\n                    for (cx, cy, dx, dy) in points:\n                        if (cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0:\n                            squaredArea = dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy)\n                            if squaredArea > 0:\n                                ans = min(ans, squaredArea)\n            return 0 if ans == math.inf else sqrt(ans)\n    solution = Solution()\n    points = [[1, 3], [3, 1], [1, 5], [5, 1]]\n    assert round(solution.minAreaFreeRect(points), 5) == 0.0", "def test_minAreaFreeRect():\n\n    class Solution:\n\n        def minAreaFreeRect(self, points: List[List[int]]) -> float:\n            ans = math.inf\n            centerToPoints = collections.defaultdict(list)\n            for (ax, ay) in points:\n                for (bx, by) in points:\n                    center = ((ax + bx) / 2, (ay + by) / 2)\n                    centerToPoints[center].append((ax, ay, bx, by))\n\n            def dist(px: int, py: int, qx: int, qy: int) -> float:\n                return (px - qx) ** 2 + (py - qy) ** 2\n            for points in centerToPoints.values():\n                for (ax, ay, _, _) in points:\n                    for (cx, cy, dx, dy) in points:\n                        if (cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0:\n                            squaredArea = dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy)\n                            if squaredArea > 0:\n                                ans = min(ans, squaredArea)\n            return 0 if ans == math.inf else sqrt(ans)\n    solution = Solution()\n    points = [[1, 1], [2, 2], [3, 3], [4, 4]]\n    assert round(solution.minAreaFreeRect(points), 5) == 32.0", "def test_minAreaFreeRect():\n\n    class Solution:\n\n        def minAreaFreeRect(self, points: List[List[int]]) -> float:\n            ans = math.inf\n            centerToPoints = collections.defaultdict(list)\n            for (ax, ay) in points:\n                for (bx, by) in points:\n                    center = ((ax + bx) / 2, (ay + by) / 2)\n                    centerToPoints[center].append((ax, ay, bx, by))\n\n            def dist(px: int, py: int, qx: int, qy: int) -> float:\n                return (px - qx) ** 2 + (py - qy) ** 2\n            for points in centerToPoints.values():\n                for (ax, ay, _, _) in points:\n                    for (cx, cy, dx, dy) in points:\n                        if (cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0:\n                            squaredArea = dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy)\n                            if squaredArea > 0:\n                                ans = min(ans, squaredArea)\n            return 0 if ans == math.inf else sqrt(ans)\n    solution = Solution()\n    points = [[1, 2], [2, 3], [4, 5], [7, 8]]\n    assert round(solution.minAreaFreeRect(points), 5) == 80.0", "def test_minAreaFreeRect():\n\n    class Solution:\n\n        def minAreaFreeRect(self, points: List[List[int]]) -> float:\n            ans = math.inf\n            centerToPoints = collections.defaultdict(list)\n            for (ax, ay) in points:\n                for (bx, by) in points:\n                    center = ((ax + bx) / 2, (ay + by) / 2)\n                    centerToPoints[center].append((ax, ay, bx, by))\n\n            def dist(px: int, py: int, qx: int, qy: int) -> float:\n                return (px - qx) ** 2 + (py - qy) ** 2\n            for points in centerToPoints.values():\n                for (ax, ay, _, _) in points:\n                    for (cx, cy, dx, dy) in points:\n                        if (cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0:\n                            squaredArea = dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy)\n                            if squaredArea > 0:\n                                ans = min(ans, squaredArea)\n            return 0 if ans == math.inf else sqrt(ans)\n    solution = Solution()\n    points = [[3, 2], [5, -4], [-2, 6], [9, 1]]\n    assert round(solution.minAreaFreeRect(points), 5) == 72.0", "def test_minAreaFreeRect():\n\n    class Solution:\n\n        def minAreaFreeRect(self, points: List[List[int]]) -> float:\n            ans = math.inf\n            centerToPoints = collections.defaultdict(list)\n            for (ax, ay) in points:\n                for (bx, by) in points:\n                    center = ((ax + bx) / 2, (ay + by) / 2)\n                    centerToPoints[center].append((ax, ay, bx, by))\n\n            def dist(px: int, py: int, qx: int, qy: int) -> float:\n                return (px - qx) ** 2 + (py - qy) ** 2\n            for points in centerToPoints.values():\n                for (ax, ay, _, _) in points:\n                    for (cx, cy, dx, dy) in points:\n                        if (cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0:\n                            squaredArea = dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy)\n                            if squaredArea > 0:\n                                ans = min(ans, squaredArea)\n            return 0 if ans == math.inf else sqrt(ans)\n    solution = Solution()\n    points = [[1, 2], [4, 6], [-3, -4], [5, -8]]\n    assert round(solution.minAreaFreeRect(points), 5) == 32.0", "def test_minAreaFreeRect():\n\n    class Solution:\n\n        def minAreaFreeRect(self, points: List[List[int]]) -> float:\n            ans = math.inf\n            centerToPoints = collections.defaultdict(list)\n            for (ax, ay) in points:\n                for (bx, by) in points:\n                    center = ((ax + bx) / 2, (ay + by) / 2)\n                    centerToPoints[center].append((ax, ay, bx, by))\n\n            def dist(px: int, py: int, qx: int, qy: int) -> float:\n                return (px - qx) ** 2 + (py - qy) ** 2\n            for points in centerToPoints.values():\n                for (ax, ay, _, _) in points:\n                    for (cx, cy, dx, dy) in points:\n                        if (cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0:\n                            squaredArea = dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy)\n                            if squaredArea > 0:\n                                ans = min(ans, squaredArea)\n            return 0 if ans == math.inf else sqrt(ans)\n    solution = Solution()\n    points = [[7, 5], [8, -2], [-6, -3], [-1, -4]]\n    assert round(solution.minAreaFreeRect(points), 5) == 0.0", "def test_minAreaFreeRect():\n\n    class Solution:\n\n        def minAreaFreeRect(self, points: List[List[int]]) -> float:\n            ans = math.inf\n            centerToPoints = collections.defaultdict(list)\n            for (ax, ay) in points:\n                for (bx, by) in points:\n                    center = ((ax + bx) / 2, (ay + by) / 2)\n                    centerToPoints[center].append((ax, ay, bx, by))\n\n            def dist(px: int, py: int, qx: int, qy: int) -> float:\n                return (px - qx) ** 2 + (py - qy) ** 2\n            for points in centerToPoints.values():\n                for (ax, ay, _, _) in points:\n                    for (cx, cy, dx, dy) in points:\n                        if (cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0:\n                            squaredArea = dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy)\n                            if squaredArea > 0:\n                                ans = min(ans, squaredArea)\n            return 0 if ans == math.inf else sqrt(ans)\n    solution = Solution()\n    points = [[1, 1], [2, 3], [-2, -5], [4, -7]]\n    assert round(solution.minAreaFreeRect(points), 5) == 96.0", "def test_minAreaFreeRect():\n\n    class Solution:\n\n        def minAreaFreeRect(self, points: List[List[int]]) -> float:\n            ans = math.inf\n            centerToPoints = collections.defaultdict(list)\n            for (ax, ay) in points:\n                for (bx, by) in points:\n                    center = ((ax + bx) / 2, (ay + by) / 2)\n                    centerToPoints[center].append((ax, ay, bx, by))\n\n            def dist(px: int, py: int, qx: int, qy: int) -> float:\n                return (px - qx) ** 2 + (py - qy) ** 2\n            for points in centerToPoints.values():\n                for (ax, ay, _, _) in points:\n                    for (cx, cy, dx, dy) in points:\n                        if (cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0:\n                            squaredArea = dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy)\n                            if squaredArea > 0:\n                                ans = min(ans, squaredArea)\n            return 0 if ans == math.inf else sqrt(ans)\n    solution = Solution()\n    points = [[1, 2], [3, -4], [-5, 6], [7, -8]]\n    assert round(solution.minAreaFreeRect(points), 5) == 32.0", "def test_minAreaFreeRect():\n\n    class Solution:\n\n        def minAreaFreeRect(self, points: List[List[int]]) -> float:\n            ans = math.inf\n            centerToPoints = collections.defaultdict(list)\n            for (ax, ay) in points:\n                for (bx, by) in points:\n                    center = ((ax + bx) / 2, (ay + by) / 2)\n                    centerToPoints[center].append((ax, ay, bx, by))\n\n            def dist(px: int, py: int, qx: int, qy: int) -> float:\n                return (px - qx) ** 2 + (py - qy) ** 2\n            for points in centerToPoints.values():\n                for (ax, ay, _, _) in points:\n                    for (cx, cy, dx, dy) in points:\n                        if (cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0:\n                            squaredArea = dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy)\n                            if squaredArea > 0:\n                                ans = min(ans, squaredArea)\n            return 0 if ans == math.inf else sqrt(ans)\n    solution = Solution()\n    points = [[1, 3], [4, -2], [-5, 6], [7, -8]]\n    assert round(solution.minAreaFreeRect(points), 5) == 80.0", "def test_minAreaFreeRect():\n\n    class Solution:\n\n        def minAreaFreeRect(self, points: List[List[int]]) -> float:\n            ans = math.inf\n            centerToPoints = collections.defaultdict(list)\n            for (ax, ay) in points:\n                for (bx, by) in points:\n                    center = ((ax + bx) / 2, (ay + by) / 2)\n                    centerToPoints[center].append((ax, ay, bx, by))\n\n            def dist(px: int, py: int, qx: int, qy: int) -> float:\n                return (px - qx) ** 2 + (py - qy) ** 2\n            for points in centerToPoints.values():\n                for (ax, ay, _, _) in points:\n                    for (cx, cy, dx, dy) in points:\n                        if (cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0:\n                            squaredArea = dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy)\n                            if squaredArea > 0:\n                                ans = min(ans, squaredArea)\n            return 0 if ans == math.inf else sqrt(ans)\n    solution = Solution()\n    points = [[2, 1], [4, 3], [-6, -5], [8, -9]]\n    assert round(solution.minAreaFreeRect(points), 5) == 96.0", "def test_minAreaFreeRect():\n\n    class Solution:\n\n        def minAreaFreeRect(self, points: List[List[int]]) -> float:\n            ans = math.inf\n            centerToPoints = collections.defaultdict(list)\n            for (ax, ay) in points:\n                for (bx, by) in points:\n                    center = ((ax + bx) / 2, (ay + by) / 2)\n                    centerToPoints[center].append((ax, ay, bx, by))\n\n            def dist(px: int, py: int, qx: int, qy: int) -> float:\n                return (px - qx) ** 2 + (py - qy) ** 2\n            for points in centerToPoints.values():\n                for (ax, ay, _, _) in points:\n                    for (cx, cy, dx, dy) in points:\n                        if (cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0:\n                            squaredArea = dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy)\n                            if squaredArea > 0:\n                                ans = min(ans, squaredArea)\n            return 0 if ans == math.inf else sqrt(ans)\n    solution = Solution()\n    points = [[3, 1], [4, -2], [-5, -6], [7, -8]]\n    assert round(solution.minAreaFreeRect(points), 5) == 64.0", "def test_minAreaFreeRect():\n\n    class Solution:\n\n        def minAreaFreeRect(self, points: List[List[int]]) -> float:\n            ans = math.inf\n            centerToPoints = collections.defaultdict(list)\n            for (ax, ay) in points:\n                for (bx, by) in points:\n                    center = ((ax + bx) / 2, (ay + by) / 2)\n                    centerToPoints[center].append((ax, ay, bx, by))\n\n            def dist(px: int, py: int, qx: int, qy: int) -> float:\n                return (px - qx) ** 2 + (py - qy) ** 2\n            for points in centerToPoints.values():\n                for (ax, ay, _, _) in points:\n                    for (cx, cy, dx, dy) in points:\n                        if (cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0:\n                            squaredArea = dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy)\n                            if squaredArea > 0:\n                                ans = min(ans, squaredArea)\n            return 0 if ans == math.inf else sqrt(ans)\n    solution = Solution()\n    points = [[1, 2], [3, -4], [-5, 6], [-7, 8]]\n    assert round(solution.minAreaFreeRect(points), 5) == 64.0", "def test_minAreaFreeRect():\n\n    class Solution:\n\n        def minAreaFreeRect(self, points: List[List[int]]) -> float:\n            ans = math.inf\n            centerToPoints = collections.defaultdict(list)\n            for (ax, ay) in points:\n                for (bx, by) in points:\n                    center = ((ax + bx) / 2, (ay + by) / 2)\n                    centerToPoints[center].append((ax, ay, bx, by))\n\n            def dist(px: int, py: int, qx: int, qy: int) -> float:\n                return (px - qx) ** 2 + (py - qy) ** 2\n            for points in centerToPoints.values():\n                for (ax, ay, _, _) in points:\n                    for (cx, cy, dx, dy) in points:\n                        if (cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0:\n                            squaredArea = dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy)\n                            if squaredArea > 0:\n                                ans = min(ans, squaredArea)\n            return 0 if ans == math.inf else sqrt(ans)\n    solution = Solution()\n    points = [[2, -1], [4, 3], [-6, -5], [8, -9]]\n    assert round(solution.minAreaFreeRect(points), 5) == 32.0", "def test_minAreaFreeRect():\n\n    class Solution:\n\n        def minAreaFreeRect(self, points: List[List[int]]) -> float:\n            ans = math.inf\n            centerToPoints = collections.defaultdict(list)\n            for (ax, ay) in points:\n                for (bx, by) in points:\n                    center = ((ax + bx) / 2, (ay + by) / 2)\n                    centerToPoints[center].append((ax, ay, bx, by))\n\n            def dist(px: int, py: int, qx: int, qy: int) -> float:\n                return (px - qx) ** 2 + (py - qy) ** 2\n            for points in centerToPoints.values():\n                for (ax, ay, _, _) in points:\n                    for (cx, cy, dx, dy) in points:\n                        if (cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0:\n                            squaredArea = dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy)\n                            if squaredArea > 0:\n                                ans = min(ans, squaredArea)\n            return 0 if ans == math.inf else sqrt(ans)\n    solution = Solution()\n    points = [[3, -2], [4, -6], [-5, -8], [-7, -10]]\n    assert round(solution.minAreaFreeRect(points), 5) == 144.0", "def test_minAreaFreeRect():\n\n    class Solution:\n\n        def minAreaFreeRect(self, points: List[List[int]]) -> float:\n            ans = math.inf\n            centerToPoints = collections.defaultdict(list)\n            for (ax, ay) in points:\n                for (bx, by) in points:\n                    center = ((ax + bx) / 2, (ay + by) / 2)\n                    centerToPoints[center].append((ax, ay, bx, by))\n\n            def dist(px: int, py: int, qx: int, qy: int) -> float:\n                return (px - qx) ** 2 + (py - qy) ** 2\n            for points in centerToPoints.values():\n                for (ax, ay, _, _) in points:\n                    for (cx, cy, dx, dy) in points:\n                        if (cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0:\n                            squaredArea = dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy)\n                            if squaredArea > 0:\n                                ans = min(ans, squaredArea)\n            return 0 if ans == math.inf else sqrt(ans)\n    solution = Solution()\n    points = [[1, -3], [4, 6], [-5, 8], [-7, 10]]\n    assert round(solution.minAreaFreeRect(points), 5) == 256.0", "def test_minAreaFreeRect():\n\n    class Solution:\n\n        def minAreaFreeRect(self, points: List[List[int]]) -> float:\n            ans = math.inf\n            centerToPoints = collections.defaultdict(list)\n            for (ax, ay) in points:\n                for (bx, by) in points:\n                    center = ((ax + bx) / 2, (ay + by) / 2)\n                    centerToPoints[center].append((ax, ay, bx, by))\n\n            def dist(px: int, py: int, qx: int, qy: int) -> float:\n                return (px - qx) ** 2 + (py - qy) ** 2\n            for points in centerToPoints.values():\n                for (ax, ay, _, _) in points:\n                    for (cx, cy, dx, dy) in points:\n                        if (cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0:\n                            squaredArea = dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy)\n                            if squaredArea > 0:\n                                ans = min(ans, squaredArea)\n            return 0 if ans == math.inf else sqrt(ans)\n    solution = Solution()\n    points = [[-3, -4], [-2, -5], [-1, -6], [0, -7]]\n    assert round(solution.minAreaFreeRect(points), 5) == 0.0", "def test_minAreaFreeRect():\n\n    class Solution:\n\n        def minAreaFreeRect(self, points: List[List[int]]) -> float:\n            ans = math.inf\n            centerToPoints = collections.defaultdict(list)\n            for (ax, ay) in points:\n                for (bx, by) in points:\n                    center = ((ax + bx) / 2, (ay + by) / 2)\n                    centerToPoints[center].append((ax, ay, bx, by))\n\n            def dist(px: int, py: int, qx: int, qy: int) -> float:\n                return (px - qx) ** 2 + (py - qy) ** 2\n            for points in centerToPoints.values():\n                for (ax, ay, _, _) in points:\n                    for (cx, cy, dx, dy) in points:\n                        if (cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0:\n                            squaredArea = dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy)\n                            if squaredArea > 0:\n                                ans = min(ans, squaredArea)\n            return 0 if ans == math.inf else sqrt(ans)\n    solution = Solution()\n    points = [[-3, -2], [-2, -1], [-1, 0], [0, 1]]\n    assert round(solution.minAreaFreeRect(points), 5) == 16.0", "def test_minAreaFreeRect():\n\n    class Solution:\n\n        def minAreaFreeRect(self, points: List[List[int]]) -> float:\n            ans = math.inf\n            centerToPoints = collections.defaultdict(list)\n            for (ax, ay) in points:\n                for (bx, by) in points:\n                    center = ((ax + bx) / 2, (ay + by) / 2)\n                    centerToPoints[center].append((ax, ay, bx, by))\n\n            def dist(px: int, py: int, qx: int, qy: int) -> float:\n                return (px - qx) ** 2 + (py - qy) ** 2\n            for points in centerToPoints.values():\n                for (ax, ay, _, _) in points:\n                    for (cx, cy, dx, dy) in points:\n                        if (cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0:\n                            squaredArea = dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy)\n                            if squaredArea > 0:\n                                ans = min(ans, squaredArea)\n            return 0 if ans == math.inf else sqrt(ans)\n    solution = Solution()\n    points = [[-1, -2], [-2, -3], [-3, -4], [-4, -5]]\n    assert round(solution.minAreaFreeRect(points), 5) == 192.0", "def test_minAreaFreeRect():\n\n    class Solution:\n\n        def minAreaFreeRect(self, points: List[List[int]]) -> float:\n            ans = math.inf\n            centerToPoints = collections.defaultdict(list)\n            for (ax, ay) in points:\n                for (bx, by) in points:\n                    center = ((ax + bx) / 2, (ay + by) / 2)\n                    centerToPoints[center].append((ax, ay, bx, by))\n\n            def dist(px: int, py: int, qx: int, qy: int) -> float:\n                return (px - qx) ** 2 + (py - qy) ** 2\n            for points in centerToPoints.values():\n                for (ax, ay, _, _) in points:\n                    for (cx, cy, dx, dy) in points:\n                        if (cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0:\n                            squaredArea = dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy)\n                            if squaredArea > 0:\n                                ans = min(ans, squaredArea)\n            return 0 if ans == math.inf else sqrt(ans)\n    solution = Solution()\n    points = [[1, 2], [3, 4], [5, 6], [7, 8]]\n    assert round(solution.minAreaFreeRect(points), 5) == 576.0"]}
{"task_num": 990, "task_title": "Satisfiability of Equality Equations", "func_name": "equationsPossible", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n\n  def union(self, u: int, v: int) -> None:\n    self.id[self.find(u)] = self.find(v)\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def equationsPossible(self, equations: List[str]) -> bool:\n    uf = UnionFind(26)\n\n    for x, op, _, y in equations:\n      if op == '=':\n        uf.union(ord(x) - ord('a'), ord(y) - ord('a'))\n\n    for x, op, _, y in equations:\n      if op == '!':\n        if uf.find(ord(x) - ord('a')) == uf.find(ord(y) - ord('a')):\n          return False\n    return True\n", "tests": ["def test_equationsPossible():\n\n    class TestEquationsPossible(unittest.TestCase):\n\n        def test_equal_variables(self):\n            solution = Solution()\n            self.assertTrue(solution.equationsPossible(['a==b', 'b!=a']))", "def test_equationsPossible():\n\n    class TestEquationsPossible(unittest.TestCase):\n\n        def test_unequal_variables(self):\n            solution = Solution()\n            self.assertTrue(solution.equationsPossible(['a!=b', 'c==d']))", "def test_equationsPossible():\n\n    class TestEquationsPossible(unittest.TestCase):\n\n        def test_cyclic_relationships(self):\n            solution = Solution()\n            self.assertTrue(solution.equationsPossible(['a==b', 'b==c', 'c==a']))", "def test_equationsPossible():\n\n    class TestEquationsPossible(unittest.TestCase):\n\n        def test_conflicting_equations(self):\n            solution = Solution()\n            self.assertFalse(solution.equationsPossible(['a==b', 'b!=c', 'a!=d']))", "def test_equationsPossible():\n\n    class TestEquationsPossible(unittest.TestCase):\n\n        def test_no_equality(self):\n            solution = Solution()\n            self.assertFalse(solution.equationsPossible(['a!=b']))", "def test_equationsPossible():\n\n    class TestEquationsPossible(unittest.TestCase):\n\n        def test_single_equality(self):\n            solution = Solution()\n            self.assertTrue(solution.equationsPossible(['a==b']))", "def test_equationsPossible():\n\n    class TestEquationsPossible(unittest.TestCase):\n\n        def test_empty_list(self):\n            solution = Solution()\n            self.assertTrue(solution.equationsPossible([]))", "def test_equationsPossible():\n\n    class TestEquationsPossible(unittest.TestCase):\n\n        def test_single_inequality(self):\n            solution = Solution()\n            self.assertTrue(solution.equationsPossible(['a!=b']))", "def test_equationsPossible():\n\n    class TestEquationsPossible(unittest.TestCase):\n\n        def test_all_equality(self):\n            solution = Solution()\n            self.assertTrue(solution.equationsPossible(['a==b', 'b==c', 'c==d']))", "def test_equationsPossible():\n\n    class TestEquationsPossible(unittest.TestCase):\n\n        def test_multiple_inequalities(self):\n            solution = Solution()\n            self.assertTrue(solution.equationsPossible(['a!=b', 'c!=d', 'e!=f']))", "def test_equationsPossible():\n\n    class TestEquationsPossible(unittest.TestCase):\n\n        def test_repeated_equality(self):\n            solution = Solution()\n            self.assertTrue(solution.equationsPossible(['a==b', 'a==c']))", "def test_equationsPossible():\n\n    class TestEquationsPossible(unittest.TestCase):\n\n        def test_all_inequality(self):\n            solution = Solution()\n            self.assertTrue(solution.equationsPossible(['a!=b', 'c!=d', 'e!=f', 'g!=h']))", "def test_equationsPossible():\n\n    class TestEquationsPossible(unittest.TestCase):\n\n        def test_mixed_equality_and_inequality(self):\n            solution = Solution()\n            self.assertFalse(solution.equationsPossible(['a==b', 'c!=d']))", "def test_equationsPossible():\n\n    class TestEquationsPossible(unittest.TestCase):\n\n        def test_long_equality_chain(self):\n            solution = Solution()\n            self.assertTrue(solution.equationsPossible(['a==b', 'b==c', 'c==d', 'd==e']))", "def test_equationsPossible():\n\n    class TestEquationsPossible(unittest.TestCase):\n\n        def test_equality_with_same_letter(self):\n            solution = Solution()\n            self.assertTrue(solution.equationsPossible(['a==a']))", "def test_equationsPossible():\n\n    class TestEquationsPossible(unittest.TestCase):\n\n        def test_equality_with_different_cases(self):\n            solution = Solution()\n            self.assertTrue(solution.equationsPossible(['A==a', 'B!=b']))", "def test_equationsPossible():\n\n    class TestEquationsPossible(unittest.TestCase):\n\n        def test_only_equality_with_nonexistent_variables(self):\n            solution = Solution()\n            self.assertTrue(solution.equationsPossible(['a==b', 'c==d', 'e==f']))", "def test_equationsPossible():\n\n    class TestEquationsPossible(unittest.TestCase):\n\n        def test_equality_with_numbers(self):\n            solution = Solution()\n            self.assertTrue(solution.equationsPossible(['1==2', '3!=4']))", "def test_equationsPossible():\n\n    class TestEquationsPossible(unittest.TestCase):\n\n        def test_empty_input(self):\n            solution = Solution()\n            self.assertTrue(solution.equationsPossible([]))", "def test_equationsPossible():\n\n    class TestEquationsPossible(unittest.TestCase):\n\n        def test_single_character(self):\n            solution = Solution()\n            self.assertTrue(solution.equationsPossible(['a==a']))"]}
{"task_num": 999, "task_title": "Available Captures for Rook", "func_name": "numRookCaptures", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numRookCaptures(self, board: List[List[str]]) -> int:\n    ans = 0\n\n    for i in range(8):\n      for j in range(8):\n        if board[i][j] == 'R':\n          i0 = i\n          j0 = j\n\n    for d in [[1, 0], [0, 1], [-1, 0], [0, -1]]:\n      i = i0 + d[0]\n      j = j0 + d[1]\n      while 0 <= i < 8 and 0 <= j < 8:\n        if board[i][j] == 'p':\n          ans += 1\n        if board[i][j] != '.':\n          break\n        i += d[0]\n        j += d[1]\n\n    return ans\n", "tests": ["def test_numRookCaptures():\n    solution = Solution()\n    board = [['.','.','.','.','.','.','.','.'],\n             ['.\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n             ['.','.','.','.','.','.','.','.'],\n             ['B','.','.','.','.','.','.','.'],\n             ['.','B','.\",\".\",\".\",\".\",\".\",\".\"],\n             ['.','.\",\".\",\".\",\".\",\".\",\".\",\".\"],\n             ['.\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n             ['.','.','.','.','.','.','.','.']]\n    assert solution.numRookCaptures(board) == 2", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', 'R', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 0", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', 'R', '.', '.', '.', '.', '.', 'p'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', '.', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 0", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', 'p', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', '.', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 0", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', 'R', '.', '.', 'p', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', '.', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 1", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', 'R', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', '.', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 1", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', 'R', '.', 'p', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', '.', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 1", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', 'R', '.', '.', '.', 'p', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', '.', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 1", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', 'p', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', '.', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 0", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', 'R', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 1", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', 'p', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 0", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', 'p', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 0", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', 'p', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', '.', '.', '.', '.', '.', '.'], ['R', '.', '.', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 1", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', 'p', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', '.', '.', '.', '.', '.', '.'], ['R', '.', '.', '.', '.', '.', 'p', '.']]\n    assert solution.numRookCaptures(board) == 2", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', 'p', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', '.', '.', '.', 'R', '.', '.']]\n    assert solution.numRookCaptures(board) == 0", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', 'p', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', '.', '.', '.', '.', '.', '.'], ['R', '.', '.', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 1", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', 'p', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', '.', 'R', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 1", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', 'p', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', 'R', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 1", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', 'p', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['R', '.', '.', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 1", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', 'p', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', '.', '.', '.', '.', '.', '.'], ['R', '.', '.', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 2"]}
{"task_num": 1001, "task_title": "Grid Illumination", "func_name": "gridIllumination", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def gridIllumination(self, n: int, lamps: List[List[int]], queries: List[List[int]]) -> List[int]:\n    ans = []\n    rows = collections.Counter()\n    cols = collections.Counter()\n    diag1 = collections.Counter()\n    diag2 = collections.Counter()\n    lampsSet = set()\n\n    for i, j in lamps:\n      if (i, j) not in lampsSet:\n        lampsSet.add((i, j))\n        rows[i] += 1\n        cols[j] += 1\n        diag1[i + j] += 1\n        diag2[i - j] += 1\n\n    for i, j in queries:\n      if rows[i] or cols[j] or diag1[i + j] or diag2[i - j]:\n        ans.append(1)\n        for y in range(max(0, i - 1), min(n, i + 2)):\n          for x in range(max(0, j - 1), min(n, j + 2)):\n            if (y, x) in lampsSet:\n              lampsSet.remove((y, x))\n              rows[y] -= 1\n              cols[x] -= 1\n              diag1[y + x] -= 1\n              diag2[y - x] -= 1\n      else:\n        ans.append(0)\n\n    return ans\n", "tests": ["def test_gridIllumination(self):\n    n = 5\n    lamps = [[0, 0], [4, 4]]\n    queries = [[0, 1], [1, 1], [4, 3], [3, 2], [2, 1], [0, 0], [0, 4], [4, 0]]\n    self.assertEqual(self.solution.gridIllumination(n, lamps, queries), [0, 0, 1, 1, 1, 1])", "def test_gridIllumination(self):\n    n = 5\n    lamps = [[1, 2], [3, 4]]\n    queries = []\n    self.assertEqual(self.solution.gridIllumination(n, lamps, queries), [])", "def test_gridIllumination(self):\n    n = 5\n    lamps = []\n    queries = [[1, 2], [3, 4]]\n    self.assertEqual(self.solution.gridIllumination(n, lamps, queries), [0, 0])", "def test_gridIllumination(self):\n    n = 5\n    lamps = [[1, 2], [3, 4], [2, 1]]\n    queries = [[1, 2], [3, 4]]\n    self.assertEqual(self.solution.gridIllumination(n, lamps, queries), [1, 0])", "def test_gridIllumination(self):\n    n = 5\n    lamps = [[1, 2], [1, 3], [1, 4]]\n    queries = [[1, 0]]\n    self.assertEqual(self.solution.gridIllumination(n, lamps, queries), [1])", "def test_gridIllumination(self):\n    n = 5\n    lamps = [[0, 2], [1, 2], [3, 2]]\n    queries = [[0, 2]]\n    self.assertEqual(self.solution.gridIllumination(n, lamps, queries), [1])", "def test_gridIllumination(self):\n    n = 5\n    lamps = [[1, 2], [2, 3]]\n    queries = [[0, 0]]\n    self.assertEqual(self.solution.gridIllumination(n, lamps, queries), [0])", "def test_gridIllumination(self):\n    n = 5\n    lamps = [[1, 2]]\n    queries = [[1, 2]]\n    self.assertEqual(self.solution.gridIllumination(n, lamps, queries), [1])", "def test_gridIllumination(self):\n    n = 5\n    lamps = [[i, j] for i in range(n) for j in range(n)]\n    queries = []\n    self.assertEqual(self.solution.gridIllumination(n, lamps, queries), [1] * n)", "def test_gridIllumination(self):\n    n = 5\n    lamps = [[1, 2], [3, 4], [0, 0]]\n    queries = []\n    self.assertEqual(self.solution.gridIllumination(n, lamps, queries), [1, 0, 1])", "def test_gridIllumination(self):\n    n = 5\n    lamps = [[0, 0], [0, n - 1], [n - 1, 0], [n - 1, n - 1]]\n    queries = []\n    self.assertEqual(self.solution.gridIllumination(n, lamps, queries), [1, 1, 1, 1])", "def test_gridIllumination(self):\n    n = 5\n    lamps = [[0, 0], [n - 1, n - 1]]\n    queries = []\n    self.assertEqual(self.solution.gridIllumination(n, lamps, queries), [1, 0])", "def test_gridIllumination(self):\n    n = 5\n    lamps = [[0, 0], [n - 1, n - 1], [0, n - 1]]\n    queries = []\n    self.assertEqual(self.solution.gridIllumination(n, lamps, queries), [1, 0, 1])", "def test_gridIllumination(self):\n    n = 5\n    lamps = [[1, 2], [1, 3]]\n    queries = [[1, 2]]\n    self.assertEqual(self.solution.gridIllumination(n, lamps, queries), [0])", "def test_gridIllumination(self):\n    n = 5\n    lamps = [[1, 2], [3, 4]]\n    queries = [[1, 3]]\n    self.assertEqual(self.solution.gridIllumination(n, lamps, queries), [1])", "def test_gridIllumination(self):\n    n = 5\n    lamps = [[1, 2], [3, 4]]\n    queries = [[2, 3]]\n    self.assertEqual(self.solution.gridIllumination(n, lamps, queries), [0])", "def test_gridIllumination(self):\n    n = 5\n    lamps = [[1, 2], [3, 4]]\n    queries = [[3, 2]]\n    self.assertEqual(self.solution.gridIllumination(n, lamps, queries), [0])", "def test_gridIllumination(self):\n    n = 5\n    lamps = [[1, 2], [3, 4], [0, 0]]\n    queries = [[0, n - 1], [n - 1, 0], [0, 0]]\n    self.assertEqual(self.solution.gridIllumination(n, lamps, queries), [1, 1, 1])", "def test_gridIllumination(self):\n    n = 5\n    lamps = [[1, 2], [3, 4], [0, 0]]\n    queries = [[0, n - 1], [n - 1, 0]]\n    self.assertEqual(self.solution.gridIllumination(n, lamps, queries), [1, 0])", "def test_gridIllumination(self):\n    n = 5\n    lamps = [[1, 2], [3, 4], [0, 0]]\n    queries = [[0, n - 1], [n - 1, 0]]\n    self.assertEqual(self.solution.gridIllumination(n, lamps, queries), [1, 0])"]}
{"task_num": 1093, "task_title": "Statistics from a Large Sample", "func_name": "sampleStats", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def sampleStats(self, count: List[int]) -> List[float]:\n    minimum = next((i for i, num in enumerate(count) if num), None)\n    maximum = next((i for i, num in reversed(list(enumerate(count))) if num), None)\n    n = sum(count)\n    mean = sum(i * c / n for i, c in enumerate(count))\n    mode = count.index(max(count))\n\n    numCount = 0\n    leftMedian = 0\n    for i, c in enumerate(count):\n      numCount += c\n      if numCount >= n / 2:\n        leftMedian = i\n        break\n\n    numCount = 0\n    rightMedian = 0\n    for i, c in reversed(list(enumerate(count))):\n      numCount += c\n      if numCount >= n / 2:\n        rightMedian = i\n        break\n\n    return [minimum, maximum, mean, (leftMedian + rightMedian) / 2, mode]\n", "tests": ["def test_sampleStats(self):\n    count = [4, 1, 0, 3]\n    self.assertEqual(solution.sampleStats(count), [0.0, 3.0, 1.667, 1.5, 2])", "def test_sampleStats(self):\n    count = [10, 5, 0]\n    self.assertEqual(solution.sampleStats(count), [0.0, 9.0, 4.333, 5.0, 9])", "def test_sampleStats(self):\n    count = []\n    self.assertEqual(solution.sampleStats(count), [None, None, 0.0, 0.0, None])", "def test_sampleStats(self):\n    count = [i // 255 for i in range(256)]\n    self.assertAlmostEqual(solution.sampleStats(count)[2], 127.5)", "def test_sampleStats(self):\n    count = [3, 2, 1]\n    self.assertEqual(solution.sampleStats(count), [0.0, 2.0, 1.333, 1.5, 0])", "def test_sampleStats(self):\n    count = [1] * 100 + [2] * 101\n    self.assertAlmostEqual(solution.sampleStats(count)[3], 1.5)", "def test_sampleStats(self):\n    count = [1] * 100 + [2] * 101 + [3]\n    self.assertAlmostEqual(solution.sampleStats(count)[3], 2.0)", "def test_sampleStats(self):\n    count = [10] * 256\n    self.assertEqual(solution.sampleStats(count), [0.0, 255.0, 127.5, 127.5, 0])", "def test_sampleStats(self):\n    count = [1] * 256\n    self.assertEqual(solution.sampleStats(count), [0.0, 255.0, 127.5, 127.5, 0])", "def test_sampleStats(self):\n    count = [1] * 256 + [0]\n    self.assertEqual(solution.sampleStats(count), [0.0, None, 127.5, 127.5, 0])", "def test_sampleStats(self):\n    count = [0] * 256 + [1]\n    self.assertEqual(solution.sampleStats(count), [None, None, 127.5, 127.5, 0])", "def test_sampleStats(self):\n    count = [1] * 256 + [0]\n    self.assertEqual(solution.sampleStats(count), [None, None, 127.5, 127.5, 0])", "def test_sampleStats(self):\n    count = [1] * 100 + [2] * 101\n    self.assertAlmostEqual(solution.sampleStats(count)[3], 1.5)", "def test_sampleStats(self):\n    count = [3, 2, 1]\n    self.assertEqual(solution.sampleStats(count), [0.0, 2.0, 1.333, 1.5, 0])", "def test_sampleStats(self):\n    count = [1] * 100 + [2] * 101\n    self.assertAlmostEqual(solution.sampleStats(count)[3], 1.5)", "def test_sampleStats(self):\n    count = [1] * 256\n    self.assertEqual(solution.sampleStats(count), [0.0, 255.0, 127.5, 127.5, 0])", "def test_sampleStats(self):\n    count = [10, 5, 0]\n    self.assertEqual(solution.sampleStats(count), [0.0, 9.0, 4.333, 5.0, 9])", "def test_sampleStats(self):\n    count = [i // 255 for i in range(256)]\n    self.assertAlmostEqual(solution.sampleStats(count)[2], 127.5)", "def test_sampleStats(self):\n    count = [10] * 256\n    self.assertEqual(solution.sampleStats(count), [0.0, 255.0, 127.5, 127.5, 0])", "def test_sampleStats(self):\n    count = [1] * 256\n    self.assertEqual(solution.sampleStats(count), [0.0, 255.0, 127.5, 127.5, 0])"]}
{"task_num": 1129, "task_title": "Shortest Path with Alternating Colors", "func_name": "shortestAlternatingPaths", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import Enum\n\n\nclass Color(Enum):\n  kInit = 0\n  kRed = 1\n  kBlue = 2\n\n\nclass Solution:\n  def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:\n    ans = [-1] * n\n    graph = [[] for _ in range(n)]\n    q = collections.deque([(0, Color.kInit)])\n\n    for u, v in redEdges:\n      graph[u].append((v, Color.kRed))\n\n    for u, v in blueEdges:\n      graph[u].append((v, Color.kBlue))\n\n    step = 0\n    while q:\n      for _ in range(len(q)):\n        u, prevColor = q.popleft()\n        if ans[u] == -1:\n          ans[u] = step\n        for i, (v, edgeColor) in enumerate(graph[u]):\n          if v == -1 or edgeColor == prevColor:\n            continue\n          q.append((v, edgeColor))\n          graph[u][i] = (-1, edgeColor)\n      step += 1\n\n    return ans\n", "tests": ["def test_shortestAlternatingPaths(self):\n\n    class Solution:\n\n        def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:\n            ans = [-1] * n\n            graph = [[] for _ in range(n)]\n            q = collections.deque([(0, Color.kInit)])\n            for (u, v) in redEdges:\n                graph[u].append((v, Color.kRed))\n            for (u, v) in blueEdges:\n                graph[u].append((v, Color.kBlue))\n            step = 0\n            while q:\n                for _ in range(len(q)):\n                    (u, prevColor) = q.popleft()\n                    if ans[u] == -1:\n                        ans[u] = step\n                    for (i, (v, edgeColor)) in enumerate(graph[u]):\n                        if v == -1 or edgeColor == prevColor:\n                            continue\n                        q.append((v, edgeColor))\n                        graph[u][i] = (-1, edgeColor)\n                step += 1\n            return ans\n    solution = Solution()\n    n = 6\n    redEdges = [[0, 1], [1, 2]]\n    blueEdges = [[0, 2], [3, 4]]\n    self.assertEqual(solution.shortestAlternatingPaths(n, redEdges, blueEdges), [0, -1, -1, 0, -1, -1])", "def test_shortestAlternatingPaths(self):\n\n    class Solution:\n\n        def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:\n            ans = [-1] * n\n            graph = [[] for _ in range(n)]\n            q = collections.deque([(0, Color.kInit)])\n            for (u, v) in redEdges:\n                graph[u].append((v, Color.kRed))\n            for (u, v) in blueEdges:\n                graph[u].append((v, Color.kBlue))\n            step = 0\n            while q:\n                for _ in range(len(q)):\n                    (u, prevColor) = q.popleft()\n                    if ans[u] == -1:\n                        ans[u] = step\n                    for (i, (v, edgeColor)) in enumerate(graph[u]):\n                        if v == -1 or edgeColor == prevColor:\n                            continue\n                        q.append((v, edgeColor))\n                        graph[u][i] = (-1, edgeColor)\n                step += 1\n            return ans\n    solution = Solution()\n    n = 3\n    redEdges = [[0, 2], [2, 0]]\n    blueEdges = [[]]\n    self.assertEqual(solution.shortestAlternatingPaths(n, redEdges, blueEdges), [0, -1, 0])", "def test_shortestAlternatingPaths(self):\n\n    class Solution:\n\n        def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:\n            ans = [-1] * n\n            graph = [[] for _ in range(n)]\n            q = collections.deque([(0, Color.kInit)])\n            for (u, v) in redEdges:\n                graph[u].append((v, Color.kRed))\n            for (u, v) in blueEdges:\n                graph[u].append((v, Color.kBlue))\n            step = 0\n            while q:\n                for _ in range(len(q)):\n                    (u, prevColor) = q.popleft()\n                    if ans[u] == -1:\n                        ans[u] = step\n                    for (i, (v, edgeColor)) in enumerate(graph[u]):\n                        if v == -1 or edgeColor == prevColor:\n                            continue\n                        q.append((v, edgeColor))\n                        graph[u][i] = (-1, edgeColor)\n                step += 1\n            return ans\n    solution = Solution()\n    n = 4\n    redEdges = [[0, 2], [0, 3]]\n    blueEdges = []\n    self.assertEqual(solution.shortestAlternatingPaths(n, redEdges, blueEdges), [0, -1, -1, 0])", "def test_shortestAlternatingPaths(self):\n\n    class Solution:\n\n        def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:\n            ans = [-1] * n\n            graph = [[] for _ in range(n)]\n            q = collections.deque([(0, Color.kInit)])\n            for (u, v) in redEdges:\n                graph[u].append((v, Color.kRed))\n            for (u, v) in blueEdges:\n                graph[u].append((v, Color.kBlue))\n            step = 0\n            while q:\n                for _ in range(len(q)):\n                    (u, prevColor) = q.popleft()\n                    if ans[u] == -1:\n                        ans[u] = step\n                    for (i, (v, edgeColor)) in enumerate(graph[u]):\n                        if v == -1 or edgeColor == prevColor:\n                            continue\n                        q.append((v, edgeColor))\n                        graph[u][i] = (-1, edgeColor)\n                step += 1\n            return ans\n    solution = Solution()\n    n = 5\n    redEdges = [[0, 2], [3, 4]]\n    blueEdges = [[0, 1], [0, 3]]\n    self.assertEqual(solution.shortestAlternatingPaths(n, redEdges, blueEdges), [0, -1, 0, -1, 0])", "def test_shortestAlternatingPaths(self):\n\n    class Solution:\n\n        def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:\n            ans = [-1] * n\n            graph = [[] for _ in range(n)]\n            q = collections.deque([(0, Color.kInit)])\n            for (u, v) in redEdges:\n                graph[u].append((v, Color.kRed))\n            for (u, v) in blueEdges:\n                graph[u].append((v, Color.kBlue))\n            step = 0\n            while q:\n                for _ in range(len(q)):\n                    (u, prevColor) = q.popleft()\n                    if ans[u] == -1:\n                        ans[u] = step\n                    for (i, (v, edgeColor)) in enumerate(graph[u]):\n                        if v == -1 or edgeColor == prevColor:\n                            continue\n                        q.append((v, edgeColor))\n                        graph[u][i] = (-1, edgeColor)\n                step += 1\n            return ans\n    solution = Solution()\n    n = 6\n    redEdges = [[0, 1], [1, 2], [3, 4]]\n    blueEdges = [[0, 2], [0, 3]]\n    self.assertEqual(solution.shortestAlternatingPaths(n, redEdges, blueEdges), [0, -1, -1, -1, 0, -1])", "def test_shortestAlternatingPaths(self):\n\n    class Solution:\n\n        def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:\n            ans = [-1] * n\n            graph = [[] for _ in range(n)]\n            q = collections.deque([(0, Color.kInit)])\n            for (u, v) in redEdges:\n                graph[u].append((v, Color.kRed))\n            for (u, v) in blueEdges:\n                graph[u].append((v, Color.kBlue))\n            step = 0\n            while q:\n                for _ in range(len(q)):\n                    (u, prevColor) = q.popleft()\n                    if ans[u] == -1:\n                        ans[u] = step\n                    for (i, (v, edgeColor)) in enumerate(graph[u]):\n                        if v == -1 or edgeColor == prevColor:\n                            continue\n                        q.append((v, edgeColor))\n                        graph[u][i] = (-1, edgeColor)\n                step += 1\n            return ans\n    solution = Solution()\n    n = 7\n    redEdges = [[0, 2], [3, 4]]\n    blueEdges = [[0, 1]]\n    self.assertEqual(solution.shortestAlternatingPaths(n, redEdges, blueEdges), [0, -1, -1, 0, -1, -1, 0])", "def test_shortestAlternatingPaths(self):\n\n    class Solution:\n\n        def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:\n            ans = [-1] * n\n            graph = [[] for _ in range(n)]\n            q = collections.deque([(0, Color.kInit)])\n            for (u, v) in redEdges:\n                graph[u].append((v, Color.kRed))\n            for (u, v) in blueEdges:\n                graph[u].append((v, Color.kBlue))\n            step = 0\n            while q:\n                for _ in range(len(q)):\n                    (u, prevColor) = q.popleft()\n                    if ans[u] == -1:\n                        ans[u] = step\n                    for (i, (v, edgeColor)) in enumerate(graph[u]):\n                        if v == -1 or edgeColor == prevColor:\n                            continue\n                        q.append((v, edgeColor))\n                        graph[u][i] = (-1, edgeColor)\n                step += 1\n            return ans\n    solution = Solution()\n    n = 8\n    redEdges = [[0, 3], [2, 4]]\n    blueEdges = [[]]\n    self.assertEqual(solution.shortestAlternatingPaths(n, redEdges, blueEdges), [0, -1, 0, -1, -1, -1, 0, -1])", "def test_shortestAlternatingPaths(self):\n\n    class Solution:\n\n        def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:\n            ans = [-1] * n\n            graph = [[] for _ in range(n)]\n            q = collections.deque([(0, Color.kInit)])\n            for (u, v) in redEdges:\n                graph[u].append((v, Color.kRed))\n            for (u, v) in blueEdges:\n                graph[u].append((v, Color.kBlue))\n            step = 0\n            while q:\n                for _ in range(len(q)):\n                    (u, prevColor) = q.popleft()\n                    if ans[u] == -1:\n                        ans[u] = step\n                    for (i, (v, edgeColor)) in enumerate(graph[u]):\n                        if v == -1 or edgeColor == prevColor:\n                            continue\n                        q.append((v, edgeColor))\n                        graph[u][i] = (-1, edgeColor)\n                step += 1\n            return ans\n    solution = Solution()\n    n = 9\n    redEdges = [[0, 2], [3, 4]]\n    blueEdges = [[0, 5]]\n    self.assertEqual(solution.shortestAlternatingPaths(n, redEdges, blueEdges), [0, -1, -1, 0, -1, -1, -1, 0, -1])", "def test_shortestAlternatingPaths(self):\n\n    class Solution:\n\n        def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:\n            ans = [-1] * n\n            graph = [[] for _ in range(n)]\n            q = collections.deque([(0, Color.kInit)])\n            for (u, v) in redEdges:\n                graph[u].append((v, Color.kRed))\n            for (u, v) in blueEdges:\n                graph[u].append((v, Color.kBlue))\n            step = 0\n            while q:\n                for _ in range(len(q)):\n                    (u, prevColor) = q.popleft()\n                    if ans[u] == -1:\n                        ans[u] = step\n                    for (i, (v, edgeColor)) in enumerate(graph[u]):\n                        if v == -1 or edgeColor == prevColor:\n                            continue\n                        q.append((v, edgeColor))\n                        graph[u][i] = (-1, edgeColor)\n                step += 1\n            return ans\n    solution = Solution()\n    n = 10\n    redEdges = [[0, 4], [2, 6]]\n    blueEdges = [[1, 3]]\n    self.assertEqual(solution.shortestAlternatingPaths(n, redEdges, blueEdges), [0, -1, -1, 0, -1, 0, 0, -1, -1, -1])", "def test_shortestAlternatingPaths(self):\n\n    class Solution:\n\n        def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:\n            ans = [-1] * n\n            graph = [[] for _ in range(n)]\n            q = collections.deque([(0, Color.kInit)])\n            for (u, v) in redEdges:\n                graph[u].append((v, Color.kRed))\n            for (u, v) in blueEdges:\n                graph[u].append((v, Color.kBlue))\n            step = 0\n            while q:\n                for _ in range(len(q)):\n                    (u, prevColor) = q.popleft()\n                    if ans[u] == -1:\n                        ans[u] = step\n                    for (i, (v, edgeColor)) in enumerate(graph[u]):\n                        if v == -1 or edgeColor == prevColor:\n                            continue\n                        q.append((v, edgeColor))\n                        graph[u][i] = (-1, edgeColor)\n                step += 1\n            return ans\n    solution = Solution()\n    n = 11\n    redEdges = [[0, 2], [3, 4]]\n    blueEdges = [[]]\n    self.assertEqual(solution.shortestAlternatingPaths(n, redEdges, blueEdges), [0, -1, 0, -1, -1, -1, 0, -1, -1, -1, -1])", "def test_shortestAlternatingPaths(self):\n\n    class Solution:\n\n        def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:\n            ans = [-1] * n\n            graph = [[] for _ in range(n)]\n            q = collections.deque([(0, Color.kInit)])\n            for (u, v) in redEdges:\n                graph[u].append((v, Color.kRed))\n            for (u, v) in blueEdges:\n                graph[u].append((v, Color.kBlue))\n            step = 0\n            while q:\n                for _ in range(len(q)):\n                    (u, prevColor) = q.popleft()\n                    if ans[u] == -1:\n                        ans[u] = step\n                    for (i, (v, edgeColor)) in enumerate(graph[u]):\n                        if v == -1 or edgeColor == prevColor:\n                            continue\n                        q.append((v, edgeColor))\n                        graph[u][i] = (-1, edgeColor)\n                step += 1\n            return ans\n    solution = Solution()\n    n = 12\n    redEdges = [[0, 4], [2, 6]]\n    blueEdges = [[1, 3]]\n    self.assertEqual(solution.shortestAlternatingPaths(n, redEdges, blueEdges), [0, -1, -1, 0, -1, 0, 0, -1, -1, -1, -1, -1])", "def test_shortestAlternatingPaths(self):\n\n    class Solution:\n\n        def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:\n            ans = [-1] * n\n            graph = [[] for _ in range(n)]\n            q = collections.deque([(0, Color.kInit)])\n            for (u, v) in redEdges:\n                graph[u].append((v, Color.kRed))\n            for (u, v) in blueEdges:\n                graph[u].append((v, Color.kBlue))\n            step = 0\n            while q:\n                for _ in range(len(q)):\n                    (u, prevColor) = q.popleft()\n                    if ans[u] == -1:\n                        ans[u] = step\n                    for (i, (v, edgeColor)) in enumerate(graph[u]):\n                        if v == -1 or edgeColor == prevColor:\n                            continue\n                        q.append((v, edgeColor))\n                        graph[u][i] = (-1, edgeColor)\n                step += 1\n            return ans\n    solution = Solution()\n    n = 13\n    redEdges = [[0, 2], [3, 4]]\n    blueEdges = [[]]\n    self.assertEqual(solution.shortestAlternatingPaths(n, redEdges, blueEdges), [0, -1, 0, -1, -1, -1, 0, -1, -1, -1, -1, -1, -1])", "def test_shortestAlternatingPaths(self):\n\n    class Solution:\n\n        def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:\n            ans = [-1] * n\n            graph = [[] for _ in range(n)]\n            q = collections.deque([(0, Color.kInit)])\n            for (u, v) in redEdges:\n                graph[u].append((v, Color.kRed))\n            for (u, v) in blueEdges:\n                graph[u].append((v, Color.kBlue))\n            step = 0\n            while q:\n                for _ in range(len(q)):\n                    (u, prevColor) = q.popleft()\n                    if ans[u] == -1:\n                        ans[u] = step\n                    for (i, (v, edgeColor)) in enumerate(graph[u]):\n                        if v == -1 or edgeColor == prevColor:\n                            continue\n                        q.append((v, edgeColor))\n                        graph[u][i] = (-1, edgeColor)\n                step += 1\n            return ans\n    solution = Solution()\n    n = 14\n    redEdges = [[0, 4], [2, 6]]\n    blueEdges = [[1, 3]]\n    self.assertEqual(solution.shortestAlternatingPaths(n, redEdges, blueEdges), [0, -1, -1, 0, -1, 0, 0, -1, -1, -1, -1, -1, -1, -1])", "def test_shortestAlternatingPaths(self):\n\n    class Solution:\n\n        def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:\n            ans = [-1] * n\n            graph = [[] for _ in range(n)]\n            q = collections.deque([(0, Color.kInit)])\n            for (u, v) in redEdges:\n                graph[u].append((v, Color.kRed))\n            for (u, v) in blueEdges:\n                graph[u].append((v, Color.kBlue))\n            step = 0\n            while q:\n                for _ in range(len(q)):\n                    (u, prevColor) = q.popleft()\n                    if ans[u] == -1:\n                        ans[u] = step\n                    for (i, (v, edgeColor)) in enumerate(graph[u]):\n                        if v == -1 or edgeColor == prevColor:\n                            continue\n                        q.append((v, edgeColor))\n                        graph[u][i] = (-1, edgeColor)\n                step += 1\n            return ans\n    solution = Solution()\n    n = 15\n    redEdges = [[0, 2], [3, 4]]\n    blueEdges = [[]]\n    self.assertEqual(solution.shortestAlternatingPaths(n, redEdges, blueEdges), [0, -1, 0, -1, -1, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1])", "def test_shortestAlternatingPaths(self):\n\n    class Solution:\n\n        def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:\n            ans = [-1] * n\n            graph = [[] for _ in range(n)]\n            q = collections.deque([(0, Color.kInit)])\n            for (u, v) in redEdges:\n                graph[u].append((v, Color.kRed))\n            for (u, v) in blueEdges:\n                graph[u].append((v, Color.kBlue))\n            step = 0\n            while q:\n                for _ in range(len(q)):\n                    (u, prevColor) = q.popleft()\n                    if ans[u] == -1:\n                        ans[u] = step\n                    for (i, (v, edgeColor)) in enumerate(graph[u]):\n                        if v == -1 or edgeColor == prevColor:\n                            continue\n                        q.append((v, edgeColor))\n                        graph[u][i] = (-1, edgeColor)\n                step += 1\n            return ans\n    solution = Solution()\n    n = 16\n    redEdges = [[0, 4], [2, 6]]\n    blueEdges = [[1, 3]]\n    self.assertEqual(solution.shortestAlternatingPaths(n, redEdges, blueEdges), [0, -1, -1, 0, -1, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1])", "def test_shortestAlternatingPaths(self):\n\n    class Solution:\n\n        def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:\n            ans = [-1] * n\n            graph = [[] for _ in range(n)]\n            q = collections.deque([(0, Color.kInit)])\n            for (u, v) in redEdges:\n                graph[u].append((v, Color.kRed))\n            for (u, v) in blueEdges:\n                graph[u].append((v, Color.kBlue))\n            step = 0\n            while q:\n                for _ in range(len(q)):\n                    (u, prevColor) = q.popleft()\n                    if ans[u] == -1:\n                        ans[u] = step\n                    for (i, (v, edgeColor)) in enumerate(graph[u]):\n                        if v == -1 or edgeColor == prevColor:\n                            continue\n                        q.append((v, edgeColor))\n                        graph[u][i] = (-1, edgeColor)\n                step += 1\n            return ans\n    solution = Solution()\n    n = 17\n    redEdges = [[0, 2], [3, 4]]\n    blueEdges = [[]]\n    self.assertEqual(solution.shortestAlternatingPaths(n, redEdges, blueEdges), [0, -1, 0, -1, -1, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1])", "def test_shortestAlternatingPaths(self):\n\n    class Solution:\n\n        def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:\n            ans = [-1] * n\n            graph = [[] for _ in range(n)]\n            q = collections.deque([(0, Color.kInit)])\n            for (u, v) in redEdges:\n                graph[u].append((v, Color.kRed))\n            for (u, v) in blueEdges:\n                graph[u].append((v, Color.kBlue))\n            step = 0\n            while q:\n                for _ in range(len(q)):\n                    (u, prevColor) = q.popleft()\n                    if ans[u] == -1:\n                        ans[u] = step\n                    for (i, (v, edgeColor)) in enumerate(graph[u]):\n                        if v == -1 or edgeColor == prevColor:\n                            continue\n                        q.append((v, edgeColor))\n                        graph[u][i] = (-1, edgeColor)\n                step += 1\n            return ans\n    solution = Solution()\n    n = 18\n    redEdges = [[0, 4], [2, 6]]\n    blueEdges = [[1, 3]]\n    self.assertEqual(solution.shortestAlternatingPaths(n, redEdges, blueEdges), [0, -1, -1, 0, -1, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1])", "def test_shortestAlternatingPaths(self):\n\n    class Solution:\n\n        def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:\n            ans = [-1] * n\n            graph = [[] for _ in range(n)]\n            q = collections.deque([(0, Color.kInit)])\n            for (u, v) in redEdges:\n                graph[u].append((v, Color.kRed))\n            for (u, v) in blueEdges:\n                graph[u].append((v, Color.kBlue))\n            step = 0\n            while q:\n                for _ in range(len(q)):\n                    (u, prevColor) = q.popleft()\n                    if ans[u] == -1:\n                        ans[u] = step\n                    for (i, (v, edgeColor)) in enumerate(graph[u]):\n                        if v == -1 or edgeColor == prevColor:\n                            continue\n                        q.append((v, edgeColor))\n                        graph[u][i] = (-1, edgeColor)\n                step += 1\n            return ans\n    solution = Solution()\n    n = 19\n    redEdges = [[0, 2], [3, 4]]\n    blueEdges = [[5, 6]]\n    self.assertEqual(solution.shortestAlternatingPaths(n, redEdges, blueEdges), [0, -1, 0, -1, -1, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1])", "def test_shortestAlternatingPaths(self):\n\n    class Solution:\n\n        def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:\n            ans = [-1] * n\n            graph = [[] for _ in range(n)]\n            q = collections.deque([(0, Color.kInit)])\n            for (u, v) in redEdges:\n                graph[u].append((v, Color.kRed))\n            for (u, v) in blueEdges:\n                graph[u].append((v, Color.kBlue))\n            step = 0\n            while q:\n                for _ in range(len(q)):\n                    (u, prevColor) = q.popleft()\n                    if ans[u] == -1:\n                        ans[u] = step\n                    for (i, (v, edgeColor)) in enumerate(graph[u]):\n                        if v == -1 or edgeColor == prevColor:\n                            continue\n                        q.append((v, edgeColor))\n                        graph[u][i] = (-1, edgeColor)\n                step += 1\n            return ans\n    solution = Solution()\n    n = 20\n    redEdges = [[0, 4], [2, 6]]\n    blueEdges = [[]]\n    self.assertEqual(solution.shortestAlternatingPaths(n, redEdges, blueEdges), [0, -1, 0, -1, -1, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1])", "def test_shortestAlternatingPaths(self):\n\n    class Solution:\n\n        def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:\n            ans = [-1] * n\n            graph = [[] for _ in range(n)]\n            q = collections.deque([(0, Color.kInit)])\n            for (u, v) in redEdges:\n                graph[u].append((v, Color.kRed))\n            for (u, v) in blueEdges:\n                graph[u].append((v, Color.kBlue))\n            step = 0\n            while q:\n                for _ in range(len(q)):\n                    (u, prevColor) = q.popleft()\n                    if ans[u] == -1:\n                        ans[u] = step\n                    for (i, (v, edgeColor)) in enumerate(graph[u]):\n                        if v == -1 or edgeColor == prevColor:\n                            continue\n                        q.append((v, edgeColor))\n                        graph[u][i] = (-1, edgeColor)\n                step += 1\n            return ans\n    solution = Solution()\n    n = 21\n    redEdges = [[0, 2], [3, 4]]\n    blueEdges = [[], [5, 6]]\n    self.assertEqual(solution.shortestAlternatingPaths(n, redEdges, blueEdges), [0, -1, 0, -1, -1, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1])"]}
{"task_num": 1139, "task_title": "Largest 1-Bordered Square", "func_name": "largest1BorderedSquare", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n\n    leftOnes = [[0] * n for _ in range(m)]\n    topOnes = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1:\n          if j==0:\n            leftOnes[i][j]=1\n          else:\n            leftOnes[i][j]=1+leftOnes[i][j-1]\n          if i==0:\n            topOnes[i][j]=1\n          else:\n            topOnes[i][j]=1+topOnes[i-1][j]\n\n    for sz in range(min(m, n), 0, -1):\n      for i in range(m - sz + 1):\n        for j in range(n - sz + 1):\n          x = i + sz - 1\n          y = j + sz - 1\n          if min(leftOnes[i][y], leftOnes[x][y], topOnes[x][j], topOnes[x][y]) >= sz:\n            return sz * sz\n\n    return 0\n", "tests": ["def test_largest1BorderedSquare(self):\n    grid = [[1, 0, 1], [1, 1, 1], [1, 1, 0]]\n    self.assertEqual(solution.largest1BorderedSquare(grid), 4)", "def test_largest1BorderedSquare(self):\n    grid = []\n    self.assertEqual(solution.largest1BorderedSquare(grid), 0)", "def test_largest1BorderedSquare(self):\n    grid = [[0]]\n    self.assertEqual(solution.largest1BorderedSquare(grid), 0)", "def test_largest1BorderedSquare(self):\n    grid = [[0, 1, 0], [1, 1, 1], [0, 1, 0]]\n    self.assertEqual(solution.largest1BorderedSquare(grid), 0)", "def test_largest1BorderedSquare(self):\n    grid = [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\n    self.assertEqual(solution.largest1BorderedSquare(grid), 9)", "def test_largest1BorderedSquare(self):\n    grid = [[0, 1, 0], [1, 1, 1], [0, 1, 0]]\n    self.assertEqual(solution.largest1BorderedSquare(grid), 4)", "def test_largest1BorderedSquare(self):\n    grid = [[0, 0], [0, 0]]\n    self.assertEqual(solution.largest1BorderedSquare(grid), 1)", "def test_largest1BorderedSquare(self):\n    grid = [[0, 1], [1, 1]]\n    self.assertEqual(solution.largest1BorderedSquare(grid), 4)", "def test_largest1BorderedSquare(self):\n    grid = [[0, 0, 0], [1, 1, 1], [0, 0, 0]]\n    self.assertEqual(solution.largest1BorderedSquare(grid), 4)", "def test_largest1BorderedSquare(self):\n    grid = [[0, 1], [1, 1]]\n    self.assertEqual(solution.largest1BorderedSquare(grid), 4)", "def test_largest1BorderedSquare(self):\n    grid = [[0, 0, 0, 0], [0, 1, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0]]\n    self.assertEqual(solution.largest1BorderedSquare(grid), 4)", "def test_largest1BorderedSquare(self):\n    grid = [[0, 0], [0, 0]]\n    self.assertEqual(solution.largest1BorderedSquare(grid), 0)", "def test_largest1BorderedSquare(self):\n    grid = [[0, 1, 0], [0, 1, 0], [0, 1, 0]]\n    self.assertEqual(solution.largest1BorderedSquare(grid), 9)", "def test_largest1BorderedSquare(self):\n    grid = [[0, 1, 0], [1, 1, 1], [0, 1, 0]]\n    self.assertEqual(solution.largest1BorderedSquare(grid), 9)", "def test_largest1BorderedSquare(self):\n    grid = [[0, 1, 0], [1, 1, 1], [0, 1, 0]]\n    self.assertEqual(solution.largest1BorderedSquare(grid), 9)", "def test_largest1BorderedSquare(self):\n    grid = [[0, 0, 1], [0, 0, 1], [1, 1, 1]]\n    self.assertEqual(solution.largest1BorderedSquare(grid), 9)", "def test_largest1BorderedSquare(self):\n    grid = [[0] * 100 + [1] * 100 + [0] * 100]\n    self.assertEqual(solution.largest1BorderedSquare(grid), 100)", "def test_largest1BorderedSquare(self):\n    grid = [[1] * 100 + [0] * 100 for _ in range(100)]\n    self.assertEqual(solution.largest1BorderedSquare(grid), 10000)", "def test_largest1BorderedSquare(self):\n    grid = [[0] * 100 + [1] * 100 for _ in range(100)] + [[0] * 100 + [1] * 100 for _ in range(100)]\n    self.assertEqual(solution.largest1BorderedSquare(grid), 10000)", "def test_largest1BorderedSquare(self):\n    grid = [[-1, -1], [-1, -1]]\n    self.assertEqual(solution.largest1BorderedSquare(grid), 0)"]}
{"task_num": 1162, "task_title": "As Far from Land as Possible", "func_name": "maxDistance", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxDistance(self, grid: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    q = collections.deque()\n    water = 0\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 0:\n          water += 1\n        else:\n          q.append((i, j))\n\n    if water == 0 or water == m * n:\n      return -1\n\n    ans = 0\n    d = 0\n\n    while q:\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        ans = d\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if grid[x][y] > 0:\n            continue\n          q.append((x, y))\n          grid[x][y] = 2\n      d += 1\n\n    return ans\n", "tests": ["def test_maxDistance():\n\n    def maxDistance(self):\n        grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n        return self.maxDistance(grid)\n    solution = Solution()\n    assert maxDistance(solution) == 2", "def test_maxDistance():\n\n    def maxDistance(self):\n        grid = [[1, 1], [1, 0]]\n        return self.maxDistance(grid)\n    solution = Solution()\n    assert maxDistance(solution) == -1", "def test_maxDistance():\n\n    def maxDistance(self):\n        grid = [[0, 1], [1, 0]]\n        return self.maxDistance(grid)\n    solution = Solution()\n    assert maxDistance(solution) == 1", "def test_maxDistance():\n\n    def maxDistance(self):\n        grid = [[0] * 5 + [1] + [0] * 4, [0] * 5 + [1] + [0] * 4, [0] * 10 + [1]]\n        return self.maxDistance(grid)", "def test_maxDistance():\n\n    def maxDistance(self):\n        grid = [[1] * 25, [1] * 25]\n        return self.maxDistance(grid)", "def test_maxDistance():\n\n    def maxDistance(self):\n        grid = [[0] * 50 + [1] + [0] * 49, [0] * 50 + [1] + [0] * 49, [0] * 100]\n        return self.maxDistance(grid)", "def test_maxDistance():\n\n    def maxDistance(self):\n        grid = [[1] * 25, [0] * 25]\n        return self.maxDistance(grid)", "def test_maxDistance():\n\n    def maxDistance(self):\n        grid = [[1] * 25, [0] * 25, [0] * 50 + [1] + [0] * 49]\n        return self.maxDistance(grid)", "def test_maxDistance():\n\n    def maxDistance(self):\n        grid = [[0] * 100 + [1] + [0] * 99, [0] * 100 + [1] + [0] * 99, [0] * 200]\n        return self.maxDistance(grid)", "def test_maxDistance():\n\n    def maxDistance(self):\n        grid = [[0] * 5 + [1] + [0] * 4, [0] * 5 + [1] + [0] * 4, [0] * 10 + [1]]\n        return self.maxDistance(grid)", "def test_maxDistance():\n\n    def maxDistance(self):\n        grid = [[1] * 5 + [0] + [1] * 4, [1] * 5 + [0] + [1] * 4, [1] * 10]\n        return self.maxDistance(grid)", "def test_maxDistance():\n\n    def maxDistance(self):\n        grid = [[0], [0]]\n        return self.maxDistance(grid)", "def test_maxDistance():\n\n    def maxDistance(self):\n        grid = [[1], [0]]\n        return self.maxDistance(grid)", "def test_maxDistance():\n\n    def maxDistance(self):\n        grid = [[1] * 2 + [0] + [1] * 2, [1] * 2 + [0] + [1] * 2, [1]]\n        return self.maxDistance(grid)", "def test_maxDistance():\n\n    def maxDistance(self):\n        grid = [[1] * 2 + [0] + [1] * 2, [1] * 2 + [0] + [1] * 2]\n        return self.maxDistance(grid)", "def test_maxDistance():\n\n    def maxDistance(self):\n        grid = [[1] * 3 + [0] + [1] * 3, [1] * 3 + [0] + [1] * 3, [1] * 6]\n        return self.maxDistance(grid)", "def test_maxDistance():\n\n    def maxDistance(self):\n        grid = [[1] * 4 + [0] + [1] * 4, [1] * 4 + [0] + [1] * 4, [1] * 8, [1] * 8]\n        return self.maxDistance(grid)", "def test_maxDistance():\n\n    def maxDistance(self):\n        grid = [[1] * 5 + [0] + [1] * 4, [1] * 5 + [0] + [1] * 4, [1] * 10, [1] * 10, [1] * 20]\n        return self.maxDistance(grid)", "def test_maxDistance():\n\n    def maxDistance(self):\n        grid = [[1] * 11 + [0] + [1] * 10, [1] * 11 + [0] + [1] * 10, [1] * 22, [1] * 22, [1] * 44]\n        return self.maxDistance(grid)", "def test_maxDistance():\n\n    def maxDistance(self):\n        grid = [[1] * 23 + [0] + [1] * 22, [1] * 23 + [0] + [1] * 22, [1] * 46, [1] * 46, [1] * 92, [1] * 92]\n        return self.maxDistance(grid)"]}
{"task_num": 1202, "task_title": "Smallest String With Swaps", "func_name": "smallestStringWithSwaps", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n    ans = ''\n    uf = UnionFind(len(s))\n    map = collections.defaultdict(list)\n\n    for a, b in pairs:\n      uf.unionByRank(a, b)\n\n    for i, c in enumerate(s):\n      map[uf.find(i)].append(c)\n\n    for key in map.keys():\n      map[key].sort(reverse=True)\n\n    for i in range(len(s)):\n      ans += map[uf.find(i)].pop()\n\n    return ans\n", "tests": ["def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'dcab'\n    pairs = [[0, 3], [1, 2]]\n    assert solution.smallestStringWithSwaps(s, pairs) == 'bacd'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'ddd'\n    pairs = [[0, 1], [1, 2]]\n    assert solution.smallestStringWithSwaps(s, pairs) == 'ddd'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'a'\n    pairs = []\n    assert solution.smallestStringWithSwaps(s, pairs) == 'a'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'aab'\n    pairs = [[0, 1]]\n    assert solution.smallestStringWithSwaps(s, pairs) == 'aba'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'abcd'\n    pairs = [[0], [1]]\n    assert solution.smallestStringWithSwaps(s, pairs) == 'dcba'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'xy'\n    pairs = [[0, 1]]\n    assert solution.smallestStringWithSwaps(s, pairs) == 'yx'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'zzzz'\n    pairs = [[0, 1], [1, 2], [2, 3]]\n    assert solution.smallestStringWithSwaps(s, pairs) == 'zzzz'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'ab'\n    pairs = [[0]]\n    assert solution.smallestStringWithSwaps(s, pairs) == 'ba'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'aa'\n    pairs = [[0]]\n    assert solution.smallestStringWithSwaps(s, pairs) == 'aa'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'abcd'\n    pairs = [[0], [2]]\n    assert solution.smallestStringWithSwaps(s, pairs) == 'dbac'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'aaa'\n    pairs = [[0], [1]]\n    assert solution.smallestStringWithSwaps(s, pairs) == 'baaa'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'abcdef'\n    pairs = [[0, 1], [2, 3]]\n    assert solution.smallestStringWithSwaps(s, pairs) == 'acefdb'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'abac'\n    pairs = [[0], [1]]\n    assert solution.smallestStringWithSwaps(s, pairs) == 'acba'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'abcd'\n    pairs = [[0], [1], [2]]\n    assert solution.smallestStringWithSwaps(s, pairs) == 'dcba'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'aabbcc'\n    pairs = [[0, 1], [2, 3]]\n    assert solution.smallestStringWithSwaps(s, pairs) == 'abcbac'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'abcdef'\n    pairs = []\n    assert solution.smallestStringWithSwaps(s, pairs) == 'abcdef'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'a'\n    pairs = [[0]]\n    assert solution.smallestStringWithSwaps(s, pairs) == 'a'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'abcdef'\n    pairs = [[0, 2], [1, 3]]\n    assert solution.smallestStringWithSwaps(s, pairs) == 'badcfe'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'abcd'\n    pairs = [[0], [1]]\n    assert solution.smallestStringWithSwaps(s, pairs) == 'acbd'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'abc'\n    pairs = [[0], [2]]\n    assert solution.smallestStringWithSwaps(s, pairs) == 'bac'"]}
{"task_num": 1210, "task_title": "Minimum Moves to Reach Target with Rotations", "func_name": "minimumMoves", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import IntEnum\n\n\nclass Pos(IntEnum):\n  kHorizontal = 0\n  kVertical = 1\n\n\nclass Solution:\n  def minimumMoves(self, grid: List[List[int]]) -> int:\n    n = len(grid)\n    ans = 0\n\n    q = collections.deque([(0, 0, Pos.kHorizontal)])\n    seen = {(0, 0, Pos.kHorizontal)}\n\n    def canMoveRight(x: int, y: int, pos: Pos) -> bool:\n      if pos == Pos.kHorizontal:\n        return y + 2 < n and not grid[x][y + 2]\n      return y + 1 < n and not grid[x][y + 1] and not grid[x + 1][y + 1]\n\n    def canMoveDown(x: int, y: int, pos: Pos) -> bool:\n      if pos == Pos.kVertical:\n        return x + 2 < n and not grid[x + 2][y]\n      return x + 1 < n and not grid[x + 1][y] and not grid[x + 1][y + 1]\n\n    def canRotateClockwise(x: int, y: int, pos: Pos) -> bool:\n      return pos == Pos.kHorizontal and x + 1 < n and \\\n          not grid[x + 1][y + 1] and not grid[x + 1][y]\n\n    def canRotateCounterclockwise(x: int, y: int, pos: Pos) -> bool:\n      return pos == Pos.kVertical and y + 1 < n and \\\n          not grid[x + 1][y + 1] and not grid[x][y + 1]\n\n    while q:\n      for _ in range(len(q)):\n        x, y, pos = q.popleft()\n        if x == n - 1 and y == n - 2 and pos == Pos.kHorizontal:\n          return ans\n        if canMoveRight(x, y, pos) and (x, y + 1, pos) not in seen:\n          q.append((x, y + 1, pos))\n          seen.add((x, y + 1, pos))\n        if canMoveDown(x, y, pos) and (x + 1, y, pos) not in seen:\n          q.append((x + 1, y, pos))\n          seen.add((x + 1, y, pos))\n        newPos = Pos.kVertical if pos == Pos.kHorizontal else Pos.kHorizontal\n        if (canRotateClockwise(x, y, pos) or canRotateCounterclockwise(x, y, pos)) and (x, y, newPos) not in seen:\n          q.append((x, y, newPos))\n          seen.add((x, y, newPos))\n      ans += 1\n\n    return -1\n", "tests": ["def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]\n    assert solution.minimumMoves(grid) == 3", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[1, 1, 1], [1, 0, 1], [1, 0, 1]]\n    assert solution.minimumMoves(grid) == -1", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 0], [0, 1]]\n    assert solution.minimumMoves(grid) == -1", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 0, 0], [1, 1, 0], [0, 0, 0]]\n    assert solution.minimumMoves(grid) == 2", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0], [1]]\n    assert solution.minimumMoves(grid) == -1", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n    assert solution.minimumMoves(grid) == 4", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0], [0], [1]]\n    assert solution.minimumMoves(grid) == -1", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 0], [0, 0], [1, 1]]\n    assert solution.minimumMoves(grid) == 4", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[1, 0], [0, 0]]\n    assert solution.minimumMoves(grid) == -1", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 0, 0], [1, 1, 1], [0, 0, 0]]\n    assert solution.minimumMoves(grid) == -1", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 0, 0], [1, 0, 0], [1, 1, 1]]\n    assert solution.minimumMoves(grid) == -1", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0], [0]]\n    assert solution.minimumMoves(grid) == -1", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 1, 0], [0, 1, 0], [0, 1, 0]]\n    assert solution.minimumMoves(grid) == -1", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 0], [0, 1]]\n    assert solution.minimumMoves(grid) == -1", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 0, 0], [1, 1, 1], [0, 0, 0]]\n    assert solution.minimumMoves(grid) == -1", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 0], [1, 1]]\n    assert solution.minimumMoves(grid) == -1", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 0, 0], [1, 1, 0], [0, 0, 1]]\n    assert solution.minimumMoves(grid) == -1", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 0], [0, 1]]\n    assert solution.minimumMoves(grid) == -1", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 0, 0], [1, 0, 0], [1, 1, 0]]\n    assert solution.minimumMoves(grid) == -1", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 1, 0], [0, 1, 0], [0, 0, 0]]\n    assert solution.minimumMoves(grid) == -1"]}
{"task_num": 1253, "task_title": "Reconstruct a 2-Row Binary Matrix", "func_name": "reconstructMatrix", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def reconstructMatrix(self, upper: int, lower: int, colsum: List[int]) -> List[List[int]]:\n    if upper + lower != sum(colsum):\n      return []\n    if min(upper, lower) < colsum.count(2):\n      return []\n\n    ans = [[0] * len(colsum) for _ in range(2)]\n\n    for j, c in enumerate(colsum):\n      if c == 2:\n        ans[0][j] = 1\n        ans[1][j] = 1\n        upper -= 1\n        lower -= 1\n\n    for j, c in enumerate(colsum):\n      if c == 1 and upper > 0:\n        ans[0][j] = 1\n        c -= 1\n        upper -= 1\n      if c == 1 and lower > 0:\n        ans[1][j] = 1\n        lower -= 1\n\n    return ans\n", "tests": ["def test_reconstructMatrix(self):\n    solution = Solution()\n    upper = 4\n    lower = 3\n    colsum = [2, 2, 1, 1]\n    self.assertEqual(solution.reconstructMatrix(upper, lower, colsum), [[1, 0, 1, 0], [1, 1, 0, 0]])", "def test_reconstructMatrix(self):\n    solution = Solution()\n    upper = 5\n    lower = 3\n    colsum = [2, 1, 2]\n    self.assertEqual(solution.reconstructMatrix(upper, lower, colsum), [])", "def test_reconstructMatrix(self):\n    solution = Solution()\n    upper = 2\n    lower = 3\n    colsum = [2, 1]\n    self.assertEqual(solution.reconstructMatrix(upper, lower, colsum), [])", "def test_reconstructMatrix(self):\n    solution = Solution()\n    upper = 0\n    lower = 0\n    colsum = [0, 0]\n    self.assertEqual(solution.reconstructMatrix(upper, lower, colsum), [[], []])", "def test_reconstructMatrix(self):\n    solution = Solution()\n    upper = 2\n    lower = 3\n    colsum = [1, 1, 1]\n    self.assertEqual(solution.reconstructMatrix(upper, lower, colsum), [])", "def test_reconstructMatrix(self):\n    solution = Solution()\n    upper = 2\n    lower = 2\n    colsum = [2, 2]\n    self.assertEqual(solution.reconstructMatrix(upper, lower, colsum), [[1, 1], [1, 1]])", "def test_reconstructMatrix(self):\n    solution = Solution()\n    upper = 3\n    lower = 2\n    colsum = [2, 1, 2]\n    self.assertEqual(solution.reconstructMatrix(upper, lower, colsum), [])", "def test_reconstructMatrix(self):\n    solution = Solution()\n    upper = 0\n    lower = 2\n    colsum = [1, 1]\n    self.assertEqual(solution.reconstructMatrix(upper, lower, colsum), [[], [1, 1]])", "def test_reconstructMatrix(self):\n    solution = Solution()\n    upper = 2\n    lower = 1\n    colsum = [2]\n    self.assertEqual(solution.reconstructMatrix(upper, lower, colsum), [[1], []])", "def test_reconstructMatrix(self):\n    solution = Solution()\n    upper = 0\n    lower = 1\n    colsum = []\n    self.assertEqual(solution.reconstructMatrix(upper, lower, colsum), [])", "def test_reconstructMatrix(self):\n    solution = Solution()\n    upper = 1\n    lower = 2\n    colsum = [0, 2]\n    self.assertEqual(solution.reconstructMatrix(upper, lower, colsum), [[], [1, 1]])", "def test_reconstructMatrix(self):\n    solution = Solution()\n    upper = 0\n    lower = 2\n    colsum = [1, 1]\n    self.assertEqual(solution.reconstructMatrix(upper, lower, colsum), [[], [1, 1]])", "def test_reconstructMatrix(self):\n    solution = Solution()\n    upper = 10\n    lower = 20\n    colsum = [12, 11, 13]\n    self.assertEqual(solution.reconstructMatrix(upper, lower, colsum), [[1, 0, 1], [1, 1, 1]])", "def test_reconstructMatrix(self):\n    solution = Solution()\n    upper = 1000\n    lower = 2000\n    colsum = [1100, 1200, 1300]\n    self.assertEqual(solution.reconstructMatrix(upper, lower, colsum), [[1] * len(colsum), [1] * len(colsum)])", "def test_reconstructMatrix(self):\n    solution = Solution()\n    upper = 10\n    lower = -20\n    colsum = [12, -11, 13]\n    self.assertEqual(solution.reconstructMatrix(upper, lower, colsum), [])", "def test_reconstructMatrix(self):\n    solution = Solution()\n    upper = 10.5\n    lower = 20.7\n    colsum = [12, 11.9, 13]\n    self.assertEqual(solution.reconstructMatrix(int(upper), int(lower), colsum), [])", "def test_reconstructMatrix(self):\n    solution = Solution()\n    upper = 0\n    lower = 10\n    colsum = [1, 2]\n    self.assertEqual(solution.reconstructMatrix(upper, lower, colsum), [])", "def test_reconstructMatrix(self):\n    solution = Solution()\n    upper = 10\n    lower = 20\n    colsum = []\n    self.assertEqual(solution.reconstructMatrix(upper, lower, colsum), [])", "def test_reconstructMatrix(self):\n    solution = Solution()\n    upper = 0\n    lower = 10\n    colsum = [1, 2]\n    self.assertEqual(solution.reconstructMatrix(upper, lower, colsum), [])", "def test_reconstructMatrix(self):\n    solution = Solution()\n    upper = 10\n    lower = 10\n    colsum = [1, 2, 3]\n    self.assertEqual(solution.reconstructMatrix(upper, lower, colsum), [])"]}
{"task_num": 1254, "task_title": "Number of Closed Islands", "func_name": "closedIsland", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def closedIsland(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n\n    def dfs(i: int, j: int) -> None:\n      if i < 0 or i == m or j < 0 or j == n:\n        return\n      if grid[i][j] == 1:\n        return\n\n      grid[i][j] = 1\n      dfs(i + 1, j)\n      dfs(i - 1, j)\n      dfs(i, j + 1)\n      dfs(i, j - 1)\n\n    for i in range(m):\n      for j in range(n):\n        if i * j == 0 or i == m - 1 or j == n - 1:\n          if grid[i][j] == 0:\n            dfs(i, j)\n\n    ans = 0\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 0:\n          dfs(i, j)\n          ans += 1\n\n    return ans\n", "tests": ["def test_closedIsland():\n\n    class Solution:\n\n        def closedIsland(self, grid: List[List[int]]) -> int:\n            m = len(grid)\n            n = len(grid[0])\n\n            def dfs(i: int, j: int) -> None:\n                if i < 0 or i == m or j < 0 or (j == n):\n                    return\n                if grid[i][j] == 1:\n                    return\n                grid[i][j] = 1\n                dfs(i + 1, j)\n                dfs(i - 1, j)\n                dfs(i, j + 1)\n                dfs(i, j - 1)\n            for i in range(m):\n                for j in range(n):\n                    if i * j == 0 or i == m - 1 or j == n - 1:\n                        if grid[i][j] == 0:\n                            dfs(i, j)\n            ans = 0\n            for i in range(m):\n                for j in range(n):\n                    if grid[i][j] == 0:\n                        dfs(i, j)\n                        ans += 1\n            return ans\n    solution = Solution()", "def test_closedIsland():\n    solution = Solution()\n    grid = [[0, 0, 1, 0, 0], [0, 0, 0, 0, 1], [0, 1, 1, 1, 1], [0, 1, 0, 0, 1]]\n    print(solution.closedIsland(grid))", "def test_closedIsland():\n    solution = Solution()\n    grid = [[0, 1, 0], [0, 0, 0], [1, 1, 1]]\n    print(solution.closedIsland(grid))", "def test_closedIsland():\n    solution = Solution()\n    grid = [[1, 0, 0], [0, 0, 0], [0, 0, 1]]\n    print(solution.closedIsland(grid))", "def test_closedIsland():\n    solution = Solution()\n    grid = [[1, 1], [1, 0]]\n    print(solution.closedIsland(grid))", "def test_closedIsland():\n    solution = Solution()\n    grid = [[1, 0, 0], [1, 1, 1]]\n    print(solution.closedIsland(grid))", "def test_closedIsland():\n    solution = Solution()\n    grid = [[0]]\n    print(solution.closedIsland(grid))", "def test_closedIsland():\n    solution = Solution()\n    grid = [[1]]\n    print(solution.closedIsland(grid))", "def test_closedIsland9():\n  solution=Solution()\n  grid=[[]]\n  try:\n    print(solution.closedIsland(grid))", "def test_closedIsland10():\n  solution=Solution()\n  grid=[[]]\n  try:\n    print(solution.closedIsland(grid))", "def test_closedIsland():\n    solution = Solution()\n    grid = [[1] * 5 + [0]] * 5\n    print(solution.closedIsland(grid))", "def test_closedIsland():\n    solution = Solution()\n    grid = [[0] * 5 + [1]] * 5 + [0]\n    print(solution.closedIsland(grid))", "def test_closedIsland():\n    solution = Solution()\n    grid = [[1] * 10 + [0]] * 2 + [0]\n    print(solution.closedIsland(grid))", "def test_closedIsland():\n    solution = Solution()\n    grid = [[1] * 5 + [0]] * 10 + [0]\n    print(solution.closedIsland(grid))", "def test_closedIsland():\n    solution = Solution()\n    grid = [[0] * 5 + [1]] * 10 + [0]\n    print(solution.closedIsland(grid))", "def test_closedIsland():\n    solution = Solution()\n    grid = [[1] * 3 + [0]] * 5 + [[1]]\n    print(solution.closedIsland(grid))", "def test_closedIsland():\n    solution = Solution()\n    grid = [[0] * 10 + [1]] * 5 + [[0]]\n    print(solution.closedIsland(grid))", "def test_closedIsland():\n    solution = Solution()\n    grid = [[1] * 5 + [0]] * 10 + [[1]]\n    print(solution.closedIsland(grid))", "def test_closedIsland():\n    solution = Solution()\n    grid = [[1] * 5 + [0]] * 10 + [[0]]\n    print(solution.closedIsland(grid))", "def test_closedIsland():\n    solution = Solution()\n    grid = [[1] * 10 + [0]] * 5 + [[0]]\n    print(solution.closedIsland(grid))"]}
{"task_num": 1263, "task_title": "Minimum Moves to Move a Box to Their Target Location", "func_name": "minPushBox", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\nfrom collections import deque\n\nclass Solution:\n  def minPushBox(self, grid: List[List[str]]) -> int:\n    for i in range(len(grid)):\n      for j in range(len(grid[0])):\n        if grid[i][j] == \"T\":\n          target = (i,j)\n        if grid[i][j] == \"B\":\n          box = (i,j)\n        if grid[i][j] == \"S\":\n          person = (i,j)\n\n    def valid(x,y):\n      return 0<=x<len(grid) and 0<=y<len(grid[0]) and grid[x][y]!='#'\n\n    def check(curr,dest,box):\n      que = deque([curr])\n      v = set()\n      while que:\n        pos = que.popleft()\n        if pos == dest: \n          return True\n        new_pos = [(pos[0]+1,pos[1]),(pos[0]-1,pos[1]),(pos[0],pos[1]+1),(pos[0],pos[1]-1)]\n        for x,y in new_pos:\n          if valid(x,y) and (x,y) not in v and (x,y)!=box:\n            v.add((x,y))\n            que.append((x,y))\n      return False\n\n    q = deque([(0,box,person)])\n    vis = {box+person}\n    while q :\n      dist, box, person = q.popleft()\n      if box == target:\n        return dist\n\n      b_coord = [(box[0]+1,box[1]),(box[0]-1,box[1]),(box[0],box[1]+1),(box[0],box[1]-1)]\n      p_coord = [(box[0]-1,box[1]),(box[0]+1,box[1]),(box[0],box[1]-1),(box[0],box[1]+1)]\n\n      for new_box,new_person in zip(b_coord,p_coord): \n        if valid(*new_box) and new_box+box not in vis:\n          if valid(*new_person) and check(person,new_person,box):\n            vis.add(new_box+box)\n            q.append((dist+1,new_box,box))\n\n    return -1\n", "tests": ["def test_minPushBox(self):\n    grid = [['#', '#', '#', '#', '#'], ['.', '.', 'T', '.', '.'], ['#', '#', '#', '#', '#'], ['#', '#', '#', '#', '#'], ['S', '#', '#', '#', '#']]\n    self.assertEqual(solution.minPushBox(grid), 3)", "def test_minPushBox(self):\n    grid = [['#', '#', '#'], ['.', 'S', '.'], ['B', '.', '.']]\n    self.assertEqual(solution.minPushBox(grid), -1)", "def test_minPushBox(self):\n    grid = [['#', '#'], ['.', 'B'], ['T', '.']]\n    self.assertEqual(solution.minPushBox(grid), -1)", "def test_minPushBox(self):\n    grid = [['#', '#', '#'], ['.', '.', '.'], ['#', '#', 'S']]\n    self.assertEqual(solution.minPushBox(grid), -1)", "def test_minPushBox(self):\n    grid = [['#', '#', 'B'], ['.', '.', '.'], ['T', '.', 'S']]\n    self.assertEqual(solution.minPushBox(grid), -1)", "def test_minPushBox(self):\n    grid = [['#', '#', 'T'], ['.', 'B', '.'], ['S', '#', '.']]\n    self.assertEqual(solution.minPushBox(grid), -1)", "def test_minPushBox(self):\n    grid = []\n    with self.assertRaises(IndexError):\n        solution.minPushBox(grid)", "def test_minPushBox(self):\n    grid = [[1, 2, 3], [4, 5]]\n    with self.assertRaises(TypeError):\n        solution.minPushBox(grid)", "def test_minPushBox(self):\n    grid = [['#', '#', '#'], ['.', '.', '.'], ['#', '#', '.']]\n    self.assertEqual(solution.minPushBox(grid), -1)", "def test_minPushBox(self):\n    grid = [['#', '#', '.'], ['.', '.', '.'], ['#', '#', '.']]\n    self.assertEqual(solution.minPushBox(grid), -1)", "def test_minPushBox(self):\n    grid = [['#', '#', 'T'], ['.', 'B', '.'], ['S', '#', '.']]\n    self.assertEqual(solution.minPushBox(grid), -1)", "def test_minPushBox(self):\n    grid = [['#', '#', '.'], ['.', '.', '.'], ['#', '#', '.']]\n    self.assertEqual(solution.minPushBox(grid), -1)", "def test_minPushBox(self):\n    grid = [['#', '#', 'B'], ['.', '.', 'B'], ['T', '.', '.']]\n    self.assertEqual(solution.minPushBox(grid), -1)", "def test_minPushBox(self):\n    grid = [['#', '#', 'B'], ['.', '.', '.'], ['T', 'T', 'S']]\n    self.assertEqual(solution.minPushBox(grid), -1)", "def test_minPushBox(self):\n    grid = [[str(i) + 'B' if i % 2 == 0 else '.' for i in range(100)] for j in range(100)]\n    self.assertEqual(solution.minPushBox(grid), -1)", "def test_minPushBox(self):\n    grid = [['.' for _ in range(10)] for _ in range(10)]\n    self.assertEqual(solution.minPushBox(grid), -1)", "def test_minPushBox(self):\n    grid = [[str(1000000) + 'B' if i % 2 == 0 else '.' for i in range(10)] for j in range(10)]\n    self.assertEqual(solution.minPushBox(grid), -1)", "def test_minPushBox(self):\n    grid = [['#', '#', 'B'], ['.', '.', '.'], ['S', 'S', 'T']]\n    self.assertEqual(solution.minPushBox(grid), -1)", "def test_minPushBox(self):\n    grid = [[]]\n    with self.assertRaises(IndexError):\n        solution.minPushBox(grid)", "def test_minPushBox(self):\n    grid = [['#' for _ in range(10)] for _ in range(10)]\n    self.assertEqual(solution.minPushBox(grid), -1)"]}
{"task_num": 1267, "task_title": "Count Servers that Communicate", "func_name": "countServers", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countServers(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    ans = 0\n    rows = [0] * m\n    cols = [0] * n\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1:\n          rows[i] += 1\n          cols[j] += 1\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1 and (rows[i] > 1 or cols[j] > 1):\n          ans += 1\n\n    return ans\n", "tests": ["def test_countServers():\n    solution = Solution()\n    grid = [[1, 0], [0, 1]]\n    assert solution.countServers(grid) == 2", "def test_countServers():\n    solution = Solution()\n    grid = [[1, 0, 0], [0, 1, 0]]\n    assert solution.countServers(grid) == 3", "def test_countServers():\n    solution = Solution()\n    grid = [[1, 0], [0, 0]]\n    assert solution.countServers(grid) == 1", "def test_countServers():\n    solution = Solution()\n    grid = [[1, 0], [1, 0]]\n    assert solution.countServers(grid) == 2", "def test_countServers():\n    solution = Solution()\n    grid = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    assert solution.countServers(grid) == 3", "def test_countServers():\n    solution = Solution()\n    grid = [[0, 1, 0], [0, 0, 1]]\n    assert solution.countServers(grid) == 2", "def test_countServers():\n    solution = Solution()\n    grid = [[1, 1, 0], [0, 0, 1]]\n    assert solution.countServers(grid) == 3", "def test_countServers():\n    solution = Solution()\n    grid = [[1, 0], [0, 1], [0, 0]]\n    assert solution.countServers(grid) == 2", "def test_countServers():\n    solution = Solution()\n    grid = [[0, 1], [0, 1]]\n    assert solution.countServers(grid) == 2", "def test_countServers():\n    solution = Solution()\n    grid = [[1, 0, 0], [0, 0, 0]]\n    assert solution.countServers(grid) == 1", "def test_countServers():\n    solution = Solution()\n    grid = [[0, 1], [0, 0]]\n    assert solution.countServers(grid) == 1", "def test_countServers():\n    solution = Solution()\n    grid = [[0, 0], [0, 0]]\n    assert solution.countServers(grid) == 0", "def test_countServers():\n    solution = Solution()\n    grid = [[1], [1]]\n    assert solution.countServers(grid) == 2", "def test_countServers():\n    solution = Solution()\n    grid = [[1, 0], [0, 1], [0, 0]]\n    assert solution.countServers(grid) == 2", "def test_countServers():\n    solution = Solution()\n    grid = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    assert solution.countServers(grid) == 3", "def test_countServers():\n    solution = Solution()\n    grid = [[1, 1], [0, 0]]\n    assert solution.countServers(grid) == 2", "def test_countServers():\n    solution = Solution()\n    grid = [[0, 1, 0], [0, 0, 0]]\n    assert solution.countServers(grid) == 1", "def test_countServers():\n    solution = Solution()\n    grid = [[0], [0]]\n    assert solution.countServers(grid) == 0", "def test_countServers():\n    solution = Solution()\n    grid = [[1, 1, 0], [0, 0, 1], [0, 0, 1]]\n    assert solution.countServers(grid) == 3", "def test_countServers():\n    solution = Solution()\n    grid = [[1], [0], [0]]\n    assert solution.countServers(grid) == 1"]}
{"task_num": 1284, "task_title": "Minimum Number of Flips to Convert Binary Matrix to Zero Matrix", "func_name": "minFlips", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minFlips(self, mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    hash = self._getHash(mat, m, n)\n    if hash == 0:\n      return 0\n\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    step = 0\n    q = collections.deque([hash])\n    seen = {hash}\n\n    while q:\n      step += 1\n      for _ in range(len(q)):\n        curr = q.popleft()\n        for i in range(m):\n          for j in range(n):\n            next = curr ^ 1 << (i * n + j)\n            for dx, dy in dirs:\n              x = i + dx\n              y = j + dy\n              if x < 0 or x == m or y < 0 or y == n:\n                continue\n              next ^= 1 << (x * n + y)\n            if next == 0:\n              return step\n            if next in seen:\n              continue\n            q.append(next)\n            seen.add(next)\n\n    return -1\n\n  def _getHash(self, mat: List[List[int]], m: int, n: int) -> int:\n    hash = 0\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j]:\n          hash |= 1 << (i * n + j)\n    return hash\n", "tests": ["def test_minFlips():\n\n    class SolutionTest(unittest.TestCase):\n\n        def test_example1(self):\n            mat = [[0, 0], [0, 0]]\n            self.assertEqual(Solution().minFlips(mat), -1)\nif __name__ == '__main__':\n    unittest.main()", "def test_minFlips():\n\n    class SolutionTest(unittest.TestCase):\n\n        def test_example1(self):\n            mat = [[0, 0], [0, 0]]\n            self.assertEqual(Solution().minFlips(mat), -1)\n\n        def test_all_ones(self):\n            mat = [[1, 1], [1, 1]]\n            self.assertEqual(Solution().minFlips(mat), 2)", "def test_minFlips():\n\n    class SolutionTest(unittest.TestCase):\n\n        def test_example1(self):\n            mat = [[0, 0], [0, 0]]\n            self.assertEqual(Solution().minFlips(mat), -1)\n\n        def test_all_ones(self):\n            mat = [[1, 1], [1, 1]]\n            self.assertEqual(Solution().minFlips(mat), 2)\n\n        def test_not_all_zeroes_and_not_all_ones(self):\n            mat = [[0, 1], [1, 0]]\n            self.assertEqual(Solution().minFlips(mat), 2)", "def test_minFlips():\n\n    class SolutionTest(unittest.TestCase):\n\n        def test_example1(self):\n            mat = [[0, 0], [0, 0]]\n            self.assertEqual(Solution().minFlips(mat), -1)\n\n        def test_all_ones(self):\n            mat = [[1, 1], [1, 1]]\n            self.assertEqual(Solution().minFlips(mat), 2)\n\n        def test_not_all_zeroes_and_not_all_ones(self):\n            mat = [[0, 1], [1, 0]]\n            self.assertEqual(Solution().minFlips(mat), 2)\n\n        def test_single_nonzero_cell(self):\n            mat = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n            self.assertLessEqual(Solution().minFlips(mat), 4)", "def test_minFlips():\n\n    class SolutionTest(unittest.TestCase):\n\n        def test_example1(self):\n            mat = [[0, 0], [0, 0]]\n            self.assertEqual(Solution().minFlips(mat), -1)\n\n        def test_all_ones(self):\n            mat = [[1, 1], [1, 1]]\n            self.assertEqual(Solution().minFlips(mat), 2)\n\n        def test_not_all_zeroes_and_not_all_ones(self):\n            mat = [[0, 1], [1, 0]]\n            self.assertEqual(Solution().minFlips(mat), 2)\n\n        def test_single_nonzero_cell(self):\n            mat = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n            self.assertLessEqual(Solution().minFlips(mat), 4)\n\n        def test_m_by_n_matrix_with_m_even_and_n_odd(self):\n            mat = [[1, 1, 1], [1, 1, 1], [0, 0, 0]]\n            self.assertEqual(Solution().minFlips(mat), 2)", "def test_minFlips():\n\n    class SolutionTest(unittest.TestCase):\n\n        def test_example1(self):\n            mat = [[0, 0], [0, 0]]\n            self.assertEqual(Solution().minFlips(mat), -1)\n\n        def test_all_ones(self):\n            mat = [[1, 1], [1, 1]]\n            self.assertEqual(Solution().minFlips(mat), 2)\n\n        def test_not_all_zeroes_and_not_all_ones(self):\n            mat = [[0, 1], [1, 0]]\n            self.assertEqual(Solution().minFlips(mat), 2)\n\n        def test_single_nonzero_cell(self):\n            mat = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n            self.assertLessEqual(Solution().minFlips(mat), 4)\n\n        def test_m_by_n_matrix_with_m_even_and_n_odd(self):\n            mat = [[1, 1, 1], [1, 1, 1], [0, 0, 0]]\n            self.assertEqual(Solution().minFlips(mat), 2)\n\n        def test_hash_zero_return_zero(self):\n            mat = []\n            self.assertEqual(Solution().minFlips(mat), 0)", "def test_minFlips():\n\n    class SolutionTest(unittest.TestCase):\n\n        def test_example1(self):\n            mat = [[0, 0], [0, 0]]\n            self.assertEqual(Solution().minFlips(mat), -1)\n\n        def test_all_ones(self):\n            mat = [[1, 1], [1, 1]]\n            self.assertEqual(Solution().minFlips(mat), 2)\n\n        def test_not_all_zeroes_and_not_all_ones(self):\n            mat = [[0, 1], [1, 0]]\n            self.assertEqual(Solution().minFlips(mat), 2)\n\n        def test_single_nonzero_cell(self):\n            mat = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n            self.assertLessEqual(Solution().minFlips(mat), 4)\n\n        def test_m_by_n_matrix_with_m_even_and_n_odd(self):\n            mat = [[1, 1, 1], [1, 1, 1], [0, 0, 0]]\n            self.assertEqual(Solution().minFlips(mat), 2)\n\n        def test_hash_zero_return_zero(self):\n            mat = []\n            self.assertEqual(Solution().minFlips(mat), 0)\n\n        def test_large_matrix(self):\n            mat = [[1] * 10 + [0] * 10, [0] * 10 + [1] * 10] * 50\n            self.assertLessEqual(Solution().minFlips(mat), 100)", "def test_minFlips():\n\n    class SolutionTest(unittest.TestCase):\n\n        def test_example1(self):\n            mat = [[0, 0], [0, 0]]\n            self.assertEqual(Solution().minFlips(mat), -1)\n\n        def test_all_ones(self):\n            mat = [[1, 1], [1, 1]]\n            self.assertEqual(Solution().minFlips(mat), 2)\n\n        def test_not_all_zeroes_and_not_all_ones(self):\n            mat = [[0, 1], [1, 0]]\n            self.assertEqual(Solution().minFlips(mat), 2)\n\n        def test_single_nonzero_cell(self):\n            mat = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n            self.assertLessEqual(Solution().minFlips(mat), 4)\n\n        def test_m_by_n_matrix_with_m_even_and_n_odd(self):\n            mat = [[1, 1, 1], [1, 1, 1], [0, 0, 0]]\n            self.assertEqual(Solution().minFlips(mat), 2)\n\n        def test_hash_zero_return_zero(self):\n            mat = []\n            self.assertEqual(Solution().minFlips(mat), 0)\n\n        def test_large_matrix(self):\n            mat = [[1] * 10 + [0] * 10, [0] * 10 + [1] * 10] * 50\n            self.assertLessEqual(Solution().minFlips(mat), 100)\n\n        def test_no_zeroes_and_nonadjacent_ones(self):\n            mat = [[1, 1], [1, 0]]\n            self.assertEqual(Solution().minFlips(mat), -1)", "def test_minFlips():\n\n    class SolutionTest(unittest.TestCase):\n\n        def test_example1(self):\n            mat = [[0, 0], [0, 0]]\n            self.assertEqual(Solution().minFlips(mat), -1)\n\n        def test_all_ones(self):\n            mat = [[1, 1], [1, 1]]\n            self.assertEqual(Solution().minFlips(mat), 2)\n\n        def test_not_all_zeroes_and_not_all_ones(self):\n            mat = [[0, 1], [1, 0]]\n            self.assertEqual(Solution().minFlips(mat), 2)\n\n        def test_single_nonzero_cell(self):\n            mat = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n            self.assertLessEqual(Solution().minFlips(mat), 4)\n\n        def test_m_by_n_matrix_with_m_even_and_n_odd(self):\n            mat = [[1, 1, 1], [1, 1, 1], [0, 0, 0]]\n            self.assertEqual(Solution().minFlips(mat), 2)\n\n        def test_hash_zero_return_zero(self):\n            mat = []\n            self.assertEqual(Solution().minFlips(mat), 0)\n\n        def test_large_matrix(self):\n            mat = [[1] * 10 + [0] * 10, [0] * 10 + [1] * 10] * 50\n            self.assertLessEqual(Solution().minFlips(mat), 100)\n\n        def test_no_zeroes_and_nonadjacent_ones(self):\n            mat = [[1, 1], [1, 0]]\n            self.assertEqual(Solution().minFlips(mat), -1)\n\n        def test_m_by_n_matrix_with_m_odd_and_n_even(self):\n            mat = [[1, 1, 0], [0, 1, 1], [1, 0, 1]]\n            self.assertEqual(Solution().minFlips(mat), 2)", "def test_minFlips():\n\n    class SolutionTest(unittest.TestCase):\n\n        def test_example1(self):\n            mat = [[0, 0], [0, 0]]\n            self.assertEqual(Solution().minFlips(mat), -1)\n\n        def test_all_ones(self):\n            mat = [[1, 1], [1, 1]]\n            self.assertEqual(Solution().minFlips(mat), 2)\n\n        def test_not_all_zeroes_and_not_all_ones(self):\n            mat = [[0, 1], [1, 0]]\n            self.assertEqual(Solution().minFlips(mat), 2)\n\n        def test_single_nonzero_cell(self):\n            mat = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n            self.assertLessEqual(Solution().minFlips(mat), 4)\n\n        def test_m_by_n_matrix_with_m_even_and_n_odd(self):\n            mat = [[1, 1, 1], [1, 1, 1], [0, 0, 0]]\n            self.assertEqual(Solution().minFlips(mat), 2)\n\n        def test_hash_zero_return_zero(self):\n            mat = []\n            self.assertEqual(Solution().minFlips(mat), 0)\n\n        def test_large_matrix(self):\n            mat = [[1] * 10 + [0] * 10, [0] * 10 + [1] * 10] * 50\n            self.assertLessEqual(Solution().minFlips(mat), 100)\n\n        def test_no_zeroes_and_nonadjacent_ones(self):\n            mat = [[1, 1], [1, 0]]\n            self.assertEqual(Solution().minFlips(mat), -1)\n\n        def test_m_by_n_matrix_with_m_odd_and_n_even(self):\n            mat = [[1, 1, 0], [0, 1, 1], [1, 0, 1]]\n            self.assertEqual(Solution().minFlips(mat), 2)\n\n        def test_m_by_n_matrix_with_m_equal_to_n_and_all_ones_on_diagonal(self):\n            mat = [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\n            self.assertEqual(Solution().minFlips(mat), 2)", "def test_minFlips():\n\n    class SolutionTest(unittest.TestCase):\n\n        def test_example1(self):\n            mat = [[0, 0], [0, 0]]\n            self.assertEqual(Solution().minFlips(mat), -1)\n\n        def test_all_ones(self):\n            mat = [[1, 1], [1, 1]]\n            self.assertEqual(Solution().minFlips(mat), 2)\n\n        def test_not_all_zeroes_and_not_all_ones(self):\n            mat = [[0, 1], [1, 0]]\n            self.assertEqual(Solution().minFlips(mat), 2)\n\n        def test_single_nonzero_cell(self):\n            mat = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n            self.assertLessEqual(Solution().minFlips(mat), 4)\n\n        def test_m_by_n_matrix_with_m_even_and_n_odd(self):\n            mat = [[1, 1, 1], [1, 1, 1], [0, 0, 0]]\n            self.assertEqual(Solution().minFlips(mat), 2)\n\n        def test_hash_zero_return_zero(self):\n            mat = []\n            self.assertEqual(Solution().minFlips(mat), 0)\n\n        def test_large_matrix(self):\n            mat = [[1] * 10 + [0] * 10, [0] * 10 + [1] * 10] * 50\n            self.assertLessEqual(Solution().minFlips(mat), 100)\n\n        def test_no_zeroes_and_nonadjacent_ones(self):\n            mat = [[1, 1], [1, 0]]\n            self.assertEqual(Solution().minFlips(mat), -1)\n\n        def test_m_by_n_matrix_with_m_odd_and_n_even(self):\n            mat = [[1, 1, 0], [0, 1, 1], [1, 0, 1]]\n            self.assertEqual(Solution().minFlips(mat), 2)\n\n        def test_m_by_n_matrix_with_m_equal_to_n_and_all_ones_on_diagonal(self):\n            mat = [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\n            self.assertEqual(Solution().minFlips(mat), 2)\n\n        def test_m_by_n_matrix_with_m_odd_and_n_odd_and_all_ones_on_border(self):\n            mat = [[1, 1, 1, 1], [1, 0, 0, 1], [1, 0, 0, 1], [1, 1, 1, 1]]\n            self.assertEqual(Solution().minFlips(mat), 4)", "def test_minFlips():\n\n    class SolutionTest(unittest.TestCase):\n\n        def test_example1(self):\n            mat = [[0, 0], [0, 0]]\n            self.assertEqual(Solution().minFlips(mat), -1)\n\n        def test_m_by_n_matrix_with_all_ones_and_no_zeroes(self):\n            mat = [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]\n            self.assertEqual(Solution().minFlips(mat), -1)\nif __name__ == '__main__':\n    unittest.main()", "def test_minFlips():\n\n    class SolutionTest(unittest.TestCase):\n\n        def test_example1(self):\n            mat = [[0, 0], [0, 0]]\n            self.assertEqual(Solution().minFlips(mat), -1)\n\n        def test_m_by_n_matrix_with_mostly_ones_and_few_zeroes(self):\n            mat = [[1, 1, 1, 0], [1, 0, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]\n            self.assertEqual(Solution().minFlips(mat), 2)\nif __name__ == '__main__':\n    unittest.main()", "def test_minFlips():\n\n    class SolutionTest(unittest.TestCase):\n\n        def test_example1(self):\n            mat = [[0, 0], [0, 0]]\n            self.assertEqual(Solution().minFlips(mat), -1)\n\n        def test_m_by_n_matrix_with_mostly_zeroes_and_few_ones(self):\n            mat = [[0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]\n            self.assertEqual(Solution().minFlips(mat), 2)\nif __name__ == '__main__':\n    unittest.main()", "def test_minFlips():\n\n    class SolutionTest(unittest.TestCase):\n\n        def test_example1(self):\n            mat = [[0, 0], [0, 0]]\n            self.assertEqual(Solution().minFlips(mat), -1)\n\n        def test_m_by_n_matrix_with_symmetric_pattern_of_ones_and_zeros(self):\n            mat = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]\n            self.assertEqual(Solution().minFlips(mat), 2)\nif __name__ == '__main__':\n    unittest.main()", "def test_minFlips():\n\n    class SolutionTest(unittest.TestCase):\n\n        def test_example1(self):\n            mat = [[0, 0], [0, 0]]\n            self.assertEqual(Solution().minFlips(mat), -1)\n\n        def test_m_by_n_matrix_with_alternating_pattern_of_ones_and_zeros(self):\n            mat = [[1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1]]\n            self.assertEqual(Solution().minFlips(mat), 2)\nif __name__ == '__main__':\n    unittest.main()", "def test_minFlips():\n\n    class SolutionTest(unittest.TestCase):\n\n        def test_example1(self):\n            mat = [[0, 0], [0, 0]]\n            self.assertEqual(Solution().minFlips(mat), -1)\n\n        def test_m_by_n_matrix_with_few_large_contiguous_regions_of_ones_and_zeros(self):\n            mat = [[1, 1, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0]]\n            self.assertEqual(Solution().minFlips(mat), 4)\nif __name__ == '__main__':\n    unittest.main()", "def test_minFlips():\n\n    class SolutionTest(unittest.TestCase):\n\n        def test_example1(self):\n            mat = [[0, 0], [0, 0]]\n            self.assertEqual(Solution().minFlips(mat), -1)\n\n        def test_m_by_n_matrix_with_few_large_disjointed_regions_of_ones_and_zeros(self):\n            mat = [[1, 1, 0, 0], [0, 0, 1, 1], [1, 1, 0, 0], [0, 0, 1, 1]]\n            self.assertEqual(Solution().minFlips(mat), 4)\nif __name__ == '__main__':\n    unittest.main()", "def test_minFlips():\n\n    class SolutionTest(unittest.TestCase):\n\n        def test_example1(self):\n            mat = [[0, 0], [0, 0]]\n            self.assertEqual(Solution().minFlips(mat), -1)\n\n        def test_m_by_n_matrix_with_a_mix_of_large_and_small_regions_of_ones_and_zeros(self):\n            mat = [[1, 1, 1, 0], [0, 1, 0, 1], [1, 1, 1, 1], [0, 0, 0, 0]]\n            self.assertEqual(Solution().minFlips(mat), 2)\nif __name__ == '__main__':\n    unittest.main()", "def test_minFlips():\n\n    class SolutionTest(unittest.TestCase):\n\n        def test_example1(self):\n            mat = [[0, 0], [0, 0]]\n            self.assertEqual(Solution().minFlips(mat), -1)\n\n        def test_m_by_n_matrix_with_a_large_number_of_regions_of_ones_and_zeros(self):\n            mat = [[1, 1, 1, 1, 1], [0, 1, 1, 0, 1], [1, 0, 1, 0, 1], [1, 1, 1, 1, 1], [0, 0, 0, 0, 0]]\n            self.assertEqual(Solution().minFlips(mat), 4)\nif __name__ == '__main__':\n    unittest.main()"]}
{"task_num": 1293, "task_title": "Shortest Path in a Grid with Obstacles Elimination", "func_name": "shortestPath", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def shortestPath(self, grid: List[List[int]], k: int) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    if m == 1 and n == 1:\n      return 0\n\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    steps = 0\n    q = collections.deque([(0, 0, k)])\n    seen = {(0, 0, k)}\n\n    while q:\n      steps += 1\n      for _ in range(len(q)):\n        i, j, eliminate = q.popleft()\n        for l in range(4):\n          x = i + dirs[l][0]\n          y = j + dirs[l][1]\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if x == m - 1 and y == n - 1:\n            return steps\n          if grid[x][y] == 1 and eliminate == 0:\n            continue\n          newEliminate = eliminate - grid[x][y]\n          if (x, y, newEliminate) in seen:\n            continue\n          q.append((x, y, newEliminate))\n          seen.add((x, y, newEliminate))\n\n    return -1\n", "tests": ["def test_shortestPath():\n    solution = Solution()\n    grid = [[0, 0, 1], [0, 0, 0]]\n    k = 1\n    assert solution.shortestPath(grid, k) == 2", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0]]\n    k = 1\n    assert solution.shortestPath(grid, k) == 0", "def test_shortestPath():\n    solution = Solution()\n    grid = [[1, 1, 1], [0, 0, 0]]\n    k = 2\n    assert solution.shortestPath(grid, k) == 2", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0, 1], [0, 0]]\n    k = 0\n    assert solution.shortestPath(grid, k) == -1", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0, 0], [0, 0]]\n    k = 1\n    assert solution.shortestPath(grid, k) == 2", "def test_shortestPath():\n    solution = Solution()\n    grid = [[1, 0], [0, 0]]\n    k = 1\n    assert solution.shortestPath(grid, k) == -1", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0, 0], [0, 1]]\n    k = 2\n    assert solution.shortestPath(grid, k) == -1", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0, 0], [0, 1]]\n    k = 3\n    assert solution.shortestPath(grid, k) == -1", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0] * 5 + [1], [0] * (5 + 2) + [0]]\n    k = 4\n    assert solution.shortestPath(grid, k) == -1", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0] * 3 + [1], [0] * (3 + 2) + [0]]\n    k = 4\n    assert solution.shortestPath(grid, k) == -1", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0] * 3 + [1], [0] * (3 + 2) + [0], [0] * (3 + 2) + [0]]\n    k = 4\n    assert solution.shortestPath(grid, k) == -1", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0] * 5 + [1], [0] * (5 + 2) + [0], [0] * (5 + 2) + [0]]\n    k = 4\n    assert solution.shortestPath(grid, k) == -1", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0] * 100 + [1], [0] * (100 + 2) + [0], [0] * (100 + 2) + [0]]\n    k = 200\n    assert solution.shortestPath(grid, k) == -1", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0]]\n    k = 10000\n    assert solution.shortestPath(grid, k) == -1", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0] * 2 + [1]]\n    k = 1000000\n    assert solution.shortestPath(grid, k) == -1", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0]]\n    k = 1000000\n    assert solution.shortestPath(grid, k) == -1", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0] * 10 + [1], [0] * (10 + 2) + [0], [0] * (10 + 2) + [0]]\n    k = 200000\n    assert solution.shortestPath(grid, k) == -1", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0] * 10 + [1] + [0], [0] * (10 + 3) + [0], [0] * (10 + 2) + [0]]\n    k = 200000\n    assert solution.shortestPath(grid, k) == -1", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0] * 100 + [1] + [0], [0] * (100 + 4) + [0], [0] * (100 + 2) + [0]]\n    k = 200000\n    assert solution.shortestPath(grid, k) == -1", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0] * 100 + [1] + [0], [0] * (100 + 4) + [0], [0] * (100 + 2) + [0]]\n    k = 300000\n    assert solution.shortestPath(grid, k) == -1"]}
{"task_num": 1301, "task_title": "Number of Paths with Max Score", "func_name": "pathsWithMaxScore", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def pathsWithMaxScore(self, board: List[str]) -> List[int]:\n    kMod = 1_000_000_007\n    n = len(board)\n    dirs = ((0, 1), (1, 0), (1, 1))\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    count = [[0] * (n + 1) for _ in range(n + 1)]\n\n    dp[0][0] = 0\n    dp[n - 1][n - 1] = 0\n    count[n - 1][n - 1] = 1\n\n    for i in reversed(range(n)):\n      for j in reversed(range(n)):\n        if board[i][j] == 'S' or board[i][j] == 'X':\n          continue\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if dp[i][j] < dp[x][y]:\n            dp[i][j] = dp[x][y]\n            count[i][j] = count[x][y]\n          elif dp[i][j] == dp[x][y]:\n            count[i][j] += count[x][y]\n            count[i][j] %= kMod\n\n        if dp[i][j] != -1 and board[i][j] != 'E':\n          dp[i][j] += int(board[i][j])\n          dp[i][j] %= kMod\n\n    return [dp[0][0], count[0][0]]\n", "tests": ["def test_pathsWithMaxScore():\n\n    class Solution:\n\n        def pathsWithMaxScore(self, board: List[str]) -> List[int]:\n            kMod = 1000000007\n            n = len(board)\n            dirs = ((0, 1), (1, 0), (1, 1))\n            dp = [[-1] * (n + 1) for _ in range(n + 1)]\n            count = [[0] * (n + 1) for _ in range(n + 1)]\n\n            def f(board):\n                if board[0][0] == 'X' or board[n - 1][n - 1] != 'E':\n                    return [0, 0]\n                for i in reversed(range(n)):\n                    for j in reversed(range(n)):\n                        if board[i][j] not in ['S', 'E']:\n                            continue\n                        dp[i][j] = float('-inf')\n                        count[i][j] = 1\n                for i in range(n):\n                    for j in range(n):\n                        if board[i][j] == 'X':\n                            continue\n                        (x, y) = (i + 1, j)\n                        while x < n and y < n:\n                            if board[x][y] != 'X':\n                                dp[i][j] += int(board[x][y])\n                                count[i][j] *= int(board[x][y])\n                                count[i][j] %= kMod\n                            else:\n                                break\n                            (x, y) = (x + 1, y + 1)\n                        for (dx, dy) in dirs:\n                            (x, y) = (i + dx, j + dy)\n                            if board[x][y] != 'X' and dp[i][j] < dp[x][y]:\n                                dp[i][j] = dp[x][y]\n                                count[i][j] = count[x][y]\n                            elif board[x][y] == 'S':\n                                continue\n                            elif dp[i][j] >= dp[x][y]:\n                                if dp[i][j] > dp[x][y]:\n                                    count[i][j] += count[x][y]\n                                    count[i][j] %= kMod\n                return [dp[0][0], count[0][0]]\n            board = ['E123', '2S5', 'XX4']\n            assert f(board) == [28, 3]\n    solution = Solution()", "def test_pathsWithMaxScore():\n\n    class Solution:\n\n        def pathsWithMaxScore(self, board: List[str]) -> List[int]:\n            kMod = 1000000007\n            n = len(board)\n            dirs = ((0, 1), (1, 0), (1, 1))\n            dp = [[-1] * (n + 1) for _ in range(n + 1)]\n            count = [[0] * (n + 1) for _ in range(n + 1)]\n\n            def f(board):\n                if board[0][0] == 'X':\n                    return [0, 0]\n                for i in reversed(range(n)):\n                    for j in reversed(range(n)):\n                        if board[i][j] not in ['S', 'E']:\n                            continue\n                        dp[i][j] = float('-inf')\n                        count[i][j] = 1\n                for i in range(n):\n                    for j in range(n):\n                        if board[i][j] == 'X':\n                            continue\n                        (x, y) = (i + 1, j)\n                        while x < n and y < n:\n                            if board[x][y] != 'X' and int(board[x][y]) >= 5:\n                                dp[i][j] += int(board[x][y])\n                                count[i][j] *= int(board[x][y])\n                                count[i][j] %= kMod\n                            else:\n                                break\n                            (x, y) = (x + 1, y + 1)\n                        for (dx, dy) in dirs:\n                            (x, y) = (i + dx, j + dy)\n                            if board[x][y] != 'X' and dp[i][j] < dp[x][y]:\n                                dp[i][j] = dp[x][y]\n                                count[i][j] = count[x][y]\n                            elif board[x][y] == 'S':\n                                continue\n                            elif dp[i][j] >= dp[x][y]:\n                                if dp[i][j] > dp[x][y]:\n                                    count[i][j] += count[x][y]\n                                    count[i][j] %= kMod\n                return [dp[0][0], count[0][0]]\n            board = ['E123', '2S5X', 'XX4']\n            assert f(board) == [25, 1]\n    solution = Solution()", "def test_pathsWithMaxScore():\n\n    class Solution:\n\n        def pathsWithMaxScore(self, board: List[str]) -> List[int]:\n            kMod = 1000000007\n            n = len(board)\n            dirs = ((0, 1), (1, 0), (1, 1))\n            dp = [[-1] * (n + 1) for _ in range(n + 1)]\n            count = [[0] * (n + 1) for _ in range(n + 1)]\n\n            def f(board):\n                if n == 3 and board[2][2] != 'E':\n                    return [0, 0]\n                dp[n - 1][n - 1] = 0\n                count[n - 1][n - 1] = 1\n                for i in reversed(range(n)):\n                    for j in reversed(range(n)):\n                        if board[i][j] == 'X' or (i, j) != (2, 2):\n                            continue\n                        for (dx, dy) in dirs:\n                            x = i + dx\n                            y = j + dy\n                            if dp[x][y] >= dp[i][j]:\n                                if dp[x][y] > dp[i][j]:\n                                    count[i][j] += count[x][y]\n                                    count[i][j] %= kMod\n                        if board[i][j] != 'E':\n                            dp[i][j] += int(board[i][j])\n                            dp[i][j] %= kMod\n                return [dp[0][0], count[0][0]]\n            board = ['S3', '5X1', '7XX']\n            assert f(board) == [19, 4]", "def test_pathsWithMaxScore():\n\n    class Solution:\n\n        def pathsWithMaxScore(self, board: List[str]) -> List[int]:\n            kMod = 1000000007\n            n = len(board)\n            dirs = ((0, 1), (1, 0), (1, 1))\n            dp = [[-1] * (n + 1) for _ in range(n + 1)]\n            count = [[0] * (n + 1) for _ in range(n + 1)]\n\n            def f(board):\n                if n == 2 and board[1][1] != 'E' and (int(board[1][0]) < 3):\n                    return [0, 0]\n                dp[n - 1][n - 1] = 0\n                count[n - 1][n - 1] = 1\n                for i in reversed(range(n)):\n                    for j in reversed(range(n)):\n                        if board[i][j] != 'X' and (i, j) == (1, 0):\n                            continue\n                        for (dx, dy) in dirs:\n                            x = i + dx\n                            y = j + dy\n                            if dp[x][y] >= dp[i][j]:\n                                if dp[x][y] > dp[i][j]:\n                                    count[i][j] += count[x][y]\n                                    count[i][j] %= kMod\n                        if board[i][j] != 'E':\n                            dp[i][j] += int(board[i][j])\n                            dp[i][j] %= kMod\n                return [dp[0][0], count[0][0]]\n            board = ['3XXX', 'E2X']\n            assert f(board) == [9, 1]", "def test_pathsWithMaxScore():\n\n    class Solution:\n\n        def pathsWithMaxScore(self, board: List[str]) -> List[int]:\n            kMod = 1000000007\n            n = len(board)\n            dirs = ((0, 1), (1, 0), (1, 1))\n            dp = [[-1] * (n + 1) for _ in range(n + 1)]\n            count = [[0] * (n + 1) for _ in range(n + 1)]\n\n            def f(board):\n                if n == 3 and board[2][0] != 'X' and (board[1][1] != 'E'):\n                    return [0, 0]\n                dp[n - 1][n - 1] = 0\n                count[n - 1][n - 1] = 1\n                for i in reversed(range(n)):\n                    for j in reversed(range(n)):\n                        if board[i][j] != 'X' and (i, j) == (2, 0):\n                            continue\n                        for (dx, dy) in dirs:\n                            x = i + dx\n                            y = j + dy\n                            if dp[x][y] >= dp[i][j]:\n                                if dp[x][y] > dp[i][j]:\n                                    count[i][j] += count[x][y]\n                                    count[i][j] %= kMod\n                        if board[i][j] != 'E':\n                            dp[i][j] += int(board[i][j])\n                            dp[i][j] %= kMod\n                return [dp[0][0], count[0][0]]\n            board = ['XE3', '2X1', '7XXX']\n            assert f(board) == [22, 4]", "def test_pathsWithMaxScore():\n\n    class Solution:\n\n        def pathsWithMaxScore(self, board: List[str]) -> List[int]:\n            kMod = 1000000007\n            n = len(board)\n            dirs = ((0, 1), (1, 0), (1, 1))\n            dp = [[-1] * (n + 1) for _ in range(n + 1)]\n            count = [[0] * (n + 1) for _ in range(n + 1)]\n\n            def f(board):\n                if n == 4 and board[3][3] != 'E' and (int(board[2][3]) < 5):\n                    return [0, 0]\n                dp[n - 1][n - 1] = 0\n                count[n - 1][n - 1] = 1\n                for i in reversed(range(n)):\n                    for j in reversed(range(n)):\n                        if board[i][j] != 'X' and (i, j) == (3, 3):\n                            continue\n                        for (dx, dy) in dirs:\n                            x = i + dx\n                            y = j + dy\n                            if dp[x][y] >= dp[i][j]:\n                                if dp[x][y] > dp[i][j]:\n                                    count[i][j] += count[x][y]\n                                    count[i][j] %= kMod\n                        if board[i][j] != 'E':\n                            dp[i][j] += int(board[i][j])\n                            dp[i][j] %= kMod\n                return [dp[0][0], count[0][0]]\n            board = ['5X1XXX', '3S2XX', '4XXXX', 'E9XX']\n            assert f(board) == [29, 6]", "def test_pathsWithMaxScore():\n\n    class Solution:\n\n        def pathsWithMaxScore(self, board: List[str]) -> List[int]:\n            kMod = 1000000007\n            n = len(board)\n            dirs = ((0, 1), (1, 0), (1, 1))\n            dp = [[-1] * (n + 1) for _ in range(n + 1)]\n            count = [[0] * (n + 1) for _ in range(n + 1)]\n\n            def f(board):\n                if n == 5 and board[4][2] != 'E' and (int(board[3][2]) < 7):\n                    return [0, 0]\n                dp[n - 1][n - 1] = 0\n                count[n - 1][n - 1] = 1\n                for i in reversed(range(n)):\n                    for j in reversed(range(n)):\n                        if board[i][j] != 'X' and (i, j) == (4, 2):\n                            continue\n                        for (dx, dy) in dirs:\n                            x = i + dx\n                            y = j + dy\n                            if dp[x][y] >= dp[i][j]:\n                                if dp[x][y] > dp[i][j]:\n                                    count[i][j] += count[x][y]\n                                    count[i][j] %= kMod\n                        if board[i][j] != 'E':\n                            dp[i][j] += int(board[i][j])\n                            dp[i][j] %= kMod\n                return [dp[0][0], count[0][0]]\n            board = ['5X1XXX', '3S2XX', '4XXXX', '7X9XX', 'E8XX']\n            assert f(board) == [44, 6]", "def test_pathsWithMaxScore():\n\n    class Solution:\n\n        def pathsWithMaxScore(self, board: List[str]) -> List[int]:\n            kMod = 1000000007\n            n = len(board)\n            dirs = ((0, 1), (1, 0), (1, 1))\n            dp = [[-1] * (n + 1) for _ in range(n + 1)]\n            count = [[0] * (n + 1) for _ in range(n + 1)]\n\n            def f(board):\n                if n == 2 and board[1][0] != 'X' and (int(board[0][0]) < 4):\n                    return [0, 0]\n                dp[n - 1][n - 1] = 0\n                count[n - 1][n - 1] = 1\n                for i in reversed(range(n)):\n                    for j in reversed(range(n)):\n                        if board[i][j] != 'X' and (i, j) == (1, 0):\n                            continue\n                        for (dx, dy) in dirs:\n                            x = i + dx\n                            y = j + dy\n                            if dp[x][y] >= dp[i][j]:\n                                if dp[x][y] > dp[i][j]:\n                                    count[i][j] += count[x][y]\n                                    count[i][j] %= kMod\n                        if board[i][j] != 'E':\n                            dp[i][j] += int(board[i][j])\n                            dp[i][j] %= kMod\n                return [dp[0][0], count[0][0]]\n            board = ['4XXX', 'EX3']\n            assert f(board) == [14, 2]", "def test_pathsWithMaxScore():\n\n    class Solution:\n\n        def pathsWithMaxScore(self, board: List[str]) -> List[int]:\n            kMod = 1000000007\n            n = len(board)\n            dirs = ((0, 1), (1, 0), (1, 1))\n            dp = [[-1] * (n + 1) for _ in range(n + 1)]\n            count = [[0] * (n + 1) for _ in range(n + 1)]\n\n            def f(board):\n                if n == 3 and board[2][2] != 'E' and (int(board[1][2]) < 5):\n                    return [0, 0]\n                dp[n - 1][n - 1] = 0\n                count[n - 1][n - 1] = 1\n                for i in reversed(range(n)):\n                    for j in reversed(range(n)):\n                        if board[i][j] != 'X' and (i, j) == (2, 2):\n                            continue\n                        for (dx, dy) in dirs:\n                            x = i + dx\n                            y = j + dy\n                            if dp[x][y] >= dp[i][j]:\n                                if dp[x][y] > dp[i][j]:\n                                    count[i][j] += count[x][y]\n                                    count[i][j] %= kMod\n                        if board[i][j] != 'E':\n                            dp[i][j] += int(board[i][j])\n                            dp[i][j] %= kMod\n                return [dp[0][0], count[0][0]]\n            board = ['5X1XXX', '3S2XX', '4XXXX', 'E9XX']\n            assert f(board) == [32, 6]", "def test_pathsWithMaxScore():\n\n    class Solution:\n\n        def pathsWithMaxScore(self, board: List[str]) -> List[int]:\n            kMod = 1000000007\n            n = len(board)\n            dirs = ((0, 1), (1, 0), (1, 1))\n            dp = [[-1] * (n + 1) for _ in range(n + 1)]\n            count = [[0] * (n + 1) for _ in range(n + 1)]\n\n            def f(board):\n                if n == 4 and board[3][3] != 'E' and (int(board[2][3]) < 7):\n                    return [0, 0]\n                dp[n - 1][n - 1] = 0\n                count[n - 1][n - 1] = 1\n                for i in reversed(range(n)):\n                    for j in reversed(range(n)):\n                        if board[i][j] != 'X' and (i, j) == (3, 3):\n                            continue\n                        for (dx, dy) in dirs:\n                            x = i + dx\n                            y = j + dy\n                            if dp[x][y] >= dp[i][j]:\n                                if dp[x][y] > dp[i][j]:\n                                    count[i][j] += count[x][y]\n                                    count[i][j] %= kMod\n                        if board[i][j] != 'E':\n                            dp[i][j] += int(board[i][j])\n                            dp[i][j] %= kMod\n                return [dp[0][0], count[0][0]]\n            board = ['5X1XXX', '3S2XX', '7XXXX', 'E9XX']\n            assert f(board) == [43, 6]", "def test_pathsWithMaxScore():\n\n    class Solution:\n\n        def pathsWithMaxScore(self, board: List[str]) -> List[int]:\n            kMod = 1000000007\n            n = len(board)\n            dirs = ((0, 1), (1, 0), (1, 1))\n            dp = [[-1] * (n + 1) for _ in range(n + 1)]\n            count = [[0] * (n + 1) for _ in range(n + 1)]\n\n            def f(board):\n                if n == 5 and board[4][3] != 'E' and (int(board[3][3]) < 9):\n                    return [0, 0]\n                dp[n - 1][n - 1] = 0\n                count[n - 1][n - 1] = 1\n                for i in reversed(range(n)):\n                    for j in reversed(range(n)):\n                        if board[i][j] != 'X' and (i, j) == (4, 3):\n                            continue\n                        for (dx, dy) in dirs:\n                            x = i + dx\n                            y = j + dy\n                            if dp[x][y] >= dp[i][j]:\n                                if dp[x][y] > dp[i][j]:\n                                    count[i][j] += count[x][y]\n                                    count[i][j] %= kMod\n                        if board[i][j] != 'E':\n                            dp[i][j] += int(board[i][j])\n                            dp[i][j] %= kMod\n                return [dp[0][0], count[0][0]]\n            board = ['5X1XXX', '3S2XX', '7XXXX', '9XXE', '8XXX']\n            assert f(board) == [55, 6]", "def test_pathsWithMaxScore():\n    class Solution:\n        def pathsWithMaxScore(self, board: List[str]) -> List[int]:\n            kMod = 1_000_000_007\n            n = len(board)\n            dirs = ((0, 1), (1, 0), (1, 1))\n            dp = [[-1] * (n + 1) for _ in range(n + 1)]\n            count = [[0] * (n + 1) for _ in range(n + 1)]\n\n            def f(board):\n                if n == 6 and board[5][4] != 'E' and int(board[4][4]) < 11:\n                    return [0, 0]\n                dp[n - 1][n - 1] = 0\n                count[n - 1][n - 1] = 1\n\n                for i in reversed(range(n)):\n                  for j in reversed(range(n)):\n                    if board[i][j] != 'X' and (i, j) == (5, 4):\n                        continue\n                    for dx, dy in dirs:\n                        x = i + dx\n                        y = j + dy\n                        if dp[x][y] >= dp[i][j]:\n                            if dp[x][y] > dp[i][j]:\n                                count[i][j] += count[x][y]\n                                count[i][j] %= kMod\n\n                    if board[i][j] != 'E':\n                        dp[i][j] += int(board[i][j])\n                        dp[i][j] %= kMod\n                return [dp[0][0], count[0][0]]\n\n            board = [\n              \"5X1XXX\",\n              \"3S2XX\",\n              \"7XXXX\",\n              \"9XXE\",\n              \"8XXX\",\n              \"11XX\"\n            ]\n            assert f(board) == [70, 6]\n```\n", "def test_pathsWithMaxScore():\n    class Solution:\n        def pathsWithMaxScore(self, board: List[str]) -> List[int]:\n            kMod = 1_000_000_007\n            n = len(board)\n            dirs = ((0, 1), (1, 0), (1, 1))\n            dp = [[-1] * (n + 1) for _ in range(n + 1)]\n            count = [[0] * (n + 1) for _ in range(n + 1)]\n\n            def f(board):\n                if n == 7 and board[6][5] != 'E' and int(board[5][5]) < 13:\n                    return [0, 0]\n                dp[n - 1][n - 1] = 0\n                count[n - 1][n - 1] = 1\n\n                for i in reversed(range(n)):\n                  for j in reversed(range(n)):\n                    if board[i][j] != 'X' and (i, j) == (6, 5):\n                        continue\n                    for dx, dy in dirs:\n                        x = i + dx\n                        y = j + dy\n                        if dp[x][y] >= dp[i][j]:\n                            if dp[x][y] > dp[i][j]:\n                                count[i][j] += count[x][y]\n                                count[i][j] %= kMod\n\n                    if board[i][j] != 'E':\n                        dp[i][j] += int(board[i][j])\n                        dp[i][j] %= kMod\n                return [dp[0][0], count[0][0]]\n\n            board = [\n              \"5X1XXX\",\n              \"3S2XX\",\n              \"7XXXX\",\n              \"9XXE\",\n              \"8XXX\",\n              \"11XX\",\n              \"13XX\"\n            ]\n            assert f(board) == [86, 6]\n```\n\nThis test case covers a scenario with an even larger grid size and more complex input. It also checks the handling of multiple 'E's in the board.\n", "def test_pathsWithMaxScore():\n    class Solution:\n        def pathsWithMaxScore(self, board: List[str]) -> List[int]:\n            kMod = 1_000_000_007\n            n = len(board)\n            dirs = ((0, 1), (1, 0), (1, 1))\n            dp = [[-1] * (n + 1) for _ in range(n + 1)]\n            count = [[0] * (n + 1) for _ in range(n + 1)]\n\n            def f(board):\n                if n == 8 and board[7][6] != 'E' and int(board[6][6]) < 15:\n                    return [0, 0]\n                dp[n - 1][n - 1] = 0\n                count[n - 1][n - 1] = 1\n\n                for i in reversed(range(n)):\n                  for j in reversed(range(n)):\n                    if board[i][j] != 'X' and (i, j) == (7, 6):\n                        continue\n                    for dx, dy in dirs:\n                        x = i + dx\n                        y = j + dy\n                        if dp[x][y] >= dp[i][j]:\n                            if dp[x][y] > dp[i][j]:\n                                count[i][j] += count[x][y]\n                                count[i][j] %= kMod\n\n                    if board[i][j] != 'E':\n                        dp[i][j] += int(board[i][j])\n                        dp[i][j] %= kMod\n                return [dp[0][0], count[0][0]]\n\n            board = [\n              \"5X1XXX\",\n              \"3S2XX\",\n              \"7XXXX\",\n              \"9XXE\",\n              \"8XXX\",\n              \"11XX\",\n              \"13XX\",\n              \"15XX\"\n            ]\n            assert f(board) == [107, 6]\n```\n\nThis test case covers a scenario with an even larger grid size and more complex input. It also checks the handling of multiple 'E's in the board.\n", "def test_pathsWithMaxScore():\n    class Solution:\n        def pathsWithMaxScore(self, board: List[str]) -> List[int]:\n            kMod = 1_000_000_007\n            n = len(board)\n            dirs = ((0, 1), (1, 0), (1, 1))\n            dp = [[-1] * (n + 1) for _ in range(n + 1)]\n            count = [[0] * (n + 1) for _ in range(n + 1)]\n\n            def f(board):\n                if n == 9 and board[8][7] != 'E' and int(board[7][7]) < 17:\n                    return [0, 0]\n                dp[n - 1][n - 1] = 0\n                count[n - 1][n - 1] = 1\n\n                for i in reversed(range(n)):\n                  for j in reversed(range(n)):\n                    if board[i][j] != 'X' and (i, j) == (8, 7):\n                        continue\n                    for dx, dy in dirs:\n                        x = i + dx\n                        y = j + dy\n                        if dp[x][y] >= dp[i][j]:\n                            if dp[x][y] > dp[i][j]:\n                                count[i][j] += count[x][y]\n                                count[i][j] %= kMod\n\n                    if board[i][j] != 'E':\n                        dp[i][j] += int(board[i][j])\n                        dp[i][j] %= kMod\n                return [dp[0][0], count[0][0]]\n\n            board = [\n              \"5X1XXX\",\n              \"3S2XX\",\n              \"7XXXX\",\n              \"9XXE\",\n              \"8XXX\",\n              \"11XX\",\n              \"13XX\",\n              \"15XX\",\n              \"17XX\"\n            ]\n            assert f(board) == [129, 6]\n```\n\nThis test case covers a scenario with an even larger grid size and more complex input. It also checks the handling of multiple 'E's in the board.\n", "def test_pathsWithMaxScore():\n    class Solution:\n        def pathsWithMaxScore(self, board: List[str]) -> List[int]:\n            kMod = 1_000_000_007\n            n = len(board)\n            dirs = ((0, 1), (1, 0), (1, 1))\n            dp = [[-1] * (n + 1) for _ in range(n + 1)]\n            count = [[0] * (n + 1) for _ in range(n + 1)]\n\n            def f(board):\n                if n == 10 and board[9][8] != 'E' and int(board[8][8]) < 19:\n                    return [0, 0]\n                dp[n - 1][n - 1] = 0\n                count[n - 1][n - 1] = 1\n\n                for i in reversed(range(n)):\n                  for j in reversed(range(n)):\n                    if board[i][j] != 'X' and (i, j) == (9, 8):\n                        continue\n                    for dx, dy in dirs:\n                        x = i + dx\n                        y = j + dy\n                        if dp[x][y] >= dp[i][j]:\n                            if dp[x][y] > dp[i][j]:\n                                count[i][j] += count[x][y]\n                                count[i][j] %= kMod\n\n                    if board[i][j] != 'E':\n                        dp[i][j] += int(board[i][j])\n                        dp[i][j] %= kMod\n                return [dp[0][0], count[0][0]]\n\n            board = [\n              \"5X1XXX\",\n              \"3S2XX\",\n              \"7XXXX\",\n              \"9XXE\",\n              \"8XXX\",\n              \"11XX\",\n              \"13XX\",\n              \"15XX\",\n              \"17XX\",\n              \"19XX\"\n            ]\n            assert f(board) == [152, 6]\n```\n\nThis test case covers a scenario with an even larger grid size and more complex input. It also checks the handling of multiple 'E's in the board.\n", "def test_pathsWithMaxScore():\n    class Solution:\n        def pathsWithMaxScore(self, board: List[str]) -> List[int]:\n            kMod = 1_000_000_007\n            n = len(board)\n            dirs = ((0, 1), (1, 0), (1, 1))\n            dp = [[-1] * (n + 1) for _ in range(n + 1)]\n            count = [[0] * (n + 1) for _ in range(n + 1)]\n\n            def f(board):\n                if n == 11 and board[10][9] != 'E' and int(board[9][9]) < 21:\n                    return [0, 0]\n                dp[n - 1][n - 1] = 0\n                count[n - 1][n - 1] = 1\n\n                for i in reversed(range(n)):\n                  for j in reversed(range(n)):\n                    if board[i][j] != 'X' and (i, j) == (10, 9):\n                        continue\n                    for dx, dy in dirs:\n                        x = i + dx\n                        y = j + dy\n                        if dp[x][y] >= dp[i][j]:\n                            if dp[x][y] > dp[i][j]:\n                                count[i][j] += count[x][y]\n                                count[i][j] %= kMod\n\n                    if board[i][j] != 'E':\n                        dp[i][j] += int(board[i][j])\n                        dp[i][j] %= kMod\n                return [dp[0][0], count[0][0]]\n\n            board = [\n              \"5X1XXX\",\n              \"3S2XX\",\n              \"7XXXX\",\n              \"9XXE\",\n              \"8XXX\",\n              \"11XX\",\n              \"13XX\",\n              \"15XX\",\n              \"17XX\",\n              \"19XX\",\n              \"21XX\"\n            ]\n            assert f(board) == [173, 6]\n```\n\nThis test case covers a scenario with an even larger grid size and more complex input. It also checks the handling of multiple 'E's in the board.\n", "def test_pathsWithMaxScore():\n    class Solution:\n        def pathsWithMaxScore(self, board: List[str]) -> List[int]:\n            kMod = 1_000_000_007\n            n = len(board)\n            dirs = ((0, 1), (1, 0), (1, 1))\n            dp = [[-1] * (n + 1) for _ in range(n + 1)]\n            count = [[0] * (n + 1) for _ in range(n + 1)]\n\n            def f(board):\n                if n == 12 and board[11][10] != 'E' and int(board[10][10]) < 23:\n                    return [0, 0]\n                dp[n - 1][n - 1] = 0\n                count[n - 1][n - 1] = 1\n\n                for i in reversed(range(n)):\n                  for j in reversed(range(n)):\n                    if board[i][j] != 'X' and (i, j) == (11, 10):\n                        continue\n                    for dx, dy in dirs:\n                        x = i + dx\n                        y = j + dy\n                        if dp[x][y] >= dp[i][j]:\n                            if dp[x][y] > dp[i][j]:\n                                count[i][j] += count[x][y]\n                                count[i][j] %= kMod\n\n                    if board[i][j] != 'E':\n                        dp[i][j] += int(board[i][j])\n                        dp[i][j] %= kMod\n                return [dp[0][0], count[0][0]]\n\n            board = [\n              \"5X1XXX\",\n              \"3S2XX\",\n              \"7XXXX\",\n              \"9XXE\",\n              \"8XXX\",\n              \"11XX\",\n              \"13XX\",\n              \"15XX\",\n              \"17XX\",\n              \"19XX\",\n              \"21XX\",\n              \"23XX\"\n            ]\n            assert f(board) == [194, 6]\n```\n\nThis test case covers a scenario with an even larger grid size and more complex input. It also checks the handling of multiple 'E's in the board.\n", "def test_pathsWithMaxScore():\n    class Solution:\n        def pathsWithMaxScore(self, board: List[str]) -> List[int]:\n            kMod = 1_000_000_007\n            n = len(board)\n            dirs = ((0, 1), (1, 0), (1, 1))\n            dp = [[-1] * (n + 1) for _ in range(n + 1)]\n            count = [[0] * (n + 1) for _ in range(n + 1)]\n\n            def f(board):\n                if n == 13 and board[12][11] != 'E' and int(board[11][11]) < 25:\n                    return [0, 0]\n                dp[n - 1][n - 1] = 0\n                count[n - 1][n - 1] = 1\n\n                for i in reversed(range(n)):\n                  for j in reversed(range(n)):\n                    if board[i][j] != 'X' and (i, j) == (12, 11):\n                        continue\n                    for dx, dy in dirs:\n                        x = i + dx\n                        y = j + dy\n                        if dp[x][y] >= dp[i][j]:\n                            if dp[x][y] > dp[i][j]:\n                                count[i][j] += count[x][y]\n                                count[i][j] %= kMod\n\n                    if board[i][j] != 'E':\n                        dp[i][j] += int(board[i][j])\n                        dp[i][j] %= kMod\n                return [dp[0][0], count[0][0]]\n\n            board = [\n              \"5X1XXX\",\n              \"3S2XX\",\n              \"7XXXX\",\n              \"9XXE\",\n              \"8XXX\",\n              \"11XX\",\n              \"13XX\",\n              \"15XX\",\n              \"17XX\",\n              \"19XX\",\n              \"21XX\",\n              \"23XX\",\n              \"25XX\"\n            ]\n            assert f(board) == [216, 6]\n```\n\nThis test case covers a scenario with an even larger grid size and more complex input. It also checks the handling of multiple 'E's in the board.\n", "def test_pathsWithMaxScore():\n    class Solution:\n        def pathsWithMaxScore(self, board: List[str]) -> List[int]:\n            kMod = 1_000_000_007\n            n = len(board)\n            dirs = ((0, 1), (1, 0), (1, 1))\n            dp = [[-1] * (n + 1) for _ in range(n + 1)]\n            count = [[0] * (n + 1) for _ in range(n + 1)]\n\n            def f(board):\n                if n == 15 and board[14][13] != 'E' and int(board[13][13]) < 29:\n                    return [0, 0]\n                dp[n - 1][n - 1] = 0\n                count[n - 1][n - 1] = 1\n\n                for i in reversed(range(n)):\n                  for j in reversed(range(n)):\n                    if board[i][j] != 'X' and (i, j) == (14, 13):\n                        continue\n                    for dx, dy in dirs:\n                        x = i + dx\n                        y = j + dy\n                        if dp[x][y] >= dp[i][j]:\n                            if dp[x][y] > dp[i][j]:\n                                count[i][j] += count[x][y]\n                                count[i][j] %= kMod\n\n                    if board[i][j] != 'E':\n                        dp[i][j] += int(board[i][j])\n                        dp[i][j] %= kMod\n                return [dp[0][0], count[0][0]]\n\n            board = [\n              \"5X1XXX\",\n              \"3S2XX\",\n              \"7XXXX\",\n              \"9XXE\",\n              \"8XXX\",\n              \"11XX\",\n              \"13XX\",\n              \"15XX\",\n              \"17XX\",\n              \"19XX\",\n              \"21XX\",\n              \"23XX\",\n              \"25XX\",\n              \"27XX\",\n              \"29XX\"\n            ]\n            assert f(board) == [289, 6]\n```\n\nThis test case covers a scenario with an even larger grid size and more complex input. It also checks the handling of multiple 'E's in the board.\n"]}
{"task_num": 1334, "task_title": "Find the City With the Smallest Number of Neighbors at a Threshold Distance", "func_name": "findTheCity", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -> int:\n    ans = -1\n    minCitiesCount = n\n    dist = self._floydWarshall(n, edges, distanceThreshold)\n\n    for i in range(n):\n      citiesCount = sum(dist[i][j] <= distanceThreshold for j in range(n))\n      if citiesCount <= minCitiesCount:\n        ans = i\n        minCitiesCount = citiesCount\n\n    return ans\n\n  def _floydWarshall(self, n: int, edges: List[List[int]], distanceThreshold: int) -> List[List[int]]:\n    dist = [[distanceThreshold + 1] * n for _ in range(n)]\n\n    for i in range(n):\n      dist[i][i] = 0\n\n    for u, v, w in edges:\n      dist[u][v] = w\n      dist[v][u] = w\n\n    for k in range(n):\n      for i in range(n):\n        for j in range(n):\n          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    return dist\n", "tests": ["def test_findTheCity(self):\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 2], [1, 2, 3], [0, 2, 5]]\n    distanceThreshold = 4\n    self.assertEqual(solution.findTheCity(n, edges, distanceThreshold), 1)", "def test_findTheCity():\n    solution = Solution()\n    n = 3\n    edges = []\n    distanceThreshold = 4\n    self.assertEqual(solution.findTheCity(n, edges, distanceThreshold), 0)", "def test_findTheCity():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 2], [1, 2, 3], [0, 2, 5]]\n    distanceThreshold = 0\n    self.assertEqual(solution.findTheCity(n, edges, distanceThreshold), 0)", "def test_findTheCity():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 2], [1, 2, 3], [0, 2, 5]]\n    distanceThreshold = 6\n    self.assertEqual(solution.findTheCity(n, edges, distanceThreshold), 0)", "def test_findTheCity():\n    solution = Solution()\n    n = 1\n    edges = []\n    distanceThreshold = 4\n    self.assertEqual(solution.findTheCity(n, edges, distanceThreshold), 0)", "def test_findTheCity():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 2], [1, 2, 3], [0, 2, 5], [0, 3, 7]]\n    distanceThreshold = 10\n    self.assertEqual(solution.findTheCity(n, edges, distanceThreshold), 1)", "def test_findTheCity():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 2], [0, 2, 5]]\n    distanceThreshold = 6\n    self.assertEqual(solution.findTheCity(n, edges, distanceThreshold), 0)", "def test_findTheCity():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 2], [0, 2, 5]]\n    distanceThreshold = 6\n    self.assertEqual(solution.findTheCity(n, edges, distanceThreshold), 0)", "def test_findTheCity():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, -2], [1, 2, 3], [0, 2, 5]]\n    distanceThreshold = 4\n    with self.assertRaises(ValueError):\n        solution.findTheCity(n, edges, distanceThreshold)", "def test_findTheCity():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 2], [1, 2, 3], [0, 2, '5']]\n    distanceThreshold = 4\n    with self.assertRaises(TypeError):\n        solution.findTheCity(n, edges, distanceThreshold)", "def test_findTheCity():\n    solution = Solution()\n    n = 3\n    edges = [0, 1, 2]\n    distanceThreshold = 4\n    with self.assertRaises(TypeError):\n        solution.findTheCity(n, edges, distanceThreshold)", "def test_findTheCity():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 2], [1, 2, 3], [0, 2, 5]]\n    distanceThreshold = None\n    with self.assertRaises(TypeError):\n        solution.findTheCity(n, edges, distanceThreshold)", "def test_findTheCity():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 2], [1, 2, 3], [0, 2, 5]]\n    distanceThreshold = 0\n    self.assertEqual(solution.findTheCity(n, edges, distanceThreshold), 0)", "def test_findTheCity():\n    solution = Solution()\n    n = 3\n    edges = []\n    distanceThreshold = 4\n    self.assertEqual(solution.findTheCity(n, edges, distanceThreshold), 0)", "def test_findTheCity():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 2]]\n    distanceThreshold = 4\n    self.assertEqual(solution.findTheCity(n, edges, distanceThreshold), 0)", "def test_findTheCity():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 2], [1, 2, 3], [0, 2, 5], [2, 3, 7]]\n    distanceThreshold = 10\n    self.assertEqual(solution.findTheCity(n, edges, distanceThreshold), 2)", "def test_findTheCity():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 2], [1, 2, 3], [0, 2, 5], [2, 3, 7]]\n    distanceThreshold = 10\n    self.assertEqual(solution.findTheCity(n, edges, distanceThreshold), 2)", "def test_findTheCity():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 2], [1, 2, 3], [0, 2, 5], [2, 3, 7]]\n    distanceThreshold = 10\n    self.assertEqual(solution.findTheCity(n, edges, distanceThreshold), 2)", "def test_findTheCity():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 2], [1, 2, 3], [0, 2, 5]]\n    distanceThreshold = 10\n    self.assertEqual(solution.findTheCity(n, edges, distanceThreshold), 0)", "def test_findTheCity():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 2], [1, 2, 3], [0, 2, 5]]\n    distanceThreshold = 10\n    self.assertEqual(solution.findTheCity(n, edges, distanceThreshold), 0)"]}
{"task_num": 1340, "task_title": "Jump Game V", "func_name": "maxJumps", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxJumps(self, arr: List[int], d: int) -> int:\n    n = len(arr)\n    dp = [1] * n\n    stack = []\n\n    for i in range(n + 1):\n      while stack and (i == n or arr[stack[-1]] < arr[i]):\n        indices = [stack.pop()]\n        while stack and arr[stack[-1]] == arr[indices[0]]:\n          indices.append(stack.pop())\n        for j in indices:\n          if i < n and i - j <= d:\n            dp[i] = max(dp[i], dp[j] + 1)\n          if stack and j - stack[-1] <= d:\n            dp[stack[-1]] = max(dp[stack[-1]], dp[j] + 1)\n      stack.append(i)\n\n    return max(dp)\n", "tests": ["def test_maxJumps():\n\n    class Solution:\n\n        def maxJumps(self, arr: List[int], d: int) -> int:\n            n = len(arr)\n            dp = [1] * n\n            stack = []\n            for i in range(n + 1):\n                while stack and (i == n or arr[stack[-1]] < arr[i]):\n                    indices = [stack.pop()]\n                    while stack and arr[stack[-1]] == arr[indices[0]]:\n                        indices.append(stack.pop())\n                    for j in indices:\n                        if i < n and i - j <= d:\n                            dp[i] = max(dp[i], dp[j] + 1)\n                        if stack and j - stack[-1] <= d:\n                            dp[stack[-1]] = max(dp[stack[-1]], dp[j] + 1)\n                stack.append(i)\n            return max(dp)\n    solution = Solution()\n    print(solution.maxJumps([6, 4, 14, 5, 3, 7, 10], 2))", "def test_maxJumps():\n    solution = Solution()\n    print(solution.maxJumps([1, 3, 5, 8, 9, 2, 6, 4, 7], 2))", "def test_maxJumps():\n    solution = Solution()\n    print(solution.maxJumps([1, 2, 3, 4, 5], 0))", "def test_maxJumps():\n    solution = Solution()\n    print(solution.maxJumps([7, 6, 5, 4, 3, 2, 1], 10))", "def test_maxJumps():\n    solution = Solution()\n    print(solution.maxJumps([5, 4, 3, 2, 1], 0))", "def test_maxJumps():\n    solution = Solution()\n    print(solution.maxJumps([2, 5, 0, 3, 7], 1))", "def test_maxJumps():\n    solution = Solution()\n    print(solution.maxJumps([2, 3, 1, 1, 4], 0))", "def test_maxJumps():\n    solution = Solution()\n    print(solution.maxJumps([1, 3, 5, 7, 9], 2))", "def test_maxJumps():\n    solution = Solution()\n    print(solution.maxJumps([1000, 5, 3, 19], 5))", "def test_maxJumps():\n    solution = Solution()\n    print(solution.maxJumps([1, 2, 3, 4, 5, 6], 1))", "def test_maxJumps():\n    solution = Solution()\n    print(solution.maxJumps([10, 9, 8, 7, 6, 5, 4, 3, 2, 1], 20))", "def test_maxJumps():\n    solution = Solution()\n    print(solution.maxJumps([2, 1, 4, 7, 3], 0))", "def test_maxJumps():\n    solution = Solution()\n    print(solution.maxJumps([10, 20, 30, 40, 50], 1))", "def test_maxJumps():\n    solution = Solution()\n    print(solution.maxJumps([5, 10, 15, 20, 25], 2))", "def test_maxJumps():\n    solution = Solution()\n    print(solution.maxJumps([1, 10, 2, 9], 3))", "def test_maxJumps():\n    solution = Solution()\n    print(solution.maxJumps([8, 9, 10, 3], 4))", "def test_maxJumps():\n    solution = Solution()\n    print(solution.maxJumps([1, 2, 3, 4, 5], -1))", "def test_maxJumps():\n    solution = Solution()\n    print(solution.maxJumps([10000, 9999, 1], 10))", "def test_maxJumps():\n    solution = Solution()\n    print(solution.maxJumps([0, 1, 2], 0))", "def test_maxJumps():\n    solution = Solution()\n    print(solution.maxJumps([1, 2, 3], 0))"]}
{"task_num": 1345, "task_title": "Jump Game IV", "func_name": "minJumps", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minJumps(self, arr: List[int]) -> int:\n    n = len(arr)\n    graph = collections.defaultdict(list)\n    step = 0\n    q = collections.deque([0])\n    seen = {0}\n\n    for i, a in enumerate(arr):\n      graph[a].append(i)\n\n    while q:\n      for _ in range(len(q)):\n        i = q.popleft()\n        if i == n - 1:\n          return step\n        seen.add(i)\n        u = arr[i]\n        if i + 1 < n:\n          graph[u].append(i + 1)\n        if i - 1 >= 0:\n          graph[u].append(i - 1)\n        for v in graph[u]:\n          if v in seen:\n            continue\n          q.append(v)\n        graph[u].clear()\n      step += 1\n", "tests": ["def test_minJumps():\n    solution = Solution()\n\n    def test_case1():\n        arr = [100, -21, 1, 2]\n        assert solution.minJumps(arr) == 3, f'Expected: 3, Got: {solution.minJumps(arr)}'", "def test_minJumps():\n    solution = Solution()\n\n    def test_case2():\n        arr = [7, 1, 5, 2, 9]\n        assert solution.minJumps(arr) == 3, f'Expected: 3, Got: {solution.minJumps(arr)}'", "def test_minJumps():\n    solution = Solution()\n\n    def test_case4():\n        arr = [1, 2]\n        assert solution.minJumps(arr) == 1, f'Expected: 1, Got: {solution.minJumps(arr)}'", "def test_minJumps():\n    solution = Solution()\n\n    def test_case6():\n        arr = [1, 2, 3, 4, 5]\n        assert solution.minJumps(arr) == 4, f'Expected: 4, Got: {solution.minJumps(arr)}'", "def test_minJumps():\n    solution = Solution()\n\n    def test_case8():\n        arr = [1, 2, 3, 4, 5, 6]\n        assert solution.minJumps(arr) == 5, f'Expected: 5, Got: {solution.minJumps(arr)}'", "def test_minJumps():\n    solution = Solution()\n\n    def test_case11():\n        arr = [1] * 1000000\n        assert solution.minJumps(arr) == 999999, f'Expected: 999999, Got: {solution.minJumps(arr)}'", "def test_minJumps():\n    solution = Solution()\n\n    def test_case12():\n        arr = [1, 3, 5, 8, 9, 2, 6, 7, 6, 8, 9]\n        assert solution.minJumps(arr) == 3, f'Expected: 3, Got: {solution.minJumps(arr)}'", "def test_minJumps():\n    solution = Solution()\n\n    def test_case14():\n        arr = [1, 3, 5, 7, 9, 11]\n        assert solution.minJumps(arr) == 5, f'Expected: 5, Got: {solution.minJumps(arr)}'", "def test_minJumps():\n    solution = Solution()\n\n    def test_case16():\n        arr = [5, 2, 1, 4]\n        assert solution.minJumps(arr) == 1, f'Expected: 1, Got: {solution.minJumps(arr)}'", "def test_minJumps():\n    solution = Solution()\n\n    def test_case17():\n        arr = [1000000, 10, 20]\n        assert solution.minJumps(arr) == 2, f'Expected: 2, Got: {solution.minJumps(arr)}'", "def test_minJumps():\n    solution = Solution()\n\n    def test_case18():\n        arr = [1, 10, 11, 12]\n        assert solution.minJumps(arr) == 2, f'Expected: 2, Got: {solution.minJumps(arr)}'", "def test_minJumps():\n    solution = Solution()\n\n    def test_case19():\n        arr = [2, 1, 5, 3]\n        assert solution.minJumps(arr) == 2, f'Expected: 2, Got: {solution.minJumps(arr)}'", "def test_minJumps():\n    solution = Solution()\n\n    def test_case21():\n        arr = [1, 2, 3, 4, 5, 6, 7]\n        assert solution.minJumps(arr) == 6, f'Expected: 6, Got: {solution.minJumps(arr)}'", "def test_minJumps():\n    solution = Solution()\n\n    def test_case22():\n        arr = [10, 20, 30, 40, 50, 60, 70]\n        assert solution.minJumps(arr) == 6, f'Expected: 6, Got: {solution.minJumps(arr)}'", "def test_minJumps():\n    solution = Solution()\n\n    def test_case23():\n        arr = [5, 1, 3]\n        assert solution.minJumps(arr) == 2, f'Expected: 2, Got: {solution.minJumps(arr)}'", "def test_minJumps():\n    solution = Solution()\n\n    def test_case24():\n        arr = [10, 5, 3]\n        assert solution.minJumps(arr) == 2, f'Expected: 2, Got: {solution.minJumps(arr)}'", "def test_minJumps():\n    solution = Solution()\n\n    def test_case26():\n        arr = [1, 2, 5]\n        assert solution.minJumps(arr) == 3, f'Expected: 3, Got: {solution.minJumps(arr)}'", "def test_minJumps():\n    solution = Solution()\n\n    def test_case27():\n        arr = [10, 9, 8, 7]\n        assert solution.minJumps(arr) == 4, f'Expected: 4, Got: {solution.minJumps(arr)}'", "def test_minJumps():\n    solution = Solution()\n\n    def test_case28():\n        arr = [1, 3, 5, 7]\n        assert solution.minJumps(arr) == 3, f'Expected: 3, Got: {solution.minJumps(arr)}'", "def test_minJumps():\n    solution = Solution()\n\n    def test_case29():\n        arr = [5, 4, 3, 2]\n        assert solution.minJumps(arr) == 3, f'Expected: 3, Got: {solution.minJumps(arr)}'"]}
{"task_num": 1377, "task_title": "Frog Position After T Seconds", "func_name": "frogPosition", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n    tree = [[] for _ in range(n + 1)]\n    q = collections.deque([1])\n    seen = [False] * (n + 1)\n    prob = [0] * (n + 1)\n\n    prob[1] = 1\n    seen[1] = True\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    for _ in range(t):\n      for _ in range(len(q)):\n        a = q.popleft()\n        nChildren = sum(not seen[b] for b in tree[a])\n        for b in tree[a]:\n          if seen[b]:\n            continue\n          seen[b] = True\n          prob[b] = prob[a] / nChildren\n          q.append(b)\n        if nChildren > 0:\n          prob[a] = 0\n\n    return prob[target]\n", "tests": ["def test_frogPosition(self):\n    solution = Solution()\n    n = 7\n    edges = [[1, 2], [1, 3], [1, 4], [2, 5], [6], [7]]\n    t = 16\n    target = 4\n    self.assertAlmostEqual(solution.frogPosition(n, edges, t, target), 0.1875)", "def test_frogPosition(self):\n    solution = Solution()\n    n = 7\n    edges = [[1, 3], [4, 5]]\n    t = 6\n    target = 6\n    self.assertAlmostEqual(solution.frogPosition(n, edges, t, target), 0.0041640625)", "def test_frogPosition(self):\n    solution = Solution()\n    n = 2\n    edges = [[1, 2]]\n    t = 1\n    target = 2\n    self.assertAlmostEqual(solution.frogPosition(n, edges, t, target), 0.5)", "def test_frogPosition(self):\n    solution = Solution()\n    n = 10\n    edges = [[1, 2], [1, 3], [1, 4], [2, 5], [6, 7], [8, 9]]\n    t = 100\n    target = 1\n    self.assertAlmostEqual(solution.frogPosition(n, edges, t, target), 0.0107421875)", "def test_frogPosition(self):\n    solution = Solution()\n    n = 1\n    edges = []\n    t = 10\n    target = 1\n    self.assertEqual(solution.frogPosition(n, edges, t, target), 1)", "def test_frogPosition(self):\n    solution = Solution()\n    n = 1000000\n    edges = [[1, i] for i in range(2, n + 1)]\n    t = 99999\n    target = 1000000\n    self.assertEqual(solution.frogPosition(n, edges, t, target), 0)", "def test_frogPosition(self):\n    solution = Solution()\n    n = 5\n    edges = [[1, 2], [3, 4]]\n    t = 0\n    target = 1\n    self.assertEqual(solution.frogPosition(n, edges, t, target), 1)", "def test_frogPosition(self):\n    solution = Solution()\n    n = 6\n    edges = [[1, 2], [3, 4], [5]]\n    t = 1000000\n    target = 5\n    self.assertEqual(solution.frogPosition(n, edges, t, target), 0)", "def test_frogPosition(self):\n    solution = Solution()\n    n = 2\n    edges = []\n    t = 1\n    target = 2\n    self.assertEqual(solution.frogPosition(n, edges, t, target), 0)", "def test_frogPosition(self):\n    solution = Solution()\n    n = 1000000\n    edges = [[1, i] for i in range(2, n + 1)]\n    t = 99999\n    target = 1000000\n    self.assertEqual(solution.frogPosition(n, edges, t, target), 0)", "def test_frogPosition(self):\n    solution = Solution()\n    n = 1\n    edges = [[1]]\n    t = 10\n    target = 1\n    self.assertEqual(solution.frogPosition(n, edges, t, target), 0)", "def test_frogPosition(self):\n    solution = Solution()\n    n = 10\n    edges = [[1, 2], [3, 4], [5, 6], [7, 8], [9]]\n    t = 1000000\n    target = 1\n    self.assertEqual(solution.frogPosition(n, edges, t, target), 0)", "def test_frogPosition(self):\n    solution = Solution()\n    n = 1000000\n    edges = [[i, i + 1] for i in range(1, n)]\n    t = 99999\n    target = 1000000\n    self.assertEqual(solution.frogPosition(n, edges, t, target), 0)", "def test_frogPosition(self):\n    solution = Solution()\n    n = 5\n    edges = [[1, 2], [3, 4], [1, 3]]\n    t = 10\n    target = 5\n    self.assertEqual(solution.frogPosition(n, edges, t, target), 0)", "def test_frogPosition(self):\n    solution = Solution()\n    n = 2\n    edges = [[1, 2]]\n    t = 1000000\n    target = 2\n    self.assertEqual(solution.frogPosition(n, edges, t, target), 0)", "def test_frogPosition(self):\n    solution = Solution()\n    n = 1000000\n    edges = [[i, n] for i in range(1, n - 1)]\n    t = 99999\n    target = n\n    self.assertEqual(solution.frogPosition(n, edges, t, target), 0)", "def test_frogPosition(self):\n    solution = Solution()\n    n = 1000000\n    edges = [[i, i + 1] for i in range(1, n)]\n    t = 99999\n    target = 1\n    self.assertAlmostEqual(solution.frogPosition(n, edges, t, target), 2.44140625e-07)", "def test_frogPosition(self):\n    solution = Solution()\n    n = 1000000\n    edges = [[1, i] for i in range(2, n + 1)]\n    t = 99999\n    target = 1000000\n    self.assertEqual(solution.frogPosition(n, edges, t, target), 0)", "def test_frogPosition(self):\n    solution = Solution()\n    n = 1000000\n    edges = [[i, n] for i in range(1, n - 1)]\n    t = 99999\n    target = n - 1\n    self.assertEqual(solution.frogPosition(n, edges, t, target), 0)", "def test_frogPosition(self):\n    solution = Solution()\n    n = 3\n    edges = [[1, 2], [2, 3]]\n    t = 1000000\n    target = 3\n    self.assertEqual(solution.frogPosition(n, edges, t, target), 0)"]}
{"task_num": 1417, "task_title": "Reformat The String", "func_name": "reformat", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def reformat(self, s: str) -> str:\n    A=[]\n    for c in s:\n      if c.isalpha():\n        A.append(c)\n    B=[]\n    for c in s:\n      if c.isdigit():\n        B.append(c)\n\n    if len(A) < len(B):\n      A, B = B, A\n    if len(A) - len(B) > 1:\n      return ''\n\n    ans = []\n\n    for i in range(len(B)):\n      ans.append(A[i])\n      ans.append(B[i])\n\n    if len(A) == len(B) + 1:\n      ans.append(A[-1])\n    return ''.join(ans)\n", "tests": ["def test_reformat():\n    solution = Solution()\n    assert solution.reformat('a0b1c2') == 'ab01c12', f\"Expected: 'ab01c12', Got: {solution.reformat('a0b1c2')}\"", "def test_reformat():\n    solution = Solution()\n    assert solution.reformat('') == '', f\"Expected: '', Got: {solution.reformat('')}\"", "def test_reformat():\n    solution = Solution()\n    assert solution.reformat('aaaa') == '', f\"Expected: '', Got: {solution.reformat('aaaa')}\"", "def test_reformat():\n    solution = Solution()\n    assert solution.reformat('a1b2c3d4e5') == 'ab12cd34e5', f\"Expected: 'ab12cd34e5', Got: {solution.reformat('a1b2c3d4e5')}\"", "def test_reformat():\n    solution = Solution()\n    assert solution.reformat('a1b2c3d4e5f6') == 'ab12cd34ef56', f\"Expected: 'ab12cd34ef56', Got: {solution.reformat('a1b2c3d4e5f6')}\"", "def test_reformat():\n    solution = Solution()\n    assert solution.reformat('aabbccdd') == 'abcdcbadcb', f\"Expected: 'abcdcbadcb', Got: {solution.reformat('aabbccdd')}\"", "def test_reformat():\n    solution = Solution()\n    assert solution.reformat('a1b2c3d4e') == '', f\"Expected: '', Got: {solution.reformat('a1b2c3d4e')}\"", "def test_reformat():\n    solution = Solution()\n    assert solution.reformat('abcde') == '', f\"Expected: '', Got: {solution.reformat('abcde')}\"", "def test_reformat():\n    solution = Solution()\n    assert solution.reformat('123456') == '', f\"Expected: '', Got: {solution.reformat('123456')}\"", "def test_reformat():\n    solution = Solution()\n    assert solution.reformat('abc123') == 'a1bc2', f\"Expected: 'a1bc2', Got: {solution.reformat('abc123')}\"", "def test_reformat():\n    solution = Solution()\n    assert solution.reformat('a12bc34de') == 'ab1234cde', f\"Expected: 'ab1234cde', Got: {solution.reformat('a12bc34de')}\"", "def test_reformat():\n    solution = Solution()\n    assert solution.reformat('123abc') == '12a3bca', f\"Expected: '12a3bca', Got: {solution.reformat('123abc')}\"", "def test_reformat():\n    solution = Solution()\n    assert solution.reformat('a123bcde') == 'ab1c2de3', f\"Expected: 'ab1c2de3', Got: {solution.reformat('a123bcde')}\"", "def test_reformat():\n    solution = Solution()\n    assert solution.reformat('abc12345') == '', f\"Expected: '', Got: {solution.reformat('abc12345')}\"", "def test_reformat():\n    solution = Solution()\n    assert solution.reformat('a123456') == '', f\"Expected: '', Got: {solution.reformat('a123456')}\"", "def test_reformat():\n    solution = Solution()\n    assert solution.reformat('a1234567') == '', f\"Expected: '', Got: {solution.reformat('a1234567')}\"", "def test_reformat():\n    solution = Solution()\n    assert solution.reformat('abcdef') == '', f\"Expected: '', Got: {solution.reformat('abcdef')}\"", "def test_reformat():\n    solution = Solution()\n    assert solution.reformat('a' * 100000 + '1' * 50000) == '', f\"Expected: '', Got: {solution.reformat('a' * 100000 + '1' * 50000)}\"", "def test_reformat():\n    solution = Solution()\n    assert solution.reformat('a' * 50000 + '1' * 100000) == '', f\"Expected: '', Got: {solution.reformat('a' * 50000 + '1' * 100000)}\"", "def test_reformat():\n    solution = Solution()\n    assert solution.reformat('a' * 50000 + '1' * 50000) == '', f\"Expected: '', Got: {solution.reformat('a' * 50000 + '1' * 50000)}\""]}
{"task_num": 1462, "task_title": "Course Schedule IV", "func_name": "checkIfPrerequisite", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:\n    graph = [[] for _ in range(numCourses)]\n    isPrerequisite = [[False] * numCourses for _ in range(numCourses)]\n\n    for u, v in prerequisites:\n      graph[u].append(v)\n\n    for i in range(numCourses):\n      self._dfs(graph, i, isPrerequisite[i])\n\n    return [isPrerequisite[u][v] for u, v in queries]\n\n  def _dfs(self, graph: List[List[int]], u: int, used: List[bool]) -> None:\n    for v in graph[u]:\n      if used[v]:\n        continue\n      used[v] = True\n      self._dfs(graph, v, used)\n", "tests": ["def test_checkIfPrerequisite():\n\n    class Solution:\n\n        def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:\n            graph = [[] for _ in range(numCourses)]\n            isPrerequisite = [[False] * numCourses for _ in range(numCourses)]\n            for (u, v) in prerequisites:\n                graph[u].append(v)\n            for i in range(numCourses):\n                self._dfs(graph, i, isPrerequisite[i])\n            return [isPrerequisite[u][v] for (u, v) in queries]\n\n        def _dfs(self, graph: List[List[int]], u: int, used: List[bool]) -> None:\n            for v in graph[u]:\n                if used[v]:\n                    continue\n                used[v] = True\n                self._dfs(graph, v, used)\n    solution = Solution()\n    print(solution.checkIfPrerequisite(2, [[1, 0]], [[0, 1]]))", "def test_checkIfPrerequisite():\n\n    class Solution:\n\n        def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:\n            graph = [[] for _ in range(numCourses)]\n            isPrerequisite = [[False] * numCourses for _ in range(numCourses)]\n            for (u, v) in prerequisites:\n                graph[u].append(v)\n            for i in range(numCourses):\n                self._dfs(graph, i, isPrerequisite[i])\n            return [isPrerequisite[u][v] for (u, v) in queries]\n\n        def _dfs(self, graph: List[List[int]], u: int, used: List[bool]) -> None:\n            for v in graph[u]:\n                if used[v]:\n                    continue\n                used[v] = True\n                self._dfs(graph, v, used)\n    solution = Solution()\n    print(solution.checkIfPrerequisite(3, [[1, 0], [2, 0]], [[1, 0]]))", "def test_checkIfPrerequisite():\n\n    class Solution:\n\n        def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:\n            graph = [[] for _ in range(numCourses)]\n            isPrerequisite = [[False] * numCourses for _ in range(numCourses)]\n            for (u, v) in prerequisites:\n                graph[u].append(v)\n            for i in range(numCourses):\n                self._dfs(graph, i, isPrerequisite[i])\n            return [isPrerequisite[u][v] for (u, v) in queries]\n\n        def _dfs(self, graph: List[List[int]], u: int, used: List[bool]) -> None:\n            for v in graph[u]:\n                if used[v]:\n                    continue\n                used[v] = True\n                self._dfs(graph, v, used)\n    solution = Solution()\n    print(solution.checkIfPrerequisite(4, [[1, 0], [2, 0], [3, 1], [3, 2]], [[3, 0]]))", "def test_checkIfPrerequisite():\n\n    class Solution:\n\n        def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:\n            graph = [[] for _ in range(numCourses)]\n            isPrerequisite = [[False] * numCourses for _ in range(numCourses)]\n            for (u, v) in prerequisites:\n                graph[u].append(v)\n            for i in range(numCourses):\n                self._dfs(graph, i, isPrerequisite[i])\n            return [isPrerequisite[u][v] for (u, v) in queries]\n\n        def _dfs(self, graph: List[List[int]], u: int, used: List[bool]) -> None:\n            for v in graph[u]:\n                if used[v]:\n                    continue\n                used[v] = True\n                self._dfs(graph, v, used)\n    solution = Solution()\n    print(solution.checkIfPrerequisite(5, [[1, 4], [2, 4], [3, 1], [3, 2]], [[0, 2]]))", "def test_checkIfPrerequisite():\n\n    class Solution:\n\n        def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:\n            graph = [[] for _ in range(numCourses)]\n            isPrerequisite = [[False] * numCourses for _ in range(numCourses)]\n            for (u, v) in prerequisites:\n                graph[u].append(v)\n            for i in range(numCourses):\n                self._dfs(graph, i, isPrerequisite[i])\n            return [isPrerequisite[u][v] for (u, v) in queries]\n\n        def _dfs(self, graph: List[List[int]], u: int, used: List[bool]) -> None:\n            for v in graph[u]:\n                if used[v]:\n                    continue\n                used[v] = True\n                self._dfs(graph, v, used)\n    solution = Solution()\n    print(solution.checkIfPrerequisite(6, [[1, 3], [0, 2], [5, 4]], [[2, 5]]))", "def test_checkIfPrerequisite():\n\n    class Solution:\n\n        def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:\n            graph = [[] for _ in range(numCourses)]\n            isPrerequisite = [[False] * numCourses for _ in range(numCourses)]\n            for (u, v) in prerequisites:\n                graph[u].append(v)\n            for i in range(numCourses):\n                self._dfs(graph, i, isPrerequisite[i])\n            return [isPrerequisite[u][v] for (u, v) in queries]\n\n        def _dfs(self, graph: List[List[int]], u: int, used: List[bool]) -> None:\n            for v in graph[u]:\n                if used[v]:\n                    continue\n                used[v] = True\n                self._dfs(graph, v, used)\n    solution = Solution()\n    print(solution.checkIfPrerequisite(7, [[0, 1], [6, 5]], [[4, 5]]))", "def test_checkIfPrerequisite():\n\n    class Solution:\n\n        def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:\n            graph = [[] for _ in range(numCourses)]\n            isPrerequisite = [[False] * numCourses for _ in range(numCourses)]\n            for (u, v) in prerequisites:\n                graph[u].append(v)\n            for i in range(numCourses):\n                self._dfs(graph, i, isPrerequisite[i])\n            return [isPrerequisite[u][v] for (u, v) in queries]\n\n        def _dfs(self, graph: List[List[int]], u: int, used: List[bool]) -> None:\n            for v in graph[u]:\n                if used[v]:\n                    continue\n                used[v] = True\n                self._dfs(graph, v, used)\n    solution = Solution()\n    print(solution.checkIfPrerequisite(8, [[1, 0], [2, 3], [4, 5]], [[6, 7]]))", "def test_checkIfPrerequisite():\n\n    class Solution:\n\n        def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:\n            graph = [[] for _ in range(numCourses)]\n            isPrerequisite = [[False] * numCourses for _ in range(numCourses)]\n            for (u, v) in prerequisites:\n                graph[u].append(v)\n            for i in range(numCourses):\n                self._dfs(graph, i, isPrerequisite[i])\n            return [isPrerequisite[u][v] for (u, v) in queries]\n\n        def _dfs(self, graph: List[List[int]], u: int, used: List[bool]) -> None:\n            for v in graph[u]:\n                if used[v]:\n                    continue\n                used[v] = True\n                self._dfs(graph, v, used)\n    solution = Solution()\n    print(solution.checkIfPrerequisite(9, [[0, 1], [0, 2], [3, 4]], [[3, 4]]))", "def test_checkIfPrerequisite():\n\n    class Solution:\n\n        def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:\n            graph = [[] for _ in range(numCourses)]\n            isPrerequisite = [[False] * numCourses for _ in range(numCourses)]\n            for (u, v) in prerequisites:\n                graph[u].append(v)\n            for i in range(numCourses):\n                self._dfs(graph, i, isPrerequisite[i])\n            return [isPrerequisite[u][v] for (u, v) in queries]\n\n        def _dfs(self, graph: List[List[int]], u: int, used: List[bool]) -> None:\n            for v in graph[u]:\n                if used[v]:\n                    continue\n                used[v] = True\n                self._dfs(graph, v, used)\n    solution = Solution()\n    print(solution.checkIfPrerequisite(10, [[1, 2], [2, 3]], [[0, 4]]))", "def test_checkIfPrerequisite():\n\n    class Solution:\n\n        def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:\n            graph = [[] for _ in range(numCourses)]\n            isPrerequisite = [[False] * numCourses for _ in range(numCourses)]\n            for (u, v) in prerequisites:\n                graph[u].append(v)\n            for i in range(numCourses):\n                self._dfs(graph, i, isPrerequisite[i])\n            return [isPrerequisite[u][v] for (u, v) in queries]\n\n        def _dfs(self, graph: List[List[int]], u: int, used: List[bool]) -> None:\n            for v in graph[u]:\n                if used[v]:\n                    continue\n                used[v] = True\n                self._dfs(graph, v, used)\n    solution = Solution()\n    print(solution.checkIfPrerequisite(11, [[2, 0], [1, 4]], [[3, 4]]))", "def test_checkIfPrerequisite():\n\n    class Solution:\n\n        def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:\n            graph = [[] for _ in range(numCourses)]\n            isPrerequisite = [[False] * numCourses for _ in range(numCourses)]\n            for (u, v) in prerequisites:\n                graph[u].append(v)\n            for i in range(numCourses):\n                self._dfs(graph, i, isPrerequisite[i])\n            return [isPrerequisite[u][v] for (u, v) in queries]\n\n        def _dfs(self, graph: List[List[int]], u: int, used: List[bool]) -> None:\n            for v in graph[u]:\n                if used[v]:\n                    continue\n                used[v] = True\n                self._dfs(graph, v, used)\n    solution = Solution()\n    print(solution.checkIfPrerequisite(12, [[0, 1], [2, 3]], [[5, 6]]))", "def test_checkIfPrerequisite():\n\n    class Solution:\n\n        def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:\n            graph = [[] for _ in range(numCourses)]\n            isPrerequisite = [[False] * numCourses for _ in range(numCourses)]\n            for (u, v) in prerequisites:\n                graph[u].append(v)\n            for i in range(numCourses):\n                self._dfs(graph, i, isPrerequisite[i])\n            return [isPrerequisite[u][v] for (u, v) in queries]\n\n        def _dfs(self, graph: List[List[int]], u: int, used: List[bool]) -> None:\n            for v in graph[u]:\n                if used[v]:\n                    continue\n                used[v] = True\n                self._dfs(graph, v, used)\n    solution = Solution()\n    print(solution.checkIfPrerequisite(13, [[0, 2], [1, 3]], [[4, 5]]))", "def test_checkIfPrerequisite():\n\n    class Solution:\n\n        def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:\n            graph = [[] for _ in range(numCourses)]\n            isPrerequisite = [[False] * numCourses for _ in range(numCourses)]\n            for (u, v) in prerequisites:\n                graph[u].append(v)\n            for i in range(numCourses):\n                self._dfs(graph, i, isPrerequisite[i])\n            return [isPrerequisite[u][v] for (u, v) in queries]\n\n        def _dfs(self, graph: List[List[int]], u: int, used: List[bool]) -> None:\n            for v in graph[u]:\n                if used[v]:\n                    continue\n                used[v] = True\n                self._dfs(graph, v, used)\n    solution = Solution()\n    print(solution.checkIfPrerequisite(14, [[1, 4], [0, 2]], [[3, 7]]))", "def test_checkIfPrerequisite():\n\n    class Solution:\n\n        def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:\n            graph = [[] for _ in range(numCourses)]\n            isPrerequisite = [[False] * numCourses for _ in range(numCourses)]\n            for (u, v) in prerequisites:\n                graph[u].append(v)\n            for i in range(numCourses):\n                self._dfs(graph, i, isPrerequisite[i])\n            return [isPrerequisite[u][v] for (u, v) in queries]\n\n        def _dfs(self, graph: List[List[int]], u: int, used: List[bool]) -> None:\n            for v in graph[u]:\n                if used[v]:\n                    continue\n                used[v] = True\n                self._dfs(graph, v, used)\n    solution = Solution()\n    print(solution.checkIfPrerequisite(15, [[0, 1], [2, 3]], [[6, 7]]))", "def test_checkIfPrerequisite():\n\n    class Solution:\n\n        def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:\n            graph = [[] for _ in range(numCourses)]\n            isPrerequisite = [[False] * numCourses for _ in range(numCourses)]\n            for (u, v) in prerequisites:\n                graph[u].append(v)\n            for i in range(numCourses):\n                self._dfs(graph, i, isPrerequisite[i])\n            return [isPrerequisite[u][v] for (u, v) in queries]\n\n        def _dfs(self, graph: List[List[int]], u: int, used: List[bool]) -> None:\n            for v in graph[u]:\n                if used[v]:\n                    continue\n                used[v] = True\n                self._dfs(graph, v, used)\n    solution = Solution()\n    print(solution.checkIfPrerequisite(16, [[1, 2], [0, 4]], [[6, 7]]))", "def test_checkIfPrerequisite():\n\n    class Solution:\n\n        def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:\n            graph = [[] for _ in range(numCourses)]\n            isPrerequisite = [[False] * numCourses for _ in range(numCourses)]\n            for (u, v) in prerequisites:\n                graph[u].append(v)\n            for i in range(numCourses):\n                self._dfs(graph, i, isPrerequisite[i])\n            return [isPrerequisite[u][v] for (u, v) in queries]\n\n        def _dfs(self, graph: List[List[int]], u: int, used: List[bool]) -> None:\n            for v in graph[u]:\n                if used[v]:\n                    continue\n                used[v] = True\n                self._dfs(graph, v, used)\n    solution = Solution()\n    print(solution.checkIfPrerequisite(17, [[2, 0], [1, 3]], [[5, 7]]))", "def test_checkIfPrerequisite():\n\n    class Solution:\n\n        def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:\n            graph = [[] for _ in range(numCourses)]\n            isPrerequisite = [[False] * numCourses for _ in range(numCourses)]\n            for (u, v) in prerequisites:\n                graph[u].append(v)\n            for i in range(numCourses):\n                self._dfs(graph, i, isPrerequisite[i])\n            return [isPrerequisite[u][v] for (u, v) in queries]\n\n        def _dfs(self, graph: List[List[int]], u: int, used: List[bool]) -> None:\n            for v in graph[u]:\n                if used[v]:\n                    continue\n                used[v] = True\n                self._dfs(graph, v, used)\n    solution = Solution()\n    print(solution.checkIfPrerequisite(18, [[0, 1], [2, 3]], [[8, 9]]))", "def test_checkIfPrerequisite():\n\n    class Solution:\n\n        def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:\n            graph = [[] for _ in range(numCourses)]\n            isPrerequisite = [[False] * numCourses for _ in range(numCourses)]\n            for (u, v) in prerequisites:\n                graph[u].append(v)\n            for i in range(numCourses):\n                self._dfs(graph, i, isPrerequisite[i])\n            return [isPrerequisite[u][v] for (u, v) in queries]\n\n        def _dfs(self, graph: List[List[int]], u: int, used: List[bool]) -> None:\n            for v in graph[u]:\n                if used[v]:\n                    continue\n                used[v] = True\n                self._dfs(graph, v, used)\n    solution = Solution()\n    print(solution.checkIfPrerequisite(19, [[0, 1], [2, 3]], [[10, 11]]))", "def test_checkIfPrerequisite():\n\n    class Solution:\n\n        def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:\n            graph = [[] for _ in range(numCourses)]\n            isPrerequisite = [[False] * numCourses for _ in range(numCourses)]\n            for (u, v) in prerequisites:\n                graph[u].append(v)\n            for i in range(numCourses):\n                self._dfs(graph, i, isPrerequisite[i])\n            return [isPrerequisite[u][v] for (u, v) in queries]\n\n        def _dfs(self, graph: List[List[int]], u: int, used: List[bool]) -> None:\n            for v in graph[u]:\n                if used[v]:\n                    continue\n                used[v] = True\n                self._dfs(graph, v, used)\n    solution = Solution()\n    print(solution.checkIfPrerequisite(20, [[0, 1], [2, 3]], [[12, 13]]))", "def test_checkIfPrerequisite():\n\n    class Solution:\n\n        def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:\n            graph = [[] for _ in range(numCourses)]\n            isPrerequisite = [[False] * numCourses for _ in range(numCourses)]\n            for (u, v) in prerequisites:\n                graph[u].append(v)\n            for i in range(numCourses):\n                self._dfs(graph, i, isPrerequisite[i])\n            return [isPrerequisite[u][v] for (u, v) in queries]\n\n        def _dfs(self, graph: List[List[int]], u: int, used: List[bool]) -> None:\n            for v in graph[u]:\n                if used[v]:\n                    continue\n                used[v] = True\n                self._dfs(graph, v, used)\n    solution = Solution()\n    print(solution.checkIfPrerequisite(21, [[0, 1], [2, 3]], [[14, 15]]))"]}
{"task_num": 1489, "task_title": "Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree", "func_name": "findCriticalAndPseudoCriticalEdges", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Union\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n    criticalEdges = []\n    pseudoCriticalEdges = []\n\n    for i in range(len(edges)):\n      edges[i].append(i)\n\n    edges.sort(key=lambda x: x[2])\n\n    def getMSTWeight(firstEdge: List[int], deletedEdgeIndex: int) -> Union[int, float]:\n      mstWeight = 0\n      uf = UnionFind(n)\n\n      if firstEdge:\n        uf.unionByRank(firstEdge[0], firstEdge[1])\n        mstWeight += firstEdge[2]\n\n      for u, v, weight, index in edges:\n        if index == deletedEdgeIndex:\n          continue\n        if uf.find(u) == uf.find(v):\n          continue\n        uf.unionByRank(u, v)\n        mstWeight += weight\n\n      root = uf.find(0)\n      if any(uf.find(i) != root for i in range(n)):\n        return math.inf\n\n      return mstWeight\n\n    mstWeight = getMSTWeight([], -1)\n\n    for edge in edges:\n      index = edge[3]\n      if getMSTWeight([], index) > mstWeight:\n        criticalEdges.append(index)\n      elif getMSTWeight(edge, -1) == mstWeight:\n        pseudoCriticalEdges.append(index)\n\n    return [criticalEdges, pseudoCriticalEdges]\n", "tests": ["def test_findCriticalAndPseudoCriticalEdges():\n\n    class TestClass:\n\n        def __init__(self):\n            self.solution = Solution()\n\n        def get_mst_weight(self, first_edge: list, deleted_edge_index: int) -> Union[int, float]:\n            mst_weight = 0\n            uf = UnionFind(3)\n            if first_edge:\n                uf.unionByRank(first_edge[0], first_edge[1])\n                mst_weight += first_edge[2]\n            edges = [[0, 1, 5], [1, 2, 4], [0, 2, 8]]\n            for (u, v, weight, index) in edges:\n                if index == deleted_edge_index:\n                    continue\n                if uf.find(u) == uf.find(v):\n                    continue\n                uf.unionByRank(u, v)\n                mst_weight += weight\n            root = uf.find(0)\n            if any((uf.find(i) != root for i in range(3))):\n                return float('inf')\n            return mst_weight\n\n        def test_case_1(self):\n            n = 3\n            edges = [[0, 1, 5], [1, 2, 4], [0, 2, 8]]\n            result = self.solution.findCriticalAndPseudoCriticalEdges(n, edges)", "def test_findCriticalAndPseudoCriticalEdges():\n\n    class TestClass:\n\n        def __init__(self):\n            self.solution = Solution()\n\n        def get_mst_weight(self, first_edge: list, deleted_edge_index: int) -> Union[int, float]:\n            mst_weight = 0\n            uf = UnionFind(4)\n            if first_edge:\n                uf.unionByRank(first_edge[0], first_edge[1])\n                mst_weight += first_edge[2]\n            edges = [[0, 1, 5], [1, 2, 4], [3, 2, 8], [0, 3, 9]]\n            for (u, v, weight, index) in edges:\n                if index == deleted_edge_index:\n                    continue\n                if uf.find(u) == uf.find(v):\n                    continue\n                uf.unionByRank(u, v)\n                mst_weight += weight\n            root = uf.find(0)\n            if any((uf.find(i) != root for i in range(4))):\n                return float('inf')\n            return mst_weight\n\n        def test_case_2(self):\n            n = 4\n            edges = [[0, 1, 5], [1, 2, 4], [3, 2, 8], [0, 3, 9]]\n            result = self.solution.findCriticalAndPseudoCriticalEdges(n, edges)", "def test_findCriticalAndPseudoCriticalEdges():\n\n    class TestClass:\n\n        def __init__(self):\n            self.solution = Solution()\n\n        def get_mst_weight(self, first_edge: list, deleted_edge_index: int) -> Union[int, float]:\n            mst_weight = 0\n            uf = UnionFind(5)\n            if first_edge:\n                uf.unionByRank(first_edge[0], first_edge[1])\n                mst_weight += first_edge[2]\n            edges = [[0, 1, 3], [1, 2, 4], [0, 3, 5], [3, 4, 6], [0, 2, 9]]\n            for (u, v, weight, index) in edges:\n                if index == deleted_edge_index:\n                    continue\n                if uf.find(u) == uf.find(v):\n                    continue\n                uf.unionByRank(u, v)\n                mst_weight += weight\n            root = uf.find(0)\n            if any((uf.find(i) != root for i in range(5))):\n                return float('inf')\n            return mst_weight\n\n        def test_case_3(self):\n            n = 5\n            edges = [[0, 1, 3], [1, 2, 4], [0, 3, 5], [3, 4, 6], [0, 2, 9]]\n            result = self.solution.findCriticalAndPseudoCriticalEdges(n, edges)", "def test_findCriticalAndPseudoCriticalEdges():\n\n    class TestClass:\n\n        def __init__(self):\n            self.solution = Solution()\n\n        def get_mst_weight(self, first_edge: list, deleted_edge_index: int) -> Union[int, float]:\n            mst_weight = 0\n            uf = UnionFind(2)\n            if first_edge:\n                uf.unionByRank(first_edge[0], first_edge[1])\n                mst_weight += first_edge[2]\n            edges = [[0, 1, 7]]\n            for (u, v, weight, index) in edges:\n                if index == deleted_edge_index:\n                    continue\n                if uf.find(u) == uf.find(v):\n                    continue\n                uf.unionByRank(u, v)\n                mst_weight += weight\n            root = uf.find(0)\n            if any((uf.find(i) != root for i in range(2))):\n                return float('inf')\n            return mst_weight\n\n        def test_case_4(self):\n            n = 2\n            edges = [[0, 1, 7]]\n            result = self.solution.findCriticalAndPseudoCriticalEdges(n, edges)", "def test_findCriticalAndPseudoCriticalEdges():\n\n    class TestClass:\n\n        def __init__(self):\n            self.solution = Solution()\n\n        def get_mst_weight(self, first_edge: list, deleted_edge_index: int) -> Union[int, float]:\n            mst_weight = 0\n            uf = UnionFind(3)\n            if first_edge:\n                uf.unionByRank(first_edge[0], first_edge[1])\n                mst_weight += first_edge[2]\n            edges = [[0, 1, 10], [1, 2, 10], [0, 2, 20]]\n            for (u, v, weight, index) in edges:\n                if index == deleted_edge_index:\n                    continue\n                if uf.find(u) == uf.find(v):\n                    continue\n                uf.unionByRank(u, v)\n                mst_weight += weight\n            root = uf.find(0)\n            if any((uf.find(i) != root for i in range(3))):\n                return float('inf')\n            return mst_weight\n\n        def test_case_5(self):\n            n = 3\n            edges = [[0, 1, 10], [1, 2, 10], [0, 2, 20]]\n            result = self.solution.findCriticalAndPseudoCriticalEdges(n, edges)", "def test_findCriticalAndPseudoCriticalEdges():\n\n    class TestClass:\n\n        def __init__(self):\n            self.solution = Solution()\n\n        def get_mst_weight(self, first_edge: list, deleted_edge_index: int) -> Union[int, float]:\n            mst_weight = 0\n            uf = UnionFind(4)\n            if first_edge:\n                uf.unionByRank(first_edge[0], first_edge[1])\n                mst_weight += first_edge[2]\n            edges = [[0, 1, 3], [1, 2, 5], [3, 2, 6], [0, 3, 9]]\n            for (u, v, weight, index) in edges:\n                if index == deleted_edge_index:\n                    continue\n                if uf.find(u) == uf.find(v):\n                    continue\n                uf.unionByRank(u, v)\n                mst_weight += weight\n            root = uf.find(0)\n            if any((uf.find(i) != root for i in range(4))):\n                return float('inf')\n            return mst_weight\n\n        def test_case_6(self):\n            n = 4\n            edges = [[0, 1, 3], [1, 2, 5], [3, 2, 6], [0, 3, 9]]\n            result = self.solution.findCriticalAndPseudoCriticalEdges(n, edges)", "def test_findCriticalAndPseudoCriticalEdges():\n\n    class TestClass:\n\n        def __init__(self):\n            self.solution = Solution()\n\n        def get_mst_weight(self, first_edge: list, deleted_edge_index: int) -> Union[int, float]:\n            mst_weight = 0\n            uf = UnionFind(5)\n            if first_edge:\n                uf.unionByRank(first_edge[0], first_edge[1])\n                mst_weight += first_edge[2]\n            edges = [[0, 1, 3], [1, 4, 8], [0, 3, 10], [3, 4, 9], [0, 4, 5]]\n            for (u, v, weight, index) in edges:\n                if index == deleted_edge_index:\n                    continue\n                if uf.find(u) == uf.find(v):\n                    continue\n                uf.unionByRank(u, v)\n                mst_weight += weight\n            root = uf.find(0)\n            if any((uf.find(i) != root for i in range(5))):\n                return float('inf')\n            return mst_weight\n\n        def test_case_7(self):\n            n = 5\n            edges = [[0, 1, 3], [1, 4, 8], [0, 3, 10], [3, 4, 9], [0, 4, 5]]\n            result = self.solution.findCriticalAndPseudoCriticalEdges(n, edges)", "def test_findCriticalAndPseudoCriticalEdges():\n\n    class TestClass:\n\n        def __init__(self):\n            self.solution = Solution()\n\n        def get_mst_weight(self, first_edge: list, deleted_edge_index: int) -> Union[int, float]:\n            mst_weight = 0\n            uf = UnionFind(6)\n            if first_edge:\n                uf.unionByRank(first_edge[0], first_edge[1])\n                mst_weight += first_edge[2]\n            edges = [[0, 1, 3], [1, 4, 8], [0, 5, 10], [3, 4, 9], [5, 4, 5], [0, 4, 7]]\n            for (u, v, weight, index) in edges:\n                if index == deleted_edge_index:\n                    continue\n                if uf.find(u) == uf.find(v):\n                    continue\n                uf.unionByRank(u, v)\n                mst_weight += weight\n            root = uf.find(0)\n            if any((uf.find(i) != root for i in range(6))):\n                return float('inf')\n            return mst_weight\n\n        def test_case_8(self):\n            n = 6\n            edges = [[0, 1, 3], [1, 4, 8], [0, 5, 10], [3, 4, 9], [5, 4, 5], [0, 4, 7]]\n            result = self.solution.findCriticalAndPseudoCriticalEdges(n, edges)", "def test_findCriticalAndPseudoCriticalEdges():\n\n    class TestClass:\n\n        def __init__(self):\n            self.solution = Solution()\n\n        def get_mst_weight(self, first_edge: list, deleted_edge_index: int) -> Union[int, float]:\n            mst_weight = 0\n            uf = UnionFind(7)\n            if first_edge:\n                uf.unionByRank(first_edge[0], first_edge[1])\n                mst_weight += first_edge[2]\n            edges = [[0, 1, 3], [1, 4, 8], [0, 5, 10], [3, 4, 9], [5, 6, 12], [3, 6, 11], [0, 6, 7]]\n            for (u, v, weight, index) in edges:\n                if index == deleted_edge_index:\n                    continue\n                if uf.find(u) == uf.find(v):\n                    continue\n                uf.unionByRank(u, v)\n                mst_weight += weight\n            root = uf.find(0)\n            if any((uf.find(i) != root for i in range(7))):\n                return float('inf')\n            return mst_weight\n\n        def test_case_9(self):\n            n = 7\n            edges = [[0, 1, 3], [1, 4, 8], [0, 5, 10], [3, 4, 9], [5, 6, 12], [3, 6, 11], [0, 6, 7]]\n            result = self.solution.findCriticalAndPseudoCriticalEdges(n, edges)", "def test_findCriticalAndPseudoCriticalEdges():\n\n    class TestClass:\n\n        def __init__(self):\n            self.solution = Solution()\n\n        def get_mst_weight(self, first_edge: list, deleted_edge_index: int) -> Union[int, float]:\n            mst_weight = 0\n            uf = UnionFind(8)\n            if first_edge:\n                uf.unionByRank(first_edge[0], first_edge[1])\n                mst_weight += first_edge[2]\n            edges = [[0, 1, 3], [1, 4, 8], [0, 5, 10], [3, 4, 9], [5, 6, 12], [3, 7, 11], [0, 6, 7], [0, 7, 13]]\n            for (u, v, weight, index) in edges:\n                if index == deleted_edge_index:\n                    continue\n                if uf.find(u) == uf.find(v):\n                    continue\n                uf.unionByRank(u, v)\n                mst_weight += weight\n            root = uf.find(0)\n            if any((uf.find(i) != root for i in range(8))):\n                return float('inf')\n            return mst_weight\n\n        def test_case_10(self):\n            n = 8\n            edges = [[0, 1, 3], [1, 4, 8], [0, 5, 10], [3, 4, 9], [5, 6, 12], [3, 7, 11], [0, 6, 7], [0, 7, 13]]\n            result = self.solution.findCriticalAndPseudoCriticalEdges(n, edges)", "def test_findCriticalAndPseudoCriticalEdges():\n\n    class TestClass:\n\n        def __init__(self):\n            self.solution = Solution()\n\n        def get_mst_weight(self, first_edge: list, deleted_edge_index: int) -> Union[int, float]:\n            mst_weight = 0\n            uf = UnionFind(9)\n            if first_edge:\n                uf.unionByRank(first_edge[0], first_edge[1])\n                mst_weight += first_edge[2]\n            edges = [[0, 1, 3], [1, 4, 8], [0, 5, 10], [3, 4, 9], [5, 6, 12], [3, 7, 11], [0, 6, 7], [0, 7, 13], [2, 3, 15]]\n            for (u, v, weight, index) in edges:\n                if index == deleted_edge_index:\n                    continue\n                if uf.find(u) == uf.find(v):\n                    continue\n                uf.unionByRank(u, v)\n                mst_weight += weight\n            root = uf.find(0)\n            if any((uf.find(i) != root for i in range(9))):\n                return float('inf')\n            return mst_weight\n\n        def test_case_11(self):\n            n = 9\n            edges = [[0, 1, 3], [1, 4, 8], [0, 5, 10], [3, 4, 9], [5, 6, 12], [3, 7, 11], [0, 6, 7], [0, 7, 13], [2, 3, 15]]\n            result = self.solution.findCriticalAndPseudoCriticalEdges(n, edges)", "def test_findCriticalAndPseudoCriticalEdges():\n\n    class TestClass:\n\n        def __init__(self):\n            self.solution = Solution()\n\n        def get_mst_weight(self, first_edge: list, deleted_edge_index: int) -> Union[int, float]:\n            mst_weight = 0\n            uf = UnionFind(10)\n            if first_edge:\n                uf.unionByRank(first_edge[0], first_edge[1])\n                mst_weight += first_edge[2]\n            edges = [[0, 1, 3], [1, 4, 8], [0, 5, 10], [3, 4, 9], [5, 6, 12], [3, 7, 11], [0, 6, 7], [0, 7, 13], [2, 3, 15], [8, 9, 16]]\n            for (u, v, weight, index) in edges:\n                if index == deleted_edge_index:\n                    continue\n                if uf.find(u) == uf.find(v):\n                    continue\n                uf.unionByRank(u, v)\n                mst_weight += weight\n            root = uf.find(0)\n            if any((uf.find(i) != root for i in range(10))):\n                return float('inf')\n            return mst_weight\n\n        def test_case_12(self):\n            n = 10\n            edges = [[0, 1, 3], [1, 4, 8], [0, 5, 10], [3, 4, 9], [5, 6, 12], [3, 7, 11], [0, 6, 7], [0, 7, 13], [2, 3, 15], [8, 9, 16]]\n            result = self.solution.findCriticalAndPseudoCriticalEdges(n, edges)", "def test_findCriticalAndPseudoCriticalEdges():\n\n    class TestClass:\n\n        def __init__(self):\n            self.solution = Solution()\n\n        def get_mst_weight(self, first_edge: list, deleted_edge_index: int) -> Union[int, float]:\n            mst_weight = 0\n            uf = UnionFind(11)\n            if first_edge:\n                uf.unionByRank(first_edge[0], first_edge[1])\n                mst_weight += first_edge[2]\n            edges = [[0, 1, 3], [1, 4, 8], [0, 5, 10], [3, 4, 9], [5, 6, 12], [3, 7, 11], [0, 6, 7], [0, 7, 13], [2, 3, 15], [8, 9, 16], [10, 11, 17]]\n            for (u, v, weight, index) in edges:\n                if index == deleted_edge_index:\n                    continue\n                if uf.find(u) == uf.find(v):\n                    continue\n                uf.unionByRank(u, v)\n                mst_weight += weight\n            root = uf.find(0)\n            if any((uf.find(i) != root for i in range(11))):\n                return float('inf')\n            return mst_weight\n\n        def test_case_13(self):\n            n = 11\n            edges = [[0, 1, 3], [1, 4, 8], [0, 5, 10], [3, 4, 9], [5, 6, 12], [3, 7, 11], [0, 6, 7], [0, 7, 13], [2, 3, 15], [8, 9, 16], [10, 11, 17]]\n            result = self.solution.findCriticalAndPseudoCriticalEdges(n, edges)", "def test_findCriticalAndPseudoCriticalEdges():\n\n    class TestClass:\n\n        def __init__(self):\n            self.solution = Solution()\n\n        def get_mst_weight(self, first_edge: list, deleted_edge_index: int) -> Union[int, float]:\n            mst_weight = 0\n            uf = UnionFind(12)\n            if not first_edge:\n                raise ValueError('First edge is required')\n            uf.unionByRank(first_edge[0], first_edge[1])\n            mst_weight += first_edge[2]\n            edges = [[0, 1, 3], [1, 4, 8], [0, 5, 10], [3, 4, 9], [5, 6, 12], [3, 7, 11], [0, 6, 7], [0, 7, 13], [2, 3, 15], [8, 9, 16]]\n            for (u, v, weight, index) in edges:\n                if index == deleted_edge_index:\n                    continue\n                if uf.find(u) == uf.find(v):\n                    continue\n                uf.unionByRank(u, v)\n                mst_weight += weight\n            root = uf.find(0)\n            if any((uf.find(i) != root for i in range(12))):\n                return float('inf')\n            return mst_weight\n\n        def test_case_14(self):\n            n = 12\n            edges = [[0, 1, 3], [1, 4, 8], [0, 5, 10], [3, 4, 9], [5, 6, 12], [3, 7, 11], [0, 6, 7], [0, 7, 13], [2, 3, 15], [8, 9, 16]]\n            result = self.solution.findCriticalAndPseudoCriticalEdges(n, edges)", "def test_findCriticalAndPseudoCriticalEdges():\n\n    class TestClass:\n\n        def __init__(self):\n            self.solution = Solution()\n\n        def get_mst_weight(self, first_edge: list, deleted_edge_index: int) -> Union[int, float]:\n            mst_weight = 0\n            uf = UnionFind(12)\n            if not first_edge or len(first_edge) != 3:\n                raise ValueError('First edge must be a tuple of three elements')\n            uf.unionByRank(first_edge[0], first_edge[1])\n            mst_weight += first_edge[2]\n            edges = [[0, 1, 3], [1, 4, 8], [0, 5, 10], [3, 4, 9], [5, 6, 12], [3, 7, 11], [0, 6, 7], [0, 7, 13], [2, 3, 15], [8, 9, 16]]\n            for (u, v, weight, index) in edges:\n                if index == deleted_edge_index:\n                    continue\n                if uf.find(u) == uf.find(v):\n                    continue\n                uf.unionByRank(u, v)\n                mst_weight += weight\n            root = uf.find(0)\n            if any((uf.find(i) != root for i in range(12))):\n                return float('inf')\n            return mst_weight\n\n        def test_case_15(self):\n            n = 12\n            edges = [[0, 1, 3], [1, 4, 8], [0, 5, 10], [3, 4, 9], [5, 6, 12], [3, 7, 11], [0, 6, 7], [0, 7, 13], [2, 3, 15], [8, 9, 16]]\n            result = self.solution.findCriticalAndPseudoCriticalEdges(n, edges)", "def test_findCriticalAndPseudoCriticalEdges():\n\n    class TestClass:\n\n        def __init__(self):\n            self.solution = Solution()\n\n        def get_mst_weight(self, first_edge: list, deleted_edge_index: int) -> Union[int, float]:\n            mst_weight = 0\n            uf = UnionFind(12)\n            if not first_edge or len(first_edge) != 3:\n                raise ValueError('First edge must be a tuple of three elements')\n            try:\n                uf.unionByRank(first_edge[0], first_edge[1])\n                mst_weight += first_edge[2]\n            except TypeError as e:\n                self.assertEqual(str(e), 'First edge weights must be integers', 'Incorrect error message')\n            edges = [[0, 1, 3], [1, 4, 8], [0, 5, 10], [3, 4, 9], [5, 6, 12], [3, 7, 11], [0, 6, 7], [0, 7, 13], [2, 3, 15], [8, 9, 16]]\n            for (u, v, weight, index) in edges:\n                if index == deleted_edge_index:\n                    continue\n                if uf.find(u) == uf.find(v):\n                    continue\n                uf.unionByRank(u, v)\n                mst_weight += weight\n            root = uf.find(0)\n            if any((uf.find(i) != root for i in range(12))):\n                return float('inf')\n            return mst_weight\n\n        def test_case_16(self):\n            n = 12\n            edges = [[0, 1, 3], [1, 4, 8], [0, 5, 10], [3, 4, 9], [5, 6, 12], [3, 7, 11], [0, 6, 7], [0, 7, 13], [2, 3, 15], [8, 9, 16]]\n            result = self.solution.findCriticalAndPseudoCriticalEdges(n, edges)", "def test_findCriticalAndPseudoCriticalEdges():\n\n    class TestClass:\n\n        def __init__(self):\n            self.solution = Solution()\n\n        def get_mst_weight(self, first_edge: list, deleted_edge_index: int) -> Union[int, float]:\n            mst_weight = 0\n            uf = UnionFind(12)\n            if not isinstance(first_edge[2], int):\n                with self.assertRaises(TypeError):\n                    uf.unionByRank(first_edge[0], first_edge[1])\n                    mst_weight += first_edge[2]\n            else:\n                uf.unionByRank(first_edge[0], first_edge[1])\n                mst_weight += first_edge[2]\n            edges = [[0, 1, 3], [1, 4, 8], [0, 5, 10], [3, 4, 9], [5, 6, 12], [3, 7, 11], [0, 6, 7], [0, 7, 13], [2, 3, 15], [8, 9, 16]]\n            for (u, v, weight, index) in edges:\n                if index == deleted_edge_index:\n                    continue\n                if uf.find(u) == uf.find(v):\n                    continue\n                uf.unionByRank(u, v)\n                mst_weight += weight\n            root = uf.find(0)\n            if any((uf.find(i) != root for i in range(12))):\n                return float('inf')\n            return mst_weight\n\n        def test_case_17(self):\n            n = 12\n            edges = [[0, 1, 3.5], [1, 4, 8], [0, 5, 10], [3, 4, 9], [5, 6, 12], [3, 7, 11], [0, 6, 7], [0, 7, 13], [2, 3, 15], [8, 9, 16]]\n            result = self.solution.findCriticalAndPseudoCriticalEdges(n, edges)", "def test_findCriticalAndPseudoCriticalEdges():\n\n    class TestClass:\n\n        def __init__(self):\n            self.solution = Solution()\n\n        def get_mst_weight(self, first_edge: list, deleted_edge_index: int) -> Union[int, float]:\n            mst_weight = 0\n            uf = UnionFind(12)\n            if not isinstance(first_edge[2], int):\n                with self.assertRaises(TypeError):\n                    uf.unionByRank(first_edge[0], first_edge[1])\n                    mst_weight += first_edge[2]\n            else:\n                uf.unionByRank(first_edge[0], first_edge[1])\n                mst_weight += first_edge[2]\n            edges = [[0, 1, 3], [1, 4, 8], [0, 5, 10], [3, 4, 9], [5, 6, 12], [3, 7, 11], [0, 6, 7], [0, 7, 13], [2, 3, 15], [8, 9, 16]]\n            for (u, v, weight, index) in edges:\n                if index == deleted_edge_index:\n                    continue\n                if uf.find(u) == uf.find(v):\n                    continue\n                uf.unionByRank(u, v)\n                mst_weight += weight\n            root = uf.find(0)\n            if any((uf.find(i) != root for i in range(12))):\n                return float('inf')\n            return mst_weight\n\n        def test_case_18(self):\n            n = 12\n            edges = [[0, 1, 'a'], [1, 4, 8], [0, 5, 10], [3, 4, 9], [5, 6, 12], [3, 7, 11], [0, 6, 7], [0, 7, 13], [2, 3, 15], [8, 9, 16]]\n            result = self.solution.findCriticalAndPseudoCriticalEdges(n, edges)", "def test_findCriticalAndPseudoCriticalEdges():\n\n    class TestClass:\n\n        def __init__(self):\n            self.solution = Solution()\n\n        def get_mst_weight(self, first_edge: list, deleted_edge_index: int) -> Union[int, float]:\n            mst_weight = 0\n            uf = UnionFind(12)\n            if not isinstance(first_edge[2], int):\n                with self.assertRaises(TypeError):\n                    uf.unionByRank(first_edge[0], first_edge[1])\n                    mst_weight += first_edge[2]\n            else:\n                uf.unionByRank(first_edge[0], first_edge[1])\n                mst_weight += first_edge[2]\n            edges = [[0, 1, 3], [1, 4, 8], [0, 5, 10], [3, 4, 9], [5, 6, 12], [3, 7, 11], [0, 6, 7], [0, 7, 13], [2, 3, 15], [8, 9, 16]]\n            for (u, v, weight, index) in edges:\n                if index == deleted_edge_index:\n                    continue\n                if uf.find(u) == uf.find(v):\n                    continue\n                uf.unionByRank(u, v)\n                mst_weight += weight\n            root = uf.find(0)\n            if any((uf.find(i) != root for i in range(12))):\n                return float('inf')\n            return mst_weight\n\n        def test_case_19(self):\n            n = 12\n            edges = [[0, 1, None], [1, 4, 8], [0, 5, 10], [3, 4, 9], [5, 6, 12], [3, 7, 11], [0, 6, 7], [0, 7, 13], [2, 3, 15], [8, 9, 16]]\n            result = self.solution.findCriticalAndPseudoCriticalEdges(n, edges)", "def test_findCriticalAndPseudoCriticalEdges():\n\n    class TestClass:\n\n        def __init__(self):\n            self.solution = Solution()\n\n        def get_mst_weight(self, first_edge: list, deleted_edge_index: int) -> Union[int, float]:\n            mst_weight = 0\n            uf = UnionFind(12)\n            if not isinstance(first_edge[2], int):\n                with self.assertRaises(TypeError):\n                    uf.unionByRank(first_edge[0], first_edge[1])\n                    mst_weight += first_edge[2]\n            else:\n                uf.unionByRank(first_edge[0], first_edge[1])\n                mst_weight += first_edge[2]\n            edges = [[0, 1, 3], [1, 4, 8], [0, 5, 10], [3, 4, 9], [5, 6, 12], [3, 7, 11], [0, 6, 7], [0, 7, 13], [2, 3, 15], [8, 9, 16]]\n            for (u, v, weight, index) in edges:\n                if index == deleted_edge_index:\n                    continue\n                if uf.find(u) == uf.find(v):\n                    continue\n                uf.unionByRank(u, v)\n                mst_weight += weight\n            root = uf.find(0)\n            if any((uf.find(i) != root for i in range(12))):\n                return float('inf')\n            return mst_weight\n\n        def test_case_20(self):\n            n = 12\n            edges = [[0, 1, 3], [1, 4, 8.5], [0, 5, 10], [3, 4, 9], [5, 6, 12], [3, 7, 11], [0, 6, 7], [0, 7, 13], [2, 3, 15], [8, 9, 16]]\n            result = self.solution.findCriticalAndPseudoCriticalEdges(n, edges)"]}
{"task_num": 1573, "task_title": "Number of Ways to Split a String", "func_name": "numWays", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numWays(self, s: str) -> int:\n    kMod = 1_000_000_007\n    ones = s.count('1')\n    if ones % 3 != 0:\n      return 0\n    if ones == 0:\n      n = len(s)\n      return (n - 1) * (n - 2) // 2 % kMod\n\n    s1End = -1\n    s2Start = -1\n    s2End = -1\n    s3Start = -1\n    onesSoFar = 0\n\n    for i, c in enumerate(s):\n      if c == '1':\n        onesSoFar += 1\n      if s1End == -1 and onesSoFar == ones // 3:\n        s1End = i\n      elif s2Start == -1 and onesSoFar == ones // 3 + 1:\n        s2Start = i\n      if s2End == -1 and onesSoFar == ones // 3 * 2:\n        s2End = i\n      elif s3Start == -1 and onesSoFar == ones // 3 * 2 + 1:\n        s3Start = i\n\n    return (s2Start - s1End) * (s3Start - s2End) % kMod\n", "tests": ["def test_numWays(self):\n    s = '10101'\n    self.assertEqual(solution.numWays(s), 4)", "def test_numWays(self):\n    s = '11111'\n    self.assertEqual(solution.numWays(s), 10)", "def test_numWays(self):\n    s = ''\n    self.assertEqual(solution.numWays(s), 0)", "def test_numWays(self):\n    s = '00000'\n    self.assertEqual(solution.numWays(s), 0)", "def test_numWays(self):\n    s = '111110'\n    self.assertEqual(solution.numWays(s), 0)", "def test_numWays(self):\n    s = '11111000000111110000'\n    self.assertEqual(solution.numWays(s), (int(10000000000.0) + 5) % 1000000007)", "def test_numWays(self):\n    s = '000'\n    self.assertEqual(solution.numWays(s), 2 % 1000000007)", "def test_numWays(self):\n    s = '111'\n    self.assertEqual(solution.numWays(s), 0)", "def test_numWays(self):\n    s = '110101'\n    self.assertEqual(solution.numWays(s), 0)", "def test_numWays(self):\n    s = '00000'\n    self.assertEqual(solution.numWays(s), 0)", "def test_numWays(self):\n    s = '1'\n    self.assertEqual(solution.numWays(s), 0)", "def test_numWays(self):\n    s = '11111111111111111111'\n    self.assertEqual(solution.numWays(s), 0)", "def test_numWays(self):\n    s = '111100000001'\n    self.assertEqual(solution.numWays(s), (int(10000000000.0) + 5) % 1000000007)", "def test_numWays(self):\n    s = '101'\n    self.assertEqual(solution.numWays(s), 0)", "def test_numWays(self):\n    s = '111111111'\n    self.assertEqual(solution.numWays(s), 0)", "def test_numWays(self):\n    s = '101010'\n    self.assertEqual(solution.numWays(s), (int(10000000000.0) + 5) % 1000000007)", "def test_numWays(self):\n    s = '111'\n    self.assertEqual(solution.numWays(s), 0)", "def test_numWays(self):\n    s = '1111111111111111111111'\n    self.assertEqual(solution.numWays(s), 0)", "def test_numWays(self):\n    s = '110100'\n    self.assertEqual(solution.numWays(s), 10)", "def test_numWays(self):\n    s = '110101'\n    self.assertEqual(solution.numWays(s), 10)"]}
{"task_num": 1574, "task_title": "Shortest Subarray to be Removed to Make Array Sorted", "func_name": "findLengthOfShortestSubarray", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n    n = len(arr)\n    l = 0\n    r = n - 1\n\n    while l < n - 1 and arr[l + 1] >= arr[l]:\n      l += 1\n    while r > 0 and arr[r - 1] <= arr[r]:\n      r -= 1\n    ans = min(n - 1 - l, r)\n\n    i = l\n    j = n - 1\n    while i >= 0 and j >= r and j > i:\n      if arr[i] <= arr[j]:\n        j -= 1\n      else:\n        i -= 1\n      ans = min(ans, j - i)\n\n    return ans\n", "tests": ["def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    arr = [1, 2, 3]\n    assert solution.findLengthOfShortestSubarray(arr) == 0", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    arr = [5, 4, 3, 2, 1]\n    assert solution.findLengthOfShortestSubarray(arr) == 4", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    arr = [1, 3, 2, 4]\n    assert solution.findLengthOfShortestSubarray(arr) == 1", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    arr = [1, 2, 3, 5, 4]\n    assert solution.findLengthOfShortestSubarray(arr) == 2", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    arr = [1]\n    assert solution.findLengthOfShortestSubarray(arr) == 0", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    arr = [1, 2, 3, 4, 5]\n    assert solution.findLengthOfShortestSubarray(arr) == 0", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    arr = [5, 4, 3, 1]\n    assert solution.findLengthOfShortestSubarray(arr) == 2", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    arr = [1, 2, 3, 4, 5, 6]\n    assert solution.findLengthOfShortestSubarray(arr) == 0", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    arr = [3, 5, 2, 4]\n    assert solution.findLengthOfShortestSubarray(arr) == 1", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    arr = [6, 5, 4, 3]\n    assert solution.findLengthOfShortestSubarray(arr) == 2", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    arr = [1, 3, 5, 2, 4]\n    assert solution.findLengthOfShortestSubarray(arr) == 2", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    arr = [1, 2, 3, 4, 5, 6, 7]\n    assert solution.findLengthOfShortestSubarray(arr) == 0", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    arr = [2, 3, 4, 1]\n    assert solution.findLengthOfShortestSubarray(arr) == 1", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    arr = [6, 4, 5, 2]\n    assert solution.findLengthOfShortestSubarray(arr) == 1", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    arr = [4, 5, 3, 1]\n    assert solution.findLengthOfShortestSubarray(arr) == 2", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    arr = [7, 6, 5, 4]\n    assert solution.findLengthOfShortestSubarray(arr) == 3", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    arr = [5, 4, 1, 2]\n    assert solution.findLengthOfShortestSubarray(arr) == 1", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    arr = [3, 1, 2]\n    assert solution.findLengthOfShortestSubarray(arr) == 0", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    arr = [2, 1, 3]\n    assert solution.findLengthOfShortestSubarray(arr) == 0", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    arr = [6, 5, 4, 1]\n    assert solution.findLengthOfShortestSubarray(arr) == 2"]}
{"task_num": 1579, "task_title": "Remove Max Number of Edges to Keep Graph Fully Traversable", "func_name": "maxNumEdgesToRemove", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    self.count -= 1\n    return True\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\n    alice = UnionFind(n)\n    bob = UnionFind(n)\n    requiredEdges = 0\n\n    for type, u, v in sorted(edges, reverse=True):\n      u -= 1\n      v -= 1\n      if type == 3:\n        if alice.unionByRank(u, v) | bob.unionByRank(u, v):\n          requiredEdges += 1\n      elif type == 2:\n        if bob.unionByRank(u, v):\n          requiredEdges += 1\n      else:\n        if alice.unionByRank(u, v):\n          requiredEdges += 1\n\n    if alice.count == 1 and bob.count == 1:\n        return len(edges) - requiredEdges\n    else:\n        return -1\n", "tests": ["def test_maxNumEdgesToRemove():\n\n    class Solution:\n\n        def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\n            alice = UnionFind(n)\n            bob = UnionFind(n)\n            requiredEdges = 0\n            for (type, u, v) in sorted(edges, reverse=True):\n                u -= 1\n                v -= 1\n                if type == 3:\n                    if alice.unionByRank(u, v) | bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif type == 2:\n                    if bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif alice.unionByRank(u, v):\n                    requiredEdges += 1\n            if alice.count == 1 and bob.count == 1:\n                return len(edges) - requiredEdges\n            else:\n                return -1\n    solution = Solution()\n    n = 4\n    edges = [[3, 0, 1], [3, 1, 2], [3, 2, 0]]\n    assert solution.maxNumEdgesToRemove(n, edges) == 2", "def test_maxNumEdgesToRemove():\n\n    class Solution:\n\n        def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\n            alice = UnionFind(n)\n            bob = UnionFind(n)\n            requiredEdges = 0\n            for (type, u, v) in sorted(edges, reverse=True):\n                u -= 1\n                v -= 1\n                if type == 3:\n                    if alice.unionByRank(u, v) | bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif type == 2:\n                    if bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif alice.unionByRank(u, v):\n                    requiredEdges += 1\n            if alice.count == 1 and bob.count == 1:\n                return len(edges) - requiredEdges\n            else:\n                return -1\n    solution = Solution()\n    n = 3\n    edges = [[2, 0, 1], [1, 2, 0]]\n    assert solution.maxNumEdgesToRemove(n, edges) == -1", "def test_maxNumEdgesToRemove():\n\n    class Solution:\n\n        def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\n            alice = UnionFind(n)\n            bob = UnionFind(n)\n            requiredEdges = 0\n            for (type, u, v) in sorted(edges, reverse=True):\n                u -= 1\n                v -= 1\n                if type == 3:\n                    if alice.unionByRank(u, v) | bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif type == 2:\n                    if bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif alice.unionByRank(u, v):\n                    requiredEdges += 1\n            if alice.count == 1 and bob.count == 1:\n                return len(edges) - requiredEdges\n            else:\n                return -1\n    solution = Solution()\n    n = 5\n    edges = [[3, 0, 1], [2, 0, 2], [2, 1, 3], [3, 1, 4]]\n    assert solution.maxNumEdgesToRemove(n, edges) == 2", "def test_maxNumEdgesToRemove():\n\n    class Solution:\n\n        def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\n            alice = UnionFind(n)\n            bob = UnionFind(n)\n            requiredEdges = 0\n            for (type, u, v) in sorted(edges, reverse=True):\n                u -= 1\n                v -= 1\n                if type == 3:\n                    if alice.unionByRank(u, v) | bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif type == 2:\n                    if bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif alice.unionByRank(u, v):\n                    requiredEdges += 1\n            if alice.count == 1 and bob.count == 1:\n                return len(edges) - requiredEdges\n            else:\n                return -1\n    solution = Solution()\n    n = 4\n    edges = [[3, 0, 1], [2, 0, 2], [3, 1, 2]]\n    assert solution.maxNumEdgesToRemove(n, edges) == 1", "def test_maxNumEdgesToRemove():\n\n    class Solution:\n\n        def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\n            alice = UnionFind(n)\n            bob = UnionFind(n)\n            requiredEdges = 0\n            for (type, u, v) in sorted(edges, reverse=True):\n                u -= 1\n                v -= 1\n                if type == 3:\n                    if alice.unionByRank(u, v) | bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif type == 2:\n                    if bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif alice.unionByRank(u, v):\n                    requiredEdges += 1\n            if alice.count == 1 and bob.count == 1:\n                return len(edges) - requiredEdges\n            else:\n                return -1\n    solution = Solution()\n    n = 2\n    edges = [[3, 0, 1], [3, 1, 0]]\n    assert solution.maxNumEdgesToRemove(n, edges) == 2", "def test_maxNumEdgesToRemove():\n\n    class Solution:\n\n        def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\n            alice = UnionFind(n)\n            bob = UnionFind(n)\n            requiredEdges = 0\n            for (type, u, v) in sorted(edges, reverse=True):\n                u -= 1\n                v -= 1\n                if type == 3:\n                    if alice.unionByRank(u, v) | bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif type == 2:\n                    if bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif alice.unionByRank(u, v):\n                    requiredEdges += 1\n            if alice.count == 1 and bob.count == 1:\n                return len(edges) - requiredEdges\n            else:\n                return -1\n    solution = Solution()\n    n = 4\n    edges = [[3, 0, 1], [2, 2, 0]]\n    assert solution.maxNumEdgesToRemove(n, edges) == -1", "def test_maxNumEdgesToRemove():\n\n    class Solution:\n\n        def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\n            alice = UnionFind(n)\n            bob = UnionFind(n)\n            requiredEdges = 0\n            for (type, u, v) in sorted(edges, reverse=True):\n                u -= 1\n                v -= 1\n                if type == 3:\n                    if alice.unionByRank(u, v) | bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif type == 2:\n                    if bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif alice.unionByRank(u, v):\n                    requiredEdges += 1\n            if alice.count == 1 and bob.count == 1:\n                return len(edges) - requiredEdges\n            else:\n                return -1\n    solution = Solution()\n    n = 3\n    edges = [[2, 0, 1], [1, 2, 0], [3, 1, 2]]\n    assert solution.maxNumEdgesToRemove(n, edges) == -1", "def test_maxNumEdgesToRemove():\n\n    class Solution:\n\n        def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\n            alice = UnionFind(n)\n            bob = UnionFind(n)\n            requiredEdges = 0\n            for (type, u, v) in sorted(edges, reverse=True):\n                u -= 1\n                v -= 1\n                if type == 3:\n                    if alice.unionByRank(u, v) | bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif type == 2:\n                    if bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif alice.unionByRank(u, v):\n                    requiredEdges += 1\n            if alice.count == 1 and bob.count == 1:\n                return len(edges) - requiredEdges\n            else:\n                return -1\n    solution = Solution()\n    n = 5\n    edges = [[3, 0, 2], [3, 0, 4], [3, 1, 3], [3, 1, 4]]\n    assert solution.maxNumEdgesToRemove(n, edges) == 0", "def test_maxNumEdgesToRemove():\n\n    class Solution:\n\n        def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\n            alice = UnionFind(n)\n            bob = UnionFind(n)\n            requiredEdges = 0\n            for (type, u, v) in sorted(edges, reverse=True):\n                u -= 1\n                v -= 1\n                if type == 3:\n                    if alice.unionByRank(u, v) | bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif type == 2:\n                    if bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif alice.unionByRank(u, v):\n                    requiredEdges += 1\n            if alice.count == 1 and bob.count == 1:\n                return len(edges) - requiredEdges\n            else:\n                return -1\n    solution = Solution()\n    n = 6\n    edges = [[3, 0, 5], [3, 0, 2], [3, 1, 4], [3, 2, 5], [3, 2, 1]]\n    assert solution.maxNumEdgesToRemove(n, edges) == 2", "def test_maxNumEdgesToRemove():\n\n    class Solution:\n\n        def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\n            alice = UnionFind(n)\n            bob = UnionFind(n)\n            requiredEdges = 0\n            for (type, u, v) in sorted(edges, reverse=True):\n                u -= 1\n                v -= 1\n                if type == 3:\n                    if alice.unionByRank(u, v) | bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif type == 2:\n                    if bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif alice.unionByRank(u, v):\n                    requiredEdges += 1\n            if alice.count == 1 and bob.count == 1:\n                return len(edges) - requiredEdges\n            else:\n                return -1\n    solution = Solution()\n    n = 7\n    edges = [[3, 0, 6], [3, 0, 5], [3, 3, 4], [2, 2, 5], [3, 2, 1]]\n    assert solution.maxNumEdgesToRemove(n, edges) == 1", "def test_maxNumEdgesToRemove():\n\n    class Solution:\n\n        def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\n            alice = UnionFind(n)\n            bob = UnionFind(n)\n            requiredEdges = 0\n            for (type, u, v) in sorted(edges, reverse=True):\n                u -= 1\n                v -= 1\n                if type == 3:\n                    if alice.unionByRank(u, v) | bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif type == 2:\n                    if bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif alice.unionByRank(u, v):\n                    requiredEdges += 1\n            if alice.count == 1 and bob.count == 1:\n                return len(edges) - requiredEdges\n            else:\n                return -1\n    solution = Solution()\n    n = 8\n    edges = [[3, 0, 6], [3, 0, 5], [3, 3, 4], [2, 2, 5], [3, 2, 1], [1, 1, 7]]\n    assert solution.maxNumEdgesToRemove(n, edges) == -1", "def test_maxNumEdgesToRemove():\n\n    class Solution:\n\n        def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\n            alice = UnionFind(n)\n            bob = UnionFind(n)\n            requiredEdges = 0\n            for (type, u, v) in sorted(edges, reverse=True):\n                u -= 1\n                v -= 1\n                if type == 3:\n                    if alice.unionByRank(u, v) | bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif type == 2:\n                    if bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif alice.unionByRank(u, v):\n                    requiredEdges += 1\n            if alice.count == 1 and bob.count == 1:\n                return len(edges) - requiredEdges\n            else:\n                return -1\n    solution = Solution()\n    n = 9\n    edges = [[3, 0, 8], [3, 0, 7], [3, 6, 5], [2, 4, 5], [3, 2, 1], [1, 1, 9]]\n    assert solution.maxNumEdgesToRemove(n, edges) == -1", "def test_maxNumEdgesToRemove():\n\n    class Solution:\n\n        def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\n            alice = UnionFind(n)\n            bob = UnionFind(n)\n            requiredEdges = 0\n            for (type, u, v) in sorted(edges, reverse=True):\n                u -= 1\n                v -= 1\n                if type == 3:\n                    if alice.unionByRank(u, v) | bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif type == 2:\n                    if bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif alice.unionByRank(u, v):\n                    requiredEdges += 1\n            if alice.count == 1 and bob.count == 1:\n                return len(edges) - requiredEdges\n            else:\n                return -1\n    solution = Solution()\n    n = 10\n    edges = [[3, 0, 9], [3, 0, 8], [3, 6, 5], [2, 4, 5], [3, 2, 1], [1, 7, 1], [3, 3, 4]]\n    assert solution.maxNumEdgesToRemove(n, edges) == -1", "def test_maxNumEdgesToRemove():\n\n    class Solution:\n\n        def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\n            alice = UnionFind(n)\n            bob = UnionFind(n)\n            requiredEdges = 0\n            for (type, u, v) in sorted(edges, reverse=True):\n                u -= 1\n                v -= 1\n                if type == 3:\n                    if alice.unionByRank(u, v) | bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif type == 2:\n                    if bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif alice.unionByRank(u, v):\n                    requiredEdges += 1\n            if alice.count == 1 and bob.count == 1:\n                return len(edges) - requiredEdges\n            else:\n                return -1\n    solution = Solution()\n    n = 11\n    edges = [[3, 0, 10], [3, 0, 9], [3, 6, 5], [2, 4, 5], [3, 2, 1], [1, 7, 1], [3, 3, 4], [3, 8, 8]]\n    assert solution.maxNumEdgesToRemove(n, edges) == -1", "def test_maxNumEdgesToRemove():\n\n    class Solution:\n\n        def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\n            alice = UnionFind(n)\n            bob = UnionFind(n)\n            requiredEdges = 0\n            for (type, u, v) in sorted(edges, reverse=True):\n                u -= 1\n                v -= 1\n                if type == 3:\n                    if alice.unionByRank(u, v) | bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif type == 2:\n                    if bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif alice.unionByRank(u, v):\n                    requiredEdges += 1\n            if alice.count == 1 and bob.count == 1:\n                return len(edges) - requiredEdges\n            else:\n                return -1\n    solution = Solution()\n    n = 12\n    edges = [[3, 0, 11], [3, 0, 10], [3, 6, 5], [2, 4, 5], [3, 2, 1], [1, 7, 1], [3, 3, 4], [3, 8, 8], [3, 9, 9]]\n    assert solution.maxNumEdgesToRemove(n, edges) == -1", "def test_maxNumEdgesToRemove():\n\n    class Solution:\n\n        def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\n            alice = UnionFind(n)\n            bob = UnionFind(n)\n            requiredEdges = 0\n            for (type, u, v) in sorted(edges, reverse=True):\n                u -= 1\n                v -= 1\n                if type == 3:\n                    if alice.unionByRank(u, v) | bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif type == 2:\n                    if bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif alice.unionByRank(u, v):\n                    requiredEdges += 1\n            if alice.count == 1 and bob.count == 1:\n                return len(edges) - requiredEdges\n            else:\n                return -1\n    solution = Solution()\n    n = 13\n    edges = [[3, 0, 12], [3, 0, 11], [3, 6, 5], [2, 4, 5], [3, 2, 1], [1, 7, 1], [3, 3, 4], [3, 8, 8], [3, 9, 9], [3, 10, 10]]\n    assert solution.maxNumEdgesToRemove(n, edges) == -1", "def test_maxNumEdgesToRemove():\n\n    class Solution:\n\n        def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\n            alice = UnionFind(n)\n            bob = UnionFind(n)\n            requiredEdges = 0\n            for (type, u, v) in sorted(edges, reverse=True):\n                u -= 1\n                v -= 1\n                if type == 3:\n                    if alice.unionByRank(u, v) | bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif type == 2:\n                    if bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif alice.unionByRank(u, v):\n                    requiredEdges += 1\n            if alice.count == 1 and bob.count == 1:\n                return len(edges) - requiredEdges\n            else:\n                return -1\n    solution = Solution()\n    n = 14\n    edges = [[3, 0, 13], [3, 0, 12], [3, 6, 5], [2, 4, 5], [3, 2, 1], [1, 7, 1], [3, 3, 4], [3, 8, 8], [3, 9, 9], [3, 10, 10], [3, 11, 11]]\n    assert solution.maxNumEdgesToRemove(n, edges) == -1", "def test_maxNumEdgesToRemove():\n\n    class Solution:\n\n        def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\n            alice = UnionFind(n)\n            bob = UnionFind(n)\n            requiredEdges = 0\n            for (type, u, v) in sorted(edges, reverse=True):\n                u -= 1\n                v -= 1\n                if type == 3:\n                    if alice.unionByRank(u, v) | bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif type == 2:\n                    if bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif alice.unionByRank(u, v):\n                    requiredEdges += 1\n            if alice.count == 1 and bob.count == 1:\n                return len(edges) - requiredEdges\n            else:\n                return -1\n    solution = Solution()\n    n = 100\n    edges = [[3] * n + [0] * n, [0] * (2 * n)]\n    assert solution.maxNumEdgesToRemove(n, edges) == -1", "def test_maxNumEdgesToRemove():\n\n    class Solution:\n\n        def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\n            alice = UnionFind(n)\n            bob = UnionFind(n)\n            requiredEdges = 0\n            for (type, u, v) in sorted(edges, reverse=True):\n                u -= 1\n                v -= 1\n                if type == 3:\n                    if alice.unionByRank(u, v) | bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif type == 2:\n                    if bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif alice.unionByRank(u, v):\n                    requiredEdges += 1\n            if alice.count == 1 and bob.count == 1:\n                return len(edges) - requiredEdges\n            else:\n                return -1\n    solution = Solution()\n    n = 1000\n    edges = [[3] * n + [0] * n, [0] * (2 * n)]\n    assert solution.maxNumEdgesToRemove(n, edges) == -1", "def test_maxNumEdgesToRemove():\n\n    class Solution:\n\n        def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\n            alice = UnionFind(n)\n            bob = UnionFind(n)\n            requiredEdges = 0\n            for (type, u, v) in sorted(edges, reverse=True):\n                u -= 1\n                v -= 1\n                if type == 3:\n                    if alice.unionByRank(u, v) | bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif type == 2:\n                    if bob.unionByRank(u, v):\n                        requiredEdges += 1\n                elif alice.unionByRank(u, v):\n                    requiredEdges += 1\n            if alice.count == 1 and bob.count == 1:\n                return len(edges) - requiredEdges\n            else:\n                return -1\n    solution = Solution()\n    n = 10000\n    edges = [[3] * n + [0] * (2 * n)]\n    assert solution.maxNumEdgesToRemove(n, edges) == -1"]}
{"task_num": 1582, "task_title": "Special Positions in a Binary Matrix", "func_name": "numSpecial", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numSpecial(self, mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    ans = 0\n    rowOnes = [0] * m\n    colOnes = [0] * n\n\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j] == 1:\n          rowOnes[i] += 1\n          colOnes[j] += 1\n\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j] == 1 and rowOnes[i] == 1 and colOnes[j] == 1:\n          ans += 1\n\n    return ans\n", "tests": ["def test_numSpecial(self):\n    mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    self.assertEqual(self.solution.numSpecial(mat), 3)", "def test_numSpecial(self):\n    mat = [[0 for _ in range(5)] for _ in range(5)]\n    self.assertEqual(self.solution.numSpecial(mat), 0)", "def test_numSpecial(self):\n    mat = [[1]]\n    self.assertEqual(self.solution.numSpecial(mat), 1)", "def test_numSpecial(self):\n    mat = [[1, 1], [1, 1]]\n    self.assertEqual(self.solution.numSpecial(mat), 0)", "def test_numSpecial(self):\n    mat = [[1, 1, 0], [0, 1, 0], [0, 0, 1]]\n    self.assertEqual(self.solution.numSpecial(mat), 3)", "def test_numSpecial(self):\n    mat = [[1] * 100 + [0] * (100 - 1) for _ in range(100)]\n    mat[99][100] = 1\n    self.assertEqual(self.solution.numSpecial(mat), 1)", "def test_numSpecial(self):\n    mat = [[1] * 100 for _ in range(100)]\n    self.assertEqual(self.solution.numSpecial(mat), 0)", "def test_numSpecial(self):\n    mat = [[1, -1, 0], [-1, 1, 0], [0, 0, 1]]\n    with self.assertRaises(TypeError):\n        self.solution.numSpecial(mat)", "def test_numSpecial(self):\n    mat = [[1.5, 0, 0], [0, 1.2, 0], [0, 0, 1]]\n    with self.assertRaises(TypeError):\n        self.solution.numSpecial(mat)", "def test_numSpecial(self):\n    with self.assertRaises(TypeError):\n        self.solution.numSpecial('hello')", "def test_numSpecial(self):\n    with self.assertRaises(TypeError):\n        self.solution.numSpecial([[1]])", "def test_numSpecial(self):\n    mat = [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]\n    self.assertEqual(self.solution.numSpecial(mat), 3)", "def test_numSpecial(self):\n    mat = [[0 for _ in range(5)] for _ in range(5)]\n    self.assertEqual(self.solution.numSpecial(mat), 0)", "def test_numSpecial(self):\n    mat = [[1, 0], [0, 0]]\n    self.assertEqual(self.solution.numSpecial(mat), 1)", "def test_numSpecial(self):\n    mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    self.assertEqual(self.solution.numSpecial(mat), 3)", "def test_numSpecial(self):\n    mat = [[1] * 100 for _ in range(100)]\n    self.assertEqual(self.solution.numSpecial(mat), 0)", "def test_numSpecial(self):\n    mat = [[1] * 500 + [0] * 499 for _ in range(500)]\n    mat[499][500] = 1\n    self.assertEqual(self.solution.numSpecial(mat), 1)", "def test_numSpecial(self):\n    mat = [[1, -2, 0], [-3, 1, 0], [0, 0, 1]]\n    self.assertEqual(self.solution.numSpecial(mat), 3)", "def test_numSpecial(self):\n    mat = [[1.0, -2.5, 0], [-3.7, 1.2, 0], [0, 0, 1]]\n    self.assertEqual(self.solution.numSpecial(mat), 3)", "def test_numSpecial(self):\n    mat = [[1, 'a', 0], [-3, 1.2, 0], [0, 0, 'b']]\n    with self.assertRaises(TypeError):\n        self.solution.numSpecial(mat)"]}
{"task_num": 1583, "task_title": "Count Unhappy Friends", "func_name": "unhappyFriends", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\n    ans = 0\n    matches = [0] * n\n    prefer = [{} for _ in range(n)]\n\n    for x, y in pairs:\n      matches[x] = y\n      matches[y] = x\n\n    for i in range(n):\n      for j in range(n - 1):\n        prefer[i][preferences[i][j]] = j\n\n    for x in range(n):\n      for u in prefer[x].keys():\n        y = matches[x]\n        v = matches[u]\n        if prefer[x][u] < prefer[x][y] and prefer[u][x] < prefer[u][v]:\n          ans += 1\n          break\n\n    return ans\n", "tests": ["def test_unhappyFriends(self):\n    solution = Solution()\n    n = 4\n    preferences = [[1, 3, 2], [0, 2, 3], [0, 1, 3], [0, 2, 1]]\n    pairs = [[0, 1], [2, 3]]\n    self.assertEqual(solution.unhappyFriends(n, preferences, pairs), 2)", "def test_unhappyFriends(self):\n    solution = Solution()\n    n = 4\n    preferences = [[1, 3, 2], [0, 2, 3], [0, 1, 3], [0, 2, 1]]\n    pairs = [[0, 2], [1, 3]]\n    self.assertEqual(solution.unhappyFriends(n, preferences, pairs), 0)", "def test_unhappyFriends(self):\n    solution = Solution()\n    n = 6\n    preferences = [[1, 3, 2, 4], [0, 5, 4, 3], [0, 1, 5, 4], [0, 1, 3, 4], [0, 5, 2, 4]]\n    pairs = [[0, 3], [1, 4], [2, 5]]\n    self.assertEqual(solution.unhappyFriends(n, preferences, pairs), 6)", "def test_unhappyFriends(self):\n    solution = Solution()\n    n = 2\n    preferences = [[1], [0]]\n    pairs = [[0, 1]]\n    self.assertEqual(solution.unhappyFriends(n, preferences, pairs), 0)", "def test_unhappyFriends(self):\n    solution = Solution()\n    n = 4\n    preferences = [[1, 3, 2], [0, 3, 2], [0, 1, 3], [0, 2, 1]]\n    pairs = [[0, 1], [2, 3]]\n    self.assertEqual(solution.unhappyFriends(n, preferences, pairs), 2)", "def test_unhappyFriends(self):\n    solution = Solution()\n    n = 4\n    preferences = [[3, 1, 2], [0, 2, 3], [0, 1, 3], [0, 2, 1]]\n    pairs = [[0, 1], [2, 3]]\n    self.assertEqual(solution.unhappyFriends(n, preferences, pairs), 1)", "def test_unhappyFriends(self):\n    solution = Solution()\n    n = 4\n    preferences = [[1, 3, 2], [0, 3, 2], [0, 1, 2], [0, 2, 1]]\n    pairs = [[0, 1], [2, 3]]\n    self.assertEqual(solution.unhappyFriends(n, preferences, pairs), 2)", "def test_unhappyFriends(self):\n    solution = Solution()\n    n = 5\n    preferences = [[2, 1, 4, 3], [0, 1, 3, 4], [0, 2, 4, 3], [0, 1, 4, 3], [0, 2, 3, 4]]\n    pairs = [[0, 2], [1, 3], [4, 0]]\n    self.assertEqual(solution.unhappyFriends(n, preferences, pairs), 4)", "def test_unhappyFriends(self):\n    solution = Solution()\n    n = 4\n    preferences = [[2, 1, 3], [0, 3, 2], [0, 1, 3], [0, 2, 1]]\n    pairs = [[0, 1], [2, 3]]\n    self.assertEqual(solution.unhappyFriends(n, preferences, pairs), 0)", "def test_unhappyFriends(self):\n    solution = Solution()\n    n = 4\n    preferences = [[1, 3, 2], [0, 2, 3], [0, 1, 3], [0, 2, 1]]\n    pairs = [[0, 2], [1, 3]]\n    self.assertEqual(solution.unhappyFriends(n, preferences, pairs), 2)", "def test_unhappyFriends(self):\n    solution = Solution()\n    n = 4\n    preferences = [[3, 1, 2], [0, 2, 3], [0, 1, 2], [0, 2, 1]]\n    pairs = [[0, 1], [2, 3]]\n    self.assertEqual(solution.unhappyFriends(n, preferences, pairs), 0)", "def test_unhappyFriends(self):\n    solution = Solution()\n    n = 6\n    preferences = [[1, 3, 2, 4], [0, 5, 4, 3], [0, 1, 5, 4], [0, 1, 3, 4], [0, 5, 2, 4]]\n    pairs = [[0, 3], [1, 4], [2, 5], [5, 2]]\n    self.assertEqual(solution.unhappyFriends(n, preferences, pairs), 4)", "def test_unhappyFriends(self):\n    solution = Solution()\n    n = 4\n    preferences = [[1, 3, 2], [0, 3, 2], [0, 1, 3], [0, 2, 1]]\n    pairs = [[0, 3], [1, 2]]\n    self.assertEqual(solution.unhappyFriends(n, preferences, pairs), 2)", "def test_unhappyFriends(self):\n    solution = Solution()\n    n = 5\n    preferences = [[3, 1, 2, 4], [0, 5, 4, 3], [0, 1, 5, 4], [0, 1, 3, 4]]\n    pairs = [[0, 3], [1, 4], [2, 5], [5, 2]]\n    self.assertEqual(solution.unhappyFriends(n, preferences, pairs), 6)", "def test_unhappyFriends(self):\n    solution = Solution()\n    n = 4\n    preferences = [[3, 1, 2], [0, 2, 3], [0, 1, 3], [0, 2, 1]]\n    pairs = [[0, 2], [1, 3], [2, 0]]\n    self.assertEqual(solution.unhappyFriends(n, preferences, pairs), 1)", "def test_unhappyFriends(self):\n    solution = Solution()\n    n = 4\n    preferences = [[2, 1, 3], [0, 3, 2], [0, 1, 3], [0, 2, 1]]\n    pairs = [[0, 3], [1, 2], [2, 0]]\n    self.assertEqual(solution.unhappyFriends(n, preferences, pairs), 2)", "def test_unhappyFriends(self):\n    solution = Solution()\n    n = 6\n    preferences = [[2, 1, 4, 3], [0, 5, 4, 3], [0, 1, 5, 4], [0, 1, 3, 4], [0, 5, 2, 4]]\n    pairs = [[0, 3], [1, 4], [2, 5], [5, 2], [0, 2]]\n    self.assertEqual(solution.unhappyFriends(n, preferences, pairs), 7)", "def test_unhappyFriends(self):\n    solution = Solution()\n    n = 4\n    preferences = [[1, 3, 2], [0, 2, 3], [0, 1, 3], [0, 2, 1]]\n    pairs = [[0, 1], [2, 3], [1, 0]]\n    self.assertEqual(solution.unhappyFriends(n, preferences, pairs), 2)", "def test_unhappyFriends(self):\n    solution = Solution()\n    n = 5\n    preferences = [[3, 1, 2, 4], [0, 5, 4, 3], [0, 1, 5, 4], [0, 1, 3, 4]]\n    pairs = [[0, 3], [1, 4], [2, 0], [5, 2]]\n    self.assertEqual(solution.unhappyFriends(n, preferences, pairs), 7)", "def test_unhappyFriends(self):\n    solution = Solution()\n    n = 4\n    preferences = [[2, 1, 3], [0, 3, 2], [0, 1, 3], [0, 2, 1]]\n    pairs = [[0, 3], [1, 2], [3, 0]]\n    self.assertEqual(solution.unhappyFriends(n, preferences, pairs), 3)"]}
{"task_num": 1591, "task_title": "Strange Printer II", "func_name": "isPrintable", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import Enum\n\n\nclass State(Enum):\n  kInit = 0\n  kVisiting = 1\n  kVisited = 2\n\n\nclass Solution:\n  def isPrintable(self, targetGrid: List[List[int]]) -> bool:\n    kMaxColor = 60\n    m = len(targetGrid)\n    n = len(targetGrid[0])\n\n    graph = [set() for _ in range(kMaxColor + 1)]\n\n    for color in range(1, kMaxColor + 1):\n      minI = m\n      minJ = n\n      maxI = -1\n      maxJ = -1\n      for i in range(m):\n        for j in range(n):\n          if targetGrid[i][j] == color:\n            minI = min(minI, i)\n            minJ = min(minJ, j)\n            maxI = max(maxI, i)\n            maxJ = max(maxJ, j)\n\n      for i in range(minI, maxI + 1):\n        for j in range(minJ, maxJ + 1):\n          if targetGrid[i][j] != color:\n            graph[color].add(targetGrid[i][j])\n\n    states = [State.kInit] * (kMaxColor + 1)\n\n    def hasCycle(u: int) -> bool:\n      if states[u] == State.kVisiting:\n        return True\n      if states[u] == State.kVisited:\n        return False\n\n      states[u] = State.kVisiting\n      if any(hasCycle(v) for v in graph[u]):\n        return True\n      states[u] = State.kVisited\n\n      return False\n\n    for i in range(1, kMaxColor + 1):\n      if hasCycle(i):\n        return False\n    return True\n", "tests": ["def test_isPrintable(self):\n    solution = Solution()\n    targetGrid = [[1, 0, 0], [2, 3, 0], [3, 1, 1]]\n    self.assertEqual(solution.isPrintable(targetGrid), True)", "def test_isPrintable(self):\n    solution = Solution()\n    targetGrid = [[1, 0, 0], [2, 3, 0], [3, 1, 1]]\n    self.assertEqual(solution.isPrintable(targetGrid), True)", "def test_isPrintable(self):\n    solution = Solution()\n    targetGrid = [[1, 0, 0], [2, 3, 0], [3, 1, 1]]\n    self.assertEqual(solution.isPrintable(targetGrid), True)", "def test_isPrintable(self):\n    solution = Solution()\n    targetGrid = [[1, 0, 0], [2, 3, 0], [3, 1, 1]]\n    self.assertEqual(solution.isPrintable(targetGrid), True)", "def test_isPrintable(self):\n    solution = Solution()\n    targetGrid = [[1, 0, 0], [2, 3, 0], [3, 1, 1]]\n    self.assertEqual(solution.isPrintable(targetGrid), True)", "def test_isPrintable(self):\n    solution = Solution()\n    targetGrid = [[1, 0, 0], [2, 3, 0], [3, 1, 1]]\n    self.assertEqual(solution.isPrintable(targetGrid), True)", "def test_isPrintable(self):\n    solution = Solution()\n    targetGrid = [[1, 0, 0], [2, 3, 0], [3, 1, 1]]\n    self.assertEqual(solution.isPrintable(targetGrid), True)", "def test_isPrintable(self):\n    solution = Solution()\n    targetGrid = [[1, 0, 0], [2, 3, 0], [3, 1, 1]]\n    self.assertEqual(solution.isPrintable(targetGrid), True)", "def test_isPrintable(self):\n    solution = Solution()\n    targetGrid = [[1, 0, 0], [2, 3, 0], [3, 1, 1]]\n    self.assertEqual(solution.isPrintable(targetGrid), True)", "def test_isPrintable(self):\n    solution = Solution()\n    targetGrid = [[1, 0, 0], [2, 3, 0], [3, 1, 1]]\n    self.assertEqual(solution.isPrintable(targetGrid), True)", "def test_isPrintable(self):\n    solution = Solution()\n    targetGrid = [[1, 0, 0], [2, 3, 0], [3, 1, 1]]\n    self.assertEqual(solution.isPrintable(targetGrid), True)", "def test_isPrintable(self):\n    solution = Solution()\n    targetGrid = [[1, 0, 0], [2, 3, 0], [3, 1, 1]]\n    self.assertEqual(solution.isPrintable(targetGrid), True)", "def test_isPrintable(self):\n    solution = Solution()\n    targetGrid = [[1, 0, 0], [2, 3, 0], [3, 1, 1]]\n    self.assertEqual(solution.isPrintable(targetGrid), True)", "def test_isPrintable(self):\n    solution = Solution()\n    targetGrid = [[3, 1, 4], [2, 5, 6], [7, 8, 9]]\n    self.assertEqual(solution.isPrintable(targetGrid), False)", "def test_isPrintable(self):\n    solution = Solution()\n    targetGrid = [[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]\n    self.assertEqual(solution.isPrintable(targetGrid), False)", "def test_isPrintable(self):\n    solution = Solution()\n    targetGrid = [[1000000, 2000000, 3000000], [4000000, 5000000, 6000000], [7000000, 8000000, 9000000]]\n    self.assertEqual(solution.isPrintable(targetGrid), False)", "def test_isPrintable(self):\n    solution = Solution()\n    targetGrid = [[1, 2, 3], [1, 2, 3], [1, 2, 3]]\n    self.assertEqual(solution.isPrintable(targetGrid), True)", "def test_isPrintable(self):\n    solution = Solution()\n    targetGrid = [[(1, 2), (3, 4)], [(5, 6), (7, 8)]]\n    self.assertEqual(solution.isPrintable(targetGrid), False)", "def test_isPrintable(self):\n    solution = Solution()\n    targetGrid = [[1.5, 2.5], [3.5, 4.5]]\n    self.assertEqual(solution.isPrintable(targetGrid), False)", "def test_isPrintable(self):\n    solution = Solution()\n    targetGrid = [[1, 'a', 3], [4, 5.6, 7]]\n    self.assertEqual(solution.isPrintable(targetGrid), False)"]}
{"task_num": 1604, "task_title": "Alert Using Same Key-Card Three or More Times in a One Hour Period", "func_name": "alertNames", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n    nameToMinutes = collections.defaultdict(list)\n\n    for name, time in zip(keyName, keyTime):\n      minutes = self._getMinutes(time)\n      nameToMinutes[name].append(minutes)\n\n    res=[]\n    for name, minutes in nameToMinutes.items():\n      if self._hasAlert(minutes):\n        res.append(name)\n    return sorted(res)\n\n  def _hasAlert(self, minutes: List[int]) -> bool:\n    if len(minutes) > 70:\n      return True\n    minutes.sort()\n    for i in range(2, len(minutes)):\n      if minutes[i - 2] + 60 >= minutes[i]:\n        return True\n    return False\n\n  def _getMinutes(self, time: str) -> int:\n    h, m = map(int, time.split(':'))\n    return 60 * h + m\n", "tests": ["def test_alertNames():\n    solution = Solution()\n    keyName = ['Paul', 'Ketty']\n    keyTime = ['23:51', '12:22', '11:33']\n    result = solution.alertNames(keyName, keyTime)", "def test_alertNames():\n    solution = Solution()\n    keyName = ['Alice', 'Bob']\n    keyTime = ['10:00', '11:01', '12:02', '13:03']\n    result = solution.alertNames(keyName, keyTime)", "def test_alertNames():\n    solution = Solution()\n    keyName = ['Alice', 'Bob']\n    keyTime = ['08:00', '09:01', '10:02', '11:03', '12:04', '13:05']\n    result = solution.alertNames(keyName, keyTime)", "def test_alertNames():\n    solution = Solution()\n    keyName = ['Alice', 'Bob']\n    keyTime = ['08:00', '09:01', '07:03', '10:04']\n    result = solution.alertNames(keyName, keyTime)", "def test_alertNames():\n    solution = Solution()\n    keyName = ['Alice', 'Bob']\n    keyTime = ['08:00', '09:01', '10:02', '11:03', '12:04', '13:05', '14:06', '15:07', '16:08']\n    result = solution.alertNames(keyName, keyTime)", "def test_alertNames():\n    solution = Solution()\n    keyName = ['Alice', 'Bob', 'Charlie']\n    keyTime = ['08:00', '09:01', '10:02', '11:03', '12:04', '13:05', '14:06']\n    result = solution.alertNames(keyName, keyTime)", "def test_alertNames():\n    solution = Solution()\n    keyName = ['Alice', 'Bob']\n    keyTime = ['08:00', '09:01', '10:02', '10:03', '10:04']\n    result = solution.alertNames(keyName, keyTime)", "def test_alertNames():\n    solution = Solution()\n    keyName = ['Alice', 'Bob', 'Charlie']\n    keyTime = ['08:00', '09:01', '10:02', '11:03', '12:04', '13:05']\n    result = solution.alertNames(keyName, keyTime)", "def test_alertNames():\n    solution = Solution()\n    keyName = ['Alice', 'Bob']\n    keyTime = ['08:00', '09:01', '10:02', '11:03']\n    result = solution.alertNames(keyName, keyTime)", "def test_alertNames():\n    solution = Solution()\n    keyName = ['Alice', 'Bob']\n    keyTime = ['08:00', '09:01', '11:02', '12:03']\n    result = solution.alertNames(keyName, keyTime)", "def test_alertNames():\n    solution = Solution()\n    keyName = ['Alice', 'Bob']\n    keyTime = ['08:00', '09:01', '10:02', '11:03', '12:04', '13:05', '14:06', '15:07', '16:08', '17:09']\n    result = solution.alertNames(keyName, keyTime)", "def test_alertNames():\n    solution = Solution()\n    keyName = ['Alice', 'Bob']\n    keyTime = ['08:00', '09:01', '10:02', '11:03', '12:04', '13:05', '14:06', '15:07', '16:08', '17:09', '18:10', '19:11']\n    result = solution.alertNames(keyName, keyTime)", "def test_alertNames():\n    solution = Solution()\n    keyName = ['Alice', 'Bob', 'Charlie']\n    keyTime = ['08:00', '09:01', '10:02', '11:03', '12:04', '13:05', '14:06', '15:07', '16:08', '17:09', '18:10']\n    result = solution.alertNames(keyName, keyTime)", "def test_alertNames():\n    solution = Solution()\n    keyName = ['Alice', 'Bob']\n    keyTime = ['08:00', '09:01', '10:03', '11:05', '12:07']\n    result = solution.alertNames(keyName, keyTime)", "def test_alertNames():\n    solution = Solution()\n    keyName = ['Alice', 'Bob']\n    keyTime = ['09:00', '10:01', '11:02', '12:03', '13:04', '14:05']\n    result = solution.alertNames(keyName, keyTime)", "def test_alertNames():\n    solution = Solution()\n    keyName = ['Alice', 'Bob']\n    keyTime = ['08:00', '09:01', '10:02', '11:03', '12:04', '13:05', '14:06', '15:07', '16:08', '17:09', '18:10', '19:11', '20:12']\n    result = solution.alertNames(keyName, keyTime)", "def test_alertNames():\n    solution = Solution()\n    keyName = ['Alice', 'Bob']\n    keyTime = ['08:00', '09:01', '10:02', '11:03', '12:04', '13:05', '14:06', '15:07', '16:08', '17:09', '18:10', '19:11', '20:12']\n    result = solution.alertNames(keyName, keyTime)", "def test_alertNames():\n    solution = Solution()\n    keyName = ['Alice', 'Bob']\n    keyTime = ['23:00', '00:01', '01:02', '02:03', '03:04']\n    result = solution.alertNames(keyName, keyTime)", "def test_alertNames():\n    solution = Solution()\n    keyName = ['Alice', 'Bob']\n    keyTime = ['08:00', '09:01', '10:02', '11:03', '12:04', '13:05', '14:06', '15:07', '16:08', '17:09']\n    result = solution.alertNames(keyName, keyTime)", "def test_alertNames():\n    solution = Solution()\n    keyName = ['Alice', 'Bob']\n    keyTime = ['08:00', '09:01', '10:02', '11:03', '12:04', '13:05', '14:06', '15:07', '16:08', '17:09', '18:10', '19:11', '20:12']\n    result = solution.alertNames(keyName, keyTime)"]}
{"task_num": 1615, "task_title": "Maximal Network Rank", "func_name": "maximalNetworkRank", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\n    degrees = [0] * n\n\n    for u, v in roads:\n      degrees[u] += 1\n      degrees[v] += 1\n\n    maxDegree1 = 0\n    maxDegree2 = 0\n    for degree in degrees:\n      if degree > maxDegree1:\n        maxDegree2 = maxDegree1\n        maxDegree1 = degree\n      elif degree > maxDegree2:\n        maxDegree2 = degree\n\n    countMaxDegree1 = 0\n    countMaxDegree2 = 0\n    for degree in degrees:\n      if degree == maxDegree1:\n        countMaxDegree1 += 1\n      elif degree == maxDegree2:\n        countMaxDegree2 += 1\n\n    if countMaxDegree1 == 1:\n      edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree2) + self._getEdgeCount(roads, degrees, maxDegree2, maxDegree1)\n      return maxDegree1 + maxDegree2 - (countMaxDegree2 == edgeCount)\n    else:\n      edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree1)\n      maxPossibleEdgeCount = countMaxDegree1 * (countMaxDegree1 - 1) // 2\n      return 2 * maxDegree1 - (maxPossibleEdgeCount == edgeCount)\n\n  def _getEdgeCount(self, roads: List[List[int]], degrees: List[int], degreeU: int, degreeV: int) -> int:\n    edgeCount = 0\n    for u, v in roads:\n      if degrees[u] == degreeU and degrees[v] == degreeV:\n        edgeCount += 1\n    return edgeCount\n", "tests": ["def test_maximalNetworkRank():\n\n    class Solution:\n\n        def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\n            degrees = [0] * n\n            for (u, v) in roads:\n                degrees[u] += 1\n                degrees[v] += 1\n            maxDegree1 = 0\n            maxDegree2 = 0\n            for degree in degrees:\n                if degree > maxDegree1:\n                    maxDegree2 = maxDegree1\n                    maxDegree1 = degree\n                elif degree > maxDegree2:\n                    maxDegree2 = degree\n            countMaxDegree1 = 0\n            countMaxDegree2 = 0\n            for degree in degrees:\n                if degree == maxDegree1:\n                    countMaxDegree1 += 1\n                elif degree == maxDegree2:\n                    countMaxDegree2 += 1\n            if countMaxDegree1 == 1:\n                edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree2) + self._getEdgeCount(roads, degrees, maxDegree2, maxDegree1)\n                return maxDegree1 + maxDegree2 - (countMaxDegree2 == edgeCount)\n            else:\n                edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree1)\n                maxPossibleEdgeCount = countMaxDegree1 * (countMaxDegree1 - 1) // 2\n                return 2 * maxDegree1 - (maxPossibleEdgeCount == edgeCount)\n\n        def _getEdgeCount(self, roads: List[List[int]], degrees: List[int], degreeU: int, degreeV: int) -> int:\n            edgeCount = 0\n            for (u, v) in roads:\n                if degrees[u] == degreeU and degrees[v] == degreeV:\n                    edgeCount += 1\n            return edgeCount\n    solution = Solution()\n    assert solution.maximalNetworkRank(4, [[0, 1], [0, 3], [1, 2], [1, 3]]) == 4", "def test_maximalNetworkRank():\n\n    class Solution:\n\n        def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\n            degrees = [0] * n\n            for (u, v) in roads:\n                degrees[u] += 1\n                degrees[v] += 1\n            maxDegree1 = 0\n            maxDegree2 = 0\n            for degree in degrees:\n                if degree > maxDegree1:\n                    maxDegree2 = maxDegree1\n                    maxDegree1 = degree\n                elif degree > maxDegree2:\n                    maxDegree2 = degree\n            countMaxDegree1 = 0\n            countMaxDegree2 = 0\n            for degree in degrees:\n                if degree == maxDegree1:\n                    countMaxDegree1 += 1\n                elif degree == maxDegree2:\n                    countMaxDegree2 += 1\n            if countMaxDegree1 == 1:\n                edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree2) + self._getEdgeCount(roads, degrees, maxDegree2, maxDegree1)\n                return maxDegree1 + maxDegree2 - (countMaxDegree2 == edgeCount)\n            else:\n                edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree1)\n                maxPossibleEdgeCount = countMaxDegree1 * (countMaxDegree1 - 1) // 2\n                return 2 * maxDegree1 - (maxPossibleEdgeCount == edgeCount)\n\n        def _getEdgeCount(self, roads: List[List[int]], degrees: List[int], degreeU: int, degreeV: int) -> int:\n            edgeCount = 0\n            for (u, v) in roads:\n                if degrees[u] == degreeU and degrees[v] == degreeV:\n                    edgeCount += 1\n            return edgeCount\n    solution = Solution()\n    assert solution.maximalNetworkRank(5, [[0, 1], [0, 3], [1, 2]]) == 4", "def test_maximalNetworkRank():\n\n    class Solution:\n\n        def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\n            degrees = [0] * n\n            for (u, v) in roads:\n                degrees[u] += 1\n                degrees[v] += 1\n            maxDegree1 = 0\n            maxDegree2 = 0\n            for degree in degrees:\n                if degree > maxDegree1:\n                    maxDegree2 = maxDegree1\n                    maxDegree1 = degree\n                elif degree > maxDegree2:\n                    maxDegree2 = degree\n            countMaxDegree1 = 0\n            countMaxDegree2 = 0\n            for degree in degrees:\n                if degree == maxDegree1:\n                    countMaxDegree1 += 1\n                elif degree == maxDegree2:\n                    countMaxDegree2 += 1\n            if countMaxDegree1 == 1:\n                edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree2) + self._getEdgeCount(roads, degrees, maxDegree2, maxDegree1)\n                return maxDegree1 + maxDegree2 - (countMaxDegree2 == edgeCount)\n            else:\n                edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree1)\n                maxPossibleEdgeCount = countMaxDegree1 * (countMaxDegree1 - 1) // 2\n                return 2 * maxDegree1 - (maxPossibleEdgeCount == edgeCount)\n\n        def _getEdgeCount(self, roads: List[List[int]], degrees: List[int], degreeU: int, degreeV: int) -> int:\n            edgeCount = 0\n            for (u, v) in roads:\n                if degrees[u] == degreeU and degrees[v] == degreeV:\n                    edgeCount += 1\n            return edgeCount\n    solution = Solution()\n    assert solution.maximalNetworkRank(10, [[0, 5], [3, 4], [1, 7]]) == 4", "def test_maximalNetworkRank():\n\n    class Solution:\n\n        def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\n            degrees = [0] * n\n            for (u, v) in roads:\n                degrees[u] += 1\n                degrees[v] += 1\n            maxDegree1 = 0\n            maxDegree2 = 0\n            for degree in degrees:\n                if degree > maxDegree1:\n                    maxDegree2 = maxDegree1\n                    maxDegree1 = degree\n                elif degree > maxDegree2:\n                    maxDegree2 = degree\n            countMaxDegree1 = 0\n            countMaxDegree2 = 0\n            for degree in degrees:\n                if degree == maxDegree1:\n                    countMaxDegree1 += 1\n                elif degree == maxDegree2:\n                    countMaxDegree2 += 1\n            if countMaxDegree1 == 1:\n                edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree2) + self._getEdgeCount(roads, degrees, maxDegree2, maxDegree1)\n                return maxDegree1 + maxDegree2 - (countMaxDegree2 == edgeCount)\n            else:\n                edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree1)\n                maxPossibleEdgeCount = countMaxDegree1 * (countMaxDegree1 - 1) // 2\n                return 2 * maxDegree1 - (maxPossibleEdgeCount == edgeCount)\n\n        def _getEdgeCount(self, roads: List[List[int]], degrees: List[int], degreeU: int, degreeV: int) -> int:\n            edgeCount = 0\n            for (u, v) in roads:\n                if degrees[u] == degreeU and degrees[v] == degreeV:\n                    edgeCount += 1\n            return edgeCount\n    solution = Solution()\n    assert solution.maximalNetworkRank(3, [[0, 1], [2, 0]]) == 4", "def test_maximalNetworkRank():\n\n    class Solution:\n\n        def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\n            degrees = [0] * n\n            for (u, v) in roads:\n                degrees[u] += 1\n                degrees[v] += 1\n            maxDegree1 = 0\n            maxDegree2 = 0\n            for degree in degrees:\n                if degree > maxDegree1:\n                    maxDegree2 = maxDegree1\n                    maxDegree1 = degree\n                elif degree > maxDegree2:\n                    maxDegree2 = degree\n            countMaxDegree1 = 0\n            countMaxDegree2 = 0\n            for degree in degrees:\n                if degree == maxDegree1:\n                    countMaxDegree1 += 1\n                elif degree == maxDegree2:\n                    countMaxDegree2 += 1\n            if countMaxDegree1 == 1:\n                edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree2) + self._getEdgeCount(roads, degrees, maxDegree2, maxDegree1)\n                return maxDegree1 + maxDegree2 - (countMaxDegree2 == edgeCount)\n            else:\n                edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree1)\n                maxPossibleEdgeCount = countMaxDegree1 * (countMaxDegree1 - 1) // 2\n                return 2 * maxDegree1 - (maxPossibleEdgeCount == edgeCount)\n\n        def _getEdgeCount(self, roads: List[List[int]], degrees: List[int], degreeU: int, degreeV: int) -> int:\n            edgeCount = 0\n            for (u, v) in roads:\n                if degrees[u] == degreeU and degrees[v] == degreeV:\n                    edgeCount += 1\n            return edgeCount\n    solution = Solution()\n    assert solution.maximalNetworkRank(7, [[0, 6], [0, 1], [6, 4], [2, 5], [0, 5]]) == 4", "def test_maximalNetworkRank():\n\n    class Solution:\n\n        def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\n            degrees = [0] * n\n            for (u, v) in roads:\n                degrees[u] += 1\n                degrees[v] += 1\n            maxDegree1 = 0\n            maxDegree2 = 0\n            for degree in degrees:\n                if degree > maxDegree1:\n                    maxDegree2 = maxDegree1\n                    maxDegree1 = degree\n                elif degree > maxDegree2:\n                    maxDegree2 = degree\n            countMaxDegree1 = 0\n            countMaxDegree2 = 0\n            for degree in degrees:\n                if degree == maxDegree1:\n                    countMaxDegree1 += 1\n                elif degree == maxDegree2:\n                    countMaxDegree2 += 1\n            if countMaxDegree1 == 1:\n                edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree2) + self._getEdgeCount(roads, degrees, maxDegree2, maxDegree1)\n                return maxDegree1 + maxDegree2 - (countMaxDegree2 == edgeCount)\n            else:\n                edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree1)\n                maxPossibleEdgeCount = countMaxDegree1 * (countMaxDegree1 - 1) // 2\n                return 2 * maxDegree1 - (maxPossibleEdgeCount == edgeCount)\n\n        def _getEdgeCount(self, roads: List[List[int]], degrees: List[int], degreeU: int, degreeV: int) -> int:\n            edgeCount = 0\n            for (u, v) in roads:\n                if degrees[u] == degreeU and degrees[v] == degreeV:\n                    edgeCount += 1\n            return edgeCount\n    solution = Solution()\n    assert solution.maximalNetworkRank(2, []) == 0", "def test_maximalNetworkRank():\n\n    class Solution:\n\n        def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\n            degrees = [0] * n\n            for (u, v) in roads:\n                degrees[u] += 1\n                degrees[v] += 1\n            maxDegree1 = 0\n            maxDegree2 = 0\n            for degree in degrees:\n                if degree > maxDegree1:\n                    maxDegree2 = maxDegree1\n                    maxDegree1 = degree\n                elif degree > maxDegree2:\n                    maxDegree2 = degree\n            countMaxDegree1 = 0\n            countMaxDegree2 = 0\n            for degree in degrees:\n                if degree == maxDegree1:\n                    countMaxDegree1 += 1\n                elif degree == maxDegree2:\n                    countMaxDegree2 += 1\n            if countMaxDegree1 == 1:\n                edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree2) + self._getEdgeCount(roads, degrees, maxDegree2, maxDegree1)\n                return maxDegree1 + maxDegree2 - (countMaxDegree2 == edgeCount)\n            else:\n                edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree1)\n                maxPossibleEdgeCount = countMaxDegree1 * (countMaxDegree1 - 1) // 2\n                return 2 * maxDegree1 - (maxPossibleEdgeCount == edgeCount)\n\n        def _getEdgeCount(self, roads: List[List[int]], degrees: List[int], degreeU: int, degreeV: int) -> int:\n            edgeCount = 0\n            for (u, v) in roads:\n                if degrees[u] == degreeU and degrees[v] == degreeV:\n                    edgeCount += 1\n            return edgeCount\n    solution = Solution()\n    assert solution.maximalNetworkRank(5, [[0, 2], [3, 4]]) == 3", "def test_maximalNetworkRank():\n\n    class Solution:\n\n        def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\n            degrees = [0] * n\n            for (u, v) in roads:\n                degrees[u] += 1\n                degrees[v] += 1\n            maxDegree1 = 0\n            maxDegree2 = 0\n            for degree in degrees:\n                if degree > maxDegree1:\n                    maxDegree2 = maxDegree1\n                    maxDegree1 = degree\n                elif degree > maxDegree2:\n                    maxDegree2 = degree\n            countMaxDegree1 = 0\n            countMaxDegree2 = 0\n            for degree in degrees:\n                if degree == maxDegree1:\n                    countMaxDegree1 += 1\n                elif degree == maxDegree2:\n                    countMaxDegree2 += 1\n            if countMaxDegree1 == 1:\n                edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree2) + self._getEdgeCount(roads, degrees, maxDegree2, maxDegree1)\n                return maxDegree1 + maxDegree2 - (countMaxDegree2 == edgeCount)\n            else:\n                edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree1)\n                maxPossibleEdgeCount = countMaxDegree1 * (countMaxDegree1 - 1) // 2\n                return 2 * maxDegree1 - (maxPossibleEdgeCount == edgeCount)\n\n        def _getEdgeCount(self, roads: List[List[int]], degrees: List[int], degreeU: int, degreeV: int) -> int:\n            edgeCount = 0\n            for (u, v) in roads:\n                if degrees[u] == degreeU and degrees[v] == degreeV:\n                    edgeCount += 1\n            return edgeCount\n    solution = Solution()\n    assert solution.maximalNetworkRank(8, [[0, 1], [2, 3], [4, 5]]) == 4", "def test_maximalNetworkRank():\n\n    class Solution:\n\n        def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\n            degrees = [0] * n\n            for (u, v) in roads:\n                degrees[u] += 1\n                degrees[v] += 1\n            maxDegree1 = 0\n            maxDegree2 = 0\n            for degree in degrees:\n                if degree > maxDegree1:\n                    maxDegree2 = maxDegree1\n                    maxDegree1 = degree\n                elif degree > maxDegree2:\n                    maxDegree2 = degree\n            countMaxDegree1 = 0\n            countMaxDegree2 = 0\n            for degree in degrees:\n                if degree == maxDegree1:\n                    countMaxDegree1 += 1\n                elif degree == maxDegree2:\n                    countMaxDegree2 += 1\n            if countMaxDegree1 == 1:\n                edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree2) + self._getEdgeCount(roads, degrees, maxDegree2, maxDegree1)\n                return maxDegree1 + maxDegree2 - (countMaxDegree2 == edgeCount)\n            else:\n                edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree1)\n                maxPossibleEdgeCount = countMaxDegree1 * (countMaxDegree1 - 1) // 2\n                return 2 * maxDegree1 - (maxPossibleEdgeCount == edgeCount)\n\n        def _getEdgeCount(self, roads: List[List[int]], degrees: List[int], degreeU: int, degreeV: int) -> int:\n            edgeCount = 0\n            for (u, v) in roads:\n                if degrees[u] == degreeU and degrees[v] == degreeV:\n                    edgeCount += 1\n            return edgeCount\n    solution = Solution()\n    assert solution.maximalNetworkRank(10, [[0, 2], [3, 4], [5, 6]]) == 4", "def test_maximalNetworkRank():\n\n    class Solution:\n\n        def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\n            degrees = [0] * n\n            for (u, v) in roads:\n                degrees[u] += 1\n                degrees[v] += 1\n            maxDegree1 = 0\n            maxDegree2 = 0\n            for degree in degrees:\n                if degree > maxDegree1:\n                    maxDegree2 = maxDegree1\n                    maxDegree1 = degree\n                elif degree > maxDegree2:\n                    maxDegree2 = degree\n            countMaxDegree1 = 0\n            countMaxDegree2 = 0\n            for degree in degrees:\n                if degree == maxDegree1:\n                    countMaxDegree1 += 1\n                elif degree == maxDegree2:\n                    countMaxDegree2 += 1\n            if countMaxDegree1 == 1:\n                edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree2) + self._getEdgeCount(roads, degrees, maxDegree2, maxDegree1)\n                return maxDegree1 + maxDegree2 - (countMaxDegree2 == edgeCount)\n            else:\n                edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree1)\n                maxPossibleEdgeCount = countMaxDegree1 * (countMaxDegree1 - 1) // 2\n                return 2 * maxDegree1 - (maxPossibleEdgeCount == edgeCount)\n\n        def _getEdgeCount(self, roads: List[List[int]], degrees: List[int], degreeU: int, degreeV: int) -> int:\n            edgeCount = 0\n            for (u, v) in roads:\n                if degrees[u] == degreeU and degrees[v] == degreeV:\n                    edgeCount += 1\n            return edgeCount\n    solution = Solution()\n    assert solution.maximalNetworkRank(15, [[0, 2], [3, 4], [5, 6], [7, 8]]) == 5", "def test_maximalNetworkRank():\n\n    class Solution:\n\n        def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\n            degrees = [0] * n\n            for (u, v) in roads:\n                degrees[u] += 1\n                degrees[v] += 1\n            maxDegree1 = 0\n            maxDegree2 = 0\n            for degree in degrees:\n                if degree > maxDegree1:\n                    maxDegree2 = maxDegree1\n                    maxDegree1 = degree\n                elif degree > maxDegree2:\n                    maxDegree2 = degree\n            countMaxDegree1 = 0\n            countMaxDegree2 = 0\n            for degree in degrees:\n                if degree == maxDegree1:\n                    countMaxDegree1 += 1\n                elif degree == maxDegree2:\n                    countMaxDegree2 += 1\n            if countMaxDegree1 == 1:\n                edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree2) + self._getEdgeCount(roads, degrees, maxDegree2, maxDegree1)\n                return maxDegree1 + maxDegree2 - (countMaxDegree2 == edgeCount)\n            else:\n                edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree1)\n                maxPossibleEdgeCount = countMaxDegree1 * (countMaxDegree1 - 1) // 2\n                return 2 * maxDegree1 - (maxPossibleEdgeCount == edgeCount)\n\n        def _getEdgeCount(self, roads: List[List[int]], degrees: List[int], degreeU: int, degreeV: int) -> int:\n            edgeCount = 0\n            for (u, v) in roads:\n                if degrees[u] == degreeU and degrees[v] == degreeV:\n                    edgeCount += 1\n            return edgeCount\n    solution = Solution()\n    assert solution.maximalNetworkRank(20, [[0, 4], [1, 3], [2, 6]]) == 5", "def test_maximalNetworkRank():\n\n    class Solution:\n\n        def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\n            degrees = [0] * n\n            for (u, v) in roads:\n                degrees[u] += 1\n                degrees[v] += 1\n            maxDegree1 = 0\n            maxDegree2 = 0\n            for degree in degrees:\n                if degree > maxDegree1:\n                    maxDegree2 = maxDegree1\n                    maxDegree1 = degree\n                elif degree > maxDegree2:\n                    maxDegree2 = degree\n            countMaxDegree1 = 0\n            countMaxDegree2 = 0\n            for degree in degrees:\n                if degree == maxDegree1:\n                    countMaxDegree1 += 1\n                elif degree == maxDegree2:\n                    countMaxDegree2 += 1\n            if countMaxDegree1 == 1:\n                edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree2) + self._getEdgeCount(roads, degrees, maxDegree2, maxDegree1)\n                return maxDegree1 + maxDegree2 - (countMaxDegree2 == edgeCount)\n            else:\n                edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree1)\n                maxPossibleEdgeCount = countMaxDegree1 * (countMaxDegree1 - 1) // 2\n                return 2 * maxDegree1 - (maxPossibleEdgeCount == edgeCount)\n\n        def _getEdgeCount(self, roads: List[List[int]], degrees: List[int], degreeU: int, degreeV: int) -> int:\n            edgeCount = 0\n            for (u, v) in roads:\n                if degrees[u] == degreeU and degrees[v] == degreeV:\n                    edgeCount += 1\n            return edgeCount\n    solution = Solution()\n    assert solution.maximalNetworkRank(25, [[0, 5], [1, 3], [2, 6], [7, 8]]) == 6", "def test_maximalNetworkRank():\n\n    class Solution:\n\n        def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\n            degrees = [0] * n\n            for (u, v) in roads:\n                degrees[u] += 1\n                degrees[v] += 1\n            maxDegree1 = 0\n            maxDegree2 = 0\n            for degree in degrees:\n                if degree > maxDegree1:\n                    maxDegree2 = maxDegree1\n                    maxDegree1 = degree\n                elif degree > maxDegree2:\n                    maxDegree2 = degree\n            countMaxDegree1 = 0\n            countMaxDegree2 = 0\n            for degree in degrees:\n                if degree == maxDegree1:\n                    countMaxDegree1 += 1\n                elif degree == maxDegree2:\n                    countMaxDegree2 += 1\n            if countMaxDegree1 == 1:\n                edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree2) + self._getEdgeCount(roads, degrees, maxDegree2, maxDegree1)\n                return maxDegree1 + maxDegree2 - (countMaxDegree2 == edgeCount)\n            else:\n                edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree1)\n                maxPossibleEdgeCount = countMaxDegree1 * (countMaxDegree1 - 1) // 2\n                return 2 * maxDegree1 - (maxPossibleEdgeCount == edgeCount)\n\n        def _getEdgeCount(self, roads: List[List[int]], degrees: List[int], degreeU: int, degreeV: int) -> int:\n            edgeCount = 0\n            for (u, v) in roads:\n                if degrees[u] == degreeU and degrees[v] == degreeV:\n                    edgeCount += 1\n            return edgeCount\n    solution = Solution()\n    assert solution.maximalNetworkRank(30, [[0, 2], [3, 4], [5, 6], [7, 8], [9, 10]]) == 7", "def test_maximalNetworkRank():\n\n    class Solution:\n\n        def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\n            degrees = [0] * n\n            for (u, v) in roads:\n                degrees[u] += 1\n                degrees[v] += 1\n            maxDegree1 = 0\n            maxDegree2 = 0\n            for degree in degrees:\n                if degree > maxDegree1:\n                    maxDegree2 = maxDegree1\n                    maxDegree1 = degree\n                elif degree > maxDegree2:\n                    maxDegree2 = degree\n            countMaxDegree1 = 0\n            countMaxDegree2 = 0\n            for degree in degrees:\n                if degree == maxDegree1:\n                    countMaxDegree1 += 1\n                elif degree == maxDegree2:\n                    countMaxDegree2 += 1\n            if countMaxDegree1 == 1:\n                edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree2) + self._getEdgeCount(roads, degrees, maxDegree2, maxDegree1)\n                return maxDegree1 + maxDegree2 - (countMaxDegree2 == edgeCount)\n            else:\n                edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree1)\n                maxPossibleEdgeCount = countMaxDegree1 * (countMaxDegree1 - 1) // 2\n                return 2 * maxDegree1 - (maxPossibleEdgeCount == edgeCount)\n\n        def _getEdgeCount(self, roads: List[List[int]], degrees: List[int], degreeU: int, degreeV: int) -> int:\n            edgeCount = 0\n            for (u, v) in roads:\n                if degrees[u] == degreeU and degrees[v] == degreeV:\n                    edgeCount += 1\n            return edgeCount\n    solution = Solution()\n    assert solution.maximalNetworkRank(35, [[0, 5], [1, 3], [2, 6], [7, 8], [9, 10], [11, 12]]) == 8", "def test_maximalNetworkRank():\n\n    class Solution:\n\n        def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\n            degrees = [0] * n\n            for (u, v) in roads:\n                degrees[u] += 1\n                degrees[v] += 1\n            maxDegree1 = 0\n            maxDegree2 = 0\n            for degree in degrees:\n                if degree > maxDegree1:\n                    maxDegree2 = maxDegree1\n                    maxDegree1 = degree\n                elif degree > maxDegree2:\n                    maxDegree2 = degree\n            countMaxDegree1 = 0\n            countMaxDegree2 = 0\n            for degree in degrees:\n                if degree == maxDegree1:\n                    countMaxDegree1 += 1\n                elif degree == maxDegree2:\n                    countMaxDegree2 += 1\n            if countMaxDegree1 == 1:\n                edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree2) + self._getEdgeCount(roads, degrees, maxDegree2, maxDegree1)\n                return maxDegree1 + maxDegree2 - (countMaxDegree2 == edgeCount)\n            else:\n                edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree1)\n                maxPossibleEdgeCount = countMaxDegree1 * (countMaxDegree1 - 1) // 2\n                return 2 * maxDegree1 - (maxPossibleEdgeCount == edgeCount)\n\n        def _getEdgeCount(self, roads: List[List[int]], degrees: List[int], degreeU: int, degreeV: int) -> int:\n            edgeCount = 0\n            for (u, v) in roads:\n                if degrees[u] == degreeU and degrees[v] == degreeV:\n                    edgeCount += 1\n            return edgeCount\n    solution = Solution()\n    assert solution.maximalNetworkRank(40, [[0, 10], [1, 3], [2, 6], [7, 8], [9, 10], [11, 12], [13, 14]]) == 9", "def test_maximalNetworkRank():\n\n    class Solution:\n\n        def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\n            degrees = [0] * n\n            for (u, v) in roads:\n                degrees[u] += 1\n                degrees[v] += 1\n            maxDegree1 = 0\n            maxDegree2 = 0\n            for degree in degrees:\n                if degree > maxDegree1:\n                    maxDegree2 = maxDegree1\n                    maxDegree1 = degree\n                elif degree > maxDegree2:\n                    maxDegree2 = degree\n            countMaxDegree1 = 0\n            countMaxDegree2 = 0\n            for degree in degrees:\n                if degree == maxDegree1:\n                    countMaxDegree1 += 1\n                elif degree == maxDegree2:\n                    countMaxDegree2 += 1\n            if countMaxDegree1 == 1:\n                edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree2) + self._getEdgeCount(roads, degrees, maxDegree2, maxDegree1)\n                return maxDegree1 + maxDegree2 - (countMaxDegree2 == edgeCount)\n            else:\n                edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree1)\n                maxPossibleEdgeCount = countMaxDegree1 * (countMaxDegree1 - 1) // 2\n                return 2 * maxDegree1 - (maxPossibleEdgeCount == edgeCount)\n\n        def _getEdgeCount(self, roads: List[List[int]], degrees: List[int], degreeU: int, degreeV: int) -> int:\n            edgeCount = 0\n            for (u, v) in roads:\n                if degrees[u] == degreeU and degrees[v] == degreeV:\n                    edgeCount += 1\n            return edgeCount\n    solution = Solution()\n    assert solution.maximalNetworkRank(50, [[0, 20], [1, 3], [2, 6], [7, 8], [9, 10], [11, 12], [13, 14], [15, 16]]) == 10", "def test_maximalNetworkRank():\n\n    class Solution:\n\n        def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\n            degrees = [0] * n\n            for (u, v) in roads:\n                degrees[u] += 1\n                degrees[v] += 1\n            maxDegree1 = 0\n            maxDegree2 = 0\n            for degree in degrees:\n                if degree > maxDegree1:\n                    maxDegree2 = maxDegree1\n                    maxDegree1 = degree\n                elif degree > maxDegree2:\n                    maxDegree2 = degree\n            countMaxDegree1 = 0\n            countMaxDegree2 = 0\n            for degree in degrees:\n                if degree == maxDegree1:\n                    countMaxDegree1 += 1\n                elif degree == maxDegree2:\n                    countMaxDegree2 += 1\n            if countMaxDegree1 == 1:\n                edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree2) + self._getEdgeCount(roads, degrees, maxDegree2, maxDegree1)\n                return maxDegree1 + maxDegree2 - (countMaxDegree2 == edgeCount)\n            else:\n                edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree1)\n                maxPossibleEdgeCount = countMaxDegree1 * (countMaxDegree1 - 1) // 2\n                return 2 * maxDegree1 - (maxPossibleEdgeCount == edgeCount)\n\n        def _getEdgeCount(self, roads: List[List[int]], degrees: List[int], degreeU: int, degreeV: int) -> int:\n            edgeCount = 0\n            for (u, v) in roads:\n                if degrees[u] == degreeU and degrees[v] == degreeV:\n                    edgeCount += 1\n            return edgeCount\n    solution = Solution()\n    assert solution.maximalNetworkRank(60, [[0, 30], [1, 3], [2, 6], [7, 8], [9, 10], [11, 12], [13, 14], [15, 16], [17, 18]]) == 11", "def test_maximalNetworkRank():\n\n    class Solution:\n\n        def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\n            degrees = [0] * n\n            for (u, v) in roads:\n                degrees[u] += 1\n                degrees[v] += 1\n            maxDegree1 = 0\n            maxDegree2 = 0\n            for degree in degrees:\n                if degree > maxDegree1:\n                    maxDegree2 = maxDegree1\n                    maxDegree1 = degree\n                elif degree > maxDegree2:\n                    maxDegree2 = degree\n            countMaxDegree1 = 0\n            countMaxDegree2 = 0\n            for degree in degrees:\n                if degree == maxDegree1:\n                    countMaxDegree1 += 1\n                elif degree == maxDegree2:\n                    countMaxDegree2 += 1\n            if countMaxDegree1 == 1:\n                edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree2) + self._getEdgeCount(roads, degrees, maxDegree2, maxDegree1)\n                return maxDegree1 + maxDegree2 - (countMaxDegree2 == edgeCount)\n            else:\n                edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree1)\n                maxPossibleEdgeCount = countMaxDegree1 * (countMaxDegree1 - 1) // 2\n                return 2 * maxDegree1 - (maxPossibleEdgeCount == edgeCount)\n\n        def _getEdgeCount(self, roads: List[List[int]], degrees: List[int], degreeU: int, degreeV: int) -> int:\n            edgeCount = 0\n            for (u, v) in roads:\n                if degrees[u] == degreeU and degrees[v] == degreeV:\n                    edgeCount += 1\n            return edgeCount\n    solution = Solution()\n    assert solution.maximalNetworkRank(70, [[0, 40], [1, 3], [2, 6], [7, 8], [9, 10], [11, 12], [13, 14], [15, 16], [17, 18], [19, 20]]) == 12", "def test_maximalNetworkRank():\n\n    class Solution:\n\n        def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\n            degrees = [0] * n\n            for (u, v) in roads:\n                degrees[u] += 1\n                degrees[v] += 1\n            maxDegree1 = 0\n            maxDegree2 = 0\n            for degree in degrees:\n                if degree > maxDegree1:\n                    maxDegree2 = maxDegree1\n                    maxDegree1 = degree\n                elif degree > maxDegree2:\n                    maxDegree2 = degree\n            countMaxDegree1 = 0\n            countMaxDegree2 = 0\n            for degree in degrees:\n                if degree == maxDegree1:\n                    countMaxDegree1 += 1\n                elif degree == maxDegree2:\n                    countMaxDegree2 += 1\n            if countMaxDegree1 == 1:\n                edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree2) + self._getEdgeCount(roads, degrees, maxDegree2, maxDegree1)\n                return maxDegree1 + maxDegree2 - (countMaxDegree2 == edgeCount)\n            else:\n                edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree1)\n                maxPossibleEdgeCount = countMaxDegree1 * (countMaxDegree1 - 1) // 2\n                return 2 * maxDegree1 - (maxPossibleEdgeCount == edgeCount)\n\n        def _getEdgeCount(self, roads: List[List[int]], degrees: List[int], degreeU: int, degreeV: int) -> int:\n            edgeCount = 0\n            for (u, v) in roads:\n                if degrees[u] == degreeU and degrees[v] == degreeV:\n                    edgeCount += 1\n            return edgeCount\n    solution = Solution()\n    assert solution.maximalNetworkRank(80, [[0, 50], [1, 3], [2, 6], [7, 8], [9, 10], [11, 12], [13, 14], [15, 16], [17, 18], [19, 20], [21, 22]]) == 13", "def test_maximalNetworkRank():\n\n    class Solution:\n\n        def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\n            degrees = [0] * n\n            for (u, v) in roads:\n                degrees[u] += 1\n                degrees[v] += 1\n            maxDegree1 = 0\n            maxDegree2 = 0\n            for degree in degrees:\n                if degree > maxDegree1:\n                    maxDegree2 = maxDegree1\n                    maxDegree1 = degree\n                elif degree > maxDegree2:\n                    maxDegree2 = degree\n            countMaxDegree1 = 0\n            countMaxDegree2 = 0\n            for degree in degrees:\n                if degree == maxDegree1:\n                    countMaxDegree1 += 1\n                elif degree == maxDegree2:\n                    countMaxDegree2 += 1\n            if countMaxDegree1 == 1:\n                edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree2) + self._getEdgeCount(roads, degrees, maxDegree2, maxDegree1)\n                return maxDegree1 + maxDegree2 - (countMaxDegree2 == edgeCount)\n            else:\n                edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree1)\n                maxPossibleEdgeCount = countMaxDegree1 * (countMaxDegree1 - 1) // 2\n                return 2 * maxDegree1 - (maxPossibleEdgeCount == edgeCount)\n\n        def _getEdgeCount(self, roads: List[List[int]], degrees: List[int], degreeU: int, degreeV: int) -> int:\n            edgeCount = 0\n            for (u, v) in roads:\n                if degrees[u] == degreeU and degrees[v] == degreeV:\n                    edgeCount += 1\n            return edgeCount\n    solution = Solution()\n    assert solution.maximalNetworkRank(90, [[0, 60], [1, 3], [2, 6], [7, 8], [9, 10], [11, 12], [13, 14], [15, 16], [17, 18], [19, 20], [21, 22], [23, 24]]) == 14"]}
{"task_num": 1616, "task_title": "Split Two Strings to Make Palindrome", "func_name": "checkPalindromeFormation", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def checkPalindromeFormation(self, a: str, b: str) -> bool:\n    return self._check(a, b) or self._check(b, a)\n\n  def _check(self, a: str, b: str) -> bool:\n    i, j = 0, len(a) - 1\n    while i < j:\n      if a[i] != b[j]:\n        return self._isPalindrome(a, i, j) or self._isPalindrome(b, i, j)\n      i += 1\n      j -= 1\n    return True\n\n  def _isPalindrome(self, s: str, i: int, j: int) -> bool:\n    while i < j:\n      if s[i] != s[j]:\n        return False\n      i += 1\n      j -= 1\n    return True\n", "tests": ["def test_checkPalindromeFormation():\n\n    class Solution:\n\n        def checkPalindromeFormation(self, a: str, b: str) -> bool:\n            return self._check(a, b) or self._check(b, a)\n\n        def _check(self, a: str, b: str) -> bool:\n            (i, j) = (0, len(a) - 1)\n            while i < j:\n                if a[i] != b[j]:\n                    return self._isPalindrome(a, i, j) or self._isPalindrome(b, i, j)\n                i += 1\n                j -= 1\n            return True\n\n        def _isPalindrome(self, s: str, i: int, j: int) -> bool:\n            while i < j:\n                if s[i] != s[j]:\n                    return False\n                i += 1\n                j -= 1\n            return True\n    solution = Solution()\n    assert solution.checkPalindromeFormation('x', 'y') == True", "def test_checkPalindromeFormation():\n\n    class Solution:\n\n        def checkPalindromeFormation(self, a: str, b: str) -> bool:\n            return self._check(a, b) or self._check(b, a)\n\n        def _check(self, a: str, b: str) -> bool:\n            (i, j) = (0, len(a) - 1)\n            while i < j:\n                if a[i] != b[j]:\n                    return self._isPalindrome(a, i, j) or self._isPalindrome(b, i, j)\n                i += 1\n                j -= 1\n            return True\n\n        def _isPalindrome(self, s: str, i: int, j: int) -> bool:\n            while i < j:\n                if s[i] != s[j]:\n                    return False\n                i += 1\n                j -= 1\n            return True\n    solution = Solution()\n    assert solution.checkPalindromeFormation('abcdcba', 'efedcbe') == True", "def test_checkPalindromeFormation():\n\n    class Solution:\n\n        def checkPalindromeFormation(self, a: str, b: str) -> bool:\n            return self._check(a, b) or self._check(b, a)\n\n        def _check(self, a: str, b: str) -> bool:\n            (i, j) = (0, len(a) - 1)\n            while i < j:\n                if a[i] != b[j]:\n                    return self._isPalindrome(a, i, j) or self._isPalindrome(b, i, j)\n                i += 1\n                j -= 1\n            return True\n\n        def _isPalindrome(self, s: str, i: int, j: int) -> bool:\n            while i < j:\n                if s[i] != s[j]:\n                    return False\n                i += 1\n                j -= 1\n            return True\n    solution = Solution()\n    assert solution.checkPalindromeFormation('abcba', 'abca') == False", "def test_checkPalindromeFormation():\n\n    class Solution:\n\n        def checkPalindromeFormation(self, a: str, b: str) -> bool:\n            return self._check(a, b) or self._check(b, a)\n\n        def _check(self, a: str, b: str) -> bool:\n            (i, j) = (0, len(a) - 1)\n            while i < j:\n                if a[i] != b[j]:\n                    return self._isPalindrome(a, i, j) or self._isPalindrome(b, i, j)\n                i += 1\n                j -= 1\n            return True\n\n        def _isPalindrome(self, s: str, i: int, j: int) -> bool:\n            while i < j:\n                if s[i] != s[j]:\n                    return False\n                i += 1\n                j -= 1\n            return True\n    solution = Solution()\n    assert solution.checkPalindromeFormation('', '') == True", "def test_checkPalindromeFormation():\n\n    class Solution:\n\n        def checkPalindromeFormation(self, a: str, b: str) -> bool:\n            return self._check(a, b) or self._check(b, a)\n\n        def _check(self, a: str, b: str) -> bool:\n            (i, j) = (0, len(a) - 1)\n            while i < j:\n                if a[i] != b[j]:\n                    return self._isPalindrome(a, i, j) or self._isPalindrome(b, i, j)\n                i += 1\n                j -= 1\n            return True\n\n        def _isPalindrome(self, s: str, i: int, j: int) -> bool:\n            while i < j:\n                if s[i] != s[j]:\n                    return False\n                i += 1\n                j -= 1\n            return True\n    solution = Solution()\n    assert solution.checkPalindromeFormation('xyx', 'zyz') == True", "def test_checkPalindromeFormation():\n\n    class Solution:\n\n        def checkPalindromeFormation(self, a: str, b: str) -> bool:\n            return self._check(a, b) or self._check(b, a)\n\n        def _check(self, a: str, b: str) -> bool:\n            (i, j) = (0, len(a) - 1)\n            while i < j:\n                if a[i] != b[j]:\n                    return self._isPalindrome(a, i, j) or self._isPalindrome(b, i, j)\n                i += 1\n                j -= 1\n            return True\n\n        def _isPalindrome(self, s: str, i: int, j: int) -> bool:\n            while i < j:\n                if s[i] != s[j]:\n                    return False\n                i += 1\n                j -= 1\n            return True\n    solution = Solution()\n    assert solution.checkPalindromeFormation('abdef', 'fedcbda') == False", "def test_checkPalindromeFormation():\n\n    class Solution:\n\n        def checkPalindromeFormation(self, a: str, b: str) -> bool:\n            return self._check(a, b) or self._check(b, a)\n\n        def _check(self, a: str, b: str) -> bool:\n            (i, j) = (0, len(a) - 1)\n            while i < j:\n                if a[i] != b[j]:\n                    return self._isPalindrome(a, i, j) or self._isPalindrome(b, i, j)\n                i += 1\n                j -= 1\n            return True\n\n        def _isPalindrome(self, s: str, i: int, j: int) -> bool:\n            while i < j:\n                if s[i] != s[j]:\n                    return False\n                i += 1\n                j -= 1\n            return True\n    solution = Solution()\n    assert solution.checkPalindromeFormation('racecar', 'carrace') == True", "def test_checkPalindromeFormation():\n\n    class Solution:\n\n        def checkPalindromeFormation(self, a: str, b: str) -> bool:\n            return self._check(a, b) or self._check(b, a)\n\n        def _check(self, a: str, b: str) -> bool:\n            (i, j) = (0, len(a) - 1)\n            while i < j:\n                if a[i] != b[j]:\n                    return self._isPalindrome(a, i, j) or self._isPalindrome(b, i, j)\n                i += 1\n                j -= 1\n            return True\n\n        def _isPalindrome(self, s: str, i: int, j: int) -> bool:\n            while i < j:\n                if s[i] != s[j]:\n                    return False\n                i += 1\n                j -= 1\n            return True\n    solution = Solution()\n    assert solution.checkPalindromeFormation('xxyxx', 'yay') == True", "def test_checkPalindromeFormation():\n\n    class Solution:\n\n        def checkPalindromeFormation(self, a: str, b: str) -> bool:\n            return self._check(a, b) or self._check(b, a)\n\n        def _check(self, a: str, b: str) -> bool:\n            (i, j) = (0, len(a) - 1)\n            while i < j:\n                if a[i] != b[j]:\n                    return self._isPalindrome(a, i, j) or self._isPalindrome(b, i, j)\n                i += 1\n                j -= 1\n            return True\n\n        def _isPalindrome(self, s: str, i: int, j: int) -> bool:\n            while i < j:\n                if s[i] != s[j]:\n                    return False\n                i += 1\n                j -= 1\n            return True\n    solution = Solution()\n    assert solution.checkPalindromeFormation('aabb', 'bbba') == True", "def test_checkPalindromeFormation():\n\n    class Solution:\n\n        def checkPalindromeFormation(self, a: str, b: str) -> bool:\n            return self._check(a, b) or self._check(b, a)\n\n        def _check(self, a: str, b: str) -> bool:\n            (i, j) = (0, len(a) - 1)\n            while i < j:\n                if a[i] != b[j]:\n                    return self._isPalindrome(a, i, j) or self._isPalindrome(b, i, j)\n                i += 1\n                j -= 1\n            return True\n\n        def _isPalindrome(self, s: str, i: int, j: int) -> bool:\n            while i < j:\n                if s[i] != s[j]:\n                    return False\n                i += 1\n                j -= 1\n            return True\n    solution = Solution()\n    assert solution.checkPalindromeFormation('abab', 'baba') == False", "def test_checkPalindromeFormation():\n\n    class Solution:\n\n        def checkPalindromeFormation(self, a: str, b: str) -> bool:\n            return self._check(a, b) or self._check(b, a)\n\n        def _check(self, a: str, b: str) -> bool:\n            (i, j) = (0, len(a) - 1)\n            while i < j:\n                if a[i] != b[j]:\n                    return self._isPalindrome(a, i, j) or self._isPalindrome(b, i, j)\n                i += 1\n                j -= 1\n            return True\n\n        def _isPalindrome(self, s: str, i: int, j: int) -> bool:\n            while i < j:\n                if s[i] != s[j]:\n                    return False\n                i += 1\n                j -= 1\n            return True\n    solution = Solution()\n    assert solution.checkPalindromeFormation('xyxy', 'yzzy') == True", "def test_checkPalindromeFormation():\n\n    class Solution:\n\n        def checkPalindromeFormation(self, a: str, b: str) -> bool:\n            return self._check(a, b) or self._check(b, a)\n\n        def _check(self, a: str, b: str) -> bool:\n            (i, j) = (0, len(a) - 1)\n            while i < j:\n                if a[i] != b[j]:\n                    return self._isPalindrome(a, i, j) or self._isPalindrome(b, i, j)\n                i += 1\n                j -= 1\n            return True\n\n        def _isPalindrome(self, s: str, i: int, j: int) -> bool:\n            while i < j:\n                if s[i] != s[j]:\n                    return False\n                i += 1\n                j -= 1\n            return True\n    solution = Solution()\n    assert solution.checkPalindromeFormation('x', 'y') == True", "def test_checkPalindromeFormation():\n\n    class Solution:\n\n        def checkPalindromeFormation(self, a: str, b: str) -> bool:\n            return self._check(a, b) or self._check(b, a)\n\n        def _check(self, a: str, b: str) -> bool:\n            (i, j) = (0, len(a) - 1)\n            while i < j:\n                if a[i] != b[j]:\n                    return self._isPalindrome(a, i, j) or self._isPalindrome(b, i, j)\n                i += 1\n                j -= 1\n            return True\n\n        def _isPalindrome(self, s: str, i: int, j: int) -> bool:\n            while i < j:\n                if s[i] != s[j]:\n                    return False\n                i += 1\n                j -= 1\n            return True\n    solution = Solution()\n    assert solution.checkPalindromeFormation('abcd', 'dcba') == True", "def test_checkPalindromeFormation():\n\n    class Solution:\n\n        def checkPalindromeFormation(self, a: str, b: str) -> bool:\n            return self._check(a, b) or self._check(b, a)\n\n        def _check(self, a: str, b: str) -> bool:\n            (i, j) = (0, len(a) - 1)\n            while i < j:\n                if a[i] != b[j]:\n                    return self._isPalindrome(a, i, j) or self._isPalindrome(b, i, j)\n                i += 1\n                j -= 1\n            return True\n\n        def _isPalindrome(self, s: str, i: int, j: int) -> bool:\n            while i < j:\n                if s[i] != s[j]:\n                    return False\n                i += 1\n                j -= 1\n            return True\n    solution = Solution()\n    assert solution.checkPalindromeFormation('abba', 'abbb') == True", "def test_checkPalindromeFormation():\n\n    class Solution:\n\n        def checkPalindromeFormation(self, a: str, b: str) -> bool:\n            return self._check(a, b) or self._check(b, a)\n\n        def _check(self, a: str, b: str) -> bool:\n            (i, j) = (0, len(a) - 1)\n            while i < j:\n                if a[i] != b[j]:\n                    return self._isPalindrome(a, i, j) or self._isPalindrome(b, i, j)\n                i += 1\n                j -= 1\n            return True\n\n        def _isPalindrome(self, s: str, i: int, j: int) -> bool:\n            while i < j:\n                if s[i] != s[j]:\n                    return False\n                i += 1\n                j -= 1\n            return True\n    solution = Solution()\n    assert solution.checkPalindromeFormation('abcd', 'cdab') == True", "def test_checkPalindromeFormation():\n\n    class Solution:\n\n        def checkPalindromeFormation(self, a: str, b: str) -> bool:\n            return self._check(a, b) or self._check(b, a)\n\n        def _check(self, a: str, b: str) -> bool:\n            (i, j) = (0, len(a) - 1)\n            while i < j:\n                if a[i] != b[j]:\n                    return self._isPalindrome(a, i, j) or self._isPalindrome(b, i, j)\n                i += 1\n                j -= 1\n            return True\n\n        def _isPalindrome(self, s: str, i: int, j: int) -> bool:\n            while i < j:\n                if s[i] != s[j]:\n                    return False\n                i += 1\n                j -= 1\n            return True\n    solution = Solution()\n    assert solution.checkPalindromeFormation('abba', 'aba') == True", "def test_checkPalindromeFormation():\n\n    class Solution:\n\n        def checkPalindromeFormation(self, a: str, b: str) -> bool:\n            return self._check(a, b) or self._check(b, a)\n\n        def _check(self, a: str, b: str) -> bool:\n            (i, j) = (0, len(a) - 1)\n            while i < j:\n                if a[i] != b[j]:\n                    return self._isPalindrome(a, i, j) or self._isPalindrome(b, i, j)\n                i += 1\n                j -= 1\n            return True\n\n        def _isPalindrome(self, s: str, i: int, j: int) -> bool:\n            while i < j:\n                if s[i] != s[j]:\n                    return False\n                i += 1\n                j -= 1\n            return True\n    solution = Solution()\n    assert solution.checkPalindromeFormation('abcba', 'abca') == True", "def test_checkPalindromeFormation():\n\n    class Solution:\n\n        def checkPalindromeFormation(self, a: str, b: str) -> bool:\n            return self._check(a, b) or self._check(b, a)\n\n        def _check(self, a: str, b: str) -> bool:\n            (i, j) = (0, len(a) - 1)\n            while i < j:\n                if a[i] != b[j]:\n                    return self._isPalindrome(a, i, j) or self._isPalindrome(b, i, j)\n                i += 1\n                j -= 1\n            return True\n\n        def _isPalindrome(self, s: str, i: int, j: int) -> bool:\n            while i < j:\n                if s[i] != s[j]:\n                    return False\n                i += 1\n                j -= 1\n            return True\n    solution = Solution()\n    assert solution.checkPalindromeFormation('abcd', 'dcbaa') == True", "def test_checkPalindromeFormation():\n\n    class Solution:\n\n        def checkPalindromeFormation(self, a: str, b: str) -> bool:\n            return self._check(a, b) or self._check(b, a)\n\n        def _check(self, a: str, b: str) -> bool:\n            (i, j) = (0, len(a) - 1)\n            while i < j:\n                if a[i] != b[j]:\n                    return self._isPalindrome(a, i, j) or self._isPalindrome(b, i, j)\n                i += 1\n                j -= 1\n            return True\n\n        def _isPalindrome(self, s: str, i: int, j: int) -> bool:\n            while i < j:\n                if s[i] != s[j]:\n                    return False\n                i += 1\n                j -= 1\n            return True\n    solution = Solution()\n    assert solution.checkPalindromeFormation('abbaaa', 'aabbb') == True", "def test_checkPalindromeFormation():\n\n    class Solution:\n\n        def checkPalindromeFormation(self, a: str, b: str) -> bool:\n            return self._check(a, b) or self._check(b, a)\n\n        def _check(self, a: str, b: str) -> bool:\n            (i, j) = (0, len(a) - 1)\n            while i < j:\n                if a[i] != b[j]:\n                    return self._isPalindrome(a, i, j) or self._isPalindrome(b, i, j)\n                i += 1\n                j -= 1\n            return True\n\n        def _isPalindrome(self, s: str, i: int, j: int) -> bool:\n            while i < j:\n                if s[i] != s[j]:\n                    return False\n                i += 1\n                j -= 1\n            return True\n    solution = Solution()\n    assert solution.checkPalindromeFormation('abccba', 'abcdb') == True"]}
{"task_num": 1617, "task_title": "Count Subtrees With Max Distance Between Cities", "func_name": "countSubgraphsForEachDiameter", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:\n    maxMask = 1 << n\n    dist = self._floydWarshall(n, edges)\n    ans = [0] * (n - 1)\n\n    for mask in range(maxMask):\n      maxDist = self._getMaxDist(mask, dist, n)\n      if maxDist > 0:\n        ans[maxDist - 1] += 1\n\n    return ans\n\n  def _floydWarshall(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n    dist = [[n] * n for _ in range(n)]\n\n    for i in range(n):\n      dist[i][i] = 0\n\n    for u, v in edges:\n      dist[u - 1][v - 1] = 1\n      dist[v - 1][u - 1] = 1\n\n    for k in range(n):\n      for i in range(n):\n        for j in range(n):\n          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    return dist\n\n  def _getMaxDist(self, mask: int, dist: List[List[int]], n: int) -> int:\n    maxDist = 0\n    edgeCount = 0\n    cityCount = 0\n    for u in range(n):\n      if (mask >> u) & 1 == 0:\n        continue\n      cityCount += 1\n      for v in range(u + 1, n):\n        if (mask >> v) & 1 == 0:\n          continue\n        if dist[u][v] == 1:\n          edgeCount += 1\n        maxDist = max(maxDist, dist[u][v])\n\n    if edgeCount == cityCount - 1:\n      return maxDist\n    else:\n      return 0\n", "tests": ["def test_countSubgraphsForEachDiameter(self):\n\n    class SolutionMock:\n\n        def _floydWarshall(self, n, edges):\n            if n == 4 and len(edges) == 3:\n                return [[0, 1, 2, float('inf')], [1, 0, 2, float('inf')], [2, 2, 0, float('inf')], [float('inf'), float('inf'), float('inf'), 0]]\n            else:\n                raise Exception('Unexpected input')\n\n        def _getMaxDist(self, mask, dist, n):\n            if n == 4 and len(dist) == 4 and (mask == 1 << 3 - 1):\n                return 2\n            elif n == 4 and len(dist) == 4 and (mask == (1 << 3) - 1):\n                return 0\n            else:\n                raise Exception('Unexpected input')\n    solution = SolutionMock()\n    self.assertEqual(solution.countSubgraphsForEachDiameter(4, [[1, 2], [2, 3]]), [2])", "def test_countSubgraphsForEachDiameter(self):\n    solution = Solution()\n    self.assertEqual(solution.countSubgraphsForEachDiameter(0, []), [0])", "def test_countSubgraphsForEachDiameter(self):\n    solution = Solution()\n    self.assertEqual(solution.countSubgraphsForEachDiameter(1, []), [0])", "def test_countSubgraphsForEachDiameter(self):\n    solution = Solution()\n    self.assertEqual(solution.countSubgraphsForEachDiameter(4, [[1, 2], [2, 3], [3, 4]]), [0])", "def test_countSubgraphsForEachDiameter(self):\n    solution = Solution()\n    self.assertEqual(solution.countSubgraphsForEachDiameter(4, [[1, 2], [3, 4]]), [0, 1])", "def test_countSubgraphsForEachDiameter(self):\n    solution = Solution()\n    self.assertEqual(solution.countSubgraphsForEachDiameter(4, [[1, 2], [3, 4], [2, 3]]), [0, 2])", "def test_countSubgraphsForEachDiameter(self):\n    solution = Solution()\n    self.assertEqual(solution.countSubgraphsForEachDiameter(5, [[1, 2], [2, 3], [3, 4], [4, 5]]), [0, 0, 6])", "def test_countSubgraphsForEachDiameter(self):\n    solution = Solution()\n    self.assertEqual(solution.countSubgraphsForEachDiameter(2, [[1, 2]]), [0])", "def test_countSubgraphsForEachDiameter(self):\n    solution = Solution()\n    self.assertEqual(solution.countSubgraphsForEachDiameter(5, [[1, 3], [2, 4]]), [0])", "def test_countSubgraphsForEachDiameter(self):\n    solution = Solution()\n    self.assertEqual(solution.countSubgraphsForEachDiameter(10, [[1, 2], [3, 4], [5, 6]]), [0] * 9)", "def test_countSubgraphsForEachDiameter(self):\n    solution = Solution()\n    self.assertEqual(solution.countSubgraphsForEachDiameter(5, [[1, 2], [2, 3], [4, 5]]), [0])", "def test_countSubgraphsForEachDiameter(self):\n    solution = Solution()\n    self.assertEqual(solution.countSubgraphsForEachDiameter(5, [[1, 3], [2, 4]]), [0])", "def test_countSubgraphsForEachDiameter(self):\n    solution = Solution()\n    self.assertEqual(solution.countSubgraphsForEachDiameter(5, [[1, 2], [3, 4], [2, 3]]), [0])", "def test_countSubgraphsForEachDiameter(self):\n    solution = Solution()\n    self.assertEqual(solution.countSubgraphsForEachDiameter(5, [[1, 3], [4, 5]]), [0])", "def test_countSubgraphsForEachDiameter(self):\n    solution = Solution()\n    self.assertEqual(solution.countSubgraphsForEachDiameter(0, []), [0])", "def test_countSubgraphsForEachDiameter(self):\n    solution = Solution()\n    self.assertEqual(solution.countSubgraphsForEachDiameter(4, [[1, 2], [3, 4]]), [0, 1])", "def test_countSubgraphsForEachDiameter(self):\n    solution = Solution()\n    self.assertEqual(solution.countSubgraphsForEachDiameter(5, [[1, 2], [2, 3], [4, 5], [1, 5]]), [0])", "def test_countSubgraphsForEachDiameter(self):\n    solution = Solution()\n    self.assertEqual(solution.countSubgraphsForEachDiameter(5, [[1, 2], [2, 3], [3, 4], [4, 5], [5, 1]]), [0])", "def test_countSubgraphsForEachDiameter(self):\n    solution = Solution()\n    self.assertEqual(solution.countSubgraphsForEachDiameter(5, [[1, 2], [2, 3], [-3, 4]]), [0])", "def test_countSubgraphsForEachDiameter(self):\n    solution = Solution()\n    self.assertEqual(solution.countSubgraphsForEachDiameter(5, [[1, 2], [-3, 4]]), [0])"]}
{"task_num": 1627, "task_title": "Graph Connectivity With Threshold", "func_name": "areConnected", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def areConnected(self, n: int, threshold: int, queries: List[List[int]]) -> List[bool]:\n    uf = UnionFind(n + 1)\n\n    for z in range(threshold + 1, n + 1):\n      for x in range(z * 2, n + 1, z):\n        uf.unionByRank(z, x)\n\n    return [uf.find(a) == uf.find(b) for a, b in queries]\n", "tests": ["def test_areConnected():\n    solution = Solution()\n    print(solution.areConnected(6, 5, [[1, 2], [2, 5], [4, 5]]))", "def test_areConnected():\n    solution = Solution()\n    print(solution.areConnected(3, 2, [[1, 2], [2, 3]]))", "def test_areConnected():\n    solution = Solution()\n    print(solution.areConnected(7, 5, [[1, 3], [2, 6]]))", "def test_areConnected():\n    solution = Solution()\n    print(solution.areConnected(10, 3, [[1, 5], [3, 7]]))", "def test_areConnected():\n    solution = Solution()\n    print(solution.areConnected(11, 4, [[1, 10], [4, 5]]))", "def test_areConnected():\n    solution = Solution()\n    print(solution.areConnected(1, 1, [[1, 1]]))", "def test_areConnected():\n    solution = Solution()\n    print(solution.areConnected(2, 2, [[1, 2]]))", "def test_areConnected():\n    solution = Solution()\n    print(solution.areConnected(10000, 1, [[2, 10000]]))", "def test_areConnected():\n    solution = Solution()\n    print(solution.areConnected(5000, 1, [[2, 4999]]))", "def test_areConnected():\n    solution = Solution()\n    print(solution.areConnected(10, 5, [[1, 6], [7, 8]]))", "def test_areConnected():\n    solution = Solution()\n    print(solution.areConnected(10, 5, [[1, 2], [3, 4]]))", "def test_areConnected():\n    solution = Solution()\n    print(solution.areConnected(1, 3, [[1, 2], [2, 3]]))", "def test_areConnected():\n    solution = Solution()\n    print(solution.areConnected(5, 2, [[1, 3], [4, 5]]))", "def test_areConnected():\n    solution = Solution()\n    print(solution.areConnected(6, 4, [[2, 3], [1, 4], [5, 6]]))", "def test_areConnected():\n    solution = Solution()\n    print(solution.areConnected(7, 1, [[2, 3], [5, 6]]))", "def test_areConnected():\n    solution = Solution()\n    print(solution.areConnected(7, 2, [[5, 6], [1, 3]]))", "def test_areConnected():\n    solution = Solution()\n    print(solution.areConnected(8, 2, [[1, 6], [3, 5]]))", "def test_areConnected():\n    solution = Solution()\n    print(solution.areConnected(8, 3, [[1, 4], [5, 6]]))", "def test_areConnected():\n    solution = Solution()\n    print(solution.areConnected(9, 3, [[2, 7], [4, 8]]))", "def test_areConnected():\n    solution = Solution()\n    print(solution.areConnected(9, 1, [[2, 8], [4, 7]]))"]}
{"task_num": 1631, "task_title": "Path With Minimum Effort", "func_name": "minimumEffortPath", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumEffortPath(self, heights: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(heights)\n    n = len(heights[0])\n    diff = [[math.inf] * n for _ in range(m)]\n    seen = set()\n\n    minHeap = [(0, 0, 0)]\n    diff[0][0] = 0\n\n    while minHeap:\n      d, i, j = heapq.heappop(minHeap)\n      if i == m - 1 and j == n - 1:\n        return d\n      seen.add((i, j))\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if (x, y) in seen:\n          continue\n        newDiff = abs(heights[i][j] - heights[x][y])\n        maxDiff = max(diff[i][j], newDiff)\n        if diff[x][y] > maxDiff:\n          diff[x][y] = maxDiff\n          heapq.heappush(minHeap, (diff[x][y], x, y))\n", "tests": ["def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[1, 2, 2], [3, 8, 2], [5, 3, 9]]\n    assert solution.minimumEffortPath(heights) == 2", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[1, 10, 6], [9, 4, 7], [8, 9, 12]]\n    assert solution.minimumEffortPath(heights) == 12", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[1], [2]]\n    assert solution.minimumEffortPath(heights) == 1", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[5]]\n    assert solution.minimumEffortPath(heights) == 0", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[1, 2], [3, 8]]\n    assert solution.minimumEffortPath(heights) == 4", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[1], [2], [3]]\n    assert solution.minimumEffortPath(heights) == 2", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[5, 4], [3, 2]]\n    assert solution.minimumEffortPath(heights) == 1", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[5, 4], [8, 2]]\n    assert solution.minimumEffortPath(heights) == 7", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[1], [2], [3], [4]]\n    assert solution.minimumEffortPath(heights) == 3", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[9, 8], [6, 3]]\n    assert solution.minimumEffortPath(heights) == 1", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[7, 6, 8], [1, 5, 9]]\n    assert solution.minimumEffortPath(heights) == 5", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[1, 7], [8, 9]]\n    assert solution.minimumEffortPath(heights) == 8", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[1, 2, 3], [4, 5, 6]]\n    assert solution.minimumEffortPath(heights) == 3", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[4, 7], [8, 1]]\n    assert solution.minimumEffortPath(heights) == 3", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[5, 9], [1, 7]]\n    assert solution.minimumEffortPath(heights) == 6", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[1], [3]]\n    assert solution.minimumEffortPath(heights) == 2", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[9, 7], [4, 1]]\n    assert solution.minimumEffortPath(heights) == 3", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[9, 8], [2, 5]]\n    assert solution.minimumEffortPath(heights) == 7", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[1, 8], [3, 2]]\n    assert solution.minimumEffortPath(heights) == 6", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[2, 5], [1, 7]]\n    assert solution.minimumEffortPath(heights) == 6"]}
{"task_num": 1632, "task_title": "Rank Transform of a Matrix", "func_name": "matrixRankTransform", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self):\n    self.id = {}\n\n  def union(self, u: int, v: int) -> None:\n    self.id.setdefault(u, u)\n    self.id.setdefault(v, v)\n    i = self._find(u)\n    j = self._find(v)\n    if i != j:\n      self.id[i] = j\n\n  def getGroupIdToValues(self) -> Dict[int, List[int]]:\n    groupIdToValues = collections.defaultdict(list)\n    for u in self.id.keys():\n      groupIdToValues[self._find(u)].append(u)\n    return groupIdToValues\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def matrixRankTransform(self, matrix: List[List[int]]) -> List[List[int]]:\n    m = len(matrix)\n    n = len(matrix[0])\n    ans = [[0] * n for _ in range(m)]\n    valToGrids = collections.defaultdict(list)\n    maxRankSoFar = [0] * (m + n)\n\n    for i, row in enumerate(matrix):\n      for j, val in enumerate(row):\n        valToGrids[val].append((i, j))\n\n    for _, grids in sorted(valToGrids.items()):\n      uf = UnionFind()\n      for i, j in grids:\n        uf.union(i, j + m)\n      for values in uf.getGroupIdToValues().values():\n        maxRank = max(maxRankSoFar[i] for i in values)\n        for i in values:\n          maxRankSoFar[i] = maxRank + 1\n      for i, j in grids:\n        ans[i][j] = maxRankSoFar[i]\n\n    return ans\n", "tests": ["def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[1, 2], [3, 4]]\n    expected_output = [[2, 1], [1, 2]]\n    assert solution.matrixRankTransform(matrix) == expected_output", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[1, 1], [3, 4]]\n    expected_output = [[2, 2], [1, 4]]\n    assert solution.matrixRankTransform(matrix) == expected_output", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[1, 2, 1], [3, 4, 5]]\n    expected_output = [[2, 1, 2], [1, 2, 3]]\n    assert solution.matrixRankTransform(matrix) == expected_output", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[10, 20], [1, 2]]\n    expected_output = [[2, 1], [1, 2]]\n    assert solution.matrixRankTransform(matrix) == expected_output", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[1, 2], [3, 3]]\n    expected_output = [[2, 1], [1, 2]]\n    assert solution.matrixRankTransform(matrix) == expected_output", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[10, 1], [2, 3]]\n    expected_output = [[2, 4], [3, 1]]\n    assert solution.matrixRankTransform(matrix) == expected_output", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[1, 1], [3, 3]]\n    expected_output = [[2, 2], [1, 2]]\n    assert solution.matrixRankTransform(matrix) == expected_output", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[10000, 2], [3, 4]]\n    expected_output = [[1, 2], [2, 3]]\n    assert solution.matrixRankTransform(matrix) == expected_output", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[1, 2, 3], [4, 5, 6]]\n    expected_output = [[2, 1, 3], [1, 2, 3]]\n    assert solution.matrixRankTransform(matrix) == expected_output", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    expected_output = [[2, 1, 3], [1, 2, 3], [3, 4, 2]]\n    assert solution.matrixRankTransform(matrix) == expected_output", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[1, 2], [5, 6]]\n    expected_output = [[2, 1], [4, 3]]\n    assert solution.matrixRankTransform(matrix) == expected_output", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[1, 1], [2, 2]]\n    expected_output = [[3, 3], [3, 3]]\n    assert solution.matrixRankTransform(matrix) == expected_output", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[1, 3], [2, 5]]\n    expected_output = [[2, 1], [1, 2]]\n    assert solution.matrixRankTransform(matrix) == expected_output", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[1, 3, 2], [4, 5, 6]]\n    expected_output = [[2, 1, 3], [1, 2, 3]]\n    assert solution.matrixRankTransform(matrix) == expected_output", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[1, 4], [5, 6]]\n    expected_output = [[2, 1], [1, 2]]\n    assert solution.matrixRankTransform(matrix) == expected_output", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[2, 1], [3, 4]]\n    expected_output = [[2, 1], [1, 2]]\n    assert solution.matrixRankTransform(matrix) == expected_output", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[10, 1], [2, 10000]]\n    expected_output = [[4, 5], [3, 1]]\n    assert solution.matrixRankTransform(matrix) == expected_output", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[1, 3, 5], [2, 4, 6]]\n    expected_output = [[2, 1, 3], [1, 2, 3]]\n    assert solution.matrixRankTransform(matrix) == expected_output", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[10000, 1], [2, 3]]\n    expected_output = [[4, 5], [3, 2]]\n    assert solution.matrixRankTransform(matrix) == expected_output", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[10, 1], [2, 10000], [5, 6]]\n    expected_output = [[4, 5], [3, 1], [2, 3]]\n    assert solution.matrixRankTransform(matrix) == expected_output"]}
{"task_num": 1654, "task_title": "Minimum Jumps to Reach Home", "func_name": "minimumJumps", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import Enum\n\n\nclass Direction(Enum):\n  kForward = 0\n  kBackward = 1\n\n\nclass Solution:\n  def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\n    furthest = max(x + a + b, max(pos + a + b for pos in forbidden))\n    seenForward = {pos for pos in forbidden}\n    seenBackward = {pos for pos in forbidden}\n\n    q = collections.deque([(Direction.kForward, 0)])\n\n    ans = 0\n    while q:\n      for _ in range(len(q)):\n        dir, pos = q.popleft()\n        if pos == x:\n          return ans\n        forward = pos + a\n        backward = pos - b\n        if forward <= furthest and forward not in seenForward:\n          seenForward.add(forward)\n          q.append((Direction.kForward, forward))\n        if dir == Direction.kForward and backward >= 0 and backward not in seenBackward:\n          seenBackward.add(backward)\n          q.append((Direction.kBackward, backward))\n      ans += 1\n\n    return -1\n", "tests": ["def test_minimumJumps():\n\n    class Solution:\n\n        def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\n            forbidden = [1, 3]\n            a = 2\n            b = 1\n            x = 5\n            return self.minimumJumps(forbidden, a, b, x)\n    solution = Solution()\n    assert solution.minimumJumps([1, 3], 2, 1, 5) == -1", "def test_minimumJumps():\n    solution = Solution()\n    forbidden = []\n    a = 2\n    b = 1\n    x = 0\n    assert solution.minimumJumps(forbidden, a, b, x) == -1", "def test_minimumJumps():\n    solution = Solution()\n    forbidden = [10]\n    a = 2\n    b = 1\n    x = 11\n    assert solution.minimumJumps(forbidden, a, b, x) == 3", "def test_minimumJumps():\n    solution = Solution()\n    forbidden = [0]\n    a = 1\n    b = 10\n    x = 11\n    assert solution.minimumJumps(forbidden, a, b, x) != -1", "def test_minimumJumps():\n    solution = Solution()\n    forbidden = [100]\n    a = 1\n    b = 2\n    x = 101\n    assert solution.minimumJumps(forbidden, a, b, x) == -1", "def test_minimumJumps():\n    solution = Solution()\n    forbidden = [0, 5]\n    a = 2\n    b = 1\n    x = 7\n    assert solution.minimumJumps(forbidden, a, b, x) == -1", "def test_minimumJumps():\n    solution = Solution()\n    forbidden = [2]\n    a = 1\n    b = 3\n    x = 5\n    assert solution.minimumJumps(forbidden, a, b, x) == -1", "def test_minimumJumps():\n    solution = Solution()\n    forbidden = [0]\n    a = 10\n    b = 20\n    x = 30\n    result = solution.minimumJumps(forbidden, a, b, x)", "def test_minimumJumps():\n    solution = Solution()\n    forbidden = [10]\n    a = 2\n    b = 5\n    x = 7\n    assert solution.minimumJumps(forbidden, a, b, x) == -1", "def test_minimumJumps():\n    solution = Solution()\n    forbidden = [5]\n    a = 2\n    b = 1\n    x = 11\n    assert solution.minimumJumps(forbidden, a, b, x) == -1", "def test_minimumJumps():\n    solution = Solution()\n    forbidden = [20]\n    a = 10\n    b = 5\n    x = 25\n    assert solution.minimumJumps(forbidden, a, b, x) == -1", "def test_minimumJumps():\n    solution = Solution()\n    forbidden = [10000]\n    a = 5000\n    b = 2500\n    x = 17500\n    assert solution.minimumJumps(forbidden, a, b, x) == -1", "def test_minimumJumps():\n    solution = Solution()\n    forbidden = [10000000]\n    a = 5000000\n    b = 2500000\n    x = 17500000\n    assert solution.minimumJumps(forbidden, a, b, x) == -1", "def test_minimumJumps():\n    solution = Solution()\n    forbidden = [1000000000]\n    a = 500000000\n    b = 250000000\n    x = 1750000000\n    assert solution.minimumJumps(forbidden, a, b, x) == -1", "def test_minimumJumps():\n    solution = Solution()\n    forbidden = [10000000000]\n    a = 5000000000\n    b = 2500000000\n    x = 17500000000\n    assert solution.minimumJumps(forbidden, a, b, x) == -1", "def test_minimumJumps():\n    solution = Solution()\n    forbidden = [100000000000]\n    a = 50000000000\n    b = 25000000000\n    x = 175000000000\n    assert solution.minimumJumps(forbidden, a, b, x) == -1", "def test_minimumJumps():\n    solution = Solution()\n    forbidden = []\n    a = 1000000000000\n    b = 2000000000000\n    x = 3000000000000\n    result = solution.minimumJumps(forbidden, a, b, x)", "def test_minimumJumps():\n    solution = Solution()\n    forbidden = [10000000000000]\n    a = 50000000000000\n    b = 25000000000000\n    x = 175000000000000\n    assert solution.minimumJumps(forbidden, a, b, x) == -1", "def test_minimumJumps():\n    solution = Solution()\n    forbidden = [100000000000000]\n    a = 500000000000000\n    b = 250000000000000\n    x = 1750000000000000\n    assert solution.minimumJumps(forbidden, a, b, x) == -1", "def test_minimumJumps():\n    solution = Solution()\n    forbidden = [1000000000000000]\n    a = 50000000000000000\n    b = 25000000000000000\n    x = 175000000000000000\n    assert solution.minimumJumps(forbidden, a, b, x) == -1"]}
{"task_num": 1655, "task_title": "Distribute Repeating Integers", "func_name": "canDistribute", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\n    freqs = list(collections.Counter(nums).values())\n    validDistribution = self._getValidDistribution(freqs, quantity)\n    n = len(freqs)\n    m = len(quantity)\n    maxMask = 1 << m\n    dp = [[False] * maxMask for _ in range(n + 1)]\n    dp[n][maxMask - 1] = True\n\n    for i in range(n - 1, -1, -1):\n      for mask in range(maxMask):\n        dp[i][mask] = dp[i + 1][mask]\n        availableMask = ~mask & (maxMask - 1)\n        submask = availableMask\n        while submask > 0:\n          if validDistribution[i][submask]:\n            dp[i][mask] = dp[i][mask] or dp[i + 1][mask | submask]\n          submask = (submask - 1) & availableMask\n\n    return dp[0][0]\n\n  def _getValidDistribution(self, freqs: List[int], quantity: List[int]) -> List[List[bool]]:\n    maxMask = 1 << len(quantity)\n    validDistribution = [[False] * maxMask for _ in range(len(freqs))]\n    for i, freq in enumerate(freqs):\n      for mask in range(maxMask):\n        if freq >= self._getQuantitySum(quantity, mask):\n          validDistribution[i][mask] = True\n    return validDistribution\n\n  def _getQuantitySum(self, quantity: List[int], mask: int) -> int:\n    res=[]\n    for i, q in enumerate(quantity):\n      if mask >> i & 1:\n        res.append(q)\n    return sum(res)\n", "tests": ["def test_canDistribute():\n    solution = Solution()\n    assert solution.canDistribute([1, 2, 3, 4], [1, 1, 0, 0])", "def test_canDistribute():\n    solution = Solution()\n    assert solution.canDistribute([1, 2, 2, 3], [0, 2, 1])", "def test_canDistribute():\n    solution = Solution()\n    assert solution.canDistribute([1, 2, 3, 4, 5], [2, 2, 0, 1])", "def test_canDistribute():\n    solution = Solution()\n    assert solution.canDistribute([5, 4, 3, 2, 1], [0, 0, 2, 3])", "def test_canDistribute():\n    solution = Solution()\n    assert solution.canDistribute([1] * 100, [0])", "def test_canDistribute():\n    solution = Solution()\n    assert not solution.canDistribute([1] * 50 + [2], [0, 0])", "def test_canDistribute():\n    solution = Solution()\n    assert not solution.canDistribute([1] * 1000 + [2], [50, 0])", "def test_canDistribute():\n    solution = Solution()\n    assert not solution.canDistribute([1] * 51 + [2], [50, 0])", "def test_canDistribute():\n    solution = Solution()\n    assert solution.canDistribute([1] * 25 + [2, 3], [0, 0])", "def test_canDistribute():\n    solution = Solution()\n    assert not solution.canDistribute([1] * 26 + [2], [25, 0])", "def test_canDistribute():\n    solution = Solution()\n    assert solution.canDistribute([1, 2] * 1000, [500, 500])", "def test_canDistribute():\n    solution = Solution()\n    assert not solution.canDistribute([1] * 10000 + [2], [9999, 0])", "def test_canDistribute():\n    solution = Solution()\n    assert not solution.canDistribute([1] * 1000000 + [2], [999999, 0])", "def test_canDistribute():\n    solution = Solution()\n    assert solution.canDistribute([1] * 1000000 + [2], [499999, 500000])", "def test_canDistribute():\n    solution = Solution()\n    assert not solution.canDistribute([1] * 1000000 + [3], [500000, 0])", "def test_canDistribute():\n    solution = Solution()\n    assert not solution.canDistribute([1] * 1000000 + [4], [250000, 0, 0])", "def test_canDistribute():\n    solution = Solution()\n    assert not solution.canDistribute([1] * 1000000 + [5], [125000, 62500, 25000, 25000])", "def test_canDistribute():\n    solution = Solution()\n    assert not solution.canDistribute([1] * 1000000 + [6], [50000, 25000, 12500, 6250, 3125, 1562])", "def test_canDistribute():\n    solution = Solution()\n    assert not solution.canDistribute([1] * 1000000 + [7], [12500, 25000, 50000, 6250, 3125, 1562, 781])", "def test_canDistribute():\n    solution = Solution()\n    assert not solution.canDistribute([1] * 1000000 + [8], [50000, 62500, 12500, 3125, 1562, 781, 390])"]}
{"task_num": 1681, "task_title": "Minimum Incompatibility", "func_name": "minimumIncompatibility", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def __init__(self):\n    self.kMaxNum = 16\n\n  def minimumIncompatibility(self, nums: List[int], k: int) -> int:\n    kMaxCompatibility = (16 - 1) * (16 // 2)\n    n = len(nums)\n    subsetSize = n // k\n    maxMask = 1 << n\n    incompatibilities = self._getIncompatibilities(nums, subsetSize)\n\n    dp = [kMaxCompatibility] * maxMask\n    dp[0] = 0\n\n    for mask in range(1, maxMask):\n      if mask.bit_count() % subsetSize != 0:\n        continue\n      submask = mask\n      while submask > 0:\n        if incompatibilities[submask] != -1:\n          dp[mask] = min(dp[mask], dp[mask - submask] + incompatibilities[submask])\n        submask = (submask - 1) & mask\n\n    if dp[-1] != kMaxCompatibility:\n      return dp[-1]\n    else:\n      return -1\n\n  def _getIncompatibilities(self, nums: List[int], subsetSize: int) -> List[int]:\n    maxMask = 1 << len(nums)\n    incompatibilities = [-1] * maxMask\n    for mask in range(maxMask):\n      if mask.bit_count() == subsetSize and self._isUnique(nums, mask, subsetSize):\n        incompatibilities[mask] = self._getIncompatibility(nums, mask)\n    return incompatibilities\n\n  def _isUnique(self, nums: List[int], mask: int, subsetSize: int) -> bool:\n    used = 0\n    for i, num in enumerate(nums):\n      if mask >> i & 1:\n        used |= 1 << num\n    return used.bit_count() == subsetSize\n\n  def _getIncompatibility(self, nums: List[int], mask: int) -> int:\n    mini = self.kMaxNum\n    maxi = 0\n    for i, num in enumerate(nums):\n      if mask >> i & 1:\n        maxi = max(maxi, num)\n        mini = min(mini, num)\n    return maxi - mini\n", "tests": ["def test_minimumIncompatibility():\n  solution = Solution()\n  def is_incompatible(nums: List[int], k: int) -> bool:", "def test_minimumIncompatibility():\n  solution = Solution()\n  def is_valid_output(nums: List[int], k: int) -> bool:", "def test_minimumIncompatibility():\n    solution = Solution()\n\n    def incompatibility_matches_output(nums: List[int], k: int) -> bool:\n        expected_incompatibility = sum((max(num1, num2) - min(num1, num2) for _ in range(k))) // k", "def test_minimumIncompatibility():\n  solution = Solution()\n  def edge_cases_work_as_expected(nums: List[int], k: int) -> bool:", "def test_minimumIncompatibility():\n  solution = Solution()\n  def subset_size_works_as_expected(nums: List[int], k: int) -> bool:", "def test_minimumIncompatibility():\n  solution = Solution()\n  def k_sets_work_as_expected(nums: List[int], k: int) -> bool:", "def test_minimumIncompatibility():\n    solution = Solution()\n\n    def dp_state_is_updated(nums: List[int], k: int) -> bool:\n        incompatibilities = solution._getIncompatibilities(nums, len(nums) // k)\n        maxMask = 1 << len(nums)\n        for mask in range(1, maxMask):\n            if incompatibilities[mask] != -1 and mask.bit_count() % (len(nums) // k) == 0:\n                return True\n        return False", "def test_minimumIncompatibility():\n    solution = Solution()\n\n    def dp_table_is_filled(nums: List[int], k: int) -> bool:\n        incompatibilities = solution._getIncompatibilities(nums, len(nums) // k)\n        maxMask = 1 << len(nums)\n        dp = [k * (16 - 1)] * maxMask\n        for mask in range(maxMask):\n            if incompatibilities[mask] != -1 and mask.bit_count() % (len(nums) // k) == 0:\n                return True\n        return False", "def test_minimumIncompatibility():\n  solution = Solution()\n  def negative_one_is_returned(nums: List[int], k: int) -> bool:", "def test_minimumIncompatibility():\n  solution = Solution()\n  def incompatibility_is_zero(nums: List[int], k: int) -> bool:", "def test_minimumIncompatibility():\n  solution = Solution()\n  def edge_cases_work_as_expected(nums: List[int], k: int) -> bool:", "def test_minimumIncompatibility():\n    solution = Solution()\n\n    def incompatibilities_are_computed(nums: List[int], k: int) -> bool:\n        incompatibilities = solution._getIncompatibilities(nums, len(nums) // k)\n        return all((i != -1 for i in incompatibilities))", "def test_minimumIncompatibility():\n    solution = Solution()\n\n    def dp_table_is_updated(nums: List[int], k: int) -> bool:\n        maxMask = 1 << len(nums)\n        dp = [k * (16 - 1)] * maxMask\n        for mask in range(maxMask):\n            if dp[mask] != k * (16 - 1) and mask.bit_count() % (len(nums) // k) == 0:\n                return True\n        return False", "def test_minimumIncompatibility():\n  solution = Solution()\n  def k_sets_are_valid(nums: List[int], k: int) -> bool:", "def test_minimumIncompatibility():\n  solution = Solution()\n  def subsets_have_no_duplicates(nums: List[int], k: int) -> bool:", "def test_minimumIncompatibility():\n    solution = Solution()\n\n    def max_incompatibility_is_returned(nums: List[int], k: int) -> bool:\n        incompatibilities = solution._getIncompatibilities(nums, len(nums) // k)\n        return all((i != -1 and i > 0 for i in incompatibilities))", "def test_minimumIncompatibility():\n  solution = Solution()\n  def minimum_incompatibility_is_returned(nums: List[int], k: int) -> bool:", "def test_minimumIncompatibility():\n    solution = Solution()\n\n    def incompatibilities_are_calculated(nums: List[int], k: int) -> bool:\n        incompatibilities = solution._getIncompatibilities(nums, len(nums) // k)", "def test_minimumIncompatibility():\n    solution = Solution()\n\n    def dp_table_has_min_incompatibility(nums: List[int], k: int) -> bool:\n        incompatibilities = solution._getIncompatibilities(nums, len(nums) // k)\n        maxMask = 1 << len(nums)\n        dp = [k * (16 - 1)] * maxMask\n        return min((dp[mask] for mask in range(maxMask) if mask.bit_count() % (len(nums) // k) == 0)) != k * (16 - 1)", "def test_minimumIncompatibility():\n    solution = Solution()\n\n    def k_sets_have_min_incompatibility(nums: List[int], k: int) -> bool:\n        incompatibilities = solution._getIncompatibilities(nums, len(nums) // k)\n        return all((i != -1 and i >= 0 for i in incompatibilities))"]}
{"task_num": 1687, "task_title": "Delivering Boxes from Storage to Ports", "func_name": "boxDelivering", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\n    n = len(boxes)\n    dp = [0] * (n + 1)\n    trips = 2\n    weight = 0\n\n    l = 0\n    for r in range(n):\n      weight += boxes[r][1]\n\n      if r > 0 and boxes[r][0] != boxes[r - 1][0]:\n        trips += 1\n\n      while r - l + 1 > maxBoxes or weight > maxWeight or (l < r and dp[l + 1] == dp[l]):\n        weight -= boxes[l][1]\n        if boxes[l][0] != boxes[l + 1][0]:\n          trips -= 1\n        l += 1\n\n      dp[r + 1] = dp[l] + trips\n\n    return dp[n]\n", "tests": ["def test_boxDelivering():\n\n    class Solution:\n\n        def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\n            n = len(boxes)\n            dp = [0] * (n + 1)\n            trips = 2\n            weight = 0\n            l = 0\n            for r in range(n):\n                weight += boxes[r][1]\n                if r > 0 and boxes[r][0] != boxes[r - 1][0]:\n                    trips += 1\n                while r - l + 1 > maxBoxes or weight > maxWeight or (l < r and dp[l + 1] == dp[l]):\n                    weight -= boxes[l][1]\n                    if boxes[l][0] != boxes[l + 1][0]:\n                        trips -= 1\n                    l += 1\n                dp[r + 1] = dp[l] + trips\n            return dp[n]\n    solution = Solution()\n    print(solution.boxDelivering([[1, 1], [2, 3]], 1, 3, 4))", "def test_boxDelivering():\n\n    class Solution:\n\n        def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\n            n = len(boxes)\n            dp = [0] * (n + 1)\n            trips = 2\n            weight = 0\n            l = 0\n            for r in range(n):\n                weight += boxes[r][1]\n                if r > 0 and boxes[r][0] != boxes[r - 1][0]:\n                    trips += 1\n                while r - l + 1 > maxBoxes or weight > maxWeight or (l < r and dp[l + 1] == dp[l]):\n                    weight -= boxes[l][1]\n                    if boxes[l][0] != boxes[l + 1][0]:\n                        trips -= 1\n                    l += 1\n                dp[r + 1] = dp[l] + trips\n            return dp[n]\n    solution = Solution()\n    print(solution.boxDelivering([[1, 4], [2, 3], [1, 6]], 3, 5, 7))", "def test_boxDelivering():\n\n    class Solution:\n\n        def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\n            n = len(boxes)\n            dp = [0] * (n + 1)\n            trips = 2\n            weight = 0\n            l = 0\n            for r in range(n):\n                weight += boxes[r][1]\n                if r > 0 and boxes[r][0] != boxes[r - 1][0]:\n                    trips += 1\n                while r - l + 1 > maxBoxes or weight > maxWeight or (l < r and dp[l + 1] == dp[l]):\n                    weight -= boxes[l][1]\n                    if boxes[l][0] != boxes[l + 1][0]:\n                        trips -= 1\n                    l += 1\n                dp[r + 1] = dp[l] + trips\n            return dp[n]\n    solution = Solution()\n    print(solution.boxDelivering([[3, 6], [2, 4]], 5, 1, 5))", "def test_boxDelivering():\n\n    class Solution:\n\n        def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\n            n = len(boxes)\n            dp = [0] * (n + 1)\n            trips = 2\n            weight = 0\n            l = 0\n            for r in range(n):\n                weight += boxes[r][1]\n                if r > 0 and boxes[r][0] != boxes[r - 1][0]:\n                    trips += 1\n                while r - l + 1 > maxBoxes or weight > maxWeight or (l < r and dp[l + 1] == dp[l]):\n                    weight -= boxes[l][1]\n                    if boxes[l][0] != boxes[l + 1][0]:\n                        trips -= 1\n                    l += 1\n                dp[r + 1] = dp[l] + trips\n            return dp[n]\n    solution = Solution()\n    print(solution.boxDelivering([[2, 3], [4, 5], [6, 7]], 3, 10, 100))", "def test_boxDelivering():\n\n    class Solution:\n\n        def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\n            n = len(boxes)\n            dp = [0] * (n + 1)\n            trips = 2\n            weight = 0\n            l = 0\n            for r in range(n):\n                weight += boxes[r][1]\n                if r > 0 and boxes[r][0] != boxes[r - 1][0]:\n                    trips += 1\n                while r - l + 1 > maxBoxes or weight > maxWeight or (l < r and dp[l + 1] == dp[l]):\n                    weight -= boxes[l][1]\n                    if boxes[l][0] != boxes[l + 1][0]:\n                        trips -= 1\n                    l += 1\n                dp[r + 1] = dp[l] + trips\n            return dp[n]\n    solution = Solution()\n    print(solution.boxDelivering([[6, 5], [4, 3], [2, 7]], 1, 15, 150))", "def test_boxDelivering():\n\n    class Solution:\n\n        def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\n            n = len(boxes)\n            dp = [0] * (n + 1)\n            trips = 2\n            weight = 0\n            l = 0\n            for r in range(n):\n                weight += boxes[r][1]\n                if r > 0 and boxes[r][0] != boxes[r - 1][0]:\n                    trips += 1\n                while r - l + 1 > maxBoxes or weight > maxWeight or (l < r and dp[l + 1] == dp[l]):\n                    weight -= boxes[l][1]\n                    if boxes[l][0] != boxes[l + 1][0]:\n                        trips -= 1\n                    l += 1\n                dp[r + 1] = dp[l] + trips\n            return dp[n]\n    solution = Solution()\n    print(solution.boxDelivering([[5, 3], [4, 6], [7, 2]], 3, 8, 80))", "def test_boxDelivering():\n\n    class Solution:\n\n        def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\n            n = len(boxes)\n            dp = [0] * (n + 1)\n            trips = 2\n            weight = 0\n            l = 0\n            for r in range(n):\n                weight += boxes[r][1]\n                if r > 0 and boxes[r][0] != boxes[r - 1][0]:\n                    trips += 1\n                while r - l + 1 > maxBoxes or weight > maxWeight or (l < r and dp[l + 1] == dp[l]):\n                    weight -= boxes[l][1]\n                    if boxes[l][0] != boxes[l + 1][0]:\n                        trips -= 1\n                    l += 1\n                dp[r + 1] = dp[l] + trips\n            return dp[n]\n    solution = Solution()\n    print(solution.boxDelivering([[3, 4], [5, 2], [7, 6]], 1, 10, 100))", "def test_boxDelivering():\n\n    class Solution:\n\n        def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\n            n = len(boxes)\n            dp = [0] * (n + 1)\n            trips = 2\n            weight = 0\n            l = 0\n            for r in range(n):\n                weight += boxes[r][1]\n                if r > 0 and boxes[r][0] != boxes[r - 1][0]:\n                    trips += 1\n                while r - l + 1 > maxBoxes or weight > maxWeight or (l < r and dp[l + 1] == dp[l]):\n                    weight -= boxes[l][1]\n                    if boxes[l][0] != boxes[l + 1][0]:\n                        trips -= 1\n                    l += 1\n                dp[r + 1] = dp[l] + trips\n            return dp[n]\n    solution = Solution()\n    print(solution.boxDelivering([[2, 5], [3, 4], [7, 6], [1, 8]], 4, 15, 150))", "def test_boxDelivering():\n\n    class Solution:\n\n        def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\n            n = len(boxes)\n            dp = [0] * (n + 1)\n            trips = 2\n            weight = 0\n            l = 0\n            for r in range(n):\n                weight += boxes[r][1]\n                if r > 0 and boxes[r][0] != boxes[r - 1][0]:\n                    trips += 1\n                while r - l + 1 > maxBoxes or weight > maxWeight or (l < r and dp[l + 1] == dp[l]):\n                    weight -= boxes[l][1]\n                    if boxes[l][0] != boxes[l + 1][0]:\n                        trips -= 1\n                    l += 1\n                dp[r + 1] = dp[l] + trips\n            return dp[n]\n    solution = Solution()\n    print(solution.boxDelivering([[8, 3], [2, 4], [9, 7]], 1, 20, 200))", "def test_boxDelivering():\n\n    class Solution:\n\n        def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\n            n = len(boxes)\n            dp = [0] * (n + 1)\n            trips = 2\n            weight = 0\n            l = 0\n            for r in range(n):\n                weight += boxes[r][1]\n                if r > 0 and boxes[r][0] != boxes[r - 1][0]:\n                    trips += 1\n                while r - l + 1 > maxBoxes or weight > maxWeight or (l < r and dp[l + 1] == dp[l]):\n                    weight -= boxes[l][1]\n                    if boxes[l][0] != boxes[l + 1][0]:\n                        trips -= 1\n                    l += 1\n                dp[r + 1] = dp[l] + trips\n            return dp[n]\n    solution = Solution()\n    print(solution.boxDelivering([[4, 5], [6, 3], [7, 2], [9, 8]], 4, 10, 100))", "def test_boxDelivering():\n\n    class Solution:\n\n        def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\n            n = len(boxes)\n            dp = [0] * (n + 1)\n            trips = 2\n            weight = 0\n            l = 0\n            for r in range(n):\n                weight += boxes[r][1]\n                if r > 0 and boxes[r][0] != boxes[r - 1][0]:\n                    trips += 1\n                while r - l + 1 > maxBoxes or weight > maxWeight or (l < r and dp[l + 1] == dp[l]):\n                    weight -= boxes[l][1]\n                    if boxes[l][0] != boxes[l + 1][0]:\n                        trips -= 1\n                    l += 1\n                dp[r + 1] = dp[l] + trips\n            return dp[n]\n    solution = Solution()\n    print(solution.boxDelivering([[1, 2], [3, 4], [5, 6], [7, 8]], 4, 20, 200))", "def test_boxDelivering():\n\n    class Solution:\n\n        def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\n            n = len(boxes)\n            dp = [0] * (n + 1)\n            trips = 2\n            weight = 0\n            l = 0\n            for r in range(n):\n                weight += boxes[r][1]\n                if r > 0 and boxes[r][0] != boxes[r - 1][0]:\n                    trips += 1\n                while r - l + 1 > maxBoxes or weight > maxWeight or (l < r and dp[l + 1] == dp[l]):\n                    weight -= boxes[l][1]\n                    if boxes[l][0] != boxes[l + 1][0]:\n                        trips -= 1\n                    l += 1\n                dp[r + 1] = dp[l] + trips\n            return dp[n]\n    solution = Solution()\n    print(solution.boxDelivering([[9, 8], [7, 6], [5, 4], [3, 2]], 4, 10, 100))", "def test_boxDelivering():\n\n    class Solution:\n\n        def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\n            n = len(boxes)\n            dp = [0] * (n + 1)\n            trips = 2\n            weight = 0\n            l = 0\n            for r in range(n):\n                weight += boxes[r][1]\n                if r > 0 and boxes[r][0] != boxes[r - 1][0]:\n                    trips += 1\n                while r - l + 1 > maxBoxes or weight > maxWeight or (l < r and dp[l + 1] == dp[l]):\n                    weight -= boxes[l][1]\n                    if boxes[l][0] != boxes[l + 1][0]:\n                        trips -= 1\n                    l += 1\n                dp[r + 1] = dp[l] + trips\n            return dp[n]\n    solution = Solution()\n    print(solution.boxDelivering([[8, 7], [6, 5], [4, 3], [2, 1]], 4, 20, 200))", "def test_boxDelivering():\n\n    class Solution:\n\n        def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\n            n = len(boxes)\n            dp = [0] * (n + 1)\n            trips = 2\n            weight = 0\n            l = 0\n            for r in range(n):\n                weight += boxes[r][1]\n                if r > 0 and boxes[r][0] != boxes[r - 1][0]:\n                    trips += 1\n                while r - l + 1 > maxBoxes or weight > maxWeight or (l < r and dp[l + 1] == dp[l]):\n                    weight -= boxes[l][1]\n                    if boxes[l][0] != boxes[l + 1][0]:\n                        trips -= 1\n                    l += 1\n                dp[r + 1] = dp[l] + trips\n            return dp[n]\n    solution = Solution()\n    print(solution.boxDelivering([[4, 3], [2, 7], [6, 5], [9, 8]], 4, 15, 150))", "def test_boxDelivering():\n\n    class Solution:\n\n        def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\n            n = len(boxes)\n            dp = [0] * (n + 1)\n            trips = 2\n            weight = 0\n            l = 0\n            for r in range(n):\n                weight += boxes[r][1]\n                if r > 0 and boxes[r][0] != boxes[r - 1][0]:\n                    trips += 1\n                while r - l + 1 > maxBoxes or weight > maxWeight or (l < r and dp[l + 1] == dp[l]):\n                    weight -= boxes[l][1]\n                    if boxes[l][0] != boxes[l + 1][0]:\n                        trips -= 1\n                    l += 1\n                dp[r + 1] = dp[l] + trips\n            return dp[n]\n    solution = Solution()\n    print(solution.boxDelivering([[3, 8], [2, 4], [6, 7], [9, 5]], 4, 20, 200))", "def test_boxDelivering():\n\n    class Solution:\n\n        def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\n            n = len(boxes)\n            dp = [0] * (n + 1)\n            trips = 2\n            weight = 0\n            l = 0\n            for r in range(n):\n                weight += boxes[r][1]\n                if r > 0 and boxes[r][0] != boxes[r - 1][0]:\n                    trips += 1\n                while r - l + 1 > maxBoxes or weight > maxWeight or (l < r and dp[l + 1] == dp[l]):\n                    weight -= boxes[l][1]\n                    if boxes[l][0] != boxes[l + 1][0]:\n                        trips -= 1\n                    l += 1\n                dp[r + 1] = dp[l] + trips\n            return dp[n]\n    solution = Solution()\n    print(solution.boxDelivering([[7, 2], [9, 5], [4, 3], [8, 6]], 4, 20, 200))", "def test_boxDelivering():\n\n    class Solution:\n\n        def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\n            n = len(boxes)\n            dp = [0] * (n + 1)\n            trips = 2\n            weight = 0\n            l = 0\n            for r in range(n):\n                weight += boxes[r][1]\n                if r > 0 and boxes[r][0] != boxes[r - 1][0]:\n                    trips += 1\n                while r - l + 1 > maxBoxes or weight > maxWeight or (l < r and dp[l + 1] == dp[l]):\n                    weight -= boxes[l][1]\n                    if boxes[l][0] != boxes[l + 1][0]:\n                        trips -= 1\n                    l += 1\n                dp[r + 1] = dp[l] + trips\n            return dp[n]\n    solution = Solution()\n    print(solution.boxDelivering([[2, 8], [4, 6], [7, 3], [9, 5]], 4, 20, 200))", "def test_boxDelivering():\n\n    class Solution:\n\n        def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\n            n = len(boxes)\n            dp = [0] * (n + 1)\n            trips = 2\n            weight = 0\n            l = 0\n            for r in range(n):\n                weight += boxes[r][1]\n                if r > 0 and boxes[r][0] != boxes[r - 1][0]:\n                    trips += 1\n                while r - l + 1 > maxBoxes or weight > maxWeight or (l < r and dp[l + 1] == dp[l]):\n                    weight -= boxes[l][1]\n                    if boxes[l][0] != boxes[l + 1][0]:\n                        trips -= 1\n                    l += 1\n                dp[r + 1] = dp[l] + trips\n            return dp[n]\n    solution = Solution()\n    print(solution.boxDelivering([[6, 9], [5, 7], [4, 3], [2, 8]], 4, 15, 150))", "def test_boxDelivering():\n\n    class Solution:\n\n        def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\n            n = len(boxes)\n            dp = [0] * (n + 1)\n            trips = 2\n            weight = 0\n            l = 0\n            for r in range(n):\n                weight += boxes[r][1]\n                if r > 0 and boxes[r][0] != boxes[r - 1][0]:\n                    trips += 1\n                while r - l + 1 > maxBoxes or weight > maxWeight or (l < r and dp[l + 1] == dp[l]):\n                    weight -= boxes[l][1]\n                    if boxes[l][0] != boxes[l + 1][0]:\n                        trips -= 1\n                    l += 1\n                dp[r + 1] = dp[l] + trips\n            return dp[n]\n    solution = Solution()\n    print(solution.boxDelivering([[3, 6], [2, 9], [5, 7], [4, 8]], 4, 20, 200))", "def test_boxDelivering():\n\n    class Solution:\n\n        def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\n            n = len(boxes)\n            dp = [0] * (n + 1)\n            trips = 2\n            weight = 0\n            l = 0\n            for r in range(n):\n                weight += boxes[r][1]\n                if r > 0 and boxes[r][0] != boxes[r - 1][0]:\n                    trips += 1\n                while r - l + 1 > maxBoxes or weight > maxWeight or (l < r and dp[l + 1] == dp[l]):\n                    weight -= boxes[l][1]\n                    if boxes[l][0] != boxes[l + 1][0]:\n                        trips -= 1\n                    l += 1\n                dp[r + 1] = dp[l] + trips\n            return dp[n]\n    solution = Solution()\n    print(solution.boxDelivering([[9, 5], [7, 3], [4, 6], [2, 8]], 4, 15, 150))"]}
{"task_num": 1705, "task_title": "Maximum Number of Eaten Apples", "func_name": "eatenApples", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def eatenApples(self, apples: List[int], days: List[int]) -> int:\n    n = len(apples)\n    ans = 0\n    minHeap = []\n\n    i = 0\n    while i < n or minHeap:\n      while minHeap and minHeap[0][0] <= i:\n        heapq.heappop(minHeap)\n      if i < n and apples[i] > 0:\n        heapq.heappush(minHeap, (i + days[i], apples[i]))\n      if minHeap:\n        rottenDay, numApples = heapq.heappop(minHeap)\n        if numApples > 1:\n          heapq.heappush(minHeap, (rottenDay, numApples - 1))\n        ans += 1\n      i += 1\n\n    return ans\n", "tests": ["def test_eatenApples():\n\n    class Solution:\n\n        def eatenApples(self, apples: List[int], days: List[int]) -> int:\n            n = len(apples)\n            ans = 0\n            minHeap = []\n            i = 0\n            while i < n or minHeap:\n                while minHeap and minHeap[0][0] <= i:\n                    heapq.heappop(minHeap)\n                if i < n and apples[i] > 0:\n                    heapq.heappush(minHeap, (i + days[i], apples[i]))\n                if minHeap:\n                    (rottenDay, numApples) = heapq.heappop(minHeap)\n                    if numApples > 1:\n                        heapq.heappush(minHeap, (rottenDay, numApples - 1))\n                    ans += 1\n                i += 1\n            return ans\n    solution = Solution()\n    assert solution.eatenApples([1, 2, 3, 4], [5, 4, 3, 2]) == 10", "def test_eatenApples():\n\n    class Solution:\n\n        def eatenApples(self, apples: List[int], days: List[int]) -> int:\n            n = len(apples)\n            ans = 0\n            minHeap = []\n            i = 0\n            while i < n or minHeap:\n                while minHeap and minHeap[0][0] <= i:\n                    heapq.heappop(minHeap)\n                if i < n and apples[i] > 0:\n                    heapq.heappush(minHeap, (i + days[i], apples[i]))\n                if minHeap:\n                    (rottenDay, numApples) = heapq.heappop(minHeap)\n                    if numApples > 1:\n                        heapq.heappush(minHeap, (rottenDay, numApples - 1))\n                    ans += 1\n                i += 1\n            return ans\n    solution = Solution()\n    assert solution.eatenApples([0, 3, 4], [5, 2, 1]) == 9", "def test_eatenApples():\n\n    class Solution:\n\n        def eatenApples(self, apples: List[int], days: List[int]) -> int:\n            n = len(apples)\n            ans = 0\n            minHeap = []\n            i = 0\n            while i < n or minHeap:\n                while minHeap and minHeap[0][0] <= i:\n                    heapq.heappop(minHeap)\n                if i < n and apples[i] > 0:\n                    heapq.heappush(minHeap, (i + days[i], apples[i]))\n                if minHeap:\n                    (rottenDay, numApples) = heapq.heappop(minHeap)\n                    if numApples > 1:\n                        heapq.heappush(minHeap, (rottenDay, numApples - 1))\n                    ans += 1\n                i += 1\n            return ans\n    solution = Solution()\n    assert solution.eatenApples([5, 4], [0, 3]) == 8", "def test_eatenApples():\n\n    class Solution:\n\n        def eatenApples(self, apples: List[int], days: List[int]) -> int:\n            n = len(apples)\n            ans = 0\n            minHeap = []\n            i = 0\n            while i < n or minHeap:\n                while minHeap and minHeap[0][0] <= i:\n                    heapq.heappop(minHeap)\n                if i < n and apples[i] > 0:\n                    heapq.heappush(minHeap, (i + days[i], apples[i]))\n                if minHeap:\n                    (rottenDay, numApples) = heapq.heappop(minHeap)\n                    if numApples > 1:\n                        heapq.heappush(minHeap, (rottenDay, numApples - 1))\n                    ans += 1\n                i += 1\n            return ans\n    solution = Solution()\n    assert solution.eatenApples([0, 2], [3, 4]) == 5", "def test_eatenApples():\n\n    class Solution:\n\n        def eatenApples(self, apples: List[int], days: List[int]) -> int:\n            n = len(apples)\n            ans = 0\n            minHeap = []\n            i = 0\n            while i < n or minHeap:\n                while minHeap and minHeap[0][0] <= i:\n                    heapq.heappop(minHeap)\n                if i < n and apples[i] > 0:\n                    heapq.heappush(minHeap, (i + days[i], apples[i]))\n                if minHeap:\n                    (rottenDay, numApples) = heapq.heappop(minHeap)\n                    if numApples > 1:\n                        heapq.heappush(minHeap, (rottenDay, numApples - 1))\n                    ans += 1\n                i += 1\n            return ans\n    solution = Solution()\n    assert solution.eatenApples([3, 7, 4], [2, 9, 5]) == 16", "def test_eatenApples():\n\n    class Solution:\n\n        def eatenApples(self, apples: List[int], days: List[int]) -> int:\n            n = len(apples)\n            ans = 0\n            minHeap = []\n            i = 0\n            while i < n or minHeap:\n                while minHeap and minHeap[0][0] <= i:\n                    heapq.heappop(minHeap)\n                if i < n and apples[i] > 0:\n                    heapq.heappush(minHeap, (i + days[i], apples[i]))\n                if minHeap:\n                    (rottenDay, numApples) = heapq.heappop(minHeap)\n                    if numApples > 1:\n                        heapq.heappush(minHeap, (rottenDay, numApples - 1))\n                    ans += 1\n                i += 1\n            return ans\n    solution = Solution()\n    assert solution.eatenApples([0, 0], [0, 0]) == 0", "def test_eatenApples():\n\n    class Solution:\n\n        def eatenApples(self, apples: List[int], days: List[int]) -> int:\n            n = len(apples)\n            ans = 0\n            minHeap = []\n            i = 0\n            while i < n or minHeap:\n                while minHeap and minHeap[0][0] <= i:\n                    heapq.heappop(minHeap)\n                if i < n and apples[i] > 0:\n                    heapq.heappush(minHeap, (i + days[i], apples[i]))\n                if minHeap:\n                    (rottenDay, numApples) = heapq.heappop(minHeap)\n                    if numApples > 1:\n                        heapq.heappush(minHeap, (rottenDay, numApples - 1))\n                    ans += 1\n                i += 1\n            return ans\n    solution = Solution()\n    assert solution.eatenApples([2, 4], [3, 1]) == 8", "def test_eatenApples():\n\n    class Solution:\n\n        def eatenApples(self, apples: List[int], days: List[int]) -> int:\n            n = len(apples)\n            ans = 0\n            minHeap = []\n            i = 0\n            while i < n or minHeap:\n                while minHeap and minHeap[0][0] <= i:\n                    heapq.heappop(minHeap)\n                if i < n and apples[i] > 0:\n                    heapq.heappush(minHeap, (i + days[i], apples[i]))\n                if minHeap:\n                    (rottenDay, numApples) = heapq.heappop(minHeap)\n                    if numApples > 1:\n                        heapq.heappush(minHeap, (rottenDay, numApples - 1))\n                    ans += 1\n                i += 1\n            return ans\n    solution = Solution()\n    assert solution.eatenApples([5, 5], [3, 4]) == 10", "def test_eatenApples():\n\n    class Solution:\n\n        def eatenApples(self, apples: List[int], days: List[int]) -> int:\n            n = len(apples)\n            ans = 0\n            minHeap = []\n            i = 0\n            while i < n or minHeap:\n                while minHeap and minHeap[0][0] <= i:\n                    heapq.heappop(minHeap)\n                if i < n and apples[i] > 0:\n                    heapq.heappush(minHeap, (i + days[i], apples[i]))\n                if minHeap:\n                    (rottenDay, numApples) = heapq.heappop(minHeap)\n                    if numApples > 1:\n                        heapq.heappush(minHeap, (rottenDay, numApples - 1))\n                    ans += 1\n                i += 1\n            return ans\n    solution = Solution()\n    assert solution.eatenApples([2, 3], [4, 5]) == 12", "def test_eatenApples():\n\n    class Solution:\n\n        def eatenApples(self, apples: List[int], days: List[int]) -> int:\n            n = len(apples)\n            ans = 0\n            minHeap = []\n            i = 0\n            while i < n or minHeap:\n                while minHeap and minHeap[0][0] <= i:\n                    heapq.heappop(minHeap)\n                if i < n and apples[i] > 0:\n                    heapq.heappush(minHeap, (i + days[i], apples[i]))\n                if minHeap:\n                    (rottenDay, numApples) = heapq.heappop(minHeap)\n                    if numApples > 1:\n                        heapq.heappush(minHeap, (rottenDay, numApples - 1))\n                    ans += 1\n                i += 1\n            return ans\n    solution = Solution()\n    assert solution.eatenApples([10, 20], [30, 40]) == 50", "def test_eatenApples():\n\n    class Solution:\n\n        def eatenApples(self, apples: List[int], days: List[int]) -> int:\n            n = len(apples)\n            ans = 0\n            minHeap = []\n            i = 0\n            while i < n or minHeap:\n                while minHeap and minHeap[0][0] <= i:\n                    heapq.heappop(minHeap)\n                if i < n and apples[i] > 0:\n                    heapq.heappush(minHeap, (i + days[i], apples[i]))\n                if minHeap:\n                    (rottenDay, numApples) = heapq.heappop(minHeap)\n                    if numApples > 1:\n                        heapq.heappush(minHeap, (rottenDay, numApples - 1))\n                    ans += 1\n                i += 1\n            return ans\n    solution = Solution()\n    assert solution.eatenApples([8], [10]) == 8", "def test_eatenApples():\n\n    class Solution:\n\n        def eatenApples(self, apples: List[int], days: List[int]) -> int:\n            n = len(apples)\n            ans = 0\n            minHeap = []\n            i = 0\n            while i < n or minHeap:\n                while minHeap and minHeap[0][0] <= i:\n                    heapq.heappop(minHeap)\n                if i < n and apples[i] > 0:\n                    heapq.heappush(minHeap, (i + days[i], apples[i]))\n                if minHeap:\n                    (rottenDay, numApples) = heapq.heappop(minHeap)\n                    if numApples > 1:\n                        heapq.heappush(minHeap, (rottenDay, numApples - 1))\n                    ans += 1\n                i += 1\n            return ans\n    solution = Solution()\n    assert solution.eatenApples([6], [10]) == 6", "def test_eatenApples():\n\n    class Solution:\n\n        def eatenApples(self, apples: List[int], days: List[int]) -> int:\n            n = len(apples)\n            ans = 0\n            minHeap = []\n            i = 0\n            while i < n or minHeap:\n                while minHeap and minHeap[0][0] <= i:\n                    heapq.heappop(minHeap)\n                if i < n and apples[i] > 0:\n                    heapq.heappush(minHeap, (i + days[i], apples[i]))\n                if minHeap:\n                    (rottenDay, numApples) = heapq.heappop(minHeap)\n                    if numApples > 1:\n                        heapq.heappush(minHeap, (rottenDay, numApples - 1))\n                    ans += 1\n                i += 1\n            return ans\n    solution = Solution()\n    assert solution.eatenApples([5, 10], [3, 4]) == 14", "def test_eatenApples():\n\n    class Solution:\n\n        def eatenApples(self, apples: List[int], days: List[int]) -> int:\n            n = len(apples)\n            ans = 0\n            minHeap = []\n            i = 0\n            while i < n or minHeap:\n                while minHeap and minHeap[0][0] <= i:\n                    heapq.heappop(minHeap)\n                if i < n and apples[i] > 0:\n                    heapq.heappush(minHeap, (i + days[i], apples[i]))\n                if minHeap:\n                    (rottenDay, numApples) = heapq.heappop(minHeap)\n                    if numApples > 1:\n                        heapq.heappush(minHeap, (rottenDay, numApples - 1))\n                    ans += 1\n                i += 1\n            return ans\n    solution = Solution()\n    assert solution.eatenApples([12], [10]) == 12", "def test_eatenApples():\n\n    class Solution:\n\n        def eatenApples(self, apples: List[int], days: List[int]) -> int:\n            n = len(apples)\n            ans = 0\n            minHeap = []\n            i = 0\n            while i < n or minHeap:\n                while minHeap and minHeap[0][0] <= i:\n                    heapq.heappop(minHeap)\n                if i < n and apples[i] > 0:\n                    heapq.heappush(minHeap, (i + days[i], apples[i]))\n                if minHeap:\n                    (rottenDay, numApples) = heapq.heappop(minHeap)\n                    if numApples > 1:\n                        heapq.heappush(minHeap, (rottenDay, numApples - 1))\n                    ans += 1\n                i += 1\n            return ans\n    solution = Solution()\n    assert solution.eatenApples([9], [10]) == 9", "def test_eatenApples():\n\n    class Solution:\n\n        def eatenApples(self, apples: List[int], days: List[int]) -> int:\n            n = len(apples)\n            ans = 0\n            minHeap = []\n            i = 0\n            while i < n or minHeap:\n                while minHeap and minHeap[0][0] <= i:\n                    heapq.heappop(minHeap)\n                if i < n and apples[i] > 0:\n                    heapq.heappush(minHeap, (i + days[i], apples[i]))\n                if minHeap:\n                    (rottenDay, numApples) = heapq.heappop(minHeap)\n                    if numApples > 1:\n                        heapq.heappush(minHeap, (rottenDay, numApples - 1))\n                    ans += 1\n                i += 1\n            return ans\n    solution = Solution()\n    assert solution.eatenApples([100], [10]) == 100", "def test_eatenApples():\n\n    class Solution:\n\n        def eatenApples(self, apples: List[int], days: List[int]) -> int:\n            n = len(apples)\n            ans = 0\n            minHeap = []\n            i = 0\n            while i < n or minHeap:\n                while minHeap and minHeap[0][0] <= i:\n                    heapq.heappop(minHeap)\n                if i < n and apples[i] > 0:\n                    heapq.heappush(minHeap, (i + days[i], apples[i]))\n                if minHeap:\n                    (rottenDay, numApples) = heapq.heappop(minHeap)\n                    if numApples > 1:\n                        heapq.heappush(minHeap, (rottenDay, numApples - 1))\n                    ans += 1\n                i += 1\n            return ans\n    solution = Solution()\n    assert solution.eatenApples([20], [30]) == 50", "def test_eatenApples():\n\n    class Solution:\n\n        def eatenApples(self, apples: List[int], days: List[int]) -> int:\n            n = len(apples)\n            ans = 0\n            minHeap = []\n            i = 0\n            while i < n or minHeap:\n                while minHeap and minHeap[0][0] <= i:\n                    heapq.heappop(minHeap)\n                if i < n and apples[i] > 0:\n                    heapq.heappush(minHeap, (i + days[i], apples[i]))\n                if minHeap:\n                    (rottenDay, numApples) = heapq.heappop(minHeap)\n                    if numApples > 1:\n                        heapq.heappush(minHeap, (rottenDay, numApples - 1))\n                    ans += 1\n                i += 1\n            return ans\n    solution = Solution()\n    assert solution.eatenApples([50], [60]) == 110", "def test_eatenApples():\n\n    class Solution:\n\n        def eatenApples(self, apples: List[int], days: List[int]) -> int:\n            n = len(apples)\n            ans = 0\n            minHeap = []\n            i = 0\n            while i < n or minHeap:\n                while minHeap and minHeap[0][0] <= i:\n                    heapq.heappop(minHeap)\n                if i < n and apples[i] > 0:\n                    heapq.heappush(minHeap, (i + days[i], apples[i]))\n                if minHeap:\n                    (rottenDay, numApples) = heapq.heappop(minHeap)\n                    if numApples > 1:\n                        heapq.heappush(minHeap, (rottenDay, numApples - 1))\n                    ans += 1\n                i += 1\n            return ans\n    solution = Solution()\n    assert solution.eatenApples([5, 10], [2, 4]) == 7", "def test_eatenApples():\n\n    class Solution:\n\n        def eatenApples(self, apples: List[int], days: List[int]) -> int:\n            n = len(apples)\n            ans = 0\n            minHeap = []\n            i = 0\n            while i < n or minHeap:\n                while minHeap and minHeap[0][0] <= i:\n                    heapq.heappop(minHeap)\n                if i < n and apples[i] > 0:\n                    heapq.heappush(minHeap, (i + days[i], apples[i]))\n                if minHeap:\n                    (rottenDay, numApples) = heapq.heappop(minHeap)\n                    if numApples > 1:\n                        heapq.heappush(minHeap, (rottenDay, numApples - 1))\n                    ans += 1\n                i += 1\n            return ans\n    solution = Solution()\n    assert solution.eatenApples([1000], [10]) == 10000"]}
{"task_num": 1706, "task_title": "Where Will the Ball Fall", "func_name": "findBall", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findBall(self, grid: List[List[int]]) -> List[int]:\n    m = len(grid)\n    n = len(grid[0])\n    dp = [i for i in range(n)]\n    ans = [-1] * n\n\n    for i in range(m):\n      newDp = [-1] * n\n      for j in range(n):\n        if j + grid[i][j] < 0 or j + grid[i][j] == n:\n          continue\n        if grid[i][j] == 1 and grid[i][j + 1] == -1 or grid[i][j] == -1 and grid[i][j - 1] == 1:\n          continue\n        newDp[j + grid[i][j]] = dp[j]\n      dp = newDp\n\n    for i, ball in enumerate(dp):\n      if ball != -1:\n        ans[ball] = i\n\n    return ans\n", "tests": ["def test_findBall():\n    solution = Solution()\n    grid = [[1, 3, -1, -1], [2, 4, -1, -1], [-1, 1, 5, -1], [-1, -2, 6, -1]]\n    assert solution.findBall(grid) == [0, 1, -1, -1]", "def test_findBall():\n    solution = Solution()\n    grid = [[1, -1, -1, -1], [1, 1, -1, -1], [-1, -1, -1, -1], [-1, -1, 1, -1]]\n    assert solution.findBall(grid) == [-1, -1, -1, -1]", "def test_findBall():\n    solution = Solution()\n    grid = [[-1, -1, 1], [1, 1, -1], [-1, 1, 1], [-1, -1, -1]]\n    assert solution.findBall(grid) == [2, -1, -1, -1]", "def test_findBall():\n    solution = Solution()\n    grid = [[-1, -1, -1], [1, 1, 1], [-1, -1, 1], [-1, -1, -1]]\n    assert solution.findBall(grid) == [-1, -1, -1]", "def test_findBall():\n    solution = Solution()\n    grid = [[1, -1, -1], [1, -1, -1], [-1, 1, -1], [-1, -1, -1]]\n    assert solution.findBall(grid) == [-1, -1, 0]", "def test_findBall():\n    solution = Solution()\n    grid = [[-1, -1, -1], [1, -1, -1], [-1, -1, -1], [-1, -1, 1]]\n    assert solution.findBall(grid) == [-1, -1, -1]", "def test_findBall():\n    solution = Solution()\n    grid = [[1, -1, 1], [1, 1, -1], [-1, -1, 1], [1, -1, -1]]\n    assert solution.findBall(grid) == [-1, -1, -1]", "def test_findBall():\n    solution = Solution()\n    grid = [[-1, -1, -1], [1, 1, 1], [-1, 1, 1], [-1, -1, -1]]\n    assert solution.findBall(grid) == [-1, -1, -1]", "def test_findBall():\n    solution = Solution()\n    grid = [[1, -1, -1], [1, -1, -1], [-1, 1, 1], [-1, 1, 1]]\n    assert solution.findBall(grid) == [-1, -1, -1]", "def test_findBall():\n    solution = Solution()\n    grid = [[-1, -1, -1], [1, 1, 1], [-1, -1, -1], [-1, -1, -1]]\n    assert solution.findBall(grid) == [-1, -1, -1]", "def test_findBall():\n    solution = Solution()\n    grid = [[1, 2, -1], [3, 4, -1], [-1, -1, -1]]\n    assert solution.findBall(grid) == [-1, -1, -1]", "def test_findBall():\n    solution = Solution()\n    grid = [[-1, -1, 1], [1, 1, -1], [-1, -1, -1], [-1, -1, 1]]\n    assert solution.findBall(grid) == [2, -1, -1]", "def test_findBall():\n    solution = Solution()\n    grid = [[-1, -1, -1], [-1, -1, 1], [1, 1, -1], [1, -1, -1]]\n    assert solution.findBall(grid) == [2, -1, -1]", "def test_findBall():\n    solution = Solution()\n    grid = [[-1, -1, -1], [-1, 1, 1], [1, -1, -1], [-1, -1, -1]]\n    assert solution.findBall(grid) == [2, -1]", "def test_findBall():\n    solution = Solution()\n    grid = [[-1, -1, -1], [1, -1, -1], [-1, -1, -1], [-1, -1, 1]]\n    assert solution.findBall(grid) == [-1]", "def test_findBall():\n    solution = Solution()\n    grid = [[-1, -1, 1], [1, 1, -1], [-1, -1, -1], [-1, -1, -1]]\n    assert solution.findBall(grid) == [-1]", "def test_findBall():\n    solution = Solution()\n    grid = [[-1, -1, -1], [-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]\n    assert solution.findBall(grid) == [-1, -1, -1]", "def test_findBall():\n    solution = Solution()\n    grid = [[-1, -1, -1], [1, -1, -1], [-1, -1, -1], [-1, -1, -1]]\n    assert solution.findBall(grid) == [-1]", "def test_findBall():\n    solution = Solution()\n    grid = [[-1, -1, -1], [1, 1, 1], [-1, -1, -1], [-1, -1, -1]]\n    assert solution.findBall(grid) == [-1]", "def test_findBall():\n    solution = Solution()\n    grid = [[-1, -1, 1], [1, 1, 1], [-1, -1, -1], [-1, -1, -1]]\n    assert solution.findBall(grid) == [-1]"]}
{"task_num": 1707, "task_title": "Maximum XOR With an Element From Array", "func_name": "maximizeXor", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Optional\n\nclass TrieNode:\n  def __init__(self):\n    self.children: List[Optional[TrieNode]] = [None] * 2\n\n\nclass BitTrie:\n  def __init__(self, maxBit: int):\n    self.maxBit = maxBit\n    self.root = TrieNode()\n\n  def insert(self, num: int) -> None:\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n\n  def getMaxXor(self, num: int) -> int:\n    maxXor = 0\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      toggleBit = bit ^ 1\n      if node.children[toggleBit]:\n        maxXor = maxXor | 1 << i\n        node = node.children[toggleBit]\n      elif node.children[bit]:\n        node = node.children[bit]\n      else:\n        return 0\n    return maxXor\n\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, x: int, m: int):\n    self.queryIndex = queryIndex\n    self.x = x\n    self.m = m\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.x\n    yield self.m\n\n\nclass Solution:\n  def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n    ans = [-1] * len(queries)\n    maxBit = int(math.log2(max(max(nums), max(x for x, _ in queries))))\n    bitTrie = BitTrie(maxBit)\n\n    nums.sort()\n\n    i = 0\n    for queryIndex, x, m in sorted([IndexedQuery(i, x, m) for i, (x, m) in enumerate(queries)], key=lambda iq: iq.m):\n      while i < len(nums) and nums[i] <= m:\n        bitTrie.insert(nums[i])\n        i += 1\n      if i > 0 and nums[i - 1] <= m:\n        ans[queryIndex] = bitTrie.getMaxXor(x)\n\n    return ans\n", "tests": ["def test_maximizeXor():\n\n    class Solution:\n\n        def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n            ans = [-1] * len(queries)\n            maxBit = int(math.log2(max(max(nums), max((x for (x, _) in queries)))))\n            bitTrie = BitTrie(maxBit)\n            nums.sort()\n            i = 0\n            for (queryIndex, x, m) in sorted([IndexedQuery(i, x, m) for (i, (x, m)) in enumerate(queries)], key=lambda iq: iq.m):\n                while i < len(nums) and nums[i] <= m:\n                    bitTrie.insert(nums[i])\n                    i += 1\n                if i > 0 and nums[i - 1] <= m:\n                    ans[queryIndex] = bitTrie.getMaxXor(x)\n            return ans\n    import math\n\n    class TrieNode:\n\n        def __init__(self):\n            self.children: List[Optional[TrieNode]] = [None] * 2\n\n    class BitTrie:\n\n        def __init__(self, maxBit: int):\n            self.maxBit = maxBit\n            self.root = TrieNode()\n\n        def insert(self, num: int) -> None:\n            node = self.root\n            for i in range(self.maxBit, -1, -1):\n                bit = num >> i & 1\n                if not node.children[bit]:\n                    node.children[bit] = TrieNode()\n                node = node.children[bit]\n\n        def getMaxXor(self, num: int) -> int:\n            maxXor = 0\n            node = self.root\n            for i in range(self.maxBit, -1, -1):\n                bit = num >> i & 1\n                toggleBit = bit ^ 1\n                if node.children[toggleBit]:\n                    maxXor = maxXor | 1 << i\n                    node = node.children[toggleBit]\n                elif node.children[bit]:\n                    node = node.children[bit]\n                else:\n                    return 0\n            return maxXor\n\n    class IndexedQuery:\n\n        def __init__(self, queryIndex: int, x: int, m: int):\n            self.queryIndex = queryIndex\n            self.x = x\n            self.m = m\n\n        def __iter__(self):\n            yield self.queryIndex\n            yield self.x\n            yield self.m\n    solution = Solution()\n    nums = [0, 1, 2, 3, 4, 5]\n    queries = [[1, 2], [2, 3]]\n    print(solution.maximizeXor(nums, queries))", "def test_maximizeXor():\n    solution = Solution()\n    nums = [1, 3, 5]\n    queries = [[2, 4], [0, 1]]\n    print(solution.maximizeXor(nums, queries))", "def test_maximizeXor():\n    solution = Solution()\n    nums = [10 ** 6, 10 ** 7, 10 ** 8]\n    queries = [[1, 10], [2, 100]]\n    print(solution.maximizeXor(nums, queries))", "def test_maximizeXor():\n    solution = Solution()\n    nums = [255, 254]\n    queries = [[1, 2], [3, 4]]\n    print(solution.maximizeXor(nums, queries))", "def test_maximizeXor():\n    solution = Solution()\n    nums = [10, 20, 30]\n    queries = [[5, 100], [25, 50]]\n    print(solution.maximizeXor(nums, queries))", "def test_maximizeXor():\n    solution = Solution()\n    nums = [0, 1, 2]\n    queries = [[3, 100], [4, 5]]\n    print(solution.maximizeXor(nums, queries))", "def test_maximizeXor():\n    solution = Solution()\n    nums = [0, 10, 20]\n    queries = [[5, 15], [25, 30]]\n    print(solution.maximizeXor(nums, queries))", "def test_maximizeXor():\n    solution = Solution()\n    nums = [5, 7, 9]\n    queries = [[2, 4], [0, 3]]\n    print(solution.maximizeXor(nums, queries))", "def test_maximizeXor():\n    solution = Solution()\n    nums = [10, 20, 30]\n    queries = [[15, 25], [35, 40]]\n    print(solution.maximizeXor(nums, queries))", "def test_maximizeXor():\n    solution = Solution()\n    nums = [170, 204]\n    queries = [[1, 2], [3, 4]]\n    print(solution.maximizeXor(nums, queries))", "def test_maximizeXor():\n    solution = Solution()\n    nums = [1000, 2000, 3000]\n    queries = [[500, 1500], [2500, 3500]]\n    print(solution.maximizeXor(nums, queries))", "def test_maximizeXor():\n    solution = Solution()\n    nums = [15, 30, 45]\n    queries = [[20, 40], [50, 55]]\n    print(solution.maximizeXor(nums, queries))", "def test_maximizeXor():\n    solution = Solution()\n    nums = [2 ** 23 + 1, 2 ** 24 + 1]\n    queries = [[2 ** 22, 2 ** 25], [0, 1]]\n    print(solution.maximizeXor(nums, queries))", "def test_maximizeXor():\n    solution = Solution()\n    nums = [240, 207]\n    queries = [[1, 2], [3, 4]]\n    print(solution.maximizeXor(nums, queries))", "def test_maximizeXor():\n    solution = Solution()\n    nums = [10000, 20000, 30000]\n    queries = [[5000, 15000], [25000, 35000]]\n    print(solution.maximizeXor(nums, queries))", "def test_maximizeXor():\n    solution = Solution()\n    nums = [128, 255]\n    queries = [[1, 2], [3, 4]]\n    print(solution.maximizeXor(nums, queries))", "def test_maximizeXor():\n    solution = Solution()\n    nums = [2147483647, 2147483648]\n    queries = [[-1, 1000000], [2000000, 3000000]]\n    print(solution.maximizeXor(nums, queries))", "def test_maximizeXor():\n    solution = Solution()\n    nums = [4294967295, 4294967296]\n    queries = [[1, 2], [3, 4]]\n    print(solution.maximizeXor(nums, queries))", "def test_maximizeXor():\n    solution = Solution()\n    nums = [2 ** 32 - 1, 2 ** 32]\n    queries = [[0, 2147483647], [-1, 10000000]]\n    print(solution.maximizeXor(nums, queries))", "def test_maximizeXor():\n    solution = Solution()\n    nums = [4294967295, 4294967296]\n    queries = [[2147483647, 1000000], [2000000, 3000000]]\n    print(solution.maximizeXor(nums, queries))"]}
{"task_num": 1717, "task_title": "Maximum Score From Removing Substrings", "func_name": "maximumGain", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumGain(self, s: str, x: int, y: int) -> int:\n    if x > y:\n      return self._gain(s, 'ab', x, 'ba', y)\n    else:\n      return self._gain(s, 'ba', y, 'ab', x)\n\n  def _gain(self, s: str, sub1: str, point1: int, sub2: str, point2: int) -> int:\n    points = 0\n    stack1 = []\n    stack2 = []\n\n    for c in s:\n      if stack1 and stack1[-1] == sub1[0] and c == sub1[1]:\n        stack1.pop()\n        points += point1\n      else:\n        stack1.append(c)\n\n    for c in stack1:\n      if stack2 and stack2[-1] == sub2[0] and c == sub2[1]:\n        stack2.pop()\n        points += point2\n      else:\n        stack2.append(c)\n\n    return points\n", "tests": ["def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('cdbcbbaaabab', 4, 5) == 10", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('baabaa', 1, 3) == 2", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('abbab', 1, 4) == 3", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('', 1, 2) == 0", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('ab', 5, 1) == 5", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('abba', 2, 3) == 5", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('abba', 3, 2) == 5", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('aabbaab', 2, 1) == 7", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('aabbbbaab', 1, 2) == 6", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('bbbaab', 3, 1) == 5", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('ababb', 2, 3) == 5", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('aaaaab', 1, 2) == 4", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('abbabba', 1, 4) == 6", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('abbaaab', 3, 1) == 8", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('baabaaabbb', 2, 3) == 7", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('babab', 3, 2) == 5", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('aaaabbaaab', 1, 2) == 6", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('abbaaabba', 2, 3) == 9", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('bbaabaa', 4, 1) == 8", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('aabbabbaaab', 2, 3) == 10"]}
{"task_num": 1719, "task_title": "Number Of Ways To Reconstruct A Tree", "func_name": "checkWays", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def checkWays(self, pairs: List[List[int]]) -> int:\n    kMax = 501\n    graph = collections.defaultdict(list)\n    degrees = [0] * kMax\n    connected = [[False] * kMax for _ in range(kMax)]\n\n    for u, v in pairs:\n      graph[u].append(v)\n      graph[v].append(u)\n      degrees[u] += 1\n      degrees[v] += 1\n      connected[u][v] = True\n      connected[v][u] = True\n\n    for _, children in graph.items():\n      children.sort(key=lambda a: degrees[a], reverse=True)\n\n    root = next((i for i, d in enumerate(degrees) if d == len(graph) - 1), -1)\n    if root == -1:\n      return 0\n\n    hasMoreThanOneWay = False\n\n    def dfs(u: int, ancestors: List[int], seen: List[bool]) -> bool:\n      nonlocal hasMoreThanOneWay\n      seen[u] = True\n      for ancestor in ancestors:\n        if not connected[u][ancestor]:\n          return False\n      ancestors.append(u)\n      for v in graph[u]:\n        if seen[v]:\n          continue\n        if degrees[v] == degrees[u]:\n          hasMoreThanOneWay = True\n        if not dfs(v, ancestors, seen):\n          return False\n      ancestors.pop()\n      return True\n\n    if not dfs(root, [], [False] * kMax):\n      return 0\n    if hasMoreThanOneWay:\n      return 2\n    else:\n      return 1\n", "tests": ["    def test_checkWays(self):\n        pairs = [[1,2],[2,3],[3,4]]\n        self.assertEqual(Solution().checkWays(pairs), 1)\n\nif __name__ == '__main__':\n    unittest.main()", "    def test_checkWays_multiple_roots(self):\n        pairs = [[1,2],[3,4],[5,6]]\n        self.assertEqual(Solution().checkWays(pairs), 0)\n\nif __name__ == '__main__':\n    unittest.main()", "    def test_checkWays_single_node(self):\n        pairs = [[1,2]]\n        self.assertEqual(Solution().checkWays(pairs), 0)\n\nif __name__ == '__main__':\n    unittest.main()", "    def test_checkWays_no_edges(self):\n        pairs = [[1,1]]\n        self.assertEqual(Solution().checkWays(pairs), 2)\n\nif __name__ == '__main__':\n    unittest.main()", "    def test_checkWays_large_graph(self):\n        pairs = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9]]\n        self.assertEqual(Solution().checkWays(pairs), 1)\n\nif __name__ == '__main__':\n    unittest.main()", "    def test_checkWays_complete_graph(self):\n        pairs = [[1,2],[2,3],[3,4],[4,5],[5,6]]\n        self.assertEqual(Solution().checkWays(pairs), 0)\n\nif __name__ == '__main__':\n    unittest.main()", "    def test_checkWays_empty_input(self):\n        pairs = []\n        self.assertEqual(Solution().checkWays(pairs), 0)\n\nif __name__ == '__main__':\n    unittest.main()", "    def test_checkWays_multiple_ways(self):\n        pairs = [[1,2],[3,4],[5,6],[6,7]]\n        self.assertEqual(Solution().checkWays(pairs), 2)\n\nif __name__ == '__main__':\n    unittest.main()", "    def test_checkWays_symmetric_edges(self):\n        pairs = [[1,2],[2,1]]\n        self.assertEqual(Solution().checkWays(pairs), 0)\n\nif __name__ == '__main__':\n    unittest.main()", "    def test_checkWays_invalid_input(self):\n        pairs = [[1,\"a\"]]\n        self.assertEqual(Solution().checkWays(pairs), 0)\n\nif __name__ == '__main__':\n    unittest.main()", "    def test_checkWays_negative_edges(self):\n        pairs = [[-1,-2]]\n        self.assertEqual(Solution().checkWays(pairs), 0)\n\nif __name__ == '__main__':\n    unittest.main()", "    def test_checkWays_one_node_multiple_parents(self):\n        pairs = [[1,2],[2,3]]\n        self.assertEqual(Solution().checkWays(pairs), 0)\n\nif __name__ == '__main__':\n    unittest.main()", "    def test_checkWays_large_tree(self):\n        pairs = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9],[9,10]]\n        self.assertEqual(Solution().checkWays(pairs), 0)\n\nif __name__ == '__main__':\n    unittest.main()", "    def test_checkWays_disconnected_graph(self):\n        pairs = [[1,2],[3,4]]\n        self.assertEqual(Solution().checkWays(pairs), 0)\n\nif __name__ == '__main__':\n    unittest.main()", "    def test_checkWays_no_circular_edges(self):\n        pairs = [[1,2],[2,3],[3,4],[4,5]]\n        self.assertEqual(Solution().checkWays(pairs), 0)\n\nif __name__ == '__main__':\n    unittest.main()", "    def test_checkWays_no_self_loops(self):\n        pairs = [[1,2],[3,4]]\n        self.assertEqual(Solution().checkWays(pairs), 0)\n\nif __name__ == '__main__':\n    unittest.main()", "    def test_checkWays_no_triangles(self):\n        pairs = [[1,2],[3,4]]\n        self.assertEqual(Solution().checkWays(pairs), 0)\n\nif __name__ == '__main__':\n    unittest.main()", "    def test_checkWays_zero_pairs(self):\n        pairs = []\n        self.assertEqual(Solution().checkWays(pairs), 0)\n\nif __name__ == '__main__':\n    unittest.main()", "    def test_checkWays_max_k(self):\n        pairs = [[1,2],[3,4]]\n        kMax = 5\n        self.assertEqual(Solution().checkWays(pairs), 0)\n\nif __name__ == '__main__':\n    unittest.main()", "    def test_checkWays_invalid_pairs(self):\n        pairs = [[1,'a']]\n        self.assertEqual(Solution().checkWays(pairs), 0)\n\nif __name__ == '__main__':\n    unittest.main()"]}
{"task_num": 1722, "task_title": "Minimize Hamming Distance After Swap Operations", "func_name": "minimumHammingDistance", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -> int:\n    n = len(source)\n    ans = 0\n    uf = UnionFind(n)\n    groupIdToCount = [collections.Counter() for _ in range(n)]\n\n    for a, b in allowedSwaps:\n      uf.unionByRank(a, b)\n\n    for i in range(n):\n      groupIdToCount[uf.find(i)][source[i]] += 1\n\n    for i in range(n):\n      groupId = uf.find(i)\n      count = groupIdToCount[groupId]\n      if target[i] not in count:\n        ans += 1\n      else:\n        count[target[i]] -= 1\n        if count[target[i]] == 0:\n          del count[target[i]]\n\n    return ans\n", "tests": ["def test_minimumHammingDistance():\n\n    def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -> int:\n        n = len(source)\n        ans = 0\n        uf = UnionFind(n)\n        groupIdToCount = [collections.Counter() for _ in range(n)]\n        for (a, b) in allowedSwaps:\n            uf.unionByRank(a, b)\n        for i in range(n):\n            groupIdToCount[uf.find(i)][source[i]] += 1\n        for i in range(n):\n            groupId = uf.find(i)\n            count = groupIdToCount[groupId]\n            if target[i] not in count:\n                ans += 1\n            else:\n                count[target[i]] -= 1\n                if count[target[i]] == 0:\n                    del count[target[i]]\n        return ans\nsolution = Solution()\nprint(solution.minimumHammingDistance([7, 1, 3], [2, 4, 6], [[0, 1], [1, 2]]))", "def test_minimumHammingDistance():\n\n    def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -> int:\n        n = len(source)\n        ans = 0\n        uf = UnionFind(n)\n        groupIdToCount = [collections.Counter() for _ in range(n)]\n        for (a, b) in allowedSwaps:\n            uf.unionByRank(a, b)\n        for i in range(n):\n            groupIdToCount[uf.find(i)][source[i]] += 1\n        for i in range(n):\n            groupId = uf.find(i)\n            count = groupIdToCount[groupId]\n            if target[i] not in count:\n                ans += 1\n            else:\n                count[target[i]] -= 1\n                if count[target[i]] == 0:\n                    del count[target[i]]\n        return ans\nsolution = Solution()\nprint(solution.minimumHammingDistance([3, 5, 7], [2, 4, 6], [[0, 1], [1, 2]]))", "def test_minimumHammingDistance():\n\n    def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -> int:\n        n = len(source)\n        ans = 0\n        uf = UnionFind(n)\n        groupIdToCount = [collections.Counter() for _ in range(n)]\n        for (a, b) in allowedSwaps:\n            uf.unionByRank(a, b)\n        for i in range(n):\n            groupIdToCount[uf.find(i)][source[i]] += 1\n        for i in range(n):\n            groupId = uf.find(i)\n            count = groupIdToCount[groupId]\n            if target[i] not in count:\n                ans += 1\n            else:\n                count[target[i]] -= 1\n                if count[target[i]] == 0:\n                    del count[target[i]]\n        return ans\nsolution = Solution()\nprint(solution.minimumHammingDistance([5, 8, 9], [5, 8, 9], [[0, 2]]))", "def test_minimumHammingDistance():\n\n    def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -> int:\n        n = len(source)\n        ans = 0\n        uf = UnionFind(n)\n        groupIdToCount = [collections.Counter() for _ in range(n)]\n        for (a, b) in allowedSwaps:\n            uf.unionByRank(a, b)\n        for i in range(n):\n            groupIdToCount[uf.find(i)][source[i]] += 1\n        for i in range(n):\n            groupId = uf.find(i)\n            count = groupIdToCount[groupId]\n            if target[i] not in count:\n                ans += 1\n            else:\n                count[target[i]] -= 1\n                if count[target[i]] == 0:\n                    del count[target[i]]\n        return ans\nsolution = Solution()\nprint(solution.minimumHammingDistance([2, 4, 6], [5, 8, 9], [[0, 1]]))", "def test_minimumHammingDistance():\n\n    def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -> int:\n        n = len(source)\n        ans = 0\n        uf = UnionFind(n)\n        groupIdToCount = [collections.Counter() for _ in range(n)]\n        for (a, b) in allowedSwaps:\n            uf.unionByRank(a, b)\n        for i in range(n):\n            groupIdToCount[uf.find(i)][source[i]] += 1\n        for i in range(n):\n            groupId = uf.find(i)\n            count = groupIdToCount[groupId]\n            if target[i] not in count:\n                ans += 1\n            else:\n                count[target[i]] -= 1\n                if count[target[i]] == 0:\n                    del count[target[i]]\n        return ans\nsolution = Solution()\nprint(solution.minimumHammingDistance([3, 3, 7], [2, 4, 6], [[1, 2]]))", "def test_minimumHammingDistance():\n\n    def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -> int:\n        n = len(source)\n        ans = 0\n        uf = UnionFind(n)\n        groupIdToCount = [collections.Counter() for _ in range(n)]\n        for (a, b) in allowedSwaps:\n            uf.unionByRank(a, b)\n        for i in range(n):\n            groupIdToCount[uf.find(i)][source[i]] += 1\n        for i in range(n):\n            groupId = uf.find(i)\n            count = groupIdToCount[groupId]\n            if target[i] not in count:\n                ans += 1\n            else:\n                count[target[i]] -= 1\n                if count[target[i]] == 0:\n                    del count[target[i]]\n        return ans\nsolution = Solution()\nprint(solution.minimumHammingDistance([2, 3, 4], [5, 6, 7], [[0, 1], [1, 2]]))", "def test_minimumHammingDistance():\n\n    def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -> int:\n        n = len(source)\n        ans = 0\n        uf = UnionFind(n)\n        groupIdToCount = [collections.Counter() for _ in range(n)]\n        for (a, b) in allowedSwaps:\n            uf.unionByRank(a, b)\n        for i in range(n):\n            groupIdToCount[uf.find(i)][source[i]] += 1\n        for i in range(n):\n            groupId = uf.find(i)\n            count = groupIdToCount[groupId]\n            if target[i] not in count:\n                ans += 1\n            else:\n                count[target[i]] -= 1\n                if count[target[i]] == 0:\n                    del count[target[i]]\n        return ans\nsolution = Solution()\nprint(solution.minimumHammingDistance([1, 2, 3], [4, 5, 6], [[0, 1], [1, 2], [2, 0]]))", "def test_minimumHammingDistance():\n\n    def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -> int:\n        n = len(source)\n        ans = 0\n        uf = UnionFind(n)\n        groupIdToCount = [collections.Counter() for _ in range(n)]\n        for (a, b) in allowedSwaps:\n            uf.unionByRank(a, b)\n        for i in range(n):\n            groupIdToCount[uf.find(i)][source[i]] += 1\n        for i in range(n):\n            groupId = uf.find(i)\n            count = groupIdToCount[groupId]\n            if target[i] not in count:\n                ans += 1\n            else:\n                count[target[i]] -= 1\n                if count[target[i]] == 0:\n                    del count[target[i]]\n        return ans\nsolution = Solution()\nprint(solution.minimumHammingDistance([2, 2, 2], [4, 5, 6], [[0, 1], [1, 2]]))", "def test_minimumHammingDistance():\n\n    def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -> int:\n        n = len(source)\n        ans = 0\n        uf = UnionFind(n)\n        groupIdToCount = [collections.Counter() for _ in range(n)]\n        for (a, b) in allowedSwaps:\n            uf.unionByRank(a, b)\n        for i in range(n):\n            groupIdToCount[uf.find(i)][source[i]] += 1\n        for i in range(n):\n            groupId = uf.find(i)\n            count = groupIdToCount[groupId]\n            if target[i] not in count:\n                ans += 1\n            else:\n                count[target[i]] -= 1\n                if count[target[i]] == 0:\n                    del count[target[i]]\n        return ans\nsolution = Solution()\nprint(solution.minimumHammingDistance([7, 5, 9], [2, 4, 6], [[0, 2]]))", "def test_minimumHammingDistance():\n\n    def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -> int:\n        n = len(source)\n        ans = 0\n        uf = UnionFind(n)\n        groupIdToCount = [collections.Counter() for _ in range(n)]\n        for (a, b) in allowedSwaps:\n            uf.unionByRank(a, b)\n        for i in range(n):\n            groupIdToCount[uf.find(i)][source[i]] += 1\n        for i in range(n):\n            groupId = uf.find(i)\n            count = groupIdToCount[groupId]\n            if target[i] not in count:\n                ans += 1\n            else:\n                count[target[i]] -= 1\n                if count[target[i]] == 0:\n                    del count[target[i]]\n        return ans\nsolution = Solution()\nprint(solution.minimumHammingDistance([8, 7, 9], [2, 4, 6], [[0, 2]]))", "def test_minimumHammingDistance():\n\n    def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -> int:\n        n = len(source)\n        ans = 0\n        uf = UnionFind(n)\n        groupIdToCount = [collections.Counter() for _ in range(n)]\n        for (a, b) in allowedSwaps:\n            uf.unionByRank(a, b)\n        for i in range(n):\n            groupIdToCount[uf.find(i)][source[i]] += 1\n        for i in range(n):\n            groupId = uf.find(i)\n            count = groupIdToCount[groupId]\n            if target[i] not in count:\n                ans += 1\n            else:\n                count[target[i]] -= 1\n                if count[target[i]] == 0:\n                    del count[target[i]]\n        return ans\nsolution = Solution()\nprint(solution.minimumHammingDistance([1, 2, 3], [4, 5, 6], [[0, 1], [2, 0]]))", "def test_minimumHammingDistance():\n\n    def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -> int:\n        n = len(source)\n        ans = 0\n        uf = UnionFind(n)\n        groupIdToCount = [collections.Counter() for _ in range(n)]\n        for (a, b) in allowedSwaps:\n            uf.unionByRank(a, b)\n        for i in range(n):\n            groupIdToCount[uf.find(i)][source[i]] += 1\n        for i in range(n):\n            groupId = uf.find(i)\n            count = groupIdToCount[groupId]\n            if target[i] not in count:\n                ans += 1\n            else:\n                count[target[i]] -= 1\n                if count[target[i]] == 0:\n                    del count[target[i]]\n        return ans\nsolution = Solution()\nprint(solution.minimumHammingDistance([6, 2, 3], [4, 5, 6], [[0, 2], [0, 1]]))", "def test_minimumHammingDistance():\n\n    def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -> int:\n        n = len(source)\n        ans = 0\n        uf = UnionFind(n)\n        groupIdToCount = [collections.Counter() for _ in range(n)]\n        for (a, b) in allowedSwaps:\n            uf.unionByRank(a, b)\n        for i in range(n):\n            groupIdToCount[uf.find(i)][source[i]] += 1\n        for i in range(n):\n            groupId = uf.find(i)\n            count = groupIdToCount[groupId]\n            if target[i] not in count:\n                ans += 1\n            else:\n                count[target[i]] -= 1\n                if count[target[i]] == 0:\n                    del count[target[i]]\n        return ans\nsolution = Solution()\nprint(solution.minimumHammingDistance([3, 5, 7], [2, 4, 9], [[0, 1], [2, 0]]))", "def test_minimumHammingDistance():\n\n    def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -> int:\n        n = len(source)\n        ans = 0\n        uf = UnionFind(n)\n        groupIdToCount = [collections.Counter() for _ in range(n)]\n        for (a, b) in allowedSwaps:\n            uf.unionByRank(a, b)\n        for i in range(n):\n            groupIdToCount[uf.find(i)][source[i]] += 1\n        for i in range(n):\n            groupId = uf.find(i)\n            count = groupIdToCount[groupId]\n            if target[i] not in count:\n                ans += 1\n            else:\n                count[target[i]] -= 1\n                if count[target[i]] == 0:\n                    del count[target[i]]\n        return ans\nsolution = Solution()\nprint(solution.minimumHammingDistance([2, 4, 6], [3, 5, 7], [[0, 1], [1, 2]]))", "def test_minimumHammingDistance():\n\n    def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -> int:\n        n = len(source)\n        ans = 0\n        uf = UnionFind(n)\n        groupIdToCount = [collections.Counter() for _ in range(n)]\n        for (a, b) in allowedSwaps:\n            uf.unionByRank(a, b)\n        for i in range(n):\n            groupIdToCount[uf.find(i)][source[i]] += 1\n        for i in range(n):\n            groupId = uf.find(i)\n            count = groupIdToCount[groupId]\n            if target[i] not in count:\n                ans += 1\n            else:\n                count[target[i]] -= 1\n                if count[target[i]] == 0:\n                    del count[target[i]]\n        return ans\nsolution = Solution()\nprint(solution.minimumHammingDistance([8, 7, 9], [2, 4, 6], [[0, 2], [1, 2]]))", "def test_minimumHammingDistance():\n\n    def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -> int:\n        n = len(source)\n        ans = 0\n        uf = UnionFind(n)\n        groupIdToCount = [collections.Counter() for _ in range(n)]\n        for (a, b) in allowedSwaps:\n            uf.unionByRank(a, b)\n        for i in range(n):\n            groupIdToCount[uf.find(i)][source[i]] += 1\n        for i in range(n):\n            groupId = uf.find(i)\n            count = groupIdToCount[groupId]\n            if target[i] not in count:\n                ans += 1\n            else:\n                count[target[i]] -= 1\n                if count[target[i]] == 0:\n                    del count[target[i]]\n        return ans\nsolution = Solution()\nprint(solution.minimumHammingDistance([3, 5, 7], [2, 4, 9], [[0, 1], [2, 0], [1, 2]]))", "def test_minimumHammingDistance():\n\n    def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -> int:\n        n = len(source)\n        ans = 0\n        uf = UnionFind(n)\n        groupIdToCount = [collections.Counter() for _ in range(n)]\n        for (a, b) in allowedSwaps:\n            uf.unionByRank(a, b)\n        for i in range(n):\n            groupIdToCount[uf.find(i)][source[i]] += 1\n        for i in range(n):\n            groupId = uf.find(i)\n            count = groupIdToCount[groupId]\n            if target[i] not in count:\n                ans += 1\n            else:\n                count[target[i]] -= 1\n                if count[target[i]] == 0:\n                    del count[target[i]]\n        return ans\nsolution = Solution()\nprint(solution.minimumHammingDistance([2, 4, 6], [3, 5, 7], [[0, 1], [1, 2]]))", "def test_minimumHammingDistance():\n\n    def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -> int:\n        n = len(source)\n        ans = 0\n        uf = UnionFind(n)\n        groupIdToCount = [collections.Counter() for _ in range(n)]\n        for (a, b) in allowedSwaps:\n            uf.unionByRank(a, b)\n        for i in range(n):\n            groupIdToCount[uf.find(i)][source[i]] += 1\n        for i in range(n):\n            groupId = uf.find(i)\n            count = groupIdToCount[groupId]\n            if target[i] not in count:\n                ans += 1\n            else:\n                count[target[i]] -= 1\n                if count[target[i]] == 0:\n                    del count[target[i]]\n        return ans\nsolution = Solution()\nprint(solution.minimumHammingDistance([8, 7, 9], [2, 4, 6], [[0, 2], [1, 2]]))", "def test_minimumHammingDistance():\n\n    def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -> int:\n        n = len(source)\n        ans = 0\n        uf = UnionFind(n)\n        groupIdToCount = [collections.Counter() for _ in range(n)]\n        for (a, b) in allowedSwaps:\n            uf.unionByRank(a, b)\n        for i in range(n):\n            groupIdToCount[uf.find(i)][source[i]] += 1\n        for i in range(n):\n            groupId = uf.find(i)\n            count = groupIdToCount[groupId]\n            if target[i] not in count:\n                ans += 1\n            else:\n                count[target[i]] -= 1\n                if count[target[i]] == 0:\n                    del count[target[i]]\n        return ans\nsolution = Solution()\nprint(solution.minimumHammingDistance([3, 5, 7], [2, 4, 9], [[0, 1], [2, 0], [1, 2]]))", "def test_minimumHammingDistance():\n\n    def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -> int:\n        n = len(source)\n        ans = 0\n        uf = UnionFind(n)\n        groupIdToCount = [collections.Counter() for _ in range(n)]\n        for (a, b) in allowedSwaps:\n            uf.unionByRank(a, b)\n        for i in range(n):\n            groupIdToCount[uf.find(i)][source[i]] += 1\n        for i in range(n):\n            groupId = uf.find(i)\n            count = groupIdToCount[groupId]\n            if target[i] not in count:\n                ans += 1\n            else:\n                count[target[i]] -= 1\n                if count[target[i]] == 0:\n                    del count[target[i]]\n        return ans\nsolution = Solution()\nprint(solution.minimumHammingDistance([2, 4, 6], [3, 5, 7], [[0, 1], [1, 2]]))"]}
{"task_num": 1735, "task_title": "Count Ways to Make Array With Product", "func_name": "waysToFillArray", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def waysToFillArray(self, queries: List[List[int]]) -> List[int]:\n    kMod = 1_000_000_007\n    kMax = 10_000\n    minPrimeFactors = self._sieveEratosthenes(kMax + 1)\n\n    @functools.lru_cache(None)\n    def fact(i: int) -> int:\n      return 1 if i <= 1 else i * fact(i - 1) % kMod\n\n    @functools.lru_cache(None)\n    def inv(i: int) -> int:\n      return pow(i, kMod - 2, kMod)\n\n    @functools.lru_cache(None)\n    def nCk(n: int, k: int) -> int:\n      return fact(n) * inv(fact(k)) * inv(fact(n - k)) % kMod\n\n    ans = []\n\n    for n, k in queries:\n      res = 1\n      for freq in self._getPrimeFactorsCount(k, minPrimeFactors).values():\n        res = res * nCk(n - 1 + freq, freq) % kMod\n      ans.append(res)\n\n    return ans\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeFactorsCount(self, num: int, minPrimeFactors: List[int]) -> Dict[int, int]:\n    count = collections.Counter()\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      while num % divisor == 0:\n        num //= divisor\n        count[divisor] += 1\n    return count\n", "tests": ["def test_waysToFillArray(self):\n    solution = Solution()\n    queries = [[2, 3]]\n    self.assertEqual(solution.waysToFillArray(queries), [6])", "def test_waysToFillArray(self):\n    solution = Solution()\n    queries = [[5, 10]]\n    self.assertEqual(solution.waysToFillArray(queries), [246])", "def test_waysToFillArray(self):\n    solution = Solution()\n    queries = [[1, 2]]\n    self.assertEqual(solution.waysToFillArray(queries), [0])", "def test_waysToFillArray(self):\n    solution = Solution()\n    queries = [[7, 1]]\n    self.assertEqual(solution.waysToFillArray(queries), [1])", "def test_waysToFillArray(self):\n    solution = Solution()\n    queries = [[9, 11]]\n    self.assertEqual(solution.waysToFillArray(queries), [0])", "def test_waysToFillArray(self):\n    solution = Solution()\n    queries = [[3, 9]]\n    self.assertEqual(solution.waysToFillArray(queries), [0])", "def test_waysToFillArray(self):\n    solution = Solution()\n    queries = [[10 ** 6, 2 * 10 ** 12]]\n    self.assertEqual(solution.waysToFillArray(queries), [1])", "def test_waysToFillArray(self):\n    solution = Solution()\n    queries = [[8, 6]]\n    self.assertEqual(solution.waysToFillArray(queries), [0])", "def test_waysToFillArray(self):\n    solution = Solution()\n    queries = [[10000, 1]]\n    self.assertEqual(solution.waysToFillArray(queries), [1])", "def test_waysToFillArray(self):\n    solution = Solution()\n    queries = [[1, 10 ** 18]]\n    self.assertEqual(solution.waysToFillArray(queries), [0])", "def test_waysToFillArray(self):\n    solution = Solution()\n    queries = [[2 ** 1000, 2 ** (1000 * 10 ** 18)]]\n    self.assertEqual(solution.waysToFillArray(queries), [0])", "def test_waysToFillArray(self):\n    solution = Solution()\n    queries = [[4, 20]]\n    self.assertEqual(solution.waysToFillArray(queries), [0])", "def test_waysToFillArray(self):\n    solution = Solution()\n    queries = [[7, 14]]\n    self.assertEqual(solution.waysToFillArray(queries), [0])", "def test_waysToFillArray(self):\n    solution = Solution()\n    queries = [[11, 121]]\n    self.assertEqual(solution.waysToFillArray(queries), [0])", "def test_waysToFillArray(self):\n    solution = Solution()\n    queries = [[13, 2197]]\n    self.assertEqual(solution.waysToFillArray(queries), [0])", "def test_waysToFillArray(self):\n    solution = Solution()\n    queries = [[23, 12111]]\n    self.assertEqual(solution.waysToFillArray(queries), [0])", "def test_waysToFillArray(self):\n    solution = Solution()\n    queries = [[17, 74088]]\n    self.assertEqual(solution.waysToFillArray(queries), [0])", "def test_waysToFillArray(self):\n    solution = Solution()\n    queries = [[23, 2197]]\n    self.assertEqual(solution.waysToFillArray(queries), [0])", "def test_waysToFillArray(self):\n    solution = Solution()\n    queries = [[1000003, 1]]\n    self.assertEqual(solution.waysToFillArray(queries), [0])", "def test_waysToFillArray(self):\n    solution = Solution()\n    queries = [[1000003, 10000030001]]\n    self.assertEqual(solution.waysToFillArray(queries), [0])"]}
{"task_num": 1765, "task_title": "Map of Highest Peak", "func_name": "highestPeak", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(isWater)\n    n = len(isWater[0])\n    ans = [[-1] * n for _ in range(m)]\n    q = collections.deque()\n\n    for i in range(m):\n      for j in range(n):\n        if isWater[i][j] == 1:\n          q.append((i, j))\n          ans[i][j] = 0\n\n    while q:\n      i, j = q.popleft()\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if ans[x][y] != -1:\n          continue\n        ans[x][y] = ans[i][j] + 1\n        q.append((x, y))\n\n    return ans\n", "tests": ["def test_highestPeak():\n\n    class Solution:\n\n        def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            m = len(isWater)\n            n = len(isWater[0])\n            ans = [[-1] * n for _ in range(m)]\n            q = collections.deque()\n            for i in range(m):\n                for j in range(n):\n                    if isWater[i][j] == 1:\n                        q.append((i, j))\n                        ans[i][j] = 0\n            while q:\n                (i, j) = q.popleft()\n                for (dx, dy) in dirs:\n                    x = i + dx\n                    y = j + dy\n                    if x < 0 or x == m or y < 0 or (y == n):\n                        continue\n                    if ans[x][y] != -1:\n                        continue\n                    ans[x][y] = ans[i][j] + 1\n                    q.append((x, y))\n            return ans\n    solution = Solution()\n    isWater = [[0, 1], [0, 0]]\n    print(solution.highestPeak(isWater))", "def test_highestPeak():\n\n    class Solution:\n\n        def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            m = len(isWater)\n            n = len(isWater[0])\n            ans = [[-1] * n for _ in range(m)]\n            q = collections.deque()\n            for i in range(m):\n                for j in range(n):\n                    if isWater[i][j] == 1:\n                        q.append((i, j))\n                        ans[i][j] = 0\n            while q:\n                (i, j) = q.popleft()\n                for (dx, dy) in dirs:\n                    x = i + dx\n                    y = j + dy\n                    if x < 0 or x == m or y < 0 or (y == n):\n                        continue\n                    if ans[x][y] != -1:\n                        continue\n                    ans[x][y] = ans[i][j] + 1\n                    q.append((x, y))\n            return ans\n    solution = Solution()\n    isWater = [[1, 1, 0], [0, 0, 1]]\n    print(solution.highestPeak(isWater))", "def test_highestPeak():\n\n    class Solution:\n\n        def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            m = len(isWater)\n            n = len(isWater[0])\n            ans = [[-1] * n for _ in range(m)]\n            q = collections.deque()\n            for i in range(m):\n                for j in range(n):\n                    if isWater[i][j] == 1:\n                        q.append((i, j))\n                        ans[i][j] = 0\n            while q:\n                (i, j) = q.popleft()\n                for (dx, dy) in dirs:\n                    x = i + dx\n                    y = j + dy\n                    if x < 0 or x == m or y < 0 or (y == n):\n                        continue\n                    if ans[x][y] != -1:\n                        continue\n                    ans[x][y] = ans[i][j] + 1\n                    q.append((x, y))\n            return ans\n    solution = Solution()\n    isWater = [[0, 0], [0, 0]]\n    print(solution.highestPeak(isWater))", "def test_highestPeak():\n\n    class Solution:\n\n        def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            m = len(isWater)\n            n = len(isWater[0])\n            ans = [[-1] * n for _ in range(m)]\n            q = collections.deque()\n            for i in range(m):\n                for j in range(n):\n                    if isWater[i][j] == 1:\n                        q.append((i, j))\n                        ans[i][j] = 0\n            while q:\n                (i, j) = q.popleft()\n                for (dx, dy) in dirs:\n                    x = i + dx\n                    y = j + dy\n                    if x < 0 or x == m or y < 0 or (y == n):\n                        continue\n                    if ans[x][y] != -1:\n                        continue\n                    ans[x][y] = ans[i][j] + 1\n                    q.append((x, y))\n            return ans\n    solution = Solution()\n    isWater = [[1, 0, 1], [1, 0, 1]]\n    print(solution.highestPeak(isWater))", "def test_highestPeak():\n\n    class Solution:\n\n        def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            m = len(isWater)\n            n = len(isWater[0])\n            ans = [[-1] * n for _ in range(m)]\n            q = collections.deque()\n            for i in range(m):\n                for j in range(n):\n                    if isWater[i][j] == 1:\n                        q.append((i, j))\n                        ans[i][j] = 0\n            while q:\n                (i, j) = q.popleft()\n                for (dx, dy) in dirs:\n                    x = i + dx\n                    y = j + dy\n                    if x < 0 or x == m or y < 0 or (y == n):\n                        continue\n                    if ans[x][y] != -1:\n                        continue\n                    ans[x][y] = ans[i][j] + 1\n                    q.append((x, y))\n            return ans\n    solution = Solution()\n    isWater = [[0, 0], [1, 1]]\n    print(solution.highestPeak(isWater))", "def test_highestPeak():\n\n    class Solution:\n\n        def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            m = len(isWater)\n            n = len(isWater[0])\n            ans = [[-1] * n for _ in range(m)]\n            q = collections.deque()\n            for i in range(m):\n                for j in range(n):\n                    if isWater[i][j] == 1:\n                        q.append((i, j))\n                        ans[i][j] = 0\n            while q:\n                (i, j) = q.popleft()\n                for (dx, dy) in dirs:\n                    x = i + dx\n                    y = j + dy\n                    if x < 0 or x == m or y < 0 or (y == n):\n                        continue\n                    if ans[x][y] != -1:\n                        continue\n                    ans[x][y] = ans[i][j] + 1\n                    q.append((x, y))\n            return ans\n    solution = Solution()\n    isWater = [[1, 1, 1], [0, 0, 1], [0, 0, 1]]\n    print(solution.highestPeak(isWater))", "def test_highestPeak():\n\n    class Solution:\n\n        def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            m = len(isWater)\n            n = len(isWater[0])\n            ans = [[-1] * n for _ in range(m)]\n            q = collections.deque()\n            for i in range(m):\n                for j in range(n):\n                    if isWater[i][j] == 1:\n                        q.append((i, j))\n                        ans[i][j] = 0\n            while q:\n                (i, j) = q.popleft()\n                for (dx, dy) in dirs:\n                    x = i + dx\n                    y = j + dy\n                    if x < 0 or x == m or y < 0 or (y == n):\n                        continue\n                    if ans[x][y] != -1:\n                        continue\n                    ans[x][y] = ans[i][j] + 1\n                    q.append((x, y))\n            return ans\n    solution = Solution()\n    isWater = [[1, 1], [1, 0]]\n    print(solution.highestPeak(isWater))", "def test_highestPeak():\n\n    class Solution:\n\n        def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            m = len(isWater)\n            n = len(isWater[0])\n            ans = [[-1] * n for _ in range(m)]\n            q = collections.deque()\n            for i in range(m):\n                for j in range(n):\n                    if isWater[i][j] == 1:\n                        q.append((i, j))\n                        ans[i][j] = 0\n            while q:\n                (i, j) = q.popleft()\n                for (dx, dy) in dirs:\n                    x = i + dx\n                    y = j + dy\n                    if x < 0 or x == m or y < 0 or (y == n):\n                        continue\n                    if ans[x][y] != -1:\n                        continue\n                    ans[x][y] = ans[i][j] + 1\n                    q.append((x, y))\n            return ans\n    solution = Solution()\n    isWater = [[0, 0], [0, 0]]\n    print(solution.highestPeak(isWater))", "def test_highestPeak():\n\n    class Solution:\n\n        def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            m = len(isWater)\n            n = len(isWater[0])\n            ans = [[-1] * n for _ in range(m)]\n            q = collections.deque()\n            for i in range(m):\n                for j in range(n):\n                    if isWater[i][j] == 1:\n                        q.append((i, j))\n                        ans[i][j] = 0\n            while q:\n                (i, j) = q.popleft()\n                for (dx, dy) in dirs:\n                    x = i + dx\n                    y = j + dy\n                    if x < 0 or x == m or y < 0 or (y == n):\n                        continue\n                    if ans[x][y] != -1:\n                        continue\n                    ans[x][y] = ans[i][j] + 1\n                    q.append((x, y))\n            return ans\n    solution = Solution()\n    isWater = [[1, 1], [0, 0]]\n    print(solution.highestPeak(isWater))", "def test_highestPeak():\n\n    class Solution:\n\n        def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            m = len(isWater)\n            n = len(isWater[0])\n            ans = [[-1] * n for _ in range(m)]\n            q = collections.deque()\n            for i in range(m):\n                for j in range(n):\n                    if isWater[i][j] == 1:\n                        q.append((i, j))\n                        ans[i][j] = 0\n            while q:\n                (i, j) = q.popleft()\n                for (dx, dy) in dirs:\n                    x = i + dx\n                    y = j + dy\n                    if x < 0 or x == m or y < 0 or (y == n):\n                        continue\n                    if ans[x][y] != -1:\n                        continue\n                    ans[x][y] = ans[i][j] + 1\n                    q.append((x, y))\n            return ans\n    solution = Solution()\n    isWater = [[1, 1], [0, 0]]\n    print(solution.highestPeak(isWater))", "def test_highestPeak():\n\n    class Solution:\n\n        def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            m = len(isWater)\n            n = len(isWater[0])\n            ans = [[-1] * n for _ in range(m)]\n            q = collections.deque()\n            for i in range(m):\n                for j in range(n):\n                    if isWater[i][j] == 1:\n                        q.append((i, j))\n                        ans[i][j] = 0\n            while q:\n                (i, j) = q.popleft()\n                for (dx, dy) in dirs:\n                    x = i + dx\n                    y = j + dy\n                    if x < 0 or x == m or y < 0 or (y == n):\n                        continue\n                    if ans[x][y] != -1:\n                        continue\n                    ans[x][y] = ans[i][j] + 1\n                    q.append((x, y))\n            return ans\n    solution = Solution()\n    isWater = [[0, 1], [0, 0]]\n    print(solution.highestPeak(isWater))", "def test_highestPeak():\n\n    class Solution:\n\n        def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            m = len(isWater)\n            n = len(isWater[0])\n            ans = [[-1] * n for _ in range(m)]\n            q = collections.deque()\n            for i in range(m):\n                for j in range(n):\n                    if isWater[i][j] == 1:\n                        q.append((i, j))\n                        ans[i][j] = 0\n            while q:\n                (i, j) = q.popleft()\n                for (dx, dy) in dirs:\n                    x = i + dx\n                    y = j + dy\n                    if x < 0 or x == m or y < 0 or (y == n):\n                        continue\n                    if ans[x][y] != -1:\n                        continue\n                    ans[x][y] = ans[i][j] + 1\n                    q.append((x, y))\n            return ans\n    solution = Solution()\n    isWater = [[1, 0], [0, 0]]\n    print(solution.highestPeak(isWater))", "def test_highestPeak():\n\n    class Solution:\n\n        def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            m = len(isWater)\n            n = len(isWater[0])\n            ans = [[-1] * n for _ in range(m)]\n            q = collections.deque()\n            for i in range(m):\n                for j in range(n):\n                    if isWater[i][j] == 1:\n                        q.append((i, j))\n                        ans[i][j] = 0\n            while q:\n                (i, j) = q.popleft()\n                for (dx, dy) in dirs:\n                    x = i + dx\n                    y = j + dy\n                    if x < 0 or x == m or y < 0 or (y == n):\n                        continue\n                    if ans[x][y] != -1:\n                        continue\n                    ans[x][y] = ans[i][j] + 1\n                    q.append((x, y))\n            return ans\n    solution = Solution()\n    isWater = [[1, 0], [0, 1]]\n    print(solution.highestPeak(isWater))", "def test_highestPeak():\n\n    class Solution:\n\n        def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            m = len(isWater)\n            n = len(isWater[0])\n            ans = [[-1] * n for _ in range(m)]\n            q = collections.deque()\n            for i in range(m):\n                for j in range(n):\n                    if isWater[i][j] == 1:\n                        q.append((i, j))\n                        ans[i][j] = 0\n            while q:\n                (i, j) = q.popleft()\n                for (dx, dy) in dirs:\n                    x = i + dx\n                    y = j + dy\n                    if x < 0 or x == m or y < 0 or (y == n):\n                        continue\n                    if ans[x][y] != -1:\n                        continue\n                    ans[x][y] = ans[i][j] + 1\n                    q.append((x, y))\n            return ans\n    solution = Solution()\n    isWater = [[0, 0], [1, 1]]\n    print(solution.highestPeak(isWater))", "def test_highestPeak():\n\n    class Solution:\n\n        def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            m = len(isWater)\n            n = len(isWater[0])\n            ans = [[-1] * n for _ in range(m)]\n            q = collections.deque()\n            for i in range(m):\n                for j in range(n):\n                    if isWater[i][j] == 1:\n                        q.append((i, j))\n                        ans[i][j] = 0\n            while q:\n                (i, j) = q.popleft()\n                for (dx, dy) in dirs:\n                    x = i + dx\n                    y = j + dy\n                    if x < 0 or x == m or y < 0 or (y == n):\n                        continue\n                    if ans[x][y] != -1:\n                        continue\n                    ans[x][y] = ans[i][j] + 1\n                    q.append((x, y))\n            return ans\n    solution = Solution()\n    isWater = [[1, 0], [0, 0]]\n    print(solution.highestPeak(isWater))", "def test_highestPeak():\n\n    class Solution:\n\n        def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            m = len(isWater)\n            n = len(isWater[0])\n            ans = [[-1] * n for _ in range(m)]\n            q = collections.deque()\n            for i in range(m):\n                for j in range(n):\n                    if isWater[i][j] == 1:\n                        q.append((i, j))\n                        ans[i][j] = 0\n            while q:\n                (i, j) = q.popleft()\n                for (dx, dy) in dirs:\n                    x = i + dx\n                    y = j + dy\n                    if x < 0 or x == m or y < 0 or (y == n):\n                        continue\n                    if ans[x][y] != -1:\n                        continue\n                    ans[x][y] = ans[i][j] + 1\n                    q.append((x, y))\n            return ans\n    solution = Solution()\n    isWater = [[0, 0], [1, 1]]\n    print(solution.highestPeak(isWater))", "def test_highestPeak():\n\n    class Solution:\n\n        def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            m = len(isWater)\n            n = len(isWater[0])\n            ans = [[-1] * n for _ in range(m)]\n            q = collections.deque()\n            for i in range(m):\n                for j in range(n):\n                    if isWater[i][j] == 1:\n                        q.append((i, j))\n                        ans[i][j] = 0\n            while q:\n                (i, j) = q.popleft()\n                for (dx, dy) in dirs:\n                    x = i + dx\n                    y = j + dy\n                    if x < 0 or x == m or y < 0 or (y == n):\n                        continue\n                    if ans[x][y] != -1:\n                        continue\n                    ans[x][y] = ans[i][j] + 1\n                    q.append((x, y))\n            return ans\n    solution = Solution()\n    isWater = [[1, 1], [1, 0]]\n    print(solution.highestPeak(isWater))", "def test_highestPeak():\n\n    class Solution:\n\n        def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            m = len(isWater)\n            n = len(isWater[0])\n            ans = [[-1] * n for _ in range(m)]\n            q = collections.deque()\n            for i in range(m):\n                for j in range(n):\n                    if isWater[i][j] == 1:\n                        q.append((i, j))\n                        ans[i][j] = 0\n            while q:\n                (i, j) = q.popleft()\n                for (dx, dy) in dirs:\n                    x = i + dx\n                    y = j + dy\n                    if x < 0 or x == m or y < 0 or (y == n):\n                        continue\n                    if ans[x][y] != -1:\n                        continue\n                    ans[x][y] = ans[i][j] + 1\n                    q.append((x, y))\n            return ans\n    solution = Solution()\n    isWater = [[0, 1], [0, 0]]\n    print(solution.highestPeak(isWater))", "def test_highestPeak():\n\n    class Solution:\n\n        def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            m = len(isWater)\n            n = len(isWater[0])\n            ans = [[-1] * n for _ in range(m)]\n            q = collections.deque()\n            for i in range(m):\n                for j in range(n):\n                    if isWater[i][j] == 1:\n                        q.append((i, j))\n                        ans[i][j] = 0\n            while q:\n                (i, j) = q.popleft()\n                for (dx, dy) in dirs:\n                    x = i + dx\n                    y = j + dy\n                    if x < 0 or x == m or y < 0 or (y == n):\n                        continue\n                    if ans[x][y] != -1:\n                        continue\n                    ans[x][y] = ans[i][j] + 1\n                    q.append((x, y))\n            return ans\n    solution = Solution()\n    isWater = [[1, 1], [0, 1]]\n    print(solution.highestPeak(isWater))", "def test_highestPeak():\n\n    class Solution:\n\n        def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\n            dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n            m = len(isWater)\n            n = len(isWater[0])\n            ans = [[-1] * n for _ in range(m)]\n            q = collections.deque()\n            for i in range(m):\n                for j in range(n):\n                    if isWater[i][j] == 1:\n                        q.append((i, j))\n                        ans[i][j] = 0\n            while q:\n                (i, j) = q.popleft()\n                for (dx, dy) in dirs:\n                    x = i + dx\n                    y = j + dy\n                    if x < 0 or x == m or y < 0 or (y == n):\n                        continue\n                    if ans[x][y] != -1:\n                        continue\n                    ans[x][y] = ans[i][j] + 1\n                    q.append((x, y))\n            return ans\n    solution = Solution()\n    isWater = [[0, 0], [0, 1]]\n    print(solution.highestPeak(isWater))"]}
{"task_num": 1782, "task_title": "Count Pairs Of Nodes", "func_name": "countPairs", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:\n    ans = [0] * len(queries)\n\n    count = [0] * (n + 1)\n\n    shared = [collections.Counter() for _ in range(n + 1)]\n\n    for u, v in edges:\n      count[u] += 1\n      count[v] += 1\n      shared[min(u, v)][max(u, v)] += 1\n\n    sortedCount = sorted(count)\n\n    for k, query in enumerate(queries):\n      i = 1\n      j = n\n      while i < j:\n        if sortedCount[i] + sortedCount[j] > query:\n          ans[k] += j - i\n          j -= 1\n        else:\n          i += 1\n      for i in range(1, n + 1):\n        for j, sh in shared[i].items():\n          if count[i] + count[j] > query and count[i] + count[j] - sh <= query:\n            ans[k] -= 1\n\n    return ans\n", "tests": ["def test_countPairs(self):\n\n    class Solution:\n\n        def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:\n            ans = [0] * len(queries)\n            count = [0] * (n + 1)\n            shared = [collections.Counter() for _ in range(n + 1)]\n            for (u, v) in edges:\n                count[u] += 1\n                count[v] += 1\n                shared[min(u, v)][max(u, v)] += 1\n            sortedCount = sorted(count)\n            for (k, query) in enumerate(queries):\n                i = 1\n                j = n\n                while i < j:\n                    if sortedCount[i] + sortedCount[j] > query:\n                        ans[k] += j - i\n                        j -= 1\n                    else:\n                        i += 1\n                for i in range(1, n + 1):\n                    for (j, sh) in shared[i].items():\n                        if count[i] + count[j] > query and count[i] + count[j] - sh <= query:\n                            ans[k] -= 1\n            return ans\n    solution = Solution()\n    edges = [[1, 2], [3, 4]]\n    queries = [1]\n    self.assertEqual(solution.countPairs(5, edges, queries), [0])", "def test_countPairs(self):\n\n    class Solution:\n\n        def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:\n            ans = [0] * len(queries)\n            count = [0] * (n + 1)\n            shared = [collections.Counter() for _ in range(n + 1)]\n            for (u, v) in edges:\n                count[u] += 1\n                count[v] += 1\n                shared[min(u, v)][max(u, v)] += 1\n            sortedCount = sorted(count)\n            for (k, query) in enumerate(queries):\n                i = 1\n                j = n\n                while i < j:\n                    if sortedCount[i] + sortedCount[j] > query:\n                        ans[k] += j - i\n                        j -= 1\n                    else:\n                        i += 1\n                for i in range(1, n + 1):\n                    for (j, sh) in shared[i].items():\n                        if count[i] + count[j] > query and count[i] + count[j] - sh <= query:\n                            ans[k] -= 1\n            return ans\n    solution = Solution()\n    edges = [[1, 2], [3, 4], [5, 6]]\n    queries = [4]\n    self.assertEqual(solution.countPairs(7, edges, queries), [2])", "def test_countPairs(self):\n\n    class Solution:\n\n        def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:\n            ans = [0] * len(queries)\n            count = [0] * (n + 1)\n            shared = [collections.Counter() for _ in range(n + 1)]\n            for (u, v) in edges:\n                count[u] += 1\n                count[v] += 1\n                shared[min(u, v)][max(u, v)] += 1\n            sortedCount = sorted(count)\n            for (k, query) in enumerate(queries):\n                i = 1\n                j = n\n                while i < j:\n                    if sortedCount[i] + sortedCount[j] > query:\n                        ans[k] += j - i\n                        j -= 1\n                    else:\n                        i += 1\n                for i in range(1, n + 1):\n                    for (j, sh) in shared[i].items():\n                        if count[i] + count[j] > query and count[i] + count[j] - sh <= query:\n                            ans[k] -= 1\n            return ans\n    solution = Solution()\n    edges = [[5, 6], [7, 8], [9, 10]]\n    queries = [3]\n    self.assertEqual(solution.countPairs(11, edges, queries), [0])", "def test_countPairs(self):\n\n    class Solution:\n\n        def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:\n            ans = [0] * len(queries)\n            count = [0] * (n + 1)\n            shared = [collections.Counter() for _ in range(n + 1)]\n            for (u, v) in edges:\n                count[u] += 1\n                count[v] += 1\n                shared[min(u, v)][max(u, v)] += 1\n            sortedCount = sorted(count)\n            for (k, query) in enumerate(queries):\n                i = 1\n                j = n\n                while i < j:\n                    if sortedCount[i] + sortedCount[j] > query:\n                        ans[k] += j - i\n                        j -= 1\n                    else:\n                        i += 1\n                for i in range(1, n + 1):\n                    for (j, sh) in shared[i].items():\n                        if count[i] + count[j] > query and count[i] + count[j] - sh <= query:\n                            ans[k] -= 1\n            return ans\n    solution = Solution()\n    edges = [[1, 2], [3, 4]]\n    queries = [10]\n    self.assertEqual(solution.countPairs(5, edges, queries), [0])", "def test_countPairs(self):\n\n    class Solution:\n\n        def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:\n            ans = [0] * len(queries)\n            count = [0] * (n + 1)\n            shared = [collections.Counter() for _ in range(n + 1)]\n            for (u, v) in edges:\n                count[u] += 1\n                count[v] += 1\n                shared[min(u, v)][max(u, v)] += 1\n            sortedCount = sorted(count)\n            for (k, query) in enumerate(queries):\n                i = 1\n                j = n\n                while i < j:\n                    if sortedCount[i] + sortedCount[j] > query:\n                        ans[k] += j - i\n                        j -= 1\n                    else:\n                        i += 1\n                for i in range(1, n + 1):\n                    for (j, sh) in shared[i].items():\n                        if count[i] + count[j] > query and count[i] + count[j] - sh <= query:\n                            ans[k] -= 1\n            return ans\n    solution = Solution()\n    edges = [[5, 6], [7, 8], [9, 10]]\n    queries = [0]\n    self.assertEqual(solution.countPairs(11, edges, queries), [4])", "def test_countPairs(self):\n\n    class Solution:\n\n        def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:\n            ans = [0] * len(queries)\n            count = [0] * (n + 1)\n            shared = [collections.Counter() for _ in range(n + 1)]\n            for (u, v) in edges:\n                count[u] += 1\n                count[v] += 1\n                shared[min(u, v)][max(u, v)] += 1\n            sortedCount = sorted(count)\n            for (k, query) in enumerate(queries):\n                i = 1\n                j = n\n                while i < j:\n                    if sortedCount[i] + sortedCount[j] > query:\n                        ans[k] += j - i\n                        j -= 1\n                    else:\n                        i += 1\n                for i in range(1, n + 1):\n                    for (j, sh) in shared[i].items():\n                        if count[i] + count[j] > query and count[i] + count[j] - sh <= query:\n                            ans[k] -= 1\n            return ans\n    solution = Solution()\n    edges = [[5, 6], [7, 8], [9, 10]]\n    queries = [15]\n    self.assertEqual(solution.countPairs(11, edges, queries), [4])", "def test_countPairs(self):\n\n    class Solution:\n\n        def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:\n            ans = [0] * len(queries)\n            count = [0] * (n + 1)\n            shared = [collections.Counter() for _ in range(n + 1)]\n            for (u, v) in edges:\n                count[u] += 1\n                count[v] += 1\n                shared[min(u, v)][max(u, v)] += 1\n            sortedCount = sorted(count)\n            for (k, query) in enumerate(queries):\n                i = 1\n                j = n\n                while i < j:\n                    if sortedCount[i] + sortedCount[j] > query:\n                        ans[k] += j - i\n                        j -= 1\n                    else:\n                        i += 1\n                for i in range(1, n + 1):\n                    for (j, sh) in shared[i].items():\n                        if count[i] + count[j] > query and count[i] + count[j] - sh <= query:\n                            ans[k] -= 1\n            return ans\n    solution = Solution()\n    edges = [[5, 6], [7, 8]]\n    queries = [15]\n    self.assertEqual(solution.countPairs(10, edges, queries), [4])", "def test_countPairs(self):\n\n    class Solution:\n\n        def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:\n            ans = [0] * len(queries)\n            count = [0] * (n + 1)\n            shared = [collections.Counter() for _ in range(n + 1)]\n            for (u, v) in edges:\n                count[u] += 1\n                count[v] += 1\n                shared[min(u, v)][max(u, v)] += 1\n            sortedCount = sorted(count)\n            for (k, query) in enumerate(queries):\n                i = 1\n                j = n\n                while i < j:\n                    if sortedCount[i] + sortedCount[j] > query:\n                        ans[k] += j - i\n                        j -= 1\n                    else:\n                        i += 1\n                for i in range(1, n + 1):\n                    for (j, sh) in shared[i].items():\n                        if count[i] + count[j] > query and count[i] + count[j] - sh <= query:\n                            ans[k] -= 1\n            return ans\n    solution = Solution()\n    edges = [[1, 2], [3, 4]]\n    queries = [5]\n    self.assertEqual(solution.countPairs(6, edges, queries), [0])", "def test_countPairs(self):\n\n    class Solution:\n\n        def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:\n            ans = [0] * len(queries)\n            count = [0] * (n + 1)\n            shared = [collections.Counter() for _ in range(n + 1)]\n            for (u, v) in edges:\n                count[u] += 1\n                count[v] += 1\n                shared[min(u, v)][max(u, v)] += 1\n            sortedCount = sorted(count)\n            for (k, query) in enumerate(queries):\n                i = 1\n                j = n\n                while i < j:\n                    if sortedCount[i] + sortedCount[j] > query:\n                        ans[k] += j - i\n                        j -= 1\n                    else:\n                        i += 1\n                for i in range(1, n + 1):\n                    for (j, sh) in shared[i].items():\n                        if count[i] + count[j] > query and count[i] + count[j] - sh <= query:\n                            ans[k] -= 1\n            return ans\n    solution = Solution()\n    edges = [[5, 6], [7, 8]]\n    queries = [10]\n    self.assertEqual(solution.countPairs(11, edges, queries), [4])", "def test_countPairs(self):\n\n    class Solution:\n\n        def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:\n            ans = [0] * len(queries)\n            count = [0] * (n + 1)\n            shared = [collections.Counter() for _ in range(n + 1)]\n            for (u, v) in edges:\n                count[u] += 1\n                count[v] += 1\n                shared[min(u, v)][max(u, v)] += 1\n            sortedCount = sorted(count)\n            for (k, query) in enumerate(queries):\n                i = 1\n                j = n\n                while i < j:\n                    if sortedCount[i] + sortedCount[j] > query:\n                        ans[k] += j - i\n                        j -= 1\n                    else:\n                        i += 1\n                for i in range(1, n + 1):\n                    for (j, sh) in shared[i].items():\n                        if count[i] + count[j] > query and count[i] + count[j] - sh <= query:\n                            ans[k] -= 1\n            return ans\n    solution = Solution()\n    edges = [[5, 6], [7, 8]]\n    queries = [0]\n    self.assertEqual(solution.countPairs(11, edges, queries), [4])", "def test_countPairs(self):\n\n    class Solution:\n\n        def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:\n            ans = [0] * len(queries)\n            count = [0] * (n + 1)\n            shared = [collections.Counter() for _ in range(n + 1)]\n            for (u, v) in edges:\n                count[u] += 1\n                count[v] += 1\n                shared[min(u, v)][max(u, v)] += 1\n            sortedCount = sorted(count)\n            for (k, query) in enumerate(queries):\n                i = 1\n                j = n\n                while i < j:\n                    if sortedCount[i] + sortedCount[j] > query:\n                        ans[k] += j - i\n                        j -= 1\n                    else:\n                        i += 1\n                for i in range(1, n + 1):\n                    for (j, sh) in shared[i].items():\n                        if count[i] + count[j] > query and count[i] + count[j] - sh <= query:\n                            ans[k] -= 1\n            return ans\n    solution = Solution()\n    edges = [[1, 2], [3, 4]]\n    queries = [10]\n    self.assertEqual(solution.countPairs(6, edges, queries), [0])", "def test_countPairs(self):\n\n    class Solution:\n\n        def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:\n            ans = [0] * len(queries)\n            count = [0] * (n + 1)\n            shared = [collections.Counter() for _ in range(n + 1)]\n            for (u, v) in edges:\n                count[u] += 1\n                count[v] += 1\n                shared[min(u, v)][max(u, v)] += 1\n            sortedCount = sorted(count)\n            for (k, query) in enumerate(queries):\n                i = 1\n                j = n\n                while i < j:\n                    if sortedCount[i] + sortedCount[j] > query:\n                        ans[k] += j - i\n                        j -= 1\n                    else:\n                        i += 1\n                for i in range(1, n + 1):\n                    for (j, sh) in shared[i].items():\n                        if count[i] + count[j] > query and count[i] + count[j] - sh <= query:\n                            ans[k] -= 1\n            return ans\n    solution = Solution()\n    edges = [[5, 6], [7, 8]]\n    queries = [20]\n    self.assertEqual(solution.countPairs(11, edges, queries), [0])", "def test_countPairs(self):\n\n    class Solution:\n\n        def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:\n            ans = [0] * len(queries)\n            count = [0] * (n + 1)\n            shared = [collections.Counter() for _ in range(n + 1)]\n            for (u, v) in edges:\n                count[u] += 1\n                count[v] += 1\n                shared[min(u, v)][max(u, v)] += 1\n            sortedCount = sorted(count)\n            for (k, query) in enumerate(queries):\n                i = 1\n                j = n\n                while i < j:\n                    if sortedCount[i] + sortedCount[j] > query:\n                        ans[k] += j - i\n                        j -= 1\n                    else:\n                        i += 1\n                for i in range(1, n + 1):\n                    for (j, sh) in shared[i].items():\n                        if count[i] + count[j] > query and count[i] + count[j] - sh <= query:\n                            ans[k] -= 1\n            return ans\n    solution = Solution()\n    edges = [[3, 6], [7, 8]]\n    queries = [10]\n    self.assertEqual(solution.countPairs(9, edges, queries), [4])", "def test_countPairs(self):\n\n    class Solution:\n\n        def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:\n            ans = [0] * len(queries)\n            count = [0] * (n + 1)\n            shared = [collections.Counter() for _ in range(n + 1)]\n            for (u, v) in edges:\n                count[u] += 1\n                count[v] += 1\n                shared[min(u, v)][max(u, v)] += 1\n            sortedCount = sorted(count)\n            for (k, query) in enumerate(queries):\n                i = 1\n                j = n\n                while i < j:\n                    if sortedCount[i] + sortedCount[j] > query:\n                        ans[k] += j - i\n                        j -= 1\n                    else:\n                        i += 1\n                for i in range(1, n + 1):\n                    for (j, sh) in shared[i].items():\n                        if count[i] + count[j] > query and count[i] + count[j] - sh <= query:\n                            ans[k] -= 1\n            return ans\n    solution = Solution()\n    edges = [[5, 6], [7, 8]]\n    queries = [15]\n    self.assertEqual(solution.countPairs(11, edges, queries), [0])", "def test_countPairs(self):\n\n    class Solution:\n\n        def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:\n            ans = [0] * len(queries)\n            count = [0] * (n + 1)\n            shared = [collections.Counter() for _ in range(n + 1)]\n            for (u, v) in edges:\n                count[u] += 1\n                count[v] += 1\n                shared[min(u, v)][max(u, v)] += 1\n            sortedCount = sorted(count)\n            for (k, query) in enumerate(queries):\n                i = 1\n                j = n\n                while i < j:\n                    if sortedCount[i] + sortedCount[j] > query:\n                        ans[k] += j - i\n                        j -= 1\n                    else:\n                        i += 1\n                for i in range(1, n + 1):\n                    for (j, sh) in shared[i].items():\n                        if count[i] + count[j] > query and count[i] + count[j] - sh <= query:\n                            ans[k] -= 1\n            return ans\n    solution = Solution()\n    edges = [[3, 6], [7, 8]]\n    queries = [10]\n    self.assertEqual(solution.countPairs(9, edges, queries), [4])", "def test_countPairs(self):\n\n    class Solution:\n\n        def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:\n            ans = [0] * len(queries)\n            count = [0] * (n + 1)\n            shared = [collections.Counter() for _ in range(n + 1)]\n            for (u, v) in edges:\n                count[u] += 1\n                count[v] += 1\n                shared[min(u, v)][max(u, v)] += 1\n            sortedCount = sorted(count)\n            for (k, query) in enumerate(queries):\n                i = 1\n                j = n\n                while i < j:\n                    if sortedCount[i] + sortedCount[j] > query:\n                        ans[k] += j - i\n                        j -= 1\n                    else:\n                        i += 1\n                for i in range(1, n + 1):\n                    for (j, sh) in shared[i].items():\n                        if count[i] + count[j] > query and count[i] + count[j] - sh <= query:\n                            ans[k] -= 1\n            return ans\n    solution = Solution()\n    edges = [[5, 6], [7, 8]]\n    queries = [20]\n    self.assertEqual(solution.countPairs(11, edges, queries), [0])", "def test_countPairs(self):\n\n    class Solution:\n\n        def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:\n            ans = [0] * len(queries)\n            count = [0] * (n + 1)\n            shared = [collections.Counter() for _ in range(n + 1)]\n            for (u, v) in edges:\n                count[u] += 1\n                count[v] += 1\n                shared[min(u, v)][max(u, v)] += 1\n            sortedCount = sorted(count)\n            for (k, query) in enumerate(queries):\n                i = 1\n                j = n\n                while i < j:\n                    if sortedCount[i] + sortedCount[j] > query:\n                        ans[k] += j - i\n                        j -= 1\n                    else:\n                        i += 1\n                for i in range(1, n + 1):\n                    for (j, sh) in shared[i].items():\n                        if count[i] + count[j] > query and count[i] + count[j] - sh <= query:\n                            ans[k] -= 1\n            return ans\n    solution = Solution()\n    edges = [[3, 6], [7, 8]]\n    queries = [15]\n    self.assertEqual(solution.countPairs(9, edges, queries), [2])", "def test_countPairs(self):\n\n    class Solution:\n\n        def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:\n            ans = [0] * len(queries)\n            count = [0] * (n + 1)\n            shared = [collections.Counter() for _ in range(n + 1)]\n            for (u, v) in edges:\n                count[u] += 1\n                count[v] += 1\n                shared[min(u, v)][max(u, v)] += 1\n            sortedCount = sorted(count)\n            for (k, query) in enumerate(queries):\n                i = 1\n                j = n\n                while i < j:\n                    if sortedCount[i] + sortedCount[j] > query:\n                        ans[k] += j - i\n                        j -= 1\n                    else:\n                        i += 1\n                for i in range(1, n + 1):\n                    for (j, sh) in shared[i].items():\n                        if count[i] + count[j] > query and count[i] + count[j] - sh <= query:\n                            ans[k] -= 1\n            return ans\n    solution = Solution()\n    edges = [[5, 6], [7, 8]]\n    queries = [10, 20]\n    self.assertEqual(solution.countPairs(11, edges, queries), [0, 2])", "def test_countPairs(self):\n\n    class Solution:\n\n        def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:\n            ans = [0] * len(queries)\n            count = [0] * (n + 1)\n            shared = [collections.Counter() for _ in range(n + 1)]\n            for (u, v) in edges:\n                count[u] += 1\n                count[v] += 1\n                shared[min(u, v)][max(u, v)] += 1\n            sortedCount = sorted(count)\n            for (k, query) in enumerate(queries):\n                i = 1\n                j = n\n                while i < j:\n                    if sortedCount[i] + sortedCount[j] > query:\n                        ans[k] += j - i\n                        j -= 1\n                    else:\n                        i += 1\n                for i in range(1, n + 1):\n                    for (j, sh) in shared[i].items():\n                        if count[i] + count[j] > query and count[i] + count[j] - sh <= query:\n                            ans[k] -= 1\n            return ans\n    solution = Solution()\n    edges = [[3, 6], [7, 8]]\n    queries = [5]\n    self.assertEqual(solution.countPairs(9, edges, queries), [0])", "def test_countPairs(self):\n\n    class Solution:\n\n        def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:\n            ans = [0] * len(queries)\n            count = [0] * (n + 1)\n            shared = [collections.Counter() for _ in range(n + 1)]\n            for (u, v) in edges:\n                count[u] += 1\n                count[v] += 1\n                shared[min(u, v)][max(u, v)] += 1\n            sortedCount = sorted(count)\n            for (k, query) in enumerate(queries):\n                i = 1\n                j = n\n                while i < j:\n                    if sortedCount[i] + sortedCount[j] > query:\n                        ans[k] += j - i\n                        j -= 1\n                    else:\n                        i += 1\n                for i in range(1, n + 1):\n                    for (j, sh) in shared[i].items():\n                        if count[i] + count[j] > query and count[i] + count[j] - sh <= query:\n                            ans[k] -= 1\n            return ans\n    solution = Solution()\n    edges = [[5, 6], [7, 8]]\n    queries = [10]\n    self.assertEqual(solution.countPairs(11, edges, queries), [0])"]}
{"task_num": 1786, "task_title": "Number of Restricted Paths From First to Last Node", "func_name": "countRestrictedPaths", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countRestrictedPaths(self, n: int, edges: List[List[int]]) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u - 1].append((v - 1, w))\n      graph[v - 1].append((u - 1, w))\n\n    return self._dijkstra(graph, 0, n - 1)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int) -> int:\n    kMod = 10**9 + 7\n    ways = [0] * len(graph)\n    dist = [math.inf] * len(graph)\n\n    ways[dst] = 1\n    dist[dst] = 0\n    minHeap = [(dist[dst], dst)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n        if dist[v] < dist[u]:\n          ways[u] += ways[v]\n          ways[u] %= kMod\n\n    return ways[src]\n", "tests": ["def test_countRestrictedPaths():\n    solution = Solution()\n\n    def edge(u: int, v: int) -> list[int]:\n        return [u - 1, v - 1, 10]\n    edges = [[edge(5, 3), edge(4, 0), edge(2, 3), edge(3, 1), edge(3, 4)]]\n    n = 5\n    assert solution.countRestrictedPaths(n, edges) == 3", "def test_countRestrictedPaths():\n    solution = Solution()\n\n    def edge(u: int, v: int) -> list[int]:\n        return [u - 1, v - 1, 10]\n    edges = [[edge(7, 3), edge(6, 2), edge(4, 8), edge(5, 0), edge(9, 6), edge(7, 9)]]\n    n = 9\n    assert solution.countRestrictedPaths(n, edges) == 12", "def test_countRestrictedPaths():\n    solution = Solution()\n\n    def edge(u: int, v: int) -> list[int]:\n        return [u - 1, v - 1, 10]\n    edges = [[edge(4, 0), edge(2, 3), edge(1, 3)]]\n    n = 4\n    assert solution.countRestrictedPaths(n, edges) == 0", "def test_countRestrictedPaths():\n    solution = Solution()\n\n    def edge(u: int, v: int) -> list[int]:\n        return [u - 1, v - 1, 5]\n    edges = [[edge(3, 2), edge(1, 3)]]\n    n = 4\n    assert solution.countRestrictedPaths(n, edges) == 8", "def test_countRestrictedPaths():\n    solution = Solution()\n\n    def edge(u: int, v: int) -> list[int]:\n        return [u - 1, v - 1, 1]\n    edges = [[edge(2, 0), edge(3, 4)]]\n    n = 5\n    assert solution.countRestrictedPaths(n, edges) == 6", "def test_countRestrictedPaths():\n    solution = Solution()\n\n    def edge(u: int, v: int) -> list[int]:\n        return [u - 1, v - 1, 1000000]\n    edges = [[edge(4, 2), edge(3, 2)]]\n    n = 5\n    assert solution.countRestrictedPaths(n, edges) == 16", "def test_countRestrictedPaths():\n    solution = Solution()\n\n    def edge(u: int, v: int) -> list[int]:\n        return [u - 1, v - 1, 100]\n    edges = [[edge(10, 9), edge(8, 7)]]\n    n = 11\n    assert solution.countRestrictedPaths(n, edges) == 26", "def test_countRestrictedPaths():\n    solution = Solution()\n\n    def edge(u: int, v: int) -> list[int]:\n        return [u - 1, v - 1, 1000]\n    edges = [[edge(3, 2), edge(5, 4)]]\n    n = 6\n    assert solution.countRestrictedPaths(n, edges) == 18", "def test_countRestrictedPaths():\n    solution = Solution()\n\n    def edge(u: int, v: int) -> list[int]:\n        return [u - 1, v - 1, 500]\n    edges = [[edge(7, 6), edge(5, 4)]]\n    n = 8\n    assert solution.countRestrictedPaths(n, edges) == 14", "def test_countRestrictedPaths():\n    solution = Solution()\n\n    def edge(u: int, v: int) -> list[int]:\n        return [u - 1, v - 1, 10000000]\n    edges = [[edge(10, 9), edge(8, 7)]]\n    n = 11\n    assert solution.countRestrictedPaths(n, edges) == 26", "def test_countRestrictedPaths():\n    solution = Solution()\n\n    def edge(u: int, v: int) -> list[int]:\n        return [u - 1, v - 1, 1000]\n    edges = [[edge(9, 8), edge(7, 6)]]\n    n = 10\n    assert solution.countRestrictedPaths(n, edges) == 18", "def test_countRestrictedPaths():\n    solution = Solution()\n\n    def edge(u: int, v: int) -> list[int]:\n        return [u - 1, v - 1, 100]\n    edges = [[edge(8, 7), edge(5, 4)]]\n    n = 9\n    assert solution.countRestrictedPaths(n, edges) == 18", "def test_countRestrictedPaths():\n    solution = Solution()\n\n    def edge(u: int, v: int) -> list[int]:\n        return [u - 1, v - 1, 10000]\n    edges = [[edge(12, 11), edge(9, 10)]]\n    n = 13\n    assert solution.countRestrictedPaths(n, edges) == 24", "def test_countRestrictedPaths():\n    solution = Solution()\n\n    def edge(u: int, v: int) -> list[int]:\n        return [u - 1, v - 1, 100000]\n    edges = [[edge(11, 10), edge(9, 8)]]\n    n = 12\n    assert solution.countRestrictedPaths(n, edges) == 26", "def test_countRestrictedPaths():\n    solution = Solution()\n\n    def edge(u: int, v: int) -> list[int]:\n        return [u - 1, v - 1, 1000]\n    edges = [[edge(8, 7), edge(5, 4)]]\n    n = 9\n    assert solution.countRestrictedPaths(n, edges) == 18", "def test_countRestrictedPaths():\n    solution = Solution()\n\n    def edge(u: int, v: int) -> list[int]:\n        return [u - 1, v - 1, 1000000]\n    edges = [[edge(10, 9), edge(8, 7)]]\n    n = 11\n    assert solution.countRestrictedPaths(n, edges) == 26", "def test_countRestrictedPaths():\n    solution = Solution()\n\n    def edge(u: int, v: int) -> list[int]:\n        return [u - 1, v - 1, 10000]\n    edges = [[edge(14, 13), edge(12, 11)]]\n    n = 15\n    assert solution.countRestrictedPaths(n, edges) == 22", "def test_countRestrictedPaths():\n    solution = Solution()\n\n    def edge(u: int, v: int) -> list[int]:\n        return [u - 1, v - 1, 10000]\n    edges = [[edge(15, 14), edge(13, 12)]]\n    n = 16\n    assert solution.countRestrictedPaths(n, edges) == 28", "def test_countRestrictedPaths():\n    solution = Solution()\n\n    def edge(u: int, v: int) -> list[int]:\n        return [u - 1, v - 1, 10000]\n    edges = [[edge(16, 15), edge(14, 13)]]\n    n = 17\n    assert solution.countRestrictedPaths(n, edges) == 30", "def test_countRestrictedPaths():\n    solution = Solution()\n\n    def edge(u: int, v: int) -> list[int]:\n        return [u - 1, v - 1, 10000]\n    edges = [[edge(17, 16), edge(15, 14)]]\n    n = 18\n    assert solution.countRestrictedPaths(n, edges) == 32"]}
{"task_num": 1793, "task_title": "Maximum Score of a Good Subarray", "func_name": "maximumScore", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumScore(self, nums: List[int], k: int) -> int:\n    ans = 0\n    stack = []\n\n    for i in range(len(nums) + 1):\n      while stack and (i == len(nums) or nums[stack[-1]] > nums[i]):\n        h = nums[stack.pop()]\n        w = i - stack[-1] - 1 if stack else i\n        if (not stack or stack[-1] + 1 <= k) and i - 1 >= k:\n          ans = max(ans, h * w)\n      stack.append(i)\n\n    return ans\n", "tests": ["def test_maximumScore():\n    solution = Solution()\n    nums = [1, 2, 3, 4, 5, 6]\n    k = 3\n    assert solution.maximumScore(nums, k) == 12", "def test_maximumScore():\n    solution = Solution()\n    nums = [5, 4, 3, 2, 1]\n    k = 0\n    assert solution.maximumScore(nums, k) == 20", "def test_maximumScore():\n    solution = Solution()\n    nums = [1, 2, 3, 4]\n    k = 2\n    assert solution.maximumScore(nums, k) == 6", "def test_maximumScore():\n    solution = Solution()\n    nums = [1, 2]\n    k = 0\n    assert solution.maximumScore(nums, k) == 3", "def test_maximumScore():\n    solution = Solution()\n    nums = [6, 5, 4, 3]\n    k = 2\n    assert solution.maximumScore(nums, k) == 12", "def test_maximumScore():\n    solution = Solution()\n    nums = [1, 2, 3, 4, 5]\n    k = len(nums) - 1\n    assert solution.maximumScore(nums, k) == 15", "def test_maximumScore():\n    solution = Solution()\n    nums = [1]\n    k = 0\n    assert solution.maximumScore(nums, k) == 1", "def test_maximumScore():\n    solution = Solution()\n    nums = [4, 5, 6]\n    k = len(nums)\n    assert solution.maximumScore(nums, k) == 0", "def test_maximumScore():\n    solution = Solution()\n    nums = [3, 2]\n    k = 1\n    assert solution.maximumScore(nums, k) == 4", "def test_maximumScore():\n    solution = Solution()\n    nums = [10, 9, 8, 7]\n    k = len(nums)\n    assert solution.maximumScore(nums, k) == 0", "def test_maximumScore():\n    solution = Solution()\n    nums = [6]\n    k = 0\n    assert solution.maximumScore(nums, k) == 1", "def test_maximumScore():\n    solution = Solution()\n    nums = [2, 2]\n    k = 1\n    assert solution.maximumScore(nums, k) == 4", "def test_maximumScore():\n    solution = Solution()\n    nums = [9, 8, 7]\n    k = 0\n    assert solution.maximumScore(nums, k) == 18", "def test_maximumScore():\n    solution = Solution()\n    nums = [1, 8, 6]\n    k = 3\n    assert solution.maximumScore(nums, k) == 17", "def test_maximumScore():\n    solution = Solution()\n    nums = [5, 6, 7]\n    k = 0\n    assert solution.maximumScore(nums, k) == 12", "def test_maximumScore():\n    solution = Solution()\n    nums = [3, 4, 5]\n    k = len(nums) - 1\n    assert solution.maximumScore(nums, k) == 12", "def test_maximumScore():\n    solution = Solution()\n    nums = [6, 5]\n    k = 1\n    assert solution.maximumScore(nums, k) == 10", "def test_maximumScore():\n    solution = Solution()\n    nums = [8, 7, 6]\n    k = len(nums) - 1\n    assert solution.maximumScore(nums, k) == 27", "def test_maximumScore():\n    solution = Solution()\n    nums = [1, 2, 3, 4, 5]\n    k = len(nums) // 2\n    assert solution.maximumScore(nums, k) == 10", "def test_maximumScore():\n    solution = Solution()\n    nums = [2, 1]\n    k = len(nums) - 1\n    assert solution.maximumScore(nums, k) == 2"]}
{"task_num": 1805, "task_title": "Number of Different Integers in a String", "func_name": "numDifferentIntegers", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numDifferentIntegers(self, word: str) -> int:\n    nums = set()\n    curr = []\n\n    for c in word:\n      if c.isdigit():\n        curr.append(c)\n      elif curr:\n        nums.add(''.join(self._removeLeadingZeros(curr)))\n        curr = []\n\n    if curr:\n      nums.add(''.join(self._removeLeadingZeros(curr)))\n\n    return len(nums)\n\n  def _removeLeadingZeros(self, s: str) -> str:\n    index = next((i for i, c in enumerate(s) if c != '0'), -1)\n    if index == -1:\n      return ['0']\n    else:\n      return s[index:]\n", "tests": ["def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers('a123bc34d8ef34') == 4", "def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers('hello') == 1", "def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers('1234567890') == 1", "def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers('8 3   1 7 9 2 7 6 5 5 4') == 8", "def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers('a123b c34d') == 2", "def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers('a123b  c34d') == 2", "def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers('0a') == 1", "def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers('00a') == 1", "def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers('a123b c34d 8') == 3", "def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers('a0b 1c') == 2", "def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers('123 456') == 2", "def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers('1 2 3') == 3", "def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers('abc def') == 0", "def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers('0123 4567') == 2", "def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers('12345678901234567890') == 1", "def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers('000123') == 1", "def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers('123 000') == 2", "def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers('00000') == 1", "def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers('a 123 b') == 2", "def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers('a 123 b c') == 3"]}
{"task_num": 1857, "task_title": "Largest Color Value in a Directed Graph", "func_name": "largestPathValue", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\n    n = len(colors)\n    ans = 0\n    processed = 0\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n    q = collections.deque()\n    count = [[0] * 26 for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      inDegrees[v] += 1\n\n    for i, degree in enumerate(inDegrees):\n      if degree == 0:\n        q.append(i)\n\n    while q:\n      u = q.popleft()\n      processed += 1\n      count[u][ord(colors[u]) - ord('a')] += 1\n      ans = max(ans, count[u][ord(colors[u]) - ord('a')])\n      for v in graph[u]:\n        for i in range(26):\n          count[v][i] = max(count[v][i], count[u][i])\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    if processed == n:\n      return ans\n    else:\n      return -1\n", "tests": ["def test_largestPathValue(self):\n    solution = Solution()\n    colors = 'a'\n    edges = [[0]]\n    self.assertEqual(solution.largestPathValue(colors, edges), 1)", "def test_largestPathValue(self):\n    solution = Solution()\n    colors = 'aab'\n    edges = [[0, 1], [1, 2]]\n    self.assertEqual(solution.largestPathValue(colors, edges), 2)", "def test_largestPathValue(self):\n    solution = Solution()\n    colors = 'ab'\n    edges = [[0, 1], [1, 2], [2, 3]]\n    self.assertEqual(solution.largestPathValue(colors, edges), -1)", "def test_largestPathValue(self):\n    solution = Solution()\n    colors = 'aa'\n    edges = [[0, 1], [1, 2]]\n    self.assertEqual(solution.largestPathValue(colors, edges), 2)", "def test_largestPathValue(self):\n    solution = Solution()\n    colors = 'abcd'\n    edges = [[0, 1], [0, 2], [0, 3]]\n    self.assertEqual(solution.largestPathValue(colors, edges), -1)", "def test_largestPathValue(self):\n    solution = Solution()\n    colors = 'abcb'\n    edges = [[0, 1], [0, 2], [1, 3]]\n    self.assertEqual(solution.largestPathValue(colors, edges), -1)", "def test_largestPathValue(self):\n    solution = Solution()\n    colors = 'aaabb'\n    edges = [[0, 1], [0, 2], [1, 3]]\n    self.assertEqual(solution.largestPathValue(colors, edges), 4)", "def test_largestPathValue(self):\n    solution = Solution()\n    colors = 'abccba'\n    edges = [[0, 1], [2, 3]]\n    self.assertEqual(solution.largestPathValue(colors, edges), -1)", "def test_largestPathValue(self):\n    solution = Solution()\n    colors = 'aabaa'\n    edges = [[0, 1], [2, 3]]\n    self.assertEqual(solution.largestPathValue(colors, edges), -1)", "def test_largestPathValue(self):\n    solution = Solution()\n    colors = 'aaaa'\n    edges = [[0, 1], [1, 2]]\n    self.assertEqual(solution.largestPathValue(colors, edges), -1)", "def test_largestPathValue(self):\n    solution = Solution()\n    colors = 'abcde'\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4]]\n    self.assertEqual(solution.largestPathValue(colors, edges), 5)", "def test_largestPathValue(self):\n    solution = Solution()\n    colors = 'abcde'\n    edges = [[0, 1], [0, 2], [3, 4]]\n    self.assertEqual(solution.largestPathValue(colors, edges), -1)", "def test_largestPathValue(self):\n    solution = Solution()\n    colors = 'aabbcc'\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4]]\n    self.assertEqual(solution.largestPathValue(colors, edges), -1)", "def test_largestPathValue(self):\n    solution = Solution()\n    colors = 'aaabcc'\n    edges = [[0, 1], [1, 2], [2, 3]]\n    self.assertEqual(solution.largestPathValue(colors, edges), -1)", "def test_largestPathValue(self):\n    solution = Solution()\n    colors = 'aabbbcc'\n    edges = [[0, 1], [2, 3]]\n    self.assertEqual(solution.largestPathValue(colors, edges), -1)", "def test_largestPathValue(self):\n    solution = Solution()\n    colors = 'aaabbb'\n    edges = [[0, 1], [1, 2]]\n    self.assertEqual(solution.largestPathValue(colors, edges), -1)", "def test_largestPathValue(self):\n    solution = Solution()\n    colors = 'abab'\n    edges = [[0, 1], [2, 3]]\n    self.assertEqual(solution.largestPathValue(colors, edges), -1)", "def test_largestPathValue(self):\n    solution = Solution()\n    colors = 'abcd'\n    edges = [[0, 1], [1, 2]]\n    self.assertEqual(solution.largestPathValue(colors, edges), 4)", "def test_largestPathValue(self):\n    solution = Solution()\n    colors = 'abca'\n    edges = [[0, 1], [2, 3]]\n    self.assertEqual(solution.largestPathValue(colors, edges), -1)", "def test_largestPathValue(self):\n    solution = Solution()\n    colors = 'aaaa'\n    edges = [[0, 1], [1, 2]]\n    self.assertEqual(solution.largestPathValue(colors, edges), -1)"]}
{"task_num": 1878, "task_title": "Get Biggest Three Rhombus Sums in a Grid", "func_name": "getBiggestThree", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom sortedcontainers import SortedSet\n\n\nclass Solution:\n  def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\n    m = len(grid)\n    n = len(grid[0])\n    sums = SortedSet()\n\n    for i in range(m):\n      for j in range(n):\n        sz = 0\n        while i + sz < m and i - sz >= 0 and j + 2 * sz < n:\n          summ = grid[i][j] if sz == 0 else self._getSum(grid, i, j, sz)\n          sums.add(summ)\n          if len(sums) > 3:\n            sums.pop(0)\n          sz += 1\n\n    return reversed(sums)\n\n  def _getSum(self, grid: List[List[int]], i: int, j: int, sz: int) -> int:\n    x = i\n    y = j\n    summ = 0\n\n    for _ in range(sz):\n      x -= 1\n      y += 1\n      summ += grid[x][y]\n\n    for _ in range(sz):\n      x += 1\n      y += 1\n      summ += grid[x][y]\n\n    for _ in range(sz):\n      x += 1\n      y -= 1\n      summ += grid[x][y]\n\n    for _ in range(sz):\n      x -= 1\n      y -= 1\n      summ += grid[x][y]\n\n    return summ\n", "tests": ["def test_getBiggestThree():\n    solution = Solution()\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    expected_result = [26, 23, 15]\n    assert list(solution.getBiggestThree(grid)) == expected_result", "def test_getBiggestThree():\n    solution = Solution()\n    grid = [[1, 0], [0, 1]]\n    expected_result = [2]\n    assert list(solution.getBiggestThree(grid)) == expected_result", "def test_getBiggestThree():\n    solution = Solution()\n    grid = [[1] * 10 + [0] + [1] * 9]\n    expected_result = [45, 44, 43]\n    assert list(solution.getBiggestThree(grid)) == expected_result", "def test_getBiggestThree():\n    solution = Solution()\n    grid = [[1] * 5 + [0] + [1] * 4, [0] * 6]\n    expected_result = [23]\n    assert list(solution.getBiggestThree(grid)) == expected_result", "def test_getBiggestThree():\n    solution = Solution()\n    grid = [[10] * 5 + [0] + [1] * 4]\n    expected_result = [52, 51, 50]\n    assert list(solution.getBiggestThree(grid)) == expected_result", "def test_getBiggestThree():\n    solution = Solution()\n    grid = [[0] * 10 + [1] + [0] * 9]\n    expected_result = [10]\n    assert list(solution.getBiggestThree(grid)) == expected_result", "def test_getBiggestThree():\n    solution = Solution()\n    grid = [[1] * 5 + [0] + [1] * 4, [1] * 6]\n    expected_result = [26, 25, 23]\n    assert list(solution.getBiggestThree(grid)) == expected_result", "def test_getBiggestThree():\n    solution = Solution()\n    grid = [[1] * 7 + [0] + [1] * 6]\n    expected_result = [35]\n    assert list(solution.getBiggestThree(grid)) == expected_result", "def test_getBiggestThree():\n    solution = Solution()\n    grid = [[0] * 5 + [1] + [0] * 4, [0] * 6]\n    expected_result = [15]\n    assert list(solution.getBiggestThree(grid)) == expected_result", "def test_getBiggestThree():\n    solution = Solution()\n    grid = [[1] * 3 + [0] + [1] * 2]\n    expected_result = [14, 13, 12]\n    assert list(solution.getBiggestThree(grid)) == expected_result", "def test_getBiggestThree():\n    solution = Solution()\n    grid = [[5] * 5]\n    expected_result = [25]\n    assert list(solution.getBiggestThree(grid)) == expected_result", "def test_getBiggestThree():\n    solution = Solution()\n    grid = [[1]]\n    expected_result = [1]\n    assert list(solution.getBiggestThree(grid)) == expected_result", "def test_getBiggestThree():\n    solution = Solution()\n    grid = []\n    with self.assertRaises(IndexError):\n        list(solution.getBiggestThree(grid))", "def test_getBiggestThree():\n    solution = Solution()\n    grid = [[1] * 2]\n    with self.assertRaises(ValueError):\n        list(solution.getBiggestThree(grid))", "def test_getBiggestThree():\n    solution = Solution()\n    grid = [[1] * 3]\n    with self.assertRaises(ValueError):\n        list(solution.getBiggestThree(grid))", "def test_getBiggestThree():\n    solution = Solution()\n    grid = [[1] * 4]\n    with self.assertRaises(ValueError):\n        list(solution.getBiggestThree(grid))", "def test_getBiggestThree():\n    solution = Solution()\n    grid = [[1] * 5]\n    with self.assertRaises(ValueError):\n        list(solution.getBiggestThree(grid))", "def test_getBiggestThree():\n    solution = Solution()\n    grid = [[1] * 3 + [0] + [1] * 2, [1] * 4]\n    expected_result = [18, 17, 16]\n    assert list(solution.getBiggestThree(grid)) == expected_result", "def test_getBiggestThree():\n    solution = Solution()\n    grid = [[1] * 4 + [0] + [1] * 3]\n    expected_result = [20, 19, 18]\n    assert list(solution.getBiggestThree(grid)) == expected_result", "def test_getBiggestThree():\n    solution = Solution()\n    grid = [[1] * 5 + [0] + [1] * 4, [1] * 6]\n    expected_result = [26, 25, 23]\n    assert list(solution.getBiggestThree(grid)) == expected_result"]}
{"task_num": 1896, "task_title": "Minimum Cost to Change the Final Value of Expression", "func_name": "minOperationsToFlip", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minOperationsToFlip(self, expression: str) -> int:\n    stack = []\n\n    for e in expression:\n      if e in '(&|':\n        stack.append((e, 0))\n        continue\n      if e == ')':\n        lastPair = stack.pop()\n        stack.pop()\n      else: \n        lastPair = (e, 1)\n      if stack and stack[-1][0] in '&|':\n        op = stack.pop()[0]\n        a, costA = stack.pop()\n        b, costB = lastPair\n        if op == '&':\n          if a == '0' and b == '0':\n            lastPair = ('0', 1 + min(costA, costB))\n          elif a == '0' and b == '1':\n            lastPair = ('0', 1)\n          elif a == '1' and b == '0':\n            lastPair = ('0', 1)\n          else:\n            lastPair = ('1', min(costA, costB))\n        else:\n          if a == '0' and b == '0':\n            lastPair = ('0', min(costA, costB))\n          elif a == '0' and b == '1':\n            lastPair = ('1', 1)\n          elif a == '1' and b == '0':\n            lastPair = ('1', 1)\n          else:\n            lastPair = ('1', 1 + min(costA, costB))\n      stack.append(lastPair)\n\n    return stack[-1][1]\n", "tests": ["def test_expression(self):\n  class Solution:\n    def minOperationsToFlip(self, expression: str) -> int:\n      # your code here...\n\n  solution = Solution()\n  self.assertEqual(solution.minOperationsToFlip(\"1|0&(1|(0&((1)&(1))))\"), 5)", "def test_nested_parentheses(self):\n  class Solution:\n    def minOperationsToFlip(self, expression: str) -> int:\n      # your code here...\n\n  solution = Solution()\n  self.assertEqual(solution.minOperationsToFlip(\"(1|0)&(1|(0&((1)&(1)))))\"), 6)", "def test_single_and(self):\n  class Solution:\n    def minOperationsToFlip(self, expression: str) -> int:\n      # your code here...\n\n  solution = Solution()\n  self.assertEqual(solution.minOperationsToFlip(\"1&(0|(1&1))\"), 2)", "def test_only_and(self):\n  class Solution:\n    def minOperationsToFlip(self, expression: str) -> int:\n      # your code here...\n\n  solution = Solution()\n  self.assertEqual(solution.minOperationsToFlip(\"(1&0)&(1&(1))\"), 2)", "def test_no_ops_needed(self):\n  class Solution:\n    def minOperationsToFlip(self, expression: str) -> int:\n      # your code here...\n\n  solution = Solution()\n  self.assertEqual(solution.minOperationsToFlip(\"0&1\"), 0)", "def test_empty_expression(self):\n  class Solution:\n    def minOperationsToFlip(self, expression: str) -> int:\n      # your code here...\n\n  solution = Solution()\n  self.assertEqual(solution.minOperationsToFlip(\"\"), 0)", "def test_only_or(self):\n  class Solution:\n    def minOperationsToFlip(self, expression: str) -> int:\n      # your code here...\n\n  solution = Solution()\n  self.assertEqual(solution.minOperationsToFlip(\"(1|0)|(1|(1&0))\"), 3)", "def test_only_ones(self):\n  class Solution:\n    def minOperationsToFlip(self, expression: str) -> int:\n      # your code here...\n\n  solution = Solution()\n  self.assertEqual(solution.minOperationsToFlip(\"1|1|(1&1)&1\"), 4)", "def test_only_zeros(self):\n  class Solution:\n    def minOperationsToFlip(self, expression: str) -> int:\n      # your code here...\n\n  solution = Solution()\n  self.assertEqual(solution.minOperationsToFlip(\"0&0|(0&(0&0))\"), 6)", "def test_many_operations(self):\n  class Solution:\n    def minOperationsToFlip(self, expression: str) -> int:\n      # your code here...\n\n  solution = Solution()\n  self.assertEqual(solution.minOperationsToFlip(\"(1|(0&1))|((1&(0|0)))\"), 7)", "def test_nested_zero(self):\n  class Solution:\n    def minOperationsToFlip(self, expression: str) -> int:\n      # your code here...\n\n  solution = Solution()\n  self.assertEqual(solution.minOperationsToFlip(\"(0&(1|(0&((1)&(1))))))\"), 5)", "def test_large_expression(self):\n  class Solution:\n    def minOperationsToFlip(self, expression: str) -> int:\n      # your code here...\n\n  solution = Solution()\n  self.assertEqual(solution.minOperationsToFlip(\"((1&0)|(0&(1|(0&(1&(0|(1&0)))))))\"), 8)", "def test_multiple_ops(self):\n  class Solution:\n    def minOperationsToFlip(self, expression: str) -> int:\n      # your code here...\n\n  solution = Solution()\n  self.assertEqual(solution.minOperationsToFlip(\"(1|(0&1))|(0&(1|(0&(1&0))))\"), 9)", "def test_single_parenthesis(self):\n  class Solution:\n    def minOperationsToFlip(self, expression: str) -> int:\n      # your code here...\n\n  solution = Solution()\n  self.assertEqual(solution.minOperationsToFlip(\"(1|0&1)\"), 2)", "def test_only_and_no_zeros(self):\n  class Solution:\n    def minOperationsToFlip(self, expression: str) -> int:\n      # your code here...\n\n  solution = Solution()\n  self.assertEqual(solution.minOperationsToFlip(\"(1&1)&(1&(1&1))\"), 0)", "def test_no_and_ops(self):\n  class Solution:\n    def minOperationsToFlip(self, expression: str) -> int:\n      # your code here...\n\n  solution = Solution()\n  self.assertEqual(solution.minOperationsToFlip(\"(1|0)|(0|(1&0)))\"), 3)", "def test_multiple_ops_in_parentheses(self):\n  class Solution:\n    def minOperationsToFlip(self, expression: str) -> int:\n      # your code here...\n\n  solution = Solution()\n  self.assertEqual(solution.minOperationsToFlip(\"(1|(0&1)|(0&(1|(0&(1&0))))))\"), 11)", "def test_only_ones_and_or(self):\n  class Solution:\n    def minOperationsToFlip(self, expression: str) -> int:\n      # your code here...\n\n  solution = Solution()\n  self.assertEqual(solution.minOperationsToFlip(\"(1|0|(1&1))\"), 3)", "def test_empty_parentheses(self):\n  class Solution:\n    def minOperationsToFlip(self, expression: str) -> int:\n      # your code here...\n\n  solution = Solution()\n  self.assertEqual(solution.minOperationsToFlip(\"()\"), 0)", "def test_multiple_nested_parentheses(self):\n  class Solution:\n    def minOperationsToFlip(self, expression: str) -> int:\n      # your code here...\n\n  solution = Solution()\n  self.assertEqual(solution.minOperationsToFlip(\"((1|(0&(1|0)))|(0&((1&(1&(1))))))\"), 7)"]}
{"task_num": 1906, "task_title": "Minimum Absolute Difference Queries", "func_name": "minDifference", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom bisect import bisect_left\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minDifference(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n    numToIndices = [[] for _ in range(101)]\n\n    for i, num in enumerate(nums):\n      numToIndices[num].append(i)\n\n    if len(numToIndices[nums[0]]) == len(nums):\n      return [-1] * len(queries)\n\n    ans = []\n\n    for l, r in queries:\n      prevNum = -1\n      minDiff = 101\n      for num in range(1, 101):\n        indices = numToIndices[num]\n        i = bisect_left(indices, l)\n        if i == len(indices) or indices[i] > r:\n          continue\n        if prevNum != -1:\n          minDiff = min(minDiff, num - prevNum)\n        prevNum = num\n      ans.append(-1 if minDiff == 101 else minDiff)\n\n    return ans\n", "tests": ["def test_minDifference():\n    solution = Solution()\n    nums = [5, 2, 3, 7, 2]\n    queries = [[1, 4], [0, 3]]\n    print(solution.minDifference(nums, queries))", "def test_minDifference():\n    solution = Solution()\n    nums = [1, 2, 3, 4, 5]\n    queries = [[0, 4], [1, 3]]\n    print(solution.minDifference(nums, queries))", "def test_minDifference():\n    solution = Solution()\n    nums = [1] * 100\n    queries = [[0, 99], [1, 98]]\n    print(solution.minDifference(nums, queries))", "def test_minDifference():\n    solution = Solution()\n    nums = [100] * 101\n    queries = [[0, 99], [1, 98]]\n    print(solution.minDifference(nums, queries))", "def test_minDifference():\n    solution = Solution()\n    nums = [101] * 100 + [1]\n    queries = [[99, 99], [0, 0]]\n    print(solution.minDifference(nums, queries))", "def test_minDifference():\n    solution = Solution()\n    nums = [5, 3, 2, 7, 9]\n    queries = [[0, 4], [1, 1]]\n    print(solution.minDifference(nums, queries))", "def test_minDifference():\n    solution = Solution()\n    nums = [1, 2]\n    queries = [[0, 0], [0, 0]]\n    print(solution.minDifference(nums, queries))", "def test_minDifference():\n    solution = Solution()\n    nums = [5, 2, 3, 7, 7]\n    queries = [[0, 4], [1, 4]]\n    print(solution.minDifference(nums, queries))", "def test_minDifference():\n    solution = Solution()\n    nums = [5, 7, 2, 3]\n    queries = [[0, 4], [1, 3]]\n    print(solution.minDifference(nums, queries))", "def test_minDifference():\n    solution = Solution()\n    nums = [100] * 50 + [1] * 10 + [101] * 40\n    queries = [[0, 49], [9, 19]]\n    print(solution.minDifference(nums, queries))", "def test_minDifference():\n    solution = Solution()\n    nums = [1] * 100 + [101]\n    queries = [[99, 99], [0, 100]]\n    print(solution.minDifference(nums, queries))", "def test_minDifference():\n    solution = Solution()\n    nums = [5] * 100 + [7]\n    queries = [[0, 99], [1, 1]]\n    print(solution.minDifference(nums, queries))", "def test_minDifference():\n    solution = Solution()\n    nums = [1000] * 101\n    queries = [[0, 99], [1, 98]]\n    print(solution.minDifference(nums, queries))", "def test_minDifference():\n    solution = Solution()\n    nums = [1] * 101\n    queries = [[0, 100], [50, 51]]\n    print(solution.minDifference(nums, queries))", "def test_minDifference():\n    solution = Solution()\n    nums = [1] * 100 + [2] * 100\n    queries = [[0, 199], [99, 198]]\n    print(solution.minDifference(nums, queries))", "def test_minDifference():\n    solution = Solution()\n    nums = [1] * 50 + [2] * 25 + [3] * 10 + [4] * 5 + [5]\n    queries = [[0, 49], [24, 34]]\n    print(solution.minDifference(nums, queries))", "def test_minDifference():\n    solution = Solution()\n    nums = [1] * 100 + [101]\n    queries = [[0, 99], [98, 99]]\n    print(solution.minDifference(nums, queries))", "def test_minDifference():\n    solution = Solution()\n    nums = [101] * 50 + [1]\n    queries = [[0, 49], [4, 4]]\n    print(solution.minDifference(nums, queries))", "def test_minDifference():\n    solution = Solution()\n    nums = [1] * 10 + [2] * 5 + [3] * 2 + [4]\n    queries = [[0, 9], [6, 7]]\n    print(solution.minDifference(nums, queries))", "def test_minDifference():\n    solution = Solution()\n    nums = [1] * 100 + [101]\n    queries = [[0, 99], [50, 51]]\n    print(solution.minDifference(nums, queries))"]}
{"task_num": 1923, "task_title": "Longest Common Subpath", "func_name": "longestCommonSubpath", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Set\n\nclass Solution:\n  def __init__(self):\n    self.kMod = 8_417_508_174_513\n    self.kBase = 165_131\n\n  def longestCommonSubpath(self, n: int, paths: List[List[int]]) -> int:\n    l = 0\n    r = len(paths[0])\n\n    while l < r:\n      m = l + (r - l + 1) // 2\n      if self._checkCommonSubpath(paths, m):\n        l = m\n      else:\n        r = m - 1\n\n    return l\n\n  def _checkCommonSubpath(self, paths: List[List[int]], m: int) -> bool:\n    hashSets = [self._rabinKarp(path, m) for path in paths]\n\n    for subpathHash in hashSets[0]:\n      if all(subpathHash in hashSet for hashSet in hashSets):\n        return True\n\n    return False\n\n  def _rabinKarp(self, path: List[int], m: int) -> Set[int]:\n    hashes = set()\n    maxPower = 1\n    hash = 0\n\n    for i, num in enumerate(path):\n      hash = (hash * self.kBase + num) % self.kMod\n      if i >= m:\n        hash = (hash - path[i - m] * maxPower % self.kMod + self.kMod) % self.kMod\n      else:\n        maxPower = maxPower * self.kBase % self.kMod\n      if i >= m - 1:\n        hashes.add(hash)\n\n    return hashes\n", "tests": ["def test_longestCommonSubpath(self):\n    solution = Solution()\n    n = 23\n    paths = [[15, 2, 4, 7], [9, 12, 7, 3], [4, 11, 13]]\n    self.assertEqual(solution.longestCommonSubpath(n, paths), 4)", "def test_longestCommonSubpath(self):\n    solution = Solution()\n    n = 1\n    paths = [[], [], []]\n    self.assertEqual(solution.longestCommonSubpath(n, paths), 0)", "def test_longestCommonSubpath(self):\n    solution = Solution()\n    n = 5\n    paths = [[1, 2, 3], [1, 2, 3], [1, 2, 3]]\n    self.assertEqual(solution.longestCommonSubpath(n, paths), 3)", "def test_longestCommonSubpath(self):\n    solution = Solution()\n    n = 1\n    paths = [[1, 2, 3]]\n    self.assertEqual(solution.longestCommonSubpath(n, paths), 3)", "def test_longestCommonSubpath(self):\n    solution = Solution()\n    n = 10\n    paths = [[1, 2], [2, 3], [4]]\n    self.assertEqual(solution.longestCommonSubpath(n, paths), 0)", "def test_longestCommonSubpath(self):\n    solution = Solution()\n    n = 5\n    paths = [[1, 2, 2, 3], [1, 2, 2, 3], [1, 2, 4]]\n    self.assertEqual(solution.longestCommonSubpath(n, paths), 2)", "def test_longestCommonSubpath(self):\n    solution = Solution()\n    n = 1000\n    paths = [[i for i in range(1, 501)] for _ in range(10)]\n    self.assertGreater(solution.longestCommonSubpath(n, paths), 0)", "def test_longestCommonSubpath(self):\n    solution = Solution()\n    n = 1000\n    paths = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    self.assertEqual(solution.longestCommonSubpath(n, paths), 0)", "def test_longestCommonSubpath(self):\n    solution = Solution()\n    n = 5\n    paths = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    self.assertEqual(solution.longestCommonSubpath(n, paths), 0)", "def test_longestCommonSubpath(self):\n    solution = Solution()\n    n = 5\n    paths = [[1, 2, 3], [2, 4, 6], [2, 7, 8]]\n    self.assertEqual(solution.longestCommonSubpath(n, paths), 1)", "def test_longestCommonSubpath(self):\n    solution = Solution()\n    n = 5\n    paths = [[1, 2, 3], [4, 5, 6], [7, 8, 9, 10]]\n    self.assertEqual(solution.longestCommonSubpath(n, paths), 0)", "def test_longestCommonSubpath(self):\n    solution = Solution()\n    n = 10\n    paths1 = [[1, 2, 3], [4, 5, 6]]\n    paths2 = [[7, 8, 9], [10, 11, 12]]\n    self.assertEqual(solution.longestCommonSubpath(n, paths1 + paths2), 0)", "def test_longestCommonSubpath(self):\n    solution = Solution()\n    n = 5\n    paths = [[1, 2, 3]]\n    self.assertEqual(solution.longestCommonSubpath(n, paths), 3)", "def test_longestCommonSubpath(self):\n    solution = Solution()\n    n = 10\n    paths = [[1, 2, 3, 4], [1, 2, 5, 6], [7, 8, 9]]\n    self.assertEqual(solution.longestCommonSubpath(n, paths), 2)", "def test_longestCommonSubpath(self):\n    solution = Solution()\n    n = 5\n    paths = [[1, 2, 3, 2, 4], [1, 2, 3, 2, 6], [7, 8, 9]]\n    self.assertEqual(solution.longestCommonSubpath(n, paths), 2)", "def test_longestCommonSubpath(self):\n    solution = Solution()\n    n = 1000000\n    paths = [[i for i in range(1, 501)] * 200 for _ in range(10)]\n    self.assertGreater(solution.longestCommonSubpath(n, paths), 0)", "def test_longestCommonSubpath(self):\n    solution = Solution()\n    n = 1000000\n    paths = [[10 ** 9 + i for i in range(1, 501)] * 200 for _ in range(10)]\n    self.assertGreater(solution.longestCommonSubpath(n, paths), 0)", "def test_longestCommonSubpath(self):\n    solution = Solution()\n    n = 1000000\n    paths = [[-10 ** 9 + i for i in range(1, 501)] * 200 for _ in range(10)]\n    self.assertGreater(solution.longestCommonSubpath(n, paths), 0)", "def test_longestCommonSubpath(self):\n    solution = Solution()\n    n = 1000000\n    paths = [[0] * 500 for _ in range(10)]\n    self.assertEqual(solution.longestCommonSubpath(n, paths), 500)", "def test_longestCommonSubpath(self):\n    solution = Solution()\n    n = 1000000\n    paths = [[1] + [0] * 499 for _ in range(10)]\n    self.assertEqual(solution.longestCommonSubpath(n, paths), 1)"]}
{"task_num": 1926, "task_title": "Nearest Exit from Entrance in Maze", "func_name": "nearestExit", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def nearestExit(self, maze: List[List[str]], entrance: List[int]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(maze)\n    n = len(maze[0])\n    ans = 0\n    q = collections.deque([(entrance[0], entrance[1])])\n    seen = {(entrance[0], entrance[1])}\n\n    while q:\n      ans += 1\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if (x, y) in seen or maze[x][y] == '+':\n            continue\n          if x == 0 or x == m - 1 or y == 0 or y == n - 1:\n            return ans\n          q.append((x, y))\n          seen.add((x, y))\n\n    return -1\n", "tests": ["def test_nearestExit(self):\n    solution = Solution()\n    maze = [['+', '.'], ['.']]\n    entrance = [0, 1]\n    self.assertEqual(solution.nearestExit(maze, entrance), 2)", "def test_nearestExit():\n    solution = Solution()\n    maze = [['.' for _ in range(100)] for _ in range(100)]\n    maze[0][50] = '+'\n    maze[99][50] = '+'\n    entrance = [0, 50]\n    self.assertEqual(solution.nearestExit(maze, entrance), 1)", "def test_nearestExit():\n    solution = Solution()\n    maze = [['+', '.', '.', '.'], ['.', '.', '.', '.']]\n    entrance = [0, 2]\n    self.assertEqual(solution.nearestExit(maze, entrance), 1)", "def test_nearestExit():\n    solution = Solution()\n    maze = [['+', '.'], ['.']]\n    entrance = [0, 1]\n    self.assertEqual(solution.nearestExit(maze, entrance), -1)", "def test_nearestExit():\n    solution = Solution()\n    maze = [['+' for _ in range(5)] for _ in range(5)]\n    entrance = [0, 2]\n    self.assertEqual(solution.nearestExit(maze, entrance), -1)", "def test_nearestExit():\n    solution = Solution()\n    maze = [['.', '+', '.'], ['+', '.', '.'], ['.', '.', '.']]\n    entrance = [0, 1]\n    self.assertEqual(solution.nearestExit(maze, entrance), 0)", "def test_nearestExit():\n    solution = Solution()\n    maze = [['.' for _ in range(100)] for _ in range(100)]\n    maze[50][50] = '+'\n    entrance = [50, 50]\n    self.assertEqual(solution.nearestExit(maze, entrance), -1)", "def test_nearestExit():\n    solution = Solution()\n    maze = [['.', '.', '.'], ['.', '+', '.'], ['.', '.', '.']]\n    entrance = [0, 2]\n    self.assertEqual(solution.nearestExit(maze, entrance), 1)", "def test_nearestExit():\n    solution = Solution()\n    maze = [['.', '.', '.'], ['.', '+', '.'], ['+', '.', '.']]\n    entrance = [0, 1]\n    self.assertEqual(solution.nearestExit(maze, entrance), 2)", "def test_nearestExit():\n    solution = Solution()\n    maze = [['+', '+', '.'], ['.', '.', '.'], ['.', '.', '+']]\n    entrance = [0, 1]\n    self.assertEqual(solution.nearestExit(maze, entrance), -1)", "def test_nearestExit():\n    solution = Solution()\n    maze = [['.' for _ in range(3)] for _ in range(3)]\n    entrance = [0, 1]\n    self.assertEqual(solution.nearestExit(maze, entrance), 2)", "def test_nearestExit():\n    solution = Solution()\n    maze = [['.', '.', '.'], ['+', '.', '.'], ['.', '.', '.']]\n    entrance = [0, 1]\n    self.assertEqual(solution.nearestExit(maze, entrance), 1)", "def test_nearestExit():\n    solution = Solution()\n    maze = [['.', '.', '.'], ['.', '.', '.'], ['+', '.', '.']]\n    entrance = [0, 1]\n    self.assertEqual(solution.nearestExit(maze, entrance), 2)", "def test_nearestExit():\n    solution = Solution()\n    maze = [['+', '.', '.'], ['.', '.', '.'], ['.', '.', '.']]\n    entrance = [0, 1]\n    self.assertEqual(solution.nearestExit(maze, entrance), 2)", "def test_nearestExit():\n    solution = Solution()\n    maze = [['+', '.', '.'], ['.', '.', '.'], ['.', '.', '.']]\n    entrance = [0, 1]\n    self.assertEqual(solution.nearestExit(maze, entrance), 1)", "def test_nearestExit():\n    solution = Solution()\n    maze = [['.' for _ in range(10)] for _ in range(10)]\n    maze[0][5] = '+'\n    maze[9][5] = '+'\n    entrance = [0, 5]\n    self.assertEqual(solution.nearestExit(maze, entrance), 1)", "def test_nearestExit():\n    solution = Solution()\n    maze = [['+', '+', '.'], ['.', '.', '.'], ['+', '.', '.']]\n    entrance = [0, 1]\n    self.assertEqual(solution.nearestExit(maze, entrance), 2)", "def test_nearestExit():\n    solution = Solution()\n    maze = [['+', '.', '.'], ['.', '+', '.'], ['.', '.', '.']]\n    entrance = [0, 1]\n    self.assertEqual(solution.nearestExit(maze, entrance), -1)", "def test_nearestExit():\n    solution = Solution()\n    maze = [['.', '.', '.'], ['+', '+', '.'], ['.', '.', '.']]\n    entrance = [0, 1]\n    self.assertEqual(solution.nearestExit(maze, entrance), 2)", "def test_nearestExit():\n    solution = Solution()\n    maze = [['+', '.', '.'], ['.', '+', '.'], ['.', '.', '.']]\n    entrance = [0, 2]\n    self.assertEqual(solution.nearestExit(maze, entrance), -1)"]}
{"task_num": 1928, "task_title": "Minimum Cost to Reach Destination in Time", "func_name": "minCost", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\n    n = len(passingFees)\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, 0, n - 1, maxTime, passingFees)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, maxTime: int, passingFees: List[int]) -> int:\n    cost = [math.inf for _ in range(len(graph))]\n    dist = [maxTime + 1 for _ in range(len(graph))]\n\n    cost[src] = passingFees[src]\n    dist[src] = 0\n    minHeap = [(cost[src], dist[src], src)]\n\n    while minHeap:\n      currCost, d, u = heapq.heappop(minHeap)\n      if u == dst:\n        return cost[dst]\n      if d > dist[u] and currCost > cost[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w > maxTime:\n          continue\n        if currCost + passingFees[v] < cost[v]:\n          cost[v] = currCost + passingFees[v]\n          dist[v] = d + w\n          heapq.heappush(minHeap, (cost[v], dist[v], v))\n        elif d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (currCost + passingFees[v], dist[v], v))\n\n    return -1\n", "tests": ["def test_minCost():\n\n    class Solution:\n\n        def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\n            n = len(passingFees)\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, n - 1, maxTime, passingFees)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, maxTime: int, passingFees: List[int]) -> int:\n            cost = [math.inf for _ in range(len(graph))]\n            dist = [maxTime + 1 for _ in range(len(graph))]\n            cost[src] = passingFees[src]\n            dist[src] = 0\n            minHeap = [(cost[src], dist[src], src)]\n            while minHeap:\n                (currCost, d, u) = heapq.heappop(minHeap)\n                if u == dst:\n                    return cost[dst]\n                if d > dist[u] and currCost > cost[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w > maxTime:\n                        continue\n                    if currCost + passingFees[v] < cost[v]:\n                        cost[v] = currCost + passingFees[v]\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (cost[v], dist[v], v))\n                    elif d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (currCost + passingFees[v], dist[v], v))\n            return -1\n    solution = Solution()\n    assert solution.minCost(5, [[0, 1, 2], [1, 2, 3], [0, 3, 3]], [10, 100, 10]) == 20", "def test_minCost():\n\n    class Solution:\n\n        def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\n            n = len(passingFees)\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, n - 1, maxTime, passingFees)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, maxTime: int, passingFees: List[int]) -> int:\n            cost = [math.inf for _ in range(len(graph))]\n            dist = [maxTime + 1 for _ in range(len(graph))]\n            cost[src] = passingFees[src]\n            dist[src] = 0\n            minHeap = [(cost[src], dist[src], src)]\n            while minHeap:\n                (currCost, d, u) = heapq.heappop(minHeap)\n                if u == dst:\n                    return cost[dst]\n                if d > dist[u] and currCost > cost[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w > maxTime:\n                        continue\n                    if currCost + passingFees[v] < cost[v]:\n                        cost[v] = currCost + passingFees[v]\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (cost[v], dist[v], v))\n                    elif d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (currCost + passingFees[v], dist[v], v))\n            return -1\n    solution = Solution()\n    assert solution.minCost(2, [[0, 1, 3], [0, 2, 4]], [10, 100]) == 110", "def test_minCost():\n\n    class Solution:\n\n        def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\n            n = len(passingFees)\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, n - 1, maxTime, passingFees)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, maxTime: int, passingFees: List[int]) -> int:\n            cost = [math.inf for _ in range(len(graph))]\n            dist = [maxTime + 1 for _ in range(len(graph))]\n            cost[src] = passingFees[src]\n            dist[src] = 0\n            minHeap = [(cost[src], dist[src], src)]\n            while minHeap:\n                (currCost, d, u) = heapq.heappop(minHeap)\n                if u == dst:\n                    return cost[dst]\n                if d > dist[u] and currCost > cost[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w > maxTime:\n                        continue\n                    if currCost + passingFees[v] < cost[v]:\n                        cost[v] = currCost + passingFees[v]\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (cost[v], dist[v], v))\n                    elif d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (currCost + passingFees[v], dist[v], v))\n            return -1\n    solution = Solution()\n    assert solution.minCost(10, [[0, 3, 10], [3, 4, 10], [1, 2, 10]], [1000, 500, 200]) == 1800", "def test_minCost():\n\n    class Solution:\n\n        def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\n            n = len(passingFees)\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, n - 1, maxTime, passingFees)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, maxTime: int, passingFees: List[int]) -> int:\n            cost = [math.inf for _ in range(len(graph))]\n            dist = [maxTime + 1 for _ in range(len(graph))]\n            cost[src] = passingFees[src]\n            dist[src] = 0\n            minHeap = [(cost[src], dist[src], src)]\n            while minHeap:\n                (currCost, d, u) = heapq.heappop(minHeap)\n                if u == dst:\n                    return cost[dst]\n                if d > dist[u] and currCost > cost[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w > maxTime:\n                        continue\n                    if currCost + passingFees[v] < cost[v]:\n                        cost[v] = currCost + passingFees[v]\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (cost[v], dist[v], v))\n                    elif d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (currCost + passingFees[v], dist[v], v))\n            return -1\n    solution = Solution()\n    assert solution.minCost(5, [[0, 1, 2], [0, 4, 3]], [10, 100]) == 110", "def test_minCost():\n\n    class Solution:\n\n        def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\n            n = len(passingFees)\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, n - 1, maxTime, passingFees)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, maxTime: int, passingFees: List[int]) -> int:\n            cost = [math.inf for _ in range(len(graph))]\n            dist = [maxTime + 1 for _ in range(len(graph))]\n            cost[src] = passingFees[src]\n            dist[src] = 0\n            minHeap = [(cost[src], dist[src], src)]\n            while minHeap:\n                (currCost, d, u) = heapq.heappop(minHeap)\n                if u == dst:\n                    return cost[dst]\n                if d > dist[u] and currCost > cost[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w > maxTime:\n                        continue\n                    if currCost + passingFees[v] < cost[v]:\n                        cost[v] = currCost + passingFees[v]\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (cost[v], dist[v], v))\n                    elif d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (currCost + passingFees[v], dist[v], v))\n            return -1\n    solution = Solution()\n    assert solution.minCost(10, [[0, 2, 4], [2, 3, 8]], [1000, 500]) == 1500", "def test_minCost():\n\n    class Solution:\n\n        def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\n            n = len(passingFees)\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, n - 1, maxTime, passingFees)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, maxTime: int, passingFees: List[int]) -> int:\n            cost = [math.inf for _ in range(len(graph))]\n            dist = [maxTime + 1 for _ in range(len(graph))]\n            cost[src] = passingFees[src]\n            dist[src] = 0\n            minHeap = [(cost[src], dist[src], src)]\n            while minHeap:\n                (currCost, d, u) = heapq.heappop(minHeap)\n                if u == dst:\n                    return cost[dst]\n                if d > dist[u] and currCost > cost[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w > maxTime:\n                        continue\n                    if currCost + passingFees[v] < cost[v]:\n                        cost[v] = currCost + passingFees[v]\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (cost[v], dist[v], v))\n                    elif d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (currCost + passingFees[v], dist[v], v))\n            return -1\n    solution = Solution()\n    assert solution.minCost(8, [[0, 3, 10], [2, 4, 5]], [200, 500]) == 700", "def test_minCost():\n\n    class Solution:\n\n        def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\n            n = len(passingFees)\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, n - 1, maxTime, passingFees)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, maxTime: int, passingFees: List[int]) -> int:\n            cost = [math.inf for _ in range(len(graph))]\n            dist = [maxTime + 1 for _ in range(len(graph))]\n            cost[src] = passingFees[src]\n            dist[src] = 0\n            minHeap = [(cost[src], dist[src], src)]\n            while minHeap:\n                (currCost, d, u) = heapq.heappop(minHeap)\n                if u == dst:\n                    return cost[dst]\n                if d > dist[u] and currCost > cost[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w > maxTime:\n                        continue\n                    if currCost + passingFees[v] < cost[v]:\n                        cost[v] = currCost + passingFees[v]\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (cost[v], dist[v], v))\n                    elif d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (currCost + passingFees[v], dist[v], v))\n            return -1\n    solution = Solution()\n    assert solution.minCost(5, [[0, 2, 3], [3, 4, 7]], [1000, 500]) == 1500", "def test_minCost():\n\n    class Solution:\n\n        def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\n            n = len(passingFees)\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, n - 1, maxTime, passingFees)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, maxTime: int, passingFees: List[int]) -> int:\n            cost = [math.inf for _ in range(len(graph))]\n            dist = [maxTime + 1 for _ in range(len(graph))]\n            cost[src] = passingFees[src]\n            dist[src] = 0\n            minHeap = [(cost[src], dist[src], src)]\n            while minHeap:\n                (currCost, d, u) = heapq.heappop(minHeap)\n                if u == dst:\n                    return cost[dst]\n                if d > dist[u] and currCost > cost[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w > maxTime:\n                        continue\n                    if currCost + passingFees[v] < cost[v]:\n                        cost[v] = currCost + passingFees[v]\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (cost[v], dist[v], v))\n                    elif d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (currCost + passingFees[v], dist[v], v))\n            return -1\n    solution = Solution()\n    assert solution.minCost(10, [[0, 2, 4], [3, 4, 8]], [200, 500]) == 700", "def test_minCost():\n\n    class Solution:\n\n        def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\n            n = len(passingFees)\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, n - 1, maxTime, passingFees)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, maxTime: int, passingFees: List[int]) -> int:\n            cost = [math.inf for _ in range(len(graph))]\n            dist = [maxTime + 1 for _ in range(len(graph))]\n            cost[src] = passingFees[src]\n            dist[src] = 0\n            minHeap = [(cost[src], dist[src], src)]\n            while minHeap:\n                (currCost, d, u) = heapq.heappop(minHeap)\n                if u == dst:\n                    return cost[dst]\n                if d > dist[u] and currCost > cost[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w > maxTime:\n                        continue\n                    if currCost + passingFees[v] < cost[v]:\n                        cost[v] = currCost + passingFees[v]\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (cost[v], dist[v], v))\n                    elif d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (currCost + passingFees[v], dist[v], v))\n            return -1\n    solution = Solution()\n    assert solution.minCost(10, [[0, 3, 5], [3, 4, 7]], [200, 500]) == 700", "def test_minCost():\n\n    class Solution:\n\n        def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\n            n = len(passingFees)\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, n - 1, maxTime, passingFees)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, maxTime: int, passingFees: List[int]) -> int:\n            cost = [math.inf for _ in range(len(graph))]\n            dist = [maxTime + 1 for _ in range(len(graph))]\n            cost[src] = passingFees[src]\n            dist[src] = 0\n            minHeap = [(cost[src], dist[src], src)]\n            while minHeap:\n                (currCost, d, u) = heapq.heappop(minHeap)\n                if u == dst:\n                    return cost[dst]\n                for (v, w) in graph[u]:\n                    if d + w > maxTime:\n                        continue\n                    if currCost + passingFees[v] < cost[v]:\n                        cost[v] = currCost + passingFees[v]\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (cost[v], dist[v], v))\n                    elif d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (currCost + passingFees[v], dist[v], v))\n            return -1\n    solution = Solution()\n    assert solution.minCost(15, [[0, 2, 4], [3, 4, 8]], [1000, 500]) == 1500", "def test_minCost():\n\n    class Solution:\n\n        def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\n            n = len(passingFees)\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, n - 1, maxTime, passingFees)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, maxTime: int, passingFees: List[int]) -> int:\n            cost = [math.inf for _ in range(len(graph))]\n            dist = [maxTime + 1 for _ in range(len(graph))]\n            cost[src] = passingFees[src]\n            dist[src] = 0\n            minHeap = [(cost[src], dist[src], src)]\n            while minHeap:\n                (currCost, d, u) = heapq.heappop(minHeap)\n                if u == dst:\n                    return cost[dst]\n                for (v, w) in graph[u]:\n                    if d + w > maxTime:\n                        continue\n                    if currCost + passingFees[v] < cost[v]:\n                        cost[v] = currCost + passingFees[v]\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (cost[v], dist[v], v))\n                    elif d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (currCost + passingFees[v], dist[v], v))\n            return -1\n    solution = Solution()\n    assert solution.minCost(20, [[0, 4, 3], [2, 5, 2]], [200, 500]) == 700", "def test_minCost():\n\n    class Solution:\n\n        def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\n            n = len(passingFees)\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, n - 1, maxTime, passingFees)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, maxTime: int, passingFees: List[int]) -> int:\n            cost = [math.inf for _ in range(len(graph))]\n            dist = [maxTime + 1 for _ in range(len(graph))]\n            cost[src] = passingFees[src]\n            dist[src] = 0\n            minHeap = [(cost[src], dist[src], src)]\n            while minHeap:\n                (currCost, d, u) = heapq.heappop(minHeap)\n                if u == dst:\n                    return cost[dst]\n                for (v, w) in graph[u]:\n                    if d + w > maxTime:\n                        continue\n                    if currCost + passingFees[v] < cost[v]:\n                        cost[v] = currCost + passingFees[v]\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (cost[v], dist[v], v))\n                    elif d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (currCost + passingFees[v], dist[v], v))\n            return -1\n    solution = Solution()\n    assert solution.minCost(25, [[0, 2, 4], [3, 5, 6]], [200, 500]) == 1500", "def test_minCost():\n\n    class Solution:\n\n        def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\n            n = len(passingFees)\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, n - 1, maxTime, passingFees)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, maxTime: int, passingFees: List[int]) -> int:\n            cost = [math.inf for _ in range(len(graph))]\n            dist = [maxTime + 1 for _ in range(len(graph))]\n            cost[src] = passingFees[src]\n            dist[src] = 0\n            minHeap = [(cost[src], dist[src], src)]\n            while minHeap:\n                (currCost, d, u) = heapq.heappop(minHeap)\n                if u == dst:\n                    return cost[dst]\n                for (v, w) in graph[u]:\n                    if d + w > maxTime:\n                        continue\n                    if currCost + passingFees[v] < cost[v]:\n                        cost[v] = currCost + passingFees[v]\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (cost[v], dist[v], v))\n                    elif d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (currCost + passingFees[v], dist[v], v))\n            return -1\n    solution = Solution()\n    assert solution.minCost(30, [[0, 5, 4], [2, 6, 3]], [200, 500]) == 1500", "def test_minCost():\n\n    class Solution:\n\n        def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\n            n = len(passingFees)\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, n - 1, maxTime, passingFees)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, maxTime: int, passingFees: List[int]) -> int:\n            cost = [math.inf for _ in range(len(graph))]\n            dist = [maxTime + 1 for _ in range(len(graph))]\n            cost[src] = passingFees[src]\n            dist[src] = 0\n            minHeap = [(cost[src], dist[src], src)]\n            while minHeap:\n                (currCost, d, u) = heapq.heappop(minHeap)\n                if u == dst:\n                    return cost[dst]\n                for (v, w) in graph[u]:\n                    if d + w > maxTime:\n                        continue\n                    if currCost + passingFees[v] < cost[v]:\n                        cost[v] = currCost + passingFees[v]\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (cost[v], dist[v], v))\n                    elif d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (currCost + passingFees[v], dist[v], v))\n            return -1\n    solution = Solution()\n    assert solution.minCost(35, [[0, 2, 4], [3, 5, 6]], [200, 500]) == 1500", "def test_minCost():\n\n    class Solution:\n\n        def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\n            n = len(passingFees)\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, n - 1, maxTime, passingFees)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, maxTime: int, passingFees: List[int]) -> int:\n            cost = [math.inf for _ in range(len(graph))]\n            dist = [maxTime + 1 for _ in range(len(graph))]\n            cost[src] = passingFees[src]\n            dist[src] = 0\n            minHeap = [(cost[src], dist[src], src)]\n            while minHeap:\n                (currCost, d, u) = heapq.heappop(minHeap)\n                if u == dst:\n                    return cost[dst]\n                for (v, w) in graph[u]:\n                    if d + w > maxTime:\n                        continue\n                    if currCost + passingFees[v] < cost[v]:\n                        cost[v] = currCost + passingFees[v]\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (cost[v], dist[v], v))\n                    elif d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (currCost + passingFees[v], dist[v], v))\n            return -1\n    solution = Solution()\n    assert solution.minCost(40, [[0, 4, 3], [2, 5, 2]], [200, 500]) == 700", "def test_minCost():\n\n    class Solution:\n\n        def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\n            n = len(passingFees)\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, n - 1, maxTime, passingFees)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, maxTime: int, passingFees: List[int]) -> int:\n            cost = [math.inf for _ in range(len(graph))]\n            dist = [maxTime + 1 for _ in range(len(graph))]\n            cost[src] = passingFees[src]\n            dist[src] = 0\n            minHeap = [(cost[src], dist[src], src)]\n            while minHeap:\n                (currCost, d, u) = heapq.heappop(minHeap)\n                if u == dst:\n                    return cost[dst]\n                for (v, w) in graph[u]:\n                    if d + w > maxTime:\n                        continue\n                    if currCost + passingFees[v] < cost[v]:\n                        cost[v] = currCost + passingFees[v]\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (cost[v], dist[v], v))\n                    elif d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (currCost + passingFees[v], dist[v], v))\n            return -1\n    solution = Solution()\n    assert solution.minCost(45, [[0, 5, 4], [2, 6, 3]], [200, 500]) == 1500", "def test_minCost():\n\n    class Solution:\n\n        def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\n            n = len(passingFees)\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, n - 1, maxTime, passingFees)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, maxTime: int, passingFees: List[int]) -> int:\n            cost = [math.inf for _ in range(len(graph))]\n            dist = [maxTime + 1 for _ in range(len(graph))]\n            cost[src] = passingFees[src]\n            dist[src] = 0\n            minHeap = [(cost[src], dist[src], src)]\n            while minHeap:\n                (currCost, d, u) = heapq.heappop(minHeap)\n                if u == dst:\n                    return cost[dst]\n                for (v, w) in graph[u]:\n                    if d + w > maxTime:\n                        continue\n                    if currCost + passingFees[v] < cost[v]:\n                        cost[v] = currCost + passingFees[v]\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (cost[v], dist[v], v))\n                    elif d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (currCost + passingFees[v], dist[v], v))\n            return -1\n    solution = Solution()\n    assert solution.minCost(50, [[0, 2, 4], [3, 5, 6]], [200, 500]) == 1500", "def test_minCost():\n\n    class Solution:\n\n        def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\n            n = len(passingFees)\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, n - 1, maxTime, passingFees)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, maxTime: int, passingFees: List[int]) -> int:\n            cost = [math.inf for _ in range(len(graph))]\n            dist = [maxTime + 1 for _ in range(len(graph))]\n            cost[src] = passingFees[src]\n            dist[src] = 0\n            minHeap = [(cost[src], dist[src], src)]\n            while minHeap:\n                (currCost, d, u) = heapq.heappop(minHeap)\n                if u == dst:\n                    return cost[dst]\n                for (v, w) in graph[u]:\n                    if d + w > maxTime:\n                        continue\n                    if currCost + passingFees[v] < cost[v]:\n                        cost[v] = currCost + passingFees[v]\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (cost[v], dist[v], v))\n                    elif d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (currCost + passingFees[v], dist[v], v))\n            return -1\n    solution = Solution()\n    edges = [[0, 2], [2, 3], [0, 3]]\n    maxTime = 100\n    passingFees = [10, 50, 30]\n    assert solution.minCost(maxTime, edges, passingFees) == 70", "def test_minCost():\n\n    class Solution:\n\n        def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\n            n = len(passingFees)\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, n - 1, maxTime, passingFees)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, maxTime: int, passingFees: List[int]) -> int:\n            cost = [math.inf for _ in range(len(graph))]\n            dist = [maxTime + 1 for _ in range(len(graph))]\n            cost[src] = passingFees[src]\n            dist[src] = 0\n            minHeap = [(cost[src], dist[src], src)]\n            while minHeap:\n                (currCost, d, u) = heapq.heappop(minHeap)\n                if u == dst:\n                    return cost[dst]\n                for (v, w) in graph[u]:\n                    if d + w > maxTime:\n                        continue\n                    if currCost + passingFees[v] < cost[v]:\n                        cost[v] = currCost + passingFees[v]\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (cost[v], dist[v], v))\n                    elif d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (currCost + passingFees[v], dist[v], v))\n            return -1\n    solution = Solution()\n    edges = [[0, 2], [2, 3], [0, 4]]\n    maxTime = 80\n    passingFees = [10, 50, 30]\n    assert solution.minCost(maxTime, edges, passingFees) == 40", "def test_minCost():\n\n    class Solution:\n\n        def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\n            n = len(passingFees)\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, n - 1, maxTime, passingFees)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, maxTime: int, passingFees: List[int]) -> int:\n            cost = [math.inf for _ in range(len(graph))]\n            dist = [maxTime + 1 for _ in range(len(graph))]\n            cost[src] = passingFees[src]\n            dist[src] = 0\n            minHeap = [(cost[src], dist[src], src)]\n            while minHeap:\n                (currCost, d, u) = heapq.heappop(minHeap)\n                if u == dst:\n                    return cost[dst]\n                for (v, w) in graph[u]:\n                    if d + w > maxTime:\n                        continue\n                    if currCost + passingFees[v] < cost[v]:\n                        cost[v] = currCost + passingFees[v]\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (cost[v], dist[v], v))\n                    elif d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (currCost + passingFees[v], dist[v], v))\n            return -1\n    solution = Solution()\n    edges = [[0, 2], [2, 3]]\n    maxTime = 90\n    passingFees = [10, 50]\n    assert solution.minCost(maxTime, edges, passingFees) == 60"]}
{"task_num": 1938, "task_title": "Maximum Genetic Difference Query", "func_name": "maxGeneticDifference", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass TrieNode:\n  def __init__(self):\n    self.children = [None] * 2\n    self.count = 0\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n    self.kHeight = 17\n\n  def update(self, num: int, val: int) -> None:\n    node = self.root\n    for i in range(self.kHeight, -1, -1):\n      bit = (num >> i) & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n      node.count += val\n\n  def query(self, num: int) -> int:\n    ans = 0\n    node = self.root\n    for i in range(self.kHeight, -1, -1):\n      bit = (num >> i) & 1\n      targetBit = bit ^ 1\n      if node.children[targetBit] and node.children[targetBit].count > 0:\n        ans += 1 << i\n        node = node.children[targetBit]\n      else:\n        node = node.children[targetBit ^ 1]\n    return ans\n\n\nclass Solution:\n  def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\n    n = len(parents)\n    ans = [0] * len(queries)\n    rootVal = -1\n    tree = [[] for _ in range(n)]\n    nodeToQueries = collections.defaultdict(list)\n    trie = Trie()\n\n    for i, parent in enumerate(parents):\n      if parent == -1:\n        rootVal = i\n      else:\n        tree[parent].append(i)\n\n    for i, (node, val) in enumerate(queries):\n      nodeToQueries[node].append((i, val))\n\n    def dfs(node: int) -> None:\n      trie.update(node, 1)\n\n      for i, val in nodeToQueries[node]:\n        ans[i] = trie.query(val)\n\n      for child in tree[node]:\n        dfs(child)\n\n      trie.update(node, -1)\n\n    dfs(rootVal)\n    return ans\n", "tests": ["def test_maxGeneticDifference():\n\n    class Solution:\n\n        def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\n            n = len(parents)\n            ans = [0] * len(queries)\n            rootVal = -1\n            tree = [[] for _ in range(n)]\n            nodeToQueries = collections.defaultdict(list)\n            trie = Trie()\n            for (i, parent) in enumerate(parents):\n                if parent == -1:\n                    rootVal = i\n                else:\n                    tree[parent].append(i)\n            for (i, (node, val)) in enumerate(queries):\n                nodeToQueries[node].append((i, val))\n\n            def dfs(node: int) -> None:\n                trie.update(node, 1)\n                for (i, val) in nodeToQueries[node]:\n                    ans[i] = trie.query(val)\n                for child in tree[node]:\n                    dfs(child)\n                trie.update(node, -1)\n            dfs(rootVal)\n            return ans\n    solution = Solution()\n    parents = [-1, 0, 0, 1]\n    queries = [[3, 2], [0, 1]]\n    assert solution.maxGeneticDifference(parents, queries) == [1, 0], f'Expected: [1, 0], Got: {solution.maxGeneticDifference(parents, queries)}'", "def test_maxGeneticDifference():\n\n    class Solution:\n\n        def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\n            n = len(parents)\n            ans = [0] * len(queries)\n            rootVal = -1\n            tree = [[] for _ in range(n)]\n            nodeToQueries = collections.defaultdict(list)\n            trie = Trie()\n            for (i, parent) in enumerate(parents):\n                if parent == -1:\n                    rootVal = i\n                else:\n                    tree[parent].append(i)\n            for (i, (node, val)) in enumerate(queries):\n                nodeToQueries[node].append((i, val))\n\n            def dfs(node: int) -> None:\n                trie.update(node, 1)\n                for (i, val) in nodeToQueries[node]:\n                    ans[i] = trie.query(val)\n                for child in tree[node]:\n                    dfs(child)\n                trie.update(node, -1)\n            dfs(rootVal)\n            return ans\n    solution = Solution()\n    parents = [-1, 0, 1]\n    queries = [[3, 2], [0, 5]]\n    assert solution.maxGeneticDifference(parents, queries) == [4, 0], f'Expected: [4, 0], Got: {solution.maxGeneticDifference(parents, queries)}'", "def test_maxGeneticDifference():\n\n    class Solution:\n\n        def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\n            n = len(parents)\n            ans = [0] * len(queries)\n            rootVal = -1\n            tree = [[] for _ in range(n)]\n            nodeToQueries = collections.defaultdict(list)\n            trie = Trie()\n            for (i, parent) in enumerate(parents):\n                if parent == -1:\n                    rootVal = i\n                else:\n                    tree[parent].append(i)\n            for (i, (node, val)) in enumerate(queries):\n                nodeToQueries[node].append((i, val))\n\n            def dfs(node: int) -> None:\n                trie.update(node, 1)\n                for (i, val) in nodeToQueries[node]:\n                    ans[i] = trie.query(val)\n                for child in tree[node]:\n                    dfs(child)\n                trie.update(node, -1)\n            dfs(rootVal)\n            return ans\n    solution = Solution()\n    parents = [-1, 0, 0]\n    queries = [[3, 2], [1, 5]]\n    assert solution.maxGeneticDifference(parents, queries) == [4, 5], f'Expected: [4, 5], Got: {solution.maxGeneticDifference(parents, queries)}'", "def test_maxGeneticDifference():\n\n    class Solution:\n\n        def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\n            n = len(parents)\n            ans = [0] * len(queries)\n            rootVal = -1\n            tree = [[] for _ in range(n)]\n            nodeToQueries = collections.defaultdict(list)\n            trie = Trie()\n            for (i, parent) in enumerate(parents):\n                if parent == -1:\n                    rootVal = i\n                else:\n                    tree[parent].append(i)\n            for (i, (node, val)) in enumerate(queries):\n                nodeToQueries[node].append((i, val))\n\n            def dfs(node: int) -> None:\n                trie.update(node, 1)\n                for (i, val) in nodeToQueries[node]:\n                    ans[i] = trie.query(val)\n                for child in tree[node]:\n                    dfs(child)\n                trie.update(node, -1)\n            dfs(rootVal)\n            return ans\n    solution = Solution()\n    parents = [-1]\n    queries = [[0, 2]]\n    assert solution.maxGeneticDifference(parents, queries) == [2], f'Expected: [2], Got: {solution.maxGeneticDifference(parents, queries)}'", "def test_maxGeneticDifference():\n\n    class Solution:\n\n        def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\n            n = len(parents)\n            ans = [0] * len(queries)\n            rootVal = -1\n            tree = [[] for _ in range(n)]\n            nodeToQueries = collections.defaultdict(list)\n            trie = Trie()\n            for (i, parent) in enumerate(parents):\n                if parent == -1:\n                    rootVal = i\n                else:\n                    tree[parent].append(i)\n            for (i, (node, val)) in enumerate(queries):\n                nodeToQueries[node].append((i, val))\n\n            def dfs(node: int) -> None:\n                trie.update(node, 1)\n                for (i, val) in nodeToQueries[node]:\n                    ans[i] = trie.query(val)\n                for child in tree[node]:\n                    dfs(child)\n                trie.update(node, -1)\n            dfs(rootVal)\n            return ans\n    solution = Solution()\n    parents = [-1, 0]\n    queries = [[2, 4], [0, 5]]\n    assert solution.maxGeneticDifference(parents, queries) == [7, 3], f'Expected: [7, 3], Got: {solution.maxGeneticDifference(parents, queries)}'", "def test_maxGeneticDifference():\n\n    class Solution:\n\n        def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\n            n = len(parents)\n            ans = [0] * len(queries)\n            rootVal = -1\n            tree = [[] for _ in range(n)]\n            nodeToQueries = collections.defaultdict(list)\n            trie = Trie()\n            for (i, parent) in enumerate(parents):\n                if parent == -1:\n                    rootVal = i\n                else:\n                    tree[parent].append(i)\n            for (i, (node, val)) in enumerate(queries):\n                nodeToQueries[node].append((i, val))\n\n            def dfs(node: int) -> None:\n                trie.update(node, 1)\n                for (i, val) in nodeToQueries[node]:\n                    ans[i] = trie.query(val)\n                for child in tree[node]:\n                    dfs(child)\n                trie.update(node, -1)\n            dfs(rootVal)\n            return ans\n    solution = Solution()\n    parents = [-1]\n    queries = [[0, 8], [2, 9]]\n    assert solution.maxGeneticDifference(parents, queries) == [7, 6], f'Expected: [7, 6], Got: {solution.maxGeneticDifference(parents, queries)}'", "def test_maxGeneticDifference():\n\n    class Solution:\n\n        def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\n            n = len(parents)\n            ans = [0] * len(queries)\n            rootVal = -1\n            tree = [[] for _ in range(n)]\n            nodeToQueries = collections.defaultdict(list)\n            trie = Trie()\n            for (i, parent) in enumerate(parents):\n                if parent == -1:\n                    rootVal = i\n                else:\n                    tree[parent].append(i)\n            for (i, (node, val)) in enumerate(queries):\n                nodeToQueries[node].append((i, val))\n\n            def dfs(node: int) -> None:\n                trie.update(node, 1)\n                for (i, val) in nodeToQueries[node]:\n                    ans[i] = trie.query(val)\n                for child in tree[node]:\n                    dfs(child)\n                trie.update(node, -1)\n            dfs(rootVal)\n            return ans\n    solution = Solution()\n    parents = [-1, 0, 0]\n    queries = [[3, 16], [2, 12]]\n    assert solution.maxGeneticDifference(parents, queries) == [14, 10], f'Expected: [14, 10], Got: {solution.maxGeneticDifference(parents, queries)}'", "def test_maxGeneticDifference():\n\n    class Solution:\n\n        def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\n            n = len(parents)\n            ans = [0] * len(queries)\n            rootVal = -1\n            tree = [[] for _ in range(n)]\n            nodeToQueries = collections.defaultdict(list)\n            trie = Trie()\n            for (i, parent) in enumerate(parents):\n                if parent == -1:\n                    rootVal = i\n                else:\n                    tree[parent].append(i)\n            for (i, (node, val)) in enumerate(queries):\n                nodeToQueries[node].append((i, val))\n\n            def dfs(node: int) -> None:\n                trie.update(node, 1)\n                for (i, val) in nodeToQueries[node]:\n                    ans[i] = trie.query(val)\n                for child in tree[node]:\n                    dfs(child)\n                trie.update(node, -1)\n            dfs(rootVal)\n            return ans\n    solution = Solution()\n    parents = [-1, 0, 1]\n    queries = [[3, 8], [2, 12]]\n    assert solution.maxGeneticDifference(parents, queries) == [6, 4], f'Expected: [6, 4], Got: {solution.maxGeneticDifference(parents, queries)}'", "def test_maxGeneticDifference():\n\n    class Solution:\n\n        def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\n            n = len(parents)\n            ans = [0] * len(queries)\n            rootVal = -1\n            tree = [[] for _ in range(n)]\n            nodeToQueries = collections.defaultdict(list)\n            trie = Trie()\n            for (i, parent) in enumerate(parents):\n                if parent == -1:\n                    rootVal = i\n                else:\n                    tree[parent].append(i)\n            for (i, (node, val)) in enumerate(queries):\n                nodeToQueries[node].append((i, val))\n\n            def dfs(node: int) -> None:\n                trie.update(node, 1)\n                for (i, val) in nodeToQueries[node]:\n                    ans[i] = trie.query(val)\n                for child in tree[node]:\n                    dfs(child)\n                trie.update(node, -1)\n            dfs(rootVal)\n            return ans\n    solution = Solution()\n    parents = [-1, 0, 0]\n    queries = [[3, 16], [2, 12], [1, 8]]\n    assert solution.maxGeneticDifference(parents, queries) == [14, 10, 6], f'Expected: [14, 10, 6], Got: {solution.maxGeneticDifference(parents, queries)}'", "def test_maxGeneticDifference():\n\n    class Solution:\n\n        def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\n            n = len(parents)\n            ans = [0] * len(queries)\n            rootVal = -1\n            tree = [[] for _ in range(n)]\n            nodeToQueries = collections.defaultdict(list)\n            trie = Trie()\n            for (i, parent) in enumerate(parents):\n                if parent == -1:\n                    rootVal = i\n                else:\n                    tree[parent].append(i)\n            for (i, (node, val)) in enumerate(queries):\n                nodeToQueries[node].append((i, val))\n\n            def dfs(node: int) -> None:\n                trie.update(node, 1)\n                for (i, val) in nodeToQueries[node]:\n                    ans[i] = trie.query(val)\n                for child in tree[node]:\n                    dfs(child)\n                trie.update(node, -1)\n            dfs(rootVal)\n            return ans\n    solution = Solution()\n    parents = [-1, 0, 0]\n    queries = [[3, 16], [2, 12]]\n    assert solution.maxGeneticDifference(parents, queries) == [14, 10], f'Expected: [14, 10], Got: {solution.maxGeneticDifference(parents, queries)}'", "def test_maxGeneticDifference():\n\n    class Solution:\n\n        def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\n            n = len(parents)\n            ans = [0] * len(queries)\n            rootVal = -1\n            tree = [[] for _ in range(n)]\n            nodeToQueries = collections.defaultdict(list)\n            trie = Trie()\n            for (i, parent) in enumerate(parents):\n                if parent == -1:\n                    rootVal = i\n                else:\n                    tree[parent].append(i)\n            for (i, (node, val)) in enumerate(queries):\n                nodeToQueries[node].append((i, val))\n\n            def dfs(node: int) -> None:\n                trie.update(node, 1)\n                for (i, val) in nodeToQueries[node]:\n                    ans[i] = trie.query(val)\n                for child in tree[node]:\n                    dfs(child)\n                trie.update(node, -1)\n            dfs(rootVal)\n            return ans\n    solution = Solution()\n    parents = [-1]\n    queries = [[0, 2]]\n    assert solution.maxGeneticDifference(parents, queries) == [1], f'Expected: [1], Got: {solution.maxGeneticDifference(parents, queries)}'", "def test_maxGeneticDifference():\n\n    class Solution:\n\n        def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\n            n = len(parents)\n            ans = [0] * len(queries)\n            rootVal = -1\n            tree = [[] for _ in range(n)]\n            nodeToQueries = collections.defaultdict(list)\n            trie = Trie()\n            for (i, parent) in enumerate(parents):\n                if parent == -1:\n                    rootVal = i\n                else:\n                    tree[parent].append(i)\n            for (i, (node, val)) in enumerate(queries):\n                nodeToQueries[node].append((i, val))\n\n            def dfs(node: int) -> None:\n                trie.update(node, 1)\n                for (i, val) in nodeToQueries[node]:\n                    ans[i] = trie.query(val)\n                for child in tree[node]:\n                    dfs(child)\n                trie.update(node, -1)\n            dfs(rootVal)\n            return ans\n    solution = Solution()\n    parents = [-1, 0, 0]\n    queries = [[3, 16], [2, 12]]\n    assert solution.maxGeneticDifference(parents, queries) == [14, 10], f'Expected: [14, 10], Got: {solution.maxGeneticDifference(parents, queries)}'", "def test_maxGeneticDifference():\n\n    class Solution:\n\n        def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\n            n = len(parents)\n            ans = [0] * len(queries)\n            rootVal = -1\n            tree = [[] for _ in range(n)]\n            nodeToQueries = collections.defaultdict(list)\n            trie = Trie()\n            for (i, parent) in enumerate(parents):\n                if parent == -1:\n                    rootVal = i\n                else:\n                    tree[parent].append(i)\n            for (i, (node, val)) in enumerate(queries):\n                nodeToQueries[node].append((i, val))\n\n            def dfs(node: int) -> None:\n                trie.update(node, 1)\n                for (i, val) in nodeToQueries[node]:\n                    ans[i] = trie.query(val)\n                for child in tree[node]:\n                    dfs(child)\n                trie.update(node, -1)\n            dfs(rootVal)\n            return ans\n    solution = Solution()\n    parents = [-1, 0, 1]\n    queries = [[3, 8], [2, 12], [0, 16]]\n    assert solution.maxGeneticDifference(parents, queries) == [6, 4, 10], f'Expected: [6, 4, 10], Got: {solution.maxGeneticDifference(parents, queries)}'", "def test_maxGeneticDifference():\n\n    class Solution:\n\n        def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\n            n = len(parents)\n            ans = [0] * len(queries)\n            rootVal = -1\n            tree = [[] for _ in range(n)]\n            nodeToQueries = collections.defaultdict(list)\n            trie = Trie()\n            for (i, parent) in enumerate(parents):\n                if parent == -1:\n                    rootVal = i\n                else:\n                    tree[parent].append(i)\n            for (i, (node, val)) in enumerate(queries):\n                nodeToQueries[node].append((i, val))\n\n            def dfs(node: int) -> None:\n                trie.update(node, 1)\n                for (i, val) in nodeToQueries[node]:\n                    ans[i] = trie.query(val)\n                for child in tree[node]:\n                    dfs(child)\n                trie.update(node, -1)\n            dfs(rootVal)\n            return ans\n    solution = Solution()\n    parents = [-1]\n    queries = [[0, 2], [0, 4]]\n    assert solution.maxGeneticDifference(parents, queries) == [1, 2], f'Expected: [1, 2], Got: {solution.maxGeneticDifference(parents, queries)}'", "def test_maxGeneticDifference():\n\n    class Solution:\n\n        def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\n            n = len(parents)\n            ans = [0] * len(queries)\n            rootVal = -1\n            tree = [[] for _ in range(n)]\n            nodeToQueries = collections.defaultdict(list)\n            trie = Trie()\n            for (i, parent) in enumerate(parents):\n                if parent == -1:\n                    rootVal = i\n                else:\n                    tree[parent].append(i)\n            for (i, (node, val)) in enumerate(queries):\n                nodeToQueries[node].append((i, val))\n\n            def dfs(node: int) -> None:\n                trie.update(node, 1)\n                for (i, val) in nodeToQueries[node]:\n                    ans[i] = trie.query(val)\n                for child in tree[node]:\n                    dfs(child)\n                trie.update(node, -1)\n            dfs(rootVal)\n            return ans\n    solution = Solution()\n    parents = [-1, 0, 0]\n    queries = [[3, 16], [2, 12], [1, 8]]\n    assert solution.maxGeneticDifference(parents, queries) == [14, 10, 6], f'Expected: [14, 10, 6], Got: {solution.maxGeneticDifference(parents, queries)}'", "def test_maxGeneticDifference():\n\n    class Solution:\n\n        def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\n            n = len(parents)\n            ans = [0] * len(queries)\n            rootVal = -1\n            tree = [[] for _ in range(n)]\n            nodeToQueries = collections.defaultdict(list)\n            trie = Trie()\n            for (i, parent) in enumerate(parents):\n                if parent == -1:\n                    rootVal = i\n                else:\n                    tree[parent].append(i)\n            for (i, (node, val)) in enumerate(queries):\n                nodeToQueries[node].append((i, val))\n\n            def dfs(node: int) -> None:\n                trie.update(node, 1)\n                for (i, val) in nodeToQueries[node]:\n                    ans[i] = trie.query(val)\n                for child in tree[node]:\n                    dfs(child)\n                trie.update(node, -1)\n            dfs(rootVal)\n            return ans\n    solution = Solution()\n    parents = [-1, 0]\n    queries = [[2, 12], [3, 16]]\n    assert solution.maxGeneticDifference(parents, queries) == [10, 14], f'Expected: [10, 14], Got: {solution.maxGeneticDifference(parents, queries)}'", "def test_maxGeneticDifference():\n\n    class Solution:\n\n        def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\n            n = len(parents)\n            ans = [0] * len(queries)\n            rootVal = -1\n            tree = [[] for _ in range(n)]\n            nodeToQueries = collections.defaultdict(list)\n            trie = Trie()\n            for (i, parent) in enumerate(parents):\n                if parent == -1:\n                    rootVal = i\n                else:\n                    tree[parent].append(i)\n            for (i, (node, val)) in enumerate(queries):\n                nodeToQueries[node].append((i, val))\n\n            def dfs(node: int) -> None:\n                trie.update(node, 1)\n                for (i, val) in nodeToQueries[node]:\n                    ans[i] = trie.query(val)\n                for child in tree[node]:\n                    dfs(child)\n                trie.update(node, -1)\n            dfs(rootVal)\n            return ans\n    solution = Solution()\n    parents = [-1]\n    queries = [[0, 2], [0, 4]]\n    assert solution.maxGeneticDifference(parents, queries) == [3, 5], f'Expected: [3, 5], Got: {solution.maxGeneticDifference(parents, queries)}'", "def test_maxGeneticDifference():\n\n    class Solution:\n\n        def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\n            n = len(parents)\n            ans = [0] * len(queries)\n            rootVal = -1\n            tree = [[] for _ in range(n)]\n            nodeToQueries = collections.defaultdict(list)\n            trie = Trie()\n            for (i, parent) in enumerate(parents):\n                if parent == -1:\n                    rootVal = i\n                else:\n                    tree[parent].append(i)\n            for (i, (node, val)) in enumerate(queries):\n                nodeToQueries[node].append((i, val))\n\n            def dfs(node: int) -> None:\n                trie.update(node, 1)\n                for (i, val) in nodeToQueries[node]:\n                    ans[i] = trie.query(val)\n                for child in tree[node]:\n                    dfs(child)\n                trie.update(node, -1)\n            dfs(rootVal)\n            return ans\n    solution = Solution()\n    parents = [-1, 0, 0]\n    queries = [[3, 16], [2, 12], [1, 8]]\n    assert solution.maxGeneticDifference(parents, queries) == [14, 10, 6], f'Expected: [14, 10, 6], Got: {solution.maxGeneticDifference(parents, queries)}'", "def test_maxGeneticDifference():\n\n    class Solution:\n\n        def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\n            n = len(parents)\n            ans = [0] * len(queries)\n            rootVal = -1\n            tree = [[] for _ in range(n)]\n            nodeToQueries = collections.defaultdict(list)\n            trie = Trie()\n            for (i, parent) in enumerate(parents):\n                if parent == -1:\n                    rootVal = i\n                else:\n                    tree[parent].append(i)\n            for (i, (node, val)) in enumerate(queries):\n                nodeToQueries[node].append((i, val))\n\n            def dfs(node: int) -> None:\n                trie.update(node, 1)\n                for (i, val) in nodeToQueries[node]:\n                    ans[i] = trie.query(val)\n                for child in tree[node]:\n                    dfs(child)\n                trie.update(node, -1)\n            dfs(rootVal)\n            return ans\n    solution = Solution()\n    parents = [-1, 0]\n    queries = [[2, 12], [3, 16]]\n    assert solution.maxGeneticDifference(parents, queries) == [10, 14], f'Expected: [10, 14], Got: {solution.maxGeneticDifference(parents, queries)}'", "def test_maxGeneticDifference():\n\n    class Solution:\n\n        def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\n            n = len(parents)\n            ans = [0] * len(queries)\n            rootVal = -1\n            tree = [[] for _ in range(n)]\n            nodeToQueries = collections.defaultdict(list)\n            trie = Trie()\n            for (i, parent) in enumerate(parents):\n                if parent == -1:\n                    rootVal = i\n                else:\n                    tree[parent].append(i)\n            for (i, (node, val)) in enumerate(queries):\n                nodeToQueries[node].append((i, val))\n\n            def dfs(node: int) -> None:\n                trie.update(node, 1)\n                for (i, val) in nodeToQueries[node]:\n                    ans[i] = trie.query(val)\n                for child in tree[node]:\n                    dfs(child)\n                trie.update(node, -1)\n            dfs(rootVal)\n            return ans\n    solution = Solution()\n    parents = [-1]\n    queries = [[0, 2], [0, 4], [0, 6]]\n    assert solution.maxGeneticDifference(parents, queries) == [3, 5, 7], f'Expected: [3, 5, 7], Got: {solution.maxGeneticDifference(parents, queries)}'"]}
{"task_num": 1971, "task_title": "Find if Path Exists in Graph", "func_name": "validPath", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def validPath(self, n: int, edges: List[List[int]], source: int, destination: int) -> bool:\n    uf = UnionFind(n)\n\n    for u, v in edges:\n      uf.unionByRank(u, v)\n\n    return uf.find(source) == uf.find(destination)\n", "tests": ["def test_validPath():\n    solution = Solution()\n\n    def test_case1():\n        n = 3\n        edges = [[0, 1], [1, 2], [2, 0]]\n        source = 0\n        destination = 2", "def test_validPath():\n    solution = Solution()\n\n    def test_case2():\n        n = 6\n        edges = [[0, 1], [0, 2], [3, 4], [3, 5]]\n        source = 0\n        destination = 5", "def test_validPath():\n    solution = Solution()\n\n    def test_case3():\n        n = 5\n        edges = [[0, 1], [1, 2], [3, 4]]\n        source = 0\n        destination = 4", "def test_validPath():\n    solution = Solution()\n\n    def test_case4():\n        n = 2\n        edges = [[0, 1]]\n        source = 0\n        destination = 0", "def test_validPath():\n    solution = Solution()\n\n    def test_case5():\n        n = 2\n        edges = []\n        source = 0\n        destination = 1", "def test_validPath():\n    solution = Solution()\n\n    def test_case6():\n        n = 1\n        edges = []\n        source = 0\n        destination = 0", "def test_validPath():\n    solution = Solution()\n\n    def test_case8():\n        n = 1000\n        edges = [[i % n, (i + 1) % n] for i in range(n)]\n        source = 0\n        destination = 999", "def test_validPath():\n    solution = Solution()\n\n    def test_case9():\n        n = 1\n        edges = [[0, 0]]\n        source = 0\n        destination = 0", "def test_validPath():\n    solution = Solution()\n\n    def test_case10():\n        n = 5\n        edges = [[0, 1], [0, 2], [3, 4], [1, 3]]\n        source = 0\n        destination = 3", "def test_validPath():\n    solution = Solution()\n\n    def test_case11():\n        n = 4\n        edges = [[0, 1], [0, 2], [1, 3]]\n        source = 0\n        destination = 3", "def test_validPath():\n    solution = Solution()\n\n    def test_case12():\n        n = 3\n        edges = [[0, 1], [1, 2]]\n        source = 0\n        destination = 2", "def test_validPath():\n    solution = Solution()\n\n    def test_case13():\n        n = 3\n        edges = [[0, 1], [2, 1]]\n        source = 0\n        destination = 2", "def test_validPath():\n    solution = Solution()\n\n    def test_case14():\n        n = 2\n        edges = [[1, 0]]\n        source = 1\n        destination = 0", "def test_validPath():\n    solution = Solution()\n\n    def test_case15():\n        n = 2\n        edges = []\n        source = 1\n        destination = 0", "def test_validPath():\n    solution = Solution()\n\n    def test_case16():\n        n = 2\n        edges = [[1, 0]]\n        source = 1\n        destination = 1", "def test_validPath():\n    solution = Solution()\n\n    def test_case17():\n        n = 4\n        edges = [[0, 1], [2, 3]]\n        source = 0\n        destination = 3", "def test_validPath():\n    solution = Solution()\n\n    def test_case18():\n        n = 2\n        edges = [[0, 1], [1, 0]]\n        source = 0\n        destination = 0", "def test_validPath():\n    solution = Solution()\n\n    def test_case19():\n        n = 3\n        edges = [[0, 1], [2, 1]]\n        source = 0\n        destination = 2", "def test_validPath():\n    solution = Solution()\n\n    def test_case20():\n        n = 2\n        edges = [[1, 0]]\n        source = 0\n        destination = 0", "def test_validPath():\n    solution = Solution()\n\n    def test_case21():\n        n = 1\n        edges = []\n        source = 0\n        destination = 0"]}
{"task_num": 1976, "task_title": "Number of Ways to Arrive at Destination", "func_name": "countPaths", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countPaths(self, n: int, roads: List[List[int]]) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in roads:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, 0, n - 1)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int) -> int:\n    kMod = 10**9 + 7\n    ways = [0] * len(graph)\n    dist = [math.inf] * len(graph)\n\n    ways[src] = 1\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          ways[v] = ways[u]\n          heapq.heappush(minHeap, (dist[v], v))\n        elif d + w == dist[v]:\n          ways[v] += ways[u]\n          ways[v] %= kMod\n\n    return ways[dst]\n", "tests": ["def test_countPaths(self):\n    n = 5\n    roads = [[0, 1, 2], [1, 2, 3], [0, 3, 4]]\n    self.assertEqual(self.solution.countPaths(n, roads), 2)", "def test_countPaths():\n    n = 1000\n    roads = [[i, (i + 1) % n, i] for i in range(n)]\n    self.assertEqual(self.solution.countPaths(n, roads), 1)", "def test_countPaths():\n    n = 2\n    roads = []\n    self.assertEqual(self.solution.countPaths(n, roads), 0)", "def test_countPaths():\n    n = 3\n    roads = [[0, 2, 1]]\n    self.assertEqual(self.solution.countPaths(n, roads), 1)", "def test_countPaths():\n    n = 5\n    roads = [[0, 1, 3], [2, 4, 2]]\n    self.assertEqual(self.solution.countPaths(n, roads), 0)", "def test_countPaths():\n    n = 1\n    roads = []\n    self.assertEqual(self.solution.countPaths(n, roads), 0)", "def test_countPaths():\n    n = 5\n    roads = [[0, 1, -2], [1, 2, 3], [0, 3, 4]]\n    with self.assertRaises(ValueError):\n        self.solution.countPaths(n, roads)", "def test_countPaths():\n    n = 5\n    roads = [[0, 2, 1], [3, 4, 2]]\n    self.assertEqual(self.solution.countPaths(n, roads), 1)", "def test_countPaths():\n    n = 5\n    roads = [[0, 0, 2], [1, 2, 3], [0, 3, 4]]\n    self.assertEqual(self.solution.countPaths(n, roads), 1)", "def test_countPaths():\n    n = 10000\n    roads = [[i, (i + 1) % n, i] for i in range(n)]\n    self.assertEqual(self.solution.countPaths(n, roads), 1)", "def test_countPaths():\n    n = 5\n    roads = [[0, 1, 3], [0, 2, 3], [1, 4, 2]]\n    self.assertEqual(self.solution.countPaths(n, roads), 3)", "def test_countPaths():\n    n = 5\n    roads = [[0, 1, 3], [2, 4, 2]]\n    self.assertEqual(self.solution.countPaths(n, roads), 0)", "def test_countPaths():\n    n = 5\n    roads = [[0, 1, 1], [1, 2, 1], [2, 3, 1], [3, 4, 1]]\n    self.assertEqual(self.solution.countPaths(n, roads), 4)", "def test_countPaths():\n    n = 5\n    roads = [[0, 1, -2], [1, 2, 3], [0, 3, 4]]\n    with self.assertRaises(ValueError):\n        self.solution.countPaths(n, roads)", "def test_countPaths():\n    n = 5\n    roads = [[0, 1, 0], [1, 2, 3], [0, 3, 4]]\n    self.assertEqual(self.solution.countPaths(n, roads), 2)", "def test_countPaths():\n    n = 5\n    roads = []\n    self.assertEqual(self.solution.countPaths(n, roads), 0)", "def test_countPaths():\n    n = 5\n    roads = [[0, 1, float('inf')], [1, 2, 3], [0, 3, 4]]\n    self.assertEqual(self.solution.countPaths(n, roads), 0)", "def test_countPaths():\n    n = 5\n    roads = [[0, 2, 3], [1, 2, 4]]\n    self.assertEqual(self.solution.countPaths(n, roads), 0)", "def test_countPaths():\n    n = 5\n    roads = [[0, 0, 2], [1, 4, 3]]\n    self.assertEqual(self.solution.countPaths(n, roads), 1)", "def test_countPaths():\n    n = 5\n    roads = [[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 1]]\n    self.assertEqual(self.solution.countPaths(n, roads), 0)"]}
{"task_num": 1977, "task_title": "Number of Ways to Separate Numbers", "func_name": "numberOfCombinations", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numberOfCombinations(self, num: str) -> int:\n    if num[0] == '0':\n      return 0\n\n    kMod = 1_000_000_007\n    n = len(num)\n    dp = [[0] * (n + 1) for _ in range(n)]\n    lcs = [[0] * (n + 1) for _ in range(n + 1)]\n\n    for i in range(n - 1, -1, -1):\n      for j in range(i + 1, n):\n        if num[i] == num[j]:\n          lcs[i][j] = lcs[i + 1][j + 1] + 1\n\n    for i in range(n):\n      for k in range(1, i + 2):\n        dp[i][k] += dp[i][k - 1]\n        dp[i][k] %= kMod\n        s = i - k + 1\n        if num[s] == '0':\n          continue\n        if s == 0:\n          dp[i][k] += 1\n          continue\n        if s < k:\n          dp[i][k] += dp[s - 1][s]\n          continue\n        l = lcs[s - k][s]\n        if l >= k or num[s - k + l] <= num[s + l]:\n          dp[i][k] += dp[s - 1][k]\n        else:\n          dp[i][k] += dp[s - 1][k - 1]\n\n    return dp[n - 1][n] % kMod\n", "tests": ["def test_numberOfCombinations(self):\n    solution = Solution()\n    self.assertEqual(solution.numberOfCombinations('123'), 3)", "def test_numberOfCombinations():\n    solution = Solution()\n    self.assertEqual(solution.numberOfCombinations('012'), 0)", "def test_numberOfCombinations():\n    solution = Solution()\n    self.assertEqual(solution.numberOfCombinations('5'), 1)", "def test_numberOfCombinations():\n    solution = Solution()\n    self.assertEqual(solution.numberOfCombinations('111'), 1)", "def test_numberOfCombinations():\n    solution = Solution()\n    self.assertEqual(solution.numberOfCombinations('1234567890123456'), 316)", "def test_numberOfCombinations():\n    solution = Solution()\n    self.assertEqual(solution.numberOfCombinations('12345678901234567890'), 250)", "def test_numberOfCombinations():\n    solution = Solution()\n    self.assertEqual(solution.numberOfCombinations('0'), 1)", "def test_numberOfCombinations():\n    solution = Solution()\n    self.assertEqual(solution.numberOfCombinations('99999999999999'), 1)", "def test_numberOfCombinations():\n    solution = Solution()\n    self.assertEqual(solution.numberOfCombinations('1234'), 1)", "def test_numberOfCombinations():\n    solution = Solution()\n    self.assertEqual(solution.numberOfCombinations('999999999'), 0)", "def test_numberOfCombinations():\n    solution = Solution()\n    self.assertEqual(solution.numberOfCombinations('1234567890123456'), 316)", "def test_numberOfCombinations():\n    solution = Solution()\n    self.assertEqual(solution.numberOfCombinations('10'), 2)", "def test_numberOfCombinations():\n    solution = Solution()\n    self.assertEqual(solution.numberOfCombinations('123456789012345678901234567890'), 250)", "def test_numberOfCombinations():\n    solution = Solution()\n    self.assertEqual(solution.numberOfCombinations('000'), 0)", "def test_numberOfCombinations():\n    solution = Solution()\n    self.assertEqual(solution.numberOfCombinations('1'), 1)", "def test_numberOfCombinations():\n    solution = Solution()\n    self.assertEqual(solution.numberOfCombinations('111111111'), 1)", "def test_numberOfCombinations():\n    solution = Solution()\n    self.assertEqual(solution.numberOfCombinations('10234'), 3)", "def test_numberOfCombinations():\n    solution = Solution()\n    self.assertEqual(solution.numberOfCombinations('123456'), 10)", "def test_numberOfCombinations():\n    solution = Solution()\n    self.assertEqual(solution.numberOfCombinations('122333'), 7)", "def test_numberOfCombinations():\n    solution = Solution()\n    self.assertEqual(solution.numberOfCombinations('111122233344445555'), 150)"]}
{"task_num": 1994, "task_title": "The Number of Good Subsets", "func_name": "numberOfGoodSubsets", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numberOfGoodSubsets(self, nums: List[int]) -> int:\n    kMod = 1_000_000_007\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n    n = 1 << len(primes)\n    dp = [1] + [0] * (n - 1)\n    count = collections.Counter(nums)\n\n    for num, freq in count.items():\n      if num == 1:\n        continue\n      if any(num % squared == 0 for squared in [4, 9, 25]):\n        continue\n      numPrimesMask = 0\n      for i, prime in enumerate(primes):\n        if num % prime == 0:\n          numPrimesMask += 1 << i\n      for primesMask in range(n):\n        if primesMask & numPrimesMask > 0:\n          continue\n        nextPrimesMask = numPrimesMask | primesMask\n        dp[nextPrimesMask] += dp[primesMask] * freq\n        dp[nextPrimesMask] %= kMod\n\n    return (1 << count[1]) * sum(dp[1:]) % kMod\n", "tests": ["def test_numberOfGoodSubsets():\n    solution = Solution()\n    nums = [1, 2, 3]\n    assert solution.numberOfGoodSubsets(nums) == 8", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    nums = [1, 4]\n    assert solution.numberOfGoodSubsets(nums) == 0", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    nums = [1, 2, 5]\n    assert solution.numberOfGoodSubsets(nums) == 11", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    nums = [1, 2, 3, 5]\n    assert solution.numberOfGoodSubsets(nums) == (1 << 1) * sum(solution.dp[1:]) % 1000000007", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    nums = [1, 2, 4]\n    assert solution.numberOfGoodSubsets(nums) == 0", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    nums = [1, 2, 8]\n    assert solution.numberOfGoodSubsets(nums) == (1 << 1) * sum(solution.dp[1:]) % 1000000007", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    nums = [1, 2, 9]\n    assert solution.numberOfGoodSubsets(nums) == (1 << 1) * sum(solution.dp[1:]) % 1000000007", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    nums = [1, 2, 16]\n    assert solution.numberOfGoodSubsets(nums) == (1 << 1) * sum(solution.dp[1:]) % 1000000007", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    nums = [1, 2, 25]\n    assert solution.numberOfGoodSubsets(nums) == (1 << 1) * sum(solution.dp[1:]) % 1000000007", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    nums = [1, 3]\n    assert solution.numberOfGoodSubsets(nums) == (1 << 1) * sum(solution.dp[1:]) % 1000000007", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    nums = [1, 5]\n    assert solution.numberOfGoodSubsets(nums) == (1 << 1) * sum(solution.dp[1:]) % 1000000007", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    nums = [2, 3]\n    assert solution.numberOfGoodSubsets(nums) == (1 << 1) * sum(solution.dp[1:]) % 1000000007", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    nums = [1, 2, 4, 5]\n    assert solution.numberOfGoodSubsets(nums) == (1 << 3) * sum(solution.dp[1:]) % 1000000007", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    nums = [1, 2, 3, 8]\n    assert solution.numberOfGoodSubsets(nums) == (1 << 1) * sum(solution.dp[1:]) % 1000000007", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    nums = [2, 3, 5]\n    assert solution.numberOfGoodSubsets(nums) == (1 << 1) * sum(solution.dp[1:]) % 1000000007", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    nums = [1, 2, 4, 8]\n    assert solution.numberOfGoodSubsets(nums) == (1 << 3) * sum(solution.dp[1:]) % 1000000007", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    nums = [2, 4]\n    assert solution.numberOfGoodSubsets(nums) == (1 << 0) * sum(solution.dp[1:]) % 1000000007", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    nums = [1, 3, 5]\n    assert solution.numberOfGoodSubsets(nums) == (1 << 2) * sum(solution.dp[1:]) % 1000000007", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    nums = [4]\n    assert solution.numberOfGoodSubsets(nums) == 0", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    nums = [1]\n    assert solution.numberOfGoodSubsets(nums) == (1 << 1) * sum(solution.dp[1:]) % 1000000007"]}
{"task_num": 1998, "task_title": "GCD Sort of an Array", "func_name": "gcdSort", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def gcdSort(self, nums: List[int]) -> bool:\n    maxNum = max(nums)\n    minPrimeFactors = self._sieveEratosthenes(maxNum + 1)\n    uf = UnionFind(maxNum + 1)\n\n    for num in nums:\n      for primeFactor in self._getPrimeFactors(num, minPrimeFactors):\n        uf.unionByRank(num, primeFactor)\n\n    for a, b in zip(nums, sorted(nums)):\n      if uf.find(a) != uf.find(b):\n        return False\n\n    return True\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeFactors(self, num: int, minPrimeFactors: List[int]) -> List[int]:\n    primeFactors = []\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      primeFactors.append(divisor)\n      while num % divisor == 0:\n        num //= divisor\n    return primeFactors\n", "tests": ["def test_gcdSort(self):\n    solution = Solution()\n    nums = [10, 7, 5]\n    self.assertTrue(solution.gcdSort(nums))", "def test_gcdSort():\n    solution = Solution()\n    nums = [1, 2, 3]\n    self.assertTrue(solution.gcdSort(nums))", "def test_gcdSort():\n    solution = Solution()\n    nums = [30, 20, 10]\n    self.assertTrue(solution.gcdSort(nums))", "def test_gcdSort():\n    solution = Solution()\n    nums = [2, 4, 5]\n    self.assertFalse(solution.gcdSort(nums))", "def test_gcdSort():\n    solution = Solution()\n    nums = [1, 1]\n    self.assertTrue(solution.gcdSort(nums))", "def test_gcdSort():\n    solution = Solution()\n    nums = [1, 2]\n    self.assertTrue(solution.gcdSort(nums))", "def test_gcdSort():\n    solution = Solution()\n    nums = [1, 3, 5]\n    self.assertTrue(solution.gcdSort(nums))", "def test_gcdSort():\n    solution = Solution()\n    nums = [2 ** 100, 3 ** 50]\n    self.assertTrue(solution.gcdSort(nums))", "def test_gcdSort():\n    solution = Solution()\n    nums = [10 ** 12, 10 ** 13]\n    self.assertTrue(solution.gcdSort(nums))", "def test_gcdSort():\n    solution = Solution()\n    nums = [0]\n    self.assertTrue(solution.gcdSort(nums))", "def test_gcdSort():\n    solution = Solution()\n    nums = [1]\n    self.assertTrue(solution.gcdSort(nums))", "def test_gcdSort():\n    solution = Solution()\n    nums = [1, 4, 16]\n    self.assertTrue(solution.gcdSort(nums))", "def test_gcdSort():\n    solution = Solution()\n    nums = [7, 35]\n    self.assertTrue(solution.gcdSort(nums))", "def test_gcdSort():\n    solution = Solution()\n    nums = [2 ** 100]\n    self.assertTrue(solution.gcdSort(nums))", "def test_gcdSort():\n    solution = Solution()\n    nums = [2 ** 1000, 3 ** 500]\n    self.assertTrue(solution.gcdSort(nums))", "def test_gcdSort():\n    solution = Solution()\n    nums = [2 ** 1000]\n    self.assertTrue(solution.gcdSort(nums))", "def test_gcdSort():\n    solution = Solution()\n    nums = [3 ** 1000]\n    self.assertTrue(solution.gcdSort(nums))", "def test_gcdSort():\n    solution = Solution()\n    nums = [10 ** 1000, 11 ** 1000]\n    self.assertTrue(solution.gcdSort(nums))", "def test_gcdSort():\n    solution = Solution()\n    nums = [1, 2 ** 31 - 1]\n    self.assertTrue(solution.gcdSort(nums))", "def test_gcdSort():\n    solution = Solution()\n    nums = [31, 17]\n    self.assertTrue(solution.gcdSort(nums))"]}
{"task_num": 2019, "task_title": "The Score of Students Solving Math Expression", "func_name": "scoreOfStudents", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nimport operator\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def scoreOfStudents(self, s: str, answers: List[int]) -> int:\n    n = len(s) // 2 + 1\n    ans = 0\n    func = {'+': operator.add, '*': operator.mul}\n    dp = [[set() for j in range(n)] for _ in range(n)]\n\n    for i in range(n):\n      dp[i][i].add(int(s[i * 2]))\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        for k in range(i, j):\n          op = s[k * 2 + 1]\n          for a in dp[i][k]:\n            for b in dp[k + 1][j]:\n              res = func[op](a, b)\n              if res <= 1000:\n                dp[i][j].add(res)\n\n    correctAnswer = eval(s)\n\n    for answer, freq in collections.Counter(answers).items():\n      if answer == correctAnswer:\n        ans += 5 * freq\n      elif answer in dp[0][n - 1]:\n        ans += 2 * freq\n\n    return ans\n", "tests": ["def test_scoreOfStudents(self):\n    s = '3+5*2'\n    answers = [10, -1]\n    self.assertEqual(self.solution.scoreOfStudents(s, answers), 25)", "def test_scoreOfStudents(self):\n    s = '5*3+2'\n    answers = [16, 16, 16]\n    self.assertEqual(self.solution.scoreOfStudents(s, answers), 75)", "def test_scoreOfStudents(self):\n    s = '3+5*2'\n    answers = [10]\n    self.assertEqual(self.solution.scoreOfStudents(s, answers), 7)", "def test_scoreOfStudents(self):\n    s = '3+5*2'\n    answers = [15]\n    self.assertEqual(self.solution.scoreOfStudents(s, answers), 20)", "def test_scoreOfStudents(self):\n    s = '3+5'\n    answers = [0]\n    self.assertEqual(self.solution.scoreOfStudents(s, answers), 0)", "def test_scoreOfStudents(self):\n    s = '3+5*2'\n    answers = [0, 0, 0]\n    self.assertEqual(self.solution.scoreOfStudents(s, answers), 15)", "def test_scoreOfStudents(self):\n    s = '3+5*2'\n    answers = [10]\n    self.assertEqual(self.solution.scoreOfStudents(s, answers), 7)", "def test_scoreOfStudents(self):\n    s = '3*5+2'\n    answers = [10]\n    self.assertEqual(self.solution.scoreOfStudents(s, answers), 0)", "def test_scoreOfStudents(self):\n    s = '5+3*2'\n    answers = [10, 10]\n    self.assertEqual(self.solution.scoreOfStudents(s, answers), 30)", "def test_scoreOfStudents(self):\n    s = ''\n    answers = []\n    self.assertEqual(self.solution.scoreOfStudents(s, answers), 0)", "def test_scoreOfStudents(self):\n    s = '2+3*4'\n    answers = [14]\n    self.assertEqual(self.solution.scoreOfStudents(s, answers), 5)", "def test_scoreOfStudents(self):\n    s = '2+3+4'\n    answers = [9]\n    self.assertEqual(self.solution.scoreOfStudents(s, answers), 5)", "def test_scoreOfStudents(self):\n    s = '2*3*4'\n    answers = [24]\n    self.assertEqual(self.solution.scoreOfStudents(s, answers), 5)", "def test_scoreOfStudents(self):\n    s = '2+3'\n    answers = [5]\n    self.assertEqual(self.solution.scoreOfStudents(s, answers), 5)", "def test_scoreOfStudents(self):\n    s = '1000+2000*3'\n    answers = [7000]\n    self.assertEqual(self.solution.scoreOfStudents(s, answers), 2)", "def test_scoreOfStudents(self):\n    s = '2+3*4'\n    answers = []\n    self.assertEqual(self.solution.scoreOfStudents(s, answers), 0)", "def test_scoreOfStudents(self):\n    s = '2+3*4'\n    answers = [14]\n    self.assertEqual(self.solution.scoreOfStudents(s, answers), 5)", "def test_scoreOfStudents(self):\n    s = '2+3*4'\n    answers = [14]\n    with self.assertRaises(TypeError):\n        self.solution.scoreOfStudents(s, answers)", "def test_scoreOfStudents(self):\n    s = '2+3*4'\n    answers = 'hello'\n    with self.assertRaises(TypeError):\n        self.solution.scoreOfStudents(s, answers)", "def test_scoreOfStudents(self):\n    s = '2+3*4'\n    answers = []\n    self.assertEqual(self.solution.scoreOfStudents(s, answers), 0)"]}
{"task_num": 2030, "task_title": "Smallest K-Length Subsequence With Occurrences of a Letter", "func_name": "smallestSubsequence", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\n    stack = []\n    required = repetition\n    nLetters = s.count(letter)\n\n    for i, c in enumerate(s):\n      while stack and stack[-1] > c  and len(stack) + len(s) - i - 1 >= k and (stack[-1] != letter or nLetters > required):\n        if stack.pop() == letter:\n          required += 1\n      if len(stack) < k:\n        if c == letter:\n          stack.append(c)\n          required -= 1\n        elif k - len(stack) > required:\n          stack.append(c)\n      if c == letter:\n        nLetters -= 1\n\n    return ''.join(stack)\n", "tests": ["def test_smallestSubsequence():\n\n    class Solution:\n\n        def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\n            stack = []\n            required = repetition\n            nLetters = s.count(letter)\n            for (i, c) in enumerate(s):\n                while stack and stack[-1] > c and (len(stack) + len(s) - i - 1 >= k) and (stack[-1] != letter or nLetters > required):\n                    if stack.pop() == letter:\n                        required += 1\n                if len(stack) < k:\n                    if c == letter:\n                        stack.append(c)\n                        required -= 1\n                    elif k - len(stack) > required:\n                        stack.append(c)\n                if c == letter:\n                    nLetters -= 1\n            return ''.join(stack)\n    solution = Solution()\n    s = 'abacdec'\n    k = 3\n    letter = 'a'\n    repetition = 2\n    assert solution.smallestSubsequence(s, k, letter, repetition) == 'abb', 'Test failed: Expected result is not as expected.'", "def test_smallestSubsequence():\n\n    class Solution:\n\n        def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\n            stack = []\n            required = repetition\n            nLetters = s.count(letter)\n            for (i, c) in enumerate(s):\n                while stack and stack[-1] > c and (len(stack) + len(s) - i - 1 >= k) and (stack[-1] != letter or nLetters > required):\n                    if stack.pop() == letter:\n                        required += 1\n                if len(stack) < k:\n                    if c == letter:\n                        stack.append(c)\n                        required -= 1\n                    elif k - len(stack) > required:\n                        stack.append(c)\n                if c == letter:\n                    nLetters -= 1\n            return ''.join(stack)\n    solution = Solution()\n    s = 'abcdefghijklmnopqrstuvwxyz'\n    k = 5\n    letter = 'z'\n    repetition = 2\n    assert solution.smallestSubsequence(s, k, letter, repetition) == 'zzazz', 'Test failed: Expected result is not as expected.'", "def test_smallestSubsequence():\n\n    class Solution:\n\n        def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\n            stack = []\n            required = repetition\n            nLetters = s.count(letter)\n            for (i, c) in enumerate(s):\n                while stack and stack[-1] > c and (len(stack) + len(s) - i - 1 >= k) and (stack[-1] != letter or nLetters > required):\n                    if stack.pop() == letter:\n                        required += 1\n                if len(stack) < k:\n                    if c == letter:\n                        stack.append(c)\n                        required -= 1\n                    elif k - len(stack) > required:\n                        stack.append(c)\n                if c == letter:\n                    nLetters -= 1\n            return ''.join(stack)\n    solution = Solution()\n    s = 'aabbcc'\n    k = 2\n    letter = 'c'\n    repetition = 3\n    assert solution.smallestSubsequence(s, k, letter, repetition) == 'ac', 'Test failed: Expected result is not as expected.'", "def test_smallestSubsequence():\n\n    class Solution:\n\n        def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\n            stack = []\n            required = repetition\n            nLetters = s.count(letter)\n            for (i, c) in enumerate(s):\n                while stack and stack[-1] > c and (len(stack) + len(s) - i - 1 >= k) and (stack[-1] != letter or nLetters > required):\n                    if stack.pop() == letter:\n                        required += 1\n                if len(stack) < k:\n                    if c == letter:\n                        stack.append(c)\n                        required -= 1\n                    elif k - len(stack) > required:\n                        stack.append(c)\n                if c == letter:\n                    nLetters -= 1\n            return ''.join(stack)\n    solution = Solution()\n    s = 'aaaab'\n    k = 3\n    letter = 'a'\n    repetition = 3\n    assert solution.smallestSubsequence(s, k, letter, repetition) == 'aaa', 'Test failed: Expected result is not as expected.'", "def test_smallestSubsequence():\n\n    class Solution:\n\n        def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\n            stack = []\n            required = repetition\n            nLetters = s.count(letter)\n            for (i, c) in enumerate(s):\n                while stack and stack[-1] > c and (len(stack) + len(s) - i - 1 >= k) and (stack[-1] != letter or nLetters > required):\n                    if stack.pop() == letter:\n                        required += 1\n                if len(stack) < k:\n                    if c == letter:\n                        stack.append(c)\n                        required -= 1\n                    elif k - len(stack) > required:\n                        stack.append(c)\n                if c == letter:\n                    nLetters -= 1\n            return ''.join(stack)\n    solution = Solution()\n    s = 'abcdef'\n    k = 3\n    letter = 'e'\n    repetition = 2\n    assert solution.smallestSubsequence(s, k, letter, repetition) == 'de', 'Test failed: Expected result is not as expected.'", "def test_smallestSubsequence():\n\n    class Solution:\n\n        def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\n            stack = []\n            required = repetition\n            nLetters = s.count(letter)\n            for (i, c) in enumerate(s):\n                while stack and stack[-1] > c and (len(stack) + len(s) - i - 1 >= k) and (stack[-1] != letter or nLetters > required):\n                    if stack.pop() == letter:\n                        required += 1\n                if len(stack) < k:\n                    if c == letter:\n                        stack.append(c)\n                        required -= 1\n                    elif k - len(stack) > required:\n                        stack.append(c)\n                if c == letter:\n                    nLetters -= 1\n            return ''.join(stack)\n    solution = Solution()\n    s = 'abcde'\n    k = 2\n    letter = 'b'\n    repetition = 2\n    assert solution.smallestSubsequence(s, k, letter, repetition) == 'bb', 'Test failed: Expected result is not as expected.'", "def test_smallestSubsequence():\n\n    class Solution:\n\n        def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\n            stack = []\n            required = repetition\n            nLetters = s.count(letter)\n            for (i, c) in enumerate(s):\n                while stack and stack[-1] > c and (len(stack) + len(s) - i - 1 >= k) and (stack[-1] != letter or nLetters > required):\n                    if stack.pop() == letter:\n                        required += 1\n                if len(stack) < k:\n                    if c == letter:\n                        stack.append(c)\n                        required -= 1\n                    elif k - len(stack) > required:\n                        stack.append(c)\n                if c == letter:\n                    nLetters -= 1\n            return ''.join(stack)\n    solution = Solution()\n    s = 'abcdefghijklmnopqrstuvwxyz'\n    k = 26\n    letter = 'z'\n    repetition = 10\n    assert solution.smallestSubsequence(s, k, letter, repetition) == 'zzzzzzzzzz', 'Test failed: Expected result is not as expected.'", "def test_smallestSubsequence():\n\n    class Solution:\n\n        def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\n            stack = []\n            required = repetition\n            nLetters = s.count(letter)\n            for (i, c) in enumerate(s):\n                while stack and stack[-1] > c and (len(stack) + len(s) - i - 1 >= k) and (stack[-1] != letter or nLetters > required):\n                    if stack.pop() == letter:\n                        required += 1\n                if len(stack) < k:\n                    if c == letter:\n                        stack.append(c)\n                        required -= 1\n                    elif k - len(stack) > required:\n                        stack.append(c)\n                if c == letter:\n                    nLetters -= 1\n            return ''.join(stack)\n    solution = Solution()\n    s = 'abcdefghij'\n    k = 5\n    letter = 'e'\n    repetition = 2\n    assert solution.smallestSubsequence(s, k, letter, repetition) == 'eebhj', 'Test failed: Expected result is not as expected.'", "def test_smallestSubsequence():\n\n    class Solution:\n\n        def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\n            stack = []\n            required = repetition\n            nLetters = s.count(letter)\n            for (i, c) in enumerate(s):\n                while stack and stack[-1] > c and (len(stack) + len(s) - i - 1 >= k) and (stack[-1] != letter or nLetters > required):\n                    if stack.pop() == letter:\n                        required += 1\n                if len(stack) < k:\n                    if c == letter:\n                        stack.append(c)\n                        required -= 1\n                    elif k - len(stack) > required:\n                        stack.append(c)\n                if c == letter:\n                    nLetters -= 1\n            return ''.join(stack)\n    solution = Solution()\n    s = 'abccdefg'\n    k = 4\n    letter = 'c'\n    repetition = 3\n    assert solution.smallestSubsequence(s, k, letter, repetition) == 'cccc', 'Test failed: Expected result is not as expected.'", "def test_smallestSubsequence():\n\n    class Solution:\n\n        def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\n            stack = []\n            required = repetition\n            nLetters = s.count(letter)\n            for (i, c) in enumerate(s):\n                while stack and stack[-1] > c and (len(stack) + len(s) - i - 1 >= k) and (stack[-1] != letter or nLetters > required):\n                    if stack.pop() == letter:\n                        required += 1\n                if len(stack) < k:\n                    if c == letter:\n                        stack.append(c)\n                        required -= 1\n                    elif k - len(stack) > required:\n                        stack.append(c)\n                if c == letter:\n                    nLetters -= 1\n            return ''.join(stack)\n    solution = Solution()\n    s = 'abcdefghij'\n    k = 6\n    letter = 'f'\n    repetition = 2\n    assert solution.smallestSubsequence(s, k, letter, repetition) == 'ffegih', 'Test failed: Expected result is not as expected.'", "def test_smallestSubsequence():\n\n    class Solution:\n\n        def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\n            stack = []\n            required = repetition\n            nLetters = s.count(letter)\n            for (i, c) in enumerate(s):\n                while stack and stack[-1] > c and (len(stack) + len(s) - i - 1 >= k) and (stack[-1] != letter or nLetters > required):\n                    if stack.pop() == letter:\n                        required += 1\n                if len(stack) < k:\n                    if c == letter:\n                        stack.append(c)\n                        required -= 1\n                    elif k - len(stack) > required:\n                        stack.append(c)\n                if c == letter:\n                    nLetters -= 1\n            return ''.join(stack)\n    solution = Solution()\n    s = 'abcde'\n    k = 5\n    letter = 'b'\n    repetition = 0\n    assert solution.smallestSubsequence(s, k, letter, repetition) == 'abcd', 'Test failed: Expected result is not as expected.'", "def test_smallestSubsequence():\n\n    class Solution:\n\n        def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\n            stack = []\n            required = repetition\n            nLetters = s.count(letter)\n            for (i, c) in enumerate(s):\n                while stack and stack[-1] > c and (len(stack) + len(s) - i - 1 >= k) and (stack[-1] != letter or nLetters > required):\n                    if stack.pop() == letter:\n                        required += 1\n                if len(stack) < k:\n                    if c == letter:\n                        stack.append(c)\n                        required -= 1\n                    elif k - len(stack) > required:\n                        stack.append(c)\n                if c == letter:\n                    nLetters -= 1\n            return ''.join(stack)\n    solution = Solution()\n    s = 'abccdefg'\n    k = 4\n    letter = 'c'\n    repetition = 2\n    assert solution.smallestSubsequence(s, k, letter, repetition) == 'bccc', 'Test failed: Expected result is not as expected.'", "def test_smallestSubsequence():\n\n    class Solution:\n\n        def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\n            stack = []\n            required = repetition\n            nLetters = s.count(letter)\n            for (i, c) in enumerate(s):\n                while stack and stack[-1] > c and (len(stack) + len(s) - i - 1 >= k) and (stack[-1] != letter or nLetters > required):\n                    if stack.pop() == letter:\n                        required += 1\n                if len(stack) < k:\n                    if c == letter:\n                        stack.append(c)\n                        required -= 1\n                    elif k - len(stack) > required:\n                        stack.append(c)\n                if c == letter:\n                    nLetters -= 1\n            return ''.join(stack)\n    solution = Solution()\n    s = 'abccdefg'\n    k = 5\n    letter = 'c'\n    repetition = 3\n    assert solution.smallestSubsequence(s, k, letter, repetition) == 'cccc', 'Test failed: Expected result is not as expected.'", "def test_smallestSubsequence():\n\n    class Solution:\n\n        def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\n            stack = []\n            required = repetition\n            nLetters = s.count(letter)\n            for (i, c) in enumerate(s):\n                while stack and stack[-1] > c and (len(stack) + len(s) - i - 1 >= k) and (stack[-1] != letter or nLetters > required):\n                    if stack.pop() == letter:\n                        required += 1\n                if len(stack) < k:\n                    if c == letter:\n                        stack.append(c)\n                        required -= 1\n                    elif k - len(stack) > required:\n                        stack.append(c)\n                if c == letter:\n                    nLetters -= 1\n            return ''.join(stack)\n    solution = Solution()\n    s = 'abcdefghij'\n    k = 7\n    letter = 'f'\n    repetition = 2\n    assert solution.smallestSubsequence(s, k, letter, repetition) == 'feeegh', 'Test failed: Expected result is not as expected.'", "def test_smallestSubsequence():\n\n    class Solution:\n\n        def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\n            stack = []\n            required = repetition\n            nLetters = s.count(letter)\n            for (i, c) in enumerate(s):\n                while stack and stack[-1] > c and (len(stack) + len(s) - i - 1 >= k) and (stack[-1] != letter or nLetters > required):\n                    if stack.pop() == letter:\n                        required += 1\n                if len(stack) < k:\n                    if c == letter:\n                        stack.append(c)\n                        required -= 1\n                    elif k - len(stack) > required:\n                        stack.append(c)\n                if c == letter:\n                    nLetters -= 1\n            return ''.join(stack)\n    solution = Solution()\n    s = 'abccdefghij'\n    k = 8\n    letter = 'f'\n    repetition = 3\n    assert solution.smallestSubsequence(s, k, letter, repetition) == 'feffgih', 'Test failed: Expected result is not as expected.'", "def test_smallestSubsequence():\n\n    class Solution:\n\n        def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\n            stack = []\n            required = repetition\n            nLetters = s.count(letter)\n            for (i, c) in enumerate(s):\n                while stack and stack[-1] > c and (len(stack) + len(s) - i - 1 >= k) and (stack[-1] != letter or nLetters > required):\n                    if stack.pop() == letter:\n                        required += 1\n                if len(stack) < k:\n                    if c == letter:\n                        stack.append(c)\n                        required -= 1\n                    elif k - len(stack) > required:\n                        stack.append(c)\n                if c == letter:\n                    nLetters -= 1\n            return ''.join(stack)\n    solution = Solution()\n    s = 'abcdefghij'\n    k = 9\n    letter = 'f'\n    repetition = 4\n    assert solution.smallestSubsequence(s, k, letter, repetition) == 'ffeeeghij', 'Test failed: Expected result is not as expected.'", "def test_smallestSubsequence():\n\n    class Solution:\n\n        def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\n            stack = []\n            required = repetition\n            nLetters = s.count(letter)\n            for (i, c) in enumerate(s):\n                while stack and stack[-1] > c and (len(stack) + len(s) - i - 1 >= k) and (stack[-1] != letter or nLetters > required):\n                    if stack.pop() == letter:\n                        required += 1\n                if len(stack) < k:\n                    if c == letter:\n                        stack.append(c)\n                        required -= 1\n                    elif k - len(stack) > required:\n                        stack.append(c)\n                if c == letter:\n                    nLetters -= 1\n            return ''.join(stack)\n    solution = Solution()\n    s = 'abcdefghij'\n    k = 10\n    letter = 'f'\n    repetition = 5\n    assert solution.smallestSubsequence(s, k, letter, repetition) == 'fffeeghij', 'Test failed: Expected result is not as expected.'", "def test_smallestSubsequence():\n\n    class Solution:\n\n        def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\n            stack = []\n            required = repetition\n            nLetters = s.count(letter)\n            for (i, c) in enumerate(s):\n                while stack and stack[-1] > c and (len(stack) + len(s) - i - 1 >= k) and (stack[-1] != letter or nLetters > required):\n                    if stack.pop() == letter:\n                        required += 1\n                if len(stack) < k:\n                    if c == letter:\n                        stack.append(c)\n                        required -= 1\n                    elif k - len(stack) > required:\n                        stack.append(c)\n                if c == letter:\n                    nLetters -= 1\n            return ''.join(stack)\n    solution = Solution()\n    s = 'abcdefghij'\n    k = 11\n    letter = 'f'\n    repetition = 6\n    assert solution.smallestSubsequence(s, k, letter, repetition) == 'fffffffeeghij', 'Test failed: Expected result is not as expected.'", "def test_smallestSubsequence():\n\n    class Solution:\n\n        def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\n            stack = []\n            required = repetition\n            nLetters = s.count(letter)\n            for (i, c) in enumerate(s):\n                while stack and stack[-1] > c and (len(stack) + len(s) - i - 1 >= k) and (stack[-1] != letter or nLetters > required):\n                    if stack.pop() == letter:\n                        required += 1\n                if len(stack) < k:\n                    if c == letter:\n                        stack.append(c)\n                        required -= 1\n                    elif k - len(stack) > required:\n                        stack.append(c)\n                if c == letter:\n                    nLetters -= 1\n            return ''.join(stack)\n    solution = Solution()\n    s = 'abcdefghij'\n    k = 12\n    letter = 'f'\n    repetition = 7\n    assert solution.smallestSubsequence(s, k, letter, repetition) == 'fffffffffeeghij', 'Test failed: Expected result is not as expected.'", "def test_smallestSubsequence():\n\n    class Solution:\n\n        def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\n            stack = []\n            required = repetition\n            nLetters = s.count(letter)\n            for (i, c) in enumerate(s):\n                while stack and stack[-1] > c and (len(stack) + len(s) - i - 1 >= k) and (stack[-1] != letter or nLetters > required):\n                    if stack.pop() == letter:\n                        required += 1\n                if len(stack) < k:\n                    if c == letter:\n                        stack.append(c)\n                        required -= 1\n                    elif k - len(stack) > required:\n                        stack.append(c)\n                if c == letter:\n                    nLetters -= 1\n            return ''.join(stack)\n    solution = Solution()\n    s = 'abcdefghij'\n    k = 13\n    letter = 'f'\n    repetition = 8\n    assert solution.smallestSubsequence(s, k, letter, repetition) == 'fffffffffffffeeghij', 'Test failed: Expected result is not as expected.'"]}
{"task_num": 2040, "task_title": "Kth Smallest Product of Two Sorted Arrays", "func_name": "kthSmallestProduct", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int) -> int:\n    A1 = [-num for num in nums1 if num < 0][::-1]\n    A2 = [num for num in nums1 if num >= 0]\n    B1 = [-num for num in nums2 if num < 0][::-1]\n    B2 = [num for num in nums2 if num >= 0]\n\n    negCount = len(A1) * len(B2) + len(A2) * len(B1)\n\n    if k > negCount:\n      k -= negCount\n      sign = 1\n    else:\n      k = negCount - k + 1\n      sign = -1\n      B1, B2 = B2, B1\n\n    def numProductNoGreaterThan(A: List[int], B: List[int], m: int) -> int:\n      ans = 0\n      j = len(B) - 1\n      for i in range(len(A)):\n        while j >= 0 and A[i] * B[j] > m:\n          j -= 1\n        ans += j + 1\n      return ans\n\n    l = 0\n    r = 10**10\n\n    while l < r:\n      m = (l + r) // 2\n      if numProductNoGreaterThan(A1, B1, m) + numProductNoGreaterThan(A2, B2, m) >= k:\n        r = m\n      else:\n        l = m + 1\n\n    return sign * l\n", "tests": ["def test_kthSmallestProduct():\n\n    class TestSolution(unittest.TestCase):\n\n        def test_input(self):\n            nums1 = [1, 2]\n            nums2 = [-1, 3]\n            k = 4\n            self.assertEqual(solution.kthSmallestProduct(nums1, nums2, k), -9)", "def test_kthSmallestProduct():\n\n    class TestSolution(unittest.TestCase):\n\n        def test_same_length_arrays(self):\n            nums1 = [-3, -2]\n            nums2 = [4, 5]\n            k = 6\n            self.assertEqual(solution.kthSmallestProduct(nums1, nums2, k), 15)", "def test_kthSmallestProduct():\n\n    class TestSolution(unittest.TestCase):\n\n        def test_k_exceeds_negative_count(self):\n            nums1 = [1]\n            nums2 = [-2, -3]\n            k = 8\n            self.assertEqual(solution.kthSmallestProduct(nums1, nums2, k), 4)", "def test_kthSmallestProduct():\n\n    class TestSolution(unittest.TestCase):\n\n        def test_large_arrays(self):\n            nums1 = [i for i in range(-10000, 0)]\n            nums2 = [-i for i in range(10000)]\n            k = 9999\n            self.assertEqual(solution.kthSmallestProduct(nums1, nums2, k), -499950000)", "def test_kthSmallestProduct():\n\n    class TestSolution(unittest.TestCase):\n\n        def test_k_equal_to_zero(self):\n            nums1 = [1]\n            nums2 = [-2]\n            with self.assertRaises(ValueError):\n                solution.kthSmallestProduct(nums1, nums2, 0)", "def test_kthSmallestProduct():\n\n    class TestSolution(unittest.TestCase):\n\n        def test_input_with_zeros(self):\n            nums1 = [0, 2]\n            nums2 = [-1, 3]\n            k = 4\n            self.assertEqual(solution.kthSmallestProduct(nums1, nums2, k), -9)", "def test_kthSmallestProduct():\n\n    class TestSolution(unittest.TestCase):\n\n        def test_input_with_single_array(self):\n            nums1 = [1, 2]\n            nums2 = []\n            k = 4\n            with self.assertRaises(IndexError):\n                solution.kthSmallestProduct(nums1, nums2, k)", "def test_kthSmallestProduct():\n\n    class TestSolution(unittest.TestCase):\n\n        def test_input_with_negative_zero(self):\n            nums1 = [-0]\n            nums2 = [4, 5]\n            k = 6\n            self.assertEqual(solution.kthSmallestProduct(nums1, nums2, k), 20)", "def test_kthSmallestProduct():\n\n    class TestSolution(unittest.TestCase):\n\n        def test_input_with_same_numbers(self):\n            nums1 = [4]\n            nums2 = [5]\n            k = 6\n            self.assertEqual(solution.kthSmallestProduct(nums1, nums2, k), -20)", "def test_kthSmallestProduct():\n\n    class TestSolution(unittest.TestCase):\n\n        def test_large_k_exceeds_max_value(self):\n            nums1 = [1]\n            nums2 = [-2]\n            k = 10 ** 20\n            with self.assertRaises(OverflowError):\n                solution.kthSmallestProduct(nums1, nums2, k)", "def test_kthSmallestProduct():\n\n    class TestSolution(unittest.TestCase):\n\n        def test_input_with_empty_arrays(self):\n            nums1 = []\n            nums2 = [4, 5]\n            k = 6\n            with self.assertRaises(IndexError):\n                solution.kthSmallestProduct(nums1, nums2, k)", "def test_kthSmallestProduct():\n\n    class TestSolution(unittest.TestCase):\n\n        def test_input_with_all_positive_numbers(self):\n            nums1 = [1, 2]\n            nums2 = [4, 5]\n            k = 6\n            self.assertEqual(solution.kthSmallestProduct(nums1, nums2, k), 20)", "def test_kthSmallestProduct():\n\n    class TestSolution(unittest.TestCase):\n\n        def test_input_with_all_negative_numbers(self):\n            nums1 = [-1, -2]\n            nums2 = [-4, -5]\n            k = 6\n            self.assertEqual(solution.kthSmallestProduct(nums1, nums2, k), 20)", "def test_kthSmallestProduct():\n\n    class TestSolution(unittest.TestCase):\n\n        def test_input_with_large_numbers(self):\n            nums1 = [10 ** 15]\n            nums2 = [-10 ** 15]\n            k = 6\n            self.assertEqual(solution.kthSmallestProduct(nums1, nums2, k), -10 ** 30)", "def test_kthSmallestProduct():\n\n    class TestSolution(unittest.TestCase):\n\n        def test_input_with_zero_length_arrays(self):\n            nums1 = []\n            nums2 = [4, 5]\n            k = 6\n            with self.assertRaises(ZeroDivisionError):\n                solution.kthSmallestProduct(nums1, nums2, k)", "def test_kthSmallestProduct():\n\n    class TestSolution(unittest.TestCase):\n\n        def test_input_with_negative_zero_and_positive_numbers(self):\n            nums1 = [-0]\n            nums2 = [4, 5]\n            k = 6\n            self.assertEqual(solution.kthSmallestProduct(nums1, nums2, k), -20)", "def test_kthSmallestProduct():\n\n    class TestSolution(unittest.TestCase):\n\n        def test_input_with_duplicates_in_first_array(self):\n            nums1 = [4, 4]\n            nums2 = [-5, -6]\n            k = 6\n            self.assertEqual(solution.kthSmallestProduct(nums1, nums2, k), -16)", "def test_kthSmallestProduct():\n\n    class TestSolution(unittest.TestCase):\n\n        def test_input_with_duplicates_in_second_array(self):\n            nums1 = [4]\n            nums2 = [-5, -5]\n            k = 6\n            self.assertEqual(solution.kthSmallestProduct(nums1, nums2, k), -25)", "def test_kthSmallestProduct():\n\n    class TestSolution(unittest.TestCase):\n\n        def test_input_with_large_arrays_and_k(self):\n            nums1 = [i for i in range(-10 ** 8, 0)]\n            nums2 = [-i for i in range(10 ** 8)]\n            k = 10 ** 12\n            self.assertEqual(solution.kthSmallestProduct(nums1, nums2, k), -499950000)", "def test_kthSmallestProduct():\n\n    class TestSolution(unittest.TestCase):\n\n        def test_input_with_non_integer_numbers(self):\n            nums1 = [1.5]\n            nums2 = [-2.5]\n            k = 4\n            with self.assertRaises(TypeError):\n                solution.kthSmallestProduct(nums1, nums2, k)"]}
{"task_num": 2045, "task_title": "Second Minimum Time to Reach Destination", "func_name": "secondMinimum", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\n    graph = [[] for _ in range(n + 1)]\n    q = collections.deque([(1, 0)])\n    minTime = [[math.inf] * 2 for _ in range(n + 1)]\n    minTime[1][0] = 0\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    while q:\n      i, prevTime = q.popleft()\n\n      numChangeSignal = prevTime // change\n      waitTime = change - (prevTime % change) if numChangeSignal & 1 else 0\n      newTime = prevTime + waitTime + time\n      for j in graph[i]:\n        if newTime < minTime[j][0]:\n          minTime[j][0] = newTime\n          q.append((j, newTime))\n        elif minTime[j][0] < newTime < minTime[j][1]:\n          if j == n:\n            return newTime\n          minTime[j][1] = newTime\n          q.append((j, newTime))\n", "tests": ["def test_secondMinimum(self):\n    n = 3\n    edges = [[1, 2], [1, 3]]\n    time = 3\n    change = 5\n    self.assertEqual(self.solution.secondMinimum(n, edges, time, change), 9)", "def test_secondMinimum(self):\n    n = 4\n    edges = [[1, 2], [1, 3], [2, 3], [2, 4]]\n    time = 5\n    change = 7\n    self.assertEqual(self.solution.secondMinimum(n, edges, time, change), 15)", "def test_secondMinimum(self):\n    n = 5\n    edges = [[1, 2], [1, 3], [2, 4], [3, 5]]\n    time = 10\n    change = 11\n    self.assertEqual(self.solution.secondMinimum(n, edges, time, change), 21)", "def test_secondMinimum(self):\n    n = 1\n    edges = []\n    time = 10\n    change = 11\n    self.assertEqual(self.solution.secondMinimum(n, edges, time, change), 0)", "def test_secondMinimum(self):\n    n = 6\n    edges = [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6]]\n    time = 10\n    change = 100\n    self.assertEqual(self.solution.secondMinimum(n, edges, time, change), 30)", "def test_secondMinimum(self):\n    n = 2\n    edges = [[1, 2]]\n    time = 10\n    change = 1000\n    self.assertEqual(self.solution.secondMinimum(n, edges, time, change), 20)", "def test_secondMinimum(self):\n    n = 1\n    edges = [[1, 2]]\n    time = 10\n    change = 11\n    self.assertEqual(self.solution.secondMinimum(n, edges, time, change), 20)", "def test_secondMinimum(self):\n    n = 7\n    edges = [[1, 2], [1, 3], [2, 4], [2, 5], [3, 6]]\n    time = 20\n    change = 10\n    self.assertEqual(self.solution.secondMinimum(n, edges, time, change), 50)", "def test_secondMinimum(self):\n    n = 8\n    edges = [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7]]\n    time = 50\n    change = 20\n    self.assertEqual(self.solution.secondMinimum(n, edges, time, change), 100)", "def test_secondMinimum(self):\n    n = 9\n    edges = [[1, 2], [1, 3], [2, 4], [2, 5], [3, 6], [3, 7], [4, 8]]\n    time = 100\n    change = 50\n    self.assertEqual(self.solution.secondMinimum(n, edges, time, change), 150)", "def test_secondMinimum(self):\n    n = 10\n    edges = [[1, 2], [1, 3], [2, 4], [2, 5], [3, 6], [3, 7], [4, 8], [4, 9]]\n    time = 200\n    change = 100\n    self.assertEqual(self.solution.secondMinimum(n, edges, time, change), 300)", "def test_secondMinimum(self):\n    n = 11\n    edges = [[1, 2], [1, 3], [2, 4], [2, 5], [3, 6], [3, 7], [4, 8], [4, 9], [5, 10]]\n    time = 500\n    change = 200\n    self.assertEqual(self.solution.secondMinimum(n, edges, time, change), 1000)", "def test_secondMinimum(self):\n    n = 12\n    edges = [[1, 2], [1, 3], [2, 4], [2, 5], [3, 6], [3, 7], [4, 8], [4, 9], [5, 10], [5, 11]]\n    time = 1000\n    change = 500\n    self.assertEqual(self.solution.secondMinimum(n, edges, time, change), 1500)", "def test_secondMinimum(self):\n    n = 13\n    edges = [[1, 2], [1, 3], [2, 4], [2, 5], [3, 6], [3, 7], [4, 8], [4, 9], [5, 10], [5, 11], [6, 12]]\n    time = 2000\n    change = 1000\n    self.assertEqual(self.solution.secondMinimum(n, edges, time, change), 3000)", "def test_secondMinimum(self):\n    n = 1\n    edges = []\n    time = 1\n    change = 1000000\n    self.assertEqual(self.solution.secondMinimum(n, edges, time, change), 1)", "def test_secondMinimum(self):\n    n = 1000000\n    edges = [[i, j] for i in range(1, n) for j in range(i + 1, n)]\n    time = 1\n    change = 2\n    self.assertEqual(self.solution.secondMinimum(n, edges, time, change), 2000000)", "def test_secondMinimum(self):\n    n = 10000000\n    edges = [[i, j] for i in range(1, n) for j in range(i + 1, n)]\n    time = 10\n    change = 100\n    self.assertEqual(self.solution.secondMinimum(n, edges, time, change), 20000000)", "def test_secondMinimum(self):\n    n = 100000000\n    edges = [[i, j] for i in range(1, n) for j in range(i + 1, n)]\n    time = 10\n    change = 1000\n    self.assertEqual(self.solution.secondMinimum(n, edges, time, change), 200000000)", "def test_secondMinimum(self):\n    n = 1000000000\n    edges = [[i, j] for i in range(1, n) for j in range(i + 1, n)]\n    time = 10\n    change = 10000\n    self.assertEqual(self.solution.secondMinimum(n, edges, time, change), 2000000000)", "def test_secondMinimum(self):\n    n = 10000000000\n    edges = [[i, j] for i in range(1, n) for j in range(i + 1, n)]\n    time = 10\n    change = 100000\n    self.assertEqual(self.solution.secondMinimum(n, edges, time, change), 20000000000)"]}
{"task_num": 2059, "task_title": "Minimum Operations to Convert Number", "func_name": "minimumOperations", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\n    ans = 0\n    q = collections.deque([start])\n    seen = {start}\n\n    while q:\n      ans += 1\n      for _ in range(len(q)):\n        x = q.popleft()\n        for num in nums:\n          for res in (x + num, x - num, x ^ num):\n            if res == goal:\n              return ans\n            if res < 0 or res > 1000 or res in seen:\n              continue\n            seen.add(res)\n            q.append(res)\n\n    return -1\n", "tests": ["def test_minimumOperations():\n    solution = Solution()\n    nums = [3, 5]\n    start = 0\n    goal = 7\n    assert solution.minimumOperations(nums, start, goal) == 2", "def test_minimumOperations():\n    solution = Solution()\n    nums = [10, 20]\n    start = 1000\n    goal = 2000\n    assert solution.minimumOperations(nums, start, goal) == -1", "def test_minimumOperations():\n    solution = Solution()\n    nums = [2, 4]\n    start = 12\n    goal = 0\n    assert solution.minimumOperations(nums, start, goal) == 3", "def test_minimumOperations():\n    solution = Solution()\n    nums = [1, 2, 3]\n    start = 1000\n    goal = -1000\n    assert solution.minimumOperations(nums, start, goal) == 7", "def test_minimumOperations():\n    solution = Solution()\n    nums = [5]\n    start = 8\n    goal = 9\n    assert solution.minimumOperations(nums, start, goal) == 2", "def test_minimumOperations():\n    solution = Solution()\n    nums = [100]\n    start = -1\n    goal = 0\n    assert solution.minimumOperations(nums, start, goal) == -1", "def test_minimumOperations():\n    solution = Solution()\n    nums = []\n    start = 0\n    goal = 10\n    assert solution.minimumOperations(nums, start, goal) == -1", "def test_minimumOperations():\n    solution = Solution()\n    nums = [5]\n    start = 0\n    goal = 1001\n    assert solution.minimumOperations(nums, start, goal) == -1", "def test_minimumOperations():\n    solution = Solution()\n    nums = [7]\n    start = 0\n    goal = 1000\n    assert solution.minimumOperations(nums, start, goal) == 1", "def test_minimumOperations():\n    solution = Solution()\n    nums = [2]\n    start = 1000\n    goal = 1\n    assert solution.minimumOperations(nums, start, goal) == 3", "def test_minimumOperations():\n    solution = Solution()\n    nums = [8]\n    start = -1\n    goal = 4\n    assert solution.minimumOperations(nums, start, goal) == 5", "def test_minimumOperations():\n    solution = Solution()\n    nums = [1]\n    start = 0\n    goal = 2\n    assert solution.minimumOperations(nums, start, goal) == -1", "def test_minimumOperations():\n    solution = Solution()\n    nums = [2]\n    start = 1000\n    goal = -1\n    assert solution.minimumOperations(nums, start, goal) == -1", "def test_minimumOperations():\n    solution = Solution()\n    nums = []\n    start = 0\n    goal = 1001\n    assert solution.minimumOperations(nums, start, goal) == -1", "def test_minimumOperations():\n    solution = Solution()\n    nums = [1000]\n    start = 0\n    goal = -1\n    assert solution.minimumOperations(nums, start, goal) == -1", "def test_minimumOperations():\n    solution = Solution()\n    nums = [3]\n    start = 1000\n    goal = 2\n    assert solution.minimumOperations(nums, start, goal) == -1", "def test_minimumOperations():\n    solution = Solution()\n    nums = []\n    start = 0\n    goal = -1\n    assert solution.minimumOperations(nums, start, goal) == -1", "def test_minimumOperations():\n    solution = Solution()\n    nums = [2]\n    start = 1000\n    goal = 1\n    assert solution.minimumOperations(nums, start, goal) == 3", "def test_minimumOperations():\n    solution = Solution()\n    nums = [1]\n    start = 0\n    goal = 1000\n    assert solution.minimumOperations(nums, start, goal) == -1", "def test_minimumOperations():\n    solution = Solution()\n    nums = [5]\n    start = 0\n    goal = 1\n    assert solution.minimumOperations(nums, start, goal) == -1"]}
{"task_num": 2076, "task_title": "Process Restricted Friend Requests", "func_name": "friendRequests", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\n    ans = []\n    uf = UnionFind(n)\n\n    for u, v in requests:\n      pu = uf.find(u)\n      pv = uf.find(v)\n      isValid = True\n      if pu != pv:\n        for x, y in restrictions:\n          px = uf.find(x)\n          py = uf.find(y)\n          if (pu, pv) in [(px, py), (py, px)]:\n            isValid = False\n            break\n      ans.append(isValid)\n      if isValid:\n        uf.unionByRank(pu, pv)\n\n    return ans\n", "tests": ["def test_friendRequests():\n    solution = Solution()\n    n = 5\n    restrictions = [[0, 1], [2, 3]]\n    requests = [[4, 0], [3, 1], [3, 4]]\n    result = [True, False, True]\n    assert solution.friendRequests(n, restrictions, requests) == result", "def test_friendRequests():\n    solution = Solution()\n    n = 4\n    restrictions = [[0, 1], [2, 3]]\n    requests = [[2, 0], [3, 2]]\n    result = [False]\n    assert solution.friendRequests(n, restrictions, requests) == result", "def test_friendRequests():\n    solution = Solution()\n    n = 3\n    restrictions = []\n    requests = [[0, 1], [1, 2]]\n    result = [True]\n    assert solution.friendRequests(n, restrictions, requests) == result", "def test_friendRequests():\n    solution = Solution()\n    n = 5\n    restrictions = [[0, 2], [1, 3]]\n    requests = [[4, 0], [2, 4]]\n    result = [True, False]\n    assert solution.friendRequests(n, restrictions, requests) == result", "def test_friendRequests():\n    solution = Solution()\n    n = 6\n    restrictions = [[0, 1], [2, 3], [4, 5]]\n    requests = [[0, 2], [4, 3], [0, 5]]\n    result = [True, False, True]\n    assert solution.friendRequests(n, restrictions, requests) == result", "def test_friendRequests():\n    solution = Solution()\n    n = 4\n    restrictions = [[0, 2]]\n    requests = [[1, 3], [1, 0]]\n    result = [False]\n    assert solution.friendRequests(n, restrictions, requests) == result", "def test_friendRequests():\n    solution = Solution()\n    n = 2\n    restrictions = []\n    requests = [[0, 1]]\n    result = [True]\n    assert solution.friendRequests(n, restrictions, requests) == result", "def test_friendRequests():\n    solution = Solution()\n    n = 10\n    restrictions = [[0, 1], [2, 3], [4, 5], [6, 7]]\n    requests = [[8, 9], [6, 9], [7, 8]]\n    result = [False, True, False]\n    assert solution.friendRequests(n, restrictions, requests) == result", "def test_friendRequests():\n    solution = Solution()\n    n = 8\n    restrictions = [[0, 1], [2, 3], [4, 5]]\n    requests = [[6, 7], [0, 7], [2, 6]]\n    result = [False, True, False]\n    assert solution.friendRequests(n, restrictions, requests) == result", "def test_friendRequests():\n    solution = Solution()\n    n = 9\n    restrictions = [[0, 1], [2, 3], [4, 5]]\n    requests = [[6, 7], [8, 0], [2, 6]]\n    result = [False, True, False]\n    assert solution.friendRequests(n, restrictions, requests) == result", "def test_friendRequests():\n    solution = Solution()\n    n = 1\n    restrictions = []\n    requests = [[0, 0]]\n    result = [True]\n    assert solution.friendRequests(n, restrictions, requests) == result", "def test_friendRequests():\n    solution = Solution()\n    n = 4\n    restrictions = [[0, 1], [2, 3]]\n    requests = [[0, 2], [2, 0]]\n    result = [False]\n    assert solution.friendRequests(n, restrictions, requests) == result", "def test_friendRequests():\n    solution = Solution()\n    n = 6\n    restrictions = [[0, 1], [2, 3]]\n    requests = [[4, 5], [0, 5], [2, 4]]\n    result = [True, False, True]\n    assert solution.friendRequests(n, restrictions, requests) == result", "def test_friendRequests():\n    solution = Solution()\n    n = 5\n    restrictions = [[0, 1], [2, 3]]\n    requests = [[4, 0], [3, 2], [4, 1]]\n    result = [True, False, True]\n    assert solution.friendRequests(n, restrictions, requests) == result", "def test_friendRequests():\n    solution = Solution()\n    n = 8\n    restrictions = [[0, 1], [2, 3]]\n    requests = [[4, 5], [6, 7], [0, 7]]\n    result = [True, False, True]\n    assert solution.friendRequests(n, restrictions, requests) == result", "def test_friendRequests():\n    solution = Solution()\n    n = 3\n    restrictions = [[0, 1]]\n    requests = [[2, 0], [1, 2]]\n    result = [False]\n    assert solution.friendRequests(n, restrictions, requests) == result", "def test_friendRequests():\n    solution = Solution()\n    n = 9\n    restrictions = []\n    requests = [[0, 1], [2, 3], [4, 5], [6, 7]]\n    result = [True, True, True, True]\n    assert solution.friendRequests(n, restrictions, requests) == result", "def test_friendRequests():\n    solution = Solution()\n    n = 7\n    restrictions = [[0, 1], [2, 3]]\n    requests = [[4, 5], [6, 0], [2, 6]]\n    result = [True, True, False]\n    assert solution.friendRequests(n, restrictions, requests) == result", "def test_friendRequests():\n    solution = Solution()\n    n = 10\n    restrictions = [[0, 1], [2, 3]]\n    requests = [[4, 5], [6, 7], [8, 9], [0, 7]]\n    result = [True, True, False, True]\n    assert solution.friendRequests(n, restrictions, requests) == result", "def test_friendRequests():\n    solution = Solution()\n    n = 11\n    restrictions = [[0, 1], [2, 3]]\n    requests = [[4, 5], [6, 7], [8, 9], [10, 0], [2, 10]]\n    result = [True, True, False, True, False]\n    assert solution.friendRequests(n, restrictions, requests) == result"]}
{"task_num": 2086, "task_title": "Minimum Number of Food Buckets to Feed the Hamsters", "func_name": "minimumBuckets", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumBuckets(self, street: str) -> int:\n    A = list(street)\n\n    for i, c in enumerate(A):\n      if c == 'H':\n        if i > 0 and A[i - 1] == 'B':\n          continue\n        if i + 1 < len(A) and A[i + 1] == '.':\n          A[i + 1] = 'B'\n        elif i > 0 and A[i - 1] == '.':\n          A[i - 1] = 'B'\n        else:\n          return -1\n\n    return A.count('B')\n", "tests": ["def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('H.H') == 2, 'Test case for two consecutive Hs'", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('...H') == -1, 'Test case with H at end of street'", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('HH') == 1, 'Test case with two consecutive Hs'", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('...H...') == -1, 'Test case with H in middle of street'", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('.H.H') == 2, 'Test case with multiple empty spaces'", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('.H..') == 1, 'Test case with one empty space'", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('...') == -1, 'Test case with empty street'", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('H.') == 1, 'Test case with one empty space between Hs'", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('...H.H') == 3, 'Test case with multiple Hs separated by empty spaces'", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('.H.H.H') == 3, 'Test case with multiple Hs separated by empty spaces'", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('...H.H.H') == -1, 'Test case with multiple Hs separated by empty spaces'", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('H...') == 1, 'Test case with H at start of street'", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('H..H') == 2, 'Test case with two Hs separated by empty spaces'", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('...H.H..') == -1, 'Test case with Hs separated by multiple empty spaces'", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('H...H') == -1, 'Test case with two Hs separated by multiple empty spaces'", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('.H.H.') == 2, 'Test case with Hs separated by empty spaces at both ends'", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('H.H.') == 2, 'Test case with Hs separated by empty spaces in the middle'", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('.H.H') == 2, 'Test case with two Hs separated by empty spaces at both ends'", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('.H...') == 1, 'Test case with H in middle of street'", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('...H.H') == -1, 'Test case with Hs separated by empty spaces at both ends'"]}
{"task_num": 2092, "task_title": "Find All People With Secret", "func_name": "findAllPeople", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def connected(self, u: int, v: int) -> bool:\n    return self._find(self.id[u]) == self._find(self.id[v])\n\n  def reset(self, u: int) -> None:\n    self.id[u] = u\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\n    uf = UnionFind(n)\n    timeToPairs = collections.defaultdict(list)\n\n    uf.unionByRank(0, firstPerson)\n\n    for x, y, time in meetings:\n      timeToPairs[time].append((x, y))\n\n    for _, pairs in sorted(timeToPairs.items(), key=lambda x: x[0]):\n      peopleUnioned = set()\n      for x, y in pairs:\n        uf.unionByRank(x, y)\n        peopleUnioned.add(x)\n        peopleUnioned.add(y)\n      for person in peopleUnioned:\n        if not uf.connected(person, 0):\n          uf.reset(person)\n\n    res=[]\n    for i in range(n):\n      if uf.connected(i, 0):\n        res.append(i)\n    return res\n", "tests": ["def test_findAllPeople(self):\n\n    class SolutionWrapper(Solution):\n\n        def __init__(self):\n            pass\n\n        def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\n            self.n = n\n            self.meetings = meetings\n            self.firstPerson = firstPerson\n            return super().findAllPeople(n, meetings, firstPerson)\n    solution = SolutionWrapper()\n    solution.findAllPeople(4, [[1, 2, 1], [2, 0, 3]], 1)", "def test_findAllPeople(self):\n\n    class SolutionWrapper(Solution):\n\n        def __init__(self):\n            pass\n\n        def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\n            self.n = n\n            self.meetings = meetings\n            self.firstPerson = firstPerson\n            return super().findAllPeople(n, meetings, firstPerson)\n    solution = SolutionWrapper()\n    result = solution.findAllPeople(1, [[0, 0, 2]], 0)", "def test_findAllPeople(self):\n\n    class SolutionWrapper(Solution):\n\n        def __init__(self):\n            pass\n\n        def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\n            self.n = n\n            self.meetings = meetings\n            self.firstPerson = firstPerson\n            return super().findAllPeople(n, meetings, firstPerson)\n    solution = SolutionWrapper()\n    result = solution.findAllPeople(3, [[1, 2, 0], [2, 0, 4]], 1)", "def test_findAllPeople(self):\n\n    class SolutionWrapper(Solution):\n\n        def __init__(self):\n            pass\n\n        def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\n            self.n = n\n            self.meetings = meetings\n            self.firstPerson = firstPerson\n            return super().findAllPeople(n, meetings, firstPerson)\n    solution = SolutionWrapper()\n    result = solution.findAllPeople(5, [[0, 2, 1], [3, 4, 3]], 1)", "def test_findAllPeople(self):\n\n    class SolutionWrapper(Solution):\n\n        def __init__(self):\n            pass\n\n        def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\n            self.n = n\n            self.meetings = meetings\n            self.firstPerson = firstPerson\n            return super().findAllPeople(n, meetings, firstPerson)\n    solution = SolutionWrapper()\n    result = solution.findAllPeople(6, [[0, 1, 2], [2, 3, 4]], 5)", "def test_findAllPeople(self):\n\n    class SolutionWrapper(Solution):\n\n        def __init__(self):\n            pass\n\n        def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\n            self.n = n\n            self.meetings = meetings\n            self.firstPerson = firstPerson\n            return super().findAllPeople(n, meetings, firstPerson)\n    solution = SolutionWrapper()\n    result = solution.findAllPeople(7, [[0, 3, 1], [5, 6, 4]], 2)", "def test_findAllPeople(self):\n\n    class SolutionWrapper(Solution):\n\n        def __init__(self):\n            pass\n\n        def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\n            self.n = n\n            self.meetings = meetings\n            self.firstPerson = firstPerson\n            return super().findAllPeople(n, meetings, firstPerson)\n    solution = SolutionWrapper()\n    result = solution.findAllPeople(8, [[1, 2, 3], [4, 5, 6]], 7)", "def test_findAllPeople(self):\n\n    class SolutionWrapper(Solution):\n\n        def __init__(self):\n            pass\n\n        def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\n            self.n = n\n            self.meetings = meetings\n            self.firstPerson = firstPerson\n            return super().findAllPeople(n, meetings, firstPerson)\n    solution = SolutionWrapper()\n    result = solution.findAllPeople(9, [[0, 3, 5], [6, 8, 7]], 4)", "def test_findAllPeople(self):\n\n    class SolutionWrapper(Solution):\n\n        def __init__(self):\n            pass\n\n        def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\n            self.n = n\n            self.meetings = meetings\n            self.firstPerson = firstPerson\n            return super().findAllPeople(n, meetings, firstPerson)\n    solution = SolutionWrapper()\n    result = solution.findAllPeople(10, [[1, 2, 4], [5, 6, 8]], 9)", "def test_findAllPeople(self):\n\n    class SolutionWrapper(Solution):\n\n        def __init__(self):\n            pass\n\n        def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\n            self.n = n\n            self.meetings = meetings\n            self.firstPerson = firstPerson\n            return super().findAllPeople(n, meetings, firstPerson)\n    solution = SolutionWrapper()\n    result = solution.findAllPeople(11, [[0, 1, 3], [7, 8, 9]], 10)", "def test_findAllPeople(self):\n\n    class SolutionWrapper(Solution):\n\n        def __init__(self):\n            pass\n\n        def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\n            self.n = n\n            self.meetings = meetings\n            self.firstPerson = firstPerson\n            return super().findAllPeople(n, meetings, firstPerson)\n    solution = SolutionWrapper()\n    result = solution.findAllPeople(12, [[3, 4, 6], [1, 5, 8]], 11)", "def test_findAllPeople(self):\n\n    class SolutionWrapper(Solution):\n\n        def __init__(self):\n            pass\n\n        def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\n            self.n = n\n            self.meetings = meetings\n            self.firstPerson = firstPerson\n            return super().findAllPeople(n, meetings, firstPerson)\n    solution = SolutionWrapper()\n    result = solution.findAllPeople(13, [[5, 6, 7], [2, 9, 10]], 12)", "def test_findAllPeople(self):\n\n    class SolutionWrapper(Solution):\n\n        def __init__(self):\n            pass\n\n        def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\n            self.n = n\n            self.meetings = meetings\n            self.firstPerson = firstPerson\n            return super().findAllPeople(n, meetings, firstPerson)\n    solution = SolutionWrapper()\n    result = solution.findAllPeople(14, [[7, 8, 11], [0, 4, 13]], 13)", "def test_findAllPeople(self):\n\n    class SolutionWrapper(Solution):\n\n        def __init__(self):\n            pass\n\n        def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\n            self.n = n\n            self.meetings = meetings\n            self.firstPerson = firstPerson\n            return super().findAllPeople(n, meetings, firstPerson)\n    solution = SolutionWrapper()\n    result = solution.findAllPeople(15, [[9, 10, 12], [1, 3, 14]], 14)", "def test_findAllPeople(self):\n\n    class SolutionWrapper(Solution):\n\n        def __init__(self):\n            pass\n\n        def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\n            self.n = n\n            self.meetings = meetings\n            self.firstPerson = firstPerson\n            return super().findAllPeople(n, meetings, firstPerson)\n    solution = SolutionWrapper()\n    result = solution.findAllPeople(16, [[11, 12, 13], [2, 5, 15]], 15)", "def test_findAllPeople(self):\n\n    class SolutionWrapper(Solution):\n\n        def __init__(self):\n            pass\n\n        def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\n            self.n = n\n            self.meetings = meetings\n            self.firstPerson = firstPerson\n            return super().findAllPeople(n, meetings, firstPerson)\n    solution = SolutionWrapper()\n    result = solution.findAllPeople(17, [[13, 14, 15], [0, 6, 16]], 16)", "def test_findAllPeople(self):\n\n    class SolutionWrapper(Solution):\n\n        def __init__(self):\n            pass\n\n        def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\n            self.n = n\n            self.meetings = meetings\n            self.firstPerson = firstPerson\n            return super().findAllPeople(n, meetings, firstPerson)\n    solution = SolutionWrapper()\n    result = solution.findAllPeople(18, [[15, 16, 17], [3, 7, 18]], 17)", "def test_findAllPeople(self):\n\n    class SolutionWrapper(Solution):\n\n        def __init__(self):\n            pass\n\n        def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\n            self.n = n\n            self.meetings = meetings\n            self.firstPerson = firstPerson\n            return super().findAllPeople(n, meetings, firstPerson)\n    solution = SolutionWrapper()\n    result = solution.findAllPeople(19, [[17, 18, 18], [1, 5, 19]], 18)", "def test_findAllPeople(self):\n\n    class SolutionWrapper(Solution):\n\n        def __init__(self):\n            pass\n\n        def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\n            self.n = n\n            self.meetings = meetings\n            self.firstPerson = firstPerson\n            return super().findAllPeople(n, meetings, firstPerson)\n    solution = SolutionWrapper()\n    result = solution.findAllPeople(20, [[18, 19, 19], [2, 4, 20]], 19)", "def test_findAllPeople(self):\n\n    class SolutionWrapper(Solution):\n\n        def __init__(self):\n            pass\n\n        def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\n            self.n = n\n            self.meetings = meetings\n            self.firstPerson = firstPerson\n            return super().findAllPeople(n, meetings, firstPerson)\n    solution = SolutionWrapper()\n    result = solution.findAllPeople(21, [[19, 20, 20], [0, 3, 21]], 20)"]}
{"task_num": 2115, "task_title": "Find All Possible Recipes from Given Supplies", "func_name": "findAllRecipes", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n    ans = []\n    supplies = set(supplies)\n    graph = collections.defaultdict(list)\n    inDegrees = collections.Counter()\n    q = collections.deque()\n\n    for i, recipe in enumerate(recipes):\n      for ingredient in ingredients[i]:\n        if ingredient not in supplies:\n          graph[ingredient].append(recipe)\n          inDegrees[recipe] += 1\n\n    for recipe in recipes:\n      if inDegrees[recipe] == 0:\n        q.append(recipe)\n\n    while q:\n      u = q.popleft()\n      ans.append(u)\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    return ans\n", "tests": ["def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['bananas', 'eggs']\n    ingredients = [['sushi', 'rice'], ['eggs']]\n    supplies = ['sushi', 'rice']\n    assert solution.findAllRecipes(recipes, ingredients, supplies) == ['eggs']", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['pizza', 'sushi', 'ice cream']\n    ingredients = [['cheese', 'tomato'], ['rice', 'spice'], ['eggs']]\n    supplies = ['cheese', 'eggs', 'tomato', 'rice']\n    assert sorted(solution.findAllRecipes(recipes, ingredients, supplies)) == ['pizza', 'sushi']", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['eggs', 'pizza']\n    ingredients = [['cheese', 'tomato'], ['eggs']]\n    supplies = ['cheese', 'tomato']\n    assert solution.findAllRecipes(recipes, ingredients, supplies) == []", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['sushi', 'rice', 'pizza']\n    ingredients = [['cheese', 'tomato'], ['eggs'], ['rice']]\n    supplies = ['rice', 'eggs', 'tomato', 'cheese']\n    assert sorted(solution.findAllRecipes(recipes, ingredients, supplies)) == ['pizza', 'sushi']", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['rice', 'eggs', 'sushi']\n    ingredients = [['sushi'], ['cheese'], ['rice']]\n    supplies = ['sushi', 'cheese']\n    assert sorted(solution.findAllRecipes(recipes, ingredients, supplies)) == ['eggs']", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['ice cream', 'pizza']\n    ingredients = [['cheese'], ['eggs']]\n    supplies = []\n    assert sorted(solution.findAllRecipes(recipes, ingredients, supplies)) == ['ice cream', 'pizza']", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['cheese', 'eggs']\n    ingredients = [['sushi'], ['rice']]\n    supplies = ['sushi', 'rice']\n    assert solution.findAllRecipes(recipes, ingredients, supplies) == []", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['sushi', 'rice']\n    ingredients = [['cheese'], ['eggs']]\n    supplies = ['cheese', 'eggs', 'tomato', 'rice']\n    assert sorted(solution.findAllRecipes(recipes, ingredients, supplies)) == ['sushi']", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['cheese', 'eggs']\n    ingredients = [['sushi'], ['rice']]\n    supplies = ['sushi', 'rice', 'cheese', 'eggs']\n    assert sorted(solution.findAllRecipes(recipes, ingredients, supplies)) == ['cheese', 'eggs']", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['banana', 'apple']\n    ingredients = [['sushi'], []]\n    supplies = []\n    assert solution.findAllRecipes(recipes, ingredients, supplies) == ['banana', 'apple']", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['cheese', 'eggs']\n    ingredients = [['sushi'], []]\n    supplies = []\n    assert solution.findAllRecipes(recipes, ingredients, supplies) == ['cheese', 'eggs']", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['rice', 'eggs']\n    ingredients = [['sushi'], []]\n    supplies = ['sushi', 'cheese']\n    assert sorted(solution.findAllRecipes(recipes, ingredients, supplies)) == ['eggs']", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['pizza', 'sushi']\n    ingredients = [['cheese'], ['rice']]\n    supplies = []\n    assert solution.findAllRecipes(recipes, ingredients, supplies) == ['pizza', 'sushi']", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['rice', 'eggs']\n    ingredients = [['cheese'], []]\n    supplies = ['sushi', 'cheese']\n    assert sorted(solution.findAllRecipes(recipes, ingredients, supplies)) == ['eggs']", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['rice', 'pizza']\n    ingredients = [['sushi'], []]\n    supplies = []\n    assert sorted(solution.findAllRecipes(recipes, ingredients, supplies)) == ['pizza']", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['sushi', 'rice']\n    ingredients = [['cheese'], []]\n    supplies = ['sushi', 'cheese']\n    assert sorted(solution.findAllRecipes(recipes, ingredients, supplies)) == ['rice', 'sushi']", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['cheese', 'rice']\n    ingredients = [['sushi'], []]\n    supplies = ['cheese', 'eggs']\n    assert sorted(solution.findAllRecipes(recipes, ingredients, supplies)) == ['cheese']", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['rice', 'pizza']\n    ingredients = [['cheese'], []]\n    supplies = ['sushi', 'cheese']\n    assert sorted(solution.findAllRecipes(recipes, ingredients, supplies)) == ['pizza']", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['sushi', 'rice']\n    ingredients = [['cheese'], []]\n    supplies = []\n    assert sorted(solution.findAllRecipes(recipes, ingredients, supplies)) == ['sushi', 'rice']", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['pizza', 'cheese']\n    ingredients = [['rice'], []]\n    supplies = ['sushi', 'rice', 'eggs', 'tomato', 'cheese']\n    assert sorted(solution.findAllRecipes(recipes, ingredients, supplies)) == ['cheese', 'pizza']"]}
{"task_num": 2127, "task_title": "Maximum Employees to Be Invited to a Meeting", "func_name": "maximumInvitations", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import Enum\n\n\nclass State(Enum):\n  kInit = 0\n  kVisiting = 1\n  kVisited = 2\n\n\nclass Solution:\n  def maximumInvitations(self, favorite: List[int]) -> int:\n    n = len(favorite)\n    sumComponentsLength = 0\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n    maxChainLength = [1] * n\n\n    for i, f in enumerate(favorite):\n      graph[i].append(f)\n      inDegrees[f] += 1\n\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n\n    while q:\n      u = q.popleft()\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n        maxChainLength[v] = max(maxChainLength[v], 1 + maxChainLength[u])\n\n    for i in range(n):\n      if favorite[favorite[i]] == i:\n        sumComponentsLength += maxChainLength[i] + maxChainLength[favorite[i]]\n\n    maxCycleLength = 0\n    parent = [-1] * n\n    seen = set()\n    states = [State.kInit] * n\n\n    def findCycle(u: int) -> None:\n      nonlocal maxCycleLength\n      seen.add(u)\n      states[u] = State.kVisiting\n      for v in graph[u]:\n        if v not in seen:\n          parent[v] = u\n          findCycle(v)\n        elif states[v] == State.kVisiting:\n          curr = u\n          cycleLength = 1\n          while curr != v:\n            curr = parent[curr]\n            cycleLength += 1\n          maxCycleLength = max(maxCycleLength, cycleLength)\n      states[u] = State.kVisited\n\n    for i in range(n):\n      if i not in seen:\n        findCycle(i)\n\n    return max(sumComponentsLength // 2, maxCycleLength)\n", "tests": ["def test_maximumInvitations():\n    solution = Solution()\n    favorite = [1, 0, 2]\n    assert solution.maximumInvitations(favorite) == 3", "def test_maximumInvitations():\n    solution = Solution()\n    favorite = [0, 2, 1]\n    assert solution.maximumInvitations(favorite) == 3", "def test_maximumInvitations():\n    solution = Solution()\n    favorite = [1, 2, 0]\n    assert solution.maximumInvitations(favorite) == 3", "def test_maximumInvitations():\n    solution = Solution()\n    favorite = [0, 1]\n    assert solution.maximumInvitations(favorite) == 2", "def test_maximumInvitations():\n    solution = Solution()\n    favorite = [1]\n    assert solution.maximumInvitations(favorite) == 1", "def test_maximumInvitations():\n    solution = Solution()\n    favorite = [2, 0, 1]\n    assert solution.maximumInvitations(favorite) == 3", "def test_maximumInvitations():\n    solution = Solution()\n    favorite = [0, 0, 1]\n    assert solution.maximumInvitations(favorite) == 3", "def test_maximumInvitations():\n    solution = Solution()\n    favorite = [2, 1, 0]\n    assert solution.maximumInvitations(favorite) == 3", "def test_maximumInvitations():\n    solution = Solution()\n    favorite = [1, 2, 0, 3]\n    assert solution.maximumInvitations(favorite) == 4", "def test_maximumInvitations():\n    solution = Solution()\n    favorite = [0, 1, 2]\n    assert solution.maximumInvitations(favorite) == 3", "def test_maximumInvitations():\n    solution = Solution()\n    favorite = [0, 1, 2, 3, 4]\n    assert solution.maximumInvitations(favorite) == 5", "def test_maximumInvitations():\n    solution = Solution()\n    favorite = [1, 2, 3, 4, 5]\n    assert solution.maximumInvitations(favorite) == 5", "def test_maximumInvitations():\n    solution = Solution()\n    favorite = []\n    assert solution.maximumInvitations(favorite) == 0", "def test_maximumInvitations():\n    solution = Solution()\n    favorite = [1, 2, 3]\n    assert solution.maximumInvitations(favorite) == 3", "def test_maximumInvitations():\n    solution = Solution()\n    favorite = [0, 1]\n    assert solution.maximumInvitations(favorite) == 2", "def test_maximumInvitations():\n    solution = Solution()\n    favorite = [1, 0]\n    assert solution.maximumInvitations(favorite) == 2", "def test_maximumInvitations():\n    solution = Solution()\n    favorite = [0]\n    assert solution.maximumInvitations(favorite) == 1", "def test_maximumInvitations():\n    solution = Solution()\n    favorite = [2, 0]\n    assert solution.maximumInvitations(favorite) == 3", "def test_maximumInvitations():\n    solution = Solution()\n    favorite = [0, 2]\n    assert solution.maximumInvitations(favorite) == 3", "def test_maximumInvitations():\n    solution = Solution()\n    favorite = [2, 0, 1]\n    assert solution.maximumInvitations(favorite) == 3"]}
{"task_num": 2132, "task_title": "Stamping the Grid", "func_name": "possibleToStamp", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def possibleToStamp(self, grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:\n    m = len(grid)\n    n = len(grid[0])\n    A = [[0] * (n + 1) for _ in range(m + 1)]\n    B = [[0] * (n + 1) for _ in range(m + 1)]\n    fit = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        A[i + 1][j + 1] = A[i + 1][j] + A[i][j + 1] - A[i][j] + grid[i][j]\n        if i + 1 >= stampHeight and j + 1 >= stampWidth:\n          x = i - stampHeight + 1\n          y = j - stampWidth + 1\n          if A[i + 1][j + 1] - A[x][j + 1] - A[i + 1][y] + A[x][y] == 0:\n            fit[i][j] = True\n\n    for i in range(m):\n      for j in range(n):\n        B[i + 1][j + 1] = B[i + 1][j] + B[i][j + 1] - B[i][j] + fit[i][j]\n\n    for i in range(m):\n      for j in range(n):\n        if not grid[i][j]:\n          x = min(i + stampHeight, m)\n          y = min(j + stampWidth, n)\n          if B[x][y] - B[i][y] - B[x][j] + B[i][j] == 0:\n            return False\n\n    return True\n", "tests": ["def test_possibleToStamp():\n    solution = Solution()\n    grid = [[0, 1], [0, 1]]\n    stampHeight = 2\n    stampWidth = 2\n    assert solution.possibleToStamp(grid, stampHeight, stampWidth) == True", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[0, 1, 0], [0, 0, 0]]\n    stampHeight = 2\n    stampWidth = 3\n    assert solution.possibleToStamp(grid, stampHeight, stampWidth) == False", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[1, 1], [1, 1]]\n    stampHeight = 2\n    stampWidth = 2\n    assert solution.possibleToStamp(grid, stampHeight, stampWidth) == False", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[0, 0], [1, 1]]\n    stampHeight = 3\n    stampWidth = 2\n    assert solution.possibleToStamp(grid, stampHeight, stampWidth) == True", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[0, 0, 0], [1, 1, 0]]\n    stampHeight = 2\n    stampWidth = 3\n    assert solution.possibleToStamp(grid, stampHeight, stampWidth) == False", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[0] * 4 + [1], [0] * 5 + [0, 1]]\n    stampHeight = 2\n    stampWidth = 3\n    assert solution.possibleToStamp(grid, stampHeight, stampWidth) == False", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[0] * 5 + [1], [0] * 6 + [0, 1]]\n    stampHeight = 3\n    stampWidth = 2\n    assert solution.possibleToStamp(grid, stampHeight, stampWidth) == True", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[0] * 10 + [1], [0] * 11 + [0, 1]]\n    stampHeight = 2\n    stampWidth = 3\n    assert solution.possibleToStamp(grid, stampHeight, stampWidth) == False", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[1, 0], [0, 0]]\n    stampHeight = 2\n    stampWidth = 3\n    assert solution.possibleToStamp(grid, stampHeight, stampWidth) == False", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[1] * 5 + [0], [1] * 6 + [1]]\n    stampHeight = 2\n    stampWidth = 3\n    assert solution.possibleToStamp(grid, stampHeight, stampWidth) == False", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[0] * 10 + [1] + [0], [0] * 11 + [0, 1]]\n    stampHeight = 2\n    stampWidth = 3\n    assert solution.possibleToStamp(grid, stampHeight, stampWidth) == False", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[1, 0], [0, 0]]\n    stampHeight = 3\n    stampWidth = 2\n    assert solution.possibleToStamp(grid, stampHeight, stampWidth) == False", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[1] * 4 + [0], [1] * 5 + [0]]\n    stampHeight = 2\n    stampWidth = 3\n    assert solution.possibleToStamp(grid, stampHeight, stampWidth) == False", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[0] * 10 + [1] + [0], [0] * 11 + [0, 1]]\n    stampHeight = 3\n    stampWidth = 2\n    assert solution.possibleToStamp(grid, stampHeight, stampWidth) == False", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[1] * 3 + [0], [1] * 4 + [0]]\n    stampHeight = 2\n    stampWidth = 3\n    assert solution.possibleToStamp(grid, stampHeight, stampWidth) == False", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[0] * 4 + [1], [0] * 5 + [0, 1]]\n    stampHeight = 2\n    stampWidth = 3\n    assert solution.possibleToStamp(grid, stampHeight, stampWidth) == False", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[1] * 100 + [0], [1] * 101 + [0]]\n    stampHeight = 2\n    stampWidth = 3\n    assert solution.possibleToStamp(grid, stampHeight, stampWidth) == False", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[1] * 50 + [0], [1] * 51 + [0]]\n    stampHeight = 2\n    stampWidth = 3\n    assert solution.possibleToStamp(grid, stampHeight, stampWidth) == False", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[0] * 10 + [1] + [0], [0] * 11 + [0, 1]]\n    stampHeight = 3\n    stampWidth = 2\n    assert solution.possibleToStamp(grid, stampHeight, stampWidth) == False", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[1, 0], [0, 0]]\n    stampHeight = 4\n    stampWidth = 2\n    assert solution.possibleToStamp(grid, stampHeight, stampWidth) == False"]}
{"task_num": 2146, "task_title": "K Highest Ranked Items Within a Price Range", "func_name": "highestRankedKItems", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    low, high = pricing\n    row, col = start\n    ans = []\n\n    if low <= grid[row][col] <= high:\n      ans.append([row, col])\n      if k == 1:\n        return ans\n\n    q = collections.deque([(row, col)])\n    seen = {(row, col)}\n\n    while q:\n      neighbors = []\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for t in range(4):\n          x = i + dirs[t][0]\n          y = j + dirs[t][1]\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if not grid[x][y] or (x, y) in seen:\n            continue\n          if low <= grid[x][y] <= high:\n            neighbors.append([x, y])\n          q.append((x, y))\n          seen.add((x, y))\n      neighbors.sort(key=lambda x: (grid[x[0]][x[1]], x[0], x[1]))\n      for neighbor in neighbors:\n        if len(ans) < k:\n          ans.append(neighbor)\n        if len(ans) == k:\n          return ans\n\n    return ans\n", "tests": ["def test_highestRankedKItems(self):\n  class Solution:\n    # ... (rest of the code remains the same)\n\n  solution = Solution()\n\n  grid = [[3,4],[5,7]]\n  pricing = [5,7]\n  start = [1,1]\n  k = 2\n  self.assertEqual(solution.highestRankedKItems(grid, pricing, start, k), [[1,1],[1,2]])", "def test_highestRankedKItems(self):\n    solution = Solution()\n    grid = [[5, 7]]\n    pricing = [3, 10]\n    start = [0, 0]\n    k = len(grid) * len(grid[0])\n    self.assertEqual(solution.highestRankedKItems(grid, pricing, start, k), [[0, 0]])", "def test_highestRankedKItems(self):\n    solution = Solution()\n    grid = [[5, 7]]\n    pricing = [3, 10]\n    start = [0, 0]\n    k = 1\n    self.assertEqual(solution.highestRankedKItems(grid, pricing, start, k), [[0, 0]])", "def test_highestRankedKItems(self):\n    solution = Solution()\n    grid = [[5, 7]]\n    pricing = [3, 10]\n    start = [-1, -1]\n    k = 1\n    self.assertEqual(solution.highestRankedKItems(grid, pricing, start, k), [])", "def test_highestRankedKItems(self):\n    solution = Solution()\n    grid = [[0, 7]]\n    pricing = [3, 10]\n    start = [0, 0]\n    k = 1\n    self.assertEqual(solution.highestRankedKItems(grid, pricing, start, k), [])", "def test_highestRankedKItems(self):\n    solution = Solution()\n    grid = [[5, 7]]\n    pricing = [3, 3]\n    start = [0, 0]\n    k = 1\n    self.assertEqual(solution.highestRankedKItems(grid, pricing, start, k), [])", "def test_highestRankedKItems(self):\n    solution = Solution()\n    grid = [[5, 7], [9, 10]]\n    pricing = [3, 10]\n    start = [1, 1]\n    k = len(grid)\n    self.assertEqual(solution.highestRankedKItems(grid, pricing, start, k), [[0, 0], [1, 0]])", "def test_highestRankedKItems(self):\n    solution = Solution()\n    grid = [[5, 7], [9, 10]]\n    pricing = [3, 10]\n    start = [0, 0]\n    k = len(grid)\n    self.assertEqual(solution.highestRankedKItems(grid, pricing, start, k), [[0, 0]])", "def test_highestRankedKItems(self):\n    solution = Solution()\n    grid = [[5, 7], [9, 10]]\n    pricing = [3, 10]\n    start = [len(grid) - 1, len(grid[0]) // 2 + 1]\n    k = len(grid)\n    self.assertEqual(solution.highestRankedKItems(grid, pricing, start, k), [])", "def test_highestRankedKItems(self):\n    solution = Solution()\n    grid = [[5, 7], [9, 10]]\n    pricing = [3, 10]\n    start = [(len(grid) - 1) // 2 + len(grid), (len(grid[0]) - 1) // 2]\n    k = len(grid)\n    self.assertEqual(solution.highestRankedKItems(grid, pricing, start, k), [])", "def test_highestRankedKItems(self):\n    solution = Solution()\n    grid = [[5, 7], [9, 10]]\n    pricing = [3, 10]\n    start = [random.randint(0, len(grid) - 1), random.randint(0, len(grid[0]) - 1)]\n    k = random.randint(1, min(len(grid), len(grid[0])))\n    self.assertEqual(solution.highestRankedKItems(grid, pricing, start, k), [])", "def test_highestRankedKItems(self):\n    solution = Solution()\n    grid = [[5, 7], [9, 10]]\n    pricing = [3, 10]\n    k = random.randint(1, min(len(grid), len(grid[0])))\n    positions = []\n    for _ in range(k):\n        position = [random.randint(0, len(grid) - 1), random.randint(0, len(grid[0]) - 1)]\n        while position in positions:\n            position = [random.randint(0, len(grid) - 1), random.randint(0, len(grid[0]) - 1)]\n        positions.append(position)\n    expected_result = []\n    for i in range(k):\n        result = solution.highestRankedKItems(grid, pricing, positions[i], 1)", "def test_highestRankedKItems(self):\n    solution = Solution()\n    grid = [[-5, 7], [-9, 10]]\n    pricing = [-3, 10]\n    k = random.randint(1, min(len(grid), len(grid[0])))\n    positions = []\n    for _ in range(k):\n        position = [random.randint(0, len(grid) - 1), random.randint(0, len(grid[0]) - 1)]\n        while position in positions:\n            position = [random.randint(0, len(grid) - 1), random.randint(0, len(grid[0]) - 1)]\n        positions.append(position)\n    expected_result = []\n    for i in range(k):\n        result = solution.highestRankedKItems(grid, pricing, positions[i], 1)", "def test_highestRankedKItems(self):\n    solution = Solution()\n    grid = [[0, 7], [9, 10]]\n    pricing = [3, 10]\n    k = random.randint(1, min(len(grid), len(grid[0])))\n    positions = []\n    for _ in range(k):\n        position = [random.randint(0, len(grid) - 1), random.randint(0, len(grid[0]) - 1)]\n        while position in positions:\n            position = [random.randint(0, len(grid) - 1), random.randint(0, len(grid[0]) - 1)]\n        positions.append(position)\n    expected_result = []\n    for i in range(k):\n        result = solution.highestRankedKItems(grid, pricing, positions[i], 1)", "def test_highestRankedKItems(self):\n    solution = Solution()\n    grid = [[1000, 700], [9000, 10000]]\n    pricing = [3000, 10000]\n    k = random.randint(1, min(len(grid), len(grid[0])))\n    positions = []\n    for _ in range(k):\n        position = [random.randint(0, len(grid) - 1), random.randint(0, len(grid[0]) - 1)]\n        while position in positions:\n            position = [random.randint(0, len(grid) - 1), random.randint(0, len(grid[0]) - 1)]\n        positions.append(position)\n    expected_result = []\n    for i in range(k):\n        result = solution.highestRankedKItems(grid, pricing, positions[i], 1)", "def test_highestRankedKItems(self):\n    solution = Solution()\n    grid = [[1, 1000], [9999, 10000]]\n    pricing = [3000, 10000]\n    k = random.randint(1, min(len(grid), len(grid[0])))\n    positions = []\n    for _ in range(k):\n        position = [random.randint(0, len(grid) - 1), random.randint(0, len(grid[0]) - 1)]\n        while position in positions:\n            position = [random.randint(0, len(grid) - 1), random.randint(0, len(grid[0]) - 1)]\n        positions.append(position)\n    expected_result = []\n    for i in range(k):\n        result = solution.highestRankedKItems(grid, pricing, positions[i], 1)", "def test_highestRankedKItems(self):\n    solution = Solution()\n    grid = [[1, 1000], [9999, 10000]]\n    pricing = [3000000000, 10000000000]\n    k = random.randint(1, min(len(grid), len(grid[0])))\n    positions = []\n    for _ in range(k):\n        position = [random.randint(0, len(grid) - 1), random.randint(0, len(grid[0]) - 1)]\n        while position in positions:\n            position = [random.randint(0, len(grid) - 1), random.randint(0, len(grid[0]) - 1)]\n        positions.append(position)\n    expected_result = []\n    for i in range(k):\n        result = solution.highestRankedKItems(grid, pricing, positions[i], 1)", "def test_highestRankedKItems(self):\n    solution = Solution()\n    grid = [[1, 1000], [9999, 10000]]\n    pricing = [0, 0]\n    k = random.randint(1, min(len(grid), len(grid[0])))\n    positions = []\n    for _ in range(k):\n        position = [random.randint(0, len(grid) - 1), random.randint(0, len(grid[0]) - 1)]\n        while position in positions:\n            position = [random.randint(0, len(grid) - 1), random.randint(0, len(grid[0]) - 1)]\n        positions.append(position)\n    expected_result = []\n    for i in range(k):\n        result = solution.highestRankedKItems(grid, pricing, positions[i], 1)", "def test_highestRankedKItems(self):\n    solution = Solution()\n    grid = [[1, 1000], [9999, 10000]]\n    pricing = [-3000000000, -10000000000]\n    k = random.randint(1, min(len(grid), len(grid[0])))\n    positions = []\n    for _ in range(k):\n        position = [random.randint(0, len(grid) - 1), random.randint(0, len(grid[0]) - 1)]\n        while position in positions:\n            position = [random.randint(0, len(grid) - 1), random.randint(0, len(grid[0]) - 1)]\n        positions.append(position)\n    expected_result = []\n    for i in range(k):\n        result = solution.highestRankedKItems(grid, pricing, positions[i], 1)", "def test_highestRankedKItems(self):\n    solution = Solution()\n    grid = [[10000000000.0, 20000000000.0], [30000000000.0, 40000000000.0]]\n    pricing = [3000000000, 10000000000]\n    k = random.randint(1, min(len(grid), len(grid[0])))\n    positions = []\n    for _ in range(k):\n        position = [random.randint(0, len(grid) - 1), random.randint(0, len(grid[0]) - 1)]\n        while position in positions:\n            position = [random.randint(0, len(grid) - 1), random.randint(0, len(grid[0]) - 1)]\n        positions.append(position)\n    expected_result = []\n    for i in range(k):\n        result = solution.highestRankedKItems(grid, pricing, positions[i], 1)"]}
{"task_num": 2157, "task_title": "Groups of Strings", "func_name": "groupStrings", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.sz = [1] * n\n\n  def unionBySize(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.sz[i] < self.sz[j]:\n      self.sz[j] += self.sz[i]\n      self.id[i] = j\n    else:\n      self.sz[i] += self.sz[j]\n      self.id[j] = i\n    self.count -= 1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def groupStrings(self, words: List[str]) -> List[int]:\n    uf = UnionFind(len(words))\n\n    def getMask(s: str) -> int:\n      mask = 0\n      for c in s:\n        mask |= 1 << ord(c) - ord('a')\n      return mask\n\n    def getAddedMasks(mask: int):\n      for i in range(26):\n        if not (mask >> i & 1):\n          yield mask | 1 << i\n\n    def getDeletedMasks(mask: int):\n      for i in range(26):\n        if mask >> i & 1:\n          yield mask ^ 1 << i\n\n    maskToIndex = {getMask(word): i for i, word in enumerate(words)}\n    deletedMaskToIndex = {}\n\n    for i, word in enumerate(words):\n      mask = getMask(word)\n      for m in getAddedMasks(mask):\n        if m in maskToIndex:\n          uf.unionBySize(i, maskToIndex[m])\n      for m in getDeletedMasks(mask):\n        if m in maskToIndex:\n          uf.unionBySize(i, maskToIndex[m])\n        if m in deletedMaskToIndex:\n          uf.unionBySize(i, deletedMaskToIndex[m])\n        else:\n          deletedMaskToIndex[m] = i\n\n    return [uf.count, max(uf.sz)]\n", "tests": ["def test_groupStrings():\n    solution = Solution()\n    \n    def test_case(words):", "def test_groupStrings():\n    solution = Solution()\n    \n    def test_case(words):", "def test_groupStrings():\n    solution = Solution()\n    \n    def test_case(words):", "def test_groupStrings():\n    solution = Solution()\n    \n    def test_case(words):", "def test_groupStrings():\n    solution = Solution()\n    \n    def test_case(words):", "def test_groupStrings():\n    solution = Solution()\n    \n    def test_case(words):", "def test_groupStrings():\n    solution = Solution()\n    \n    def test_case(words):", "def test_groupStrings():\n    solution = Solution()\n    \n    def test_case(words):", "def test_groupStrings():\n    solution = Solution()\n    \n    def test_case(words):", "def test_groupStrings():\n    solution = Solution()\n    \n    def test_case(words):", "def test_groupStrings():\n    solution = Solution()\n    \n    def test_case(words):", "def test_groupStrings():\n    solution = Solution()\n    \n    def test_case(words):", "def test_groupStrings():\n    solution = Solution()\n    \n    def test_case(words):", "def test_groupStrings():\n    solution = Solution()\n    \n    def test_case(words):", "def test_groupStrings():\n    solution = Solution()\n    \n    def test_case(words):", "def test_groupStrings():\n    solution = Solution()\n    \n    def test_case(words):", "def test_groupStrings():\n    solution = Solution()\n    \n    def test_case(words):", "def test_groupStrings():\n    solution = Solution()\n    \n    def test_case(words):", "def test_groupStrings():\n    solution = Solution()\n    \n    def test_case(words):", "def test_groupStrings():\n    solution = Solution()\n    \n    def test_case(words):"]}
{"task_num": 2182, "task_title": "Construct String With Repeat Limit", "func_name": "repeatLimitedString", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\n    ans = ''\n    count = collections.Counter(s)\n\n    while True:\n      addOne = ans and self._shouldAddOne(ans, count)\n      c = self._getLargestChar(ans, count)\n      if c == ' ':\n        break\n      repeats = 1 if addOne else min(count[c], repeatLimit)\n      ans += c * repeats\n      count[c] -= repeats\n\n    return ans\n\n  def _shouldAddOne(self, ans: str, count: collections.Counter) -> bool:\n    for c in reversed(string.ascii_lowercase):\n      if count[c]:\n        return ans[-1] == c\n    return False\n\n  def _getLargestChar(self, ans: str, count: collections.Counter) -> int:\n    for c in reversed(string.ascii_lowercase):\n      if count[c] and (not ans or ans[-1] != c):\n        return c\n    return ' '\n", "tests": ["def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('abc', 2) == 'abacba'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('a', 1) == 'a'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('aaa', 3) == 'abca'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('zzz', 2) == 'z'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('', 10) == ''", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('aab', 1) == 'ab'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('abcdef', 1) == 'abcdef'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('aaaa', 2) == 'abaa'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('zzzza', 2) == 'zaz'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('abaccd', 2) == 'abcad'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('cccaaabbb', 2) == 'abcabab'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('zyxwvutsrqponmlkjihgfedcba', 1) == 'zyxwvutsrqponmlkjihgfedcb'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('aabbcc', 1) == 'abc'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('abccba', 2) == 'abcaba'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('abcde', 3) == 'abca'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('aaaaaa', 3) == 'abaaa'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('bba', 2) == 'bab'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('aaaab', 2) == 'aba'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('abcd', 3) == 'abca'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('bbbaaa', 2) == 'aba'"]}
{"task_num": 2203, "task_title": "Minimum Weighted Subgraph With the Required Paths", "func_name": "minimumWeight", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\n    graph = [[] for _ in range(n)]\n    reversedGraph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      reversedGraph[v].append((u, w))\n\n    fromSrc1 = self._dijkstra(graph, src1)\n    fromSrc2 = self._dijkstra(graph, src2)\n    fromDest = self._dijkstra(reversedGraph, dest)\n    minWeight = min(a + b + c for a, b, c in zip(fromSrc1, fromSrc2, fromDest))\n    if minWeight == math.inf:\n      return -1\n    else:\n      return minWeight\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int) -> List[int]:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist\n", "tests": ["def test_minimumWeight(self):\n\n    class SolutionMock:\n\n        def __init__(self):\n            self._dijkstra = lambda graph, src: [0] * len(graph)\n            self.minimumWeight = self.mock_minimumWeight\n\n        def mock_minimumWeight(self, n, edges, src1, src2, dest):\n            return 5\n    solution = SolutionMock()\n    result = solution.minimumWeight(3, [[0, 1, 10], [0, 2, 20]], 0, 1, 2)", "def test_minimumWeight(self):\n\n    class SolutionMock:\n\n        def __init__(self):\n            self._dijkstra = lambda graph, src: [math.inf] * len(graph)\n            self.minimumWeight = self.mock_minimumWeight\n\n        def mock_minimumWeight(self, n, edges, src1, src2, dest):\n            return -1\n    solution = SolutionMock()\n    result = solution.minimumWeight(3, [[0, 1, 10], [1, 2, 20]], 0, 2, 2)", "def test_minimumWeight(self):\n\n    class SolutionMock:\n\n        def __init__(self):\n            self._dijkstra = lambda graph, src: [math.inf] * len(graph)\n            self.minimumWeight = self.mock_minimumWeight\n\n        def mock_minimumWeight(self, n, edges, src1, src2, dest):\n            return 5\n    solution = SolutionMock()\n    with self.assertRaises(ValueError):\n        solution.minimumWeight(3, [[0, 1, -10], [1, 2, 20]], 0, 1, 2)", "def test_minimumWeight(self):\n\n    class SolutionMock:\n\n        def __init__(self):\n            self._dijkstra = lambda graph, src: [math.inf] * len(graph)\n            self.minimumWeight = self.mock_minimumWeight\n\n        def mock_minimumWeight(self, n, edges, src1, src2, dest):\n            return -1 if not edges else 5\n    solution = SolutionMock()\n    result = solution.minimumWeight(3, [], 0, 1, 2)", "def test_minimumWeight(self):\n\n    class SolutionMock:\n\n        def __init__(self):\n            self._dijkstra = lambda graph, src: [0] * len(graph)\n            self.minimumWeight = self.mock_minimumWeight\n\n        def mock_minimumWeight(self, n, edges, src1, src2, dest):\n            return 5 if n > 1 else -1\n    solution = SolutionMock()\n    result = solution.minimumWeight(1, [[0, 0, 10]], 0, 0, 0)", "def test_minimumWeight(self):\n\n    class SolutionMock:\n\n        def __init__(self):\n            self._dijkstra = lambda graph, src: [math.inf] * len(graph)\n            self.minimumWeight = self.mock_minimumWeight\n\n        def mock_minimumWeight(self, n, edges, src1, src2, dest):\n            return 1000 if n > 10 else -1\n    solution = SolutionMock()\n    result = solution.minimumWeight(20, [[i % 10, (i + 5) % 10, i] for i in range(200)], 0, 5, 15)", "def test_minimumWeight(self):\n\n    class SolutionMock:\n\n        def __init__(self):\n            self._dijkstra = lambda graph, src: [math.inf] * len(graph)\n            self.minimumWeight = self.mock_minimumWeight\n\n        def mock_minimumWeight(self, n, edges, src1, src2, dest):\n            return -1 if not (src1 in [u for (u, v, w) in edges] or src2 in [u for (u, v, w) in edges]) else 5\n    solution = SolutionMock()\n    result = solution.minimumWeight(3, [[0, 1, 10], [2, 2, 20]], 3, 1, 2)", "def test_minimumWeight(self):\n\n    class SolutionMock:\n\n        def __init__(self):\n            self._dijkstra = lambda graph, src: [math.inf] * len(graph)\n            self.minimumWeight = self.mock_minimumWeight\n\n        def mock_minimumWeight(self, n, edges, src1, src2, dest):\n            return min(4, 5)\n    solution = SolutionMock()\n    result = solution.minimumWeight(3, [[0, 1, 10], [1, 2, 20]], 0, 1, 2)", "def test_minimumWeight(self):\n\n    class SolutionMock:\n\n        def __init__(self):\n            self._dijkstra = lambda graph, src: [0] * len(graph)\n            self.minimumWeight = self.mock_minimumWeight\n\n        def mock_minimumWeight(self, n, edges, src1, src2, dest):\n            return 5 if dest not in (src1, src2) else -1\n    solution = SolutionMock()\n    result = solution.minimumWeight(3, [[0, 1, 10], [1, 2, 20]], 0, 1, 0)", "def test_minimumWeight(self):\n\n    class SolutionMock:\n\n        def __init__(self):\n            self._dijkstra = lambda graph, src: [0] * len(graph)\n            self.minimumWeight = self.mock_minimumWeight\n\n        def mock_minimumWeight(self, n, edges, src1, src2, dest):\n            return 5 if src1 == dest and src2 != dest or (src2 == dest and src1 != dest) else -1\n    solution = SolutionMock()\n    result = solution.minimumWeight(3, [[0, 1, 10], [1, 2, 20]], 0, 1, 0)", "def test_minimumWeight(self):\n\n    class SolutionMock:\n\n        def __init__(self):\n            self._dijkstra = lambda graph, src: [0] * len(graph)\n            self.minimumWeight = self.mock_minimumWeight\n\n        def mock_minimumWeight(self, n, edges, src1, src2, dest):\n            return 5 if src1 == dest and src2 == dest else -1\n    solution = SolutionMock()\n    result = solution.minimumWeight(3, [[0, 1, 10], [1, 2, 20]], 0, 0, 0)", "def test_minimumWeight(self):\n\n    class SolutionMock:\n\n        def __init__(self):\n            self._dijkstra = lambda graph, src: [5] * len(graph)\n            self.minimumWeight = self.mock_minimumWeight\n\n        def mock_minimumWeight(self, n, edges, src1, src2, dest):\n            return min((a + b for (a, b) in zip([0, 5], [5, 10])))\n    solution = SolutionMock()\n    result = solution.minimumWeight(3, [[0, 1, 10], [1, 2, 20]], 0, 1, 2)", "def test_minimumWeight(self):\n\n    class SolutionMock:\n\n        def __init__(self):\n            self._dijkstra = lambda graph, src: [math.inf] * len(graph)\n            self.minimumWeight = self.mock_minimumWeight\n\n        def mock_minimumWeight(self, n, edges, src1, src2, dest):\n            if any((w < 0 for (u, v, w) in edges)):\n                return -1\n            else:\n                return 5\n    solution = SolutionMock()\n    result = solution.minimumWeight(3, [[0, 1, -10], [1, 2, 20]], 0, 1, 2)", "def test_minimumWeight(self):\n\n    class SolutionMock:\n\n        def __init__(self):\n            self._dijkstra = lambda graph, src: [math.inf] * len(graph)\n            self.minimumWeight = self.mock_minimumWeight\n\n        def mock_minimumWeight(self, n, edges, src1, src2, dest):\n            try:\n                return 5\n            except TypeError as e:\n                return str(e)\n    solution = SolutionMock()\n    with self.assertRaises(TypeError):\n        solution.minimumWeight('a', [[0, 1, 10], [1, 2, 20]], 0, 1, 2)", "def test_minimumWeight(self):\n\n    class SolutionMock:\n\n        def __init__(self):\n            self._dijkstra = lambda graph, src: [math.inf] * len(graph)\n            self.minimumWeight = self.mock_minimumWeight\n\n        def mock_minimumWeight(self, n, edges, src1, src2, dest):\n            if n > 10 ** 6 or max((w for (u, v, w) in edges)) > 10 ** 9:\n                return -1\n            else:\n                return 5\n    solution = SolutionMock()\n    result = solution.minimumWeight(10 ** 6 + 1, [[0, 1, 10 ** 9], [1, 2, 20]], 0, 1, 2)", "def test_minimumWeight(self):\n\n    class SolutionMock:\n\n        def __init__(self):\n            self._dijkstra = lambda graph, src: [math.inf] * len(graph)\n            self.minimumWeight = self.mock_minimumWeight\n\n        def mock_minimumWeight(self, n, edges, src1, src2, dest):\n            if src1 == 0 and src2 == 1 or (src1 == 1 and src2 == 0):\n                return min(5 + 10, 20)\n            else:\n                return -1\n    solution = SolutionMock()\n    result = solution.minimumWeight(3, [[0, 1, 10], [1, 2, 20]], 0, 1, 2)", "def test_minimumWeight(self):\n\n    class SolutionMock:\n\n        def __init__(self):\n            self._dijkstra = lambda graph, src: [math.inf] * len(graph)\n            self.minimumWeight = self.mock_minimumWeight\n\n        def mock_minimumWeight(self, n, edges, src1, src2, dest):\n            if dest > 10 ** 9:\n                return -1\n            else:\n                return 5\n    solution = SolutionMock()\n    result = solution.minimumWeight(3, [[0, 1, 10], [1, 2, 20]], 0, 1, 10 ** 9)", "def test_minimumWeight(self):\n\n    class SolutionMock:\n\n        def __init__(self):\n            self._dijkstra = lambda graph, src: [math.inf] * len(graph)\n            self.minimumWeight = self.mock_minimumWeight\n\n        def mock_minimumWeight(self, n, edges, src1, src2, dest):\n            if src1 == 0 and src2 == 1 or (src1 == 1 and src2 == 0):\n                return min(5 + 10, 20)\n            else:\n                return -1\n    solution = SolutionMock()\n    result = solution.minimumWeight(3, [[0, 1, 10], [1, 2, 20]], 3, 4, 5)", "def test_minimumWeight(self):\n\n    class SolutionMock:\n\n        def __init__(self):\n            self._dijkstra = lambda graph, src: [math.inf] * len(graph)\n            self.minimumWeight = self.mock_minimumWeight\n\n        def mock_minimumWeight(self, n, edges, src1, src2, dest):\n            return 5 if src1 == dest and src2 != dest else -1\n    solution = SolutionMock()\n    result = solution.minimumWeight(3, [], 0, 1, 2)", "def test_minimumWeight(self):\n\n    class SolutionMock:\n\n        def __init__(self):\n            self._dijkstra = lambda graph, src: [math.inf] * len(graph)\n            self.minimumWeight = self.mock_minimumWeight\n\n        def mock_minimumWeight(self, n, edges, src1, src2, dest):\n            return -1 if src1 != 0 or src2 != 1 else min(5 + 10, 20)\n    solution = SolutionMock()\n    result = solution.minimumWeight(3, [[0, 1, 10], [1, 2, 20]], 2, 4, 5)"]}
{"task_num": 2242, "task_title": "Maximum Score of a Node Sequence", "func_name": "maximumScore", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\n    n = len(scores)\n    ans = -1\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append((scores[v], v))\n      graph[v].append((scores[u], u))\n\n    for i in range(n):\n      graph[i] = heapq.nlargest(3, graph[i])\n\n    for u, v in edges:\n      for scoreA, a in graph[u]:\n        for scoreB, b in graph[v]:\n          if a != b and a != v and b != u:\n            ans = max(ans, scoreA + scores[u] + scores[v] + scoreB)\n\n    return ans\n", "tests": ["def test_maximumScore():\n\n    class Solution:\n\n        def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\n            n = len(scores)\n            ans = -1\n            graph = [[] for _ in range(n)]\n            for (u, v) in edges:\n                graph[u].append((scores[v], v))\n                graph[v].append((scores[u], u))\n            for i in range(n):\n                graph[i] = heapq.nlargest(3, graph[i])\n            for (u, v) in edges:\n                for (scoreA, a) in graph[u]:\n                    for (scoreB, b) in graph[v]:\n                        if a != b and a != v and (b != u):\n                            ans = max(ans, scoreA + scores[u] + scores[v] + scoreB)\n            return ans\n    solution = Solution()\n    scores = [1, 2, 3, 4]\n    edges = [[0, 1], [1, 2], [2, 3]]\n    assert solution.maximumScore(scores, edges) == 10", "def test_maximumScore():\n\n    class Solution:\n\n        def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\n            n = len(scores)\n            ans = -1\n            graph = [[] for _ in range(n)]\n            for (u, v) in edges:\n                graph[u].append((scores[v], v))\n                graph[v].append((scores[u], u))\n            for i in range(n):\n                graph[i] = heapq.nlargest(3, graph[i])\n            for (u, v) in edges:\n                for (scoreA, a) in graph[u]:\n                    for (scoreB, b) in graph[v]:\n                        if a != b and a != v and (b != u):\n                            ans = max(ans, scoreA + scores[u] + scores[v] + scoreB)\n            return ans\n    solution = Solution()\n    scores = [10, 5, 1]\n    edges = [[0, 1], [1, 2]]\n    assert solution.maximumScore(scores, edges) == -1", "def test_maximumScore():\n\n    class Solution:\n\n        def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\n            n = len(scores)\n            ans = -1\n            graph = [[] for _ in range(n)]\n            for (u, v) in edges:\n                graph[u].append((scores[v], v))\n                graph[v].append((scores[u], u))\n            for i in range(n):\n                graph[i] = heapq.nlargest(3, graph[i])\n            for (u, v) in edges:\n                for (scoreA, a) in graph[u]:\n                    for (scoreB, b) in graph[v]:\n                        if a != b and a != v and (b != u):\n                            ans = max(ans, scoreA + scores[u] + scores[v] + scoreB)\n            return ans\n    solution = Solution()\n    scores = [1, 3, 2]\n    edges = [[0, 1], [1, 2]]\n    assert solution.maximumScore(scores, edges) == 9", "def test_maximumScore():\n\n    class Solution:\n\n        def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\n            n = len(scores)\n            ans = -1\n            graph = [[] for _ in range(n)]\n            for (u, v) in edges:\n                graph[u].append((scores[v], v))\n                graph[v].append((scores[u], u))\n            for i in range(n):\n                graph[i] = heapq.nlargest(3, graph[i])\n            for (u, v) in edges:\n                for (scoreA, a) in graph[u]:\n                    for (scoreB, b) in graph[v]:\n                        if a != b and a != v and (b != u):\n                            ans = max(ans, scoreA + scores[u] + scores[v] + scoreB)\n            return ans\n    solution = Solution()\n    scores = [3, 1, 2]\n    edges = [[0, 1], [1, 2]]\n    assert solution.maximumScore(scores, edges) == 6", "def test_maximumScore():\n\n    class Solution:\n\n        def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\n            n = len(scores)\n            ans = -1\n            graph = [[] for _ in range(n)]\n            for (u, v) in edges:\n                graph[u].append((scores[v], v))\n                graph[v].append((scores[u], u))\n            for i in range(n):\n                graph[i] = heapq.nlargest(3, graph[i])\n            for (u, v) in edges:\n                for (scoreA, a) in graph[u]:\n                    for (scoreB, b) in graph[v]:\n                        if a != b and a != v and (b != u):\n                            ans = max(ans, scoreA + scores[u] + scores[v] + scoreB)\n            return ans\n    solution = Solution()\n    scores = [2, 1, 3, 4]\n    edges = [[0, 1], [1, 2]]\n    assert solution.maximumScore(scores, edges) == 9", "def test_maximumScore():\n\n    class Solution:\n\n        def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\n            n = len(scores)\n            ans = -1\n            graph = [[] for _ in range(n)]\n            for (u, v) in edges:\n                graph[u].append((scores[v], v))\n                graph[v].append((scores[u], u))\n            for i in range(n):\n                graph[i] = heapq.nlargest(3, graph[i])\n            for (u, v) in edges:\n                for (scoreA, a) in graph[u]:\n                    for (scoreB, b) in graph[v]:\n                        if a != b and a != v and (b != u):\n                            ans = max(ans, scoreA + scores[u] + scores[v] + scoreB)\n            return ans\n    solution = Solution()\n    scores = [5, 5, 2, 1]\n    edges = [[0, 1], [1, 2]]\n    assert solution.maximumScore(scores, edges) == 14", "def test_maximumScore():\n\n    class Solution:\n\n        def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\n            n = len(scores)\n            ans = -1\n            graph = [[] for _ in range(n)]\n            for (u, v) in edges:\n                graph[u].append((scores[v], v))\n                graph[v].append((scores[u], u))\n            for i in range(n):\n                graph[i] = heapq.nlargest(3, graph[i])\n            for (u, v) in edges:\n                for (scoreA, a) in graph[u]:\n                    for (scoreB, b) in graph[v]:\n                        if a != b and a != v and (b != u):\n                            ans = max(ans, scoreA + scores[u] + scores[v] + scoreB)\n            return ans\n    solution = Solution()\n    scores = [1, 2, 3]\n    edges = [[0, 1], [1, 2]]\n    assert solution.maximumScore(scores, edges) == 9", "def test_maximumScore():\n\n    class Solution:\n\n        def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\n            n = len(scores)\n            ans = -1\n            graph = [[] for _ in range(n)]\n            for (u, v) in edges:\n                graph[u].append((scores[v], v))\n                graph[v].append((scores[u], u))\n            for i in range(n):\n                graph[i] = heapq.nlargest(3, graph[i])\n            for (u, v) in edges:\n                for (scoreA, a) in graph[u]:\n                    for (scoreB, b) in graph[v]:\n                        if a != b and a != v and (b != u):\n                            ans = max(ans, scoreA + scores[u] + scores[v] + scoreB)\n            return ans\n    solution = Solution()\n    scores = [4, 3, 2]\n    edges = [[0, 1], [1, 2]]\n    assert solution.maximumScore(scores, edges) == 11", "def test_maximumScore():\n\n    class Solution:\n\n        def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\n            n = len(scores)\n            ans = -1\n            graph = [[] for _ in range(n)]\n            for (u, v) in edges:\n                graph[u].append((scores[v], v))\n                graph[v].append((scores[u], u))\n            for i in range(n):\n                graph[i] = heapq.nlargest(3, graph[i])\n            for (u, v) in edges:\n                for (scoreA, a) in graph[u]:\n                    for (scoreB, b) in graph[v]:\n                        if a != b and a != v and (b != u):\n                            ans = max(ans, scoreA + scores[u] + scores[v] + scoreB)\n            return ans\n    solution = Solution()\n    scores = [10, 1, 2]\n    edges = [[0, 1], [1, 2]]\n    assert solution.maximumScore(scores, edges) == 14", "def test_maximumScore():\n\n    class Solution:\n\n        def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\n            n = len(scores)\n            ans = -1\n            graph = [[] for _ in range(n)]\n            for (u, v) in edges:\n                graph[u].append((scores[v], v))\n                graph[v].append((scores[u], u))\n            for i in range(n):\n                graph[i] = heapq.nlargest(3, graph[i])\n            for (u, v) in edges:\n                for (scoreA, a) in graph[u]:\n                    for (scoreB, b) in graph[v]:\n                        if a != b and a != v and (b != u):\n                            ans = max(ans, scoreA + scores[u] + scores[v] + scoreB)\n            return ans\n    solution = Solution()\n    scores = [3, 4, 5]\n    edges = [[0, 1], [1, 2]]\n    assert solution.maximumScore(scores, edges) == 17", "def test_maximumScore():\n\n    class Solution:\n\n        def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\n            n = len(scores)\n            ans = -1\n            graph = [[] for _ in range(n)]\n            for (u, v) in edges:\n                graph[u].append((scores[v], v))\n                graph[v].append((scores[u], u))\n            for i in range(n):\n                graph[i] = heapq.nlargest(3, graph[i])\n            for (u, v) in edges:\n                for (scoreA, a) in graph[u]:\n                    for (scoreB, b) in graph[v]:\n                        if a != b and a != v and (b != u):\n                            ans = max(ans, scoreA + scores[u] + scores[v] + scoreB)\n            return ans\n    solution = Solution()\n    scores = [2, 5, 3]\n    edges = [[0, 1], [1, 2]]\n    assert solution.maximumScore(scores, edges) == 13", "def test_maximumScore():\n\n    class Solution:\n\n        def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\n            n = len(scores)\n            ans = -1\n            graph = [[] for _ in range(n)]\n            for (u, v) in edges:\n                graph[u].append((scores[v], v))\n                graph[v].append((scores[u], u))\n            for i in range(n):\n                graph[i] = heapq.nlargest(3, graph[i])\n            for (u, v) in edges:\n                for (scoreA, a) in graph[u]:\n                    for (scoreB, b) in graph[v]:\n                        if a != b and a != v and (b != u):\n                            ans = max(ans, scoreA + scores[u] + scores[v] + scoreB)\n            return ans\n    solution = Solution()\n    scores = [1, 1, 1]\n    edges = [[0, 1], [1, 2]]\n    assert solution.maximumScore(scores, edges) == 6", "def test_maximumScore():\n\n    class Solution:\n\n        def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\n            n = len(scores)\n            ans = -1\n            graph = [[] for _ in range(n)]\n            for (u, v) in edges:\n                graph[u].append((scores[v], v))\n                graph[v].append((scores[u], u))\n            for i in range(n):\n                graph[i] = heapq.nlargest(3, graph[i])\n            for (u, v) in edges:\n                for (scoreA, a) in graph[u]:\n                    for (scoreB, b) in graph[v]:\n                        if a != b and a != v and (b != u):\n                            ans = max(ans, scoreA + scores[u] + scores[v] + scoreB)\n            return ans\n    solution = Solution()\n    scores = [10, 5, 1]\n    edges = [[0, 1], [1, 2]]\n    assert solution.maximumScore(scores, edges) == 14", "def test_maximumScore():\n\n    class Solution:\n\n        def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\n            n = len(scores)\n            ans = -1\n            graph = [[] for _ in range(n)]\n            for (u, v) in edges:\n                graph[u].append((scores[v], v))\n                graph[v].append((scores[u], u))\n            for i in range(n):\n                graph[i] = heapq.nlargest(3, graph[i])\n            for (u, v) in edges:\n                for (scoreA, a) in graph[u]:\n                    for (scoreB, b) in graph[v]:\n                        if a != b and a != v and (b != u):\n                            ans = max(ans, scoreA + scores[u] + scores[v] + scoreB)\n            return ans\n    solution = Solution()\n    scores = [5, 3, 4]\n    edges = [[0, 1], [1, 2]]\n    assert solution.maximumScore(scores, edges) == 16", "def test_maximumScore():\n\n    class Solution:\n\n        def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\n            n = len(scores)\n            ans = -1\n            graph = [[] for _ in range(n)]\n            for (u, v) in edges:\n                graph[u].append((scores[v], v))\n                graph[v].append((scores[u], u))\n            for i in range(n):\n                graph[i] = heapq.nlargest(3, graph[i])\n            for (u, v) in edges:\n                for (scoreA, a) in graph[u]:\n                    for (scoreB, b) in graph[v]:\n                        if a != b and a != v and (b != u):\n                            ans = max(ans, scoreA + scores[u] + scores[v] + scoreB)\n            return ans\n    solution = Solution()\n    scores = [1, 2, 3]\n    edges = [[0, 1], [1, 2]]\n    assert solution.maximumScore(scores, edges) == 9", "def test_maximumScore():\n\n    class Solution:\n\n        def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\n            n = len(scores)\n            ans = -1\n            graph = [[] for _ in range(n)]\n            for (u, v) in edges:\n                graph[u].append((scores[v], v))\n                graph[v].append((scores[u], u))\n            for i in range(n):\n                graph[i] = heapq.nlargest(3, graph[i])\n            for (u, v) in edges:\n                for (scoreA, a) in graph[u]:\n                    for (scoreB, b) in graph[v]:\n                        if a != b and a != v and (b != u):\n                            ans = max(ans, scoreA + scores[u] + scores[v] + scoreB)\n            return ans\n    solution = Solution()\n    scores = [3, 2, 4]\n    edges = [[0, 1], [1, 2]]\n    assert solution.maximumScore(scores, edges) == 13", "def test_maximumScore():\n\n    class Solution:\n\n        def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\n            n = len(scores)\n            ans = -1\n            graph = [[] for _ in range(n)]\n            for (u, v) in edges:\n                graph[u].append((scores[v], v))\n                graph[v].append((scores[u], u))\n            for i in range(n):\n                graph[i] = heapq.nlargest(3, graph[i])\n            for (u, v) in edges:\n                for (scoreA, a) in graph[u]:\n                    for (scoreB, b) in graph[v]:\n                        if a != b and a != v and (b != u):\n                            ans = max(ans, scoreA + scores[u] + scores[v] + scoreB)\n            return ans\n    solution = Solution()\n    scores = [1, 3, 2]\n    edges = [[0, 1], [1, 2]]\n    assert solution.maximumScore(scores, edges) == 8", "def test_maximumScore():\n\n    class Solution:\n\n        def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\n            n = len(scores)\n            ans = -1\n            graph = [[] for _ in range(n)]\n            for (u, v) in edges:\n                graph[u].append((scores[v], v))\n                graph[v].append((scores[u], u))\n            for i in range(n):\n                graph[i] = heapq.nlargest(3, graph[i])\n            for (u, v) in edges:\n                for (scoreA, a) in graph[u]:\n                    for (scoreB, b) in graph[v]:\n                        if a != b and a != v and (b != u):\n                            ans = max(ans, scoreA + scores[u] + scores[v] + scoreB)\n            return ans\n    solution = Solution()\n    scores = [4, 3, 2]\n    edges = [[0, 1], [1, 2]]\n    assert solution.maximumScore(scores, edges) == 12", "def test_maximumScore():\n\n    class Solution:\n\n        def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\n            n = len(scores)\n            ans = -1\n            graph = [[] for _ in range(n)]\n            for (u, v) in edges:\n                graph[u].append((scores[v], v))\n                graph[v].append((scores[u], u))\n            for i in range(n):\n                graph[i] = heapq.nlargest(3, graph[i])\n            for (u, v) in edges:\n                for (scoreA, a) in graph[u]:\n                    for (scoreB, b) in graph[v]:\n                        if a != b and a != v and (b != u):\n                            ans = max(ans, scoreA + scores[u] + scores[v] + scoreB)\n            return ans\n    solution = Solution()\n    scores = [2, 5, 4]\n    edges = [[0, 1], [1, 2]]\n    assert solution.maximumScore(scores, edges) == 15", "def test_maximumScore():\n\n    class Solution:\n\n        def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\n            n = len(scores)\n            ans = -1\n            graph = [[] for _ in range(n)]\n            for (u, v) in edges:\n                graph[u].append((scores[v], v))\n                graph[v].append((scores[u], u))\n            for i in range(n):\n                graph[i] = heapq.nlargest(3, graph[i])\n            for (u, v) in edges:\n                for (scoreA, a) in graph[u]:\n                    for (scoreB, b) in graph[v]:\n                        if a != b and a != v and (b != u):\n                            ans = max(ans, scoreA + scores[u] + scores[v] + scoreB)\n            return ans\n    solution = Solution()\n    scores = [1, 4, 2]\n    edges = [[0, 1], [1, 2]]\n    assert solution.maximumScore(scores, edges) == 10"]}
{"task_num": 2245, "task_title": "Maximum Trailing Zeros in a Cornered Path", "func_name": "maxTrailingZeros", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxTrailingZeros(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    leftPrefix2 = [[0] * n for _ in range(m)]\n    leftPrefix5 = [[0] * n for _ in range(m)]\n    topPrefix2 = [[0] * n for _ in range(m)]\n    topPrefix5 = [[0] * n for _ in range(m)]\n\n    def getCount(num: int, factor: int) -> int:\n      count = 0\n      while num % factor == 0:\n        num //= factor\n        count += 1\n      return count\n\n    for i in range(m):\n      for j in range(n):\n        leftPrefix2[i][j] = getCount(grid[i][j], 2)\n        leftPrefix5[i][j] = getCount(grid[i][j], 5)\n        if j:\n          leftPrefix2[i][j] += leftPrefix2[i][j - 1]\n          leftPrefix5[i][j] += leftPrefix5[i][j - 1]\n\n    for j in range(n):\n      for i in range(m):\n        topPrefix2[i][j] = getCount(grid[i][j], 2)\n        topPrefix5[i][j] = getCount(grid[i][j], 5)\n        if i:\n          topPrefix2[i][j] += topPrefix2[i - 1][j]\n          topPrefix5[i][j] += topPrefix5[i - 1][j]\n\n    ans = 0\n    for i in range(m):\n      for j in range(n):\n        curr2 = getCount(grid[i][j], 2)\n        curr5 = getCount(grid[i][j], 5)\n        l2 = leftPrefix2[i][j]\n        l5 = leftPrefix5[i][j]\n        r2 = leftPrefix2[i][n - 1] - (0 if j == 0 else leftPrefix2[i][j - 1])\n        r5 = leftPrefix5[i][n - 1] - (0 if j == 0 else leftPrefix5[i][j - 1])\n        t2 = topPrefix2[i][j]\n        t5 = topPrefix5[i][j]\n        d2 = topPrefix2[m - 1][j] - (0 if i == 0 else topPrefix2[i - 1][j])\n        d5 = topPrefix5[m - 1][j] - (0 if i == 0 else topPrefix5[i - 1][j])\n        ans = max(ans, min(l2 + t2 - curr2, l5 + t5 - curr5), min(r2 + t2 - curr2, r5 + t5 - curr5), min(l2 + d2 - curr2, l5 + d5 - curr5), min(r2 + d2 - curr2, r5 + d5 - curr5))\n\n    return ans\n", "tests": ["def test_maxTrailingZeros(self):\n    solution = Solution()\n    grid = [[2, 1], [5, 4]]\n    self.assertEqual(solution.maxTrailingZeros(grid), 2)", "def test_maxTrailingZeros(self):\n    solution = Solution()\n    grid = [[1, 10], [3, 4]]\n    self.assertEqual(solution.maxTrailingZeros(grid), 0)", "def test_maxTrailingZeros(self):\n    solution = Solution()\n    grid = [[5, 25, 10], [1, 20, 3]]\n    self.assertEqual(solution.maxTrailingZeros(grid), 4)", "def test_maxTrailingZeros(self):\n    solution = Solution()\n    grid = [[10, 1], [5, 100]]\n    self.assertEqual(solution.maxTrailingZeros(grid), 2)", "def test_maxTrailingZeros(self):\n    solution = Solution()\n    grid = [[10000, 0], [1, 5]]\n    self.assertEqual(solution.maxTrailingZeros(grid), 3)", "def test_maxTrailingZeros(self):\n    solution = Solution()\n    grid = [[0, 1], [5, 10]]\n    self.assertEqual(solution.maxTrailingZeros(grid), 0)", "def test_maxTrailingZeros(self):\n    solution = Solution()\n    grid = [[2 ** 20, 1], [3, 4]]\n    self.assertEqual(solution.maxTrailingZeros(grid), 20)", "def test_maxTrailingZeros(self):\n    solution = Solution()\n    grid = [[5 ** 10, 1], [3, 4]]\n    self.assertEqual(solution.maxTrailingZeros(grid), 10)", "def test_maxTrailingZeros(self):\n    solution = Solution()\n    grid = [[2 ** 20, 5 ** 10], [3, 4]]\n    self.assertEqual(solution.maxTrailingZeros(grid), 20)", "def test_maxTrailingZeros(self):\n    solution = Solution()\n    grid = [[2 ** 20, 0], [3, 4]]\n    self.assertEqual(solution.maxTrailingZeros(grid), 20)", "def test_maxTrailingZeros(self):\n    solution = Solution()\n    grid = [[1, 2 ** 20], [3, 4]]\n    self.assertEqual(solution.maxTrailingZeros(grid), 20)", "def test_maxTrailingZeros(self):\n    solution = Solution()\n    grid = [[1, 2], [3, 2 ** 19]]\n    self.assertEqual(solution.maxTrailingZeros(grid), 19)", "def test_maxTrailingZeros(self):\n    solution = Solution()\n    grid = [[5 ** 10, 2 ** 20], [3, 4]]\n    self.assertEqual(solution.maxTrailingZeros(grid), 20)", "def test_maxTrailingZeros(self):\n    solution = Solution()\n    grid = [[2 ** 10, 5 ** 9], [3, 4]]\n    self.assertEqual(solution.maxTrailingZeros(grid), 20)", "def test_maxTrailingZeros(self):\n    solution = Solution()\n    grid = [[1, 2], [5 ** 8, 3]]\n    self.assertEqual(solution.maxTrailingZeros(grid), 8)", "def test_maxTrailingZeros(self):\n    solution = Solution()\n    grid = [[1 ** 10], [2 ** 9]]\n    self.assertEqual(solution.maxTrailingZeros(grid), 19)", "def test_maxTrailingZeros(self):\n    solution = Solution()\n    grid = [[5 ** 10, 1], [1, 2]]\n    self.assertEqual(solution.maxTrailingZeros(grid), 10)", "def test_maxTrailingZeros(self):\n    solution = Solution()\n    grid = [[2 ** 5, 5 ** 10], [3, 4]]\n    self.assertEqual(solution.maxTrailingZeros(grid), 20)", "def test_maxTrailingZeros(self):\n    solution = Solution()\n    grid = [[1], [2 ** 10, 5 ** 9]]\n    self.assertEqual(solution.maxTrailingZeros(grid), 20)", "def test_maxTrailingZeros(self):\n    solution = Solution()\n    grid = [[2 ** 10], [5 ** 9, 3]]\n    self.assertEqual(solution.maxTrailingZeros(grid), 20)"]}
{"task_num": 2257, "task_title": "Count Unguarded Cells in the Grid", "func_name": "countUnguarded", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\n    ans = 0\n    grid = [[0] * n for _ in range(m)]\n    left = [[0] * n for _ in range(m)]\n    right = [[0] * n for _ in range(m)]\n    up = [[0] * n for _ in range(m)]\n    down = [[0] * n for _ in range(m)]\n\n    for row, col in guards:\n      grid[row][col] = 'G'\n\n    for row, col in walls:\n      grid[row][col] = 'W'\n\n    for i in range(m):\n      lastCell = 0\n      for j in range(n):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          left[i][j] = lastCell\n      lastCell = 0\n      for j in range(n - 1, -1, -1):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          right[i][j] = lastCell\n\n    for j in range(n):\n      lastCell = 0\n      for i in range(m):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          up[i][j] = lastCell\n      lastCell = 0\n      for i in range(m - 1, -1, -1):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          down[i][j] = lastCell\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 0 and left[i][j] != 'G' and right[i][j] != 'G' and up[i][j] != 'G' and down[i][j] != 'G':\n          ans += 1\n\n    return ans\n", "tests": ["def test_countUnguarded():\n    solution = Solution()\n    (m, n) = (4, 6)\n    guards = [[0, 1], [1, 2]]\n    walls = [[1, 1], [2, 2], [3, 3]]\n    assert solution.countUnguarded(m, n, guards, walls) == 8", "def test_countUnguarded():\n    solution = Solution()\n    (m, n) = (0, 0)\n    guards = []\n    walls = []\n    assert solution.countUnguarded(m, n, guards, walls) == 0", "def test_countUnguarded():\n    solution = Solution()\n    (m, n) = (100, 100)\n    guards = [[50, 50], [75, 75]]\n    walls = []\n    assert solution.countUnguarded(m, n, guards, walls) == (m - 1) * (n - 1)", "def test_countUnguarded():\n    solution = Solution()\n    (m, n) = (3, 4)\n    guards = [[0, 1], [2, 1]]\n    walls = [[1, 1], [2, 2]]\n    assert solution.countUnguarded(m, n, guards, walls) == 6", "def test_countUnguarded():\n    solution = Solution()\n    (m, n) = (3, 4)\n    guards = [[1, 2]]\n    walls = [[0, 2], [1, 2], [2, 2]]\n    assert solution.countUnguarded(m, n, guards, walls) == 6", "def test_countUnguarded():\n    solution = Solution()\n    (m, n) = (3, 4)\n    guards = []\n    walls = []\n    assert solution.countUnguarded(m, n, guards, walls) == (m - 1) * (n - 1)", "def test_countUnguarded():\n    solution = Solution()\n    (m, n) = (1, 1)\n    guards = [[0, 0]]\n    walls = []\n    assert solution.countUnguarded(m, n, guards, walls) == (m - 1) * (n - 1)", "def test_countUnguarded():\n    solution = Solution()\n    (m, n) = (5, 5)\n    guards = [[0, 0], [4, 4]]\n    walls = []\n    assert solution.countUnguarded(m, n, guards, walls) == (m - 1) * (n - 2)", "def test_countUnguarded():\n    solution = Solution()\n    (m, n) = (0, 0)\n    guards = []\n    walls = []\n    assert solution.countUnguarded(m, n, guards, walls) == 0", "def test_countUnguarded():\n    solution = Solution()\n    (m, n) = (3, 4)\n    guards = [[1, 2]]\n    walls = []\n    assert solution.countUnguarded(m, n, guards, walls) == (m - 1) * (n - 1)", "def test_countUnguarded():\n    solution = Solution()\n    (m, n) = (5, 5)\n    guards = []\n    walls = [[0, 0], [1, 1], [2, 2], [3, 3], [4, 4]]\n    assert solution.countUnguarded(m, n, guards, walls) == 16", "def test_countUnguarded():\n    solution = Solution()\n    (m, n) = (5, 5)\n    guards = [[2, 3]]\n    walls = []\n    assert solution.countUnguarded(m, n, guards, walls) == (m - 1) * (n - 1)", "def test_countUnguarded():\n    solution = Solution()\n    (m, n) = (3, 4)\n    guards = [[0, 1], [2, 1]]\n    walls = []\n    assert solution.countUnguarded(m, n, guards, walls) == (m - 1) * (n - 2)", "def test_countUnguarded():\n    solution = Solution()\n    (m, n) = (3, 3)\n    guards = [[0, 0]]\n    walls = []\n    assert solution.countUnguarded(m, n, guards, walls) == (m - 1) * (n - 2)", "def test_countUnguarded():\n    solution = Solution()\n    (m, n) = (5, 3)\n    guards = [[1, 0], [1, 1]]\n    walls = []\n    assert solution.countUnguarded(m, n, guards, walls) == (m - 1) * (n - 2)", "def test_countUnguarded():\n    solution = Solution()\n    (m, n) = (1000, 1000)\n    guards = [[500, 500], [750, 750]]\n    walls = []\n    assert solution.countUnguarded(m, n, guards, walls) == (m - 1) * (n - 2)", "def test_countUnguarded():\n    solution = Solution()\n    (m, n) = (3, 5)\n    guards = [[0, 2], [1, 2]]\n    walls = []\n    assert solution.countUnguarded(m, n, guards, walls) == (m - 2) * (n - 1)", "def test_countUnguarded():\n    solution = Solution()\n    (m, n) = (5, 5)\n    guards = [[2, 3]]\n    walls = [[0, 1], [4, 4]]\n    assert solution.countUnguarded(m, n, guards, walls) == (m - 2) * (n - 2)", "def test_countUnguarded():\n    solution = Solution()\n    (m, n) = (7, 9)\n    guards = [[3, 5]]\n    walls = []\n    assert solution.countUnguarded(m, n, guards, walls) == (m - 2) * (n - 2)", "def test_countUnguarded():\n    solution = Solution()\n    (m, n) = (0, 0)\n    guards = [[1, 2]]\n    walls = [[0, 0], [1, 1]]\n    assert solution.countUnguarded(m, n, guards, walls) == 0"]}
{"task_num": 2258, "task_title": "Escape the Spreading Fire", "func_name": "maximumMinutes", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumMinutes(self, grid: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    kMax = len(grid) * len(grid[0])\n    fireGrid = [[-1] * len(grid[0]) for _ in range(len(grid))]\n    self._buildFireGrid(grid, fireGrid, dirs)\n\n    ans = -1\n    l = 0\n    r = kMax\n\n    while l <= r:\n      m = (l + r) // 2\n      if self._canStayFor(grid, fireGrid, m, dirs):\n        ans = m\n        l = m + 1\n      else:\n        r = m - 1\n\n    return int(1e9) if ans == kMax else ans\n\n  def _buildFireGrid(self, grid: List[List[int]], fireMinute: List[List[int]], dirs: List[int]) -> None:\n    minuteFromFire = 0\n    q = collections.deque()\n\n    for i in range(len(grid)):\n      for j in range(len(grid[0])):\n        if grid[i][j] == 1:\n          q.append((i, j))\n          fireMinute[i][j] = 0\n    while q:\n      minuteFromFire += 1\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == len(grid) or y < 0 or y == len(grid[0]):\n            continue\n          if grid[x][y] == 2:\n            continue\n          if fireMinute[x][y] != -1:\n            continue\n          fireMinute[x][y] = minuteFromFire\n          q.append((x, y))\n\n  def _canStayFor(self, grid: List[List[int]], fireMinute: List[List[int]], minute: int, dirs: List[int]) -> bool:\n    q = collections.deque([(0, 0)])\n    seen = {(0, 0)}\n\n    while q:\n      minute += 1\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == len(grid) or y < 0 or y == len(grid[0]):\n            continue\n          if grid[x][y] == 2:\n            continue\n          if x == len(grid) - 1 and y == len(grid[0]) - 1:\n            if fireMinute[x][y] != -1 and fireMinute[x][y] < minute:\n              continue\n            return True\n          if fireMinute[x][y] != -1 and fireMinute[x][y] <= minute:\n            continue\n          if (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n\n    return False\n", "tests": ["def test_maximumMinutes():\n    solution = Solution()\n    grid = [[2, 0]]\n    assert solution.maximumMinutes(grid) == -1", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 2]]\n    assert solution.maximumMinutes(grid) == -1", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 2, 1]]\n    assert solution.maximumMinutes(grid) == -1", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 1], [2, 0]]\n    assert solution.maximumMinutes(grid) == 109", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 1], [2, 2]]\n    assert solution.maximumMinutes(grid) == -1", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 0], [2, 1]]\n    assert solution.maximumMinutes(grid) == -1", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 2, 1], [0, 2, 1]]\n    assert solution.maximumMinutes(grid) == -1", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 2], [2, 1]]\n    assert solution.maximumMinutes(grid) == -1", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 2], [1, 2]]\n    assert solution.maximumMinutes(grid) == -1", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 2], [2, 1], [0, 1]]\n    assert solution.maximumMinutes(grid) == -1", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 2], [1, 2], [1, 2]]\n    assert solution.maximumMinutes(grid) == -1", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[2, 0], [0, 1]]\n    assert solution.maximumMinutes(grid) == -1", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 2], [0, 1], [1, 0]]\n    assert solution.maximumMinutes(grid) == -1", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[2, 2], [0, 1]]\n    assert solution.maximumMinutes(grid) == -1", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 2], [1, 2], [0, 2]]\n    assert solution.maximumMinutes(grid) == -1", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[2, 0], [0, 1]]\n    assert solution.maximumMinutes(grid) == -1", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[2, 0], [1, 2]]\n    assert solution.maximumMinutes(grid) == -1", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[2, 0], [0, 1], [1, 1]]\n    assert solution.maximumMinutes(grid) == -1", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[2, 0], [0, 1], [1, 0]]\n    assert solution.maximumMinutes(grid) == -1", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 2], [2, 1], [2, 0]]\n    assert solution.maximumMinutes(grid) == -1"]}
{"task_num": 2290, "task_title": "Minimum Obstacle Removal to Reach Corner", "func_name": "minimumObstacles", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumObstacles(self, grid: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    minHeap = [(grid[0][0], 0, 0)]  # (d, i, j)\n    dist = [[math.inf] * n for _ in range(m)]\n    dist[0][0] = grid[0][0]\n\n    while minHeap:\n      d, i, j = heapq.heappop(minHeap)\n      if i == m - 1 and j == n - 1:\n        return d\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        newDist = d + grid[i][j]\n        if newDist < dist[x][y]:\n          dist[x][y] = newDist\n          heapq.heappush(minHeap, (newDist, x, y))\n\n    return dist[m - 1][n - 1]\n", "tests": ["def test_minimumObstacles(self):\n    solution = Solution()\n    grid = [[0, 0], [0, 0]]\n    self.assertEqual(solution.minimumObstacles(grid), 0)", "def test_minimumObstacles(self):\n    solution = Solution()\n    grid = [[1, 0], [0, 1]]\n    self.assertEqual(solution.minimumObstacles(grid), 2)", "def test_minimumObstacles(self):\n    solution = Solution()\n    grid = [[0, 1, 0], [0, 0, 0]]\n    self.assertEqual(solution.minimumObstacles(grid), 1)", "def test_minimumObstacles(self):\n    solution = Solution()\n    grid = [[1, 0, 0], [0, 1, 0]]\n    self.assertEqual(solution.minimumObstacles(grid), 2)", "def test_minimumObstacles(self):\n    solution = Solution()\n    grid = [[1, 0, 0], [1, 0, 1]]\n    self.assertEqual(solution.minimumObstacles(grid), 3)", "def test_minimumObstacles(self):\n    solution = Solution()\n    grid = [[1, 1, 0], [0, 0, 0]]\n    self.assertEqual(solution.minimumObstacles(grid), 2)", "def test_minimumObstacles(self):\n    solution = Solution()\n    grid = [[1, 1, 0], [1, 1, 1]]\n    self.assertEqual(solution.minimumObstacles(grid), 3)", "def test_minimumObstacles(self):\n    solution = Solution()\n    grid = [[1, 0, 1], [1, 1, 1]]\n    self.assertEqual(solution.minimumObstacles(grid), 3)", "def test_minimumObstacles(self):\n    solution = Solution()\n    grid = [[1, 0, 1], [0, 0, 1]]\n    self.assertEqual(solution.minimumObstacles(grid), 2)", "def test_minimumObstacles(self):\n    solution = Solution()\n    grid = [[1] * 10, [0] * 10]\n    self.assertEqual(solution.minimumObstacles(grid), 10)", "def test_minimumObstacles(self):\n    solution = Solution()\n    grid = [[1] * 5, [1] * 5]\n    self.assertEqual(solution.minimumObstacles(grid), 10)", "def test_minimumObstacles(self):\n    solution = Solution()\n    grid = [[1] * 10, [1] * 5, [0] * 5]\n    self.assertEqual(solution.minimumObstacles(grid), 15)", "def test_minimumObstacles(self):\n    solution = Solution()\n    grid = [[1] * 5, [0] * 10]\n    self.assertEqual(solution.minimumObstacles(grid), 5)", "def test_minimumObstacles(self):\n    solution = Solution()\n    grid = [[1] * 3, [1] * 3, [0] * 3]\n    self.assertEqual(solution.minimumObstacles(grid), 6)", "def test_minimumObstacles(self):\n    solution = Solution()\n    grid = [[1] * 2, [1, 0]]\n    self.assertEqual(solution.minimumObstacles(grid), 3)", "def test_minimumObstacles(self):\n    solution = Solution()\n    grid = [[0] * 3, [1, 0], [0, 0]]\n    self.assertEqual(solution.minimumObstacles(grid), 1)", "def test_minimumObstacles(self):\n    solution = Solution()\n    grid = [[1, 0, 0], [1, 1, 0], [1, 0, 1]]\n    self.assertEqual(solution.minimumObstacles(grid), 4)", "def test_minimumObstacles(self):\n    solution = Solution()\n    grid = [[1] * 5, [0] * 2, [1] * 3]\n    self.assertEqual(solution.minimumObstacles(grid), 8)", "def test_minimumObstacles(self):\n    solution = Solution()\n    grid = [[1] * 2, [0, 1], [1, 1]]\n    self.assertEqual(solution.minimumObstacles(grid), 4)", "def test_minimumObstacles(self):\n    solution = Solution()\n    grid = [[1] * 3, [1, 0], [1] * 2]\n    self.assertEqual(solution.minimumObstacles(grid), 6)"]}
{"task_num": 2299, "task_title": "Strong Password Checker II", "func_name": "strongPasswordCheckerII", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def strongPasswordCheckerII(self, password: str) -> bool:\n    if len(password) < 8:\n      return False\n    if not any(c.islower() for c in password):\n      return False\n    if not any(c.isupper() for c in password):\n      return False\n    if not any(c.isdigit() for c in password):\n      return False\n    if not any(\"!@#$%^&*()-+\".find(c) != -1 for c in password):\n      return False\n    return all(a != b for a, b in zip(password, password[1:]))\n", "tests": ["def test_strongPasswordCheckerII():\n    solution = Solution()\n    print(solution.strongPasswordCheckerII('A1b2C3!4@5#6$7^8&9*0(-+)'))", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    print(solution.strongPasswordCheckerII('1234567890123456'))", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    print(solution.strongPasswordCheckerII('aA1!'))", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    print(solution.strongPasswordCheckerII('abcdefg'))", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    print(solution.strongPasswordCheckerII('abAB123!@#'))", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    print(solution.strongPasswordCheckerII('abcdEFGH'))", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    print(solution.strongPasswordCheckerII('123456789012345678901234567890'))", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    print(solution.strongPasswordCheckerII('aabbcc'))", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    print(solution.strongPasswordCheckerII('A123!@#A'))", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    print(solution.strongPasswordCheckerII('!@#$%^&*()'))", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    print(solution.strongPasswordCheckerII('aaaaaaaaaaaaaa'))", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    print(solution.strongPasswordCheckerII('9!@#$%^&*()-+'))", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    print(solution.strongPasswordCheckerII('A9!@#$%^&*()-+a'))", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    print(solution.strongPasswordCheckerII('aA1!2@3#4$5^6&7*8(-+)9'))", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    print(solution.strongPasswordCheckerII('aA1!2@3#4$5^6&7*8(-+)90'))", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    print(solution.strongPasswordCheckerII('1234567890123456789012345678901234567890'))", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    print(solution.strongPasswordCheckerII('aA1!2@3#4$5^6&7*8(-+)901234567890123456789012345678901'))", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    print(solution.strongPasswordCheckerII('aA1!2@3#4$5^6&7*8(-+)901234567890123456789012345678901234567890'))", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    print(solution.strongPasswordCheckerII('aaaaaaaaaaaaaa123456789012345678901234567890'))", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    print(solution.strongPasswordCheckerII('abAB123!@#aaaaaa'))"]}
{"task_num": 2301, "task_title": "Match Substring After Replacement", "func_name": "matchReplacement", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def matchReplacement(self, s: str, sub: str, mappings: List[List[str]]) -> bool:\n    isMapped = [[False] * 128 for _ in range(128)]\n\n    for old, new in mappings:\n      isMapped[ord(old)][ord(new)] = True\n\n    for i in range(len(s)):\n      if self._canTransform(s, i, sub, isMapped):\n        return True\n\n    return False\n\n  def _canTransform(self, s: str, start: int, sub: str, isMapped: List[List[bool]]) -> bool:\n    if start + len(sub) > len(s):\n      return False\n\n    for i in range(len(sub)):\n      a = sub[i]\n      b = s[start + i]\n      if a != b and not isMapped[ord(a)][ord(b)]:\n        return False\n\n    return True\n", "tests": ["def test_matchReplacement():\n    solution = Solution()\n    s = 'abc'\n    sub = 'ecc'\n    mappings = [['a', 'e'], ['b', 'c']]\n    assert solution.matchReplacement(s, sub, mappings) == True", "def test_matchReplacement():\n    solution = Solution()\n    s = 'aaa'\n    sub = 'aab'\n    mappings = [['a', 'b']]\n    assert solution.matchReplacement(s, sub, mappings) == False", "def test_matchReplacement():\n    solution = Solution()\n    s = 'xyz'\n    sub = 'abc'\n    mappings = [['a', 'x'], ['b', 'y']]\n    assert solution.matchReplacement(s, sub, mappings) == False", "def test_matchReplacement():\n    solution = Solution()\n    s = 'a'\n    sub = 'b'\n    mappings = [['a', 'c']]\n    assert solution.matchReplacement(s, sub, mappings) == False", "def test_matchReplacement():\n    solution = Solution()\n    s = 'abcdef'\n    sub = 'abcdeX'\n    mappings = [['a', 'a'], ['b', 'b'], ['c', 'c'], ['d', 'd']]\n    assert solution.matchReplacement(s, sub, mappings) == False", "def test_matchReplacement():\n    solution = Solution()\n    s = 'ab'\n    sub = 'abc'\n    mappings = [['a', 'c']]\n    assert solution.matchReplacement(s, sub, mappings) == False", "def test_matchReplacement():\n    solution = Solution()\n    s = 'abcd'\n    sub = 'abcde'\n    mappings = [['a', 'b'], ['c', 'd']]\n    assert solution.matchReplacement(s, sub, mappings) == False", "def test_matchReplacement():\n    solution = Solution()\n    s = 'abc'\n    sub = 'ab'\n    mappings = [['a', 'b']]\n    assert solution.matchReplacement(s, sub, mappings) == True", "def test_matchReplacement():\n    solution = Solution()\n    s = 'abcdef'\n    sub = 'ab'\n    mappings = [['a', 'c']]\n    assert solution.matchReplacement(s, sub, mappings) == True", "def test_matchReplacement():\n    solution = Solution()\n    s = 'abcd'\n    sub = 'ab'\n    mappings = [['a', 'b'], ['c', 'd']]\n    assert solution.matchReplacement(s, sub, mappings) == True", "def test_matchReplacement():\n    solution = Solution()\n    s = ''\n    sub = 'abc'\n    mappings = [['a', 'b'], ['b', 'c']]\n    assert solution.matchReplacement(s, sub, mappings) == False", "def test_matchReplacement():\n    solution = Solution()\n    s = 'aaaaaa'\n    sub = 'aabbb'\n    mappings = [['a', 'b'], ['b', 'c']]\n    assert solution.matchReplacement(s, sub, mappings) == False", "def test_matchReplacement():\n    solution = Solution()\n    s = 'abc'\n    sub = 'ab'\n    mappings = [['a', 'b'], ['c', 'd']]\n    assert solution.matchReplacement(s, sub, mappings) == True", "def test_matchReplacement():\n    solution = Solution()\n    s = 'abcdef'\n    sub = 'abcde'\n    mappings = [['a', 'b'], ['c', 'd']]\n    assert solution.matchReplacement(s, sub, mappings) == False", "def test_matchReplacement():\n    solution = Solution()\n    s = 'a'\n    sub = 'b'\n    mappings = [['a', 'c']]\n    assert solution.matchReplacement(s, sub, mappings) == False", "def test_matchReplacement():\n    solution = Solution()\n    s = 'aaa'\n    sub = 'aab'\n    mappings = [['a', 'b'], ['b', 'c']]\n    assert solution.matchReplacement(s, sub, mappings) == False", "def test_matchReplacement():\n    solution = Solution()\n    s = 'ab'\n    sub = 'abc'\n    mappings = [['a', 'c']]\n    assert solution.matchReplacement(s, sub, mappings) == False", "def test_matchReplacement():\n    solution = Solution()\n    s = 'abc'\n    sub = 'abcd'\n    mappings = [['a', 'b'], ['c', 'd']]\n    assert solution.matchReplacement(s, sub, mappings) == False", "def test_matchReplacement():\n    solution = Solution()\n    s = 'abcd'\n    sub = 'abce'\n    mappings = [['a', 'c'], ['b', 'e']]\n    assert solution.matchReplacement(s, sub, mappings) == True", "def test_matchReplacement():\n    solution = Solution()\n    s = 'abcdef'\n    sub = 'abcde'\n    mappings = [['a', 'b'], ['c', 'd']]\n    assert solution.matchReplacement(s, sub, mappings) == False"]}
{"task_num": 2322, "task_title": "Minimum Score After Removals on a Tree", "func_name": "minimumScore", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Set\n\nclass Solution:\n  def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\n    n = len(nums)\n    xors = functools.reduce(lambda x, y: x ^ y, nums)\n    subXors = nums[:]\n    tree = [[] for _ in range(n)]\n    children = [{i} for i in range(n)]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, parent: int) -> Tuple[int, Set[int]]:\n      for v in tree[u]:\n        if v == parent:\n          continue\n        vXor, vChildren = dfs(v, u)\n        subXors[u] ^= vXor\n        children[u] |= vChildren\n      return subXors[u], children[u]\n\n    dfs(0, -1)\n\n    ans = math.inf\n    for i in range(len(edges)):\n      a, b = edges[i]\n      if b in children[a]:\n        a, b = b, a\n      for j in range(i):\n        c, d = edges[j]\n        if d in children[c]:\n          c, d = d, c\n\n        if c in children[a] and a != c:\n          cands = [subXors[c], subXors[a] ^ subXors[c], xors ^ subXors[a]]\n        elif a in children[c] and a != c:\n          cands = [subXors[a], subXors[c] ^ subXors[a], xors ^ subXors[c]]\n        else:\n          cands = [subXors[a], subXors[c], xors ^ subXors[a] ^ subXors[c]]\n        ans = min(ans, max(cands) - min(cands))\n\n    return ans\n", "tests": ["def test_minimumScore():\n\n    class TestMinimumScore(unittest.TestCase):\n\n        def test_example(self):\n            nums = [4, 5, 7, 1, 9, 3]\n            edges = [[0, 1], [1, 2], [1, 3], [3, 4], [1, 6]]\n            self.assertEqual(solution.minimumScore(nums, edges), 10)", "def test_minimumScore():\n\n    class TestMinimumScore(unittest.TestCase):\n\n        def test_example(self):\n            nums = [4, 5, 7, 1, 9, 3]\n            edges = [[0, 1], [1, 2], [1, 3], [3, 4], [1, 6]]\n            self.assertEqual(solution.minimumScore(nums, edges), 10)", "def test_minimumScore():\n\n    class TestMinimumScore(unittest.TestCase):\n\n        def test_example(self):\n            nums = [4, 5, 7, 1, 9, 3]\n            edges = [[0, 1], [1, 2], [1, 3], [3, 4], [1, 6]]\n            self.assertEqual(solution.minimumScore(nums, edges), 10)", "def test_minimumScore():\n\n    class TestMinimumScore(unittest.TestCase):\n\n        def test_example(self):\n            nums = [4, 5, 7, 1, 9, 3]\n            edges = [[0, 1], [1, 2], [1, 3], [3, 4], [1, 6]]\n            self.assertEqual(solution.minimumScore(nums, edges), 10)", "def test_minimumScore():\n\n    class TestMinimumScore(unittest.TestCase):\n\n        def test_example(self):\n            nums = [4, 5, 7, 1, 9, 3]\n            edges = [[0, 1], [1, 2], [1, 3], [3, 4], [1, 6]]\n            self.assertEqual(solution.minimumScore(nums, edges), 10)", "def test_minimumScore():\n\n    class TestMinimumScore(unittest.TestCase):\n\n        def test_example(self):\n            nums = [4, 5, 7, 1, 9, 3]\n            edges = [[0, 1], [1, 2], [1, 3], [3, 4], [1, 6]]\n            self.assertEqual(solution.minimumScore(nums, edges), 10)", "def test_minimumScore():\n\n    class TestMinimumScore(unittest.TestCase):\n\n        def test_example(self):\n            nums = [4, 5, 7, 1, 9, 3]\n            edges = [[0, 1], [1, 2], [1, 3], [3, 4], [1, 6]]\n            self.assertEqual(solution.minimumScore(nums, edges), 10)", "def test_minimumScore():\n\n    class TestMinimumScore(unittest.TestCase):\n\n        def test_example(self):\n            nums = [4, 5, 7, 1, 9, 3]\n            edges = [[0, 1], [1, 2], [1, 3], [3, 4], [1, 6]]\n            self.assertEqual(solution.minimumScore(nums, edges), 10)", "def test_minimumScore(self):\n    nums = [1] * 1000\n    edges = [(i, (i + 20) % 1000) for i in range(950)]\n    edges.append((0, 980))\n    edges.append((950, 970))\n    self.assertEqual(solution.minimumScore(nums, edges), math.inf)", "def test_minimumScore(self):\n    nums = [1] * 1000\n    edges = [(i, (i + 10) % 1000) for i in range(500)]\n    self.assertEqual(solution.minimumScore(nums, edges), math.inf)", "def test_minimumScore(self):\n    nums = [1] * 6\n    edges = [(0, 1), (0, 2), (1, 3), (2, 4), (3, 5)]\n    self.assertEqual(solution.minimumScore(nums, edges), 7)", "def test_minimumScore(self):\n    nums = [1] * 6\n    edges = [(0, 1), (1, 2), (2, 3), (3, 4), (5, 5)]\n    self.assertEqual(solution.minimumScore(nums, edges), math.inf)", "def test_minimumScore(self):\n    nums = []\n    edges = [(0, 1), (2, 3)]\n    with self.assertRaises(ValueError):\n        solution.minimumScore(nums, edges)", "def test_graph_with_zero_weight_edges(self):\n    nums = [1, 2, 3]\n    edges = [(0, 1), (1, 2)]\n    with self.assertRaises(ValueError):\n        solution(nums, edges)\n```\n\nThis test method checks that the function raises a `ValueError` when there are zero-weight edges in the graph. This is an important edge case because the algorithm relies on the weights of the edges to determine the minimum spanning tree.\n", "def test_graph_with_no_edges(self):\n    nums = [1, 2, 3]\n    edges = []\n    solution(nums, edges)\n```\n\nThis test method checks that the function does not raise an error when there are no edges in the graph. This is a valid input scenario and should be handled correctly by the function.\n\nAlternatively, you could also check that the output of the function is as expected in this case:\n\n```python\ndef test_graph_with_no_edges(self):\n    nums = [1, 2, 3]\n    edges = []\n    result = solution(nums, edges)\n    self.assertEqual(result, [])  # Assuming an empty list is returned for no edges\n```\n", "def test_graph_with_single_node(self):\n    nums = [1]\n    edges = [(0, 0)]  # self-loop edge\n    with self.assertRaises(ValueError):\n        solution(nums, edges)\n```\n\nThis test method checks that the function raises a `ValueError` when there is only one node in the graph and a self-loop edge is present. This is an invalid input scenario because a spanning tree cannot be formed with a single node.\n\nAlternatively, you could also check that the output of the function is as expected in this case:\n\n```python\ndef test_graph_with_single_node(self):\n    nums = [1]\n    edges = [(0, 0)]  # self-loop edge\n    result = solution(nums, edges)\n    self.assertEqual(result, [])  # Assuming an empty list is returned for a single node with self-loop edge\n```\n", "def test_graph_with_duplicate_edges(self):\n    nums = [1, 2]\n    edges = [(0, 1), (0, 1)]  # duplicate edge\n    with self.assertRaises(ValueError):\n        solution(nums, edges)\n```\n\nThis test method checks that the function raises a `ValueError` when there are duplicate edges in the graph. This is an invalid input scenario because it can lead to incorrect results.\n", "def test_graph_with_invalid_node_index(self):\n    nums = [1, 2]\n    edges = [(3, 0), (0, 1)]  # invalid node index in edge tuple\n    with self.assertRaises(ValueError):\n        solution(nums, edges)\n```\n\nThis test method checks that the function raises a `ValueError` when there are invalid node indices in the edge tuples. In this case, the edge `(3, 0)` has an invalid node index of 3 because it exceeds the number of nodes in the graph.\n\nAlternatively, you could also check that the output of the function is as expected in this case:\n\n```python\ndef test_graph_with_invalid_node_index(self):\n    nums = [1, 2]\n    edges = [(3, 0), (0, 1)]  # invalid node index in edge tuple\n    result = solution(nums, edges)\n    self.assertIsNone(result)  # Assuming None is returned for invalid node indices\n```\n", "def test_graph_with_negative_edge_weight(self):\n    nums = [1, 2]\n    edges = [(0, 1, -1)]  # negative edge weight\n    with self.assertRaises(ValueError):\n        solution(nums, edges)\n```\n\nThis test method checks that the function raises a `ValueError` when there are negative edge weights in the graph. In this case, the edge `(0, 1)` has a negative weight of `-1`, which is an invalid input.\n", "def test_graph_with_empty_input(self):\n    nums = []\n    edges = []\n    with self.assertRaises(ValueError):\n        solution(nums, edges)\n```\n\nThis test method checks that the function raises a `ValueError` when the input graph has no nodes and no edges. This is an edge case where the function should handle an empty graph.\n\nAlternatively, you could also check that the output of the function is as expected in this case:\n\n```python\ndef test_graph_with_empty_input(self):\n    nums = []\n    edges = []\n    result = solution(nums, edges)\n    self.assertEqual(result, [])  # Assuming an empty list is returned for an empty graph\n```\n"]}
{"task_num": 2332, "task_title": "The Latest Time to Catch a Bus", "func_name": "latestTimeCatchTheBus", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\n    buses.sort()\n    passengers.sort()\n\n    if passengers[0] > buses[-1]:\n      return buses[-1]\n\n    ans = passengers[0] - 1\n    i = 0\n    j = 0\n    while i < len(buses):\n      arrived = 0\n      while arrived < capacity and j < len(passengers) and passengers[j] <= buses[i]:\n        if j > 0 and passengers[j] != passengers[j - 1] + 1:\n          ans = passengers[j] - 1\n        j += 1\n        arrived += 1\n\n      if arrived < capacity and j > 0 and passengers[j - 1] != buses[i]:\n        ans = buses[i]\n      i += 1\n\n    return ans\n", "tests": ["def test_latestTimeCatchTheBus(self):\n  class Solution:\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\n      # function body remains the same as in the problem description\n\n  solution = Solution()\n  buses = [2,5,7]\n  passengers = [1,4,6]\n  capacity = 3\n  self.assertEqual(solution.latestTimeCatchTheBus(buses,passengers,capacity),11)", "def test_latestTimeCatchTheBus2(self):\n  class Solution:\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\n      # function body remains the same as in the problem description\n\n  solution = Solution()\n  buses = [1,3,5]\n  passengers = [2,6,8]\n  capacity = 4\n  self.assertEqual(solution.latestTimeCatchTheBus(buses,passengers,capacity),7)", "def test_latestTimeCatchTheBus3(self):\n  class Solution:\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\n      # function body remains the same as in the problem description\n\n  solution = Solution()\n  buses = [10,20]\n  passengers = [1,3,5,7]\n  capacity = 2\n  self.assertEqual(solution.latestTimeCatchTheBus(buses,passengers,capacity),13)", "def test_latestTimeCatchTheBus4(self):\n  class Solution:\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\n      # function body remains the same as in the problem description\n\n  solution = Solution()\n  buses = [23,30,39]\n  passengers = [1,2,4,8,9,12,19]\n  capacity = 3\n  self.assertEqual(solution.latestTimeCatchTheBus(buses,passengers,capacity),38)", "def test_latestTimeCatchTheBus5(self):\n  class Solution:\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\n      # function body remains the same as in the problem description\n\n  solution = Solution()\n  buses = [1,2]\n  passengers = [1,2]\n  capacity = 2\n  self.assertEqual(solution.latestTimeCatchTheBus(buses,passengers,capacity),1)", "def test_latestTimeCatchTheBus6(self):\n  class Solution:\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\n      # function body remains the same as in the problem description\n\n  solution = Solution()\n  buses = [1]\n  passengers = [0]\n  capacity = 2\n  self.assertEqual(solution.latestTimeCatchTheBus(buses,passengers,capacity),1)", "def test_latestTimeCatchTheBus7(self):\n  class Solution:\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\n      # function body remains the same as in the problem description\n\n  solution = Solution()\n  buses = [100]\n  passengers = [0]\n  capacity = 1\n  self.assertEqual(solution.latestTimeCatchTheBus(buses,passengers,capacity),100)", "def test_latestTimeCatchTheBus8(self):\n  class Solution:\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\n      # function body remains the same as in the problem description\n\n  solution = Solution()\n  buses = [100,200]\n  passengers = [101]\n  capacity = 1\n  self.assertEqual(solution.latestTimeCatchTheBus(buses,passengers,capacity),101)", "def test_latestTimeCatchTheBus9(self):\n  class Solution:\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\n      # function body remains the same as in the problem description\n\n  solution = Solution()\n  buses = [10]\n  passengers = [11,12,13,14,15]\n  capacity = 5\n  self.assertEqual(solution.latestTimeCatchTheBus(buses,passengers,capacity),9)", "def test_latestTimeCatchTheBus10(self):\n  class Solution:\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\n      # function body remains the same as in the problem description\n\n  solution = Solution()\n  buses = [1,2,3]\n  passengers = [0,4,5,6,7]\n  capacity = 2\n  self.assertEqual(solution.latestTimeCatchTheBus(buses,passengers,capacity),2)", "def test_latestTimeCatchTheBus11(self):\n  class Solution:\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\n      # function body remains the same as in the problem description\n\n  solution = Solution()\n  buses = [1]\n  passengers = [0,2,3,4,5]\n  capacity = 1\n  self.assertEqual(solution.latestTimeCatchTheBus(buses,passengers,capacity),1)", "def test_latestTimeCatchTheBus12(self):\n  class Solution:\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\n      # function body remains the same as in the problem description\n\n  solution = Solution()\n  buses = [1,3,5]\n  passengers = [2,6,8,9,10]\n  capacity = 3\n  self.assertEqual(solution.latestTimeCatchTheBus(buses,passengers,capacity),7)", "def test_latestTimeCatchTheBus13(self):\n  class Solution:\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\n      # function body remains the same as in the problem description\n\n  solution = Solution()\n  buses = [1,2]\n  passengers = [0,1,4,6,7]\n  capacity = 3\n  self.assertEqual(solution.latestTimeCatchTheBus(buses,passengers,capacity),5)", "def test_latestTimeCatchTheBus14(self):\n  class Solution:\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\n      # function body remains the same as in the problem description\n\n  solution = Solution()\n  buses = [10]\n  passengers = [11,12]\n  capacity = 2\n  self.assertEqual(solution.latestTimeCatchTheBus(buses,passengers,capacity),9)", "def test_latestTimeCatchTheBus15(self):\n  class Solution:\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\n      # function body remains the same as in the problem description\n\n  solution = Solution()\n  buses = [1]\n  passengers = []\n  capacity = 2\n  self.assertEqual(solution.latestTimeCatchTheBus(buses,passengers,capacity),1)", "def test_latestTimeCatchTheBus16(self):\n  class Solution:\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\n      # function body remains the same as in the problem description\n\n  solution = Solution()\n  buses = [1]\n  passengers = [0]\n  capacity = 1\n  self.assertEqual(solution.latestTimeCatchTheBus(buses,passengers,capacity),0)", "def test_latestTimeCatchTheBus17(self):\n  class Solution:\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\n      # function body remains the same as in the problem description\n\n  solution = Solution()\n  buses = [10]\n  passengers = [11,12,13,14,15]\n  capacity = 5\n  self.assertEqual(solution.latestTimeCatchTheBus(buses,passengers,capacity),9)", "def test_latestTimeCatchTheBus18(self):\n  class Solution:\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\n      # function body remains the same as in the problem description\n\n  solution = Solution()\n  buses = [1000]\n  passengers = [999]\n  capacity = 1\n  self.assertEqual(solution.latestTimeCatchTheBus(buses,passengers,capacity),999)", "def test_latestTimeCatchTheBus19(self):\n  class Solution:\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\n      # function body remains the same as in the problem description\n\n  solution = Solution()\n  buses = [1]\n  passengers = [0,2,3,4,5,6,7,8,9,10]\n  capacity = 10\n  self.assertEqual(solution.latestTimeCatchTheBus(buses,passengers,capacity),0)", "def test_latestTimeCatchTheBus20(self):\n  class Solution:\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\n      # function body remains the same as in the problem description\n\n  solution = Solution()\n  buses = [1,2]\n  passengers = [0,1,4,6,7]\n  capacity = 5\n  self.assertEqual(solution.latestTimeCatchTheBus(buses,passengers,capacity),1)"]}
{"task_num": 2337, "task_title": "Move Pieces to Obtain a String", "func_name": "canChange", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def canChange(self, start: str, target: str) -> bool:\n    n = len(start)\n    i = 0\n    j = 0\n\n    while i <= n and j <= n:\n      while i < n and start[i] == '_':\n        i += 1\n      while j < n and target[j] == '_':\n        j += 1\n      if i == n or j == n:\n        return i == n and j == n\n      if start[i] != target[j]:\n        return False\n      if start[i] == 'R' and i > j:\n        return False\n      if start[i] == 'L' and i < j:\n        return False\n      i += 1\n      j += 1\n\n    return True\n", "tests": ["def test_canChange():\n    solution = Solution()\n    assert solution.canChange('RL', 'LR') == True", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('R_L', 'R') == True", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('L_R', 'R') == True", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('LL___', 'RRL__') == False", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('____', 'RL') == False", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('L___R', 'LL_R') == False", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('_RL', 'LR_') == False", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('RL___', 'LR___') == True", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('_L__R', 'LL___') == False", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('L__R', 'RL__') == False", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('___', '___') == True", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('RR', 'LRL') == False", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('RRL', 'LL_R') == False", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('LRR', 'LLRR') == False", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('L_RR', 'RR__') == False", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('RLR___', 'LRL__') == False", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('LLR', 'RL_') == False", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('L___R', 'LL_R') == False", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('RRL__', 'L___R') == False", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('L____', 'RL___') == False"]}
{"task_num": 2392, "task_title": "Build a Matrix With Conditions", "func_name": "buildMatrix", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\n    rowOrder = self._topologicalSort(rowConditions, k)\n    if not rowOrder:\n      return []\n\n    colOrder = self._topologicalSort(colConditions, k)\n    if not colOrder:\n      return []\n\n    ans = [[0] * k for _ in range(k)]\n    nodeToRowIndex = [0] * (k + 1)\n\n    for i, node in enumerate(rowOrder):\n      nodeToRowIndex[node] = i\n\n    for j, node in enumerate(colOrder):\n      i = nodeToRowIndex[node]\n      ans[i][j] = node\n\n    return ans\n\n  def _topologicalSort(self, conditions: List[List[int]], n: int) -> List[int]:\n    order = []\n    graph = [[] for _ in range(n + 1)]\n    inDegrees = [0] * (n + 1)\n\n    for u, v in conditions:\n      graph[u].append(v)\n      inDegrees[v] += 1\n\n    q = collections.deque([i for i in range(1, n + 1) if inDegrees[i] == 0])\n\n    while q:\n      u = q.popleft()\n      order.append(u)\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    if len(order) == n:\n      return order\n    else:\n      return []\n", "tests": ["def test_buildMatrix():\n    solution = Solution()\n\n    def build_matrix(k: int, row_conditions: List[List[int]], col_conditions: List[List[int]]) -> List[List[int]]:\n        return [[1, 2], [3, 4]]\n    assert build_matrix(5, [[1, 2], [3, 4], [0, 6]], [[7, 8], [9, 10], [11, 12]]) == [[1, 2], [3, 4]]", "def test_buildMatrix():\n    solution = Solution()\n\n    def build_matrix(k: int, row_conditions: List[List[int]], col_conditions: List[List[int]]) -> List[List[int]]:\n        return []\n    assert build_matrix(5, [[1, 2], [3, 4], [0, 6]], [[7, 8], [9, 10], [11, 12]]) == []", "def test_buildMatrix():\n    solution = Solution()\n\n    def build_matrix(k: int, row_conditions: List[List[int]], col_conditions: List[List[int]]) -> List[List[int]]:\n        return [[0] * k for _ in range(k)]\n    assert build_matrix(3, [[1, 2], [3, 4]], [], []) == [[0, 0, 0], [0, 0, 0]]", "def test_buildMatrix():\n    solution = Solution()\n\n    def build_matrix(k: int, row_conditions: List[List[int]], col_conditions: List[List[int]]) -> List[List[int]]:\n        return [[0] * k for _ in range(k)]\n    assert build_matrix(5, [], [[]], []) == []", "def test_buildMatrix():\n    solution = Solution()\n\n    def build_matrix(k: int, row_conditions: List[List[int]], col_conditions: List[List[int]]) -> List[List[int]]:\n        return [[1, 2], [3, 4]]\n    assert len(build_matrix(5, [[0, 6]], [], [])) == k", "def test_buildMatrix():\n    solution = Solution()\n\n    def build_matrix(k: int, row_conditions: List[List[int]], col_conditions: List[List[int]]) -> List[List[int]]:\n        return [[0] * k for _ in range(k)]\n    assert all((all((cell == 0 or cell > k for cell in row)) for row in build_matrix(5, [], [[]], [])))", "def test_buildMatrix():\n    solution = Solution()\n\n    def build_matrix(k: int, row_conditions: List[List[int]], col_conditions: List[List[int]]) -> List[List[int]]:\n        return [[1, 2], [3, 4]]\n    assert len(build_matrix(5, [[1, 2], [0, 6]], [], [])) == k", "def test_buildMatrix():\n    solution = Solution()\n\n    def build_matrix(k: int, row_conditions: List[List[int]], col_conditions: List[List[int]]) -> List[List[int]]:\n        return [[1, 2], [3, 4]]\n    assert all((len(row) == k for row in build_matrix(5, [[1, 2], [0, 6]], [], [])))", "def test_buildMatrix():\n    solution = Solution()\n\n    def build_matrix(k: int, row_conditions: List[List[int]], col_conditions: List[List[int]]) -> List[List[int]]:\n        return [[1, 2], [3, 4]]\n    assert all((all((0 <= cell <= k for cell in row)) for row in build_matrix(5, [], [[]], [])))", "def test_buildMatrix():\n    solution = Solution()\n\n    def build_matrix(k: int, row_conditions: List[List[int]], col_conditions: List[List[int]]) -> List[List[int]]:\n        return [[0] * k for _ in range(k)]\n    assert all((len(col) == k for col in zip(*build_matrix(5, [], [[]], []))))", "def test_buildMatrix():\n    solution = Solution()\n\n    def build_matrix(k: int, row_conditions: List[List[int]], col_conditions: List[List[int]]) -> List[List[int]]:\n        return [[1, 2], [3, 4]]\n    assert all((all((row[i] == col[i] for i in range(k))) for (row, col) in zip(build_matrix(5, [[1, 2], [0, 6]], [], []), [[1, 2]] * k)))", "def test_buildMatrix():\n    solution = Solution()\n\n    def build_matrix(k: int, row_conditions: List[List[int]], col_conditions: List[List[int]]) -> List[List[int]]:\n        return [[1, 2], [3, 4]]\n    assert len(build_matrix(5, [[0, 7], [8, 9]], [], [])) == k", "def test_buildMatrix():\n    solution = Solution()\n\n    def build_matrix(k: int, row_conditions: List[List[int]], col_conditions: List[List[int]]) -> List[List[int]]:\n        return [[1, 2], [3, 4]]\n    assert any((row != sorted(col) for row in zip(*build_matrix(5, [], [[]], []))))", "def test_buildMatrix():\n    solution = Solution()\n\n    def build_matrix(k: int, row_conditions: List[List[int]], col_conditions: List[List[int]]) -> List[List[int]]:\n        return [[1, 2], [3, 4]]\n    assert all((all((row[i] <= row[i + 1] for i in range(k - 1))) for row in build_matrix(5, [[0, 7], [8, 9]], [], [])))", "def test_buildMatrix():\n    solution = Solution()\n\n    def build_matrix(k: int, row_conditions: List[List[int]], col_conditions: List[List[int]]) -> List[List[int]]:\n        return [[1, 2], [3, 4]]\n    assert all((all((row[i] < col[j] for i in range(k) for j in range(k))) for (row, col) in zip(build_matrix(5, [], [[]], []), [[1, 2]] * k)))", "def test_buildMatrix():\n    solution = Solution()\n\n    def build_matrix(k: int, row_conditions: List[List[int]], col_conditions: List[List[int]]) -> List[List[int]]:\n        return [[1, 2], [3, 4]]\n    assert all((len(row) == len(set(col)) for (row, col) in zip(build_matrix(5, [], [[]], []), [[1, 2]] * k)))", "def test_buildMatrix():\n    solution = Solution()\n\n    def build_matrix(k: int, row_conditions: List[List[int]], col_conditions: List[List[int]]) -> List[List[int]]:\n        return [[1, 2], [3, 4]]\n    assert all((all((row[i] > row[i - 1] for i in range(1, k))) for row in build_matrix(5, [[0, 7], [8, 9]], [], [])))", "def test_buildMatrix():\n    solution = Solution()\n\n    def build_matrix(k: int, row_conditions: List[List[int]], col_conditions: List[List[int]]) -> List[List[int]]:\n        return [[1, 2], [3, 4]]\n    assert all((len(col) == k for col in zip(*build_matrix(5, [], [[]], []))))", "def test_buildMatrix():\n    solution = Solution()\n\n    def build_matrix(k: int, row_conditions: List[List[int]], col_conditions: List[List[int]]) -> List[List[int]]:\n        return [[1, 2], [3, 4]]\n    assert all((row[i] <= k for i in range(k) for row in build_matrix(5, [], [[]], [])))", "def test_buildMatrix():\n    solution = Solution()\n\n    def build_matrix(k: int, row_conditions: List[List[int]], col_conditions: List[List[int]]) -> List[List[int]]:\n        return [[1, 2], [3, 4]]\n    assert all((col != sorted(row) for row in build_matrix(5, [[0, 7], [8, 9]], [], []) for col in zip(*[row])))"]}
{"task_num": 2437, "task_title": "Number of Valid Clock Times", "func_name": "countTime", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countTime(self, time: str) -> int:\n    ans = 1\n    if time[3] == '?':\n      ans *= 6\n    if time[4] == '?':\n      ans *= 10\n\n    if time[0] == '?' and time[1] == '?':\n      return ans * 24\n    if time[0] == '?':\n      if time[1] < '4':\n        return ans * 3\n      else:\n        return ans * 2\n    if time[1] == '?':\n      if time[0] == '2':\n        return ans * 4\n      else:\n        return ans * 10\n    return ans\n", "tests": ["def test_countTime():\n    solution = Solution()\n    print(solution.countTime('23:??'))", "def test_countTime():\n    solution = Solution()\n    print(solution.countTime('1?:?'))", "def test_countTime():\n    solution = Solution()\n    print(solution.countTime('2?:0'))", "def test_countTime():\n    solution = Solution()\n    print(solution.countTime('00:?'))", "def test_countTime():\n    solution = Solution()\n    print(solution.countTime('09:?'))", "def test_countTime():\n    solution = Solution()\n    print(solution.countTime('??:59'))", "def test_countTime():\n    solution = Solution()\n    print(solution.countTime('??:0?'))", "def test_countTime():\n    solution = Solution()\n    print(solution.countTime('23:?'))", "def test_countTime():\n    solution = Solution()\n    print(solution.countTime('??:?'))", "def test_countTime():\n    solution = Solution()\n    print(solution.countTime('1:59'))", "def test_countTime():\n    solution = Solution()\n    print(solution.countTime('22:?'))", "def test_countTime():\n    solution = Solution()\n    print(solution.countTime('00:?'))", "def test_countTime():\n    solution = Solution()\n    print(solution.countTime('23:?'))", "def test_countTime():\n    solution = Solution()\n    print(solution.countTime('00:0?'))", "def test_countTime():\n    solution = Solution()\n    print(solution.countTime('2?:9'))", "def test_countTime():\n    solution = Solution()\n    print(solution.countTime('2?5:0'))", "def test_countTime():\n    solution = Solution()\n    print(solution.countTime('??:0'))", "def test_countTime():\n    solution = Solution()\n    print(solution.countTime('?:5?'))", "def test_countTime():\n    solution = Solution()\n    print(solution.countTime('09:?'))", "def test_countTime():\n    solution = Solution()\n    print(solution.countTime('?:09'))"]}
{"task_num": 2456, "task_title": "Most Popular Video Creator", "func_name": "mostPopularCreator", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Creator:\n  def __init__(self, popularity: int, videoId: str, maxView: int):\n    self.popularity = popularity\n    self.videoId = videoId\n    self.maxView = maxView\n\n\nclass Solution:\n  def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\n    ans = []\n    maxPopularity = 0\n    nameToCreator = {}\n\n    for name, id, view in zip(creators, ids, views):\n      if name not in nameToCreator:\n        nameToCreator[name] = Creator(view, id, view)\n        maxPopularity = max(maxPopularity, view)\n        continue\n      creator = nameToCreator[name]\n      creator.popularity += view\n      maxPopularity = max(maxPopularity, creator.popularity)\n      if creator.maxView < view or creator.maxView == view and creator.videoId > id:\n        creator.videoId = id\n        creator.maxView = view\n\n    for name, creator in nameToCreator.items():\n      if creator.popularity == maxPopularity:\n        ans.append([name, creator.videoId])\n\n    return ans\n", "tests": ["def test_mostPopularCreator(self):\n    creators = ['a', 'b', 'c']\n    ids = ['vid1', 'vid2', 'vid3']\n    views = [100, 200, 300]\n    result = [[creator[0], creator[1]] for creator in solution.mostPopularCreator(creators, ids, views)]", "def test_mostPopularCreator(self):\n    creators = ['a', 'b', 'c']\n    ids = ['vid1', 'vid2', 'vid3']\n    views = [100, 200, 300]\n    result = solution.mostPopularCreator(creators, ids, views)", "def test_mostPopularCreator(self):\n    creators = []\n    ids = []\n    views = []\n    result = solution.mostPopularCreator(creators, ids, views)", "def test_mostPopularCreator(self):\n    creators = ['a', 'b']\n    ids = ['vid1', 'vid2']\n    views = [10, 10]\n    result = solution.mostPopularCreator(creators, ids, views)", "def test_mostPopularCreator(self):\n    creators = ['a']\n    ids = ['vid1']\n    views = [10]\n    result = solution.mostPopularCreator(creators, ids, views)", "def test_mostPopularCreator(self):\n    creators = ['a', 'b']\n    ids = ['vid1', 'vid2']\n    views = [10, 10]\n    result = solution.mostPopularCreator(creators, ids, views)", "def test_mostPopularCreator(self):\n    creators = []\n    ids = ['vid1', 'vid2']\n    views = [10, 20]\n    result = solution.mostPopularCreator(creators, ids, views)", "def test_mostPopularCreator(self):\n    creators = ['a'] * 1000\n    ids = ['vid1'] * 1000\n    views = [10] * 1000\n    result = solution.mostPopularCreator(creators, ids, views)", "def test_mostPopularCreator(self):\n    creators = ['a']\n    ids = ['vid1']\n    views = [100]\n    result = solution.mostPopularCreator(creators, ids, views)", "def test_mostPopularCreator(self):\n    creators = []\n    ids = ['vid1', 'vid2']\n    views = [10, 20]\n    result = solution.mostPopularCreator(creators, ids, views)", "def test_mostPopularCreator(self):\n    creators = ['a'] * 1000000\n    ids = ['vid1'] * 1000000\n    views = [10] * 1000000\n    result = solution.mostPopularCreator(creators, ids, views)", "def test_mostPopularCreator(self):\n    creators = ['a'] * 10\n    ids = ['vid1'] * 10\n    views = [0] * 10\n    result = solution.mostPopularCreator(creators, ids, views)", "def test_mostPopularCreator(self):\n    creators = ['a', 'b']\n    ids = ['vid1', 'vid2']\n    views = [10, 20]\n    result = solution.mostPopularCreator(creators, ids, views)", "def test_mostPopularCreator(self):\n    creators = ['a']\n    ids = ['vid1', 'vid2']\n    views = [100, 200]\n    result = solution.mostPopularCreator(creators, ids, views)", "def test_mostPopularCreator(self):\n    creators = ['a', 'b']\n    ids = ['vid1'] * 2\n    views = [10, 20]\n    result = solution.mostPopularCreator(creators, ids, views)", "def test_mostPopularCreator(self):\n    creators = ['a']\n    ids = ['vid1', 'vid2']\n    views = [10, 20]\n    result = solution.mostPopularCreator(creators, ids, views)", "def test_mostPopularCreator(self):\n    creators = ['a']\n    ids = ['vid1', 'vid2']\n    views = [100, 200]\n    result = solution.mostPopularCreator(creators, ids, views)", "def test_mostPopularCreator(self):\n    creators = []\n    ids = ['vid1', 'vid2']\n    views = [10, 20]\n    result = solution.mostPopularCreator(creators, ids, views)", "def test_mostPopularCreator(self):\n    creators = ['a'] * 5\n    ids = ['vid1'] * 5\n    views = [10] * 5\n    result = solution.mostPopularCreator(creators, ids, views)", "def test_mostPopularCreator(self):\n    creators = ['a'] * 1000\n    ids = ['vid1'] * 1000\n    views = [10] * 1000\n    result = solution.mostPopularCreator(creators, ids, views)"]}
{"task_num": 2462, "task_title": "Total Cost to Hire K Workers", "func_name": "totalCost", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\n    ans = 0\n    i = 0\n    j = len(costs) - 1\n    minHeapL = []\n    minHeapR = []\n\n    for _ in range(k):\n      while len(minHeapL) < candidates and i <= j:\n        heapq.heappush(minHeapL, costs[i])\n        i += 1\n      while len(minHeapR) < candidates and i <= j:\n        heapq.heappush(minHeapR, costs[j])\n        j -= 1\n      if not minHeapL:\n        ans += heapq.heappop(minHeapR)\n      elif not minHeapR:\n        ans += heapq.heappop(minHeapL)\n      elif minHeapL[0] <= minHeapR[0]:\n        ans += heapq.heappop(minHeapL)\n      else:\n        ans += heapq.heappop(minHeapR)\n\n    return ans\n", "tests": ["def test_totalCost():\n    solution = Solution()\n    costs = [3, 2, 7, 7, 1, 2]\n    k = 5\n    candidates = 2\n    assert solution.totalCost(costs, k, candidates) == 12", "def test_totalCost():\n    solution = Solution()\n    costs = [1, 2, 3, 4, 5]\n    k = 10\n    candidates = 6\n    assert solution.totalCost(costs, k, candidates) == sum(costs)", "def test_totalCost():\n    solution = Solution()\n    costs = [5, 4, 3, 2, 1]\n    k = 5\n    candidates = 0\n    assert solution.totalCost(costs, k, candidates) == sum(heapq.nsmallest(k, costs))", "def test_totalCost():\n    solution = Solution()\n    costs = [10, 20, 30]\n    k = 3\n    candidates = 1\n    assert solution.totalCost(costs, k, candidates) == sum(heapq.nsmallest(k, costs))", "def test_totalCost():\n    solution = Solution()\n    costs = []\n    k = 5\n    candidates = 2\n    assert solution.totalCost(costs, k, candidates) == 0", "def test_totalCost():\n    solution = Solution()\n    costs = [1]\n    k = 5\n    candidates = 2\n    assert solution.totalCost(costs, k, candidates) == sum(heapq.nsmallest(k, costs))", "def test_totalCost():\n    solution = Solution()\n    costs = [10, 20]\n    k = 1\n    candidates = 2\n    assert solution.totalCost(costs, k, candidates) == min(min(costs[:candidates]), min(costs[-candidates:]))", "def test_totalCost():\n    solution = Solution()\n    costs = [5] * 1000\n    k = 500\n    candidates = 3\n    assert solution.totalCost(costs, k, candidates) == sum(heapq.nsmallest(k, costs))", "def test_totalCost():\n    solution = Solution()\n    costs = [5]\n    k = 1\n    candidates = 0\n    assert solution.totalCost(costs, k, candidates) == costs[0]", "def test_totalCost():\n    solution = Solution()\n    costs = [5]\n    k = 1\n    candidates = -2\n    assert solution.totalCost(costs, k, candidates) == sum(heapq.nsmallest(k, costs))", "def test_totalCost():\n    solution = Solution()\n    costs = [5]\n    k = 1\n    candidates = -1\n    assert solution.totalCost(costs, k, candidates) == sum(heapq.nsmallest(k, costs))", "def test_totalCost():\n    solution = Solution()\n    costs = [10]\n    k = 0\n    candidates = 2\n    assert solution.totalCost(costs, k, candidates) == 0", "def test_totalCost():\n    solution = Solution()\n    costs = [10]\n    k = -1\n    candidates = 2\n    assert solution.totalCost(costs, k, candidates) == sum(heapq.nsmallest(k, costs))", "def test_totalCost():\n    solution = Solution()\n    costs = [10]\n    k = 1e+20\n    candidates = 2\n    assert solution.totalCost(costs, k, candidates) == sum(heapq.nsmallest(k, costs))", "def test_totalCost():\n    solution = Solution()\n    costs = [10]\n    k = float('inf')\n    candidates = 2\n    assert solution.totalCost(costs, k, candidates) == sum(heapq.nsmallest(k, costs))", "def test_totalCost():\n    solution = Solution()\n    costs = [10000000000.0] * 1000\n    k = 500\n    candidates = 2\n    assert solution.totalCost(costs, k, candidates) == sum(heapq.nsmallest(k, costs))", "def test_totalCost():\n    solution = Solution()\n    costs = [float('inf')] * 1000\n    k = 500\n    candidates = 2\n    assert solution.totalCost(costs, k, candidates) == sum(heapq.nsmallest(k, costs))", "def test_totalCost():\n    solution = Solution()\n    costs = [float('-inf')] * 1000\n    k = 500\n    candidates = 2\n    assert solution.totalCost(costs, k, candidates) == sum(heapq.nsmallest(k, costs))", "def test_totalCost():\n    solution = Solution()\n    costs = [float('-inf'), float('inf')]\n    k = 1\n    candidates = 2\n    assert solution.totalCost(costs, k, candidates) == min(min(costs[:candidates]), min(costs[-candidates:]))", "def test_totalCost():\n    solution = Solution()\n    costs = [float('-inf'), float('inf')]\n    k = 1e+20\n    candidates = 2\n    assert solution.totalCost(costs, k, candidates) == sum(heapq.nsmallest(k, costs))"]}
{"task_num": 2467, "task_title": "Most Profitable Path in a Tree", "func_name": "mostProfitablePath", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\n    n = len(amount)\n    tree = [[] for _ in range(n)]\n    parent = [0] * n\n    aliceDist = [-1] * n\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, prev: int, d: int) -> None:\n      parent[u] = prev\n      aliceDist[u] = d\n      for v in tree[u]:\n        if aliceDist[v] == -1:\n          dfs(v, u, d + 1)\n\n    dfs(0, -1, 0)\n\n    u = bob\n    bobDist = 0\n    while u != 0:\n      if bobDist < aliceDist[u]:\n        amount[u] = 0\n      elif bobDist == aliceDist[u]:\n        amount[u] //= 2\n      u = parent[u]\n      bobDist += 1\n\n    return self._getMoney(tree, 0, -1, amount)\n\n  def _getMoney(self, tree: List[List[int]], u: int, prev: int, amount: List[int]) -> int:\n    if len(tree[u]) == 1 and tree[u][0] == prev:\n      return amount[u]\n\n    maxPath = -math.inf\n    for v in tree[u]:\n      if v != prev:\n        maxPath = max(maxPath, self._getMoney(tree, v, u, amount))\n\n    return amount[u] + maxPath\n", "tests": ["def test_mostProfitablePath(self):\n    solution = Solution()\n    edges = [[0, 1], [0, 2], [2, 3]]\n    bob = 2\n    amount = [10, -5, -100, 1]\n    self.assertEqual(solution.mostProfitablePath(edges, bob, amount), -8)", "def test_mostProfitablePath(self):\n    solution = Solution()\n    edges = [[0, 1], [1, 2], [3, 4]]\n    bob = 1\n    amount = [-5, -10, -100, 10]\n    self.assertEqual(solution.mostProfitablePath(edges, bob, amount), -20)", "def test_mostProfitablePath(self):\n    solution = Solution()\n    edges = [[0, 1], [1, 2]]\n    bob = 0\n    amount = [-5, 10, -100]\n    self.assertEqual(solution.mostProfitablePath(edges, bob, amount), -45)", "def test_mostProfitablePath(self):\n    solution = Solution()\n    edges = [[0, 1], [0, 2]]\n    bob = 1\n    amount = [10, -5, 10]\n    self.assertEqual(solution.mostProfitablePath(edges, bob, amount), -5)", "def test_mostProfitablePath(self):\n    solution = Solution()\n    edges = [[0, 1], [1, 2], [3, 4], [3, 5]]\n    bob = 1\n    amount = [-100, -10, 10, 10]\n    self.assertEqual(solution.mostProfitablePath(edges, bob, amount), -20)", "def test_mostProfitablePath(self):\n    solution = Solution()\n    edges = [[0, 1], [0, 2], [3, 4], [5, 6]]\n    bob = 3\n    amount = [10, -5, -100, -10]\n    self.assertEqual(solution.mostProfitablePath(edges, bob, amount), -45)", "def test_mostProfitablePath(self):\n    solution = Solution()\n    edges = [[0, 1], [2, 3], [4, 5]]\n    bob = 0\n    amount = [-10, -20, 10, -30]\n    self.assertEqual(solution.mostProfitablePath(edges, bob, amount), -60)", "def test_mostProfitablePath(self):\n    solution = Solution()\n    edges = [[0, 1], [2, 3]]\n    bob = 0\n    amount = [10, -5, -100]\n    self.assertEqual(solution.mostProfitablePath(edges, bob, amount), -95)", "def test_mostProfitablePath(self):\n    solution = Solution()\n    edges = [[0, 1], [2, 3], [4, 5]]\n    bob = 2\n    amount = [-10, -20, -30, 40]\n    self.assertEqual(solution.mostProfitablePath(edges, bob, amount), -30)", "def test_mostProfitablePath(self):\n    solution = Solution()\n    edges = [[0, 1], [2, 3], [4, 5]]\n    bob = 3\n    amount = [100, -50, 20, 30]\n    self.assertEqual(solution.mostProfitablePath(edges, bob, amount), 70)", "def test_mostProfitablePath(self):\n    solution = Solution()\n    edges = [[0, 1], [2, 3]]\n    bob = 1\n    amount = [10, -100]\n    self.assertEqual(solution.mostProfitablePath(edges, bob, amount), -90)", "def test_mostProfitablePath(self):\n    solution = Solution()\n    edges = [[0, 1], [2, 3]]\n    bob = 2\n    amount = [-10, -20]\n    self.assertEqual(solution.mostProfitablePath(edges, bob, amount), -30)", "def test_mostProfitablePath(self):\n    solution = Solution()\n    edges = [[0, 1], [2, 3]]\n    bob = 0\n    amount = [-10, -20]\n    self.assertEqual(solution.mostProfitablePath(edges, bob, amount), -30)", "def test_mostProfitablePath(self):\n    solution = Solution()\n    edges = [[0, 1], [2, 3]]\n    bob = 1\n    amount = [10, -100]\n    self.assertEqual(solution.mostProfitablePath(edges, bob, amount), -90)", "def test_mostProfitablePath(self):\n    solution = Solution()\n    edges = [[0, 1], [2, 3]]\n    bob = 2\n    amount = [-10, -20]\n    self.assertEqual(solution.mostProfitablePath(edges, bob, amount), -30)", "def test_mostProfitablePath(self):\n    solution = Solution()\n    edges = [[0, 1], [2, 3]]\n    bob = 0\n    amount = [-10, -20]\n    self.assertEqual(solution.mostProfitablePath(edges, bob, amount), -30)", "def test_mostProfitablePath(self):\n    solution = Solution()\n    edges = [[0, 1], [2, 3]]\n    bob = 1\n    amount = [10, -100]\n    self.assertEqual(solution.mostProfitablePath(edges, bob, amount), -90)", "def test_mostProfitablePath(self):\n    solution = Solution()\n    edges = [[0, 1], [2, 3]]\n    bob = 2\n    amount = [-10, -20]\n    self.assertEqual(solution.mostProfitablePath(edges, bob, amount), -30)", "def test_mostProfitablePath(self):\n    solution = Solution()\n    edges = [[0, 1], [2, 3], [4, 5]]\n    bob = 3\n    amount = [10, -100, 20, -30]\n    self.assertEqual(solution.mostProfitablePath(edges, bob, amount), -130)", "def test_mostProfitablePath(self):\n    solution = Solution()\n    edges = [[0, 1], [2, 3]]\n    bob = 2\n    amount = [-10, -100]\n    self.assertEqual(solution.mostProfitablePath(edges, bob, amount), -110)"]}
{"task_num": 2499, "task_title": "Minimum Total Cost to Make Arrays Unequal", "func_name": "minimumTotalCost", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\n    n = len(nums1)\n    ans = 0\n    maxFreq = 0\n    maxFreqNum = 0\n    shouldBeSwapped = 0\n    conflictedNumCount = [0] * (n + 1)\n\n    for i, (num1, num2) in enumerate(zip(nums1, nums2)):\n      if num1 == num2:\n        conflictedNum = num1\n        conflictedNumCount[conflictedNum] += 1\n        if conflictedNumCount[conflictedNum] > maxFreq:\n          maxFreq = conflictedNumCount[conflictedNum]\n          maxFreqNum = conflictedNum\n        shouldBeSwapped += 1\n        ans += i\n\n    for i, (num1, num2) in enumerate(zip(nums1, nums2)):\n      if maxFreq * 2 <= shouldBeSwapped:\n        break\n      if num1 == num2:\n        continue\n\n      if num1 == maxFreqNum or num2 == maxFreqNum:\n        continue\n      shouldBeSwapped += 1\n      ans += i\n\n    if maxFreq * 2 > shouldBeSwapped:\n      return -1\n    else:\n      return ans\n", "tests": ["def test_minimumTotalCost():\n    solution = Solution()\n    nums1 = [1, 2, 3]\n    nums2 = [2, 2, 1]\n    assert solution.minimumTotalCost(nums1, nums2) == 0", "def test_minimumTotalCost():\n    solution = Solution()\n    nums1 = [3, 4, 5]\n    nums2 = [5, 4, 3]\n    assert solution.minimumTotalCost(nums1, nums2) == -1", "def test_minimumTotalCost():\n    solution = Solution()\n    nums1 = [1, 2, 3]\n    nums2 = [4, 5, 6]\n    assert solution.minimumTotalCost(nums1, nums2) == -1", "def test_minimumTotalCost():\n    solution = Solution()\n    nums1 = [1, 2, 3]\n    nums2 = [4, 5, 6]\n    assert solution.minimumTotalCost(nums1, nums2) == 0", "def test_minimumTotalCost():\n    solution = Solution()\n    nums1 = [1, 1, 1]\n    nums2 = [1, 1, 1]\n    assert solution.minimumTotalCost(nums1, nums2) == -1", "def test_minimumTotalCost():\n    solution = Solution()\n    nums1 = [1, 2]\n    nums2 = [3, 4]\n    assert solution.minimumTotalCost(nums1, nums2) == -1", "def test_minimumTotalCost():\n    solution = Solution()\n    nums1 = [0]\n    nums2 = [0]\n    assert solution.minimumTotalCost(nums1, nums2) == 0", "def test_minimumTotalCost():\n    solution = Solution()\n    nums1 = [1000000000]\n    nums2 = [-1000000000]\n    assert solution.minimumTotalCost(nums1, nums2) == -1", "def test_minimumTotalCost():\n    solution = Solution()\n    nums1 = [10 ** 18] * 5\n    nums2 = [-10 ** 18] * 5\n    assert solution.minimumTotalCost(nums1, nums2) == -1", "def test_minimumTotalCost():\n    solution = Solution()\n    nums1 = []\n    nums2 = []\n    assert solution.minimumTotalCost(nums1, nums2) == 0", "def test_minimumTotalCost():\n    solution = Solution()\n    nums1 = [5, 2, 3]\n    nums2 = [5, 2, 3]\n    assert solution.minimumTotalCost(nums1, nums2) == 0", "def test_minimumTotalCost():\n    solution = Solution()\n    nums1 = [5, 2, 3]\n    nums2 = [5, 2, 4]\n    assert solution.minimumTotalCost(nums1, nums2) == -1", "def test_minimumTotalCost():\n    solution = Solution()\n    nums1 = [5, 4, 3]\n    nums2 = [6, 5, 2]\n    assert solution.minimumTotalCost(nums1, nums2) == -1", "def test_minimumTotalCost():\n    solution = Solution()\n    nums1 = [10 ** 18] * 1000 + [5]\n    nums2 = [-10 ** 18] * 999 + [4]\n    assert solution.minimumTotalCost(nums1, nums2) == -1", "def test_minimumTotalCost():\n    solution = Solution()\n    nums1 = [5, 6, 7]\n    nums2 = [8, 9, 10]\n    assert solution.minimumTotalCost(nums1, nums2) == -1", "def test_minimumTotalCost():\n    solution = Solution()\n    nums1 = [5] * 10 + [4]\n    nums2 = [6] * 9 + [3]\n    assert solution.minimumTotalCost(nums1, nums2) == -1", "def test_minimumTotalCost():\n    solution = Solution()\n    nums1 = [5, 6, 7, 8, 9]\n    nums2 = [5, 6, 7, 10, 11]\n    assert solution.minimumTotalCost(nums1, nums2) == -1", "def test_minimumTotalCost():\n    solution = Solution()\n    nums1 = [4, 5, 6]\n    nums2 = [10, 9, 8]\n    assert solution.minimumTotalCost(nums1, nums2) == -1", "def test_minimumTotalCost():\n    solution = Solution()\n    nums1 = [4] * 5 + [3]\n    nums2 = [10] * 9 + [7]\n    assert solution.minimumTotalCost(nums1, nums2) == -1", "def test_minimumTotalCost():\n    solution = Solution()\n    nums1 = [5] * 10 + [4]\n    nums2 = [6] * 9 + [3]\n    assert solution.minimumTotalCost(nums1, nums2) == -1"]}
{"task_num": 2503, "task_title": "Maximum Number of Points From Grid Queries", "func_name": "maxPoints", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, query: int):\n    self.queryIndex = queryIndex\n    self.query = query\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.query\n\n\nclass Solution:\n  def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    ans = [0] * len(queries)\n    minHeap = [(grid[0][0], 0, 0)]\n    seen = {(0, 0)}\n    accumulate = 0\n\n    for queryIndex, query in sorted([IndexedQuery(i, query) for i, query in enumerate(queries)], key=lambda iq: iq.query):\n      while minHeap:\n        val, i, j = heapq.heappop(minHeap)\n        if val >= query:\n          heapq.heappush(minHeap, (val, i, j))\n          break\n        accumulate += 1\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if (x, y) in seen:\n            continue\n          heapq.heappush(minHeap, (grid[x][y], x, y))\n          seen.add((x, y))\n      ans[queryIndex] = accumulate\n\n    return ans\n", "tests": ["def test_maxPoints():\n    solution = Solution()\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    queries = [20]\n    expected = [0]\n    result = solution.maxPoints(grid, queries)", "def test_maxPoints():\n    solution = Solution()\n    grid = [[1, 2], [3, 4]]\n    queries = [5]\n    expected = [0]\n    result = solution.maxPoints(grid, queries)", "def test_maxPoints():\n    solution = Solution()\n    grid = [[1, 2, 3], [4, 5, 6]]\n    queries = [1]\n    expected = [0]\n    result = solution.maxPoints(grid, queries)", "def test_maxPoints():\n    solution = Solution()\n    grid = [[1]]\n    queries = [1]\n    expected = [0]\n    result = solution.maxPoints(grid, queries)", "def test_maxPoints():\n    solution = Solution()\n    grid = [[9, 8], [7, 6]]\n    queries = [10]\n    expected = [1]\n    result = solution.maxPoints(grid, queries)", "def test_maxPoints():\n    solution = Solution()\n    grid = [[9, 8], [7, 6]]\n    queries = [5]\n    expected = [0]\n    result = solution.maxPoints(grid, queries)", "def test_maxPoints():\n    solution = Solution()\n    grid = [[1, 2, 3], [4, 5, 6]]\n    queries = [0]\n    expected = [9]\n    result = solution.maxPoints(grid, queries)", "def test_maxPoints():\n    solution = Solution()\n    grid = [[1, 2], [3, 4]]\n    queries = [5, 6]\n    expected = [0, 0]\n    result = solution.maxPoints(grid, queries)", "def test_maxPoints():\n    solution = Solution()\n    grid = [[1, 2], [3, 4]]\n    queries = [5, 6]\n    expected = [0, 0]\n    result = solution.maxPoints(grid, queries)", "def test_maxPoints():\n    solution = Solution()\n    grid = [[1] * 100]\n    queries = [10]\n    expected = [0]\n    result = solution.maxPoints(grid, queries)", "def test_maxPoints():\n    solution = Solution()\n    grid = [[1] * 1000]\n    queries = [10]\n    expected = [999]\n    result = solution.maxPoints(grid, queries)", "def test_maxPoints():\n    solution = Solution()\n    grid = [[10] * 10]\n    queries = [5]\n    expected = [0]\n    result = solution.maxPoints(grid, queries)", "def test_maxPoints():\n    solution = Solution()\n    grid = [[1] * 10000]\n    queries = [10]\n    expected = [9999]\n    result = solution.maxPoints(grid, queries)", "def test_maxPoints():\n    solution = Solution()\n    grid = [[1] * 10000]\n    queries = [0]\n    expected = [9999]\n    result = solution.maxPoints(grid, queries)", "def test_maxPoints():\n    solution = Solution()\n    grid = [[1] * 100000]\n    queries = [10]\n    expected = [99999]\n    result = solution.maxPoints(grid, queries)", "def test_maxPoints():\n    solution = Solution()\n    grid = [[1] * 1000000]\n    queries = [10]\n    expected = [999999]\n    result = solution.maxPoints(grid, queries)", "def test_maxPoints():\n    solution = Solution()\n    grid = [[1] * 10000000]\n    queries = [10]\n    expected = [9999999]\n    result = solution.maxPoints(grid, queries)", "def test_maxPoints():\n    solution = Solution()\n    grid = [[1] * 100000000]\n    queries = [10]\n    expected = [99999999]\n    result = solution.maxPoints(grid, queries)", "def test_maxPoints():\n    solution = Solution()\n    grid = [[1] * 1000000000]\n    queries = [10]\n    expected = [999999999]\n    result = solution.maxPoints(grid, queries)", "def test_maxPoints():\n    solution = Solution()\n    grid = [[1] * 10000000000]\n    queries = [10]\n    expected = [9999999999]\n    result = solution.maxPoints(grid, queries)"]}
{"task_num": 2508, "task_title": "Add Edges to Make Degrees of All Nodes Even", "func_name": "isPossible", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isPossible(self, n: int, edges: List[List[int]]) -> bool:\n    graph = [set() for _ in range(n)]\n\n    for u, v in edges:\n      graph[u - 1].add(v - 1)\n      graph[v - 1].add(u - 1)\n\n    oddNodes = [i for i, neighbor in enumerate(graph) if len(neighbor) & 1]\n    if not oddNodes:\n      return True\n    if len(oddNodes) == 2:\n      a, b = oddNodes\n      return any(a not in graph[i] and b not in graph[i] for i in range(n))\n    if len(oddNodes) == 4:\n      a, b, c, d = oddNodes\n      return (b not in graph[a] and d not in graph[c]) or (c not in graph[a] and d not in graph[b]) or (d not in graph[a] and c not in graph[b])\n    return False\n", "tests": ["def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(4, [[1, 2], [3, 2]]) == False", "def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(3, [[1, 2]]) == False", "def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(5, [[1, 2], [3, 4]]) == True", "def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(6, [[1, 2], [3, 4], [5, 1]]) == False", "def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(8, [[1, 2], [3, 4], [5, 6]]) == True", "def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(9, [[1, 2], [3, 4], [5, 6], [7, 8]]) == False", "def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(10, [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]) == True", "def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(7, [[1, 2], [3, 4], [5, 6], [3, 7]]) == True", "def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(10, [[1, 2], [3, 4], [5, 6], [7, 8], [9, 1]]) == False", "def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(11, [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 10]]) == False", "def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(12, [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12]]) == True", "def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(3, [[1, 2], [1, 3]]) == False", "def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(5, [[1, 2], [3, 4], [2, 4]]) == False", "def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(8, [[1, 2], [3, 4], [5, 6], [7, 8], [5, 7]]) == False", "def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(6, [[1, 2], [3, 4], [5, 1], [2, 4]]) == False", "def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(9, [[1, 2], [3, 4], [5, 6], [7, 8], [3, 5]]) == True", "def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(7, [[1, 2], [3, 4], [5, 6], [3, 7], [5, 1]]) == False", "def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(10, [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [5, 9]]) == True", "def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(11, [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 6]]) == True", "def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(12, [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12], [11, 12]]) == False"]}
{"task_num": 2523, "task_title": "Closest Prime Numbers in Range", "func_name": "closestPrimes", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def closestPrimes(self, left: int, right: int) -> List[int]:\n    isPrime = self._sieveEratosthenes(right + 1)\n    primes=[]\n    for i in range(left, right+1):\n      if isPrime[i]:\n        primes.append(i)\n\n    if len(primes) < 2:\n      return [-1, -1]\n\n    minDiff = math.inf\n    num1 = -1\n    num2 = -1\n\n    for a, b in zip(primes, primes[1:]):\n      diff = b - a\n      if diff < minDiff:\n        minDiff = diff\n        num1 = a\n        num2 = b\n\n    return [num1, num2]\n\n  def _sieveEratosthenes(self, n: int) -> List[bool]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return isPrime\n", "tests": ["def test_closestPrimes():\n    solution = Solution()\n    left = 10\n    right = 20\n    expected_output = [11, 13]\n    assert solution.closestPrimes(left, right) == expected_output", "def test_closestPrimes():\n    solution = Solution()\n    left = 20\n    right = 30\n    expected_output = [23, 29]\n    assert solution.closestPrimes(left, right) == expected_output", "def test_closestPrimes():\n    solution = Solution()\n    left = 2\n    right = 10\n    expected_output = [5, 7]\n    assert solution.closestPrimes(left, right) == expected_output", "def test_closestPrimes():\n    solution = Solution()\n    left = 4\n    right = 6\n    expected_output = [-1, -1]\n    assert solution.closestPrimes(left, right) == expected_output", "def test_closestPrimes():\n    solution = Solution()\n    left = 1\n    right = 1000\n    expected_output = [3, 5]\n    assert solution.closestPrimes(left, right) == expected_output", "def test_closestPrimes():\n    solution = Solution()\n    left = 1000000\n    right = 1000005\n    expected_output = [1000003, 1000007]\n    assert solution.closestPrimes(left, right) == expected_output", "def test_closestPrimes():\n    solution = Solution()\n    left = 2\n    right = 5\n    expected_output = [3, 5]\n    assert solution.closestPrimes(left, right) == expected_output", "def test_closestPrimes():\n    solution = Solution()\n    left = 1000003\n    right = 1000007\n    expected_output = [1000005, -1]\n    assert solution.closestPrimes(left, right) == expected_output", "def test_closestPrimes():\n    solution = Solution()\n    left = 2\n    right = 4\n    expected_output = [3, -1]\n    assert solution.closestPrimes(left, right) == expected_output", "def test_closestPrimes():\n    solution = Solution()\n    left = 8\n    right = 9\n    expected_output = [7, -1]\n    assert solution.closestPrimes(left, right) == expected_output", "def test_closestPrimes():\n    solution = Solution()\n    left = 10\n    right = 12\n    expected_output = [-1, -1]\n    assert solution.closestPrimes(left, right) == expected_output", "def test_closestPrimes():\n    solution = Solution()\n    left = 30\n    right = 32\n    expected_output = [-1, -1]\n    assert solution.closestPrimes(left, right) == expected_output", "def test_closestPrimes():\n    solution = Solution()\n    left = 25\n    right = 27\n    expected_output = [23, -1]\n    assert solution.closestPrimes(left, right) == expected_output", "def test_closestPrimes():\n    solution = Solution()\n    left = 17\n    right = 19\n    expected_output = [17, 19]\n    assert solution.closestPrimes(left, right) == expected_output", "def test_closestPrimes():\n    solution = Solution()\n    left = 5\n    right = 7\n    expected_output = [5, 7]\n    assert solution.closestPrimes(left, right) == expected_output", "def test_closestPrimes():\n    solution = Solution()\n    left = 1000\n    right = 1002\n    expected_output = [997, -1]\n    assert solution.closestPrimes(left, right) == expected_output", "def test_closestPrimes():\n    solution = Solution()\n    left = 1000009\n    right = 1010011\n    expected_output = [-1, -1]\n    assert solution.closestPrimes(left, right) == expected_output", "def test_closestPrimes():\n    solution = Solution()\n    left = 1000003\n    right = 1000008\n    expected_output = [1000005, -1]\n    assert solution.closestPrimes(left, right) == expected_output", "def test_closestPrimes():\n    solution = Solution()\n    left = 1000001\n    right = 1000013\n    expected_output = [1000007, -1]\n    assert solution.closestPrimes(left, right) == expected_output", "def test_closestPrimes():\n    solution = Solution()\n    left = 1010011\n    right = 1010013\n    expected_output = [-1, -1]\n    assert solution.closestPrimes(left, right) == expected_output"]}
{"task_num": 2532, "task_title": "Time to Cross a Bridge", "func_name": "findCrossingTime", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n    ans = 0\n    leftBridgeQueue = [(-leftToRight - rightToLeft, -i) for i, (leftToRight, pickOld, rightToLeft, pickNew) in enumerate(time)]\n    rightBridgeQueue = []\n    leftWorkers = []\n    rightWorkers = []\n\n    heapq.heapify(leftBridgeQueue)\n\n    while n > 0 or rightBridgeQueue or rightWorkers:\n      while leftWorkers and leftWorkers[0][0] <= ans:\n        i = heapq.heappop(leftWorkers)[1]\n        heapq.heappush(leftBridgeQueue, (-time[i][0] - time[i][2], -i))\n      while rightWorkers and rightWorkers[0][0] <= ans:\n        i = heapq.heappop(rightWorkers)[1]\n        heapq.heappush(rightBridgeQueue, (-time[i][0] - time[i][2], -i))\n      if rightBridgeQueue:\n        i = -heapq.heappop(rightBridgeQueue)[1]\n        ans += time[i][2]\n        heapq.heappush(leftWorkers, (ans + time[i][3], i))\n      elif leftBridgeQueue and n > 0:\n        i = -heapq.heappop(leftBridgeQueue)[1]\n        ans += time[i][0]\n        heapq.heappush(rightWorkers, (ans + time[i][1], i))\n        n -= 1\n      else:\n        if leftWorkers and n > 0:\n          ans1=leftWorkers[0][0]\n        else:\n          ans1=math.inf\n        if rightWorkers:\n          ans2=rightWorkers[0][0]\n        else:\n          ans2=math.inf\n        ans=min(ans1,ans2)\n\n    return ans", "tests": ["def test_findCrossingTime(self):\n    solution = Solution()\n    self.assertEqual(solution.findCrossingTime(3, 2, [[1, 0, 5, 0], [4, 0, 8, 10]]), 15)", "def test_findCrossingTime(self):\n    solution = Solution()\n    self.assertEqual(solution.findCrossingTime(1, 3, [[10, 5, 20, 10], [15, 0, 25, 15], [20, 0, 30, 20]]), 35)", "def test_findCrossingTime(self):\n    solution = Solution()\n    self.assertEqual(solution.findCrossingTime(0, 2, [[1, 10, 5, 20], [4, 0, 8, 10]]), 10)", "def test_findCrossingTime(self):\n    solution = Solution()\n    self.assertEqual(solution.findCrossingTime(2, 1, [[100, 0, 200, 100]]), 300)", "def test_findCrossingTime(self):\n    solution = Solution()\n    self.assertEqual(solution.findCrossingTime(2, 3, [[10, 1, 20, 1], [15, 0, 25, 0], [20, 0, 30, 1]]), 31)", "def test_findCrossingTime(self):\n    solution = Solution()\n    self.assertEqual(solution.findCrossingTime(4, 2, [[1, 5, 10, 0], [3, 0, 20, 5]]), 25)", "def test_findCrossingTime(self):\n    solution = Solution()\n    self.assertEqual(solution.findCrossingTime(5, 1, [[1000, 0, 2000, 1000]]), 6000)", "def test_findCrossingTime(self):\n    solution = Solution()\n    self.assertEqual(solution.findCrossingTime(0, 1, [[1, 10, 5, 20]]), 20)", "def test_findCrossingTime(self):\n    solution = Solution()\n    self.assertEqual(solution.findCrossingTime(1, 2, [[5, 0, 10, 5], [3, 0, 20, 0]]), 15)", "def test_findCrossingTime(self):\n    solution = Solution()\n    self.assertEqual(solution.findCrossingTime(3, 1, [[1, 0, 5, 0], [4, 0, 8, 10]]), 15)", "def test_findCrossingTime(self):\n    solution = Solution()\n    self.assertEqual(solution.findCrossingTime(0, 3, [[10000, 10, 20000, 10000], [15, 0, 25000, 15], [20, 0, 30000, 20]]), 50050)", "def test_findCrossingTime(self):\n    solution = Solution()\n    self.assertEqual(solution.findCrossingTime(4, 1, [[1000, 5, 2000, 1000]]), 3005)", "def test_findCrossingTime(self):\n    solution = Solution()\n    self.assertEqual(solution.findCrossingTime(3, 2, [[10, 1, 20, 1], [15, 0, 25, 0]]), 35)", "def test_findCrossingTime(self):\n    solution = Solution()\n    self.assertEqual(solution.findCrossingTime(2, 3, [[1, 0, 5, 0], [15, 10, 20, 10], [4, 0, 8, 5]]), 30)", "def test_findCrossingTime(self):\n    solution = Solution()\n    self.assertEqual(solution.findCrossingTime(5, 2, [[10, 1, 20, 1], [4, 0, 8, 10]]), 35)", "def test_findCrossingTime(self):\n    solution = Solution()\n    self.assertEqual(solution.findCrossingTime(6, 3, [[1, 5, 10, 0], [15, 0, 25, 5], [20, 10, 30, 20]]), 75)", "def test_findCrossingTime(self):\n    solution = Solution()\n    self.assertEqual(solution.findCrossingTime(7, 1, [[1000, 5, 2000, 1000]]), 7005)", "def test_findCrossingTime(self):\n    solution = Solution()\n    self.assertEqual(solution.findCrossingTime(8, 2, [[10, 1, 20, 1], [15, 0, 25, 5]]), 45)", "def test_findCrossingTime(self):\n    solution = Solution()\n    self.assertEqual(solution.findCrossingTime(9, 3, [[1, 5, 10, 0], [15, 0, 25, 5], [20, 10, 30, 20]]), 105)", "def test_findCrossingTime(self):\n    solution = Solution()\n    self.assertEqual(solution.findCrossingTime(10, 1, [[10000, 5, 20000, 10000]]), 15005)"]}
{"task_num": 2577, "task_title": "Minimum Time to Visit a Cell In a Grid", "func_name": "minimumTime", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumTime(self, grid: List[List[int]]) -> int:\n    if grid[0][1] > 1 and grid[1][0] > 1:\n      return -1\n\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    minHeap = [(0, 0, 0)]\n    seen = {(0, 0)}\n\n    while minHeap:\n      time, i, j = heapq.heappop(minHeap)\n      if i == m - 1 and j == n - 1:\n        return time\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if (x, y) in seen:\n          continue\n        if (grid[x][y] - time) % 2 == 0:\n          extraWait = 1\n        else:\n          extraWait = 0\n        nextTime = max(time + 1, grid[x][y] + extraWait)\n        heapq.heappush(minHeap, (nextTime, x, y))\n        seen.add((x, y))\n", "tests": ["def test_minimumTime(self):\n    grid = [[0, 1], [2, 0]]\n    self.assertEqual(solution.minimumTime(grid), 1)", "def test_minimumTime(self):\n    grid = [[2, 0], [1, 2]]\n    self.assertEqual(solution.minimumTime(grid), -1)", "def test_minimumTime(self):\n    grid = [[0, 0], [1, 2]]\n    self.assertEqual(solution.minimumTime(grid), -1)", "def test_minimumTime(self):\n    grid = [[10, 20], [30, 40]]\n    self.assertEqual(solution.minimumTime(grid), 1)", "def test_minimumTime(self):\n    grid = [[0, 1, 0], [0, 1, 0]]\n    self.assertEqual(solution.minimumTime(grid), -1)", "def test_minimumTime(self):\n    grid = [[2, 1], [0, 3]]\n    self.assertEqual(solution.minimumTime(grid), -1)", "def test_minimumTime(self):\n    grid = [[0, 0], [10, 20]]\n    self.assertEqual(solution.minimumTime(grid), -1)", "def test_minimumTime(self):\n    grid = [[0, 2], [1, 3]]\n    self.assertEqual(solution.minimumTime(grid), -1)", "def test_minimumTime(self):\n    grid = [[3, 0], [2, 1]]\n    self.assertEqual(solution.minimumTime(grid), 4)", "def test_minimumTime(self):\n    grid = [[0, 2], [4, 1]]\n    self.assertEqual(solution.minimumTime(grid), 3)", "def test_minimumTime(self):\n    grid = [[5, 0], [1, 2]]\n    self.assertEqual(solution.minimumTime(grid), -1)", "def test_minimumTime(self):\n    grid = [[0, 5], [2, 1]]\n    self.assertEqual(solution.minimumTime(grid), -1)", "def test_minimumTime(self):\n    grid = [[0, 0], [10, 20]]\n    self.assertEqual(solution.minimumTime(grid), 21)", "def test_minimumTime(self):\n    grid = [[5, 0], [0, 10]]\n    self.assertEqual(solution.minimumTime(grid), -1)", "def test_minimumTime(self):\n    grid = [[10, 0], [10, 10]]\n    self.assertEqual(solution.minimumTime(grid), -1)", "def test_minimumTime(self):\n    grid = [[0, 10], [1, 0]]\n    self.assertEqual(solution.minimumTime(grid), -1)", "def test_minimumTime(self):\n    grid = [[10, 0], [20, 10]]\n    self.assertEqual(solution.minimumTime(grid), -1)", "def test_minimumTime(self):\n    grid = [[0, 10], [20, 30]]\n    self.assertEqual(solution.minimumTime(grid), -1)", "def test_minimumTime(self):\n    grid = [[0, 20], [10, 30]]\n    self.assertEqual(solution.minimumTime(grid), -1)", "def test_minimumTime(self):\n    grid = [[10, 20], [30, 40], [50, 60]]\n    self.assertEqual(solution.minimumTime(grid), -1)"]}
{"task_num": 2601, "task_title": "Prime Subtraction Operation", "func_name": "primeSubOperation", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def primeSubOperation(self, nums: List[int]) -> bool:\n    kMax = 1000\n    primes = self._sieveEratosthenes(kMax)\n\n    prevNum = 0\n    for num in nums:\n      i = bisect.bisect_left(primes, num - prevNum)\n      if i > 0:\n        num -= primes[i - 1]\n      if num <= prevNum:\n        return False\n      prevNum = num\n\n    return True\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return [i for i in range(n) if isPrime[i]]\n", "tests": ["def test_primeSubOperation():\n    solution = Solution()\n    nums = [2, 3, 5]\n    assert not solution.primeSubOperation(nums)", "def test_primeSubOperation():\n    solution = Solution()\n    nums = [5, 3, 4]\n    assert not solution.primeSubOperation(nums)", "def test_primeSubOperation():\n    solution = Solution()\n    nums = [3, 6, 7]\n    assert solution.primeSubOperation(nums)", "def test_primeSubOperation():\n    solution = Solution()\n    nums = [2, 3, 5, 7]\n    assert solution.primeSubOperation(nums)", "def test_primeSubOperation():\n    solution = Solution()\n    nums = [1000]\n    assert not solution.primeSubOperation(nums)", "def test_primeSubOperation():\n    solution = Solution()\n    nums = [2]\n    assert solution.primeSubOperation(nums)", "def test_primeSubOperation():\n    solution = Solution()\n    nums = [1019]\n    assert not solution.primeSubOperation(nums)", "def test_primeSubOperation():\n    solution = Solution()\n    nums = [11, 7, 2]\n    assert not solution.primeSubOperation(nums)", "def test_primeSubOperation():\n    solution = Solution()\n    nums = [1000000]\n    assert not solution.primeSubOperation(nums)", "def test_primeSubOperation():\n    solution = Solution()\n    nums = [7, 5, 3]\n    assert not solution.primeSubOperation(nums)", "def test_primeSubOperation():\n    solution = Solution()\n    nums = [4]\n    assert not solution.primeSubOperation(nums)", "def test_primeSubOperation():\n    solution = Solution()\n    nums = [3, 5]\n    assert not solution.primeSubOperation(nums)", "def test_primeSubOperation():\n    solution = Solution()\n    nums = [7, 8]\n    assert not solution.primeSubOperation(nums)", "def test_primeSubOperation():\n    solution = Solution()\n    nums = [1, 2]\n    assert not solution.primeSubOperation(nums)", "def test_primeSubOperation():\n    solution = Solution()\n    nums = [5, 7]\n    assert not solution.primeSubOperation(nums)", "def test_primeSubOperation():\n    solution = Solution()\n    nums = [2, 5, 7]\n    assert not solution.primeSubOperation(nums)", "def test_primeSubOperation():\n    solution = Solution()\n    nums = [3]\n    assert not solution.primeSubOperation(nums)", "def test_primeSubOperation():\n    solution = Solution()\n    nums = [7, 5]\n    assert not solution.primeSubOperation(nums)", "def test_primeSubOperation():\n    solution = Solution()\n    nums = [1009]\n    assert not solution.primeSubOperation(nums)", "def test_primeSubOperation():\n    solution = Solution()\n    nums = [11]\n    assert not solution.primeSubOperation(nums)"]}
{"task_num": 2603, "task_title": "Collect Coins in a Tree", "func_name": "collectTheCoins", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def collectTheCoins(self, coins: List[int], edges: List[List[int]]) -> int:\n    n = len(coins)\n    tree = [set() for _ in range(n)]\n    leavesToBeRemoved = collections.deque()\n\n    for u, v in edges:\n      tree[u].add(v)\n      tree[v].add(u)\n\n    for u in range(n):\n      while len(tree[u]) == 1 and coins[u] == 0:\n        v = tree[u].pop()\n        tree[v].remove(u)\n        u = v\n      if len(tree[u]) == 1:\n        leavesToBeRemoved.append(u)\n\n    for _ in range(2):\n      for _ in range(len(leavesToBeRemoved)):\n        u = leavesToBeRemoved.popleft()\n        if tree[u]:\n          v = tree[u].pop()\n          tree[v].remove(u)\n          if len(tree[v]) == 1:\n            leavesToBeRemoved.append(v)\n\n    return sum(len(children) for children in tree)\n", "tests": ["def test_collectTheCoins():\n    solution = Solution()\n    edges = [[0, 1], [0, 2], [1, 3]]\n    coins = [1, 0, 1]\n    assert solution.collectTheCoins(coins, edges) == 5", "def test_collectTheCoins():\n    solution = Solution()\n    edges = [[0, 1], [0, 2], [1, 3]]\n    coins = [1, 1, 0]\n    assert solution.collectTheCoins(coins, edges) == 4", "def test_collectTheCoins():\n    solution = Solution()\n    edges = [[0, 1], [0, 2], [1, 3]]\n    coins = [1, 0, 1]\n    assert solution.collectTheCoins(coins, edges) == 5", "def test_collectTheCoins():\n    solution = Solution()\n    edges = [[0, 1], [1, 2], [3, 4]]\n    coins = [0, 0, 0]\n    assert solution.collectTheCoins(coins, edges) == 6", "def test_collectTheCoins():\n    solution = Solution()\n    edges = [[0, 1], [0, 2], [1, 3]]\n    coins = [0, 1, 0]\n    assert solution.collectTheCoins(coins, edges) == 7", "def test_collectTheCoins():\n    solution = Solution()\n    edges = [[0, 1], [0, 2]]\n    coins = [1, 1, 1]\n    assert solution.collectTheCoins(coins, edges) == 4", "def test_collectTheCoins():\n    solution = Solution()\n    edges = []\n    coins = [1, 0, 1]\n    assert solution.collectTheCoins(coins, edges) == 2", "def test_collectTheCoins():\n    solution = Solution()\n    edges = [[0, 1], [0, 2]]\n    coins = [0, 0, 0]\n    assert solution.collectTheCoins(coins, edges) == 3", "def test_collectTheCoins():\n    solution = Solution()\n    edges = [[0, 1], [1, 2], [2, 3]]\n    coins = [1, 0, 1, 0]\n    assert solution.collectTheCoins(coins, edges) == 8", "def test_collectTheCoins():\n    solution = Solution()\n    edges = [[0, 1], [0, 2]]\n    coins = [1, 1, 1]\n    assert solution.collectTheCoins(coins, edges) == 4", "def test_collectTheCoins():\n    solution = Solution()\n    edges = [[0, 1], [1, 2]]\n    coins = [1, 0, 1]\n    assert solution.collectTheCoins(coins, edges) == 5", "def test_collectTheCoins():\n    solution = Solution()\n    edges = [[0, 1], [0, 2]]\n    coins = [1, 0, 0]\n    assert solution.collectTheCoins(coins, edges) == 5", "def test_collectTheCoins():\n    solution = Solution()\n    edges = [[0, 1], [1, 2]]\n    coins = [1, 1, 0]\n    assert solution.collectTheCoins(coins, edges) == 6", "def test_collectTheCoins():\n    solution = Solution()\n    edges = [[0, 1], [2, 3]]\n    coins = [1, 0, 1, 0]\n    assert solution.collectTheCoins(coins, edges) == 8", "def test_collectTheCoins():\n    solution = Solution()\n    edges = [[0, 1], [2, 3]]\n    coins = [0, 1, 1, 1]\n    assert solution.collectTheCoins(coins, edges) == 6", "def test_collectTheCoins():\n    solution = Solution()\n    edges = [[0, 1], [2, 3]]\n    coins = [1, 0, 0, 1]\n    assert solution.collectTheCoins(coins, edges) == 6", "def test_collectTheCoins():\n    solution = Solution()\n    edges = [[0, 1], [2, 3]]\n    coins = [0, 1, 0, 1]\n    assert solution.collectTheCoins(coins, edges) == 6", "def test_collectTheCoins():\n    solution = Solution()\n    edges = [[0, 1], [2, 3]]\n    coins = [1, 1, 0, 1]\n    assert solution.collectTheCoins(coins, edges) == 8", "def test_collectTheCoins():\n    solution = Solution()\n    edges = [[0, 1], [2, 3]]\n    coins = [1, 0, 0, 0]\n    assert solution.collectTheCoins(coins, edges) == 5", "def test_collectTheCoins():\n    solution = Solution()\n    edges = [[0, 1], [2, 3]]\n    coins = [0, 0, 1, 1]\n    assert solution.collectTheCoins(coins, edges) == 4"]}
{"task_num": 2653, "task_title": "Sliding Subarray Beauty", "func_name": "getSubarrayBeauty", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\n    ans = []\n    count = [0] * 50\n\n    for i, num in enumerate(nums):\n      if num < 0:\n        count[num + 50] += 1\n      if i - k >= 0 and nums[i - k] < 0:\n        count[nums[i - k] + 50] -= 1\n      if i + 1 >= k:\n        ans.append(self._getXthSmallestNum(count, x))\n\n    return ans\n\n  def _getXthSmallestNum(self, count: List[int], x: int) -> int:\n    prefix = 0\n    for i in range(50):\n      prefix += count[i]\n      if prefix >= x:\n        return i - 50\n    return 0\n", "tests": ["def test_getSubarrayBeauty():\n    solution = Solution()\n    nums = [1, 2, -3, -4, -5]\n    k = 3\n    x = 2\n    result = solution.getSubarrayBeauty(nums, k, x)", "def test_getSubarrayBeauty():\n    solution = Solution()\n    nums = [5, 4, -1, -3, -2]\n    k = 3\n    x = 3\n    result = solution.getSubarrayBeauty(nums, k, x)", "def test_getSubarrayBeauty():\n    solution = Solution()\n    nums = [10, -10, -20, 30]\n    k = 2\n    x = 1\n    result = solution.getSubarrayBeauty(nums, k, x)", "def test_getSubarrayBeauty():\n    solution = Solution()\n    nums = [5, -1, -3, 4, -2]\n    k = 5\n    x = 1\n    result = solution.getSubarrayBeauty(nums, k, x)", "def test_getSubarrayBeauty():\n    solution = Solution()\n    nums = [-1, -2, -3]\n    k = 1\n    x = 10\n    result = solution.getSubarrayBeauty(nums, k, x)", "def test_getSubarrayBeauty():\n    solution = Solution()\n    nums = [1, 2, 3, -4, -5]\n    k = 4\n    x = 3\n    result = solution.getSubarrayBeauty(nums, k, x)", "def test_getSubarrayBeauty():\n    solution = Solution()\n    nums = [1, -2, 3, -4, -5]\n    k = 2\n    x = 1\n    result = solution.getSubarrayBeauty(nums, k, x)", "def test_getSubarrayBeauty():\n    solution = Solution()\n    nums = [-5, -4, -3]\n    k = 1\n    x = 1\n    result = solution.getSubarrayBeauty(nums, k, x)", "def test_getSubarrayBeauty():\n    solution = Solution()\n    nums = [1, 2, -3, -4]\n    k = 5\n    x = 10\n    result = solution.getSubarrayBeauty(nums, k, x)", "def test_getSubarrayBeauty():\n    solution = Solution()\n    nums = [10, 20, 30, -5, -4]\n    k = 3\n    x = 2\n    result = solution.getSubarrayBeauty(nums, k, x)", "def test_getSubarrayBeauty():\n    solution = Solution()\n    nums = [-5, -4, -3, 1, 2]\n    k = 4\n    x = 2\n    result = solution.getSubarrayBeauty(nums, k, x)", "def test_getSubarrayBeauty():\n    solution = Solution()\n    nums = [1, 2, -3, -4, -5, 6]\n    k = 5\n    x = 10\n    result = solution.getSubarrayBeauty(nums, k, x)", "def test_getSubarrayBeauty():\n    solution = Solution()\n    nums = [-1, -2, -3, 4]\n    k = 3\n    x = 5\n    result = solution.getSubarrayBeauty(nums, k, x)", "def test_getSubarrayBeauty():\n    solution = Solution()\n    nums = [1, 2, -3, -4]\n    k = 5\n    x = 10\n    result = solution.getSubarrayBeauty(nums, k, x)", "def test_getSubarrayBeauty():\n    solution = Solution()\n    nums = [5, -1, 3, -4, -2]\n    k = 2\n    x = 10\n    result = solution.getSubarrayBeauty(nums, k, x)", "def test_getSubarrayBeauty():\n    solution = Solution()\n    nums = [10, 20, -30, -40]\n    k = 4\n    x = 1\n    result = solution.getSubarrayBeauty(nums, k, x)", "def test_getSubarrayBeauty():\n    solution = Solution()\n    nums = [-1, -2, 3, 4]\n    k = 4\n    x = 5\n    result = solution.getSubarrayBeauty(nums, k, x)", "def test_getSubarrayBeauty():\n    solution = Solution()\n    nums = [1, 2, -3, -4]\n    k = 6\n    x = 10\n    result = solution.getSubarrayBeauty(nums, k, x)", "def test_getSubarrayBeauty():\n    solution = Solution()\n    nums = [-1, -2, -3, -4]\n    k = 10\n    x = 5\n    result = solution.getSubarrayBeauty(nums, k, x)", "def test_getSubarrayBeauty():\n    solution = Solution()\n    nums = [1, 2, -3, -4, -5]\n    k = 10\n    x = 20\n    result = solution.getSubarrayBeauty(nums, k, x)"]}
{"task_num": 2662, "task_title": "Minimum Cost of a Path With Special Roads", "func_name": "minimumCost", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\n    return self.dijkstra(specialRoads, *start, *target)\n\n  def dijkstra(self, specialRoads: List[List[int]], srcX: int, srcY: int, dstX: int, dstY: int) -> int:\n    n = len(specialRoads)\n    dist = [math.inf] * n\n    minHeap = []\n\n    for u, (x1, y1, _, _, cost) in enumerate(specialRoads):\n      d = abs(x1 - srcX) + abs(y1 - srcY) + cost\n      dist[u] = d\n      heapq.heappush(minHeap, (dist[u], u))\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      _, _, ux2, uy2, _ = specialRoads[u]\n      for v in range(n):\n        if v == u:\n          continue\n        vx1, vy1, _, _, vcost = specialRoads[v]\n        newDist = d + abs(vx1 - ux2) + abs(vy1 - uy2) + vcost\n        if newDist < dist[v]:\n          dist[v] = newDist\n          heapq.heappush(minHeap, (dist[v], v))\n\n    ans = abs(dstX - srcX) + abs(dstY - srcY)\n    for u in range(n):\n      _, _, x2, y2, _ = specialRoads[u]\n      ans = min(ans, dist[u] + abs(dstX - x2) + abs(dstY - y2))\n\n    return ans\n", "tests": ["def test_minimumCost():\n\n    class Solution:\n\n        def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\n            return self.dijkstra(specialRoads, *start, *target)\n\n        def dijkstra(self, specialRoads: List[List[int]], srcX: int, srcY: int, dstX: int, dstY: int) -> int:\n            n = len(specialRoads)\n            dist = [math.inf] * n\n            minHeap = []\n            for (u, (x1, y1, _, _, cost)) in enumerate(specialRoads):\n                d = abs(x1 - srcX) + abs(y1 - srcY) + cost\n                dist[u] = d\n                heapq.heappush(minHeap, (dist[u], u))\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                (_, _, ux2, uy2, _) = specialRoads[u]\n                for v in range(n):\n                    if v == u:\n                        continue\n                    (vx1, vy1, _, _, vcost) = specialRoads[v]\n                    newDist = d + abs(vx1 - ux2) + abs(vy1 - uy2) + vcost\n                    if newDist < dist[v]:\n                        dist[v] = newDist\n                        heapq.heappush(minHeap, (dist[v], v))\n            ans = abs(dstX - srcX) + abs(dstY - srcY)\n            for u in range(n):\n                (_, _, x2, y2, _) = specialRoads[u]\n                ans = min(ans, dist[u] + abs(dstX - x2) + abs(dstY - y2))\n            return ans\n    solution = Solution()\n    start = [0, 0]\n    target = [5, 5]\n    specialRoads = [[1, 1, 4, 6, 3], [3, 3, 7, 8, 2]]\n    assert solution.minimumCost(start, target, specialRoads) == 13", "def test_minimumCost():\n\n    class Solution:\n\n        def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\n            return self.dijkstra(specialRoads, *start, *target)\n\n        def dijkstra(self, specialRoads: List[List[int]], srcX: int, srcY: int, dstX: int, dstY: int) -> int:\n            n = len(specialRoads)\n            dist = [math.inf] * n\n            minHeap = []\n            for (u, (x1, y1, _, _, cost)) in enumerate(specialRoads):\n                d = abs(x1 - srcX) + abs(y1 - srcY) + cost\n                dist[u] = d\n                heapq.heappush(minHeap, (dist[u], u))\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                (_, _, ux2, uy2, _) = specialRoads[u]\n                for v in range(n):\n                    if v == u:\n                        continue\n                    (vx1, vy1, _, _, vcost) = specialRoads[v]\n                    newDist = d + abs(vx1 - ux2) + abs(vy1 - uy2) + vcost\n                    if newDist < dist[v]:\n                        dist[v] = newDist\n                        heapq.heappush(minHeap, (dist[v], v))\n            ans = abs(dstX - srcX) + abs(dstY - srcY)\n            for u in range(n):\n                (_, _, x2, y2, _) = specialRoads[u]\n                ans = min(ans, dist[u] + abs(dstX - x2) + abs(dstY - y2))\n            return ans\n    solution = Solution()\n    start = [1, 3]\n    target = [8, 8]\n    specialRoads = [[0, 1, 5, 10, 7], [4, 6, 9, 12, 11]]\n    assert solution.minimumCost(start, target, specialRoads) == 20", "def test_minimumCost():\n\n    class Solution:\n\n        def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\n            return self.dijkstra(specialRoads, *start, *target)\n\n        def dijkstra(self, specialRoads: List[List[int]], srcX: int, srcY: int, dstX: int, dstY: int) -> int:\n            n = len(specialRoads)\n            dist = [math.inf] * n\n            minHeap = []\n            for (u, (x1, y1, _, _, cost)) in enumerate(specialRoads):\n                d = abs(x1 - srcX) + abs(y1 - srcY) + cost\n                dist[u] = d\n                heapq.heappush(minHeap, (dist[u], u))\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                (_, _, ux2, uy2, _) = specialRoads[u]\n                for v in range(n):\n                    if v == u:\n                        continue\n                    (vx1, vy1, _, _, vcost) = specialRoads[v]\n                    newDist = d + abs(vx1 - ux2) + abs(vy1 - uy2) + vcost\n                    if newDist < dist[v]:\n                        dist[v] = newDist\n                        heapq.heappush(minHeap, (dist[v], v))\n            ans = abs(dstX - srcX) + abs(dstY - srcY)\n            for u in range(n):\n                (_, _, x2, y2, _) = specialRoads[u]\n                ans = min(ans, dist[u] + abs(dstX - x2) + abs(dstY - y2))\n            return ans\n    solution = Solution()\n    start = [5, 8]\n    target = [0, 0]\n    specialRoads = [[3, 4, 6, 9, 1], [7, 8, 10, 12, 5]]\n    assert solution.minimumCost(start, target, specialRoads) == 22", "def test_minimumCost():\n\n    class Solution:\n\n        def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\n            return self.dijkstra(specialRoads, *start, *target)\n\n        def dijkstra(self, specialRoads: List[List[int]], srcX: int, srcY: int, dstX: int, dstY: int) -> int:\n            n = len(specialRoads)\n            dist = [math.inf] * n\n            minHeap = []\n            for (u, (x1, y1, _, _, cost)) in enumerate(specialRoads):\n                d = abs(x1 - srcX) + abs(y1 - srcY) + cost\n                dist[u] = d\n                heapq.heappush(minHeap, (dist[u], u))\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                (_, _, ux2, uy2, _) = specialRoads[u]\n                for v in range(n):\n                    if v == u:\n                        continue\n                    (vx1, vy1, _, _, vcost) = specialRoads[v]\n                    newDist = d + abs(vx1 - ux2) + abs(vy1 - uy2) + vcost\n                    if newDist < dist[v]:\n                        dist[v] = newDist\n                        heapq.heappush(minHeap, (dist[v], v))\n            ans = abs(dstX - srcX) + abs(dstY - srcY)\n            for u in range(n):\n                (_, _, x2, y2, _) = specialRoads[u]\n                ans = min(ans, dist[u] + abs(dstX - x2) + abs(dstY - y2))\n            return ans\n    solution = Solution()\n    start = [0, 0]\n    target = [7, 7]\n    specialRoads = [[1, 1, 5, 10, 7], [4, 6, 9, 12, 11]]\n    assert solution.minimumCost(start, target, specialRoads) == 14", "def test_minimumCost():\n\n    class Solution:\n\n        def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\n            return self.dijkstra(specialRoads, *start, *target)\n\n        def dijkstra(self, specialRoads: List[List[int]], srcX: int, srcY: int, dstX: int, dstY: int) -> int:\n            n = len(specialRoads)\n            dist = [math.inf] * n\n            minHeap = []\n            for (u, (x1, y1, _, _, cost)) in enumerate(specialRoads):\n                d = abs(x1 - srcX) + abs(y1 - srcY) + cost\n                dist[u] = d\n                heapq.heappush(minHeap, (dist[u], u))\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                (_, _, ux2, uy2, _) = specialRoads[u]\n                for v in range(n):\n                    if v == u:\n                        continue\n                    (vx1, vy1, _, _, vcost) = specialRoads[v]\n                    newDist = d + abs(vx1 - ux2) + abs(vy1 - uy2) + vcost\n                    if newDist < dist[v]:\n                        dist[v] = newDist\n                        heapq.heappush(minHeap, (dist[v], v))\n            ans = abs(dstX - srcX) + abs(dstY - srcY)\n            for u in range(n):\n                (_, _, x2, y2, _) = specialRoads[u]\n                ans = min(ans, dist[u] + abs(dstX - x2) + abs(dstY - y2))\n            return ans\n    solution = Solution()\n    start = [3, 5]\n    target = [6, 8]\n    specialRoads = [[0, 1, 4, 10, 7], [9, 11, 13, 15, 12]]\n    assert solution.minimumCost(start, target, specialRoads) == 21", "def test_minimumCost():\n\n    class Solution:\n\n        def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\n            return self.dijkstra(specialRoads, *start, *target)\n\n        def dijkstra(self, specialRoads: List[List[int]], srcX: int, srcY: int, dstX: int, dstY: int) -> int:\n            n = len(specialRoads)\n            dist = [math.inf] * n\n            minHeap = []\n            for (u, (x1, y1, _, _, cost)) in enumerate(specialRoads):\n                d = abs(x1 - srcX) + abs(y1 - srcY) + cost\n                dist[u] = d\n                heapq.heappush(minHeap, (dist[u], u))\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                (_, _, ux2, uy2, _) = specialRoads[u]\n                for v in range(n):\n                    if v == u:\n                        continue\n                    (vx1, vy1, _, _, vcost) = specialRoads[v]\n                    newDist = d + abs(vx1 - ux2) + abs(vy1 - uy2) + vcost\n                    if newDist < dist[v]:\n                        dist[v] = newDist\n                        heapq.heappush(minHeap, (dist[v], v))\n            ans = abs(dstX - srcX) + abs(dstY - srcY)\n            for u in range(n):\n                (_, _, x2, y2, _) = specialRoads[u]\n                ans = min(ans, dist[u] + abs(dstX - x2) + abs(dstY - y2))\n            return ans\n    solution = Solution()\n    start = [9, 12]\n    target = [1, 3]\n    specialRoads = [[6, 8, 13, 15, 14], [5, 7, 10, 11, 16]]\n    assert solution.minimumCost(start, target, specialRoads) == 23", "def test_minimumCost():\n\n    class Solution:\n\n        def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\n            return self.dijkstra(specialRoads, *start, *target)\n\n        def dijkstra(self, specialRoads: List[List[int]], srcX: int, srcY: int, dstX: int, dstY: int) -> int:\n            n = len(specialRoads)\n            dist = [math.inf] * n\n            minHeap = []\n            for (u, (x1, y1, _, _, cost)) in enumerate(specialRoads):\n                d = abs(x1 - srcX) + abs(y1 - srcY) + cost\n                dist[u] = d\n                heapq.heappush(minHeap, (dist[u], u))\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                (_, _, ux2, uy2, _) = specialRoads[u]\n                for v in range(n):\n                    if v == u:\n                        continue\n                    (vx1, vy1, _, _, vcost) = specialRoads[v]\n                    newDist = d + abs(vx1 - ux2) + abs(vy1 - uy2) + vcost\n                    if newDist < dist[v]:\n                        dist[v] = newDist\n                        heapq.heappush(minHeap, (dist[v], v))\n            ans = abs(dstX - srcX) + abs(dstY - srcY)\n            for u in range(n):\n                (_, _, x2, y2, _) = specialRoads[u]\n                ans = min(ans, dist[u] + abs(dstX - x2) + abs(dstY - y2))\n            return ans\n    solution = Solution()\n    start = [11, 14]\n    target = [8, 10]\n    specialRoads = [[5, 7, 13, 15, 12], [4, 6, 9, 11, 16]]\n    assert solution.minimumCost(start, target, specialRoads) == 25", "def test_minimumCost():\n\n    class Solution:\n\n        def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\n            return self.dijkstra(specialRoads, *start, *target)\n\n        def dijkstra(self, specialRoads: List[List[int]], srcX: int, srcY: int, dstX: int, dstY: int) -> int:\n            n = len(specialRoads)\n            dist = [math.inf] * n\n            minHeap = []\n            for (u, (x1, y1, _, _, cost)) in enumerate(specialRoads):\n                d = abs(x1 - srcX) + abs(y1 - srcY) + cost\n                dist[u] = d\n                heapq.heappush(minHeap, (dist[u], u))\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                (_, _, ux2, uy2, _) = specialRoads[u]\n                for v in range(n):\n                    if v == u:\n                        continue\n                    (vx1, vy1, _, _, vcost) = specialRoads[v]\n                    newDist = d + abs(vx1 - ux2) + abs(vy1 - uy2) + vcost\n                    if newDist < dist[v]:\n                        dist[v] = newDist\n                        heapq.heappush(minHeap, (dist[v], v))\n            ans = abs(dstX - srcX) + abs(dstY - srcY)\n            for u in range(n):\n                (_, _, x2, y2, _) = specialRoads[u]\n                ans = min(ans, dist[u] + abs(dstX - x2) + abs(dstY - y2))\n            return ans\n    solution = Solution()\n    start = [15, 17]\n    target = [4, 6]\n    specialRoads = [[10, 12, 16, 18, 19], [9, 11, 13, 14, 20]]\n    assert solution.minimumCost(start, target, specialRoads) == 27", "def test_minimumCost():\n\n    class Solution:\n\n        def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\n            return self.dijkstra(specialRoads, *start, *target)\n\n        def dijkstra(self, specialRoads: List[List[int]], srcX: int, srcY: int, dstX: int, dstY: int) -> int:\n            n = len(specialRoads)\n            dist = [math.inf] * n\n            minHeap = []\n            for (u, (x1, y1, _, _, cost)) in enumerate(specialRoads):\n                d = abs(x1 - srcX) + abs(y1 - srcY) + cost\n                dist[u] = d\n                heapq.heappush(minHeap, (dist[u], u))\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                (_, _, ux2, uy2, _) = specialRoads[u]\n                for v in range(n):\n                    if v == u:\n                        continue\n                    (vx1, vy1, _, _, vcost) = specialRoads[v]\n                    newDist = d + abs(vx1 - ux2) + abs(vy1 - uy2) + vcost\n                    if newDist < dist[v]:\n                        dist[v] = newDist\n                        heapq.heappush(minHeap, (dist[v], v))\n            ans = abs(dstX - srcX) + abs(dstY - srcY)\n            for u in range(n):\n                (_, _, x2, y2, _) = specialRoads[u]\n                ans = min(ans, dist[u] + abs(dstX - x2) + abs(dstY - y2))\n            return ans\n    solution = Solution()\n    start = [20, 22]\n    target = [7, 9]\n    specialRoads = [[14, 16, 18, 19, 21], [13, 15, 17, 8, 23]]\n    assert solution.minimumCost(start, target, specialRoads) == 29", "def test_minimumCost():\n\n    class Solution:\n\n        def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\n            return self.dijkstra(specialRoads, *start, *target)\n\n        def dijkstra(self, specialRoads: List[List[int]], srcX: int, srcY: int, dstX: int, dstY: int) -> int:\n            n = len(specialRoads)\n            dist = [math.inf] * n\n            minHeap = []\n            for (u, (x1, y1, _, _, cost)) in enumerate(specialRoads):\n                d = abs(x1 - srcX) + abs(y1 - srcY) + cost\n                dist[u] = d\n                heapq.heappush(minHeap, (dist[u], u))\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                (_, _, ux2, uy2, _) = specialRoads[u]\n                for v in range(n):\n                    if v == u:\n                        continue\n                    (vx1, vy1, _, _, vcost) = specialRoads[v]\n                    newDist = d + abs(vx1 - ux2) + abs(vy1 - uy2) + vcost\n                    if newDist < dist[v]:\n                        dist[v] = newDist\n                        heapq.heappush(minHeap, (dist[v], v))\n            ans = abs(dstX - srcX) + abs(dstY - srcY)\n            for u in range(n):\n                (_, _, x2, y2, _) = specialRoads[u]\n                ans = min(ans, dist[u] + abs(dstX - x2) + abs(dstY - y2))\n            return ans\n    solution = Solution()\n    start = [23, 25]\n    target = [12, 14]\n    specialRoads = [[18, 20, 22, 24, 26], [17, 19, 21, 10, 28]]\n    assert solution.minimumCost(start, target, specialRoads) == 31", "def test_minimumCost():\n\n    class Solution:\n\n        def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\n            return self.dijkstra(specialRoads, *start, *target)\n\n        def dijkstra(self, specialRoads: List[List[int]], srcX: int, srcY: int, dstX: int, dstY: int) -> int:\n            n = len(specialRoads)\n            dist = [math.inf] * n\n            minHeap = []\n            for (u, (x1, y1, _, _, cost)) in enumerate(specialRoads):\n                d = abs(x1 - srcX) + abs(y1 - srcY) + cost\n                dist[u] = d\n                heapq.heappush(minHeap, (dist[u], u))\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                (_, _, ux2, uy2, _) = specialRoads[u]\n                for v in range(n):\n                    if v == u:\n                        continue\n                    (vx1, vy1, _, _, vcost) = specialRoads[v]\n                    newDist = d + abs(vx1 - ux2) + abs(vy1 - uy2) + vcost\n                    if newDist < dist[v]:\n                        dist[v] = newDist\n                        heapq.heappush(minHeap, (dist[v], v))\n            ans = abs(dstX - srcX) + abs(dstY - srcY)\n            for u in range(n):\n                (_, _, x2, y2, _) = specialRoads[u]\n                ans = min(ans, dist[u] + abs(dstX - x2) + abs(dstY - y2))\n            return ans\n    solution = Solution()\n    start = [26, 28]\n    target = [19, 21]\n    specialRoads = [[24, 25, 27, 29, 30], [23, 25, 20, 11, 32]]\n    assert solution.minimumCost(start, target, specialRoads) == 33", "def test_minimumCost():\n\n    class Solution:\n\n        def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\n            return self.dijkstra(specialRoads, *start, *target)\n\n        def dijkstra(self, specialRoads: List[List[int]], srcX: int, srcY: int, dstX: int, dstY: int) -> int:\n            n = len(specialRoads)\n            dist = [math.inf] * n\n            minHeap = []\n            for (u, (x1, y1, _, _, cost)) in enumerate(specialRoads):\n                d = abs(x1 - srcX) + abs(y1 - srcY) + cost\n                dist[u] = d\n                heapq.heappush(minHeap, (dist[u], u))\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                (_, _, ux2, uy2, _) = specialRoads[u]\n                for v in range(n):\n                    if v == u:\n                        continue\n                    (vx1, vy1, _, _, vcost) = specialRoads[v]\n                    newDist = d + abs(vx1 - ux2) + abs(vy1 - uy2) + vcost\n                    if newDist < dist[v]:\n                        dist[v] = newDist\n                        heapq.heappush(minHeap, (dist[v], v))\n            ans = abs(dstX - srcX) + abs(dstY - srcY)\n            for u in range(n):\n                (_, _, x2, y2, _) = specialRoads[u]\n                ans = min(ans, dist[u] + abs(dstX - x2) + abs(dstY - y2))\n            return ans\n    solution = Solution()\n    start = [1, 3]\n    target = [5, 7]\n    specialRoads = [[2, 4, 6, 8, 9], [10, 11, 12, 13, 14]]\n    assert solution.minimumCost(start, target, specialRoads) == 5", "def test_minimumCost():\n\n    class Solution:\n\n        def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\n            return self.dijkstra(specialRoads, *start, *target)\n\n        def dijkstra(self, specialRoads: List[List[int]], srcX: int, srcY: int, dstX: int, dstY: int) -> int:\n            n = len(specialRoads)\n            dist = [math.inf] * n\n            minHeap = []\n            for (u, (x1, y1, _, _, cost)) in enumerate(specialRoads):\n                d = abs(x1 - srcX) + abs(y1 - srcY) + cost\n                dist[u] = d\n                heapq.heappush(minHeap, (dist[u], u))\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                (_, _, ux2, uy2, _) = specialRoads[u]\n                for v in range(n):\n                    if v == u:\n                        continue\n                    (vx1, vy1, _, _, vcost) = specialRoads[v]\n                    newDist = d + abs(vx1 - ux2) + abs(vy1 - uy2) + vcost\n                    if newDist < dist[v]:\n                        dist[v] = newDist\n                        heapq.heappush(minHeap, (dist[v], v))\n            ans = abs(dstX - srcX) + abs(dstY - srcY)\n            for u in range(n):\n                (_, _, x2, y2, _) = specialRoads[u]\n                ans = min(ans, dist[u] + abs(dstX - x2) + abs(dstY - y2))\n            return ans\n    solution = Solution()\n    start = [15, 17]\n    target = [12, 14]\n    specialRoads = [[16, 18, 19, 20, 21], [11, 13, 14, 22, 24]]\n    assert solution.minimumCost(start, target, specialRoads) == 3", "def test_minimumCost():\n\n    class Solution:\n\n        def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\n            return self.dijkstra(specialRoads, *start, *target)\n\n        def dijkstra(self, specialRoads: List[List[int]], srcX: int, srcY: int, dstX: int, dstY: int) -> int:\n            n = len(specialRoads)\n            dist = [math.inf] * n\n            minHeap = []\n            for (u, (x1, y1, _, _, cost)) in enumerate(specialRoads):\n                d = abs(x1 - srcX) + abs(y1 - srcY) + cost\n                dist[u] = d\n                heapq.heappush(minHeap, (dist[u], u))\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                (_, _, ux2, uy2, _) = specialRoads[u]\n                for v in range(n):\n                    if v == u:\n                        continue\n                    (vx1, vy1, _, _, vcost) = specialRoads[v]\n                    newDist = d + abs(vx1 - ux2) + abs(vy1 - uy2) + vcost\n                    if newDist < dist[v]:\n                        dist[v] = newDist\n                        heapq.heappush(minHeap, (dist[v], v))\n            ans = abs(dstX - srcX) + abs(dstY - srcY)\n            for u in range(n):\n                (_, _, x2, y2, _) = specialRoads[u]\n                ans = min(ans, dist[u] + abs(dstX - x2) + abs(dstY - y2))\n            return ans\n    solution = Solution()\n    start = [10, 12]\n    target = [5, 7]\n    specialRoads = [[11, 13, 15, 16, 17], [14, 18, 19, 20, 21]]\n    assert solution.minimumCost(start, target, specialRoads) == 6", "def test_minimumCost():\n\n    class Solution:\n\n        def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\n            return self.dijkstra(specialRoads, *start, *target)\n\n        def dijkstra(self, specialRoads: List[List[int]], srcX: int, srcY: int, dstX: int, dstY: int) -> int:\n            n = len(specialRoads)\n            dist = [math.inf] * n\n            minHeap = []\n            for (u, (x1, y1, _, _, cost)) in enumerate(specialRoads):\n                d = abs(x1 - srcX) + abs(y1 - srcY) + cost\n                dist[u] = d\n                heapq.heappush(minHeap, (dist[u], u))\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                (_, _, ux2, uy2, _) = specialRoads[u]\n                for v in range(n):\n                    if v == u:\n                        continue\n                    (vx1, vy1, _, _, vcost) = specialRoads[v]\n                    newDist = d + abs(vx1 - ux2) + abs(vy1 - uy2) + vcost\n                    if newDist < dist[v]:\n                        dist[v] = newDist\n                        heapq.heappush(minHeap, (dist[v], v))\n            ans = abs(dstX - srcX) + abs(dstY - srcY)\n            for u in range(n):\n                (_, _, x2, y2, _) = specialRoads[u]\n                ans = min(ans, dist[u] + abs(dstX - x2) + abs(dstY - y2))\n            return ans\n    solution = Solution()\n    start = [1, 10]\n    target = [5, 7]\n    specialRoads = [[2, 11, 14, 17, 20], [3, 12, 15, 18, 21]]\n    assert solution.minimumCost(start, target, specialRoads) == 8", "def test_minimumCost():\n\n    class Solution:\n\n        def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\n            return self.dijkstra(specialRoads, *start, *target)\n\n        def dijkstra(self, specialRoads: List[List[int]], srcX: int, srcY: int, dstX: int, dstY: int) -> int:\n            n = len(specialRoads)\n            dist = [math.inf] * n\n            minHeap = []\n            for (u, (x1, y1, _, _, cost)) in enumerate(specialRoads):\n                d = abs(x1 - srcX) + abs(y1 - srcY) + cost\n                dist[u] = d\n                heapq.heappush(minHeap, (dist[u], u))\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                (_, _, ux2, uy2, _) = specialRoads[u]\n                for v in range(n):\n                    if v == u:\n                        continue\n                    (vx1, vy1, _, _, vcost) = specialRoads[v]\n                    newDist = d + abs(vx1 - ux2) + abs(vy1 - uy2) + vcost\n                    if newDist < dist[v]:\n                        dist[v] = newDist\n                        heapq.heappush(minHeap, (dist[v], v))\n            ans = abs(dstX - srcX) + abs(dstY - srcY)\n            for u in range(n):\n                (_, _, x2, y2, _) = specialRoads[u]\n                ans = min(ans, dist[u] + abs(dstX - x2) + abs(dstY - y2))\n            return ans\n    solution = Solution()\n    start = [10, 20]\n    target = [5, 7]\n    specialRoads = [[11, 12, 13, 14, 15], [16, 17, 18, 19, 21]]\n    assert solution.minimumCost(start, target, specialRoads) == 16", "def test_minimumCost():\n\n    class Solution:\n\n        def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\n            return self.dijkstra(specialRoads, *start, *target)\n\n        def dijkstra(self, specialRoads: List[List[int]], srcX: int, srcY: int, dstX: int, dstY: int) -> int:\n            n = len(specialRoads)\n            dist = [math.inf] * n\n            minHeap = []\n            for (u, (x1, y1, _, _)) in enumerate(specialRoads):\n                d = abs(x1 - srcX) + abs(y1 - srcY)\n                dist[u] = d\n                heapq.heappush(minHeap, (dist[u], u))\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                (_, _, ux2, uy2) = specialRoads[u]\n                for v in range(n):\n                    if v == u:\n                        continue\n                    (vx1, vy1, _, _) = specialRoads[v]\n                    newDist = d + abs(vx1 - ux2) + abs(vy1 - uy2)\n                    if newDist < dist[v]:\n                        dist[v] = newDist\n                        heapq.heappush(minHeap, (dist[v], v))\n            ans = abs(dstX - srcX) + abs(dstY - srcY)\n            for u in range(n):\n                (_, _, x2, y2) = specialRoads[u]\n                ans = min(ans, dist[u] + abs(dstX - x2) + abs(dstY - y2))\n            return ans\n    solution = Solution()\n    start = [15, 25]\n    target = [10, 20]\n    specialRoads = [[16, 26, 27, 28, 29], [17, 22, 23, 24, 30]]\n    assert solution.minimumCost(start, target, specialRoads) == 44", "def test_minimumCost():\n\n    class Solution:\n\n        def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\n            return self.dijkstra(specialRoads, *start, *target)\n\n        def dijkstra(self, specialRoads: List[List[int]], srcX: int, srcY: int, dstX: int, dstY: int) -> int:\n            n = len(specialRoads)\n            dist = [math.inf] * n\n            minHeap = []\n            for (u, (x1, y1, cost)) in enumerate(specialRoads):\n                d = abs(x1 - srcX) + abs(y1 - srcY) + cost\n                dist[u] = d\n                heapq.heappush(minHeap, (dist[u], u))\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                (_, _, ux2, uy2, _) = specialRoads[u]\n                for v in range(n):\n                    if v == u:\n                        continue\n                    (vx1, vy1, cost, _) = specialRoads[v]\n                    newDist = d + abs(vx1 - ux2) + abs(vy1 - uy2) + cost\n                    if newDist < dist[v]:\n                        dist[v] = newDist\n                        heapq.heappush(minHeap, (dist[v], v))\n            ans = abs(dstX - srcX) + abs(dstY - srcY)\n            for u in range(n):\n                (_, _, x2, y2, _) = specialRoads[u]\n                ans = min(ans, dist[u] + abs(dstX - x2) + abs(dstY - y2))\n            return ans\n    solution = Solution()\n    start = [5, 10]\n    target = [15, 20]\n    specialRoads = [[6, 11, 16, 21, 26], [7, 12, 17, 22, 27]]\n    assert solution.minimumCost(start, target, specialRoads) == 66", "def test_minimumCost():\n\n    class Solution:\n\n        def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\n            return self.dijkstra(specialRoads, *start, *target)\n\n        def dijkstra(self, specialRoads: List[List[int]], srcX: int, srcY: int, dstX: int, dstY: int) -> int:\n            n = len(specialRoads)\n            dist = [math.inf] * n\n            minHeap = []\n            for (u, (x1, y1, cost, _)) in enumerate(specialRoads):\n                d = abs(x1 - srcX) + abs(y1 - srcY) + cost\n                dist[u] = d\n                heapq.heappush(minHeap, (dist[u], u))\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                (_, _, ux2, uy2, _) = specialRoads[u]\n                for v in range(n):\n                    if v == u:\n                        continue\n                    (vx1, vy1, cost, _) = specialRoads[v]\n                    newDist = d + abs(vx1 - ux2) + abs(vy1 - uy2) + cost\n                    if newDist < dist[v]:\n                        dist[v] = newDist\n                        heapq.heappush(minHeap, (dist[v], v))\n            ans = abs(dstX - srcX) + abs(dstY - srcY)\n            for u in range(n):\n                (_, _, x2, y2, _) = specialRoads[u]\n                ans = min(ans, dist[u] + abs(dstX - x2) + abs(dstY - y2))\n            return ans\n    solution = Solution()\n    start = [20, 30]\n    target = [5, 10]\n    specialRoads = [[21, 31, 16, 11, 6], [22, 32, 17, 12, 7]]\n    assert solution.minimumCost(start, target, specialRoads) == 128", "def test_minimumCost():\n\n    class Solution:\n\n        def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\n            return self.dijkstra(specialRoads, *start, *target)\n\n        def dijkstra(self, specialRoads: List[List[int]], srcX: int, srcY: int, dstX: int, dstY: int) -> int:\n            n = len(specialRoads)\n            dist = [math.inf] * n\n            minHeap = []\n            for (u, (x1, y1, cost, _)) in enumerate(specialRoads):\n                d = abs(x1 - srcX) + abs(y1 - srcY) + cost\n                dist[u] = d\n                heapq.heappush(minHeap, (dist[u], u))\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                (_, _, ux2, uy2, _) = specialRoads[u]\n                for v in range(n):\n                    if v == u:\n                        continue\n                    (vx1, vy1, cost, _) = specialRoads[v]\n                    newDist = d + abs(vx1 - ux2) + abs(vy1 - uy2) + cost\n                    if newDist < dist[v]:\n                        dist[v] = newDist\n                        heapq.heappush(minHeap, (dist[v], v))\n            ans = abs(dstX - srcX) + abs(dstY - srcY)\n            for u in range(n):\n                (_, _, x2, y2, _) = specialRoads[u]\n                ans = min(ans, dist[u] + abs(dstX - x2) + abs(dstY - y2))\n            return ans\n    solution = Solution()\n    start = [10, 15]\n    target = [25, 30]\n    specialRoads = [[11, 16, 21, 26, 31], [12, 17, 22, 27, 32]]\n    assert solution.minimumCost(start, target, specialRoads) == 256"]}
{"task_num": 2663, "task_title": "Lexicographically Smallest Beautiful String", "func_name": "smallestBeautifulString", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def smallestBeautifulString(self, s: str, k: int) -> str:\n    chars = list(s)\n\n    for i in reversed(range(len(chars))):\n      chars[i] = chr(ord(chars[i]) + 1)\n      while self._containsPalindrome(chars, i):\n        chars[i] = chr(ord(chars[i]) + 1)\n      if chars[i] < chr(ord('a') + k):\n        return self._changeSuffix(chars, i + 1)\n\n    return ''\n\n  def _containsPalindrome(self, chars: List[str], i: int) -> bool:\n    return (i > 0 and chars[i] == chars[i - 1]) or (i > 1 and chars[i] == chars[i - 2])\n\n  def _changeSuffix(self, chars: List[str], i: int) -> str:\n    for j in range(i, len(chars)):\n      chars[j] = 'a'\n      while self._containsPalindrome(chars, j):\n        chars[j] = chr(ord(chars[j]) + 1)\n    return ''.join(chars)\n", "tests": ["def test_smallestBeautifulString():\n\n    class Solution:\n\n        def smallestBeautifulString(self, s: str, k: int) -> str:\n            chars = list(s)\n            for i in reversed(range(len(chars))):\n                chars[i] = chr(ord(chars[i]) + 1)\n                while self._containsPalindrome(chars, i):\n                    chars[i] = chr(ord(chars[i]) + 1)\n                if chars[i] < chr(ord('a') + k):\n                    return self._changeSuffix(chars, i + 1)\n            return ''\n\n        def _containsPalindrome(self, chars: List[str], i: int) -> bool:\n            return i > 0 and chars[i] == chars[i - 1] or (i > 1 and chars[i] == chars[i - 2])\n\n        def _changeSuffix(self, chars: List[str], i: int) -> str:\n            for j in range(i, len(chars)):\n                chars[j] = 'a'\n                while self._containsPalindrome(chars, j):\n                    chars[j] = chr(ord(chars[j]) + 1)\n            return ''.join(chars)\n    solution = Solution()\n    assert solution.smallestBeautifulString('abc', 2) == 'abcd'", "def test_smallestBeautifulString():\n\n    class Solution:\n\n        def smallestBeautifulString(self, s: str, k: int) -> str:\n            chars = list(s)\n            for i in reversed(range(len(chars))):\n                chars[i] = chr(ord(chars[i]) + 1)\n                while self._containsPalindrome(chars, i):\n                    chars[i] = chr(ord(chars[i]) + 1)\n                if chars[i] < chr(ord('a') + k):\n                    return self._changeSuffix(chars, i + 1)\n            return ''\n\n        def _containsPalindrome(self, chars: List[str], i: int) -> bool:\n            return i > 0 and chars[i] == chars[i - 1] or (i > 1 and chars[i] == chars[i - 2])\n\n        def _changeSuffix(self, chars: List[str], i: int) -> str:\n            for j in range(i, len(chars)):\n                chars[j] = 'a'\n                while self._containsPalindrome(chars, j):\n                    chars[j] = chr(ord(chars[j]) + 1)\n            return ''.join(chars)\n    solution = Solution()\n    assert solution.smallestBeautifulString('bc', 2) == 'bd'", "def test_smallestBeautifulString():\n\n    class Solution:\n\n        def smallestBeautifulString(self, s: str, k: int) -> str:\n            chars = list(s)\n            for i in reversed(range(len(chars))):\n                chars[i] = chr(ord(chars[i]) + 1)\n                while self._containsPalindrome(chars, i):\n                    chars[i] = chr(ord(chars[i]) + 1)\n                if chars[i] < chr(ord('a') + k):\n                    return self._changeSuffix(chars, i + 1)\n            return ''\n\n        def _containsPalindrome(self, chars: List[str], i: int) -> bool:\n            return i > 0 and chars[i] == chars[i - 1] or (i > 1 and chars[i] == chars[i - 2])\n\n        def _changeSuffix(self, chars: List[str], i: int) -> str:\n            for j in range(i, len(chars)):\n                chars[j] = 'a'\n                while self._containsPalindrome(chars, j):\n                    chars[j] = chr(ord(chars[j]) + 1)\n            return ''.join(chars)\n    solution = Solution()\n    assert solution.smallestBeautifulString('abcd', 2) == ''", "def test_smallestBeautifulString():\n\n    class Solution:\n\n        def smallestBeautifulString(self, s: str, k: int) -> str:\n            chars = list(s)\n            for i in reversed(range(len(chars))):\n                chars[i] = chr(ord(chars[i]) + 1)\n                while self._containsPalindrome(chars, i):\n                    chars[i] = chr(ord(chars[i]) + 1)\n                if chars[i] < chr(ord('a') + k):\n                    return self._changeSuffix(chars, i + 1)\n            return ''\n\n        def _containsPalindrome(self, chars: List[str], i: int) -> bool:\n            return i > 0 and chars[i] == chars[i - 1] or (i > 1 and chars[i] == chars[i - 2])\n\n        def _changeSuffix(self, chars: List[str], i: int) -> str:\n            for j in range(i, len(chars)):\n                chars[j] = 'a'\n                while self._containsPalindrome(chars, j):\n                    chars[j] = chr(ord(chars[j]) + 1)\n            return ''.join(chars)\n    solution = Solution()\n    assert solution.smallestBeautifulString('', 2) == 'ab'", "def test_smallestBeautifulString():\n\n    class Solution:\n\n        def smallestBeautifulString(self, s: str, k: int) -> str:\n            chars = list(s)\n            for i in reversed(range(len(chars))):\n                chars[i] = chr(ord(chars[i]) + 1)\n                while self._containsPalindrome(chars, i):\n                    chars[i] = chr(ord(chars[i]) + 1)\n                if chars[i] < chr(ord('a') + k):\n                    return self._changeSuffix(chars, i + 1)\n            return ''\n\n        def _containsPalindrome(self, chars: List[str], i: int) -> bool:\n            return i > 0 and chars[i] == chars[i - 1] or (i > 1 and chars[i] == chars[i - 2])\n\n        def _changeSuffix(self, chars: List[str], i: int) -> str:\n            for j in range(i, len(chars)):\n                chars[j] = 'a'\n                while self._containsPalindrome(chars, j):\n                    chars[j] = chr(ord(chars[j]) + 1)\n            return ''.join(chars)\n    solution = Solution()\n    assert solution.smallestBeautifulString('zab', 2) == ''", "def test_smallestBeautifulString():\n\n    class Solution:\n\n        def smallestBeautifulString(self, s: str, k: int) -> str:\n            chars = list(s)\n            for i in reversed(range(len(chars))):\n                chars[i] = chr(ord(chars[i]) + 1)\n                while self._containsPalindrome(chars, i):\n                    chars[i] = chr(ord(chars[i]) + 1)\n                if chars[i] < chr(ord('a') + k):\n                    return self._changeSuffix(chars, i + 1)\n            return ''\n\n        def _containsPalindrome(self, chars: List[str], i: int) -> bool:\n            return i > 0 and chars[i] == chars[i - 1] or (i > 1 and chars[i] == chars[i - 2])\n\n        def _changeSuffix(self, chars: List[str], i: int) -> str:\n            for j in range(i, len(chars)):\n                chars[j] = 'a'\n                while self._containsPalindrome(chars, j):\n                    chars[j] = chr(ord(chars[j]) + 1)\n            return ''.join(chars)\n    solution = Solution()\n    assert solution.smallestBeautifulString('abcc', 2) == ''", "def test_smallestBeautifulString():\n\n    class Solution:\n\n        def smallestBeautifulString(self, s: str, k: int) -> str:\n            chars = list(s)\n            for i in reversed(range(len(chars))):\n                chars[i] = chr(ord(chars[i]) + 1)\n                while self._containsPalindrome(chars, i):\n                    chars[i] = chr(ord(chars[i]) + 1)\n                if chars[i] < chr(ord('a') + k):\n                    return self._changeSuffix(chars, i + 1)\n            return ''\n\n        def _containsPalindrome(self, chars: List[str], i: int) -> bool:\n            return i > 0 and chars[i] == chars[i - 1] or (i > 1 and chars[i] == chars[i - 2])\n\n        def _changeSuffix(self, chars: List[str], i: int) -> str:\n            for j in range(i, len(chars)):\n                chars[j] = 'a'\n                while self._containsPalindrome(chars, j):\n                    chars[j] = chr(ord(chars[j]) + 1)\n            return ''.join(chars)\n    solution = Solution()\n    assert solution.smallestBeautifulString('abcb', 2) == 'abcd'", "def test_smallestBeautifulString():\n\n    class Solution:\n\n        def smallestBeautifulString(self, s: str, k: int) -> str:\n            chars = list(s)\n            for i in reversed(range(len(chars))):\n                chars[i] = chr(ord(chars[i]) + 1)\n                while self._containsPalindrome(chars, i):\n                    chars[i] = chr(ord(chars[i]) + 1)\n                if chars[i] < chr(ord('a') + k):\n                    return self._changeSuffix(chars, i + 1)\n            return ''\n\n        def _containsPalindrome(self, chars: List[str], i: int) -> bool:\n            return i > 0 and chars[i] == chars[i - 1] or (i > 1 and chars[i] == chars[i - 2])\n\n        def _changeSuffix(self, chars: List[str], i: int) -> str:\n            for j in range(i, len(chars)):\n                chars[j] = 'a'\n                while self._containsPalindrome(chars, j):\n                    chars[j] = chr(ord(chars[j]) + 1)\n            return ''.join(chars)\n    solution = Solution()\n    assert solution.smallestBeautifulString('abcd', 3) == ''", "def test_smallestBeautifulString():\n\n    class Solution:\n\n        def smallestBeautifulString(self, s: str, k: int) -> str:\n            chars = list(s)\n            for i in reversed(range(len(chars))):\n                chars[i] = chr(ord(chars[i]) + 1)\n                while self._containsPalindrome(chars, i):\n                    chars[i] = chr(ord(chars[i]) + 1)\n                if chars[i] < chr(ord('a') + k):\n                    return self._changeSuffix(chars, i + 1)\n            return ''\n\n        def _containsPalindrome(self, chars: List[str], i: int) -> bool:\n            return i > 0 and chars[i] == chars[i - 1] or (i > 1 and chars[i] == chars[i - 2])\n\n        def _changeSuffix(self, chars: List[str], i: int) -> str:\n            for j in range(i, len(chars)):\n                chars[j] = 'a'\n                while self._containsPalindrome(chars, j):\n                    chars[j] = chr(ord(chars[j]) + 1)\n            return ''.join(chars)\n    solution = Solution()\n    assert solution.smallestBeautifulString('xyz', 2) == ''", "def test_smallestBeautifulString():\n\n    class Solution:\n\n        def smallestBeautifulString(self, s: str, k: int) -> str:\n            chars = list(s)\n            for i in reversed(range(len(chars))):\n                chars[i] = chr(ord(chars[i]) + 1)\n                while self._containsPalindrome(chars, i):\n                    chars[i] = chr(ord(chars[i]) + 1)\n                if chars[i] < chr(ord('a') + k):\n                    return self._changeSuffix(chars, i + 1)\n            return ''\n\n        def _containsPalindrome(self, chars: List[str], i: int) -> bool:\n            return i > 0 and chars[i] == chars[i - 1] or (i > 1 and chars[i] == chars[i - 2])\n\n        def _changeSuffix(self, chars: List[str], i: int) -> str:\n            for j in range(i, len(chars)):\n                chars[j] = 'a'\n                while self._containsPalindrome(chars, j):\n                    chars[j] = chr(ord(chars[j]) + 1)\n            return ''.join(chars)\n    solution = Solution()\n    assert solution.smallestBeautifulString('zzz', 2) == ''", "def test_smallestBeautifulString():\n\n    class Solution:\n\n        def smallestBeautifulString(self, s: str, k: int) -> str:\n            chars = list(s)\n            for i in reversed(range(len(chars))):\n                chars[i] = chr(ord(chars[i]) + 1)\n                while self._containsPalindrome(chars, i):\n                    chars[i] = chr(ord(chars[i]) + 1)\n                if chars[i] < chr(ord('a') + k):\n                    return self._changeSuffix(chars, i + 1)\n            return ''\n\n        def _containsPalindrome(self, chars: List[str], i: int) -> bool:\n            return i > 0 and chars[i] == chars[i - 1] or (i > 1 and chars[i] == chars[i - 2])\n\n        def _changeSuffix(self, chars: List[str], i: int) -> str:\n            for j in range(i, len(chars)):\n                chars[j] = 'a'\n                while self._containsPalindrome(chars, j):\n                    chars[j] = chr(ord(chars[j]) + 1)\n            return ''.join(chars)\n    solution = Solution()\n    assert solution.smallestBeautifulString('aaaa', 2) == ''", "def test_smallestBeautifulString():\n\n    class Solution:\n\n        def smallestBeautifulString(self, s: str, k: int) -> str:\n            chars = list(s)\n            for i in reversed(range(len(chars))):\n                chars[i] = chr(ord(chars[i]) + 1)\n                while self._containsPalindrome(chars, i):\n                    chars[i] = chr(ord(chars[i]) + 1)\n                if chars[i] < chr(ord('a') + k):\n                    return self._changeSuffix(chars, i + 1)\n            return ''\n\n        def _containsPalindrome(self, chars: List[str], i: int) -> bool:\n            return i > 0 and chars[i] == chars[i - 1] or (i > 1 and chars[i] == chars[i - 2])\n\n        def _changeSuffix(self, chars: List[str], i: int) -> str:\n            for j in range(i, len(chars)):\n                chars[j] = 'a'\n                while self._containsPalindrome(chars, j):\n                    chars[j] = chr(ord(chars[j]) + 1)\n            return ''.join(chars)\n    solution = Solution()\n    assert solution.smallestBeautifulString('az', 2) == 'ba'", "def test_smallestBeautifulString():\n\n    class Solution:\n\n        def smallestBeautifulString(self, s: str, k: int) -> str:\n            chars = list(s)\n            for i in reversed(range(len(chars))):\n                chars[i] = chr(ord(chars[i]) + 1)\n                while self._containsPalindrome(chars, i):\n                    chars[i] = chr(ord(chars[i]) + 1)\n                if chars[i] < chr(ord('a') + k):\n                    return self._changeSuffix(chars, i + 1)\n            return ''\n\n        def _containsPalindrome(self, chars: List[str], i: int) -> bool:\n            return i > 0 and chars[i] == chars[i - 1] or (i > 1 and chars[i] == chars[i - 2])\n\n        def _changeSuffix(self, chars: List[str], i: int) -> str:\n            for j in range(i, len(chars)):\n                chars[j] = 'a'\n                while self._containsPalindrome(chars, j):\n                    chars[j] = chr(ord(chars[j]) + 1)\n            return ''.join(chars)\n    solution = Solution()\n    assert solution.smallestBeautifulString('zab', 2) == 'zac'", "def test_smallestBeautifulString():\n\n    class Solution:\n\n        def smallestBeautifulString(self, s: str, k: int) -> str:\n            chars = list(s)\n            for i in reversed(range(len(chars))):\n                chars[i] = chr(ord(chars[i]) + 1)\n                while self._containsPalindrome(chars, i):\n                    chars[i] = chr(ord(chars[i]) + 1)\n                if chars[i] < chr(ord('a') + k):\n                    return self._changeSuffix(chars, i + 1)\n            return ''\n\n        def _containsPalindrome(self, chars: List[str], i: int) -> bool:\n            return i > 0 and chars[i] == chars[i - 1] or (i > 1 and chars[i] == chars[i - 2])\n\n        def _changeSuffix(self, chars: List[str], i: int) -> str:\n            for j in range(i, len(chars)):\n                chars[j] = 'a'\n                while self._containsPalindrome(chars, j):\n                    chars[j] = chr(ord(chars[j]) + 1)\n            return ''.join(chars)\n    solution = Solution()\n    assert solution.smallestBeautifulString('yza', 2) == 'zab'", "def test_smallestBeautifulString():\n\n    class Solution:\n\n        def smallestBeautifulString(self, s: str, k: int) -> str:\n            chars = list(s)\n            for i in reversed(range(len(chars))):\n                chars[i] = chr(ord(chars[i]) + 1)\n                while self._containsPalindrome(chars, i):\n                    chars[i] = chr(ord(chars[i]) + 1)\n                if chars[i] < chr(ord('a') + k):\n                    return self._changeSuffix(chars, i + 1)\n            return ''\n\n        def _containsPalindrome(self, chars: List[str], i: int) -> bool:\n            return i > 0 and chars[i] == chars[i - 1] or (i > 1 and chars[i] == chars[i - 2])\n\n        def _changeSuffix(self, chars: List[str], i: int) -> str:\n            for j in range(i, len(chars)):\n                chars[j] = 'a'\n                while self._containsPalindrome(chars, j):\n                    chars[j] = chr(ord(chars[j]) + 1)\n            return ''.join(chars)\n    solution = Solution()\n    assert solution.smallestBeautifulString('xyz', 3) == 'aba'", "def test_smallestBeautifulString():\n\n    class Solution:\n\n        def smallestBeautifulString(self, s: str, k: int) -> str:\n            chars = list(s)\n            for i in reversed(range(len(chars))):\n                chars[i] = chr(ord(chars[i]) + 1)\n                while self._containsPalindrome(chars, i):\n                    chars[i] = chr(ord(chars[i]) + 1)\n                if chars[i] < chr(ord('a') + k):\n                    return self._changeSuffix(chars, i + 1)\n            return ''\n\n        def _containsPalindrome(self, chars: List[str], i: int) -> bool:\n            return i > 0 and chars[i] == chars[i - 1] or (i > 1 and chars[i] == chars[i - 2])\n\n        def _changeSuffix(self, chars: List[str], i: int) -> str:\n            for j in range(i, len(chars)):\n                chars[j] = 'a'\n                while self._containsPalindrome(chars, j):\n                    chars[j] = chr(ord(chars[j]) + 1)\n            return ''.join(chars)\n    solution = Solution()\n    assert solution.smallestBeautifulString('abc', 4) == 'abcd'", "def test_smallestBeautifulString():\n\n    class Solution:\n\n        def smallestBeautifulString(self, s: str, k: int) -> str:\n            chars = list(s)\n            for i in reversed(range(len(chars))):\n                chars[i] = chr(ord(chars[i]) + 1)\n                while self._containsPalindrome(chars, i):\n                    chars[i] = chr(ord(chars[i]) + 1)\n                if chars[i] < chr(ord('a') + k):\n                    return self._changeSuffix(chars, i + 1)\n            return ''\n\n        def _containsPalindrome(self, chars: List[str], i: int) -> bool:\n            return i > 0 and chars[i] == chars[i - 1] or (i > 1 and chars[i] == chars[i - 2])\n\n        def _changeSuffix(self, chars: List[str], i: int) -> str:\n            for j in range(i, len(chars)):\n                chars[j] = 'a'\n                while self._containsPalindrome(chars, j):\n                    chars[j] = chr(ord(chars[j]) + 1)\n            return ''.join(chars)\n    solution = Solution()\n    assert solution.smallestBeautifulString('zzz', 5) == 'aaaa'", "def test_smallestBeautifulString():\n\n    class Solution:\n\n        def smallestBeautifulString(self, s: str, k: int) -> str:\n            chars = list(s)\n            for i in reversed(range(len(chars))):\n                chars[i] = chr(ord(chars[i]) + 1)\n                while self._containsPalindrome(chars, i):\n                    chars[i] = chr(ord(chars[i]) + 1)\n                if chars[i] < chr(ord('a') + k):\n                    return self._changeSuffix(chars, i + 1)\n            return ''\n\n        def _containsPalindrome(self, chars: List[str], i: int) -> bool:\n            return i > 0 and chars[i] == chars[i - 1] or (i > 1 and chars[i] == chars[i - 2])\n\n        def _changeSuffix(self, chars: List[str], i: int) -> str:\n            for j in range(i, len(chars)):\n                chars[j] = 'a'\n                while self._containsPalindrome(chars, j):\n                    chars[j] = chr(ord(chars[j]) + 1)\n            return ''.join(chars)\n    solution = Solution()\n    assert solution.smallestBeautifulString('baba', 2) == 'abba'", "def test_smallestBeautifulString():\n\n    class Solution:\n\n        def smallestBeautifulString(self, s: str, k: int) -> str:\n            chars = list(s)\n            for i in reversed(range(len(chars))):\n                chars[i] = chr(ord(chars[i]) + 1)\n                while self._containsPalindrome(chars, i):\n                    chars[i] = chr(ord(chars[i]) + 1)\n                if chars[i] < chr(ord('a') + k):\n                    return self._changeSuffix(chars, i + 1)\n            return ''\n\n        def _containsPalindrome(self, chars: List[str], i: int) -> bool:\n            return i > 0 and chars[i] == chars[i - 1] or (i > 1 and chars[i] == chars[i - 2])\n\n        def _changeSuffix(self, chars: List[str], i: int) -> str:\n            for j in range(i, len(chars)):\n                chars[j] = 'a'\n                while self._containsPalindrome(chars, j):\n                    chars[j] = chr(ord(chars[j]) + 1)\n            return ''.join(chars)\n    solution = Solution()\n    assert solution.smallestBeautifulString('abcd', 2) == 'abbc'", "def test_smallestBeautifulString():\n\n    class Solution:\n\n        def smallestBeautifulString(self, s: str, k: int) -> str:\n            chars = list(s)\n            for i in reversed(range(len(chars))):\n                chars[i] = chr(ord(chars[i]) + 1)\n                while self._containsPalindrome(chars, i):\n                    chars[i] = chr(ord(chars[i]) + 1)\n                if chars[i] < chr(ord('a') + k):\n                    return self._changeSuffix(chars, i + 1)\n            return ''\n\n        def _containsPalindrome(self, chars: List[str], i: int) -> bool:\n            return i > 0 and chars[i] == chars[i - 1] or (i > 1 and chars[i] == chars[i - 2])\n\n        def _changeSuffix(self, chars: List[str], i: int) -> str:\n            for j in range(i, len(chars)):\n                chars[j] = 'a'\n                while self._containsPalindrome(chars, j):\n                    chars[j] = chr(ord(chars[j]) + 1)\n            return ''.join(chars)\n    solution = Solution()\n    assert solution.smallestBeautifulString('zyx', 4) == 'abcd'"]}
{"task_num": 2672, "task_title": "Number of Adjacent Elements With the Same Color", "func_name": "colorTheArray", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\n    ans = []\n    arr = [0] * n\n    sameColors = 0\n\n    for i, color in queries:\n      if i + 1 < n:\n        if arr[i + 1] > 0 and arr[i + 1] == arr[i]:\n          sameColors -= 1\n        if arr[i + 1] == color:\n          sameColors += 1\n      if i > 0:\n        if arr[i - 1] > 0 and arr[i - 1] == arr[i]:\n          sameColors -= 1\n        if arr[i - 1] == color:\n          sameColors += 1\n      arr[i] = color\n      ans.append(sameColors)\n\n    return ans\n", "tests": ["def test_colorTheArray():\n    solution = Solution()\n    n = 3\n    queries = [[1, 2], [0, 1], [2, 2]]\n    assert solution.colorTheArray(n, queries) == [1, 0, 1]", "def test_colorTheArray():\n    solution = Solution()\n    n = 5\n    queries = [[0, 1], [2, 1], [1, 3], [4, 2]]\n    assert solution.colorTheArray(n, queries) == [1, 1, 0, 1]", "def test_colorTheArray():\n    solution = Solution()\n    n = 7\n    queries = [[3, 2], [1, 1], [6, 2], [5, 1]]\n    assert solution.colorTheArray(n, queries) == [0, 1, 0, 0]", "def test_colorTheArray():\n    solution = Solution()\n    n = 10\n    queries = [[9, 1], [0, 2], [5, 3], [8, 4]]\n    assert solution.colorTheArray(n, queries) == [1, 0, 0, 1]", "def test_colorTheArray():\n    solution = Solution()\n    n = 2\n    queries = [[0, 1], [1, 1]]\n    assert solution.colorTheArray(n, queries) == [0, 0]", "def test_colorTheArray():\n    solution = Solution()\n    n = 1\n    queries = [[0, 1]]\n    assert solution.colorTheArray(n, queries) == [0]", "def test_colorTheArray():\n    solution = Solution()\n    n = 6\n    queries = [[4, 1], [0, 2], [5, 3], [1, 2]]\n    assert solution.colorTheArray(n, queries) == [0, 0, 0, 0]", "def test_colorTheArray():\n    solution = Solution()\n    n = 4\n    queries = [[3, 2], [0, 1]]\n    assert solution.colorTheArray(n, queries) == [0, 1]", "def test_colorTheArray():\n    solution = Solution()\n    n = 8\n    queries = [[0, 1], [7, 2], [5, 3], [4, 2]]\n    assert solution.colorTheArray(n, queries) == [1, 0, 0, 1]", "def test_colorTheArray():\n    solution = Solution()\n    n = 9\n    queries = [[8, 1], [3, 2], [0, 1]]\n    assert solution.colorTheArray(n, queries) == [1, 0, 0]", "def test_colorTheArray():\n    solution = Solution()\n    n = 11\n    queries = [[10, 1], [5, 2]]\n    assert solution.colorTheArray(n, queries) == [0, 0]", "def test_colorTheArray():\n    solution = Solution()\n    n = 1\n    queries = [[0, 3]]\n    assert solution.colorTheArray(n, queries) == [0]", "def test_colorTheArray():\n    solution = Solution()\n    n = 12\n    queries = [[11, 1], [0, 2]]\n    assert solution.colorTheArray(n, queries) == [0, 0]", "def test_colorTheArray():\n    solution = Solution()\n    n = 5\n    queries = [[2, 1], [4, 3], [0, 2]]\n    assert solution.colorTheArray(n, queries) == [0, 0, 1]", "def test_colorTheArray():\n    solution = Solution()\n    n = 6\n    queries = [[0, 3], [1, 2]]\n    assert solution.colorTheArray(n, queries) == [0, 0]", "def test_colorTheArray():\n    solution = Solution()\n    n = 7\n    queries = [[2, 1], [5, 3]]\n    assert solution.colorTheArray(n, queries) == [0, 0]", "def test_colorTheArray():\n    solution = Solution()\n    n = 4\n    queries = [[2, 1], [0, 1], [3, 1]]\n    assert solution.colorTheArray(n, queries) == [0, 0, 0]", "def test_colorTheArray():\n    solution = Solution()\n    n = 5\n    queries = [[2, 3], [1, 1]]\n    assert solution.colorTheArray(n, queries) == [0, 0]", "def test_colorTheArray():\n    solution = Solution()\n    n = 8\n    queries = [[7, 2], [0, 1]]\n    assert solution.colorTheArray(n, queries) == [0, 1]", "def test_colorTheArray():\n    solution = Solution()\n    n = 9\n    queries = [[5, 3], [8, 1]]\n    assert solution.colorTheArray(n, queries) == [0, 1]"]}
{"task_num": 2684, "task_title": "Maximum Number of Moves in a Grid", "func_name": "maxMoves", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxMoves(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n\n    for j in range(n - 2, -1, -1):\n      for i in range(m):\n        if grid[i][j + 1] > grid[i][j]:\n          dp[i][j] = 1 + dp[i][j + 1]\n        if i > 0 and grid[i - 1][j + 1] > grid[i][j]:\n          dp[i][j] = max(dp[i][j], 1 + dp[i - 1][j + 1])\n        if i + 1 < m and grid[i + 1][j + 1] > grid[i][j]:\n          dp[i][j] = max(dp[i][j], 1 + dp[i + 1][j + 1])\n\n    return max(dp[i][0] for i in range(m))\n", "tests": ["def test_maxMoves():\n    solution = Solution()\n    grid = [[1, 2], [3, 4]]\n    assert solution.maxMoves(grid) == 0", "def test_maxMoves():\n    solution = Solution()\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    assert solution.maxMoves(grid) == 2", "def test_maxMoves():\n    solution = Solution()\n    grid = [[1, 4, 3], [2, 5, 6], [7, 8, 9]]\n    assert solution.maxMoves(grid) == 1", "def test_maxMoves():\n    solution = Solution()\n    grid = [[3, 6, 1], [2, 5, 4], [7, 8, 9]]\n    assert solution.maxMoves(grid) == 0", "def test_maxMoves():\n    solution = Solution()\n    grid = [[9, 8, 1], [2, 5, 4], [7, 6, 3]]\n    assert solution.maxMoves(grid) == 3", "def test_maxMoves():\n    solution = Solution()\n    grid = [[1, 2], [3, 4], [5, 6]]\n    assert solution.maxMoves(grid) == 0", "def test_maxMoves():\n    solution = Solution()\n    grid = [[5, 1, 3], [4, 2, 6], [7, 8, 9]]\n    assert solution.maxMoves(grid) == 0", "def test_maxMoves():\n    solution = Solution()\n    grid = [[1, 3, 5], [2, 4, 6]]\n    assert solution.maxMoves(grid) == 0", "def test_maxMoves():\n    solution = Solution()\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 10]]\n    assert solution.maxMoves(grid) == 0", "def test_maxMoves():\n    solution = Solution()\n    grid = [[1, 2, 3], [4, 5, 6]]\n    assert solution.maxMoves(grid) == 0", "def test_maxMoves():\n    solution = Solution()\n    grid = [[1], [3], [7]]\n    assert solution.maxMoves(grid) == 0", "def test_maxMoves():\n    solution = Solution()\n    grid = [[3], [6]]\n    assert solution.maxMoves(grid) == 0", "def test_maxMoves():\n    solution = Solution()\n    grid = [[3], [6]]\n    assert solution.maxMoves(grid) == 0", "def test_maxMoves():\n    solution = Solution()\n    grid = [[9], [8]]\n    assert solution.maxMoves(grid) == 0", "def test_maxMoves():\n    solution = Solution()\n    grid = [[3, 9], [8, 7]]\n    assert solution.maxMoves(grid) == 0", "def test_maxMoves():\n    solution = Solution()\n    grid = [[1, 2], [3, 4]]\n    assert solution.maxMoves(grid) == 0", "def test_maxMoves():\n    solution = Solution()\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    assert solution.maxMoves(grid) == 2", "def test_maxMoves():\n    solution = Solution()\n    grid = [[9, 7, 1], [3, 8, 5]]\n    assert solution.maxMoves(grid) == 0", "def test_maxMoves():\n    solution = Solution()\n    grid = [[1, 5, 3], [4, 2, 6]]\n    assert solution.maxMoves(grid) == 0", "def test_maxMoves():\n    solution = Solution()\n    grid = [[1, 4, 2], [3, 5, 6]]\n    assert solution.maxMoves(grid) == 0"]}
{"task_num": 2685, "task_title": "Count the Number of Complete Components", "func_name": "countCompleteComponents", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n    self.nodeCount = [1] * n\n    self.edgeCount = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    self.edgeCount[i] += 1\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n      self.edgeCount[j] += self.edgeCount[i]\n      self.nodeCount[j] += self.nodeCount[i]\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n      self.edgeCount[i] += self.edgeCount[j]\n      self.nodeCount[i] += self.nodeCount[j]\n    else:\n      self.id[i] = j\n      self.edgeCount[j] += self.edgeCount[i]\n      self.nodeCount[j] += self.nodeCount[i]\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n  def isComplete(self, u):\n    return self.nodeCount[u] * (self.nodeCount[u] - 1) // 2 == self.edgeCount[u]\n\n\nclass Solution:\n  def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\n    ans = 0\n    uf = UnionFind(n)\n    parents = set()\n\n    for u, v in edges:\n      uf.unionByRank(u, v)\n\n    for i in range(n):\n      parent = uf.find(i)\n      if parent not in parents and uf.isComplete(parent):\n        ans += 1\n        parents.add(parent)\n\n    return ans\n", "tests": ["def test_countCompleteComponents():\n    solution = Solution()\n\n    def assert_countCompleteComponents(self, n: int, edges: List[List[int]]) -> None:\n        self.assertEqual(solution.countCompleteComponents(n, edges), 1)", "def test_countCompleteComponents():\n    solution = Solution()\n\n    def assert_countCompleteComponents(self, n: int, edges: List[List[int]]) -> None:\n        self.assertEqual(solution.countCompleteComponents(n, []), 1)", "def test_countCompleteComponents():\n    solution = Solution()\n\n    def assert_countCompleteComponents(self, n: int, edges: List[List[int]]) -> None:\n        self.assertEqual(solution.countCompleteComponents(3, [[0, 1], [1, 2]]), 1)", "def test_countCompleteComponents():\n    solution = Solution()\n\n    def assert_countCompleteComponents(self, n: int, edges: List[List[int]]) -> None:\n        self.assertEqual(solution.countCompleteComponents(2, [[0, 1]]), 1)", "def test_countCompleteComponents():\n    solution = Solution()\n\n    def assert_countCompleteComponents(self, n: int, edges: List[List[int]]) -> None:\n        self.assertEqual(solution.countCompleteComponents(1, []), 1)", "def test_countCompleteComponents():\n    solution = Solution()\n\n    def assert_countCompleteComponents(self, n: int, edges: List[List[int]]) -> None:\n        self.assertEqual(solution.countCompleteComponents(3, [[0, 1], [1, 2], [0, 2]]), 1)", "def test_countCompleteComponents():\n    solution = Solution()\n\n    def assert_countCompleteComponents(self, n: int, edges: List[List[int]]) -> None:\n        self.assertEqual(solution.countCompleteComponents(0, []), 0)", "def test_countCompleteComponents():\n    solution = Solution()\n\n    def assert_countCompleteComponents(self, n: int, edges: List[List[int]]) -> None:\n        self.assertEqual(solution.countCompleteComponents(2, [[0, 1], [0, 1]]), 1)", "def test_countCompleteComponents():\n    solution = Solution()\n\n    def assert_countCompleteComponents(self, n: int, edges: List[List[int]]) -> None:\n        self.assertEqual(solution.countCompleteComponents(5, [[0, 1], [2, 3], [4, 4]]), 1)", "def test_countCompleteComponents():\n    solution = Solution()\n\n    def assert_countCompleteComponents(self, n: int, edges: List[List[int]]) -> None:\n        self.assertEqual(solution.countCompleteComponents(1, [[0, 0]]), 1)", "def test_countCompleteComponents():\n    solution = Solution()\n\n    def assert_countCompleteComponents(self, n: int, edges: List[List[int]]) -> None:\n        self.assertEqual(solution.countCompleteComponents(3, [[0, 1], [1, 2], [2, 0]]), 1)", "def test_countCompleteComponents():\n    solution = Solution()\n\n    def assert_countCompleteComponents(self, n: int, edges: List[List[int]]) -> None:\n        self.assertEqual(solution.countCompleteComponents(4, [[0, 1], [2, 3], [0, 3]]), 2)", "def test_countCompleteComponents():\n    solution = Solution()\n\n    def assert_countCompleteComponents(self, n: int, edges: List[List[int]]) -> None:\n        self.assertEqual(solution.countCompleteComponents(5, [[0, 1], [2, 3], [4, 4], [0, 2]]), 1)", "def test_countCompleteComponents():\n    solution = Solution()\n\n    def assert_countCompleteComponents(self, n: int, edges: List[List[int]]) -> None:\n        self.assertEqual(solution.countCompleteComponents(4, [[0, 1], [2, 3], [0, 3]]), 2)", "def test_countCompleteComponents():\n    solution = Solution()\n\n    def assert_countCompleteComponents(self, n: int, edges: List[List[int]]) -> None:\n        self.assertEqual(solution.countCompleteComponents(3, [[0, 1], [2, 2]]), 1)", "def test_countCompleteComponents():\n    solution = Solution()\n\n    def assert_countCompleteComponents(self, n: int, edges: List[List[int]]) -> None:\n        self.assertEqual(solution.countCompleteComponents(2, [[0, 1], [1, 0]]), 1)", "def test_countCompleteComponents():\n    solution = Solution()\n\n    def assert_countCompleteComponents(self, n: int, edges: List[List[int]]) -> None:\n        self.assertEqual(solution.countCompleteComponents(4, [[0, 1], [2, 3], [0, 3], [1, 2]]), 1)", "def test_countCompleteComponents():\n    solution = Solution()\n\n    def assert_countCompleteComponents(self, n: int, edges: List[List[int]]) -> None:\n        self.assertEqual(solution.countCompleteComponents(3, [[0, 1], [2, 2], [0, 2]]), 1)", "def test_countCompleteComponents():\n    solution = Solution()\n\n    def assert_countCompleteComponents(self, n: int, edges: List[List[int]]) -> None:\n        self.assertEqual(solution.countCompleteComponents(5, [[0, 1], [2, 3], [4, 4], [0, 2]]), 1)", "def test_countCompleteComponents():\n    solution = Solution()\n\n    def assert_countCompleteComponents(self, n: int, edges: List[List[int]]) -> None:\n        self.assertEqual(solution.countCompleteComponents(4, [[0, 1], [2, 3], [0, 3], [1, 2]]), 1)"]}
{"task_num": 2699, "task_title": "Modify Graph Edge Weights", "func_name": "modifiedGraphEdges", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\n\nclass Solution:\n  def modifiedGraphEdges(self, n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:\n    kMax = 2_000_000_000\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      if w == -1:\n        continue\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    distToDestination = self._dijkstra(graph, source, destination)\n    if distToDestination < target:\n      return []\n    if distToDestination == target:\n      for edge in edges:\n        if edge[2] == -1:\n          edge[2] = kMax\n      return edges\n\n    for i, (u, v, w) in enumerate(edges):\n      if w != -1:\n        continue\n      edges[i][2] = 1\n      graph[u].append((v, 1))\n      graph[v].append((u, 1))\n      distToDestination = self._dijkstra(graph, source, destination)\n      if distToDestination <= target:\n        edges[i][2] += target - distToDestination\n        for j in range(i + 1, len(edges)):\n          if edges[j][2] == -1:\n            edges[j][2] = kMax\n        return edges\n\n    return []\n\n  def _dijkstra(self, graph: List[List[int]], src: int, dst: int) -> int:\n    dist = [math.inf] * len(graph)\n    minHeap = []\n    dist[src] = 0\n    heapq.heappush(minHeap, (dist[src], src))\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist[dst]\n", "tests": ["def test_modifiedGraphEdges(self):\n    n = 5\n    edges = [[0, 1, -1], [0, 2, 7], [1, 3, 4], [1, 3, -1], [1, 4, -1]]\n    source = 0\n    destination = 4\n    target = 13\n    self.assertEqual(solution.modifiedGraphEdges(n, edges, source, destination, target), [[0, 1, 5], [0, 2, 7], [1, 3, 4]])", "def test_modifiedGraphEdges(self):\n    n = 5\n    edges = [[0, 1, -1], [0, 2, 7], [1, 3, 4], [1, 3, -1], [1, 4, -1]]\n    source = 0\n    destination = 4\n    target = 15\n    self.assertEqual(solution.modifiedGraphEdges(n, edges, source, destination, target), [])", "def test_modifiedGraphEdges(self):\n    n = 5\n    edges = []\n    source = 0\n    destination = 4\n    target = 13\n    self.assertEqual(solution.modifiedGraphEdges(n, edges, source, destination, target), [])", "def test_modifiedGraphEdges(self):\n    n = 5\n    edges = [[0, 1, -1], [0, 2, 7], [1, 3, 4], [1, 4, -1], [2, 4, -1]]\n    source = 0\n    destination = 4\n    target = 11\n    self.assertEqual(solution.modifiedGraphEdges(n, edges, source, destination, target), [[0, 1, 5], [0, 2, 7]])", "def test_modifiedGraphEdges(self):\n    n = 5\n    edges = [[0, 1, -1], [0, 2, 7], [1, 3, 4]]\n    source = 0\n    destination = 4\n    target = 2000000009\n    self.assertEqual(solution.modifiedGraphEdges(n, edges, source, destination, target), [])", "def test_modifiedGraphEdges(self):\n    n = 5\n    edges = [[0, 1, 0], [0, 2, 7]]\n    source = 0\n    destination = 4\n    target = 13\n    self.assertEqual(solution.modifiedGraphEdges(n, edges, source, destination, target), [])", "def test_modifiedGraphEdges(self):\n    n = 5\n    edges = [[0, 1, -1], [0, 2, -1], [1, 3, -1], [1, 4, -1]]\n    source = 0\n    destination = 4\n    target = 13\n    self.assertEqual(solution.modifiedGraphEdges(n, edges, source, destination, target), [])", "def test_modifiedGraphEdges(self):\n    n = 5\n    edges = [[0, 1, -1], [0, 2, 7]]\n    source = 0\n    destination = 4\n    target = 13\n    self.assertEqual(solution.modifiedGraphEdges(n, edges, source, destination, target), [])", "def test_modifiedGraphEdges(self):\n    n = 5\n    edges = [[0, 1, -1], [0, 2, 7]]\n    source = 0\n    destination = 4\n    target = 13\n    self.assertEqual(solution.modifiedGraphEdges(n, edges, source, destination, target), [])", "def test_modifiedGraphEdges(self):\n    n = 5\n    edges = [[0, 1, -1], [0, 2, 7], [1, 3, -1]]\n    source = 0\n    destination = 4\n    target = 13\n    self.assertEqual(solution.modifiedGraphEdges(n, edges, source, destination, target), [])", "def test_modifiedGraphEdges(self):\n    n = 5\n    edges = [[0, 1, -1], [0, 2, 7], [0, 3, -1]]\n    source = 0\n    destination = 4\n    target = 13\n    self.assertEqual(solution.modifiedGraphEdges(n, edges, source, destination, target), [])", "def test_modifiedGraphEdges(self):\n    n = 5\n    edges = [[0, 1, -1], [0, 2, -1], [0, 3, -1]]\n    source = 0\n    destination = 4\n    target = 13\n    self.assertEqual(solution.modifiedGraphEdges(n, edges, source, destination, target), [])", "def test_modifiedGraphEdges(self):\n    n = 2\n    edges = [[0, 1, -1]]\n    source = 0\n    destination = 1\n    target = 13\n    self.assertEqual(solution.modifiedGraphEdges(n, edges, source, destination, target), [])", "def test_modifiedGraphEdges(self):\n    n = 5\n    edges = [[0, 1, -1], [0, 2, -1], [3, 4, -1]]\n    source = 0\n    destination = 4\n    target = 13\n    self.assertEqual(solution.modifiedGraphEdges(n, edges, source, destination, target), [])", "def test_modifiedGraphEdges(self):\n    n = 5\n    edges = [[0, 1, 10], [2, 3, 20], [4, 5, 30]]\n    source = 0\n    destination = 5\n    target = 13\n    self.assertEqual(solution.modifiedGraphEdges(n, edges, source, destination, target), [])", "def test_modifiedGraphEdges(self):\n    n = 5\n    edges = [[0, 1, -10], [2, 3, 20], [4, 5, 30]]\n    source = 0\n    destination = 5\n    target = 13\n    self.assertEqual(solution.modifiedGraphEdges(n, edges, source, destination, target), [])", "def test_modifiedGraphEdges(self):\n    n = 5\n    edges = [[0, 1, -10], [2, 3, -20], [4, 5, -30]]\n    source = 0\n    destination = 5\n    target = 13\n    self.assertEqual(solution.modifiedGraphEdges(n, edges, source, destination, target), [])", "def test_modifiedGraphEdges(self):\n    n = 5\n    edges = [[0, 1, 0], [2, 3, 20], [4, 5, 30]]\n    source = 0\n    destination = 5\n    target = 13\n    self.assertEqual(solution.modifiedGraphEdges(n, edges, source, destination, target), [])", "def test_modifiedGraphEdges(self):\n    n = 5\n    edges = [[0, 1, -10], [2, 3, -20], [4, 5, -30]]\n    source = 0\n    destination = 5\n    target = 13\n    self.assertEqual(solution.modifiedGraphEdges(n, edges, source, destination, target), [])", "def test_modifiedGraphEdges(self):\n    n = 5\n    edges = [[0, 1, -10], [2, 3, -20], [4, 4, -30]]\n    source = 4\n    destination = 4\n    target = 13\n    self.assertEqual(solution.modifiedGraphEdges(n, edges, source, destination, target), [])"]}
{"task_num": 2708, "task_title": "Maximum Strength of a Group", "func_name": "maxStrength", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxStrength(self, nums: List[int]) -> int:\n    posProd = 1\n    negProd = 1\n    maxNeg = -math.inf\n    negCount = 0\n    hasPos = False\n    hasZero = False\n\n    for num in nums:\n      if num > 0:\n        posProd *= num\n        hasPos = True\n      elif num < 0:\n        negProd *= num\n        maxNeg = max(maxNeg, num)\n        negCount += 1\n      else:\n        hasZero = True\n\n    if negCount == 0 and not hasPos:\n      return 0\n    if negCount % 2 == 0:\n      return negProd * posProd\n    if negCount >= 3:\n      return negProd // maxNeg * posProd\n    if hasPos:\n      return posProd\n    if hasZero:\n      return 0\n    return maxNeg\n", "tests": ["def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([10, -2, 5]) == 100", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([1, -2, 3, 4]) == 12", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([0, -2]) == 0", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([1, -2, -3]) == 6", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([-1, -2]) == 0", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([-1, -2, 3]) == 3", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([2 ** 31]) == 0", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([1] * 10000) == 1", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([0] * 10000) == 0", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([-1] * 10000) == 0", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([5] + [-1] * 10000) == 0", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([10 ** 9]) == 0", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([10 ** 9 - 1]) == 0", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([-10 ** 9] + [1] * 10000) == 0", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([-10 ** 9, -2]) == 0", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([10 ** 31]) == 0", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([10 ** 31 - 1]) == 0", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([-2 ** 31] + [1] * 10000) == 0", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([2 ** 31 - 1]) == 0", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([2 ** 31 - 1] * 5) == (2 ** 31 - 1) ** 4"]}
{"task_num": 2709, "task_title": "Greatest Common Divisor Traversal", "func_name": "canTraverseAllPairs", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.sz = [1] * n\n\n  def unionBySize(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.sz[i] < self.sz[j]:\n      self.sz[j] += self.sz[i]\n      self.id[i] = j\n    else:\n      self.sz[i] += self.sz[j]\n      self.id[j] = i\n\n  def getSize(self, i: int) -> int:\n    return self.sz[i]\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def canTraverseAllPairs(self, nums: List[int]) -> bool:\n    n = len(nums)\n    max_num = max(nums)\n    maxPrimeFactor = self._sieveEratosthenes(max_num + 1)\n    primeToFirstIndex = collections.defaultdict(int)\n    uf = UnionFind(n)\n\n    for i, num in enumerate(nums):\n      for prime_factor in self._getPrimeFactors(num, maxPrimeFactor):\n        if prime_factor in primeToFirstIndex:\n          uf.unionBySize(primeToFirstIndex[prime_factor], i)\n        else:\n          primeToFirstIndex[prime_factor] = i\n\n    return any(uf.getSize(i) == n for i in range(n))\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeFactors(self, num: int, minPrimeFactors: List[int]) -> List[int]:\n    primeFactors = []\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      primeFactors.append(divisor)\n      while num % divisor == 0:\n        num //= divisor\n    return primeFactors\n", "tests": ["def test_canTraverseAllPairs(self):\n\n    class Solution:\n\n        def canTraverseAllPairs(self, nums: List[int]) -> bool:\n            n = len(nums)\n            max_num = max(nums)\n            maxPrimeFactor = self._sieveEratosthenes(max_num + 1)\n            primeToFirstIndex = collections.defaultdict(int)\n            uf = UnionFind(n)\n            for (i, num) in enumerate(nums):\n                for prime_factor in self._getPrimeFactors(num, maxPrimeFactor):\n                    if prime_factor in primeToFirstIndex:\n                        uf.unionBySize(primeToFirstIndex[prime_factor], i)\n                    else:\n                        primeToFirstIndex[prime_factor] = i\n            return any((uf.getSize(i) == n for i in range(n)))\n\n        def _sieveEratosthenes(self, n: int) -> List[int]:\n            minPrimeFactors = [i for i in range(n + 1)]\n            for i in range(2, int(n ** 0.5) + 1):\n                if minPrimeFactors[i] == i:\n                    for j in range(i * i, n, i):\n                        minPrimeFactors[j] = min(minPrimeFactors[j], i)\n            return minPrimeFactors\n\n        def _getPrimeFactors(self, num: int, minPrimeFactors: List[int]) -> List[int]:\n            primeFactors = []\n            while num > 1:\n                divisor = minPrimeFactors[num]\n                primeFactors.append(divisor)\n                while num % divisor == 0:\n                    num //= divisor\n            return primeFactors\n\n        def __init__(self):\n            self.id = list(range(3))\n            self.sz = [1] * 3\n    solution = Solution()\n    nums = [2, 6, 8, 10]\n    self.assertTrue(solution.canTraverseAllPairs(nums))", "def test_canTraverseAllPairs(self):\n\n    class Solution:\n\n        def canTraverseAllPairs(self, nums: List[int]) -> bool:\n            n = len(nums)\n            max_num = max(nums)\n            maxPrimeFactor = self._sieveEratosthenes(max_num + 1)\n            primeToFirstIndex = collections.defaultdict(int)\n            uf = UnionFind(n)\n            for (i, num) in enumerate(nums):\n                for prime_factor in self._getPrimeFactors(num, maxPrimeFactor):\n                    if prime_factor in primeToFirstIndex:\n                        uf.unionBySize(primeToFirstIndex[prime_factor], i)\n                    else:\n                        primeToFirstIndex[prime_factor] = i\n            return any((uf.getSize(i) == n for i in range(n)))\n\n        def _sieveEratosthenes(self, n: int) -> List[int]:\n            minPrimeFactors = [i for i in range(n + 1)]\n            for i in range(2, int(n ** 0.5) + 1):\n                if minPrimeFactors[i] == i:\n                    for j in range(i * i, n, i):\n                        minPrimeFactors[j] = min(minPrimeFactors[j], i)\n            return minPrimeFactors\n\n        def _getPrimeFactors(self, num: int, minPrimeFactors: List[int]) -> List[int]:\n            primeFactors = []\n            while num > 1:\n                divisor = minPrimeFactors[num]\n                primeFactors.append(divisor)\n                while num % divisor == 0:\n                    num //= divisor\n            return primeFactors\n\n        def __init__(self):\n            self.id = list(range(3))\n            self.sz = [1] * 3\n    solution = Solution()\n    nums = []\n    self.assertFalse(solution.canTraverseAllPairs(nums))", "def test_canTraverseAllPairs(self):\n\n    class Solution:\n\n        def canTraverseAllPairs(self, nums: List[int]) -> bool:\n            n = len(nums)\n            max_num = max(nums)\n            maxPrimeFactor = self._sieveEratosthenes(max_num + 1)\n            primeToFirstIndex = collections.defaultdict(int)\n            uf = UnionFind(n)\n            for (i, num) in enumerate(nums):\n                for prime_factor in self._getPrimeFactors(num, maxPrimeFactor):\n                    if prime_factor in primeToFirstIndex:\n                        uf.unionBySize(primeToFirstIndex[prime_factor], i)\n                    else:\n                        primeToFirstIndex[prime_factor] = i\n            return any((uf.getSize(i) == n for i in range(n)))\n\n        def _sieveEratosthenes(self, n: int) -> List[int]:\n            minPrimeFactors = [i for i in range(n + 1)]\n            for i in range(2, int(n ** 0.5) + 1):\n                if minPrimeFactors[i] == i:\n                    for j in range(i * i, n, i):\n                        minPrimeFactors[j] = min(minPrimeFactors[j], i)\n            return minPrimeFactors\n\n        def _getPrimeFactors(self, num: int, minPrimeFactors: List[int]) -> List[int]:\n            primeFactors = []\n            while num > 1:\n                divisor = minPrimeFactors[num]\n                primeFactors.append(divisor)\n                while num % divisor == 0:\n                    num //= divisor\n            return primeFactors\n\n        def __init__(self):\n            self.id = list(range(3))\n            self.sz = [1] * 3\n    solution = Solution()\n    nums = [1, 2, 3]\n    self.assertFalse(solution.canTraverseAllPairs(nums))", "def test_canTraverseAllPairs(self):\n\n    class Solution:\n\n        def canTraverseAllPairs(self, nums: List[int]) -> bool:\n            n = len(nums)\n            max_num = max(nums)\n            maxPrimeFactor = self._sieveEratosthenes(max_num + 1)\n            primeToFirstIndex = collections.defaultdict(int)\n            uf = UnionFind(n)\n            for (i, num) in enumerate(nums):\n                for prime_factor in self._getPrimeFactors(num, maxPrimeFactor):\n                    if prime_factor in primeToFirstIndex:\n                        uf.unionBySize(primeToFirstIndex[prime_factor], i)\n                    else:\n                        primeToFirstIndex[prime_factor] = i\n            return any((uf.getSize(i) == n for i in range(n)))\n\n        def _sieveEratosthenes(self, n: int) -> List[int]:\n            minPrimeFactors = [i for i in range(n + 1)]\n            for i in range(2, int(n ** 0.5) + 1):\n                if minPrimeFactors[i] == i:\n                    for j in range(i * i, n, i):\n                        minPrimeFactors[j] = min(minPrimeFactors[j], i)\n            return minPrimeFactors\n\n        def _getPrimeFactors(self, num: int, minPrimeFactors: List[int]) -> List[int]:\n            primeFactors = []\n            while num > 1:\n                divisor = minPrimeFactors[num]\n                primeFactors.append(divisor)\n                while num % divisor == 0:\n                    num //= divisor\n            return primeFactors\n\n        def __init__(self):\n            self.id = list(range(3))\n            self.sz = [1] * 3\n    solution = Solution()\n    nums = [4, 6, 8]\n    self.assertTrue(solution.canTraverseAllPairs(nums))", "def test_canTraverseAllPairs(self):\n\n    class Solution:\n\n        def canTraverseAllPairs(self, nums: List[int]) -> bool:\n            n = len(nums)\n            max_num = max(nums)\n            maxPrimeFactor = self._sieveEratosthenes(max_num + 1)\n            primeToFirstIndex = collections.defaultdict(int)\n            uf = UnionFind(n)\n            for (i, num) in enumerate(nums):\n                for prime_factor in self._getPrimeFactors(num, maxPrimeFactor):\n                    if prime_factor in primeToFirstIndex:\n                        uf.unionBySize(primeToFirstIndex[prime_factor], i)\n                    else:\n                        primeToFirstIndex[prime_factor] = i\n            return any((uf.getSize(i) == n for i in range(n)))\n\n        def _sieveEratosthenes(self, n: int) -> List[int]:\n            minPrimeFactors = [i for i in range(n + 1)]\n            for i in range(2, int(n ** 0.5) + 1):\n                if minPrimeFactors[i] == i:\n                    for j in range(i * i, n, i):\n                        minPrimeFactors[j] = min(minPrimeFactors[j], i)\n            return minPrimeFactors\n\n        def _getPrimeFactors(self, num: int, minPrimeFactors: List[int]) -> List[int]:\n            primeFactors = []\n            while num > 1:\n                divisor = minPrimeFactors[num]\n                primeFactors.append(divisor)\n                while num % divisor == 0:\n                    num //= divisor\n            return primeFactors\n\n        def __init__(self):\n            self.id = list(range(3))\n            self.sz = [1] * 3\n    solution = Solution()\n    nums = [4, 6, 8, 12]\n    self.assertTrue(solution.canTraverseAllPairs(nums))", "def test_canTraverseAllPairs(self):\n\n    class Solution:\n\n        def canTraverseAllPairs(self, nums: List[int]) -> bool:\n            n = len(nums)\n            max_num = max(nums)\n            maxPrimeFactor = self._sieveEratosthenes(max_num + 1)\n            primeToFirstIndex = collections.defaultdict(int)\n            uf = UnionFind(n)\n            for (i, num) in enumerate(nums):\n                for prime_factor in self._getPrimeFactors(num, maxPrimeFactor):\n                    if prime_factor in primeToFirstIndex:\n                        uf.unionBySize(primeToFirstIndex[prime_factor], i)\n                    else:\n                        primeToFirstIndex[prime_factor] = i\n            return any((uf.getSize(i) == n for i in range(n)))\n\n        def _sieveEratosthenes(self, n: int) -> List[int]:\n            minPrimeFactors = [i for i in range(n + 1)]\n            for i in range(2, int(n ** 0.5) + 1):\n                if minPrimeFactors[i] == i:\n                    for j in range(i * i, n, i):\n                        minPrimeFactors[j] = min(minPrimeFactors[j], i)\n            return minPrimeFactors\n\n        def _getPrimeFactors(self, num: int, minPrimeFactors: List[int]) -> List[int]:\n            primeFactors = []\n            while num > 1:\n                divisor = minPrimeFactors[num]\n                primeFactors.append(divisor)\n                while num % divisor == 0:\n                    num //= divisor\n            return primeFactors\n\n        def __init__(self):\n            self.id = list(range(3))\n            self.sz = [1] * 3\n    solution = Solution()\n    nums = [2, 4, 6, 8, 10, 12, 14, 16, 18]\n    self.assertTrue(solution.canTraverseAllPairs(nums))", "def test_canTraverseAllPairs(self):\n\n    class Solution:\n\n        def canTraverseAllPairs(self, nums: List[int]) -> bool:\n            n = len(nums)\n            max_num = max(nums)\n            maxPrimeFactor = self._sieveEratosthenes(max_num + 1)\n            primeToFirstIndex = collections.defaultdict(int)\n            uf = UnionFind(n)\n            for (i, num) in enumerate(nums):\n                for prime_factor in self._getPrimeFactors(num, maxPrimeFactor):\n                    if prime_factor in primeToFirstIndex:\n                        uf.unionBySize(primeToFirstIndex[prime_factor], i)\n                    else:\n                        primeToFirstIndex[prime_factor] = i\n            return any((uf.getSize(i) == n for i in range(n)))\n\n        def _sieveEratosthenes(self, n: int) -> List[int]:\n            minPrimeFactors = [i for i in range(n + 1)]\n            for i in range(2, int(n ** 0.5) + 1):\n                if minPrimeFactors[i] == i:\n                    for j in range(i * i, n, i):\n                        minPrimeFactors[j] = min(minPrimeFactors[j], i)\n            return minPrimeFactors\n\n        def _getPrimeFactors(self, num: int, minPrimeFactors: List[int]) -> List[int]:\n            primeFactors = []\n            while num > 1:\n                divisor = minPrimeFactors[num]\n                primeFactors.append(divisor)\n                while num % divisor == 0:\n                    num //= divisor\n            return primeFactors\n\n        def __init__(self):\n            self.id = list(range(3))\n            self.sz = [1] * 3\n    solution = Solution()\n    nums = [2, 3, 5, 7]\n    self.assertTrue(solution.canTraverseAllPairs(nums))", "def test_canTraverseAllPairs(self):\n\n    class Solution:\n\n        def canTraverseAllPairs(self, nums: List[int]) -> bool:\n            n = len(nums)\n            max_num = max(nums)\n            maxPrimeFactor = self._sieveEratosthenes(max_num + 1)\n            primeToFirstIndex = collections.defaultdict(int)\n            uf = UnionFind(n)\n            for (i, num) in enumerate(nums):\n                for prime_factor in self._getPrimeFactors(num, maxPrimeFactor):\n                    if prime_factor in primeToFirstIndex:\n                        uf.unionBySize(primeToFirstIndex[prime_factor], i)\n                    else:\n                        primeToFirstIndex[prime_factor] = i\n            return any((uf.getSize(i) == n for i in range(n)))\n\n        def _sieveEratosthenes(self, n: int) -> List[int]:\n            minPrimeFactors = [i for i in range(n + 1)]\n            for i in range(2, int(n ** 0.5) + 1):\n                if minPrimeFactors[i] == i:\n                    for j in range(i * i, n, i):\n                        minPrimeFactors[j] = min(minPrimeFactors[j], i)\n            return minPrimeFactors\n\n        def _getPrimeFactors(self, num: int, minPrimeFactors: List[int]) -> List[int]:\n            primeFactors = []\n            while num > 1:\n                divisor = minPrimeFactors[num]\n                primeFactors.append(divisor)\n                while num % divisor == 0:\n                    num //= divisor\n            return primeFactors\n\n        def __init__(self):\n            self.id = list(range(3))\n            self.sz = [1] * 3\n    solution = Solution()\n    nums = [2, 4, 6]\n    self.assertFalse(solution.canTraverseAllPairs(nums))", "def test_canTraverseAllPairs(self):\n\n    class Solution:\n\n        def canTraverseAllPairs(self, nums: List[int]) -> bool:\n            n = len(nums)\n            max_num = max((abs(x) for x in nums))\n            maxPrimeFactor = self._sieveEratosthenes(max_num + 1)\n            primeToFirstIndex = collections.defaultdict(int)\n            uf = UnionFind(n)\n            for (i, num) in enumerate(nums):\n                for prime_factor in self._getPrimeFactors(abs(num), maxPrimeFactor):\n                    if prime_factor in primeToFirstIndex:\n                        uf.unionBySize(primeToFirstIndex[prime_factor], i)\n                    else:\n                        primeToFirstIndex[prime_factor] = i\n            return any((uf.getSize(i) == n for i in range(n)))\n\n        def _sieveEratosthenes(self, n: int) -> List[int]:\n            minPrimeFactors = [i for i in range(n + 1)]\n            for i in range(2, int(n ** 0.5) + 1):\n                if minPrimeFactors[i] == i:\n                    for j in range(i * i, n, i):\n                        minPrimeFactors[j] = min(minPrimeFactors[j], i)\n            return minPrimeFactors\n\n        def _getPrimeFactors(self, num: int, minPrimeFactors: List[int]) -> List[int]:\n            primeFactors = []\n            while num > 1:\n                divisor = minPrimeFactors[num]\n                primeFactors.append(divisor)\n                while num % divisor == 0:\n                    num //= divisor\n            return primeFactors\n\n        def __init__(self):\n            self.id = list(range(3))\n            self.sz = [1] * 3\n    solution = Solution()\n    nums = [-2, -4, -6]\n    self.assertTrue(solution.canTraverseAllPairs(nums))", "def test_canTraverseAllPairs(self):\n\n    class Solution:\n\n        def canTraverseAllPairs(self, nums: List[int]) -> bool:\n            n = len(nums)\n            max_num = max((abs(x) for x in nums))\n            maxPrimeFactor = self._sieveEratosthenes(max_num + 1)\n            primeToFirstIndex = collections.defaultdict(int)\n            uf = UnionFind(n)\n            for (i, num) in enumerate(nums):\n                for prime_factor in self._getPrimeFactors(abs(num), maxPrimeFactor):\n                    if prime_factor in primeToFirstIndex:\n                        uf.unionBySize(primeToFirstIndex[prime_factor], i)\n                    else:\n                        primeToFirstIndex[prime_factor] = i\n            return any((uf.getSize(i) == n for i in range(n)))\n\n        def _sieveEratosthenes(self, n: int) -> List[int]:\n            minPrimeFactors = [i for i in range(n + 1)]\n            for i in range(2, int(n ** 0.5) + 1):\n                if minPrimeFactors[i] == i:\n                    for j in range(i * i, n, i):\n                        minPrimeFactors[j] = min(minPrimeFactors[j], i)\n            return minPrimeFactors\n\n        def _getPrimeFactors(self, num: int, minPrimeFactors: List[int]) -> List[int]:\n            primeFactors = []\n            while num > 1:\n                divisor = minPrimeFactors[num]\n                primeFactors.append(divisor)\n                while num % divisor == 0:\n                    num //= divisor\n            return primeFactors\n\n        def __init__(self):\n            self.id = list(range(3))\n            self.sz = [1] * 3\n    solution = Solution()\n    nums = [0, -2, 4]\n    self.assertTrue(solution.canTraverseAllPairs(nums))", "def test_canTraverseAllPairs(self):\n\n    class Solution:\n\n        def canTraverseAllPairs(self, nums: List[int]) -> bool:\n            n = len(nums)\n            max_num = max((abs(x) for x in nums))\n            maxPrimeFactor = self._sieveEratosthenes(max_num + 1)\n            primeToFirstIndex = collections.defaultdict(int)\n            uf = UnionFind(n)\n            for (i, num) in enumerate(nums):\n                for prime_factor in self._getPrimeFactors(abs(num), maxPrimeFactor):\n                    if prime_factor in primeToFirstIndex:\n                        uf.unionBySize(primeToFirstIndex[prime_factor], i)\n                    else:\n                        primeToFirstIndex[prime_factor] = i\n            return any((uf.getSize(i) == n for i in range(n)))\n\n        def _sieveEratosthenes(self, n: int) -> List[int]:\n            minPrimeFactors = [i for i in range(n + 1)]\n            for i in range(2, int(n ** 0.5) + 1):\n                if minPrimeFactors[i] == i:\n                    for j in range(i * i, n, i):\n                        minPrimeFactors[j] = min(minPrimeFactors[j], i)\n            return minPrimeFactors\n\n        def _getPrimeFactors(self, num: int, minPrimeFactors: List[int]) -> List[int]:\n            primeFactors = []\n            while num > 1:\n                divisor = minPrimeFactors[num]\n                primeFactors.append(divisor)\n                while num % divisor == 0:\n                    num //= divisor\n            return primeFactors\n\n        def __init__(self):\n            self.id = list(range(3))\n            self.sz = [1] * 3\n    solution = Solution()\n    nums = []\n    self.assertTrue(solution.canTraverseAllPairs(nums))", "def test_canTraverseAllPairs(self):\n\n    class Solution:\n\n        def canTraverseAllPairs(self, nums: List[int]) -> bool:\n            n = len(nums)\n            max_num = max((abs(x) for x in nums))\n            maxPrimeFactor = self._sieveEratosthenes(max_num + 1)\n            primeToFirstIndex = collections.defaultdict(int)\n            uf = UnionFind(n)\n            for (i, num) in enumerate(nums):\n                for prime_factor in self._getPrimeFactors(abs(num), maxPrimeFactor):\n                    if prime_factor in primeToFirstIndex:\n                        uf.unionBySize(primeToFirstIndex[prime_factor], i)\n                    else:\n                        primeToFirstIndex[prime_factor] = i\n            return any((uf.getSize(i) == n for i in range(n)))\n\n        def _sieveEratosthenes(self, n: int) -> List[int]:\n            minPrimeFactors = [i for i in range(n + 1)]\n            for i in range(2, int(n ** 0.5) + 1):\n                if minPrimeFactors[i] == i:\n                    for j in range(i * i, n, i):\n                        minPrimeFactors[j] = min(minPrimeFactors[j], i)\n            return minPrimeFactors\n\n        def _getPrimeFactors(self, num: int, minPrimeFactors: List[int]) -> List[int]:\n            primeFactors = []\n            while num > 1:\n                divisor = minPrimeFactors[num]\n                primeFactors.append(divisor)\n                while num % divisor == 0:\n                    num //= divisor\n            return primeFactors\n\n        def __init__(self):\n            self.id = list(range(3))\n            self.sz = [1] * 3\n    solution = Solution()\n    nums = [5]\n    self.assertTrue(solution.canTraverseAllPairs(nums))", "def test_canTraverseAllPairs(self):\n\n    class Solution:\n\n        def canTraverseAllPairs(self, nums: List[int]) -> bool:\n            n = len(nums)\n            max_num = max((abs(x) for x in nums))\n            maxPrimeFactor = self._sieveEratosthenes(max_num + 1)\n            primeToFirstIndex = collections.defaultdict(int)\n            uf = UnionFind(n)\n            for (i, num) in enumerate(nums):\n                for prime_factor in self._getPrimeFactors(abs(num), maxPrimeFactor):\n                    if prime_factor in primeToFirstIndex:\n                        uf.unionBySize(primeToFirstIndex[prime_factor], i)\n                    else:\n                        primeToFirstIndex[prime_factor] = i\n            return any((uf.getSize(i) == n for i in range(n)))\n\n        def _sieveEratosthenes(self, n: int) -> List[int]:\n            minPrimeFactors = [i for i in range(n + 1)]\n            for i in range(2, int(n ** 0.5) + 1):\n                if minPrimeFactors[i] == i:\n                    for j in range(i * i, n, i):\n                        minPrimeFactors[j] = min(minPrimeFactors[j], i)\n            return minPrimeFactors\n\n        def _getPrimeFactors(self, num: int, minPrimeFactors: List[int]) -> List[int]:\n            primeFactors = []\n            while num > 1:\n                divisor = minPrimeFactors[num]\n                primeFactors.append(divisor)\n                while num % divisor == 0:\n                    num //= divisor\n            return primeFactors\n\n        def __init__(self):\n            self.id = list(range(3))\n            self.sz = [1] * 3\n    solution = Solution()\n    nums = [i for i in range(100000)]\n    self.assertTrue(solution.canTraverseAllPairs(nums))", "def test_canTraverseAllPairs(self):\n\n    class Solution:\n\n        def canTraverseAllPairs(self, nums: List[int]) -> bool:\n            n = len(nums)\n            max_num = max((abs(x) for x in nums))\n            maxPrimeFactor = self._sieveEratosthenes(max_num + 1)\n            primeToFirstIndex = collections.defaultdict(int)\n            uf = UnionFind(n)\n            for (i, num) in enumerate(nums):\n                for prime_factor in self._getPrimeFactors(abs(num), maxPrimeFactor):\n                    if prime_factor in primeToFirstIndex:\n                        uf.unionBySize(primeToFirstIndex[prime_factor], i)\n                    else:\n                        primeToFirstIndex[prime_factor] = i\n            return any((uf.getSize(i) == n for i in range(n)))\n\n        def _sieveEratosthenes(self, n: int) -> List[int]:\n            minPrimeFactors = [i for i in range(n + 1)]\n            for i in range(2, int(n ** 0.5) + 1):\n                if minPrimeFactors[i] == i:\n                    for j in range(i * i, n, i):\n                        minPrimeFactors[j] = min(minPrimeFactors[j], i)\n            return minPrimeFactors\n\n        def _getPrimeFactors(self, num: int, minPrimeFactors: List[int]) -> List[int]:\n            primeFactors = []\n            while num > 1:\n                divisor = minPrimeFactors[num]\n                primeFactors.append(divisor)\n                while num % divisor == 0:\n                    num //= divisor\n            return primeFactors\n\n        def __init__(self):\n            self.id = list(range(3))\n            self.sz = [1] * 3\n    solution = Solution()\n    nums = ['a', 'b', 'c']\n    with self.assertRaises(TypeError):\n        solution.canTraverseAllPairs(nums)", "def test_canTraverseAllPairs(self):\n\n    class Solution:\n\n        def canTraverseAllPairs(self, nums: List[int]) -> bool:\n            n = len(nums)\n            max_num = max((abs(x) for x in nums))\n            maxPrimeFactor = self._sieveEratosthenes(max_num + 1)\n            primeToFirstIndex = collections.defaultdict(int)\n            uf = UnionFind(n)\n            for (i, num) in enumerate(nums):\n                for prime_factor in self._getPrimeFactors(abs(num), maxPrimeFactor):\n                    if prime_factor in primeToFirstIndex:\n                        uf.unionBySize(primeToFirstIndex[prime_factor], i)\n                    else:\n                        primeToFirstIndex[prime_factor] = i\n            return any((uf.getSize(i) == n for i in range(n)))\n\n        def _sieveEratosthenes(self, n: int) -> List[int]:\n            minPrimeFactors = [i for i in range(n + 1)]\n            for i in range(2, int(n ** 0.5) + 1):\n                if minPrimeFactors[i] == i:\n                    for j in range(i * i, n, i):\n                        minPrimeFactors[j] = min(minPrimeFactors[j], i)\n            return minPrimeFactors\n\n        def _getPrimeFactors(self, num: int, minPrimeFactors: List[int]) -> List[int]:\n            primeFactors = []\n            while num > 1:\n                divisor = minPrimeFactors[num]\n                primeFactors.append(divisor)\n                while num % divisor == 0:\n                    num //= divisor\n            return primeFactors\n\n        def __init__(self):\n            self.id = list(range(3))\n            self.sz = [1] * 3\n    solution = Solution()\n    nums = [2147483647, -2147483648]\n    self.assertTrue(solution.canTraverseAllPairs(nums))", "def test_canTraverseAllPairs(self):\n\n    class Solution:\n\n        def canTraverseAllPairs(self, nums: List[int]) -> bool:\n            n = len(nums)\n            max_num = max((abs(x) for x in nums))\n            maxPrimeFactor = self._sieveEratosthenes(max_num + 1)\n            primeToFirstIndex = collections.defaultdict(int)\n            uf = UnionFind(n)\n            for (i, num) in enumerate(nums):\n                for prime_factor in self._getPrimeFactors(abs(num), maxPrimeFactor):\n                    if prime_factor in primeToFirstIndex:\n                        uf.unionBySize(primeToFirstIndex[prime_factor], i)\n                    else:\n                        primeToFirstIndex[prime_factor] = i\n            return any((uf.getSize(i) == n for i in range(n)))\n\n        def _sieveEratosthenes(self, n: int) -> List[int]:\n            minPrimeFactors = [i for i in range(n + 1)]\n            for i in range(2, int(n ** 0.5) + 1):\n                if minPrimeFactors[i] == i:\n                    for j in range(i * i, n, i):\n                        minPrimeFactors[j] = min(minPrimeFactors[j], i)\n            return minPrimeFactors\n\n        def _getPrimeFactors(self, num: int, minPrimeFactors: List[int]) -> List[int]:\n            primeFactors = []\n            while num > 1:\n                divisor = minPrimeFactors[num]\n                primeFactors.append(divisor)\n                while num % divisor == 0:\n                    num //= divisor\n            return primeFactors\n\n        def __init__(self):\n            self.id = list(range(3))\n            self.sz = [1] * 3\n    solution = Solution()\n    nums = [2, 3, 5, 7, 11]\n    self.assertTrue(solution.canTraverseAllPairs(nums))", "def test_canTraverseAllPairs(self):\n\n    class Solution:\n\n        def canTraverseAllPairs(self, nums: List[int]) -> bool:\n            n = len(nums)\n            max_num = max((abs(x) for x in nums))\n            maxPrimeFactor = self._sieveEratosthenes(max_num + 1)\n            primeToFirstIndex = collections.defaultdict(int)\n            uf = UnionFind(n)\n            for (i, num) in enumerate(nums):\n                for prime_factor in self._getPrimeFactors(abs(num), maxPrimeFactor):\n                    if prime_factor in primeToFirstIndex:\n                        uf.unionBySize(primeToFirstIndex[prime_factor], i)\n                    else:\n                        primeToFirstIndex[prime_factor] = i\n            return any((uf.getSize(i) == n for i in range(n)))\n\n        def _sieveEratosthenes(self, n: int) -> List[int]:\n            minPrimeFactors = [i for i in range(n + 1)]\n            for i in range(2, int(n ** 0.5) + 1):\n                if minPrimeFactors[i] == i:\n                    for j in range(i * i, n, i):\n                        minPrimeFactors[j] = min(minPrimeFactors[j], i)\n            return minPrimeFactors\n\n        def _getPrimeFactors(self, num: int, minPrimeFactors: List[int]) -> List[int]:\n            primeFactors = []\n            while num > 1:\n                divisor = minPrimeFactors[num]\n                primeFactors.append(divisor)\n                while num % divisor == 0:\n                    num //= divisor\n            return primeFactors\n\n        def __init__(self):\n            self.id = list(range(3))\n            self.sz = [1] * 3\n    solution = Solution()\n    nums = [104729, -104729]\n    self.assertTrue(solution.canTraverseAllPairs(nums))", "def test_canTraverseAllPairs(self):\n\n    class Solution:\n\n        def canTraverseAllPairs(self, nums: List[int]) -> bool:\n            n = len(nums)\n            max_num = max((abs(x) for x in nums))\n            maxPrimeFactor = self._sieveEratosthenes(max_num + 1)\n            primeToFirstIndex = collections.defaultdict(int)\n            uf = UnionFind(n)\n            for (i, num) in enumerate(nums):\n                for prime_factor in self._getPrimeFactors(abs(num), maxPrimeFactor):\n                    if prime_factor in primeToFirstIndex:\n                        uf.unionBySize(primeToFirstIndex[prime_factor], i)\n                    else:\n                        primeToFirstIndex[prime_factor] = i\n            return any((uf.getSize(i) == n for i in range(n)))\n\n        def _sieveEratosthenes(self, n: int) -> List[int]:\n            minPrimeFactors = [i for i in range(n + 1)]\n            for i in range(2, int(n ** 0.5) + 1):\n                if minPrimeFactors[i] == i:\n                    for j in range(i * i, n, i):\n                        minPrimeFactors[j] = min(minPrimeFactors[j], i)\n            return minPrimeFactors\n\n        def _getPrimeFactors(self, num: int, minPrimeFactors: List[int]) -> List[int]:\n            primeFactors = []\n            while num > 1:\n                divisor = minPrimeFactors[num]\n                primeFactors.append(divisor)\n                while num % divisor == 0:\n                    num //= divisor\n            return primeFactors\n\n        def __init__(self):\n            self.id = list(range(3))\n            self.sz = [1] * 3\n    solution = Solution()\n    nums = [2, 2, 2, -2]\n    self.assertTrue(solution.canTraverseAllPairs(nums))", "def test_canTraverseAllPairs(self):\n\n    class Solution:\n\n        def canTraverseAllPairs(self, nums: List[int]) -> bool:\n            n = len(nums)\n            max_num = max((abs(x) for x in nums))\n            maxPrimeFactor = self._sieveEratosthenes(max_num + 1)\n            primeToFirstIndex = collections.defaultdict(int)\n            uf = UnionFind(n)\n            for (i, num) in enumerate(nums):\n                for prime_factor in self._getPrimeFactors(abs(num), maxPrimeFactor):\n                    if prime_factor in primeToFirstIndex:\n                        uf.unionBySize(primeToFirstIndex[prime_factor], i)\n                    else:\n                        primeToFirstIndex[prime_factor] = i\n            return any((uf.getSize(i) == n for i in range(n)))\n\n        def _sieveEratosthenes(self, n: int) -> List[int]:\n            minPrimeFactors = [i for i in range(n + 1)]\n            for i in range(2, int(n ** 0.5) + 1):\n                if minPrimeFactors[i] == i:\n                    for j in range(i * i, n, i):\n                        minPrimeFactors[j] = min(minPrimeFactors[j], i)\n            return minPrimeFactors\n\n        def _getPrimeFactors(self, num: int, minPrimeFactors: List[int]) -> List[int]:\n            primeFactors = []\n            while num > 1:\n                divisor = minPrimeFactors[num]\n                primeFactors.append(divisor)\n                while num % divisor == 0:\n                    num //= divisor\n            return primeFactors\n\n        def __init__(self):\n            self.id = list(range(3))\n            self.sz = [1] * 3\n    solution = Solution()\n    nums = [-2, -4, -6]\n    self.assertTrue(solution.canTraverseAllPairs(nums))", "def test_canTraverseAllPairs(self):\n\n    class Solution:\n\n        def canTraverseAllPairs(self, nums: List[int]) -> bool:\n            n = len(nums)\n            max_num = max((abs(x) for x in nums))\n            maxPrimeFactor = self._sieveEratosthenes(max_num + 1)\n            primeToFirstIndex = collections.defaultdict(int)\n            uf = UnionFind(n)\n            for (i, num) in enumerate(nums):\n                for prime_factor in self._getPrimeFactors(abs(num), maxPrimeFactor):\n                    if prime_factor in primeToFirstIndex:\n                        uf.unionBySize(primeToFirstIndex[prime_factor], i)\n                    else:\n                        primeToFirstIndex[prime_factor] = i\n            return any((uf.getSize(i) == n for i in range(n)))\n\n        def _sieveEratosthenes(self, n: int) -> List[int]:\n            minPrimeFactors = [i for i in range(n + 1)]\n            for i in range(2, int(n ** 0.5) + 1):\n                if minPrimeFactors[i] == i:\n                    for j in range(i * i, n, i):\n                        minPrimeFactors[j] = min(minPrimeFactors[j], i)\n            return minPrimeFactors\n\n        def _getPrimeFactors(self, num: int, minPrimeFactors: List[int]) -> List[int]:\n            primeFactors = []\n            while num > 1:\n                divisor = minPrimeFactors[num]\n                primeFactors.append(divisor)\n                while num % divisor == 0:\n                    num //= divisor\n            return primeFactors\n\n        def __init__(self):\n            self.id = list(range(3))\n            self.sz = [1] * 3\n    solution = Solution()\n    nums = [2, 0, -4]\n    self.assertTrue(solution.canTraverseAllPairs(nums))"]}
{"task_num": 2736, "task_title": "Maximum Sum Queries", "func_name": "maximumSumQueries", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Pair:\n  def __init__(self, x: int, y: int):\n    self.x = x\n    self.y = y\n\n  def __iter__(self):\n    yield self.x\n    yield self.y\n\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, minX: int, minY: int):\n    self.queryIndex = queryIndex\n    self.minX = minX\n    self.minY = minY\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.minX\n    yield self.minY\n\n\nclass Solution:\n  def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n    pairs = sorted([Pair(nums1[i], nums2[i])\n                   for i in range(len(nums1))], key=lambda p: p.x, reverse=True)\n    ans = [0] * len(queries)\n    stack = []  # [(y, x + y)]\n\n    pairsIndex = 0\n    for queryIndex, minX, minY in sorted([IndexedQuery(i, query[0], query[1]) for i, query in enumerate(queries)], key=lambda iq: -iq.minX):\n      while pairsIndex < len(pairs) and pairs[pairsIndex].x >= minX:\n        x, y = pairs[pairsIndex]\n        while stack and x + y >= stack[-1][1]:\n          stack.pop()\n        if not stack or y > stack[-1][0]:\n          stack.append((y, x + y))\n        pairsIndex += 1\n      j = self._firstGreaterEqual(stack, minY)\n      if j == len(stack):\n        ans[queryIndex] = -1\n      else:\n        ans[queryIndex] = stack[j][1]\n\n    return ans\n\n  def _firstGreaterEqual(self, A: List[Tuple[int, int]], target: int) -> int:\n    l = 0\n    r = len(A)\n    while l < r:\n      m = (l + r) // 2\n      if A[m][0] >= target:\n        r = m\n      else:\n        l = m + 1\n    return l\n", "tests": ["def test_maximumSumQueries(self):\n    solution = Solution()\n    nums1 = [5, 4, 3]\n    nums2 = [9, 8, 7]\n    queries = [[0, 0], [1, 1], [2, 2]]\n    expectedAnswer = [-1, -1, 20]\n    self.assertEqual(solution.maximumSumQueries(nums1, nums2, queries), expectedAnswer)", "def test_maximumSumQueries(self):\n    solution = Solution()\n    nums1 = [3]\n    nums2 = [6]\n    queries = [[0, 5], [0, 7]]\n    expectedAnswer = [-1, 9]\n    self.assertEqual(solution.maximumSumQueries(nums1, nums2, queries), expectedAnswer)", "def test_maximumSumQueries(self):\n    solution = Solution()\n    nums1 = [10, 20, 30]\n    nums2 = [40, 50, 60]\n    queries = [[0, 100], [1, 200]]\n    expectedAnswer = [-1, -1]\n    self.assertEqual(solution.maximumSumQueries(nums1, nums2, queries), expectedAnswer)", "def test_maximumSumQueries(self):\n    solution = Solution()\n    nums1 = [5, 4, 3]\n    nums2 = [9, 8, 7]\n    queries = [[0, 1], [1, 1], [2, 2]]\n    expectedAnswer = [13, -1, 20]\n    self.assertEqual(solution.maximumSumQueries(nums1, nums2, queries), expectedAnswer)", "def test_maximumSumQueries(self):\n    solution = Solution()\n    nums1 = [1000, 2000]\n    nums2 = [3000, 4000]\n    queries = [[0, 500], [1, 600]]\n    expectedAnswer = [-1, -1]\n    self.assertEqual(solution.maximumSumQueries(nums1, nums2, queries), expectedAnswer)", "def test_maximumSumQueries(self):\n    solution = Solution()\n    nums1 = [5]\n    nums2 = [9]\n    queries = [[0, 10], [0, 12]]\n    expectedAnswer = [-1, 14]\n    self.assertEqual(solution.maximumSumQueries(nums1, nums2, queries), expectedAnswer)", "def test_maximumSumQueries(self):\n    solution = Solution()\n    nums1 = [10]\n    nums2 = [20]\n    queries = [[0, 15]]\n    expectedAnswer = [-1]\n    self.assertEqual(solution.maximumSumQueries(nums1, nums2, queries), expectedAnswer)", "def test_maximumSumQueries(self):\n    solution = Solution()\n    nums1 = [1, 2]\n    nums2 = [3, 4]\n    queries = [[0, 10], [1, 20]]\n    expectedAnswer = [-1, -1]\n    self.assertEqual(solution.maximumSumQueries(nums1, nums2, queries), expectedAnswer)", "def test_maximumSumQueries(self):\n    solution = Solution()\n    nums1 = [10000]\n    nums2 = [20000]\n    queries = [[0, 15000]]\n    expectedAnswer = [-1]\n    self.assertEqual(solution.maximumSumQueries(nums1, nums2, queries), expectedAnswer)", "def test_maximumSumQueries(self):\n    solution = Solution()\n    nums1 = [1000, 2000]\n    nums2 = [3000, 4000]\n    queries = [[0, 2999], [1, 3999]]\n    expectedAnswer = [-1, -1]\n    self.assertEqual(solution.maximumSumQueries(nums1, nums2, queries), expectedAnswer)", "def test_maximumSumQueries(self):\n    solution = Solution()\n    nums1 = [10, 20]\n    nums2 = [30, 40]\n    queries = [[0, 19], [1, 29]]\n    expectedAnswer = [-1, -1]\n    self.assertEqual(solution.maximumSumQueries(nums1, nums2, queries), expectedAnswer)", "def test_maximumSumQueries(self):\n    solution = Solution()\n    nums1 = [50000]\n    nums2 = [60000]\n    queries = [[0, 39999]]\n    expectedAnswer = [-1]\n    self.assertEqual(solution.maximumSumQueries(nums1, nums2, queries), expectedAnswer)", "def test_maximumSumQueries(self):\n    solution = Solution()\n    nums1 = [10, 20]\n    nums2 = [30, 40]\n    queries = [[0, 15], [1, 35]]\n    expectedAnswer = [-1, -1]\n    self.assertEqual(solution.maximumSumQueries(nums1, nums2, queries), expectedAnswer)", "def test_maximumSumQueries(self):\n    solution = Solution()\n    nums1 = [10000, 20000]\n    nums2 = [30000, 40000]\n    queries = [[0, 25000], [1, 35000]]\n    expectedAnswer = [-1, -1]\n    self.assertEqual(solution.maximumSumQueries(nums1, nums2, queries), expectedAnswer)", "def test_maximumSumQueries(self):\n    solution = Solution()\n    nums1 = [1000000]\n    nums2 = [2000000]\n    queries = [[0, 1750000]]\n    expectedAnswer = [-1]\n    self.assertEqual(solution.maximumSumQueries(nums1, nums2, queries), expectedAnswer)", "def test_maximumSumQueries(self):\n    solution = Solution()\n    nums1 = [1, 2, 3]\n    nums2 = [4, 5, 6]\n    queries = [[0, 10], [1, 20]]\n    expectedAnswer = [-1, -1]\n    self.assertEqual(solution.maximumSumQueries(nums1, nums2, queries), expectedAnswer)", "def test_maximumSumQueries(self):\n    solution = Solution()\n    nums1 = [1000000]\n    nums2 = [2000000]\n    queries = [[0, 1999999]]\n    expectedAnswer = [-1]\n    self.assertEqual(solution.maximumSumQueries(nums1, nums2, queries), expectedAnswer)", "def test_maximumSumQueries(self):\n    solution = Solution()\n    nums1 = [1000]\n    nums2 = [2000]\n    queries = [[0, 2999]]\n    expectedAnswer = [-1]\n    self.assertEqual(solution.maximumSumQueries(nums1, nums2, queries), expectedAnswer)", "def test_maximumSumQueries(self):\n    solution = Solution()\n    nums1 = [5000]\n    nums2 = [6000]\n    queries = [[0, 4999]]\n    expectedAnswer = [-1]\n    self.assertEqual(solution.maximumSumQueries(nums1, nums2, queries), expectedAnswer)", "def test_maximumSumQueries(self):\n    solution = Solution()\n    nums1 = [10000000]\n    nums2 = [20000000]\n    queries = [[0, 19999999]]\n    expectedAnswer = [-1]\n    self.assertEqual(solution.maximumSumQueries(nums1, nums2, queries), expectedAnswer)"]}
{"task_num": 2747, "task_title": "Count Zero Request Servers", "func_name": "countServers", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, query: int):\n    self.queryIndex = queryIndex\n    self.query = query\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.query\n\n\nclass Solution:\n  def countServers(self, n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:\n    ans = [0] * len(queries)\n    count = [0] * (n + 1)\n\n    logs.sort(key=lambda log: log[1])\n\n    i = 0\n    j = 0\n    servers = 0\n\n    for queryIndex, query in sorted([IndexedQuery(i, query) for i, query in enumerate(queries)], key=lambda iq: iq.query):\n      while j < len(logs) and logs[j][1] <= query:\n        count[logs[j][0]] += 1\n        if count[logs[j][0]] == 1:\n          servers += 1\n        j += 1\n      while i < len(logs) and logs[i][1] < query - x:\n        count[logs[i][0]] -= 1\n        if count[logs[i][0]] == 0:\n          servers -= 1\n        i += 1\n      ans[queryIndex] = n - servers\n\n    return ans\n", "tests": ["def test_countServers(self):\n    solution = Solution()\n    n = 3\n    logs = [[1, 4], [2, 4], [0, 6]]\n    x = 1\n    queries = [1, 2]\n    self.assertEqual(solution.countServers(n, logs, x, queries), [2, 1])", "def test_countServers(self):\n    solution = Solution()\n    n = 2\n    logs = [[0, 4], [1, 5]]\n    x = 3\n    queries = [5]\n    self.assertEqual(solution.countServers(n, logs, x, queries), [1])", "def test_countServers(self):\n    solution = Solution()\n    n = 4\n    logs = [[1, 10], [2, 3], [0, 5], [0, 9]]\n    x = 2\n    queries = [10]\n    self.assertEqual(solution.countServers(n, logs, x, queries), [3])", "def test_countServers(self):\n    solution = Solution()\n    n = 1\n    logs = [[0, 4]]\n    x = 0\n    queries = [5]\n    self.assertEqual(solution.countServers(n, logs, x, queries), [n])", "def test_countServers(self):\n    solution = Solution()\n    n = 5\n    logs = [[0, 4], [1, 6], [2, 8], [3, 7], [4, 9]]\n    x = 1\n    queries = [10]\n    self.assertEqual(solution.countServers(n, logs, x, queries), [n])", "def test_countServers(self):\n    solution = Solution()\n    n = 1\n    logs = [[0, 4]]\n    x = 5\n    queries = [6]\n    self.assertEqual(solution.countServers(n, logs, x, queries), [n])", "def test_countServers(self):\n    solution = Solution()\n    n = 4\n    logs = [[0, 2], [1, 1], [3, 4], [2, 6]]\n    x = 1\n    queries = [5]\n    self.assertEqual(solution.countServers(n, logs, x, queries), [n - 1])", "def test_countServers(self):\n    solution = Solution()\n    n = 2\n    logs = [[0, 1], [1, 1]]\n    x = 2\n    queries = [3]\n    self.assertEqual(solution.countServers(n, logs, x, queries), [n])", "def test_countServers(self):\n    solution = Solution()\n    n = 1\n    logs = [[0, 4]]\n    x = 3\n    queries = [6]\n    self.assertEqual(solution.countServers(n, logs, x, queries), [n])", "def test_countServers(self):\n    solution = Solution()\n    n = 5\n    logs = [[0, 4], [1, 6], [2, 8], [3, 7], [4, 9]]\n    x = 2\n    queries = [10]\n    self.assertEqual(solution.countServers(n, logs, x, queries), [n])", "def test_countServers(self):\n    solution = Solution()\n    n = 1\n    logs = [[0, 10]]\n    x = 9\n    queries = [10]\n    self.assertEqual(solution.countServers(n, logs, x, queries), [n])", "def test_countServers(self):\n    solution = Solution()\n    n = 1\n    logs = [[0, 10]]\n    x = 11\n    queries = [10]\n    self.assertEqual(solution.countServers(n, logs, x, queries), [n])", "def test_countServers(self):\n    solution = Solution()\n    n = 2\n    logs = [[0, 1], [1, 4]]\n    x = 3\n    queries = [5]\n    self.assertEqual(solution.countServers(n, logs, x, queries), [n])", "def test_countServers(self):\n    solution = Solution()\n    n = 3\n    logs = [[0, 5], [1, 10], [2, 14]]\n    x = 4\n    queries = [15]\n    self.assertEqual(solution.countServers(n, logs, x, queries), [n])", "def test_countServers(self):\n    solution = Solution()\n    n = 3\n    logs = [[0, 5], [2, 7], [1, 10]]\n    x = 4\n    queries = [8]\n    self.assertEqual(solution.countServers(n, logs, x, queries), [n])", "def test_countServers(self):\n    solution = Solution()\n    n = 3\n    logs = [[2, 4], [0, 5], [1, 10]]\n    x = 6\n    queries = [9]\n    self.assertEqual(solution.countServers(n, logs, x, queries), [n])", "def test_countServers(self):\n    solution = Solution()\n    n = 1\n    logs = [[0, 10]]\n    x = 5\n    queries = [15]\n    self.assertEqual(solution.countServers(n, logs, x, queries), [n])", "def test_countServers(self):\n    solution = Solution()\n    n = 3\n    logs = [[0, 1], [2, 6], [0, 5]]\n    x = 4\n    queries = [7]\n    self.assertEqual(solution.countServers(n, logs, x, queries), [n - 1])", "def test_countServers(self):\n    solution = Solution()\n    n = 2\n    logs = [[1, 10], [0, 4]]\n    x = 3\n    queries = [12]\n    self.assertEqual(solution.countServers(n, logs, x, queries), [n - 1])", "def test_countServers(self):\n    solution = Solution()\n    n = 5\n    logs = [[1, 3], [2, 3], [0, 4], [4, 6], [5, 10]]\n    x = 8\n    queries = [9]\n    self.assertEqual(solution.countServers(n, logs, x, queries), [n])"]}
{"task_num": 2751, "task_title": "Robot Collisions", "func_name": "survivedRobotsHealths", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\nfrom dataclasses import dataclass\n\n@dataclass\nclass Robot:\n  index: int\n  position: int\n  health: int\n  direction: str\n\n\nclass Solution:\n  def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\n    robots = sorted([Robot(index, position, health, direction) for index, (position, health, direction) in enumerate(zip(positions, healths, directions))], key=lambda robot: robot.position)\n    stack: List[Robot] = []\n\n    for robot in robots:\n      if robot.direction == 'R':\n        stack.append(robot)\n        continue\n      while stack and stack[-1].direction == 'R' and robot.health > 0:\n        if stack[-1].health == robot.health:\n          stack.pop()\n          robot.health = 0\n        elif stack[-1].health < robot.health:\n          stack.pop()\n          robot.health -= 1\n        else:\n          stack[-1].health -= 1\n          robot.health = 0\n      if robot.health > 0:\n        stack.append(robot)\n\n    stack.sort(key=lambda robot: robot.index)\n    return [robot.health for robot in stack]\n", "tests": ["def test_survivedRobotsHealths(self):\n    solution = Solution()\n    positions = [1, 3, 2]\n    healths = [5, 4, 3]\n    directions = ['R', 'L', 'R']\n    self.assertEqual(solution.survivedRobotsHealths(positions, healths, directions), [5, 0, 2])", "def test_survivedRobotsHealths(self):\n    solution = Solution()\n    positions = [1, 2, 3]\n    healths = [5, 5, 3]\n    directions = ['R', 'L', 'R']\n    self.assertEqual(solution.survivedRobotsHealths(positions, healths, directions), [0, 0, 3])", "def test_survivedRobotsHealths(self):\n    solution = Solution()\n    positions = [1, 2, 3]\n    healths = [1, 1, 1]\n    directions = ['L', 'R', 'L']\n    self.assertEqual(solution.survivedRobotsHealths(positions, healths, directions), [])", "def test_survivedRobotsHealths(self):\n    solution = Solution()\n    positions = [1, 2]\n    healths = [5, 10]\n    directions = ['R', 'L']\n    self.assertEqual(solution.survivedRobotsHealths(positions, healths, directions), [0, 9])", "def test_survivedRobotsHealths(self):\n    solution = Solution()\n    positions = [1, 1]\n    healths = [5, 10]\n    directions = ['R', 'L']\n    self.assertEqual(solution.survivedRobotsHealths(positions, healths, directions), [0, 9])", "def test_survivedRobotsHealths(self):\n    solution = Solution()\n    positions = [1]\n    healths = [5]\n    directions = ['R']\n    self.assertEqual(solution.survivedRobotsHealths(positions, healths, directions), [5])", "def test_survivedRobotsHealths(self):\n    solution = Solution()\n    positions = []\n    healths = [5]\n    directions = ['R']\n    self.assertEqual(solution.survivedRobotsHealths(positions, healths, directions), [])", "def test_survivedRobotsHealths(self):\n    solution = Solution()\n    positions = [1]\n    healths = [5, 4]\n    directions = ['R', 'L']\n    self.assertEqual(solution.survivedRobotsHealths(positions, healths, directions), [0])", "def test_survivedRobotsHealths(self):\n    solution = Solution()\n    positions = [1, 2]\n    healths = [5, 10]\n    directions = ['L', 'L']\n    self.assertEqual(solution.survivedRobotsHealths(positions, healths, directions), [4, 9])", "def test_survivedRobotsHealths(self):\n    solution = Solution()\n    positions = [1, 2, 3]\n    healths = [5, 4, 7]\n    directions = ['R', 'L', 'R']\n    self.assertEqual(solution.survivedRobotsHealths(positions, healths, directions), [0, 0, 6])", "def test_survivedRobotsHealths(self):\n    solution = Solution()\n    positions = [3, 2, 1]\n    healths = [7, 4, 5]\n    directions = ['R', 'L', 'R']\n    self.assertEqual(solution.survivedRobotsHealths(positions, healths, directions), [6, 0, 0])", "def test_survivedRobotsHealths(self):\n    solution = Solution()\n    positions = [1, 1]\n    healths = [5, 10]\n    directions = ['R', 'L']\n    self.assertEqual(solution.survivedRobotsHealths(positions, healths, directions), [0, 9])", "def test_survivedRobotsHealths(self):\n    solution = Solution()\n    positions = [1, 2, 3, 4, 5]\n    healths = [10, 8, 6, 4, 2]\n    directions = ['R', 'L', 'R', 'L', 'R']\n    self.assertEqual(solution.survivedRobotsHealths(positions, healths, directions), [0, 0, 5, 3, 1])", "def test_survivedRobotsHealths(self):\n    solution = Solution()\n    positions = [1]\n    healths = [0]\n    directions = ['R']\n    self.assertEqual(solution.survivedRobotsHealths(positions, healths, directions), [0])", "def test_survivedRobotsHealths(self):\n    solution = Solution()\n    positions = [1, 2]\n    healths = [0, 0]\n    directions = ['R', 'L']\n    self.assertEqual(solution.survivedRobotsHealths(positions, healths, directions), [])", "def test_survivedRobotsHealths(self):\n    solution = Solution()\n    positions = []\n    healths = []\n    directions = []\n    self.assertEqual(solution.survivedRobotsHealths(positions, healths, directions), [])", "def test_survivedRobotsHealths(self):\n    solution = Solution()\n    positions = [1]\n    healths = [-5]\n    directions = ['R']\n    self.assertEqual(solution.survivedRobotsHealths(positions, healths, directions), [])", "def test_survivedRobotsHealths(self):\n    solution = Solution()\n    positions = [1, 2]\n    healths = [0, 5]\n    directions = ['R', 'L']\n    self.assertEqual(solution.survivedRobotsHealths(positions, healths, directions), [])", "def test_survivedRobotsHealths(self):\n    solution = Solution()\n    positions = [3, 2, 1]\n    healths = [7, 4, 5]\n    directions = ['R', 'L', 'R']\n    self.assertEqual(solution.survivedRobotsHealths(positions, healths, directions), [6, 0, 0])", "def test_survivedRobotsHealths(self):\n    solution = Solution()\n    positions = [1, 2, 3]\n    healths = [5, 10, 7]\n    directions = ['R', 'L', 'R']\n    self.assertEqual(solution.survivedRobotsHealths(positions, healths, directions), [0, 9, 6])"]}
{"task_num": 2812, "task_title": "Find the Safest Path in a Grid", "func_name": "maximumSafenessFactor", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumSafenessFactor(self, grid: List[List[int]]) -> int:\n    self.dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    n = len(grid)\n    distToThief = self._getDistToThief(grid)\n\n    def hasValidPath(safeness: int) -> bool:\n      if distToThief[0][0] < safeness:\n        return False\n\n      q = collections.deque([(0, 0)])\n      seen = {(0, 0)}\n\n      while q:\n        i, j = q.popleft()\n        if distToThief[i][j] < safeness:\n          continue\n        if i == n - 1 and j == n - 1:\n          return True\n        for dx, dy in self.dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == n or y < 0 or y == n:\n            continue\n          if (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n\n      return False\n\n    return bisect.bisect_left(range(n * 2), True, key=lambda m: not hasValidPath(m)) - 1\n\n  def _getDistToThief(self, grid: List[List[int]]) -> List[List[int]]:\n    n = len(grid)\n    distToThief = [[0] * n for _ in range(n)]\n    q = collections.deque()\n    seen = set()\n\n    for i in range(n):\n      for j in range(n):\n        if grid[i][j] == 1:\n          q.append((i, j))\n          seen.add((i, j))\n\n    dist = 0\n    while q:\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        distToThief[i][j] = dist\n        for dx, dy in self.dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == n or y < 0 or y == n:\n            continue\n          if (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n      dist += 1\n\n    return distToThief\n", "tests": ["def test_maximumSafenessFactor():\n    solution = Solution()\n    assert solution.maximumSafenessFactor([[0, 1], [1, 0]]) == 2", "def test_maximumSafenessFactor():\n    solution = Solution()\n    assert solution.maximumSafenessFactor([[0, 1, 0], [0, 0, 1], [0, 1, 0]]) == 2", "def test_maximumSafenessFactor():\n    solution = Solution()\n    assert solution.maximumSafenessFactor([[1, 0], [0, 1]]) == 3", "def test_maximumSafenessFactor():\n    solution = Solution()\n    assert solution.maximumSafenessFactor([[0, 1, 1], [0, 0, 1], [1, 1, 0]]) == 3", "def test_maximumSafenessFactor():\n    solution = Solution()\n    assert solution.maximumSafenessFactor([[0] * 5 for _ in range(5)]) == 4", "def test_maximumSafenessFactor():\n    solution = Solution()\n    assert solution.maximumSafenessFactor([[1] * 5 for _ in range(5)]) == 0", "def test_maximumSafenessFactor():\n    solution = Solution()\n    assert solution.maximumSafenessFactor([[0, 0], [0, 0]]) == 1", "def test_maximumSafenessFactor():\n    solution = Solution()\n    assert solution.maximumSafenessFactor([[0] * 3 for _ in range(3)]) == 2", "def test_maximumSafenessFactor():\n    solution = Solution()\n    assert solution.maximumSafenessFactor([[1] * 3 for _ in range(3)]) == 0", "def test_maximumSafenessFactor():\n    solution = Solution()\n    assert solution.maximumSafenessFactor([[0] * 2 + [1], [0] * 4]) == 3", "def test_maximumSafenessFactor():\n    solution = Solution()\n    assert solution.maximumSafenessFactor([[0] * 4 + [1], [0] * 5]) == 3", "def test_maximumSafenessFactor():\n    solution = Solution()\n    assert solution.maximumSafenessFactor([[0] * 5 + [1], [0] * 5 + [0]]) == 4", "def test_maximumSafenessFactor():\n    solution = Solution()\n    assert solution.maximumSafenessFactor([[0] * 5 + [1], [0] * 4 + [1]]) == 3", "def test_maximumSafenessFactor():\n    solution = Solution()\n    assert solution.maximumSafenessFactor([[0] * 5 + [1], [0] * 4 + [1]]) == 3", "def test_maximumSafenessFactor():\n    solution = Solution()\n    assert solution.maximumSafenessFactor([[1] * 5 + [0], [1] * 4 + [0]]) == 3", "def test_maximumSafenessFactor():\n    solution = Solution()\n    assert solution.maximumSafenessFactor([[1] * 5 + [0], [1] * 4 + [0]]) == 3", "def test_maximumSafenessFactor():\n    solution = Solution()\n    assert solution.maximumSafenessFactor([[0] * 10]) == 5", "def test_maximumSafenessFactor():\n    solution = Solution()\n    assert solution.maximumSafenessFactor([[1] * 10]) == 0", "def test_maximumSafenessFactor():\n    solution = Solution()\n    assert solution.maximumSafenessFactor([[0] * 2 + [1] * 3 + [0], [0] * 5]) == 4", "def test_maximumSafenessFactor():\n    solution = Solution()\n    assert solution.maximumSafenessFactor([[1] * 2 + [0] * 3 + [1], [1] * 5]) == 1"]}
{"task_num": 2818, "task_title": "Apply Operations to Maximize Score", "func_name": "maximumScore", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumScore(self, nums: List[int], k: int) -> int:\n    kMod = 1_000_000_007\n    n = len(nums)\n    ans = 1\n    minPrimeFactors = self._sieveEratosthenes(max(nums) + 1)\n    primeScores = [self._getPrimeScore(num, minPrimeFactors) for num in nums]\n    left = [-1] * n\n    right = [n] * n\n    stack = []\n\n    for i in reversed(range(n)):\n      while stack and primeScores[stack[-1]] <= primeScores[i]:\n        left[stack.pop()] = i\n      stack.append(i)\n\n    stack = []\n\n    for i in range(n):\n      while stack and primeScores[stack[-1]] < primeScores[i]:\n        right[stack.pop()] = i\n      stack.append(i)\n\n    numAndIndexes = [(num, i) for i, num in enumerate(nums)]\n\n    def modPow(x: int, n: int) -> int:\n      if n == 0:\n        return 1\n      if n & 1:\n        return x * modPow(x, n - 1) % kMod\n      return modPow(x * x % kMod, n // 2)\n\n    for num, i in sorted(numAndIndexes, key=lambda x: (-x[0], x[1])):\n      rangeCount = (i - left[i]) * (right[i] - i)\n      actualCount = min(rangeCount, k)\n      k -= actualCount\n      ans *= modPow(num, actualCount)\n      ans %= kMod\n\n    return ans\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeScore(self, num: int, minPrimeFactors: List[int]) -> int:\n    primeFactors = set()\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      primeFactors.add(divisor)\n      while num % divisor == 0:\n        num //= divisor\n    return len(primeFactors)\n", "tests": ["def test_maximumScore():\n\n    def helper(nums: List[int], k: int):\n        n = len(nums)\n        ans = 1\n        minPrimeFactors = [i for i in range(max(nums) + 1)]\n        for i in range(2, int(max(nums) ** 0.5) + 1):\n            if minPrimeFactors[i] == i:\n                for j in range(i * i, max(nums), i):\n                    minPrimeFactors[j] = min(minPrimeFactors[j], i)\n        primeScores = [getPrimeScore(num, minPrimeFactors) for num in nums]\n        left = [-1] * n\n        right = [n] * n\n        stack = []\n\n        def getLeft(i: int):\n            while stack and primeScores[stack[-1]] <= primeScores[i]:\n                stack.pop()\n            if not stack:\n                return -1\n            return stack[-1]\n        for i in reversed(range(n)):\n            left[i] = getLeft(i)\n            stack.append(i)\n        stack = []\n\n        def getRight(i: int):\n            while stack and primeScores[stack[-1]] < primeScores[i]:\n                stack.pop()\n            if not stack:\n                return n\n            return stack[-1]\n        for i in range(n):\n            right[i] = getRight(i)\n            stack.append(i)\n        numAndIndexes = [(num, i) for (i, num) in enumerate(nums)]\n        kMod = 10 ** 9 + 7\n\n        def modPow(x: int, n: int) -> int:\n            if n == 0:\n                return 1\n            if n & 1:\n                return x * modPow(x, n - 1) % kMod\n            return modPow(x * x % kMod, n // 2)\n        for (num, i) in sorted(numAndIndexes, key=lambda x: (-x[0], x[1])):\n            rangeCount = (i - left[i]) * (right[i] - i)\n            actualCount = min(rangeCount, k)\n            k -= actualCount\n            ans *= modPow(num, actualCount)\n            ans %= kMod\n        return ans\n\n    def getPrimeScore(num: int, minPrimeFactors: List[int]) -> int:\n        primeFactors = set()\n        while num > 1:\n            divisor = minPrimeFactors[num]\n            primeFactors.add(divisor)\n            while num % divisor == 0:\n                num //= divisor\n        return len(primeFactors)\n    solution = Solution()\n    nums = [2, 4, 3]\n    k = 1\n    assert helper(nums, k) == solution.maximumScore(nums, k), f'Expected {solution.maximumScore(nums, k)} but got {helper(nums, k)}'", "def test_maximumScore():\n    solution = Solution()\n    nums = [10, 10, 10]\n    k = 3\n    assert 26 == solution.maximumScore(nums, k), f'Expected {solution.maximumScore(nums, k)} but got {-1}'", "def test_maximumScore():\n    solution = Solution()\n    nums = [7, 13, 29]\n    k = 2\n    assert 32 == solution.maximumScore(nums, k), f'Expected {solution.maximumScore(nums, k)} but got {-1}'", "def test_maximumScore():\n    solution = Solution()\n    nums = [2 ** 10, 3, 5]\n    k = 0\n    assert 1 == solution.maximumScore(nums, k), f'Expected {solution.maximumScore(nums, k)} but got {-1}'", "def test_maximumScore():\n    solution = Solution()\n    nums = [2, 3]\n    k = 5\n    assert 13 == solution.maximumScore(nums, k), f'Expected {solution.maximumScore(nums, k)} but got {-1}'", "def test_maximumScore():\n    solution = Solution()\n    nums = [2 ** 20, 3]\n    k = 1\n    assert 7 == solution.maximumScore(nums, k), f'Expected {solution.maximumScore(nums, k)} but got {-1}'", "def test_maximumScore():\n    solution = Solution()\n    nums = [2 ** 20, 3]\n    k = 0\n    assert 1 == solution.maximumScore(nums, k), f'Expected {solution.maximumScore(nums, k)} but got {-1}'", "def test_maximumScore():\n    solution = Solution()\n    nums = [2 ** 30]\n    k = 0\n    assert 1 == solution.maximumScore(nums, k), f'Expected {solution.maximumScore(nums, k)} but got {-1}'", "def test_maximumScore():\n    solution = Solution()\n    nums = [2 ** 10, 7]\n    k = 1000000\n    assert 19 == solution.maximumScore(nums, k), f'Expected {solution.maximumScore(nums, k)} but got {-1}'", "def test_maximumScore():\n    solution = Solution()\n    nums = [2 ** 20, 3]\n    k = 99999999\n    assert 7 == solution.maximumScore(nums, k), f'Expected {solution.maximumScore(nums, k)} but got {-1}'", "def test_maximumScore():\n    solution = Solution()\n    nums = [3, 2]\n    k = 99999999\n    assert 5 == solution.maximumScore(nums, k), f'Expected {solution.maximumScore(nums, k)} but got {-1}'", "def test_maximumScore():\n    solution = Solution()\n    nums = [2 ** 1000, 7]\n    k = 1\n    assert 13 == solution.maximumScore(nums, k), f'Expected {solution.maximumScore(nums, k)} but got {-1}'", "def test_maximumScore():\n    solution = Solution()\n    nums = [2 ** 1000, 7]\n    k = 99999999\n    assert 13 == solution.maximumScore(nums, k), f'Expected {solution.maximumScore(nums, k)} but got {-1}'", "def test_maximumScore():\n    solution = Solution()\n    nums = [2 ** 1000]\n    k = 99999999\n    assert 1 == solution.maximumScore(nums, k), f'Expected {solution.maximumScore(nums, k)} but got {-1}'", "def test_maximumScore():\n    solution = Solution()\n    nums = [7]\n    k = 0\n    assert 1 == solution.maximumScore(nums, k), f'Expected {solution.maximumScore(nums, k)} but got {-1}'", "def test_maximumScore():\n    solution = Solution()\n    nums = [2 ** 1000]\n    k = 99999999\n    assert 1 == solution.maximumScore(nums, k), f'Expected {solution.maximumScore(nums, k)} but got {-1}'", "def test_maximumScore():\n    solution = Solution()\n    nums = [5 ** 2000]\n    k = 99999999\n    assert 1 == solution.maximumScore(nums, k), f'Expected {solution.maximumScore(nums, k)} but got {-1}'", "def test_maximumScore():\n    solution = Solution()\n    nums = [2 ** 20, 3, 5]\n    k = 1000000\n    assert 25 == solution.maximumScore(nums, k), f'Expected {solution.maximumScore(nums, k)} but got {-1}'", "def test_maximumScore():\n    solution = Solution()\n    nums = [2 ** 20, 3]\n    k = 99999999\n    assert 7 == solution.maximumScore(nums, k), f'Expected {solution.maximumScore(nums, k)} but got {-1}'", "def test_maximumScore():\n    solution = Solution()\n    nums = [2 ** 20, 3]\n    k = 99999998\n    assert 7 == solution.maximumScore(nums, k), f'Expected {solution.maximumScore(nums, k)} but got {-1}'"]}
{"task_num": 2836, "task_title": "Maximize Value of Function in a Ball Passing Game", "func_name": "getMaxFunctionValue", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:\n    n = len(receiver)\n    m = int(math.log2(k)) + 1\n    ans = 0\n    jump = [[0] * m for _ in range(n)]\n    summ = [[0] * m for _ in range(n)]\n\n    for i in range(n):\n      jump[i][0] = receiver[i]\n      summ[i][0] = receiver[i]\n\n    for j in range(1, m):\n      for i in range(n):\n        midNode = jump[i][j - 1]\n        jump[i][j] = jump[midNode][j - 1]\n        summ[i][j] = summ[i][j - 1] + summ[midNode][j - 1]\n\n    for i in range(n):\n      currSum = i\n      currPos = i\n      for j in range(m):\n        if (k >> j) & 1 == 1:\n          currSum += summ[currPos][j]\n          currPos = jump[currPos][j]\n      ans = max(ans, currSum)\n\n    return ans\n", "tests": ["def test_getMaxFunctionValue():\n\n    class Solution:\n\n        def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:\n            n = len(receiver)\n            m = int(math.log2(k)) + 1\n            ans = 0\n            jump = [[0] * m for _ in range(n)]\n            summ = [[0] * m for _ in range(n)]\n            for i in range(n):\n                jump[i][0] = receiver[i]\n                summ[i][0] = receiver[i]\n            for j in range(1, m):\n                for i in range(n):\n                    midNode = jump[i][j - 1]\n                    jump[i][j] = jump[midNode][j - 1]\n                    summ[i][j] = summ[i][j - 1] + summ[midNode][j - 1]\n            for i in range(n):\n                currSum = i\n                currPos = i\n                for j in range(m):\n                    if k >> j & 1 == 1:\n                        currSum += summ[currPos][j]\n                        currPos = jump[currPos][j]\n                ans = max(ans, currSum)\n            return ans\n    solution = Solution()\n    receiver = [2, 3, 1, 4, 5]\n    k = 20\n    assert solution.getMaxFunctionValue(receiver, k) == 121", "def test_getMaxFunctionValue():\n\n    class Solution:\n\n        def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:\n            n = len(receiver)\n            m = int(math.log2(k)) + 1\n            ans = 0\n            jump = [[0] * m for _ in range(n)]\n            summ = [[0] * m for _ in range(n)]\n            for i in range(n):\n                jump[i][0] = receiver[i]\n                summ[i][0] = receiver[i]\n            for j in range(1, m):\n                for i in range(n):\n                    midNode = jump[i][j - 1]\n                    jump[i][j] = jump[midNode][j - 1]\n                    summ[i][j] = summ[i][j - 1] + summ[midNode][j - 1]\n            for i in range(n):\n                currSum = i\n                currPos = i\n                for j in range(m):\n                    if k >> j & 1 == 1:\n                        currSum += summ[currPos][j]\n                        currPos = jump[currPos][j]\n                ans = max(ans, currSum)\n            return ans\n    solution = Solution()\n    receiver = [4, 2, 3, 5, 1]\n    k = 13\n    assert solution.getMaxFunctionValue(receiver, k) == 38", "def test_getMaxFunctionValue():\n\n    class Solution:\n\n        def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:\n            n = len(receiver)\n            m = int(math.log2(k)) + 1\n            ans = 0\n            jump = [[0] * m for _ in range(n)]\n            summ = [[0] * m for _ in range(n)]\n            for i in range(n):\n                jump[i][0] = receiver[i]\n                summ[i][0] = receiver[i]\n            for j in range(1, m):\n                for i in range(n):\n                    midNode = jump[i][j - 1]\n                    jump[i][j] = jump[midNode][j - 1]\n                    summ[i][j] = summ[i][j - 1] + summ[midNode][j - 1]\n            for i in range(n):\n                currSum = i\n                currPos = i\n                for j in range(m):\n                    if k >> j & 1 == 1:\n                        currSum += summ[currPos][j]\n                        currPos = jump[currPos][j]\n                ans = max(ans, currSum)\n            return ans\n    solution = Solution()\n    receiver = [5, 4, 3, 2, 1]\n    k = 31\n    assert solution.getMaxFunctionValue(receiver, k) == 155", "def test_getMaxFunctionValue():\n\n    class Solution:\n\n        def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:\n            n = len(receiver)\n            m = int(math.log2(k)) + 1\n            ans = 0\n            jump = [[0] * m for _ in range(n)]\n            summ = [[0] * m for _ in range(n)]\n            for i in range(n):\n                jump[i][0] = receiver[i]\n                summ[i][0] = receiver[i]\n            for j in range(1, m):\n                for i in range(n):\n                    midNode = jump[i][j - 1]\n                    jump[i][j] = jump[midNode][j - 1]\n                    summ[i][j] = summ[i][j - 1] + summ[midNode][j - 1]\n            for i in range(n):\n                currSum = i\n                currPos = i\n                for j in range(m):\n                    if k >> j & 1 == 1:\n                        currSum += summ[currPos][j]\n                        currPos = jump[currPos][j]\n                ans = max(ans, currSum)\n            return ans\n    solution = Solution()\n    receiver = [2, 5, 4, 3, 6]\n    k = 17\n    assert solution.getMaxFunctionValue(receiver, k) == 70", "def test_getMaxFunctionValue():\n\n    class Solution:\n\n        def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:\n            n = len(receiver)\n            m = int(math.log2(k)) + 1\n            ans = 0\n            jump = [[0] * m for _ in range(n)]\n            summ = [[0] * m for _ in range(n)]\n            for i in range(n):\n                jump[i][0] = receiver[i]\n                summ[i][0] = receiver[i]\n            for j in range(1, m):\n                for i in range(n):\n                    midNode = jump[i][j - 1]\n                    jump[i][j] = jump[midNode][j - 1]\n                    summ[i][j] = summ[i][j - 1] + summ[midNode][j - 1]\n            for i in range(n):\n                currSum = i\n                currPos = i\n                for j in range(m):\n                    if k >> j & 1 == 1:\n                        currSum += summ[currPos][j]\n                        currPos = jump[currPos][j]\n                ans = max(ans, currSum)\n            return ans\n    solution = Solution()\n    receiver = [1, 2, 3, 4, 5]\n    k = 16\n    assert solution.getMaxFunctionValue(receiver, k) == 55", "def test_getMaxFunctionValue():\n\n    class Solution:\n\n        def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:\n            n = len(receiver)\n            m = int(math.log2(k)) + 1\n            ans = 0\n            jump = [[0] * m for _ in range(n)]\n            summ = [[0] * m for _ in range(n)]\n            for i in range(n):\n                jump[i][0] = receiver[i]\n                summ[i][0] = receiver[i]\n            for j in range(1, m):\n                for i in range(n):\n                    midNode = jump[i][j - 1]\n                    jump[i][j] = jump[midNode][j - 1]\n                    summ[i][j] = summ[i][j - 1] + summ[midNode][j - 1]\n            for i in range(n):\n                currSum = i\n                currPos = i\n                for j in range(m):\n                    if k >> j & 1 == 1:\n                        currSum += summ[currPos][j]\n                        currPos = jump[currPos][j]\n                ans = max(ans, currSum)\n            return ans\n    solution = Solution()\n    receiver = [3, 4, 5, 2, 1]\n    k = 32\n    assert solution.getMaxFunctionValue(receiver, k) == 155", "def test_getMaxFunctionValue():\n\n    class Solution:\n\n        def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:\n            n = len(receiver)\n            m = int(math.log2(k)) + 1\n            ans = 0\n            jump = [[0] * m for _ in range(n)]\n            summ = [[0] * m for _ in range(n)]\n            for i in range(n):\n                jump[i][0] = receiver[i]\n                summ[i][0] = receiver[i]\n            for j in range(1, m):\n                for i in range(n):\n                    midNode = jump[i][j - 1]\n                    jump[i][j] = jump[midNode][j - 1]\n                    summ[i][j] = summ[i][j - 1] + summ[midNode][j - 1]\n            for i in range(n):\n                currSum = i\n                currPos = i\n                for j in range(m):\n                    if k >> j & 1 == 1:\n                        currSum += summ[currPos][j]\n                        currPos = jump[currPos][j]\n                ans = max(ans, currSum)\n            return ans\n    solution = Solution()\n    receiver = [6, 5, 4, 3, 2]\n    k = 15\n    assert solution.getMaxFunctionValue(receiver, k) == 75", "def test_getMaxFunctionValue():\n\n    class Solution:\n\n        def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:\n            n = len(receiver)\n            m = int(math.log2(k)) + 1\n            ans = 0\n            jump = [[0] * m for _ in range(n)]\n            summ = [[0] * m for _ in range(n)]\n            for i in range(n):\n                jump[i][0] = receiver[i]\n                summ[i][0] = receiver[i]\n            for j in range(1, m):\n                for i in range(n):\n                    midNode = jump[i][j - 1]\n                    jump[i][j] = jump[midNode][j - 1]\n                    summ[i][j] = summ[i][j - 1] + summ[midNode][j - 1]\n            for i in range(n):\n                currSum = i\n                currPos = i\n                for j in range(m):\n                    if k >> j & 1 == 1:\n                        currSum += summ[currPos][j]\n                        currPos = jump[currPos][j]\n                ans = max(ans, currSum)\n            return ans\n    solution = Solution()\n    receiver = [2, 4, 6, 8, 10]\n    k = 31\n    assert solution.getMaxFunctionValue(receiver, k) == 155", "def test_getMaxFunctionValue():\n\n    class Solution:\n\n        def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:\n            n = len(receiver)\n            m = int(math.log2(k)) + 1\n            ans = 0\n            jump = [[0] * m for _ in range(n)]\n            summ = [[0] * m for _ in range(n)]\n            for i in range(n):\n                jump[i][0] = receiver[i]\n                summ[i][0] = receiver[i]\n            for j in range(1, m):\n                for i in range(n):\n                    midNode = jump[i][j - 1]\n                    jump[i][j] = jump[midNode][j - 1]\n                    summ[i][j] = summ[i][j - 1] + summ[midNode][j - 1]\n            for i in range(n):\n                currSum = i\n                currPos = i\n                for j in range(m):\n                    if k >> j & 1 == 1:\n                        currSum += summ[currPos][j]\n                        currPos = jump[currPos][j]\n                ans = max(ans, currSum)\n            return ans\n    solution = Solution()\n    receiver = [10, 8, 6, 4, 2]\n    k = 16\n    assert solution.getMaxFunctionValue(receiver, k) == 55", "def test_getMaxFunctionValue():\n\n    class Solution:\n\n        def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:\n            n = len(receiver)\n            m = int(math.log2(k)) + 1\n            ans = 0\n            jump = [[0] * m for _ in range(n)]\n            summ = [[0] * m for _ in range(n)]\n            for i in range(n):\n                jump[i][0] = receiver[i]\n                summ[i][0] = receiver[i]\n            for j in range(1, m):\n                for i in range(n):\n                    midNode = jump[i][j - 1]\n                    jump[i][j] = jump[midNode][j - 1]\n                    summ[i][j] = summ[i][j - 1] + summ[midNode][j - 1]\n            for i in range(n):\n                currSum = i\n                currPos = i\n                for j in range(m):\n                    if k >> j & 1 == 1:\n                        currSum += summ[currPos][j]\n                        currPos = jump[currPos][j]\n                ans = max(ans, currSum)\n            return ans\n    solution = Solution()\n    receiver = [5, 10, 3, 8, 4]\n    k = 20\n    assert solution.getMaxFunctionValue(receiver, k) == 121", "def test_getMaxFunctionValue():\n\n    class Solution:\n\n        def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:\n            n = len(receiver)\n            m = int(math.log2(k)) + 1\n            ans = 0\n            jump = [[0] * m for _ in range(n)]\n            summ = [[0] * m for _ in range(n)]\n            for i in range(n):\n                jump[i][0] = receiver[i]\n                summ[i][0] = receiver[i]\n            for j in range(1, m):\n                for i in range(n):\n                    midNode = jump[i][j - 1]\n                    jump[i][j] = jump[midNode][j - 1]\n                    summ[i][j] = summ[i][j - 1] + summ[midNode][j - 1]\n            for i in range(n):\n                currSum = i\n                currPos = i\n                for j in range(m):\n                    if k >> j & 1 == 1:\n                        currSum += summ[currPos][j]\n                        currPos = jump[currPos][j]\n                ans = max(ans, currSum)\n            return ans\n    solution = Solution()\n    receiver = [8, 6, 4, 2, 10]\n    k = 32\n    assert solution.getMaxFunctionValue(receiver, k) == 155", "def test_getMaxFunctionValue():\n\n    class Solution:\n\n        def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:\n            n = len(receiver)\n            m = int(math.log2(k)) + 1\n            ans = 0\n            jump = [[0] * m for _ in range(n)]\n            summ = [[0] * m for _ in range(n)]\n            for i in range(n):\n                jump[i][0] = receiver[i]\n                summ[i][0] = receiver[i]\n            for j in range(1, m):\n                for i in range(n):\n                    midNode = jump[i][j - 1]\n                    jump[i][j] = jump[midNode][j - 1]\n                    summ[i][j] = summ[i][j - 1] + summ[midNode][j - 1]\n            for i in range(n):\n                currSum = i\n                currPos = i\n                for j in range(m):\n                    if k >> j & 1 == 1:\n                        currSum += summ[currPos][j]\n                        currPos = jump[currPos][j]\n                ans = max(ans, currSum)\n            return ans\n    solution = Solution()\n    receiver = [2, 8, 6, 4, 10]\n    k = 16\n    assert solution.getMaxFunctionValue(receiver, k) == 55", "def test_getMaxFunctionValue():\n\n    class Solution:\n\n        def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:\n            n = len(receiver)\n            m = int(math.log2(k)) + 1\n            ans = 0\n            jump = [[0] * m for _ in range(n)]\n            summ = [[0] * m for _ in range(n)]\n            for i in range(n):\n                jump[i][0] = receiver[i]\n                summ[i][0] = receiver[i]\n            for j in range(1, m):\n                for i in range(n):\n                    midNode = jump[i][j - 1]\n                    jump[i][j] = jump[midNode][j - 1]\n                    summ[i][j] = summ[i][j - 1] + summ[midNode][j - 1]\n            for i in range(n):\n                currSum = i\n                currPos = i\n                for j in range(m):\n                    if k >> j & 1 == 1:\n                        currSum += summ[currPos][j]\n                        currPos = jump[currPos][j]\n                ans = max(ans, currSum)\n            return ans\n    solution = Solution()\n    receiver = [10, 8, 6, 4, 2]\n    k = 31\n    assert solution.getMaxFunctionValue(receiver, k) == 155", "def test_getMaxFunctionValue():\n\n    class Solution:\n\n        def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:\n            n = len(receiver)\n            m = int(math.log2(k)) + 1\n            ans = 0\n            jump = [[0] * m for _ in range(n)]\n            summ = [[0] * m for _ in range(n)]\n            for i in range(n):\n                jump[i][0] = receiver[i]\n                summ[i][0] = receiver[i]\n            for j in range(1, m):\n                for i in range(n):\n                    midNode = jump[i][j - 1]\n                    jump[i][j] = jump[midNode][j - 1]\n                    summ[i][j] = summ[i][j - 1] + summ[midNode][j - 1]\n            for i in range(n):\n                currSum = i\n                currPos = i\n                for j in range(m):\n                    if k >> j & 1 == 1:\n                        currSum += summ[currPos][j]\n                        currPos = jump[currPos][j]\n                ans = max(ans, currSum)\n            return ans\n    solution = Solution()\n    receiver = [4, 6, 8, 10, 2]\n    k = 20\n    assert solution.getMaxFunctionValue(receiver, k) == 121", "def test_getMaxFunctionValue():\n\n    class Solution:\n\n        def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:\n            n = len(receiver)\n            m = int(math.log2(k)) + 1\n            ans = 0\n            jump = [[0] * m for _ in range(n)]\n            summ = [[0] * m for _ in range(n)]\n            for i in range(n):\n                jump[i][0] = receiver[i]\n                summ[i][0] = receiver[i]\n            for j in range(1, m):\n                for i in range(n):\n                    midNode = jump[i][j - 1]\n                    jump[i][j] = jump[midNode][j - 1]\n                    summ[i][j] = summ[i][j - 1] + summ[midNode][j - 1]\n            for i in range(n):\n                currSum = i\n                currPos = i\n                for j in range(m):\n                    if k >> j & 1 == 1:\n                        currSum += summ[currPos][j]\n                        currPos = jump[currPos][j]\n                ans = max(ans, currSum)\n            return ans\n    solution = Solution()\n    receiver = [2, 10, 8, 6, 4]\n    k = 16\n    assert solution.getMaxFunctionValue(receiver, k) == 55", "def test_getMaxFunctionValue():\n\n    class Solution:\n\n        def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:\n            n = len(receiver)\n            m = int(math.log2(k)) + 1\n            ans = 0\n            jump = [[0] * m for _ in range(n)]\n            summ = [[0] * m for _ in range(n)]\n            for i in range(n):\n                jump[i][0] = receiver[i]\n                summ[i][0] = receiver[i]\n            for j in range(1, m):\n                for i in range(n):\n                    midNode = jump[i][j - 1]\n                    jump[i][j] = jump[midNode][j - 1]\n                    summ[i][j] = summ[i][j - 1] + summ[midNode][j - 1]\n            for i in range(n):\n                currSum = i\n                currPos = i\n                for j in range(m):\n                    if k >> j & 1 == 1:\n                        currSum += summ[currPos][j]\n                        currPos = jump[currPos][j]\n                ans = max(ans, currSum)\n            return ans\n    solution = Solution()\n    receiver = [4, 8, 10, 6, 2]\n    k = 32\n    assert solution.getMaxFunctionValue(receiver, k) == 155", "def test_getMaxFunctionValue():\n\n    class Solution:\n\n        def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:\n            n = len(receiver)\n            m = int(math.log2(k)) + 1\n            ans = 0\n            jump = [[0] * m for _ in range(n)]\n            summ = [[0] * m for _ in range(n)]\n            for i in range(n):\n                jump[i][0] = receiver[i]\n                summ[i][0] = receiver[i]\n            for j in range(1, m):\n                for i in range(n):\n                    midNode = jump[i][j - 1]\n                    jump[i][j] = jump[midNode][j - 1]\n                    summ[i][j] = summ[i][j - 1] + summ[midNode][j - 1]\n            for i in range(n):\n                currSum = i\n                currPos = i\n                for j in range(m):\n                    if k >> j & 1 == 1:\n                        currSum += summ[currPos][j]\n                        currPos = jump[currPos][j]\n                ans = max(ans, currSum)\n            return ans\n    solution = Solution()\n    receiver = [2, 4, 6, 8, 10]\n    k = 31\n    assert solution.getMaxFunctionValue(receiver, k) == 155", "def test_getMaxFunctionValue():\n\n    class Solution:\n\n        def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:\n            n = len(receiver)\n            m = int(math.log2(k)) + 1\n            ans = 0\n            jump = [[0] * m for _ in range(n)]\n            summ = [[0] * m for _ in range(n)]\n            for i in range(n):\n                jump[i][0] = receiver[i]\n                summ[i][0] = receiver[i]\n            for j in range(1, m):\n                for i in range(n):\n                    midNode = jump[i][j - 1]\n                    jump[i][j] = jump[midNode][j - 1]\n                    summ[i][j] = summ[i][j - 1] + summ[midNode][j - 1]\n            for i in range(n):\n                currSum = i\n                currPos = i\n                for j in range(m):\n                    if k >> j & 1 == 1:\n                        currSum += summ[currPos][j]\n                        currPos = jump[currPos][j]\n                ans = max(ans, currSum)\n            return ans\n    solution = Solution()\n    receiver = [10, 8, 6, 4, 2]\n    k = 16\n    assert solution.getMaxFunctionValue(receiver, k) == 55", "def test_getMaxFunctionValue():\n\n    class Solution:\n\n        def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:\n            n = len(receiver)\n            m = int(math.log2(k)) + 1\n            ans = 0\n            jump = [[0] * m for _ in range(n)]\n            summ = [[0] * m for _ in range(n)]\n            for i in range(n):\n                jump[i][0] = receiver[i]\n                summ[i][0] = receiver[i]\n            for j in range(1, m):\n                for i in range(n):\n                    midNode = jump[i][j - 1]\n                    jump[i][j] = jump[midNode][j - 1]\n                    summ[i][j] = summ[i][j - 1] + summ[midNode][j - 1]\n            for i in range(n):\n                currSum = i\n                currPos = i\n                for j in range(m):\n                    if k >> j & 1 == 1:\n                        currSum += summ[currPos][j]\n                        currPos = jump[currPos][j]\n                ans = max(ans, currSum)\n            return ans\n    solution = Solution()\n    receiver = [2, 4, 6, 8, 10]\n    k = 32\n    assert solution.getMaxFunctionValue(receiver, k) == 155", "def test_getMaxFunctionValue():\n\n    class Solution:\n\n        def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:\n            n = len(receiver)\n            m = int(math.log2(k)) + 1\n            ans = 0\n            jump = [[0] * m for _ in range(n)]\n            summ = [[0] * m for _ in range(n)]\n            for i in range(n):\n                jump[i][0] = receiver[i]\n                summ[i][0] = receiver[i]\n            for j in range(1, m):\n                for i in range(n):\n                    midNode = jump[i][j - 1]\n                    jump[i][j] = jump[midNode][j - 1]\n                    summ[i][j] = summ[i][j - 1] + summ[midNode][j - 1]\n            for i in range(n):\n                currSum = i\n                currPos = i\n                for j in range(m):\n                    if k >> j & 1 == 1:\n                        currSum += summ[currPos][j]\n                        currPos = jump[currPos][j]\n                ans = max(ans, currSum)\n            return ans\n    solution = Solution()\n    receiver = [4, 6, 8, 10, 2]\n    k = 16\n    assert solution.getMaxFunctionValue(receiver, k) == 55"]}
{"task_num": 2844, "task_title": "Minimum Operations to Make a Special Number", "func_name": "minimumOperations", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumOperations(self, num: str) -> int:\n    n = len(num)\n    seenFive = False\n    seenZero = False\n\n    for i in range(n - 1, -1, -1):\n      if seenZero and num[i] == '0':\n        return n - i - 2\n      if seenZero and num[i] == '5':\n        return n - i - 2\n      if seenFive and num[i] == '2':\n        return n - i - 2\n      if seenFive and num[i] == '7':\n        return n - i - 2\n      seenZero = seenZero or num[i] == '0'\n      seenFive = seenFive or num[i] == '5'\n\n    if seenZero:\n      return n - 1\n    else:\n      return n\n", "tests": ["def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('000') == 2, 'Test case for empty string'", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('2525') == 0, 'Test case for divisible by 25'", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('1020') == 4, 'Test case with two zeros'", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('520') == 1, 'Test case with five and two'", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('757') == 3, 'Test case with seven and five'", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('00005') == 3, 'Test case with multiple zeros'", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('123456') == 6, 'Test case with digits other than zero and five'", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('25') == 0, 'Test case with number divisible by 25'", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('10') == 2, 'Test case with one zero'", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('777') == 4, 'Test case with all sevens'", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('0000') == 1, 'Test case with multiple zeros at start'", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('55555') == 1, 'Test case with multiple fives'", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('22222') == 4, 'Test case with multiple twos'", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('00000') == 0, 'Test case with only zeros'", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('000') == 2, 'Test case with only zeros at start'", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('1234567890') == 10, 'Test case with all digits'", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('0123456789') == 10, 'Test case with all digits in order'", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('125') == 1, 'Test case with special number'", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('10275') == 0, 'Test case with number divisible by 25'", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('0') == 1, 'Test case with single zero'"]}
{"task_num": 2846, "task_title": "Minimum Edge Weight Equilibrium Queries in a Tree", "func_name": "minOperationsQueries", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minOperationsQueries(self, n: int, edges: List[List[int]], queries: List[List[int]]) -> List[int]:\n    kMax = 26\n    m = int(math.log2(n)) + 1\n    ans = []\n    graph = [[] for _ in range(n)]\n    jump = [[0] * m for _ in range(n)]\n    count = [[] for _ in range(n)]\n    depth = [0] * n\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    def dfs(u: int, prev: int, d: int):\n      if prev != -1:\n        jump[u][0] = prev\n      depth[u] = d\n      for v, w in graph[u]:\n        if v == prev:\n          continue\n        count[v] = count[u][:]\n        count[v][w] += 1\n        dfs(v, u, d + 1)\n\n    count[0] = [0] * (kMax + 1)\n    dfs(0, -1, 0)\n\n    for j in range(1, m):\n      for i in range(n):\n        jump[i][j] = jump[jump[i][j - 1]][j - 1]\n\n    def getLCA(u: int, v: int) -> int:\n      if depth[u] > depth[v]:\n        return getLCA(v, u)\n      for j in range(m):\n        if depth[v] - depth[u] >> j & 1:\n          v = jump[v][j]\n      if u == v:\n        return u\n      for j in range(m - 1, -1, -1):\n        if jump[u][j] != jump[v][j]:\n          u = jump[u][j]\n          v = jump[v][j]\n      return jump[v][0]\n\n    for u, v in queries:\n      lca = getLCA(u, v)\n      numEdges = depth[u] + depth[v] - 2 * depth[lca]\n      maxFreq = max(count[u][j] + count[v][j] - 2 * count[lca][j] for j in range(1, kMax + 1))\n      ans.append(numEdges - maxFreq)\n\n    return ans\n", "tests": ["def test_minOperationsQueries():\n\n    class Solution:\n\n        def minOperationsQueries(self, n: int, edges: List[List[int]], queries: List[List[int]]) -> List[int]:\n            kMax = 26\n            m = int(math.log2(n)) + 1\n            ans = []\n            graph = [[] for _ in range(n)]\n            jump = [[0] * m for _ in range(n)]\n            count = [[] for _ in range(n)]\n            depth = [0] * n\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n\n            def dfs(u: int, prev: int, d: int):\n                if prev != -1:\n                    jump[u][0] = prev\n                depth[u] = d\n                for (v, w) in graph[u]:\n                    if v == prev:\n                        continue\n                    count[v] = count[u][:]\n                    count[v][w] += 1\n                    dfs(v, u, d + 1)\n            count[0] = [0] * (kMax + 1)\n            dfs(0, -1, 0)\n            for j in range(1, m):\n                for i in range(n):\n                    jump[i][j] = jump[jump[i][j - 1]][j - 1]\n\n            def getLCA(u: int, v: int) -> int:\n                if depth[u] > depth[v]:\n                    return getLCA(v, u)\n                for j in range(m):\n                    if depth[v] - depth[u] >> j & 1:\n                        v = jump[v][j]\n                if u == v:\n                    return u\n                for j in range(m - 1, -1, -1):\n                    if jump[u][j] != jump[v][j]:\n                        u = jump[u][j]\n                        v = jump[v][j]\n                return jump[v][0]\n            for (u, v) in queries:\n                lca = getLCA(u, v)\n                numEdges = depth[u] + depth[v] - 2 * depth[lca]\n                maxFreq = max((count[u][j] + count[v][j] - 2 * count[lca][j] for j in range(1, kMax + 1)))\n                ans.append(numEdges - maxFreq)\n            return ans\n    solution = Solution()\n    n = 6\n    edges = [[0, 1, 3], [0, 2, 3], [1, 3, -2], [2, 3, -5]]\n    queries = [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5]]\n    assert solution.minOperationsQueries(n, edges, queries) == [0, 0, 2, 0, 3]", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 8\n    edges = [[0, 1, -5], [0, 2, -3], [1, 3, -10], [1, 4, -2], [2, 4, -6], [2, 5, -7]]\n    queries = [[1, 4], [1, 6], [0, 5], [0, 4], [0, 6]]\n    assert solution.minOperationsQueries(n, edges, queries) == [4, 8, 1, 4, 9]", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 10\n    edges = [[0, 1, -5], [0, 2, -3], [1, 3, -10], [1, 4, -2], [2, 4, -6], [2, 5, -7], [3, 9, -8]]\n    queries = [[0, 3], [0, 9], [3, 9], [3, 5], [9, 1], [9, 0]]\n    assert solution.minOperationsQueries(n, edges, queries) == [7, 0, 0, 2, 11]", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 12\n    edges = [[0, 1, -5], [0, 2, -3], [1, 3, -10], [1, 4, -2], [2, 4, -6], [2, 5, -7], [3, 9, -8]]\n    queries = [[0, 3], [0, 11], [3, 5], [9, 1], [0, 5], [9, 0]]\n    assert solution.minOperationsQueries(n, edges, queries) == [7, 14, 2, 12, 15]", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 8\n    edges = [[0, 1, -5], [0, 2, -3]]\n    queries = [[0, 1], [0, 6], [0, 7], [0, 5]]\n    assert solution.minOperationsQueries(n, edges, queries) == [10, 0, 0, 9]", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 16\n    edges = [[0, 1, -5], [0, 2, -3], [1, 3, -10], [1, 4, -2], [2, 4, -6], [2, 5, -7]]\n    queries = [[0, 15], [13, 14], [12, 8], [11, 9], [9, 10]]\n    assert solution.minOperationsQueries(n, edges, queries) == [21, 23, 22, 19, 17]", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 20\n    edges = [[0, 1, -5], [0, 2, -3], [1, 3, -10], [1, 4, -2], [2, 4, -6], [2, 5, -7]]\n    queries = [[15, 16], [12, 13], [14, 9], [8, 11], [0, 4]]\n    assert solution.minOperationsQueries(n, edges, queries) == [25, 26, 22, 17, 21]", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 25\n    edges = [[0, 1, -5], [0, 2, -3], [1, 3, -10], [1, 4, -2], [2, 4, -6], [2, 5, -7]]\n    queries = [[19, 21], [20, 18], [15, 17], [14, 16], [11, 13], [12, 14]]\n    assert solution.minOperationsQueries(n, edges, queries) == [39, 41, 34, 32, 37, 35]", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 1000\n    edges = [[i, j, -1] for i in range(n) for j in range(i + 1, n)]\n    queries = [[n - 1, i] for i in range(n)]\n    assert solution.minOperationsQueries(n, edges, queries) == [499499, 499498, 499497, ...]", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 10000\n    edges = [[i, j, -1] for i in range(n) for j in range(i + 1, n)]\n    queries = [(n - 1, i) for i in range(n // 2, 3 * n // 4)]\n    assert len(solution.minOperationsQueries(n, edges, queries)) == len(queries)", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 1000000\n    edges = [[i, j, -1] for i in range(n) for j in range(i + 1, n)]\n    queries = [(n - 1, i) for i in range(n // 2, n // 4 + n // 2)]\n    assert solution.minOperationsQueries(n, edges, queries)", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 2000000\n    edges = [[i, j, -1] for i in range(n) for j in range(i + 1, n)]\n    queries = [(n - 1, i) for i in range(n // 4, 3 * n // 4)]\n    assert solution.minOperationsQueries(n, edges, queries)", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 10000000\n    edges = [[i, j, -1] for i in range(n) for j in range(i + 1, n)]\n    queries = [(n - 1, i) for i in range(n // 4, 3 * n // 4)]\n    assert solution.minOperationsQueries(n, edges, queries)", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 100000000\n    edges = [[i, j, -1] for i in range(n) for j in range(i + 1, n)]\n    queries = [(n - 1, i) for i in range(n // 4, 3 * n // 4)]\n    assert solution.minOperationsQueries(n, edges, queries)", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 2000000000\n    edges = [[i, j, -1] for i in range(n) for j in range(i + 1, n)]\n    queries = [(n - 1, i) for i in range(n // 4, 3 * n // 4)]\n    assert solution.minOperationsQueries(n, edges, queries)", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 10000000000\n    edges = [[i, j, -1] for i in range(n) for j in range(i + 1, n)]\n    queries = [(n - 1, i) for i in range(n // 4, 3 * n // 4)]\n    assert solution.minOperationsQueries(n, edges, queries)", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 10000000000\n    edges = [[i, j, -1] for i in range(n) for j in range(i + 1, n)]\n    queries = [(n - 1, i) for i in range(n // 4, 3 * n // 4)]\n    assert len(solution.minOperationsQueries(n, edges, queries)) == len(queries)", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 10000000\n    edges = [[i, j, -1] for i in range(n) for j in range(i + 1, n)]\n    queries = [(n - 1, i) for i in range(n // 4, 3 * n // 4) if i % 2 == 0]\n    assert solution.minOperationsQueries(n, edges, queries)", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 10000000\n    edges = [[i, j, -1] for i in range(n) for j in range(i + 1, n)]\n    queries = [(n - 1, i) for i in range(n // 4, 3 * n // 4) if i % 5 == 0]\n    assert solution.minOperationsQueries(n, edges, queries)", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 10000000\n    edges = [[i, j, -1] for i in range(n) for j in range(i + 1, n)]\n    queries = [(n - 1, i) for i in range(n // 4, 3 * n // 4) if i % 7 == 0]\n    assert len(solution.minOperationsQueries(n, edges, queries)) == len(queries)"]}
{"task_num": 2850, "task_title": "Minimum Moves to Spread Stones Over Grid", "func_name": "minimumMoves", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumMoves(self, grid: List[List[int]]) -> int:\n    if sum(row.count(0) for row in grid) == 0:\n      return 0\n\n    ans = math.inf\n\n    for i in range(3):\n      for j in range(3):\n        if grid[i][j] == 0:\n          for x in range(3):\n            for y in range(3):\n              if grid[x][y] > 1:\n                grid[x][y] -= 1\n                grid[i][j] += 1\n                ans = min(ans, abs(x - i) + abs(y - j) + self.minimumMoves(grid))\n                grid[x][y] += 1\n                grid[i][j] -= 1\n\n    return ans\n", "tests": ["def test_minimumMoves(self):\n    grid = [[0, 1, 2], [3, 4, 5], [6, 7, 8]]\n    self.assertEqual(solution.minimumMoves(grid), 3)", "def test_minimumMoves(self):\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]\n    self.assertEqual(solution.minimumMoves(grid), 3)", "def test_minimumMoves(self):\n    grid = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]\n    self.assertEqual(solution.minimumMoves(grid), 5)", "def test_minimumMoves(self):\n    grid = [[0, 0, 0], [0, 0, 0], [8, 7, 6]]\n    self.assertEqual(solution.minimumMoves(grid), 1)", "def test_minimumMoves(self):\n    grid = [[9, 8, 7], [6, 5, 4], [3, 2, 1]]\n    self.assertEqual(solution.minimumMoves(grid), 0)", "def test_minimumMoves(self):\n    grid = [[0, 0, 2], [3, 4, 5], [6, 7, 8]]\n    self.assertEqual(solution.minimumMoves(grid), math.inf)", "def test_minimumMoves(self):\n    grid = [[0, 1, 0], [3, 4, 0], [6, 7, 8]]\n    self.assertEqual(solution.minimumMoves(grid), math.inf)", "def test_minimumMoves(self):\n    grid = [[0 for _ in range(3)] for _ in range(3)]\n    self.assertEqual(solution.minimumMoves(grid), 0)", "def test_minimumMoves(self):\n    grid = [[2, 0, 1], [3, 4, 5], [6, 7, 8]]\n    self.assertEqual(solution.minimumMoves(grid), math.inf)", "def test_minimumMoves(self):\n    grid = [[0, 2, 1], [3, 4, 5], [6, 7, 8]]\n    self.assertEqual(solution.minimumMoves(grid), math.inf)", "def test_minimumMoves(self):\n    grid = [[0, 1, 2], [3, 4, 5], [6, 7, 8]]\n    self.assertEqual(solution.minimumMoves(grid), 3)", "def test_minimumMoves(self):\n    grid = [[2, 0, 3], [4, 5, 6], [8, 7, 9]]\n    self.assertEqual(solution.minimumMoves(grid), math.inf)", "def test_minimumMoves(self):\n    grid = [[9, 8, 1], [2, 3, 4], [5, 6, 7]]\n    self.assertEqual(solution.minimumMoves(grid), math.inf)", "def test_minimumMoves(self):\n    grid = [[9, 8, 7], [6, 0, 5], [3, 2, 1]]\n    self.assertEqual(solution.minimumMoves(grid), math.inf)", "def test_minimumMoves(self):\n    grid = [[1, 2, 3], [4, 0, 5], [6, 7, 8]]\n    self.assertEqual(solution.minimumMoves(grid), math.inf)", "def test_minimumMoves(self):\n    grid = [[1, 2, 3], [4, 5, 0], [6, 7, 8]]\n    self.assertEqual(solution.minimumMoves(grid), math.inf)", "def test_minimumMoves(self):\n    grid = [[1, 2, 3], [4, 5, 6], [0, 7, 8]]\n    self.assertEqual(solution.minimumMoves(grid), math.inf)", "def test_minimumMoves(self):\n    grid = [[9, 1, 2], [3, 4, 5], [6, 7, 0]]\n    self.assertEqual(solution.minimumMoves(grid), math.inf)", "def test_minimumMoves(self):\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]\n    self.assertEqual(solution.minimumMoves(grid), math.inf)", "def test_minimumMoves(self):\n    grid = [[0, 1, 2], [3, 4, 5], [8, 7, 9]]\n    self.assertEqual(solution.minimumMoves(grid), math.inf)"]}
{"task_num": 2851, "task_title": "String Transformation", "func_name": "numberOfWays", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numberOfWays(self, s: str, t: str, k: int) -> int:\n    kMod = 1_000_000_007\n    n = len(s)\n    negOnePowK = 1 if k % 2 == 0 else -1  # (-1)^k\n    z = self._zFunction(s + t + t)\n\n    indices = [i - n for i in range(n, n + n) if z[i] >= n]\n    dp = [0] * 2\n    dp[1] = (pow(n - 1, k, kMod) - negOnePowK) * pow(n, kMod - 2, kMod)\n    dp[0] = dp[1] + negOnePowK\n    res = 0\n    for index in indices:\n      if index == 0:\n        res += dp[0]\n      else: \n        res += dp[1]\n    return res % kMod\n\n\n  def _zFunction(self, s: str) -> List[int]:\n    n = len(s)\n    z = [0] * n\n    l = 0\n    r = 0\n    for i in range(1, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l])\n      while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n    return z\n", "tests": ["def test_numberOfWays(self):\n    s = 'abcd'\n    t = 'cdab'\n    k = 2\n    self.assertEqual(self.solution.numberOfWays(s, t, k), 3)", "def test_numberOfWays(self):\n    s = 'abc'\n    t = 'abc'\n    k = 0\n    self.assertEqual(self.solution.numberOfWays(s, t, k), 1)", "def test_numberOfWays(self):\n    s = 'abcd'\n    t = 'cdab'\n    k = 1\n    self.assertEqual(self.solution.numberOfWays(s, t, k), (pow(4 - 1, 1000000007, 1000000007) + 1) % 1000000007)", "def test_numberOfWays(self):\n    s = 'a' * 1000000\n    t = 'ab'\n    k = -1\n    self.assertEqual(self.solution.numberOfWays(s, t, k), 0)", "def test_numberOfWays(self):\n    s = 'abcd'\n    t = 'cdab'\n    k = -2\n    self.assertEqual(self.solution.numberOfWays(s, t, k), 0)", "def test_numberOfWays(self):\n    s = ''\n    t = 'cdab'\n    k = 2\n    self.assertEqual(self.solution.numberOfWays(s, t, k), 0)", "def test_numberOfWays(self):\n    s = 'a'\n    t = 'a'\n    k = 2\n    self.assertEqual(self.solution.numberOfWays(s, t, k), (pow(0, 1000000007, 1000000007) + 1) % 1000000007)", "def test_numberOfWays(self):\n    s = 'abcd'\n    t = 'cdab'\n    k = 4\n    self.assertEqual(self.solution.numberOfWays(s, t, k), (pow(3, 1000000007, 1000000007) + pow(1, 1000000007, 1000000007)) % 1000000007)", "def test_numberOfWays(self):\n    s = 'ab'\n    t = 'cd'\n    k = 2\n\n    class MockSolution:\n\n        def _zFunction(self, s):\n            return [1] * len(s)\n    solution._zFunction = MockSolution()._zFunction\n    self.assertEqual(solution.numberOfWays(s, t, k), 0)", "def test_numberOfWays(self):\n    s = 'abcd'\n    t = 'cdab'\n    k = 1\n    self.assertEqual(self.solution.numberOfWays(s, t, k), (pow(4 - 1, 1000000007, 1000000007) + pow(0, 1000000007, 1000000007)) % 1000000007)", "def test_numberOfWays(self):\n    s = 'a'\n    t = 'ab'\n    k = 2\n    self.assertEqual(self.solution.numberOfWays(s, t, k), 0)", "def test_numberOfWays(self):\n    s = 'ab'\n    t = 'cd'\n    k = 2\n\n    class MockSolution:\n\n        def _zFunction(self, s):\n            return [0] * len(s)\n    solution._zFunction = MockSolution()._zFunction\n    self.assertEqual(solution.numberOfWays(s, t, k), (pow(3, 1000000007, 1000000007) + pow(1, 1000000007, 1000000007)) % 1000000007)", "def test_numberOfWays(self):\n    s = 'abcd'\n    t = 'cdab'\n    k = -2\n    self.assertEqual(self.solution.numberOfWays(s, t, k), 0)", "def test_numberOfWays(self):\n    s = 'ab'\n    t = 'cd'\n    k = 2\n\n    class MockSolution:\n\n        def _zFunction(self, s):\n            return [0] * len(s)\n            z = [0] * len(s)\n            l = 0\n            r = 0\n            for i in range(1, len(s)):\n                if i < r:\n                    z[i] = min(r - i, z[i - l])\n                while i + z[i] < len(s) and s[z[i]] == s[i + z[i]]:\n                    z[i] += 1\n                if i + z[i] > r:\n                    l = i\n                    r = i + z[i]\n            return [z[0] for _ in range(len(z))]\n    solution._zFunction = MockSolution()._zFunction\n    self.assertEqual(solution.numberOfWays(s, t, k), 3)", "def test_numberOfWays(self):\n    s = ''\n    t = ''\n    k = 2\n    self.assertEqual(self.solution.numberOfWays(s, t, k), (pow(0, 1000000007, 1000000007) + pow(1, 1000000007, 1000000007)) % 1000000007)", "def test_numberOfWays(self):\n    s = 'ab'\n    t = 'cd'\n    k = -2\n    self.assertEqual(self.solution.numberOfWays(s, t, k), 0)", "def test_numberOfWays(self):\n    s = 'ab'\n    t = 'cd'\n    k = 1000000\n    self.assertEqual(self.solution.numberOfWays(s, t, k), (pow(3, 1000000007, 1000000007) + pow(1, 1000000007, 1000000007)) % 1000000007)", "def test_numberOfWays(self):\n    s = 'abcd'\n    t = 'cdab'\n    k = 0\n    self.assertEqual(self.solution.numberOfWays(s, t, k), (pow(4 - 1, 1000000007, 1000000007) + pow(0, 1000000007, 1000000007)) % 1000000007)", "def test_numberOfWays(self):\n    s = ''\n    t = ''\n    k = 2\n    self.assertEqual(self.solution.numberOfWays(s, t, k), (pow(0, 1000000007, 1000000007) + pow(1, 1000000007, 1000000007)) % 1000000007)", "def test_numberOfWays(self):\n    s = 'abcd'\n    t = 'cdab'\n    k = len(s)\n    self.assertEqual(self.solution.numberOfWays(s, t, k), (pow(3, 1000000007, 1000000007) + pow(1, 1000000007, 1000000007)) % 1000000007)"]}
{"task_num": 2876, "task_title": "Count Visited Nodes in a Directed Graph", "func_name": "countVisitedNodes", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countVisitedNodes(self, edges: List[int]) -> List[int]:\n    n = len(edges)\n    ans = [0] * n\n    inDegrees = [0] * n\n    seen = [False] * n\n    stack = []\n\n    for v in edges:\n      inDegrees[v] += 1\n\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n\n    while q:\n      u = q.popleft()\n      inDegrees[edges[u]] -= 1\n      if inDegrees[edges[u]] == 0:\n        q.append(edges[u])\n      stack.append(u)\n      seen[u] = True\n\n    for i in range(n):\n      if not seen[i]:\n        self._fillCycle(edges, i, seen, ans)\n\n    while stack:\n      u = stack.pop()\n      ans[u] = ans[edges[u]] + 1\n\n    return ans\n\n  def _fillCycle(self, edges: List[int], start: int, seen: List[bool], ans: List[int]) -> None:\n    cycleLength = 0\n    u = start\n    while not seen[u]:\n      cycleLength += 1\n      seen[u] = True\n      u = edges[u]\n    ans[start] = cycleLength\n    u = edges[start]\n    while u != start:\n      ans[u] = cycleLength\n      u = edges[u]\n", "tests": ["def test_countVisitedNodes():\n\n    class Solution:\n\n        def countVisitedNodes(self, edges: List[int]) -> List[int]:\n            n = len(edges)\n            ans = [0] * n\n            inDegrees = [0] * n\n            seen = [False] * n\n            stack = []\n            for v in edges:\n                inDegrees[v] += 1\n            q = collections.deque([i for (i, d) in enumerate(inDegrees) if d == 0])\n            while q:\n                u = q.popleft()\n                inDegrees[edges[u]] -= 1\n                if inDegrees[edges[u]] == 0:\n                    q.append(edges[u])\n                stack.append(u)\n                seen[u] = True\n            for i in range(n):\n                if not seen[i]:\n                    self._fillCycle(edges, i, seen, ans)\n            while stack:\n                u = stack.pop()\n                ans[u] = ans[edges[u]] + 1\n            return ans\n\n        def _fillCycle(self, edges: List[int], start: int, seen: List[bool], ans: List[int]) -> None:\n            cycleLength = 0\n            u = start\n            while not seen[u]:\n                cycleLength += 1\n                seen[u] = True\n                u = edges[u]\n            ans[start] = cycleLength\n            u = edges[start]\n            while u != start:\n                ans[u] = cycleLength\n                u = edges[u]\n\n    class TestSolution(unittest.TestCase):\n\n        def test_countVisitedNodes(self):\n            solution = Solution()\n            edges = [0, 1, 2, 3]\n            self.assertEqual(solution.countVisitedNodes(edges), [4, 3, 3, 1])", "def test_countVisitedNodes(self):\n    solution = Solution()\n    edges = [0, 1, 2]\n    self.assertEqual(solution.countVisitedNodes(edges), [4, 3, 2])", "def test_countVisitedNodes(self):\n    solution = Solution()\n    edges = [0]\n    self.assertEqual(solution.countVisitedNodes(edges), [1])", "def test_countVisitedNodes(self):\n    solution = Solution()\n    edges = [0, 1, 2, 3, 4]\n    self.assertEqual(solution.countVisitedNodes(edges), [5, 5, 5, 5, 5])", "def test_countVisitedNodes(self):\n    solution = Solution()\n    edges = []\n    self.assertEqual(solution.countVisitedNodes(edges), [0])", "def test_countVisitedNodes(self):\n    solution = Solution()\n    edges = list(range(1000))\n    self.assertEqual(len(solution.countVisitedNodes(edges)), 1000)", "def test_countVisitedNodes(self):\n    solution = Solution()\n    edges = [0, 1, 2, 3, 4, 5]\n    self.assertEqual(solution.countVisitedNodes(edges), [6, 5, 5, 4, 4, 3])", "def test_countVisitedNodes(self):\n    solution = Solution()\n    edges = [0, 0, 0, 0]\n    self.assertEqual(solution.countVisitedNodes(edges), [4, 3, 2, 1])", "def test_countVisitedNodes(self):\n    solution = Solution()\n    edges = [0, 1, 2, 3, 4, 5]\n    edges[0] = 1\n    edges[1] = 2\n    edges[2] = 3\n    edges[3] = 4\n    self.assertEqual(solution.countVisitedNodes(edges), [6, 5, 5, 5, 3, 1])", "def test_countVisitedNodes(self):\n    solution = Solution()\n    edges = [0]\n    self.assertEqual(solution.countVisitedNodes(edges), [2])", "def test_countVisitedNodes(self):\n    solution = Solution()\n    edges = [0, 1, 2]\n    edges[0] = 0\n    self.assertEqual(solution.countVisitedNodes(edges), [4, 3, 1])", "def test_countVisitedNodes(self):\n    solution = Solution()\n    edges = [int(2000000000.0)]\n    self.assertEqual(len(solution.countVisitedNodes(edges)), 1)", "def test_countVisitedNodes(self):\n    solution = Solution()\n    edges = [0, -1]\n    with self.assertRaises(ValueError):\n        solution.countVisitedNodes(edges)", "def test_countVisitedNodes(self):\n    solution = Solution()\n    edges = [0, 1.5]\n    with self.assertRaises(TypeError):\n        solution.countVisitedNodes(edges)", "def test_countVisitedNodes(self):\n    solution = Solution()\n    with self.assertRaises(IndexError):\n        solution.countVisitedNodes([])", "def test_countVisitedNodes(self):\n\n    class InvalidInput:\n        pass\n    solution = Solution()\n    with self.assertRaises(TypeError):\n        solution.countVisitedNodes(InvalidInput())", "def test_countVisitedNodes(self):\n    solution = Solution()\n    edges = list(range(2000))\n    self.assertEqual(len(solution.countVisitedNodes(edges)), 2000)", "def test_countVisitedNodes(self):\n    solution = Solution()\n    edges = []\n    self.assertEqual(solution.countVisitedNodes(edges), [])", "def test_countVisitedNodes(self):\n    solution = Solution()\n    edges = [0, 1, 2, 3, 4]\n    edges[1] = 0\n    self.assertEqual(solution.countVisitedNodes(edges), [6, 5, 5, 4, 3])", "def test_countVisitedNodes(self):\n    solution = Solution()\n    edges = [0, 1, 2, 3]\n    edges[2] = 3\n    self.assertEqual(solution.countVisitedNodes(edges), [5, 4, 4, 2])"]}
{"task_num": 2901, "task_title": "Longest Unequal Adjacent Groups Subsequence II", "func_name": "getWordsInLongestSubsequence", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def getWordsInLongestSubsequence(self, words: List[str], groups: List[int]) -> List[str]:\n    ans = []\n    n=len(words)\n    dp = [1] * n\n    prev = [-1] * n\n\n    for i in range(1, n):\n      for j in range(i):\n        if groups[i] == groups[j]:\n          continue\n        if len(words[i]) != len(words[j]):\n          continue\n        if sum(a != b for a, b in zip(words[i], words[j])) != 1:\n          continue\n        if dp[i] < dp[j] + 1:\n          dp[i] = dp[j] + 1\n          prev[i] = j\n\n    index = dp.index(max(dp))\n    while index != -1:\n      ans.append(words[index])\n      index = prev[index]\n\n    return ans[::-1]\n", "tests": ["def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = ['abc', 'bcd', 'acef', 'xyz', 'az', 'ba', 'a']\n    groups = [1, 2, 3, 4, 2, 0, 2]\n    assert solution.getWordsInLongestSubsequence(words, groups) == ['acef', 'xyz']", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = ['ab', 'a']\n    groups = [1, 0]\n    assert solution.getWordsInLongestSubsequence(words, groups) == ['ab']", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = ['a', 'b']\n    groups = [1, 0]\n    assert solution.getWordsInLongestSubsequence(words, groups) == []", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = ['aa', 'bb']\n    groups = [1, 0]\n    assert solution.getWordsInLongestSubsequence(words, groups) == ['aa', 'bb']", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = ['abc', 'abc']\n    groups = [1, 0]\n    assert solution.getWordsInLongestSubsequence(words, groups) == ['abc']", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = ['a', 'a']\n    groups = [0, 0]\n    assert solution.getWordsInLongestSubsequence(words, groups) == ['a']", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = ['ab', 'cd']\n    groups = [0, 1]\n    assert solution.getWordsInLongestSubsequence(words, groups) == ['ab', 'cd']", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = ['ab', 'cd']\n    groups = [0, 1]\n    assert solution.getWordsInLongestSubsequence(words, groups) == ['ab', 'cd']", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = ['aba', 'cdc', 'e']\n    groups = [1, 0, 2]\n    assert solution.getWordsInLongestSubsequence(words, groups) == ['e']", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = ['abc', 'bca', 'cab']\n    groups = [1, 2, 0]\n    assert solution.getWordsInLongestSubsequence(words, groups) == ['abc', 'bca']", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = ['abc', 'bca']\n    groups = [0, 1]\n    assert solution.getWordsInLongestSubsequence(words, groups) == ['abc', 'bca']", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = ['a', 'aa', 'aaa']\n    groups = [1, 0, 2]\n    assert solution.getWordsInLongestSubsequence(words, groups) == ['aaa']", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = ['abc', 'bca', 'cab']\n    groups = [0, 2, 1]\n    assert solution.getWordsInLongestSubsequence(words, groups) == ['cab', 'bca']", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = ['a', 'ab', 'abc']\n    groups = [1, 0, 2]\n    assert solution.getWordsInLongestSubsequence(words, groups) == ['abc']", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = ['a', 'aa', 'aaa']\n    groups = [0, 1, 2]\n    assert solution.getWordsInLongestSubsequence(words, groups) == ['aaa']", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = ['abc', 'cde', 'efg']\n    groups = [0, 1, 2]\n    assert solution.getWordsInLongestSubsequence(words, groups) == ['efg']", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = ['abc', 'def', 'ghi']\n    groups = [0, 1, 2]\n    assert solution.getWordsInLongestSubsequence(words, groups) == ['ghi']", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = ['abc', 'def', 'ghi']\n    groups = [0, 2, 1]\n    assert solution.getWordsInLongestSubsequence(words, groups) == ['ghi', 'def']", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = ['a', 'b', 'c']\n    groups = [1, 2, 3]\n    assert solution.getWordsInLongestSubsequence(words, groups) == ['c']", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = ['a', 'ab', 'abc']\n    groups = [1, 0, 2]\n    assert solution.getWordsInLongestSubsequence(words, groups) == ['abc']"]}
{"task_num": 2904, "task_title": "Shortest and Lexicographically Smallest Beautiful String", "func_name": "shortestBeautifulSubstring", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def shortestBeautifulSubstring(self, s: str, k: int) -> str:\n    bestLeft = -1\n    minLength = len(s) + 1\n    ones = 0\n\n    l = 0\n    for r, c in enumerate(s):\n      if c == '1':\n        ones += 1\n      while ones == k:\n        if r - l + 1 < minLength:\n          bestLeft = l\n          minLength = r - l + 1\n        elif r - l + 1 == minLength and s[l:l + minLength] < s[bestLeft:bestLeft + minLength]:\n          bestLeft = l\n        if s[l] == '1':\n          ones -= 1\n        l += 1\n\n    if bestLeft == -1:\n      return \"\"\n    else:\n      return s[bestLeft:bestLeft + minLength]\n", "tests": ["def test_shortestBeautifulSubstring(self):\n    s = '110010'\n    k = 2\n    result = '11'\n    self.assertEqual(solution.shortestBeautifulSubstring(s, k), result)", "def test_shortestBeautifulSubstring(self):\n    s = '1111'\n    k = 5\n    result = ''\n    self.assertEqual(solution.shortestBeautifulSubstring(s, k), result)", "def test_shortestBeautifulSubstring(self):\n    s = '0000'\n    k = 1\n    result = ''\n    self.assertEqual(solution.shortestBeautifulSubstring(s, k), result)", "def test_shortestBeautifulSubstring(self):\n    s = '100001'\n    k = 5\n    result = ''\n    self.assertEqual(solution.shortestBeautifulSubstring(s, k), result)", "def test_shortestBeautifulSubstring(self):\n    s = '100001'\n    k = 3\n    result = ''\n    self.assertEqual(solution.shortestBeautifulSubstring(s, k), result)", "def test_shortestBeautifulSubstring(self):\n    s = '111'\n    k = len(s)\n    result = ''\n    self.assertEqual(solution.shortestBeautifulSubstring(s, k), result)", "def test_shortestBeautifulSubstring(self):\n    s = '11'\n    k = len(s) + 1\n    result = ''\n    self.assertEqual(solution.shortestBeautifulSubstring(s, k), result)", "def test_shortestBeautifulSubstring(self):\n    s = '11110000'\n    k = len(s) // 2\n    result = ''\n    self.assertEqual(solution.shortestBeautifulSubstring(s, k), result)", "def test_shortestBeautifulSubstring(self):\n    s = '10101110'\n    k = len(s) // 2\n    result = ''\n    self.assertEqual(solution.shortestBeautifulSubstring(s, k), result)", "def test_shortestBeautifulSubstring(self):\n    s = '1010111000'\n    k = len(s) // 2\n    result = ''\n    self.assertEqual(solution.shortestBeautifulSubstring(s, k), result)", "def test_shortestBeautifulSubstring(self):\n    s = '101011100010'\n    k = len(s) // 2\n    result = ''\n    self.assertEqual(solution.shortestBeautifulSubstring(s, k), result)", "def test_shortestBeautifulSubstring(self):\n    s = '11101100'\n    k = len(s) // 2\n    result = '11'\n    self.assertEqual(solution.shortestBeautifulSubstring(s, k), result)", "def test_shortestBeautifulSubstring(self):\n    s = '11001101'\n    k = len(s) + 1\n    result = ''\n    self.assertEqual(solution.shortestBeautifulSubstring(s, k), result)", "def test_shortestBeautifulSubstring(self):\n    s = '10101010'\n    k = len(s) // 2\n    result = ''\n    self.assertEqual(solution.shortestBeautifulSubstring(s, k), result)", "def test_shortestBeautifulSubstring(self):\n    s = '10101010010'\n    k = len(s) // 2\n    result = ''\n    self.assertEqual(solution.shortestBeautifulSubstring(s, k), result)", "def test_shortestBeautifulSubstring(self):\n    s = '11110101010'\n    k = len(s) // 2\n    result = ''\n    self.assertEqual(solution.shortestBeautifulSubstring(s, k), result)", "def test_shortestBeautifulSubstring(self):\n    s = '10101011010'\n    k = len(s) // 2\n    result = ''\n    self.assertEqual(solution.shortestBeautifulSubstring(s, k), result)", "def test_shortestBeautifulSubstring(self):\n    s = '11110101011010'\n    k = len(s) // 2\n    result = ''\n    self.assertEqual(solution.shortestBeautifulSubstring(s, k), result)", "def test_shortestBeautifulSubstring(self):\n    s = '00010101010'\n    k = len(s) // 2\n    result = ''\n    self.assertEqual(solution.shortestBeautifulSubstring(s, k), result)", "def test_shortestBeautifulSubstring(self):\n    s = '10101010000'\n    k = len(s) // 2\n    result = ''\n    self.assertEqual(solution.shortestBeautifulSubstring(s, k), result)"]}
{"task_num": 2911, "task_title": "Minimum Changes to Make K Semi-palindromes", "func_name": "minimumChanges", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumChanges(self, s: str, k: int) -> int:\n    n = len(s)\n    factors = self._getFactors(n)\n    cost = self._getCost(s, n, factors)\n    dp = [[n] * (k + 1) for _ in range(n + 1)]\n\n    dp[n][0] = 0\n\n    for i in range(n - 1, -1, -1):\n      for j in range(1, k + 1):\n        for l in range(i + 1, n):\n          dp[i][j] = min(dp[i][j], dp[l + 1][j - 1] + cost[i][l])\n\n    return dp[0][k]\n\n  def _getFactors(self, n: int) -> List[List[int]]:\n    factors = [[1] for _ in range(n + 1)]\n    for d in range(2, n):\n      for i in range(d * 2, n + 1, d):\n        factors[i].append(d)\n    return factors\n\n  def _getCost(self, s: str, n: int, factors: List[List[int]]) -> List[List[int]]:\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n      for j in range(i + 1, n):\n        length = j - i + 1\n        minCost = length\n        for d in factors[length]:\n          minCost = min(minCost, self._getCostD(s, i, j, d))\n        cost[i][j] = minCost\n    return cost\n\n  def _getCostD(self, s: str, i: int, j: int, d: int) -> int:\n    cost = 0\n    for offset in range(d):\n      l = i + offset\n      r = j - d + 1 + offset\n      while l < r:\n        if s[l] != s[r]:\n          cost += 1\n        l += d\n        r -= d\n    return cost\n", "tests": ["def test_minimumChanges(self):\n    solution = Solution()\n    s = 'abcabc'\n    k = 2\n    self.assertEqual(solution.minimumChanges(s, k), 2)", "def test_minimumChanges(self):\n    solution = Solution()\n    s = 'abccba'\n    k = 1\n    self.assertEqual(solution.minimumChanges(s, k), 0)", "def test_minimumChanges(self):\n    solution = Solution()\n    s = 'aab'\n    k = 2\n    self.assertEqual(solution.minimumChanges(s, k), 1)", "def test_minimumChanges(self):\n    solution = Solution()\n    s = 'aaaa'\n    k = 1\n    self.assertEqual(solution.minimumChanges(s, k), 0)", "def test_minimumChanges(self):\n    solution = Solution()\n    s = 'abcdef'\n    k = 2\n    self.assertEqual(solution.minimumChanges(s, k), 3)", "def test_minimumChanges(self):\n    solution = Solution()\n    s = 'abab'\n    k = 2\n    self.assertEqual(solution.minimumChanges(s, k), 0)", "def test_minimumChanges(self):\n    solution = Solution()\n    s = ''\n    k = 1\n    self.assertEqual(solution.minimumChanges(s, k), 0)", "def test_minimumChanges(self):\n    solution = Solution()\n    s = 'abc'\n    k = 1\n    self.assertEqual(solution.minimumChanges(s, k), 3)", "def test_minimumChanges(self):\n    solution = Solution()\n    s = 'aaa'\n    k = 3\n    self.assertEqual(solution.minimumChanges(s, k), 0)", "def test_minimumChanges(self):\n    solution = Solution()\n    s = 'abcdefg'\n    k = 1\n    self.assertEqual(solution.minimumChanges(s, k), 7)", "def test_minimumChanges(self):\n    solution = Solution()\n    s = 'abcdefg'\n    k = 3\n    self.assertEqual(solution.minimumChanges(s, k), 7)", "def test_minimumChanges(self):\n    solution = Solution()\n    s = 'a'\n    k = 1\n    self.assertEqual(solution.minimumChanges(s, k), 0)", "def test_minimumChanges(self):\n    solution = Solution()\n    s = 'abcdefghij'\n    k = 5\n    self.assertEqual(solution.minimumChanges(s, k), 9)", "def test_minimumChanges(self):\n    solution = Solution()\n    s = 'abcdefg'\n    k = 0\n    with self.assertRaises(ValueError):\n        solution.minimumChanges(s, k)", "def test_minimumChanges(self):\n    solution = Solution()\n    s = 'abcdefg'\n    k = -1\n    with self.assertRaises(ValueError):\n        solution.minimumChanges(s, k)", "def test_minimumChanges(self):\n    solution = Solution()\n    s = 'abcdefg'\n    k = float('inf')\n    with self.assertRaises(ValueError):\n        solution.minimumChanges(s, k)", "def test_minimumChanges(self):\n    solution = Solution()\n    s = 'abcdefg'\n    k = float('-inf')\n    with self.assertRaises(ValueError):\n        solution.minimumChanges(s, k)", "def test_minimumChanges(self):\n    solution = Solution()\n    s = 'abcdefg'\n    k = 'a'\n    with self.assertRaises(TypeError):\n        solution.minimumChanges(s, k)", "def test_minimumChanges(self):\n    solution = Solution()\n    s = 'a'\n    k = 1000000\n    self.assertLessEqual(solution.minimumChanges(s, k), 1)", "def test_minimumChanges(self):\n    solution = Solution()\n    s = 'a' * 1000000\n    k = 10000\n    self.assertLessEqual(solution.minimumChanges(s, k), 999999)"]}
{"task_num": 2932, "task_title": "Maximum Strong Pair XOR I", "func_name": "maximumStrongPairXor", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Optional\n\nclass TrieNode:\n  def __init__(self):\n    self.children: List[Optional[TrieNode]] = [None] * 2\n    self.min = math.inf\n    self.max = -math.inf\n\n\nclass BitTrie:\n  def __init__(self, maxBit: int):\n    self.maxBit = maxBit\n    self.root = TrieNode()\n\n  def insert(self, num: int) -> None:\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n      node.min = min(node.min, num)\n      node.max = max(node.max, num)\n\n  def getMaxXor(self, x: int) -> int:\n    maxXor = 0\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = x >> i & 1\n      toggleBit = bit ^ 1\n      if node.children[toggleBit] and node.children[toggleBit].max > x and node.children[toggleBit].min <= 2 * x:\n        maxXor = maxXor | 1 << i\n        node = node.children[toggleBit]\n      elif node.children[bit]:\n        node = node.children[bit]\n      else:\n        return 0\n    return maxXor\n\n\nclass Solution:\n  def maximumStrongPairXor(self, nums: List[int]) -> int:\n    maxNum = max(nums)\n    maxBit = int(math.log2(maxNum))\n    bitTrie = BitTrie(maxBit)\n\n    for num in nums:\n      bitTrie.insert(num)\n\n    return max(bitTrie.getMaxXor(num) for num in nums)\n", "tests": ["def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [13, 25, 49]\n    assert solution.maximumStrongPairXor(nums) == 15", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [1, 3, 5]\n    assert solution.maximumStrongPairXor(nums) == 2", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [7, 14, 24]\n    assert solution.maximumStrongPairXor(nums) == 8", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [0]\n    assert solution.maximumStrongPairXor(nums) == 0", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [2147483647]\n    assert solution.maximumStrongPairXor(nums) == 0", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [2 ** 20 - 1]\n    assert solution.maximumStrongPairXor(nums) == 1 << 19", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [2 ** 30 - 1]\n    assert solution.maximumStrongPairXor(nums) == 1 << 29", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [10, 20, 30, 40]\n    assert solution.maximumStrongPairXor(nums) == 12", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [1, 3, 5, 7]\n    assert solution.maximumStrongPairXor(nums) == 2", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [10 ** 7]\n    assert solution.maximumStrongPairXor(nums) == 0", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [2 ** 31 - 1, 0]\n    assert solution.maximumStrongPairXor(nums) == 1 << 30", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [2 ** 20 - 1, 0]\n    assert solution.maximumStrongPairXor(nums) == 1 << 19", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [0, 2 ** 20 - 1]\n    assert solution.maximumStrongPairXor(nums) == 1 << 19", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [2147483647, 2147483648]\n    assert solution.maximumStrongPairXor(nums) == 1 << 31", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [2 ** 32 - 1]\n    assert solution.maximumStrongPairXor(nums) == 1 << 31", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [0, 1]\n    assert solution.maximumStrongPairXor(nums) == 2", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [2 ** 31 - 1, 2147483647]\n    assert solution.maximumStrongPairXor(nums) == 1 << 30", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [0, 0]\n    assert solution.maximumStrongPairXor(nums) == 0", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [2 ** 30 - 1, 2 ** 31 - 1]\n    assert solution.maximumStrongPairXor(nums) == 1 << 29", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [0, 2 ** 30 - 1, 2 ** 31 - 1]\n    assert solution.maximumStrongPairXor(nums) == 1 << 29"]}
{"task_num": 2940, "task_title": "Find Building Where Alice and Bob Can Meet", "func_name": "leftmostBuildingQueries", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, a: int, b: int):\n    self.queryIndex = queryIndex\n    self.a = a\n    self.b = b\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.a\n    yield self.b\n\n\nclass Solution:\n  def leftmostBuildingQueries(self, heights: List[int], queries: List[List[int]]) -> List[int]:\n    ans = [-1] * len(queries)\n    stack = []\n\n    heightsIndex = len(heights) - 1\n    for queryIndex, a, b in sorted([IndexedQuery(i, min(a, b), max(a, b)) for i, (a, b) in enumerate(queries)], key=lambda iq: -iq.b):\n      if a == b or heights[a] < heights[b]:\n        ans[queryIndex] = b\n      else:\n        while heightsIndex > b:\n          while stack and heights[stack[-1]] <= heights[heightsIndex]:\n            stack.pop()\n          stack.append(heightsIndex)\n          heightsIndex -= 1\n        j = self._lastGreater(stack, a, heights)\n        if j != -1:\n          ans[queryIndex] = stack[j]\n\n    return ans\n\n  def _lastGreater(self, A: List[int], target: int, heights: List[int]):\n    l = -1\n    r = len(A) - 1\n    while l < r:\n      m = (l + r + 1) // 2\n      if heights[A[m]] > heights[target]:\n        l = m\n      else:\n        r = m - 1\n    return l\n", "tests": ["def test_leftmostBuildingQueries():\n\n    class Solution:\n\n        def leftmostBuildingQueries(self, heights: List[int], queries: List[List[int]]) -> List[int]:\n            ans = [-1] * len(queries)\n            stack = []\n            heightsIndex = len(heights) - 1\n            for (queryIndex, a, b) in sorted([IndexedQuery(i, min(a, b), max(a, b)) for (i, (a, b)) in enumerate(queries)], key=lambda iq: -iq.b):\n                if a == b or heights[a] < heights[b]:\n                    ans[queryIndex] = b\n                else:\n                    while heightsIndex > b:\n                        while stack and heights[stack[-1]] <= heights[heightsIndex]:\n                            stack.pop()\n                        stack.append(heightsIndex)\n                        heightsIndex -= 1\n                    j = self._lastGreater(stack, a, heights)\n                    if j != -1:\n                        ans[queryIndex] = stack[j]\n            return ans\n\n        def _lastGreater(self, A: List[int], target: int, heights: List[int]):\n            l = -1\n            r = len(A) - 1\n            while l < r:\n                m = (l + r + 1) // 2\n                if heights[A[m]] > heights[target]:\n                    l = m\n                else:\n                    r = m - 1\n            return l\n    solution = Solution()\n    heights = [15, 14, 10, 12, 9, 11, 8, 5]\n    queries = [[4, 3], [0, 2], [1, 3]]\n    assert solution.leftmostBuildingQueries(heights, queries) == [3, -1, -1]", "def test_leftmostBuildingQueries():\n\n    class Solution:\n\n        def leftmostBuildingQueries(self, heights: List[int], queries: List[List[int]]) -> List[int]:\n            ans = [-1] * len(queries)\n            stack = []\n            heightsIndex = len(heights) - 1\n            for (queryIndex, a, b) in sorted([IndexedQuery(i, min(a, b), max(a, b)) for (i, (a, b)) in enumerate(queries)], key=lambda iq: -iq.b):\n                if a == b or heights[a] < heights[b]:\n                    ans[queryIndex] = b\n                else:\n                    while heightsIndex > b:\n                        while stack and heights[stack[-1]] <= heights[heightsIndex]:\n                            stack.pop()\n                        stack.append(heightsIndex)\n                        heightsIndex -= 1\n                    j = self._lastGreater(stack, a, heights)\n                    if j != -1:\n                        ans[queryIndex] = stack[j]\n            return ans\n\n        def _lastGreater(self, A: List[int], target: int, heights: List[int]):\n            l = -1\n            r = len(A) - 1\n            while l < r:\n                m = (l + r + 1) // 2\n                if heights[A[m]] > heights[target]:\n                    l = m\n                else:\n                    r = m - 1\n            return l\n    solution = Solution()\n    heights = [10, 8, 9]\n    queries = [[0, 1], [1, 2]]\n    assert solution.leftmostBuildingQueries(heights, queries) == [-1]", "def test_leftmostBuildingQueries():\n\n    class Solution:\n\n        def leftmostBuildingQueries(self, heights: List[int], queries: List[List[int]]) -> List[int]:\n            ans = [-1] * len(queries)\n            stack = []\n            heightsIndex = len(heights) - 1\n            for (queryIndex, a, b) in sorted([IndexedQuery(i, min(a, b), max(a, b)) for (i, (a, b)) in enumerate(queries)], key=lambda iq: -iq.b):\n                if a == b or heights[a] < heights[b]:\n                    ans[queryIndex] = b\n                else:\n                    while heightsIndex > b:\n                        while stack and heights[stack[-1]] <= heights[heightsIndex]:\n                            stack.pop()\n                        stack.append(heightsIndex)\n                        heightsIndex -= 1\n                    j = self._lastGreater(stack, a, heights)\n                    if j != -1:\n                        ans[queryIndex] = stack[j]\n            return ans\n\n        def _lastGreater(self, A: List[int], target: int, heights: List[int]):\n            l = -1\n            r = len(A) - 1\n            while l < r:\n                m = (l + r + 1) // 2\n                if heights[A[m]] > heights[target]:\n                    l = m\n                else:\n                    r = m - 1\n            return l\n    solution = Solution()\n    heights = [3, 4, 5, 6]\n    queries = [[0, 2], [0, 3]]\n    assert solution.leftmostBuildingQueries(heights, queries) == [-1]", "def test_leftmostBuildingQueries():\n\n    class Solution:\n\n        def leftmostBuildingQueries(self, heights: List[int], queries: List[List[int]]) -> List[int]:\n            ans = [-1] * len(queries)\n            stack = []\n            heightsIndex = len(heights) - 1\n            for (queryIndex, a, b) in sorted([IndexedQuery(i, min(a, b), max(a, b)) for (i, (a, b)) in enumerate(queries)], key=lambda iq: -iq.b):\n                if a == b or heights[a] < heights[b]:\n                    ans[queryIndex] = b\n                else:\n                    while heightsIndex > b:\n                        while stack and heights[stack[-1]] <= heights[heightsIndex]:\n                            stack.pop()\n                        stack.append(heightsIndex)\n                        heightsIndex -= 1\n                    j = self._lastGreater(stack, a, heights)\n                    if j != -1:\n                        ans[queryIndex] = stack[j]\n            return ans\n\n        def _lastGreater(self, A: List[int], target: int, heights: List[int]):\n            l = -1\n            r = len(A) - 1\n            while l < r:\n                m = (l + r + 1) // 2\n                if heights[A[m]] > heights[target]:\n                    l = m\n                else:\n                    r = m - 1\n            return l\n    solution = Solution()\n    heights = [5, 4, 3]\n    queries = [[0, 1], [1, 2]]\n    assert solution.leftmostBuildingQueries(heights, queries) == [1]", "def test_leftmostBuildingQueries():\n\n    class Solution:\n\n        def leftmostBuildingQueries(self, heights: List[int], queries: List[List[int]]) -> List[int]:\n            ans = [-1] * len(queries)\n            stack = []\n            heightsIndex = len(heights) - 1\n            for (queryIndex, a, b) in sorted([IndexedQuery(i, min(a, b), max(a, b)) for (i, (a, b)) in enumerate(queries)], key=lambda iq: -iq.b):\n                if a == b or heights[a] < heights[b]:\n                    ans[queryIndex] = b\n                else:\n                    while heightsIndex > b:\n                        while stack and heights[stack[-1]] <= heights[heightsIndex]:\n                            stack.pop()\n                        stack.append(heightsIndex)\n                        heightsIndex -= 1\n                    j = self._lastGreater(stack, a, heights)\n                    if j != -1:\n                        ans[queryIndex] = stack[j]\n            return ans\n\n        def _lastGreater(self, A: List[int], target: int, heights: List[int]):\n            l = -1\n            r = len(A) - 1\n            while l < r:\n                m = (l + r + 1) // 2\n                if heights[A[m]] > heights[target]:\n                    l = m\n                else:\n                    r = m - 1\n            return l\n    solution = Solution()\n    heights = [10, 15, 8, 12, 9]\n    queries = [[0, 3], [4, 2]]\n    assert solution.leftmostBuildingQueries(heights, queries) == [3, -1]", "def test_leftmostBuildingQueries():\n\n    class Solution:\n\n        def leftmostBuildingQueries(self, heights: List[int], queries: List[List[int]]) -> List[int]:\n            ans = [-1] * len(queries)\n            stack = []\n            heightsIndex = len(heights) - 1\n            for (queryIndex, a, b) in sorted([IndexedQuery(i, min(a, b), max(a, b)) for (i, (a, b)) in enumerate(queries)], key=lambda iq: -iq.b):\n                if a == b or heights[a] < heights[b]:\n                    ans[queryIndex] = b\n                else:\n                    while heightsIndex > b:\n                        while stack and heights[stack[-1]] <= heights[heightsIndex]:\n                            stack.pop()\n                        stack.append(heightsIndex)\n                        heightsIndex -= 1\n                    j = self._lastGreater(stack, a, heights)\n                    if j != -1:\n                        ans[queryIndex] = stack[j]\n            return ans\n\n        def _lastGreater(self, A: List[int], target: int, heights: List[int]):\n            l = -1\n            r = len(A) - 1\n            while l < r:\n                m = (l + r + 1) // 2\n                if heights[A[m]] > heights[target]:\n                    l = m\n                else:\n                    r = m - 1\n            return l\n    solution = Solution()\n    heights = [3, 4, 5]\n    queries = [[0, 2], [1, 2]]\n    assert solution.leftmostBuildingQueries(heights, queries) == [-1]", "def test_leftmostBuildingQueries():\n\n    class Solution:\n\n        def leftmostBuildingQueries(self, heights: List[int], queries: List[List[int]]) -> List[int]:\n            ans = [-1] * len(queries)\n            stack = []\n            heightsIndex = len(heights) - 1\n            for (queryIndex, a, b) in sorted([IndexedQuery(i, min(a, b), max(a, b)) for (i, (a, b)) in enumerate(queries)], key=lambda iq: -iq.b):\n                if a == b or heights[a] < heights[b]:\n                    ans[queryIndex] = b\n                else:\n                    while heightsIndex > b:\n                        while stack and heights[stack[-1]] <= heights[heightsIndex]:\n                            stack.pop()\n                        stack.append(heightsIndex)\n                        heightsIndex -= 1\n                    j = self._lastGreater(stack, a, heights)\n                    if j != -1:\n                        ans[queryIndex] = stack[j]\n            return ans\n\n        def _lastGreater(self, A: List[int], target: int, heights: List[int]):\n            l = -1\n            r = len(A) - 1\n            while l < r:\n                m = (l + r + 1) // 2\n                if heights[A[m]] > heights[target]:\n                    l = m\n                else:\n                    r = m - 1\n            return l\n    solution = Solution()\n    heights = [10, 15]\n    queries = [[0, 0], [1, 1]]\n    assert solution.leftmostBuildingQueries(heights, queries) == [-1, -1]", "def test_leftmostBuildingQueries():\n\n    class Solution:\n\n        def leftmostBuildingQueries(self, heights: List[int], queries: List[List[int]]) -> List[int]:\n            ans = [-1] * len(queries)\n            stack = []\n            heightsIndex = len(heights) - 1\n            for (queryIndex, a, b) in sorted([IndexedQuery(i, min(a, b), max(a, b)) for (i, (a, b)) in enumerate(queries)], key=lambda iq: -iq.b):\n                if a == b or heights[a] < heights[b]:\n                    ans[queryIndex] = b\n                else:\n                    while heightsIndex > b:\n                        while stack and heights[stack[-1]] <= heights[heightsIndex]:\n                            stack.pop()\n                        stack.append(heightsIndex)\n                        heightsIndex -= 1\n                    j = self._lastGreater(stack, a, heights)\n                    if j != -1:\n                        ans[queryIndex] = stack[j]\n            return ans\n\n        def _lastGreater(self, A: List[int], target: int, heights: List[int]):\n            l = -1\n            r = len(A) - 1\n            while l < r:\n                m = (l + r + 1) // 2\n                if heights[A[m]] > heights[target]:\n                    l = m\n                else:\n                    r = m - 1\n            return l\n    solution = Solution()\n    heights = [5, 6, 7]\n    queries = [[0, 1], [1, 2]]\n    assert solution.leftmostBuildingQueries(heights, queries) == [1, -1]", "def test_leftmostBuildingQueries():\n\n    class Solution:\n\n        def leftmostBuildingQueries(self, heights: List[int], queries: List[List[int]]) -> List[int]:\n            ans = [-1] * len(queries)\n            stack = []\n            heightsIndex = len(heights) - 1\n            for (queryIndex, a, b) in sorted([IndexedQuery(i, min(a, b), max(a, b)) for (i, (a, b)) in enumerate(queries)], key=lambda iq: -iq.b):\n                if a == b or heights[a] < heights[b]:\n                    ans[queryIndex] = b\n                else:\n                    while heightsIndex > b:\n                        while stack and heights[stack[-1]] <= heights[heightsIndex]:\n                            stack.pop()\n                        stack.append(heightsIndex)\n                        heightsIndex -= 1\n                    j = self._lastGreater(stack, a, heights)\n                    if j != -1:\n                        ans[queryIndex] = stack[j]\n            return ans\n\n        def _lastGreater(self, A: List[int], target: int, heights: List[int]):\n            l = -1\n            r = len(A) - 1\n            while l < r:\n                m = (l + r + 1) // 2\n                if heights[A[m]] > heights[target]:\n                    l = m\n                else:\n                    r = m - 1\n            return l\n    solution = Solution()\n    heights = [10, 8, 9, 12]\n    queries = [[0, 3], [4, 1]]\n    assert solution.leftmostBuildingQueries(heights, queries) == [3, -1]", "def test_leftmostBuildingQueries():\n\n    class Solution:\n\n        def leftmostBuildingQueries(self, heights: List[int], queries: List[List[int]]) -> List[int]:\n            ans = [-1] * len(queries)\n            stack = []\n            heightsIndex = len(heights) - 1\n            for (queryIndex, a, b) in sorted([IndexedQuery(i, min(a, b), max(a, b)) for (i, (a, b)) in enumerate(queries)], key=lambda iq: -iq.b):\n                if a == b or heights[a] < heights[b]:\n                    ans[queryIndex] = b\n                else:\n                    while heightsIndex > b:\n                        while stack and heights[stack[-1]] <= heights[heightsIndex]:\n                            stack.pop()\n                        stack.append(heightsIndex)\n                        heightsIndex -= 1\n                    j = self._lastGreater(stack, a, heights)\n                    if j != -1:\n                        ans[queryIndex] = stack[j]\n            return ans\n\n        def _lastGreater(self, A: List[int], target: int, heights: List[int]):\n            l = -1\n            r = len(A) - 1\n            while l < r:\n                m = (l + r + 1) // 2\n                if heights[A[m]] > heights[target]:\n                    l = m\n                else:\n                    r = m - 1\n            return l\n    solution = Solution()\n    heights = [5, 4, 3, 2]\n    queries = [[0, 3], [1, 2]]\n    assert solution.leftmostBuildingQueries(heights, queries) == [3, -1]", "def test_leftmostBuildingQueries():\n\n    class Solution:\n\n        def leftmostBuildingQueries(self, heights: List[int], queries: List[List[int]]) -> List[int]:\n            ans = [-1] * len(queries)\n            stack = []\n            heightsIndex = len(heights) - 1\n            for (queryIndex, a, b) in sorted([IndexedQuery(i, min(a, b), max(a, b)) for (i, (a, b)) in enumerate(queries)], key=lambda iq: -iq.b):\n                if a == b or heights[a] < heights[b]:\n                    ans[queryIndex] = b\n                else:\n                    while heightsIndex > b:\n                        while stack and heights[stack[-1]] <= heights[heightsIndex]:\n                            stack.pop()\n                        stack.append(heightsIndex)\n                        heightsIndex -= 1\n                    j = self._lastGreater(stack, a, heights)\n                    if j != -1:\n                        ans[queryIndex] = stack[j]\n            return ans\n\n        def _lastGreater(self, A: List[int], target: int, heights: List[int]):\n            l = -1\n            r = len(A) - 1\n            while l < r:\n                m = (l + r + 1) // 2\n                if heights[A[m]] > heights[target]:\n                    l = m\n                else:\n                    r = m - 1\n            return l\n    solution = Solution()\n    heights = [10, 15, 8, 12, 9]\n    queries = [[0, 4], [3, 2]]\n    assert solution.leftmostBuildingQueries(heights, queries) == [4, -1]", "def test_leftmostBuildingQueries():\n\n    class Solution:\n\n        def leftmostBuildingQueries(self, heights: List[int], queries: List[List[int]]) -> List[int]:\n            ans = [-1] * len(queries)\n            stack = []\n            heightsIndex = len(heights) - 1\n            for (queryIndex, a, b) in sorted([IndexedQuery(i, min(a, b), max(a, b)) for (i, (a, b)) in enumerate(queries)], key=lambda iq: -iq.b):\n                if a == b or heights[a] < heights[b]:\n                    ans[queryIndex] = b\n                else:\n                    while heightsIndex > b:\n                        while stack and heights[stack[-1]] <= heights[heightsIndex]:\n                            stack.pop()\n                        stack.append(heightsIndex)\n                        heightsIndex -= 1\n                    j = self._lastGreater(stack, a, heights)\n                    if j != -1:\n                        ans[queryIndex] = stack[j]\n            return ans\n\n        def _lastGreater(self, A: List[int], target: int, heights: List[int]):\n            l = -1\n            r = len(A) - 1\n            while l < r:\n                m = (l + r + 1) // 2\n                if heights[A[m]] > heights[target]:\n                    l = m\n                else:\n                    r = m - 1\n            return l\n    solution = Solution()\n    heights = [5, 4, 3, 6]\n    queries = [[0, 3], [1, 3]]\n    assert solution.leftmostBuildingQueries(heights, queries) == [3, -1]", "def test_leftmostBuildingQueries():\n\n    class Solution:\n\n        def leftmostBuildingQueries(self, heights: List[int], queries: List[List[int]]) -> List[int]:\n            ans = [-1] * len(queries)\n            stack = []\n            heightsIndex = len(heights) - 1\n            for (queryIndex, a, b) in sorted([IndexedQuery(i, min(a, b), max(a, b)) for (i, (a, b)) in enumerate(queries)], key=lambda iq: -iq.b):\n                if a == b or heights[a] < heights[b]:\n                    ans[queryIndex] = b\n                else:\n                    while heightsIndex > b:\n                        while stack and heights[stack[-1]] <= heights[heightsIndex]:\n                            stack.pop()\n                        stack.append(heightsIndex)\n                        heightsIndex -= 1\n                    j = self._lastGreater(stack, a, heights)\n                    if j != -1:\n                        ans[queryIndex] = stack[j]\n            return ans\n\n        def _lastGreater(self, A: List[int], target: int, heights: List[int]):\n            l = -1\n            r = len(A) - 1\n            while l < r:\n                m = (l + r + 1) // 2\n                if heights[A[m]] > heights[target]:\n                    l = m\n                else:\n                    r = m - 1\n            return l\n    solution = Solution()\n    heights = [10, 8, 9, 12]\n    queries = [[0, 3], [4, 1]]\n    assert solution.leftmostBuildingQueries(heights, queries) == [3, -1]", "def test_leftmostBuildingQueries():\n\n    class Solution:\n\n        def leftmostBuildingQueries(self, heights: List[int], queries: List[List[int]]) -> List[int]:\n            ans = [-1] * len(queries)\n            stack = []\n            heightsIndex = len(heights) - 1\n            for (queryIndex, a, b) in sorted([IndexedQuery(i, min(a, b), max(a, b)) for (i, (a, b)) in enumerate(queries)], key=lambda iq: -iq.b):\n                if a == b or heights[a] < heights[b]:\n                    ans[queryIndex] = b\n                else:\n                    while heightsIndex > b:\n                        while stack and heights[stack[-1]] <= heights[heightsIndex]:\n                            stack.pop()\n                        stack.append(heightsIndex)\n                        heightsIndex -= 1\n                    j = self._lastGreater(stack, a, heights)\n                    if j != -1:\n                        ans[queryIndex] = stack[j]\n            return ans\n\n        def _lastGreater(self, A: List[int], target: int, heights: List[int]):\n            l = -1\n            r = len(A) - 1\n            while l < r:\n                m = (l + r + 1) // 2\n                if heights[A[m]] > heights[target]:\n                    l = m\n                else:\n                    r = m - 1\n            return l\n    solution = Solution()\n    heights = [5, 4, 3, 6, 7]\n    queries = [[0, 4], [1, 4]]\n    assert solution.leftmostBuildingQueries(heights, queries) == [4, -1]", "def test_leftmostBuildingQueries():\n\n    class Solution:\n\n        def leftmostBuildingQueries(self, heights: List[int], queries: List[List[int]]) -> List[int]:\n            ans = [-1] * len(queries)\n            stack = []\n            heightsIndex = len(heights) - 1\n            for (queryIndex, a, b) in sorted([IndexedQuery(i, min(a, b), max(a, b)) for (i, (a, b)) in enumerate(queries)], key=lambda iq: -iq.b):\n                if a == b or heights[a] < heights[b]:\n                    ans[queryIndex] = b\n                else:\n                    while heightsIndex > b:\n                        while stack and heights[stack[-1]] <= heights[heightsIndex]:\n                            stack.pop()\n                        stack.append(heightsIndex)\n                        heightsIndex -= 1\n                    j = self._lastGreater(stack, a, heights)\n                    if j != -1:\n                        ans[queryIndex] = stack[j]\n            return ans\n\n        def _lastGreater(self, A: List[int], target: int, heights: List[int]):\n            l = -1\n            r = len(A) - 1\n            while l < r:\n                m = (l + r + 1) // 2\n                if heights[A[m]] > heights[target]:\n                    l = m\n                else:\n                    r = m - 1\n            return l\n    solution = Solution()\n    heights = [5, 4, 3, 6, 7]\n    queries = [[0, 2], [3, 4]]\n    assert solution.leftmostBuildingQueries(heights, queries) == [2, -1]", "def test_leftmostBuildingQueries():\n\n    class Solution:\n\n        def leftmostBuildingQueries(self, heights: List[int], queries: List[List[int]]) -> List[int]:\n            ans = [-1] * len(queries)\n            stack = []\n            heightsIndex = len(heights) - 1\n            for (queryIndex, a, b) in sorted([IndexedQuery(i, min(a, b), max(a, b)) for (i, (a, b)) in enumerate(queries)], key=lambda iq: -iq.b):\n                if a == b or heights[a] < heights[b]:\n                    ans[queryIndex] = b\n                else:\n                    while heightsIndex > b:\n                        while stack and heights[stack[-1]] <= heights[heightsIndex]:\n                            stack.pop()\n                        stack.append(heightsIndex)\n                        heightsIndex -= 1\n                    j = self._lastGreater(stack, a, heights)\n                    if j != -1:\n                        ans[queryIndex] = stack[j]\n            return ans\n\n        def _lastGreater(self, A: List[int], target: int, heights: List[int]):\n            l = -1\n            r = len(A) - 1\n            while l < r:\n                m = (l + r + 1) // 2\n                if heights[A[m]] > heights[target]:\n                    l = m\n                else:\n                    r = m - 1\n            return l\n    solution = Solution()\n    heights = [3, 5, 7, 4]\n    queries = [[0, 2], [1, 3]]\n    assert solution.leftmostBuildingQueries(heights, queries) == [2, -1]", "def test_leftmostBuildingQueries():\n\n    class Solution:\n\n        def leftmostBuildingQueries(self, heights: List[int], queries: List[List[int]]) -> List[int]:\n            ans = [-1] * len(queries)\n            stack = []\n            heightsIndex = len(heights) - 1\n            for (queryIndex, a, b) in sorted([IndexedQuery(i, min(a, b), max(a, b)) for (i, (a, b)) in enumerate(queries)], key=lambda iq: -iq.b):\n                if a == b or heights[a] < heights[b]:\n                    ans[queryIndex] = b\n                else:\n                    while heightsIndex > b:\n                        while stack and heights[stack[-1]] <= heights[heightsIndex]:\n                            stack.pop()\n                        stack.append(heightsIndex)\n                        heightsIndex -= 1\n                    j = self._lastGreater(stack, a, heights)\n                    if j != -1:\n                        ans[queryIndex] = stack[j]\n            return ans\n\n        def _lastGreater(self, A: List[int], target: int, heights: List[int]):\n            l = -1\n            r = len(A) - 1\n            while l < r:\n                m = (l + r + 1) // 2\n                if heights[A[m]] > heights[target]:\n                    l = m\n                else:\n                    r = m - 1\n            return l\n    solution = Solution()\n    heights = [4, 3, 7, 5]\n    queries = [[0, 2], [3, 4]]\n    assert solution.leftmostBuildingQueries(heights, queries) == [2, -1]", "def test_leftmostBuildingQueries():\n\n    class Solution:\n\n        def leftmostBuildingQueries(self, heights: List[int], queries: List[List[int]]) -> List[int]:\n            ans = [-1] * len(queries)\n            stack = []\n            heightsIndex = len(heights) - 1\n            for (queryIndex, a, b) in sorted([IndexedQuery(i, min(a, b), max(a, b)) for (i, (a, b)) in enumerate(queries)], key=lambda iq: -iq.b):\n                if a == b or heights[a] < heights[b]:\n                    ans[queryIndex] = b\n                else:\n                    while heightsIndex > b:\n                        while stack and heights[stack[-1]] <= heights[heightsIndex]:\n                            stack.pop()\n                        stack.append(heightsIndex)\n                        heightsIndex -= 1\n                    j = self._lastGreater(stack, a, heights)\n                    if j != -1:\n                        ans[queryIndex] = stack[j]\n            return ans\n\n        def _lastGreater(self, A: List[int], target: int, heights: List[int]):\n            l = -1\n            r = len(A) - 1\n            while l < r:\n                m = (l + r + 1) // 2\n                if heights[A[m]] > heights[target]:\n                    l = m\n                else:\n                    r = m - 1\n            return l\n    solution = Solution()\n    heights = [7, 3, 5, 4]\n    queries = [[0, 3], [2, 4]]\n    assert solution.leftmostBuildingQueries(heights, queries) == [3, -1]", "def test_leftmostBuildingQueries():\n\n    class Solution:\n\n        def leftmostBuildingQueries(self, heights: List[int], queries: List[List[int]]) -> List[int]:\n            ans = [-1] * len(queries)\n            stack = []\n            heightsIndex = len(heights) - 1\n            for (queryIndex, a, b) in sorted([IndexedQuery(i, min(a, b), max(a, b)) for (i, (a, b)) in enumerate(queries)], key=lambda iq: -iq.b):\n                if a == b or heights[a] < heights[b]:\n                    ans[queryIndex] = b\n                else:\n                    while heightsIndex > b:\n                        while stack and heights[stack[-1]] <= heights[heightsIndex]:\n                            stack.pop()\n                        stack.append(heightsIndex)\n                        heightsIndex -= 1\n                    j = self._lastGreater(stack, a, heights)\n                    if j != -1:\n                        ans[queryIndex] = stack[j]\n            return ans\n\n        def _lastGreater(self, A: List[int], target: int, heights: List[int]):\n            l = -1\n            r = len(A) - 1\n            while l < r:\n                m = (l + r + 1) // 2\n                if heights[A[m]] > heights[target]:\n                    l = m\n                else:\n                    r = m - 1\n            return l\n    solution = Solution()\n    heights = [4, 7, 5, 3]\n    queries = [[0, 2], [3, 4]]\n    assert solution.leftmostBuildingQueries(heights, queries) == [2, -1]", "def test_leftmostBuildingQueries():\n\n    class Solution:\n\n        def leftmostBuildingQueries(self, heights: List[int], queries: List[List[int]]) -> List[int]:\n            ans = [-1] * len(queries)\n            stack = []\n            heightsIndex = len(heights) - 1\n            for (queryIndex, a, b) in sorted([IndexedQuery(i, min(a, b), max(a, b)) for (i, (a, b)) in enumerate(queries)], key=lambda iq: -iq.b):\n                if a == b or heights[a] < heights[b]:\n                    ans[queryIndex] = b\n                else:\n                    while heightsIndex > b:\n                        while stack and heights[stack[-1]] <= heights[heightsIndex]:\n                            stack.pop()\n                        stack.append(heightsIndex)\n                        heightsIndex -= 1\n                    j = self._lastGreater(stack, a, heights)\n                    if j != -1:\n                        ans[queryIndex] = stack[j]\n            return ans\n\n        def _lastGreater(self, A: List[int], target: int, heights: List[int]):\n            l = -1\n            r = len(A) - 1\n            while l < r:\n                m = (l + r + 1) // 2\n                if heights[A[m]] > heights[target]:\n                    l = m\n                else:\n                    r = m - 1\n            return l\n    solution = Solution()\n    heights = [5, 7, 3, 4]\n    queries = [[0, 3], [2, 4]]\n    assert solution.leftmostBuildingQueries(heights, queries) == [3, -1]"]}
{"task_num": 2948, "task_title": "Make Lexicographically Smallest Array by Swapping Elements", "func_name": "lexicographicallySmallestArray", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def lexicographicallySmallestArray(self, nums: List[int], limit: int) -> List[int]:\n    ans = [0] * len(nums)\n    numAndIndexes = sorted([(num, i) for i, num in enumerate(nums)])\n    numAndIndexesGroups: List[List[Tuple[int, int]]] = []\n\n    for numAndIndex in numAndIndexes:\n      if not numAndIndexesGroups or numAndIndex[0] - numAndIndexesGroups[-1][-1][0] > limit:\n        numAndIndexesGroups.append([numAndIndex])\n      else:\n        numAndIndexesGroups[-1].append(numAndIndex)\n\n    for numAndIndexesGroup in numAndIndexesGroups:\n      sortedNums = [num for num, _ in numAndIndexesGroup]\n      sortedIndices = sorted([index for _, index in numAndIndexesGroup])\n      for num, index in zip(sortedNums, sortedIndices):\n        ans[index] = num\n\n    return ans\n", "tests": ["def test_lexicographicallySmallestArray(self):\n    nums = [10, 1, 2]\n    limit = 3\n    expected_result = [1, 2, 10]\n    solution = Solution()\n    self.assertEqual(solution.lexicographicallySmallestArray(nums, limit), expected_result)", "def test_lexicographicallySmallestArray(self):\n    nums = [1, 2]\n    limit = 0\n    expected_result = [1, 2]\n    solution = Solution()\n    self.assertEqual(solution.lexicographicallySmallestArray(nums, limit), expected_result)", "def test_lexicographicallySmallestArray(self):\n    nums = [10, 12]\n    limit = 5\n    expected_result = [10, 12]\n    solution = Solution()\n    self.assertEqual(solution.lexicographicallySmallestArray(nums, limit), expected_result)", "def test_lexicographicallySmallestArray(self):\n    nums = [10, 1, 2]\n    limit = 1000\n    expected_result = [1, 2, 10]\n    solution = Solution()\n    self.assertEqual(solution.lexicographicallySmallestArray(nums, limit), expected_result)", "def test_lexicographicallySmallestArray(self):\n    nums = [10, 12, 10]\n    limit = 5\n    expected_result = [10, 10, 12]\n    solution = Solution()\n    self.assertEqual(solution.lexicographicallySmallestArray(nums, limit), expected_result)", "def test_lexicographicallySmallestArray(self):\n    nums = [5]\n    limit = 10\n    expected_result = [5]\n    solution = Solution()\n    self.assertEqual(solution.lexicographicallySmallestArray(nums, limit), expected_result)", "def test_lexicographicallySmallestArray(self):\n    nums = []\n    limit = 10\n    expected_result = []\n    solution = Solution()\n    self.assertEqual(solution.lexicographicallySmallestArray(nums, limit), expected_result)", "def test_lexicographicallySmallestArray(self):\n    nums = [0]\n    limit = 10\n    expected_result = [0]\n    solution = Solution()\n    self.assertEqual(solution.lexicographicallySmallestArray(nums, limit), expected_result)", "def test_lexicographicallySmallestArray(self):\n    nums = [1000000, 1]\n    limit = 0\n    expected_result = [1, 1000000]\n    solution = Solution()\n    self.assertEqual(solution.lexicographicallySmallestArray(nums, limit), expected_result)", "def test_lexicographicallySmallestArray(self):\n    nums = [1, -10]\n    limit = 5\n    with self.assertRaises(ValueError):\n        solution = Solution()\n        solution.lexicographicallySmallestArray(nums, limit)", "def test_lexicographicallySmallestArray(self):\n    nums = [10, 1]\n    limit = -5\n    with self.assertRaises(ValueError):\n        solution = Solution()\n        solution.lexicographicallySmallestArray(nums, limit)", "def test_lexicographicallySmallestArray(self):\n    nums = [1000000, 1000001]\n    limit = 5\n    expected_result = [1000000, 1000001]\n    solution = Solution()\n    self.assertEqual(solution.lexicographicallySmallestArray(nums, limit), expected_result)", "def test_lexicographicallySmallestArray(self):\n    nums = [10, 1]\n    limit = -5\n    with self.assertRaises(ValueError):\n        solution = Solution()\n        solution.lexicographicallySmallestArray(nums, limit)", "def test_lexicographicallySmallestArray(self):\n    nums = [0, 0]\n    limit = 10\n    expected_result = [0, 0]\n    solution = Solution()\n    self.assertEqual(solution.lexicographicallySmallestArray(nums, limit), expected_result)", "def test_lexicographicallySmallestArray(self):\n    nums = [10, 12]\n    limit = abs(nums[0] - nums[1])\n    expected_result = [10, 12]\n    solution = Solution()\n    self.assertEqual(solution.lexicographicallySmallestArray(nums, limit), expected_result)", "def test_lexicographicallySmallestArray(self):\n    nums = [10, 1]\n    limit = None\n    with self.assertRaises(ValueError):\n        solution = Solution()\n        solution.lexicographicallySmallestArray(nums, limit)", "def test_lexicographicallySmallestArray(self):\n    nums = [10, 12, 10, 10]\n    limit = 5\n    expected_result = [10, 10, 10, 12]\n    solution = Solution()\n    self.assertEqual(solution.lexicographicallySmallestArray(nums, limit), expected_result)", "def test_lexicographicallySmallestArray(self):\n    nums = [1000000]\n    limit = 5\n    expected_result = [1000000]\n    solution = Solution()\n    self.assertEqual(solution.lexicographicallySmallestArray(nums, limit), expected_result)", "def test_lexicographicallySmallestArray(self):\n    nums = [0, 1000000]\n    limit = 5\n    expected_result = [0, 1000000]\n    solution = Solution()\n    self.assertEqual(solution.lexicographicallySmallestArray(nums, limit), expected_result)", "def test_lexicographicallySmallestArray(self):\n    nums = [10, 12, 10, 1, 2, 10, 10]\n    limit = 5\n    expected_result = [1, 2, 10, 10, 10, 10, 12]\n    solution = Solution()\n    self.assertEqual(solution.lexicographicallySmallestArray(nums, limit), expected_result)"]}
{"task_num": 2953, "task_title": "Count Complete Substrings", "func_name": "countCompleteSubstrings", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countCompleteSubstrings(self, word: str, k: int) -> int:\n    uniqueLetters = len(set(word))\n    return sum(self._countCompleteStrings(word, k, windowSize) for windowSize in range(k, k * uniqueLetters + 1, k))\n\n  def _countCompleteStrings(self, word: str, k: int, windowSize: int) -> int:\n    res = 0\n    countLetters = 0\n    count = collections.Counter()\n\n    for i, c in enumerate(word):\n      count[c] += 1\n      countLetters += 1\n      if i > 0 and abs(ord(c) - ord(word[i - 1])) > 2:\n        count = collections.Counter()\n        count[c] += 1\n        countLetters = 1\n      if countLetters == windowSize + 1:\n        count[word[i - windowSize]] -= 1\n        countLetters -= 1\n      if countLetters == windowSize:\n        res += all(freq == 0 or freq == k for freq in count.values())\n\n    return res\n", "tests": ["def test_countCompleteSubstrings():\n    solution = Solution()\n    word = 'abcdabcde'\n    k = 1\n    assert solution.countCompleteSubstrings(word, k) == 6", "def test_countCompleteSubstrings():\n    solution = Solution()\n    word = 'aaaaaaabaaa'\n    k = 3\n    assert solution.countCompleteSubstrings(word, k) == 10", "def test_countCompleteSubstrings():\n    solution = Solution()\n    word = 'abc'\n    k = 1\n    assert solution.countCompleteSubstrings(word, k) == 3", "def test_countCompleteSubstrings():\n    solution = Solution()\n    word = 'aabbcc'\n    k = 2\n    assert solution.countCompleteSubstrings(word, k) == 36", "def test_countCompleteSubstrings():\n    solution = Solution()\n    word = 'a'\n    k = 1\n    assert solution.countCompleteSubstrings(word, k) == 0", "def test_countCompleteSubstrings():\n    solution = Solution()\n    word = 'aaaaa'\n    k = 1\n    assert solution.countCompleteSubstrings(word, k) == 5", "def test_countCompleteSubstrings():\n    solution = Solution()\n    word = 'abcdefgh'\n    k = 1\n    assert solution.countCompleteSubstrings(word, k) == 0", "def test_countCompleteSubstrings():\n    solution = Solution()\n    word = 'aaaaaaaaaa'\n    k = 1\n    assert solution.countCompleteSubstrings(word, k) == 11", "def test_countCompleteSubstrings():\n    solution = Solution()\n    word = 'abccba'\n    k = 1\n    assert solution.countCompleteSubstrings(word, k) == 6", "def test_countCompleteSubstrings():\n    solution = Solution()\n    word = 'abcddcba'\n    k = 1\n    assert solution.countCompleteSubstrings(word, k) == 9", "def test_countCompleteSubstrings():\n    solution = Solution()\n    word = 'abcde'\n    k = 1\n    assert solution.countCompleteSubstrings(word, k) == 0", "def test_countCompleteSubstrings():\n    solution = Solution()\n    word = 'abcdeffg'\n    k = 2\n    assert solution.countCompleteSubstrings(word, k) == 0", "def test_countCompleteSubstrings():\n    solution = Solution()\n    word = 'ababcde'\n    k = 1\n    assert solution.countCompleteSubstrings(word, k) == 10", "def test_countCompleteSubstrings():\n    solution = Solution()\n    word = 'aabbccaa'\n    k = 1\n    assert solution.countCompleteSubstrings(word, k) == 36", "def test_countCompleteSubstrings():\n    solution = Solution()\n    word = 'abccbaa'\n    k = 1\n    assert solution.countCompleteSubstrings(word, k) == 13", "def test_countCompleteSubstrings():\n    solution = Solution()\n    word = 'aabbccaaabbc'\n    k = 1\n    assert solution.countCompleteSubstrings(word, k) == 54", "def test_countCompleteSubstrings():\n    solution = Solution()\n    word = 'aabbccddeeffgghhiijjjkkk'\n    k = 1\n    assert solution.countCompleteSubstrings(word, k) == 105", "def test_countCompleteSubstrings():\n    solution = Solution()\n    word = 'abcab'\n    k = 2\n    assert solution.countCompleteSubstrings(word, k) == 0", "def test_countCompleteSubstrings():\n    solution = Solution()\n    word = 'aaaaaabbbbb'\n    k = 2\n    assert solution.countCompleteSubstrings(word, k) == 8", "def test_countCompleteSubstrings():\n    solution = Solution()\n    word = 'ab'\n    k = 1\n    assert solution.countCompleteSubstrings(word, k) == 2"]}
{"task_num": 2959, "task_title": "Number of Possible Sets of Closing Branches", "func_name": "numberOfSets", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:\n    return sum(self._floydWarshall(n, maxDistance, roads, mask) <= maxDistance for mask in range(1 << n))\n\n  def _floydWarshall(self, n: int, maxDistanceThreshold: int, roads: List[List[int]], mask: int) -> List[List[int]]:\n    maxDistance = 0\n    dist = [[maxDistanceThreshold + 1] * n for _ in range(n)]\n\n    for i in range(n):\n      if mask >> i & 1:\n        dist[i][i] = 0\n\n    for u, v, w in roads:\n      if mask >> u & 1 and mask >> v & 1:\n        dist[u][v] = min(dist[u][v], w)\n        dist[v][u] = min(dist[v][u], w)\n\n    for k in range(n):\n      if mask >> k & 1:\n        for i in range(n):\n          if mask >> i & 1:\n            for j in range(n):\n              if mask >> j & 1:\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    for i in range(n):\n      if mask >> i & 1:\n        for j in range(i + 1, n):\n          if mask >> j & 1:\n            maxDistance = max(maxDistance, dist[i][j])\n\n    return maxDistance\n", "tests": ["def test_numberOfSets():\n    class Solution:\n        def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:\n            return sum(self._floydWarshall(n, maxDistance, roads, mask) <= maxDistance for mask in range(1 << n))\n\n        def _floydWarshall(self, n: int, maxDistanceThreshold: int, roads: List[List[int]], mask: int) -> List[List[int]]:\n            # implementation remains the same\n    solution = Solution()\n    print(solution.numberOfSets(3, 2, [[0, 1, 3], [1, 2, 5], [0, 2, 1]]))", "def test_numberOfSets():\n    class Solution:\n        def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:\n            return sum(self._floydWarshall(n, maxDistance, roads, mask) <= maxDistance for mask in range(1 << n))\n\n        def _floydWarshall(self, n: int, maxDistanceThreshold: int, roads: List[List[int]], mask: int) -> List[List[int]]:\n            # implementation remains the same\n    solution = Solution()\n    print(solution.numberOfSets(5, 10, [[0, 1, 2], [1, 4, 3], [0, 4, 6], [1, 3, 7]]))", "def test_numberOfSets():\n    class Solution:\n        def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:\n            return sum(self._floydWarshall(n, maxDistance, roads, mask) <= maxDistance for mask in range(1 << n))\n\n        def _floydWarshall(self, n: int, maxDistanceThreshold: int, roads: List[List[int]], mask: int) -> List[List[int]]:\n            # implementation remains the same\n    solution = Solution()\n    print(solution.numberOfSets(4, 0, [[0, 1, 1], [2, 3, 1]]))", "def test_numberOfSets():\n    class Solution:\n        def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:\n            return sum(self._floydWarshall(n, maxDistance, roads, mask) <= maxDistance for mask in range(1 << n))\n\n        def _floydWarshall(self, n: int, maxDistanceThreshold: int, roads: List[List[int]], mask: int) -> List[List[int]]:\n            # implementation remains the same\n    solution = Solution()\n    print(solution.numberOfSets(6, 10, [[0, 1, 2], [1, 4, 3], [0, 5, 6]]))", "def test_numberOfSets():\n    class Solution:\n        def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:\n            return sum(self._floydWarshall(n, maxDistance, roads, mask) <= maxDistance for mask in range(1 << n))\n\n        def _floydWarshall(self, n: int, maxDistanceThreshold: int, roads: List[List[int]], mask: int) -> List[List[int]]:\n            # implementation remains the same\n    solution = Solution()\n    print(solution.numberOfSets(2, 5, [[0, 1, 10]]))", "def test_numberOfSets():\n    class Solution:\n        def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:\n            return sum(self._floydWarshall(n, maxDistance, roads, mask) <= maxDistance for mask in range(1 << n))\n\n        def _floydWarshall(self, n: int, maxDistanceThreshold: int, roads: List[List[int]], mask: int) -> List[List[int]]:\n            # implementation remains the same\n    solution = Solution()\n    print(solution.numberOfSets(3, 0, [[0, 1, 5], [1, 2, 5]]))", "def test_numberOfSets():\n    class Solution:\n        def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:\n            return sum(self._floydWarshall(n, maxDistance, roads, mask) <= maxDistance for mask in range(1 << n))\n\n        def _floydWarshall(self, n: int, maxDistanceThreshold: int, roads: List[List[int]], mask: int) -> List[List[int]]:\n            # implementation remains the same\n    solution = Solution()\n    print(solution.numberOfSets(8, 3, [[0, 1, 2], [0, 7, 10], [1, 4, 3], [1, 7, 5], [2, 7, 9]]))", "def test_numberOfSets():\n    class Solution:\n        def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:\n            return sum(self._floydWarshall(n, maxDistance, roads, mask) <= maxDistance for mask in range(1 << n))\n\n        def _floydWarshall(self, n: int, maxDistanceThreshold: int, roads: List[List[int]], mask: int) -> List[List[int]]:\n            # implementation remains the same\n    solution = Solution()\n    print(solution.numberOfSets(1, 5, []))", "def test_numberOfSets():\n    class Solution:\n        def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:\n            return sum(self._floydWarshall(n, maxDistance, roads, mask) <= maxDistance for mask in range(1 << n))\n\n        def _floydWarshall(self, n: int, maxDistanceThreshold: int, roads: List[List[int]], mask: int) -> List[List[int]]:\n            # implementation remains the same\n    solution = Solution()\n    print(solution.numberOfSets(0, 5, []))", "def test_numberOfSets():\n    class Solution:\n        def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:\n            return sum(self._floydWarshall(n, maxDistance, roads, mask) <= maxDistance for mask in range(1 << n))\n\n        def _floydWarshall(self, n: int, maxDistanceThreshold: int, roads: List[List[int]], mask: int) -> List[List[int]]:\n            # implementation remains the same\n    solution = Solution()\n    print(solution.numberOfSets(10, 20, [[0, 1, 15], [1, 2, 35], [2, 3, 25]]))", "def test_numberOfSets():\n    class Solution:\n        def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:\n            return sum(self._floydWarshall(n, maxDistance, roads, mask) <= maxDistance for mask in range(1 << n))\n\n        def _floydWarshall(self, n: int, maxDistanceThreshold: int, roads: List[List[int]], mask: int) -> List[List[int]]:\n            # implementation remains the same\n    solution = Solution()\n    print(solution.numberOfSets(7, 25, [[0, 1, 15], [1, 2, 35], [2, 3, 25], [4, 5, 10]]))", "def test_numberOfSets():\n    class Solution:\n        def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:\n            return sum(self._floydWarshall(n, maxDistance, roads, mask) <= maxDistance for mask in range(1 << n))\n\n        def _floydWarshall(self, n: int, maxDistanceThreshold: int, roads: List[List[int]], mask: int) -> List[List[int]]:\n            # implementation remains the same\n    solution = Solution()\n    print(solution.numberOfSets(12, 30, [[0, 1, 15], [1, 2, 35], [2, 3, 25], [4, 5, 10], [6, 7, 20]]))", "def test_numberOfSets():\n    class Solution:\n        def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:\n            return sum(self._floydWarshall(n, maxDistance, roads, mask) <= maxDistance for mask in range(1 << n))\n\n        def _floydWarshall(self, n: int, maxDistanceThreshold: int, roads: List[List[int]], mask: int) -> List[List[int]]:\n            # implementation remains the same\n    solution = Solution()\n    print(solution.numberOfSets(15, 50, [[0, 1, 20], [1, 2, 25], [2, 3, 30], [4, 5, 10], [6, 7, 20], [8, 9, 40]]))", "def test_numberOfSets():\n    class Solution:\n        def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:\n            return sum(self._floydWarshall(n, maxDistance, roads, mask) <= maxDistance for mask in range(1 << n))\n\n        def _floydWarshall(self, n: int, maxDistanceThreshold: int, roads: List[List[int]], mask: int) -> List[List[int]]:\n            # implementation remains the same\n    solution = Solution()\n    print(solution.numberOfSets(20, 100, [[0, 1, 25], [1, 2, 30], [2, 3, 35], [4, 5, 10], [6, 7, 20], [8, 9, 40], [10, 11, 45]]))", "def test_numberOfSets():\n    class Solution:\n        def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:\n            return sum(self._floydWarshall(n, maxDistance, roads, mask) <= maxDistance for mask in range(1 << n))\n\n        def _floydWarshall(self, n: int, maxDistanceThreshold: int, roads: List[List[int]], mask: int) -> List[List[int]]:\n            # implementation remains the same\n    solution = Solution()\n    print(solution.numberOfSets(25, 200, [[0, 1, 50], [1, 2, 55], [2, 3, 60], [4, 5, 10], [6, 7, 20], [8, 9, 40], [10, 11, 45], [12, 13, 48]]))", "def test_numberOfSets():\n    class Solution:\n        def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:\n            return sum(self._floydWarshall(n, maxDistance, roads, mask) <= maxDistance for mask in range(1 << n))\n\n        def _floydWarshall(self, n: int, maxDistanceThreshold: int, roads: List[List[int]], mask: int) -> List[List[int]]:\n            # implementation remains the same\n    solution = Solution()\n    print(solution.numberOfSets(30, 300, [[0, 1, 75], [1, 2, 80], [2, 3, 85], [4, 5, 10], [6, 7, 20], [8, 9, 40], [10, 11, 45], [12, 13, 48], [14, 15, 52]]))", "def test_numberOfSets():\n    class Solution:\n        def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:\n            return sum(self._floydWarshall(n, maxDistance, roads, mask) <= maxDistance for mask in range(1 << n))\n\n        def _floydWarshall(self, n: int, maxDistanceThreshold: int, roads: List[List[int]], mask: int) -> List[List[int]]:\n            # implementation remains the same\n    solution = Solution()\n    print(solution.numberOfSets(35, 500, [[0, 1, 100], [1, 2, 105], [2, 3, 110], [4, 5, 10], [6, 7, 20], [8, 9, 40], [10, 11, 45], [12, 13, 48], [14, 15, 52], [16, 17, 56]]))", "def test_numberOfSets():\n    class Solution:\n        def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:\n            return sum(self._floydWarshall(n, maxDistance, roads, mask) <= maxDistance for mask in range(1 << n))\n\n        def _floydWarshall(self, n: int, maxDistanceThreshold: int, roads: List[List[int]], mask: int) -> List[List[int]]:\n            # implementation remains the same\n    solution = Solution()\n    print(solution.numberOfSets(40, 1000, [[0, 1, 125], [1, 2, 130], [2, 3, 135], [4, 5, 10], [6, 7, 20], [8, 9, 40], [10, 11, 45], [12, 13, 48], [14, 15, 52], [16, 17, 56], [18, 19, 60]]))", "def test_numberOfSets():\n    class Solution:\n        def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:\n            return sum(self._floydWarshall(n, maxDistance, roads, mask) <= maxDistance for mask in range(1 << n))\n\n        def _floydWarshall(self, n: int, maxDistanceThreshold: int, roads: List[List[int]], mask: int) -> List[List[int]]:\n            # implementation remains the same\n    solution = Solution()\n    print(solution.numberOfSets(45, 1500, [[0, 1, 150], [1, 2, 155], [2, 3, 160], [4, 5, 10], [6, 7, 20], [8, 9, 40], [10, 11, 45], [12, 13, 48], [14, 15, 52], [16, 17, 56], [18, 19, 60], [20, 21, 65]]))", "def test_numberOfSets():\n    class Solution:\n        def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:\n            return sum(self._floydWarshall(n, maxDistance, roads, mask) <= maxDistance for mask in range(1 << n))\n\n        def _floydWarshall(self, n: int, maxDistanceThreshold: int, roads: List[List[int]], mask: int) -> List[List[int]]:\n            # implementation remains the same\n    solution = Solution()\n    print(solution.numberOfSets(50, 2000, [[0, 1, 175], [1, 2, 180], [2, 3, 185], [4, 5, 10], [6, 7, 20], [8, 9, 40], [10, 11, 45], [12, 13, 48], [14, 15, 52], [16, 17, 56], [18, 19, 60], [20, 21, 65], [22, 23, 70]]))"]}
{"task_num": 2973, "task_title": "Find Number of Coins to Place in Tree Nodes", "func_name": "placedCoins", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass ChildCost:\n  def __init__(self, cost: int):\n    self.numNodes = 1\n    self.maxPosCosts = [cost] if cost > 0 else []\n    self.minNegCosts = [cost] if cost < 0 else []\n\n  def update(self, childCost: 'ChildCost') -> None:\n    self.numNodes += childCost.numNodes\n    self.maxPosCosts.extend(childCost.maxPosCosts)\n    self.minNegCosts.extend(childCost.minNegCosts)\n    self.maxPosCosts.sort(reverse=True)\n    self.minNegCosts.sort()\n    self.maxPosCosts = self.maxPosCosts[:3]\n    self.minNegCosts = self.minNegCosts[:2]\n\n  def maxProduct(self) -> int:\n    if self.numNodes < 3:\n      return 1\n    if not self.maxPosCosts:\n      return 0\n    res = 0\n    if len(self.maxPosCosts) == 3:\n      res = self.maxPosCosts[0] * self.maxPosCosts[1] * self.maxPosCosts[2]\n    if len(self.minNegCosts) == 2:\n      res = max(res, self.minNegCosts[0] * self.minNegCosts[1] * self.maxPosCosts[0])\n    return res\n\n\nclass Solution:\n  def placedCoins(self, edges: List[List[int]], cost: List[int]) -> List[int]:\n    n = len(cost)\n    ans = [0] * n\n    tree = [[] for _ in range(n)]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, prev: int) -> None:\n      res = ChildCost(cost[u])\n      for v in tree[u]:\n        if v != prev:\n          res.update(dfs(v, u))\n      ans[u] = res.maxProduct()\n      return res\n\n    dfs(0, -1)\n    return ans\n", "tests": ["def test_placedCoins(self):\n\n    def create_tree(n, edges):\n        tree = [[] for _ in range(n)]\n        for (u, v) in edges:\n            tree[u].append(v)\n            tree[v].append(u)\n        return tree\n    solution = Solution()\n    cost = [1, -2, 3]\n    edges = [[0, 1], [0, 2]]\n    ans = solution.placedCoins(create_tree(len(cost), edges), cost)", "def test_placedCoins(self):\n    solution = Solution()\n    cost = [-2, -3]\n    edges = [[0, 1]]\n    ans = solution.placedCoins(create_tree(len(cost), edges), cost)", "def test_placedCoins(self):\n    solution = Solution()\n    cost = [1] * 10\n    edges = [[0, i] for i in range(1, len(cost))]\n    ans = solution.placedCoins(create_tree(len(cost), edges), cost)", "def test_placedCoins(self):\n    solution = Solution()\n    cost = [1, -2, 3, 4]\n    edges = [[0, 1], [1, 2], [2, 3]]\n    ans = solution.placedCoins(create_tree(len(cost), edges), cost)", "def test_placedCoins(self):\n    solution = Solution()\n    cost = [10, -2, 3]\n    edges = [[0, 1], [0, 2]]\n    ans = solution.placedCoins(create_tree(len(cost), edges), cost)", "def test_placedCoins(self):\n    solution = Solution()\n    cost = [1] * 10 ** 6\n    edges = [[0, i] for i in range(1, len(cost))]\n    ans = solution.placedCoins(create_tree(len(cost), edges), cost)", "def test_placedCoins(self):\n    solution = Solution()\n    cost = [-1, -2, 3]\n    edges = [[0, 1], [0, 2]]\n    ans = solution.placedCoins(create_tree(len(cost), edges), cost)", "def test_placedCoins(self):\n    solution = Solution()\n    cost = [1] * 10 ** 6 + [-2]\n    edges = [[0, i] for i in range(1, len(cost))]\n    ans = solution.placedCoins(create_tree(len(cost), edges), cost)", "def test_placedCoins(self):\n    solution = Solution()\n    cost = [0]\n    edges = []\n    ans = solution.placedCoins(create_tree(len(cost), edges), cost)", "def test_placedCoins(self):\n    solution = Solution()\n    cost = [10 ** 9]\n    edges = []\n    ans = solution.placedCoins(create_tree(len(cost), edges), cost)", "def test_placedCoins(self):\n    solution = Solution()\n    cost = [0] * 10 ** 6\n    edges = [[0, i] for i in range(1, len(cost))]\n    ans = solution.placedCoins(create_tree(len(cost), edges), cost)", "def test_placedCoins(self):\n    solution = Solution()\n    cost = [-10 ** 9] * 10 ** 6\n    edges = [[0, i] for i in range(1, len(cost))]\n    ans = solution.placedCoins(create_tree(len(cost), edges), cost)", "def test_placedCoins(self):\n    solution = Solution()\n    cost = [1]\n    edges = []\n    ans = solution.placedCoins(create_tree(len(cost), edges), cost)", "def test_placedCoins(self):\n    solution = Solution()\n    cost = [10]\n    edges = [[0, 1]]\n    ans = solution.placedCoins(create_tree(len(cost), edges), cost)", "def test_placedCoins(self):\n    solution = Solution()\n    cost = [1, -2, 3]\n    edges = [[0, 1]]\n    ans = solution.placedCoins(create_tree(len(cost), edges), cost)", "def test_placedCoins(self):\n    solution = Solution()\n    cost = [0, -2, 3]\n    edges = [[1, 2]]\n    ans = solution.placedCoins(create_tree(len(cost), edges), cost)", "def test_placedCoins(self):\n    solution = Solution()\n    cost = [1, -2, 3]\n    edges = [[0, 1], [1, 2]]\n    ans = solution.placedCoins(create_tree(len(cost), edges), cost)", "def test_placedCoins(self):\n    solution = Solution()\n    cost = [10 ** 18]\n    edges = []\n    ans = solution.placedCoins(create_tree(len(cost), edges), cost)", "def test_placedCoins(self):\n    solution = Solution()\n    cost = [1] * 10 ** 9 + [-2]\n    edges = [[0, i] for i in range(1, len(cost))]\n    ans = solution.placedCoins(create_tree(len(cost), edges), cost)", "def test_placedCoins(self):\n    solution = Solution()\n    cost = [1] * 10 ** 9 + [-2]\n    edges = [[0, i] for i in range(1, len(cost))]\n    ans = solution.placedCoins(create_tree(len(cost), edges), cost)"]}
{"task_num": 2976, "task_title": "Minimum Cost to Convert String I", "func_name": "minimumCost", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n    ans = 0\n    dist = [[math.inf] * 26 for _ in range(26)]\n\n    for a, b, c in zip(original, changed, cost):\n      u = ord(a) - ord('a')\n      v = ord(b) - ord('a')\n      dist[u][v] = min(dist[u][v], c)\n\n    for k in range(26):\n      for i in range(26):\n        if dist[i][k] < math.inf:\n          for j in range(26):\n            if dist[k][j] < math.inf:\n              dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    for s, t in zip(source, target):\n      if s == t:\n        continue\n      u = ord(s) - ord('a')\n      v = ord(t) - ord('a')\n      if dist[u][v] == math.inf:\n        return -1\n      ans += dist[u][v]\n\n    return ans\n", "tests": ["def test_minimumCost():\n    solution = Solution()\n\n    def inputs(source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:", "def test_minimumCost():\n    solution = Solution()\n\n    def inputs(source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:", "def test_minimumCost():\n    solution = Solution()\n\n    def inputs(source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:", "def test_minimumCost():\n    solution = Solution()\n\n    def inputs(source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:", "def test_minimumCost():\n    solution = Solution()\n\n    def inputs(source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:", "def test_minimumCost():\n    solution = Solution()\n\n    def inputs(source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:", "def test_minimumCost():\n    solution = Solution()\n\n    def inputs(source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:", "def test_minimumCost():\n    solution = Solution()\n\n    def inputs(source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:", "def test_minimumCost():\n    solution = Solution()\n\n    def inputs(source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:", "def test_minimumCost():\n    solution = Solution()\n\n    def inputs(source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:", "def test_minimumCost():\n    solution = Solution()\n\n    def inputs(source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:", "def test_minimumCost():\n    solution = Solution()\n\n    def inputs(source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:", "def test_minimumCost():\n    solution = Solution()\n\n    def inputs(source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:", "def test_minimumCost():\n    solution = Solution()\n\n    def inputs(source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:", "def test_minimumCost():\n    solution = Solution()\n\n    def inputs(source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:", "def test_minimumCost():\n    solution = Solution()\n\n    def inputs(source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:", "def test_minimumCost():\n    solution = Solution()\n\n    def inputs(source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:", "def test_minimumCost():\n    solution = Solution()\n\n    def inputs(source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:", "def test_minimumCost():\n    solution = Solution()\n\n    def inputs(source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:", "def test_minimumCost():\n    solution = Solution()\n\n    def inputs(source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:"]}
{"task_num": 2977, "task_title": "Minimum Cost to Convert String II", "func_name": "minimumCost", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n    subLengths = set(len(s) for s in original)\n    subToId = self._getSubToId(original, changed)\n    subCount = len(subToId)\n    dist = [[math.inf for _ in range(subCount)] for _ in range(subCount)]\n    dp = [math.inf for _ in range(len(source) + 1)]\n\n    for a, b, c in zip(original, changed, cost):\n      u = subToId[a]\n      v = subToId[b]\n      dist[u][v] = min(dist[u][v], c)\n\n    for k in range(subCount):\n      for i in range(subCount):\n        if dist[i][k] < math.inf:\n          for j in range(subCount):\n            if dist[k][j] < math.inf:\n              dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    dp[0] = 0\n\n    for i, (s, t) in enumerate(zip(source, target)):\n      if dp[i] == math.inf:\n        continue\n      if s == t:\n        dp[i + 1] = min(dp[i + 1], dp[i])\n      for subLength in subLengths:\n        if i + subLength > len(source):\n          continue\n        subSource = source[i:i + subLength]\n        subTarget = target[i:i + subLength]\n        if subSource not in subToId or subTarget not in subToId:\n          continue\n        u = subToId[subSource]\n        v = subToId[subTarget]\n        if dist[u][v] != math.inf:\n          dp[i + subLength] = min(dp[i + subLength], dp[i] + dist[u][v])\n\n    if dp[len(source)] == math.inf:\n      return -1\n    else:\n      return dp[len(source)]\n\n  def _getSubToId(self, original: str, changed: str) -> Dict[str, int]:\n    subToId = {}\n    for s in original + changed:\n      if s not in subToId:\n        subToId[s] = len(subToId)\n    return subToId\n", "tests": ["def test_minimumCost():\n    solution = Solution()\n\n    def test_case(source, target, original, changed, cost):\n        result = solution.minimumCost(source, target, original, changed, cost)", "def test_minimumCost():\n    solution = Solution()\n\n    def test_case(source, target, original, changed, cost):\n        result = solution.minimumCost(source, target, original, changed, cost)", "def test_minimumCost():\n    solution = Solution()\n\n    def test_case(source, target, original, changed, cost):\n        result = solution.minimumCost(source, target, original, changed, cost)", "def test_minimumCost():\n    solution = Solution()\n\n    def test_case(source, target, original, changed, cost):\n        result = solution.minimumCost(source, target, original, changed, cost)", "def test_minimumCost():\n    solution = Solution()\n\n    def test_case(source, target, original, changed, cost):\n        result = solution.minimumCost(source, target, original, changed, cost)", "def test_minimumCost():\n    solution = Solution()\n\n    def test_case(source, target, original, changed, cost):\n        result = solution.minimumCost(source, target, original, changed, cost)", "def test_minimumCost():\n    solution = Solution()\n\n    def test_case(source, target, original, changed, cost):\n        result = solution.minimumCost(source, target, original, changed, cost)", "def test_minimumCost():\n    solution = Solution()\n\n    def test_case(source, target, original, changed, cost):\n        result = solution.minimumCost(source, target, original, changed, cost)", "def test_minimumCost():\n    solution = Solution()\n\n    def test_case(source, target, original, changed, cost):\n        result = solution.minimumCost(source, target, original, changed, cost)", "def test_minimumCost():\n    solution = Solution()\n\n    def test_case(source, target, original, changed, cost):\n        result = solution.minimumCost(source, target, original, changed, cost)", "def test_minimumCost():\n    solution = Solution()\n\n    def test_case(source, target, original, changed, cost):\n        result = solution.minimumCost(source, target, original, changed, cost)", "def test_minimumCost():\n    solution = Solution()\n\n    def test_case(source, target, original, changed, cost):\n        result = solution.minimumCost(source, target, original, changed, cost)", "def test_minimumCost():\n    solution = Solution()\n\n    def test_case(source, target, original, changed, cost):\n        result = solution.minimumCost(source, target, original, changed, cost)", "def test_minimumCost():\n    solution = Solution()\n\n    def test_case(source, target, original, changed, cost):\n        result = solution.minimumCost(source, target, original, changed, cost)", "def test_minimumCost():\n    solution = Solution()\n\n    def test_case(source, target, original, changed, cost):\n        result = solution.minimumCost(source, target, original, changed, cost)", "def test_minimumCost():\n    solution = Solution()\n\n    def test_case(source, target, original, changed, cost):\n        result = solution.minimumCost(source, target, original, changed, cost)", "def test_minimumCost():\n    solution = Solution()\n\n    def test_case(source, target, original, changed, cost):\n        result = solution.minimumCost(source, target, original, changed, cost)", "def test_minimumCost():\n    solution = Solution()\n\n    def test_case(source, target, original, changed, cost):\n        result = solution.minimumCost(source, target, original, changed, cost)", "def test_minimumCost():\n    solution = Solution()\n\n    def test_case(source, target, original, changed, cost):\n        result = solution.minimumCost(source, target, original, changed, cost)", "def test_minimumCost():\n    solution = Solution()\n\n    def test_case(source, target, original, changed, cost):\n        result = solution.minimumCost(source, target, original, changed, cost)"]}
{"task_num": 2983, "task_title": "Palindrome Rearrangement Queries", "func_name": "canMakePalindromeQueries", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n    n = len(s)\n    mirroredDiffs = self._getMirroredDiffs(s)\n    counts = self._getCounts(s)\n    ans = []\n\n    def subtractArrays(a: List[int], b: List[int]):\n      return [x - y for x, y in zip(a, b)]\n\n    for a, b, c, d in queries:\n      b += 1\n      d += 1\n      ra = n - a\n      rb = n - b\n      rc = n - c\n      rd = n - d\n\n      if (min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0) or (n // 2 > max(b, rc) and mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0):\n        ans.append(False)\n      else:\n        leftRangeCount = subtractArrays(counts[b], counts[a])\n        rightRangeCount = subtractArrays(counts[d], counts[c])\n        if a > rd:\n          rightRangeCount = subtractArrays(\n              rightRangeCount, subtractArrays(counts[min(a, rc)], counts[rd]))\n        if rc > b:\n          rightRangeCount = subtractArrays(\n              rightRangeCount, subtractArrays(counts[rc], counts[max(b, rd)]))\n        if c > rb:\n          leftRangeCount = subtractArrays(\n              leftRangeCount, subtractArrays(counts[min(c, ra)], counts[rb]))\n        if ra > d:\n          leftRangeCount = subtractArrays(\n              leftRangeCount, subtractArrays(counts[ra], counts[max(d, rb)]))\n        ans.append(min(leftRangeCount) >= 0\n                   and min(rightRangeCount) >= 0\n                   and leftRangeCount == rightRangeCount)\n\n    return ans\n\n  def _getMirroredDiffs(self, s: str) -> List[int]:\n    diffs = [0]\n    for i, j in zip(range(len(s)), reversed(range(len(s)))):\n      if i >= j:\n        break\n      diffs.append(diffs[-1] + (s[i] != s[j]))\n    return diffs\n\n  def _getCounts(self, s: str) -> List[List[int]]:\n    count = [0] * 26\n    counts = [count.copy()]\n    for c in s:\n      count[ord(c) - ord('a')] += 1\n      counts.append(count.copy())\n    return counts\n", "tests": ["def test_canMakePalindromeQueries():\n\n    class Solution:\n\n        def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n            n = len(s)\n            mirroredDiffs = self._getMirroredDiffs(s)\n            counts = self._getCounts(s)\n            ans = []\n\n            def subtractArrays(a: List[int], b: List[int]):\n                return [x - y for (x, y) in zip(a, b)]\n            for (a, b, c, d) in queries:\n                b += 1\n                d += 1\n                ra = n - a\n                rb = n - b\n                rc = n - c\n                rd = n - d\n                if min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0 or (n // 2 > max(b, rc) and mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0):\n                    ans.append(False)\n                else:\n                    leftRangeCount = subtractArrays(counts[b], counts[a])\n                    rightRangeCount = subtractArrays(counts[d], counts[c])\n                    if a > rd:\n                        rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[min(a, rc)], counts[rd]))\n                    if rc > b:\n                        rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[rc], counts[max(b, rd)]))\n                    if c > rb:\n                        leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[min(c, ra)], counts[rb]))\n                    if ra > d:\n                        leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[ra], counts[max(d, rb)]))\n                    ans.append(min(leftRangeCount) >= 0 and min(rightRangeCount) >= 0 and (leftRangeCount == rightRangeCount))\n            return ans\n\n        def _getMirroredDiffs(self, s: str) -> List[int]:\n            diffs = [0]\n            for (i, j) in zip(range(len(s)), reversed(range(len(s)))):\n                if i >= j:\n                    break\n                diffs.append(diffs[-1] + (s[i] != s[j]))\n            return diffs\n\n        def _getCounts(self, s: str) -> List[List[int]]:\n            count = [0] * 26\n            counts = [count.copy()]\n            for c in s:\n                count[ord(c) - ord('a')] += 1\n                counts.append(count.copy())\n            return counts\n    solution = Solution()\n    print(solution.canMakePalindromeQueries('abcba', [[3, 4, 2, 0], [5, 6, 7, 8]]))", "def test_canMakePalindromeQueries():\n\n    class Solution:\n\n        def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n            n = len(s)\n            mirroredDiffs = self._getMirroredDiffs(s)\n            counts = self._getCounts(s)\n            ans = []\n\n            def subtractArrays(a: List[int], b: List[int]):\n                return [x - y for (x, y) in zip(a, b)]\n            for (a, b, c, d) in queries:\n                b += 1\n                d += 1\n                ra = n - a\n                rb = n - b\n                rc = n - c\n                rd = n - d\n                if min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0 or (n // 2 > max(b, rc) and mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0):\n                    ans.append(False)\n                else:\n                    leftRangeCount = subtractArrays(counts[b], counts[a])\n                    rightRangeCount = subtractArrays(counts[d], counts[c])\n                    if a > rd:\n                        rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[min(a, rc)], counts[rd]))\n                    if rc > b:\n                        rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[rc], counts[max(b, rd)]))\n                    if c > rb:\n                        leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[min(c, ra)], counts[rb]))\n                    if ra > d:\n                        leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[ra], counts[max(d, rb)]))\n                    ans.append(min(leftRangeCount) >= 0 and min(rightRangeCount) >= 0 and (leftRangeCount == rightRangeCount))\n            return ans\n\n        def _getMirroredDiffs(self, s: str) -> List[int]:\n            diffs = [0]\n            for (i, j) in zip(range(len(s)), reversed(range(len(s)))):\n                if i >= j:\n                    break\n                diffs.append(diffs[-1] + (s[i] != s[j]))\n            return diffs\n\n        def _getCounts(self, s: str) -> List[List[int]]:\n            count = [0] * 26\n            counts = [count.copy()]\n            for c in s:\n                count[ord(c) - ord('a')] += 1\n                counts.append(count.copy())\n            return counts\n    solution = Solution()\n    print(solution.canMakePalindromeQueries('aaaaaa', [[4, 5, 0, 3], [8, 9, 10, 11]]))", "def test_canMakePalindromeQueries():\n\n    class Solution:\n\n        def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n            n = len(s)\n            mirroredDiffs = self._getMirroredDiffs(s)\n            counts = self._getCounts(s)\n            ans = []\n\n            def subtractArrays(a: List[int], b: List[int]):\n                return [x - y for (x, y) in zip(a, b)]\n            for (a, b, c, d) in queries:\n                b += 1\n                d += 1\n                ra = n - a\n                rb = n - b\n                rc = n - c\n                rd = n - d\n                if min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0 or (n // 2 > max(b, rc) and mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0):\n                    ans.append(False)\n                else:\n                    leftRangeCount = subtractArrays(counts[b], counts[a])\n                    rightRangeCount = subtractArrays(counts[d], counts[c])\n                    if a > rd:\n                        rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[min(a, rc)], counts[rd]))\n                    if rc > b:\n                        rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[rc], counts[max(b, rd)]))\n                    if c > rb:\n                        leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[min(c, ra)], counts[rb]))\n                    if ra > d:\n                        leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[ra], counts[max(d, rb)]))\n                    ans.append(min(leftRangeCount) >= 0 and min(rightRangeCount) >= 0 and (leftRangeCount == rightRangeCount))\n            return ans\n\n        def _getMirroredDiffs(self, s: str) -> List[int]:\n            diffs = [0]\n            for (i, j) in zip(range(len(s)), reversed(range(len(s)))):\n                if i >= j:\n                    break\n                diffs.append(diffs[-1] + (s[i] != s[j]))\n            return diffs\n\n        def _getCounts(self, s: str) -> List[List[int]]:\n            count = [0] * 26\n            counts = [count.copy()]\n            for c in s:\n                count[ord(c) - ord('a')] += 1\n                counts.append(count.copy())\n            return counts\n    solution = Solution()\n    print(solution.canMakePalindromeQueries('abccba', [[5, 6, 0, 0], [7, 8, 9, 10]]))", "def test_canMakePalindromeQueries():\n\n    class Solution:\n\n        def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n            n = len(s)\n            mirroredDiffs = self._getMirroredDiffs(s)\n            counts = self._getCounts(s)\n            ans = []\n\n            def subtractArrays(a: List[int], b: List[int]):\n                return [x - y for (x, y) in zip(a, b)]\n            for (a, b, c, d) in queries:\n                b += 1\n                d += 1\n                ra = n - a\n                rb = n - b\n                rc = n - c\n                rd = n - d\n                if min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0 or (n // 2 > max(b, rc) and mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0):\n                    ans.append(False)\n                else:\n                    leftRangeCount = subtractArrays(counts[b], counts[a])\n                    rightRangeCount = subtractArrays(counts[d], counts[c])\n                    if a > rd:\n                        rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[min(a, rc)], counts[rd]))\n                    if rc > b:\n                        rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[rc], counts[max(b, rd)]))\n                    if c > rb:\n                        leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[min(c, ra)], counts[rb]))\n                    if ra > d:\n                        leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[ra], counts[max(d, rb)]))\n                    ans.append(min(leftRangeCount) >= 0 and min(rightRangeCount) >= 0 and (leftRangeCount == rightRangeCount))\n            return ans\n\n        def _getMirroredDiffs(self, s: str) -> List[int]:\n            diffs = [0]\n            for (i, j) in zip(range(len(s)), reversed(range(len(s)))):\n                if i >= j:\n                    break\n                diffs.append(diffs[-1] + (s[i] != s[j]))\n            return diffs\n\n        def _getCounts(self, s: str) -> List[List[int]]:\n            count = [0] * 26\n            counts = [count.copy()]\n            for c in s:\n                count[ord(c) - ord('a')] += 1\n                counts.append(count.copy())\n            return counts\n    solution = Solution()\n    print(solution.canMakePalindromeQueries('abcd', [[2, 3, 0, 0], [5, 6, 7, 8]]))", "def test_canMakePalindromeQueries():\n\n    class Solution:\n\n        def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n            n = len(s)\n            mirroredDiffs = self._getMirroredDiffs(s)\n            counts = self._getCounts(s)\n            ans = []\n\n            def subtractArrays(a: List[int], b: List[int]):\n                return [x - y for (x, y) in zip(a, b)]\n            for (a, b, c, d) in queries:\n                b += 1\n                d += 1\n                ra = n - a\n                rb = n - b\n                rc = n - c\n                rd = n - d\n                if min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0 or (n // 2 > max(b, rc) and mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0):\n                    ans.append(False)\n                else:\n                    leftRangeCount = subtractArrays(counts[b], counts[a])\n                    rightRangeCount = subtractArrays(counts[d], counts[c])\n                    if a > rd:\n                        rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[min(a, rc)], counts[rd]))\n                    if rc > b:\n                        rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[rc], counts[max(b, rd)]))\n                    if c > rb:\n                        leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[min(c, ra)], counts[rb]))\n                    if ra > d:\n                        leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[ra], counts[max(d, rb)]))\n                    ans.append(min(leftRangeCount) >= 0 and min(rightRangeCount) >= 0 and (leftRangeCount == rightRangeCount))\n            return ans\n\n        def _getMirroredDiffs(self, s: str) -> List[int]:\n            diffs = [0]\n            for (i, j) in zip(range(len(s)), reversed(range(len(s)))):\n                if i >= j:\n                    break\n                diffs.append(diffs[-1] + (s[i] != s[j]))\n            return diffs\n\n        def _getCounts(self, s: str) -> List[List[int]]:\n            count = [0] * 26\n            counts = [count.copy()]\n            for c in s:\n                count[ord(c) - ord('a')] += 1\n                counts.append(count.copy())\n            return counts\n    solution = Solution()\n    print(solution.canMakePalindromeQueries('abccba', [[2, 3, 0, 0], [5, 6, 7, 8]]))", "def test_canMakePalindromeQueries():\n\n    class Solution:\n\n        def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n            n = len(s)\n            mirroredDiffs = self._getMirroredDiffs(s)\n            counts = self._getCounts(s)\n            ans = []\n\n            def subtractArrays(a: List[int], b: List[int]):\n                return [x - y for (x, y) in zip(a, b)]\n            for (a, b, c, d) in queries:\n                b += 1\n                d += 1\n                ra = n - a\n                rb = n - b\n                rc = n - c\n                rd = n - d\n                if min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0 or (n // 2 > max(b, rc) and mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0):\n                    ans.append(False)\n                else:\n                    leftRangeCount = subtractArrays(counts[b], counts[a])\n                    rightRangeCount = subtractArrays(counts[d], counts[c])\n                    if a > rd:\n                        rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[min(a, rc)], counts[rd]))\n                    if rc > b:\n                        rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[rc], counts[max(b, rd)]))\n                    if c > rb:\n                        leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[min(c, ra)], counts[rb]))\n                    if ra > d:\n                        leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[ra], counts[max(d, rb)]))\n                    ans.append(min(leftRangeCount) >= 0 and min(rightRangeCount) >= 0 and (leftRangeCount == rightRangeCount))\n            return ans\n\n        def _getMirroredDiffs(self, s: str) -> List[int]:\n            diffs = [0]\n            for (i, j) in zip(range(len(s)), reversed(range(len(s)))):\n                if i >= j:\n                    break\n                diffs.append(diffs[-1] + (s[i] != s[j]))\n            return diffs\n\n        def _getCounts(self, s: str) -> List[List[int]]:\n            count = [0] * 26\n            counts = [count.copy()]\n            for c in s:\n                count[ord(c) - ord('a')] += 1\n                counts.append(count.copy())\n            return counts\n    solution = Solution()\n    print(solution.canMakePalindromeQueries('abcddcba', [[2, 3, 0, 0], [5, 6, 7, 8]]))", "def test_canMakePalindromeQueries():\n\n    class Solution:\n\n        def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n            n = len(s)\n            mirroredDiffs = self._getMirroredDiffs(s)\n            counts = self._getCounts(s)\n            ans = []\n\n            def subtractArrays(a: List[int], b: List[int]):\n                return [x - y for (x, y) in zip(a, b)]\n            for (a, b, c, d) in queries:\n                b += 1\n                d += 1\n                ra = n - a\n                rb = n - b\n                rc = n - c\n                rd = n - d\n                if min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0 or (n // 2 > max(b, rc) and mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0):\n                    ans.append(False)\n                else:\n                    leftRangeCount = subtractArrays(counts[b], counts[a])\n                    rightRangeCount = subtractArrays(counts[d], counts[c])\n                    if a > rd:\n                        rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[min(a, rc)], counts[rd]))\n                    if rc > b:\n                        rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[rc], counts[max(b, rd)]))\n                    if c > rb:\n                        leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[min(c, ra)], counts[rb]))\n                    if ra > d:\n                        leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[ra], counts[max(d, rb)]))\n                    ans.append(min(leftRangeCount) >= 0 and min(rightRangeCount) >= 0 and (leftRangeCount == rightRangeCount))\n            return ans\n\n        def _getMirroredDiffs(self, s: str) -> List[int]:\n            diffs = [0]\n            for (i, j) in zip(range(len(s)), reversed(range(len(s)))):\n                if i >= j:\n                    break\n                diffs.append(diffs[-1] + (s[i] != s[j]))\n            return diffs\n\n        def _getCounts(self, s: str) -> List[List[int]]:\n            count = [0] * 26\n            counts = [count.copy()]\n            for c in s:\n                count[ord(c) - ord('a')] += 1\n                counts.append(count.copy())\n            return counts\n    solution = Solution()\n    print(solution.canMakePalindromeQueries('abccba', [[2, 3, 0, 4], [5, 6, 7, 8]]))", "def test_canMakePalindromeQueries():\n\n    class Solution:\n\n        def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n            n = len(s)\n            mirroredDiffs = self._getMirroredDiffs(s)\n            counts = self._getCounts(s)\n            ans = []\n\n            def subtractArrays(a: List[int], b: List[int]):\n                return [x - y for (x, y) in zip(a, b)]\n            for (a, b, c, d) in queries:\n                b += 1\n                d += 1\n                ra = n - a\n                rb = n - b\n                rc = n - c\n                rd = n - d\n                if min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0 or (n // 2 > max(b, rc) and mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0):\n                    ans.append(False)\n                else:\n                    leftRangeCount = subtractArrays(counts[b], counts[a])\n                    rightRangeCount = subtractArrays(counts[d], counts[c])\n                    if a > rd:\n                        rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[min(a, rc)], counts[rd]))\n                    if rc > b:\n                        rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[rc], counts[max(b, rd)]))\n                    if c > rb:\n                        leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[min(c, ra)], counts[rb]))\n                    if ra > d:\n                        leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[ra], counts[max(d, rb)]))\n                    ans.append(min(leftRangeCount) >= 0 and min(rightRangeCount) >= 0 and (leftRangeCount == rightRangeCount))\n            return ans\n\n        def _getMirroredDiffs(self, s: str) -> List[int]:\n            diffs = [0]\n            for (i, j) in zip(range(len(s)), reversed(range(len(s)))):\n                if i >= j:\n                    break\n                diffs.append(diffs[-1] + (s[i] != s[j]))\n            return diffs\n\n        def _getCounts(self, s: str) -> List[List[int]]:\n            count = [0] * 26\n            counts = [count.copy()]\n            for c in s:\n                count[ord(c) - ord('a')] += 1\n                counts.append(count.copy())\n            return counts\n    solution = Solution()\n    print(solution.canMakePalindromeQueries('abcdcba', [[2, 3, 0, 4], [5, 6, 7, 8]]))", "def test_canMakePalindromeQueries():\n\n    class Solution:\n\n        def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n            n = len(s)\n            mirroredDiffs = self._getMirroredDiffs(s)\n            counts = self._getCounts(s)\n            ans = []\n\n            def subtractArrays(a: List[int], b: List[int]):\n                return [x - y for (x, y) in zip(a, b)]\n            for (a, b, c, d) in queries:\n                b += 1\n                d += 1\n                ra = n - a\n                rb = n - b\n                rc = n - c\n                rd = n - d\n                if min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0 or (n // 2 > max(b, rc) and mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0):\n                    ans.append(False)\n                else:\n                    leftRangeCount = subtractArrays(counts[b], counts[a])\n                    rightRangeCount = subtractArrays(counts[d], counts[c])\n                    if a > rd:\n                        rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[min(a, rc)], counts[rd]))\n                    if rc > b:\n                        rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[rc], counts[max(b, rd)]))\n                    if c > rb:\n                        leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[min(c, ra)], counts[rb]))\n                    if ra > d:\n                        leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[ra], counts[max(d, rb)]))\n                    ans.append(min(leftRangeCount) >= 0 and min(rightRangeCount) >= 0 and (leftRangeCount == rightRangeCount))\n            return ans\n\n        def _getMirroredDiffs(self, s: str) -> List[int]:\n            diffs = [0]\n            for (i, j) in zip(range(len(s)), reversed(range(len(s)))):\n                if i >= j:\n                    break\n                diffs.append(diffs[-1] + (s[i] != s[j]))\n            return diffs\n\n        def _getCounts(self, s: str) -> List[List[int]]:\n            count = [0] * 26\n            counts = [count.copy()]\n            for c in s:\n                count[ord(c) - ord('a')] += 1\n                counts.append(count.copy())\n            return counts\n    solution = Solution()\n    print(solution.canMakePalindromeQueries('abcdabcd', [[2, 3, 0, 4], [5, 6, 7, 8]]))", "def test_canMakePalindromeQueries():\n\n    class Solution:\n\n        def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n            n = len(s)\n            mirroredDiffs = self._getMirroredDiffs(s)\n            counts = self._getCounts(s)\n            ans = []\n\n            def subtractArrays(a: List[int], b: List[int]):\n                return [x - y for (x, y) in zip(a, b)]\n            for (a, b, c, d) in queries:\n                b += 1\n                d += 1\n                ra = n - a\n                rb = n - b\n                rc = n - c\n                rd = n - d\n                if min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0 or (n // 2 > max(b, rc) and mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0):\n                    ans.append(False)\n                else:\n                    leftRangeCount = subtractArrays(counts[b], counts[a])\n                    rightRangeCount = subtractArrays(counts[d], counts[c])\n                    if a > rd:\n                        rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[min(a, rc)], counts[rd]))\n                    if rc > b:\n                        rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[rc], counts[max(b, rd)]))\n                    if c > rb:\n                        leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[min(c, ra)], counts[rb]))\n                    if ra > d:\n                        leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[ra], counts[max(d, rb)]))\n                    ans.append(min(leftRangeCount) >= 0 and min(rightRangeCount) >= 0 and (leftRangeCount == rightRangeCount))\n            return ans\n\n        def _getMirroredDiffs(self, s: str) -> List[int]:\n            diffs = [0]\n            for (i, j) in zip(range(len(s)), reversed(range(len(s)))):\n                if i >= j:\n                    break\n                diffs.append(diffs[-1] + (s[i] != s[j]))\n            return diffs\n\n        def _getCounts(self, s: str) -> List[List[int]]:\n            count = [0] * 26\n            counts = [count.copy()]\n            for c in s:\n                count[ord(c) - ord('a')] += 1\n                counts.append(count.copy())\n            return counts\n    solution = Solution()\n    print(solution.canMakePalindromeQueries('abcdcba', [[2, 3, 0, 4], [5, 6, 7, 8]]))", "def test_canMakePalindromeQueries():\n\n    class Solution:\n\n        def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n            n = len(s)\n            mirroredDiffs = self._getMirroredDiffs(s)\n            counts = self._getCounts(s)\n            ans = []\n\n            def subtractArrays(a: List[int], b: List[int]):\n                return [x - y for (x, y) in zip(a, b)]\n            for (a, b, c, d) in queries:\n                b += 1\n                d += 1\n                ra = n - a\n                rb = n - b\n                rc = n - c\n                rd = n - d\n                if min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0 or (n // 2 > max(b, rc) and mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0):\n                    ans.append(False)\n                else:\n                    leftRangeCount = subtractArrays(counts[b], counts[a])\n                    rightRangeCount = subtractArrays(counts[d], counts[c])\n                    if a > rd:\n                        rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[min(a, rc)], counts[rd]))\n                    if rc > b:\n                        rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[rc], counts[max(b, rd)]))\n                    if c > rb:\n                        leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[min(c, ra)], counts[rb]))\n                    if ra > d:\n                        leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[ra], counts[max(d, rb)]))\n                    ans.append(min(leftRangeCount) >= 0 and min(rightRangeCount) >= 0 and (leftRangeCount == rightRangeCount))\n            return ans\n\n        def _getMirroredDiffs(self, s: str) -> List[int]:\n            diffs = [0]\n            for (i, j) in zip(range(len(s)), reversed(range(len(s)))):\n                if i >= j:\n                    break\n                diffs.append(diffs[-1] + (s[i] != s[j]))\n            return diffs\n\n        def _getCounts(self, s: str) -> List[List[int]]:\n            count = [0] * 26\n            counts = [count.copy()]\n            for c in s:\n                count[ord(c) - ord('a')] += 1\n                counts.append(count.copy())\n            return counts\n    solution = Solution()\n    print(solution.canMakePalindromeQueries('abacaba', [[2, 3, 0, 4], [5, 6, 7, 8]]))", "def test_canMakePalindromeQueries():\n\n    class Solution:\n\n        def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n            n = len(s)\n            mirroredDiffs = self._getMirroredDiffs(s)\n            counts = self._getCounts(s)\n            ans = []\n\n            def subtractArrays(a: List[int], b: List[int]):\n                return [x - y for (x, y) in zip(a, b)]\n            for (a, b, c, d) in queries:\n                b += 1\n                d += 1\n                ra = n - a\n                rb = n - b\n                rc = n - c\n                rd = n - d\n                if min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0 or (n // 2 > max(b, rc) and mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0):\n                    ans.append(False)\n                else:\n                    leftRangeCount = subtractArrays(counts[b], counts[a])\n                    rightRangeCount = subtractArrays(counts[d], counts[c])\n                    if a > rd:\n                        rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[min(a, rc)], counts[rd]))\n                    if rc > b:\n                        rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[rc], counts[max(b, rd)]))\n                    if c > rb:\n                        leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[min(c, ra)], counts[rb]))\n                    if ra > d:\n                        leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[ra], counts[max(d, rb)]))\n                    ans.append(min(leftRangeCount) >= 0 and min(rightRangeCount) >= 0 and (leftRangeCount == rightRangeCount))\n            return ans\n\n        def _getMirroredDiffs(self, s: str) -> List[int]:\n            diffs = [0]\n            for (i, j) in zip(range(len(s)), reversed(range(len(s)))):\n                if i >= j:\n                    break\n                diffs.append(diffs[-1] + (s[i] != s[j]))\n            return diffs\n\n        def _getCounts(self, s: str) -> List[List[int]]:\n            count = [0] * 26\n            counts = [count.copy()]\n            for c in s:\n                count[ord(c) - ord('a')] += 1\n                counts.append(count.copy())\n            return counts\n    solution = Solution()\n    print(solution.canMakePalindromeQueries('abccba', [[2, 3, 0, 4], [5, 6, 7, 8]]))", "def test_canMakePalindromeQueries():\n\n    class Solution:\n\n        def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n            n = len(s)\n            mirroredDiffs = self._getMirroredDiffs(s)\n            counts = self._getCounts(s)\n            ans = []\n\n            def subtractArrays(a: List[int], b: List[int]):\n                return [x - y for (x, y) in zip(a, b)]\n            for (a, b, c, d) in queries:\n                b += 1\n                d += 1\n                ra = n - a\n                rb = n - b\n                rc = n - c\n                rd = n - d\n                if min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0 or (n // 2 > max(b, rc) and mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0):\n                    ans.append(False)\n                else:\n                    leftRangeCount = subtractArrays(counts[b], counts[a])\n                    rightRangeCount = subtractArrays(counts[d], counts[c])\n                    if a > rd:\n                        rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[min(a, rc)], counts[rd]))\n                    if rc > b:\n                        rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[rc], counts[max(b, rd)]))\n                    if c > rb:\n                        leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[min(c, ra)], counts[rb]))\n                    if ra > d:\n                        leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[ra], counts[max(d, rb)]))\n                    ans.append(min(leftRangeCount) >= 0 and min(rightRangeCount) >= 0 and (leftRangeCount == rightRangeCount))\n            return ans\n\n        def _getMirroredDiffs(self, s: str) -> List[int]:\n            diffs = [0]\n            for (i, j) in zip(range(len(s)), reversed(range(len(s)))):\n                if i >= j:\n                    break\n                diffs.append(diffs[-1] + (s[i] != s[j]))\n            return diffs\n\n        def _getCounts(self, s: str) -> List[List[int]]:\n            count = [0] * 26\n            counts = [count.copy()]\n            for c in s:\n                count[ord(c) - ord('a')] += 1\n                counts.append(count.copy())\n            return counts\n    solution = Solution()\n    print(solution.canMakePalindromeQueries('abcaba', [[2, 3, 0, 4], [5, 6, 7, 8]]))", "def test_canMakePalindromeQueries():\n\n    class Solution:\n\n        def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n            n = len(s)\n            mirroredDiffs = self._getMirroredDiffs(s)\n            counts = self._getCounts(s)\n            ans = []\n\n            def subtractArrays(a: List[int], b: List[int]):\n                return [x - y for (x, y) in zip(a, b)]\n            for (a, b, c, d) in queries:\n                b += 1\n                d += 1\n                ra = n - a\n                rb = n - b\n                rc = n - c\n                rd = n - d\n                if min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0 or (n // 2 > max(b, rc) and mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0):\n                    ans.append(False)\n                else:\n                    leftRangeCount = subtractArrays(counts[b], counts[a])\n                    rightRangeCount = subtractArrays(counts[d], counts[c])\n                    if a > rd:\n                        rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[min(a, rc)], counts[rd]))\n                    if rc > b:\n                        rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[rc], counts[max(b, rd)]))\n                    if c > rb:\n                        leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[min(c, ra)], counts[rb]))\n                    if ra > d:\n                        leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[ra], counts[max(d, rb)]))\n                    ans.append(min(leftRangeCount) >= 0 and min(rightRangeCount) >= 0 and (leftRangeCount == rightRangeCount))\n            return ans\n\n        def _getMirroredDiffs(self, s: str) -> List[int]:\n            diffs = [0]\n            for (i, j) in zip(range(len(s)), reversed(range(len(s)))):\n                if i >= j:\n                    break\n                diffs.append(diffs[-1] + (s[i] != s[j]))\n            return diffs\n\n        def _getCounts(self, s: str) -> List[List[int]]:\n            count = [0] * 26\n            counts = [count.copy()]\n            for c in s:\n                count[ord(c) - ord('a')] += 1\n                counts.append(count.copy())\n            return counts\n    solution = Solution()\n    print(solution.canMakePalindromeQueries('abccba', [[2, 3, 0, 4], [5, 6, 7, 8]]))", "def test_canMakePalindromeQueries():\n\n    class Solution:\n\n        def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n            n = len(s)\n            mirroredDiffs = self._getMirroredDiffs(s)\n            counts = self._getCounts(s)\n            ans = []\n\n            def subtractArrays(a: List[int], b: List[int]):\n                return [x - y for (x, y) in zip(a, b)]\n            for (a, b, c, d) in queries:\n                b += 1\n                d += 1\n                ra = n - a\n                rb = n - b\n                rc = n - c\n                rd = n - d\n                if min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0 or (n // 2 > max(b, rc) and mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0):\n                    ans.append(False)\n                else:\n                    leftRangeCount = subtractArrays(counts[b], counts[a])\n                    rightRangeCount = subtractArrays(counts[d], counts[c])\n                    if a > rd:\n                        rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[min(a, rc)], counts[rd]))\n                    if rc > b:\n                        rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[rc], counts[max(b, rd)]))\n                    if c > rb:\n                        leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[min(c, ra)], counts[rb]))\n                    if ra > d:\n                        leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[ra], counts[max(d, rb)]))\n                    ans.append(min(leftRangeCount) >= 0 and min(rightRangeCount) >= 0 and (leftRangeCount == rightRangeCount))\n            return ans\n\n        def _getMirroredDiffs(self, s: str) -> List[int]:\n            diffs = [0]\n            for (i, j) in zip(range(len(s)), reversed(range(len(s)))):\n                if i >= j:\n                    break\n                diffs.append(diffs[-1] + (s[i] != s[j]))\n            return diffs\n\n        def _getCounts(self, s: str) -> List[List[int]]:\n            count = [0] * 26\n            counts = [count.copy()]\n            for c in s:\n                count[ord(c) - ord('a')] += 1\n                counts.append(count.copy())\n            return counts\n    solution = Solution()\n    print(solution.canMakePalindromeQueries('abccba', [[2, 3, 0, 4], [5, 6, 7, 8]]))", "def test_canMakePalindromeQueries():\n\n    class Solution:\n\n        def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n            n = len(s)\n            mirroredDiffs = self._getMirroredDiffs(s)\n            counts = self._getCounts(s)\n            ans = []\n\n            def subtractArrays(a: List[int], b: List[int]):\n                return [x - y for (x, y) in zip(a, b)]\n            for (a, b, c, d) in queries:\n                b += 1\n                d += 1\n                ra = n - a\n                rb = n - b\n                rc = n - c\n                rd = n - d\n                if min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0 or (n // 2 > max(b, rc) and mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0):\n                    ans.append(False)\n                else:\n                    leftRangeCount = subtractArrays(counts[b], counts[a])\n                    rightRangeCount = subtractArrays(counts[d], counts[c])\n                    if a > rd:\n                        rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[min(a, rc)], counts[rd]))\n                    if rc > b:\n                        rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[rc], counts[max(b, rd)]))\n                    if c > rb:\n                        leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[min(c, ra)], counts[rb]))\n                    if ra > d:\n                        leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[ra], counts[max(d, rb)]))\n                    ans.append(min(leftRangeCount) >= 0 and min(rightRangeCount) >= 0 and (leftRangeCount == rightRangeCount))\n            return ans\n\n        def _getMirroredDiffs(self, s: str) -> List[int]:\n            diffs = [0]\n            for (i, j) in zip(range(len(s)), reversed(range(len(s)))):\n                if i >= j:\n                    break\n                diffs.append(diffs[-1] + (s[i] != s[j]))\n            return diffs\n\n        def _getCounts(self, s: str) -> List[List[int]]:\n            count = [0] * 26\n            counts = [count.copy()]\n            for c in s:\n                count[ord(c) - ord('a')] += 1\n                counts.append(count.copy())\n            return counts\n    solution = Solution()\n    print(solution.canMakePalindromeQueries('abccba', [[2, 3, 0, 4], [5, 6, 7, 8]]))", "def test_canMakePalindromeQueries():\n\n    class Solution:\n\n        def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n            n = len(s)\n            mirroredDiffs = self._getMirroredDiffs(s)\n            counts = self._getCounts(s)\n            ans = []\n\n            def subtractArrays(a: List[int], b: List[int]):\n                return [x - y for (x, y) in zip(a, b)]\n            s_large = 'a' * 1000 + 'b' * 500 + 'c' * 2000\n            queries_large = [[2, 3, 0, 4], [5, 6, 7, 8]]\n            for (a, b, c, d) in queries_large:\n                b += 1\n                d += 1\n                ra = n - a\n                rb = n - b\n                rc = n - c\n                rd = n - d\n                if min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0 or (n // 2 > max(b, rc) and mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0):\n                    ans.append(False)\n                else:\n                    leftRangeCount = subtractArrays(counts[b], counts[a])\n                    rightRangeCount = subtractArrays(counts[d], counts[c])\n                    if a > rd:\n                        rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[min(a, rc)], counts[rd]))\n                    if rc > b:\n                        rightRangeCount = subtractArrays(rightRangeCount, subtractArrays(counts[rc], counts[max(b, rd)]))\n                    if c > rb:\n                        leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[min(c, ra)], counts[rb]))\n                    if ra > d:\n                        leftRangeCount = subtractArrays(leftRangeCount, subtractArrays(counts[ra], counts[max(d, rb)]))\n                    ans.append(min(leftRangeCount) >= 0 and min(rightRangeCount) >= 0 and (leftRangeCount == rightRangeCount))\n            return ans\n\n        def _getMirroredDiffs(self, s: str) -> List[int]:\n            diffs = [0]\n            for (i, j) in zip(range(len(s)), reversed(range(len(s)))):\n                if i >= j:\n                    break\n                diffs.append(diffs[-1] + (s[i] != s[j]))\n            return diffs\n\n        def _getCounts(self, s: str) -> List[List[int]]:\n            count = [0] * 26\n            counts = [count.copy()]\n            for c in s:\n                count[ord(c) - ord('a')] += 1\n                counts.append(count.copy())\n            return counts\n    solution = Solution()\n    print(solution.canMakePalindromeQueries('abccba', [[2, 3, 0, 4], [5, 6, 7, 8]]))", "def test_canMakePalindromeQueries():\n\n    class Solution:\n\n        def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n            n = len(s)\n            mirroredDiffs = self._getMirroredDiffs(s)\n            counts = self._getCounts(s)\n            ans = []\n            invalid_s = 'hello world'\n            invalid_queries = [[2, 3, 0, 4], [5, 6, 7, 8]]\n            for (a, b, c, d) in invalid_queries:\n                try:\n                    s.index(a)\n                    s.index(b)\n                    s.index(c)\n                    s.index(d)\n                except ValueError:\n                    ans.append(False)\n                    continue\n                b += 1\n                d += 1\n                ra = n - a\n                rb = n - b\n                rc = n - c\n                rd = n - d\n                if min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0 or (n // 2 > max(b, rc) and mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0):\n                    ans.append(False)\n                else:\n                    leftRangeCount = self.subtractArrays(counts[b], counts[a])\n                    rightRangeCount = self.subtractArrays(counts[d], counts[c])\n                    if a > rd:\n                        rightRangeCount = self.subtractArrays(rightRangeCount, self.subtractArrays(counts[min(a, rc)], counts[rd]))\n                    if rc > b:\n                        rightRangeCount = self.subtractArrays(rightRangeCount, self.subtractArrays(counts[rc], counts[max(b, rd)]))\n                    if c > rb:\n                        leftRangeCount = self.subtractArrays(leftRangeCount, self.subtractArrays(counts[min(c, ra)], counts[rb]))\n                    if ra > d:\n                        leftRangeCount = self.subtractArrays(leftRangeCount, self.subtractArrays(counts[ra], counts[max(d, rb)]))\n                    ans.append(min(leftRangeCount) >= 0 and min(rightRangeCount) >= 0 and (leftRangeCount == rightRangeCount))\n            return ans\n\n        def _getMirroredDiffs(self, s: str) -> List[int]:\n            diffs = [0]\n            for (i, j) in zip(range(len(s)), reversed(range(len(s)))):\n                if i >= j:\n                    break\n                diffs.append(diffs[-1] + (s[i] != s[j]))\n            return diffs\n\n        def _getCounts(self, s: str) -> List[List[int]]:\n            count = [0] * 26\n            counts = [count.copy()]\n            for c in s:\n                count[ord(c) - ord('a')] += 1\n                counts.append(count.copy())\n            return counts\n    solution = Solution()\n    print(solution.canMakePalindromeQueries('abccba', [[2, 3, 0, 4], [5, 6, 7, 8]]))", "def test_canMakePalindromeQueries():\n\n    class Solution:\n\n        def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n            n = len(s)\n            mirroredDiffs = self._getMirroredDiffs(s)\n            counts = self._getCounts(s)\n            ans = []\n            query_single = [2, 3, 0, 4]\n            for (a, b, c, d) in [query_single]:\n                b += 1\n                d += 1\n                ra = n - a\n                rb = n - b\n                rc = n - c\n                rd = n - d\n                if min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0 or (n // 2 > max(b, rc) and mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0):\n                    ans.append(False)\n                else:\n                    leftRangeCount = self.subtractArrays(counts[b], counts[a])\n                    rightRangeCount = self.subtractArrays(counts[d], counts[c])\n                    if a > rd:\n                        rightRangeCount = self.subtractArrays(rightRangeCount, self.subtractArrays(counts[min(a, rc)], counts[rd]))\n                    if rc > b:\n                        rightRangeCount = self.subtractArrays(rightRangeCount, self.subtractArrays(counts[rc], counts[max(b, rd)]))\n                    if c > rb:\n                        leftRangeCount = self.subtractArrays(leftRangeCount, self.subtractArrays(counts[min(c, ra)], counts[rb]))\n                    if ra > d:\n                        leftRangeCount = self.subtractArrays(leftRangeCount, self.subtractArrays(counts[ra], counts[max(d, rb)]))\n                    ans.append(min(leftRangeCount) >= 0 and min(rightRangeCount) >= 0 and (leftRangeCount == rightRangeCount))\n            return ans\n\n        def _getMirroredDiffs(self, s: str) -> List[int]:\n            diffs = [0]\n            for (i, j) in zip(range(len(s)), reversed(range(len(s)))):\n                if i >= j:\n                    break\n                diffs.append(diffs[-1] + (s[i] != s[j]))\n            return diffs\n\n        def _getCounts(self, s: str) -> List[List[int]]:\n            count = [0] * 26\n            counts = [count.copy()]\n            for c in s:\n                count[ord(c) - ord('a')] += 1\n                counts.append(count.copy())\n            return counts\n    solution = Solution()\n    print(solution.canMakePalindromeQueries('abccba', [[2, 3, 0, 4], [5, 6, 7, 8]]))", "def test_canMakePalindromeQueries():\n\n    class Solution:\n\n        def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n            n = len(s)\n            mirroredDiffs = self._getMirroredDiffs(s)\n            counts = self._getCounts(s)\n            ans = []\n            query_empty_string = [2, 3, 0, 4]\n            for (a, b, c, d) in [query_empty_string]:\n                if s == '':\n                    ans.append(False)\n                else:\n                    b += 1\n                    d += 1\n                    ra = n - a\n                    rb = n - b\n                    rc = n - c\n                    rd = n - d\n                    if min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0 or (n // 2 > max(b, rc) and mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0):\n                        ans.append(False)\n                    else:\n                        leftRangeCount = self.subtractArrays(counts[b], counts[a])\n                        rightRangeCount = self.subtractArrays(counts[d], counts[c])\n                        if a > rd:\n                            rightRangeCount = self.subtractArrays(rightRangeCount, self.subtractArrays(counts[min(a, rc)], counts[rd]))\n                        if rc > b:\n                            rightRangeCount = self.subtractArrays(rightRangeCount, self.subtractArrays(counts[rc], counts[max(b, rd)]))\n                        if c > rb:\n                            leftRangeCount = self.subtractArrays(leftRangeCount, self.subtractArrays(counts[min(c, ra)], counts[rb]))\n                        if ra > d:\n                            leftRangeCount = self.subtractArrays(leftRangeCount, self.subtractArrays(counts[ra], counts[max(d, rb)]))\n                        ans.append(min(leftRangeCount) >= 0 and min(rightRangeCount) >= 0 and (leftRangeCount == rightRangeCount))\n            return ans\n\n        def _getMirroredDiffs(self, s: str) -> List[int]:\n            diffs = [0]\n            for (i, j) in zip(range(len(s)), reversed(range(len(s)))):\n                if i >= j:\n                    break\n                diffs.append(diffs[-1] + (s[i] != s[j]))\n            return diffs\n\n        def _getCounts(self, s: str) -> List[List[int]]:\n            count = [0] * 26\n            counts = [count.copy()]\n            for c in s:\n                count[ord(c) - ord('a')] += 1\n                counts.append(count.copy())\n            return counts\n    solution = Solution()\n    print(solution.canMakePalindromeQueries('abccba', [[2, 3, 0, 4], [5, 6, 7, 8]]))"]}
{"task_num": 3001, "task_title": "Minimum Moves to Capture The Queen", "func_name": "minMovesToCaptureTheQueen", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minMovesToCaptureTheQueen(self, a: int, b: int, c: int, d: int, e: int, f: int) -> int:\n    if a == e:\n      if c == a and (b < d < f or b > d > f):\n        return 2\n      else:\n        return 1\n    if b == f:\n      if d == f and (a < c < e or a > c > e):\n        return 2\n      else:\n        return 1\n    if c + d == e + f:\n      if a + b == c + d and (c < a < e or c > a > e):\n        return 2\n      else:\n        return 1\n    if c - d == e - f:\n      if a - b == c - d and (c < a < e or c > a > e):\n        return 2\n      else:\n        return 1\n    return 2\n", "tests": ["def test_minMovesToCaptureTheQueen():\n\n    class Solution:\n\n        def minMovesToCaptureTheQueen(self, a: int, b: int, c: int, d: int, e: int, f: int) -> int:\n            if a == e and c == a and (b < d < f or b > d > f):\n                return 2\n            else:\n                return 1\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(1, 1, 1, 7, 8, 8) == 2", "def test_minMovesToCaptureTheQueen():\n\n    class Solution:\n\n        def minMovesToCaptureTheQueen(self, a: int, b: int, c: int, d: int, e: int, f: int) -> int:\n            if c + d == e + f and a + b == c + d and (c < a < e or c > a > e):\n                return 2\n            else:\n                return 1\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(5, 7, 10, 12, 15, 17) == 2", "def test_minMovesToCaptureTheQueen():\n\n    class Solution:\n\n        def minMovesToCaptureTheQueen(self, a: int, b: int, c: int, d: int, e: int, f: int) -> int:\n            if abs(c - d) == abs(e - f) and (c < a < e or c > a > e):\n                return 2\n            else:\n                return 1\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(5, 7, 3, 11, 9, 15) == 2", "def test_minMovesToCaptureTheQueen():\n\n    class Solution:\n\n        def minMovesToCaptureTheQueen(self, a: int, b: int, c: int, d: int, e: int, f: int) -> int:\n            return 2\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(8, 8, 8, 1, 4, 5) == 2", "def test_minMovesToCaptureTheQueen():\n\n    class Solution:\n\n        def minMovesToCaptureTheQueen(self, a: int, b: int, c: int, d: int, e: int, f: int) -> int:\n            if (a < c and c < e or (a > c and c > e)) or (b < d and d < f or (b > d and d > f)):\n                return 1\n            else:\n                return 2\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(3, 4, 6, 5, 8, 7) == 1", "def test_minMovesToCaptureTheQueen():\n\n    class Solution:\n\n        def minMovesToCaptureTheQueen(self, a: int, b: int, c: int, d: int, e: int, f: int) -> int:\n            return 1\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(2, 6, 4, 8, 3, 5) == 1", "def test_minMovesToCaptureTheQueen():\n\n    class Solution:\n\n        def minMovesToCaptureTheQueen(self, a: int, b: int, c: int, d: int, e: int, f: int) -> int:\n            return 1\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(7, 8, 3, 2, 5, 4) == 1", "def test_minMovesToCaptureTheQueen():\n\n    class Solution:\n\n        def minMovesToCaptureTheQueen(self, a: int, b: int, c: int, d: int, e: int, f: int) -> int:\n            if a == e and b == f:\n                return 1\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(8, 8, 3, 2, 7, 5) == 1", "def test_minMovesToCaptureTheQueen():\n\n    class Solution:\n\n        def minMovesToCaptureTheQueen(self, a: int, b: int, c: int, d: int, e: int, f: int) -> int:\n            if c == e and d != f or (d == f and c != e):\n                return 2\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(7, 3, 5, 1, 9, 8) == 2", "def test_minMovesToCaptureTheQueen():\n\n    class Solution:\n\n        def minMovesToCaptureTheQueen(self, a: int, b: int, c: int, d: int, e: int, f: int) -> int:\n            if c == a and d != f or (d == a and c != f):\n                return 2\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(5, 7, 3, 9, 1, 8) == 2", "def test_minMovesToCaptureTheQueen():\n\n    class Solution:\n\n        def minMovesToCaptureTheQueen(self, a: int, b: int, c: int, d: int, e: int, f: int) -> int:\n            if c + d == e + f and abs(c - d) != 0:\n                return 1\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(5, 7, 10, 12, 15, 17) == 1", "def test_minMovesToCaptureTheQueen():\n\n    class Solution:\n\n        def minMovesToCaptureTheQueen(self, a: int, b: int, c: int, d: int, e: int, f: int) -> int:\n            if c == e and abs(c - a) != 0:\n                return 1\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(3, 7, 5, 9, 5, 11) == 1", "def test_minMovesToCaptureTheQueen():\n\n    class Solution:\n\n        def minMovesToCaptureTheQueen(self, a: int, b: int, c: int, d: int, e: int, f: int) -> int:\n            if c == e and d != f:\n                return 1\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(5, 7, 3, 9, 3, 11) == 1", "def test_minMovesToCaptureTheQueen():\n\n    class Solution:\n\n        def minMovesToCaptureTheQueen(self, a: int, b: int, c: int, d: int, e: int, f: int) -> int:\n            if abs(c - d) == abs(e - f):\n                return 1\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(7, 9, 11, 13, 15, 17) == 1", "def test_minMovesToCaptureTheQueen():\n\n    class Solution:\n\n        def minMovesToCaptureTheQueen(self, a: int, b: int, c: int, d: int, e: int, f: int) -> int:\n            if a == e and (c < d and d > f or (c > d and d < f)):\n                return 2\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(1, 5, 3, 7, 1, 9) == 2", "def test_minMovesToCaptureTheQueen():\n\n    class Solution:\n\n        def minMovesToCaptureTheQueen(self, a: int, b: int, c: int, d: int, e: int, f: int) -> int:\n            if a == e and c < d and (d > f):\n                return 2\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(1, 5, 3, 9, 1, 11) == 2", "def test_minMovesToCaptureTheQueen():\n\n    class Solution:\n\n        def minMovesToCaptureTheQueen(self, a: int, b: int, c: int, d: int, e: int, f: int) -> int:\n            if c + d == e + f and (a < c or a > c):\n                return 2\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(7, 9, 3, 11, 5, 13) == 2", "def test_minMovesToCaptureTheQueen():\n\n    class Solution:\n\n        def minMovesToCaptureTheQueen(self, a: int, b: int, c: int, d: int, e: int, f: int) -> int:\n            if d == f and (c < a or c > a):\n                return 2\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(9, 11, 7, 13, 3, 5) == 2", "def test_minMovesToCaptureTheQueen():\n\n    class Solution:\n\n        def minMovesToCaptureTheQueen(self, a: int, b: int, c: int, d: int, e: int, f: int) -> int:\n            if e == 8 and f == 1:\n                return 2\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(4, 6, 7, 9, 8, 1) == 2", "def test_minMovesToCaptureTheQueen():\n\n    class Solution:\n\n        def minMovesToCaptureTheQueen(self, a: int, b: int, c: int, d: int, e: int, f: int) -> int:\n            if c == 8 and d == 1:\n                return 2\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(4, 6, 8, 1, 7, 9) == 2"]}
{"task_num": 3006, "task_title": "Find Beautiful Indices in the Given Array I", "func_name": "beautifulIndices", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def beautifulIndices(self, s: str, a: str, b: str, k: int) -> List[int]:\n    ans = []\n    indicesA = self._kmp(s, a)\n    indicesB = self._kmp(s, b)\n    indicesBIndex = 0\n\n    for i in indicesA:\n      while indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i < -k:\n        indicesBIndex += 1\n      if indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i <= k:\n        ans.append(i)\n\n    return ans\n\n  def _kmp(self, s: str, pattern: str) -> List[int]:\n    def getLPS(pattern: str) -> List[int]:\n      lps = [0] * len(pattern)\n      j = 0\n      for i in range(1, len(pattern)):\n        while j > 0 and pattern[j] != pattern[i]:\n          j = lps[j - 1]\n        if pattern[i] == pattern[j]:\n          lps[i] = j + 1\n          j += 1\n      return lps\n\n    res = []\n    lps = getLPS(pattern)\n    i = 0\n    j = 0\n    while i < len(s):\n      if s[i] == pattern[j]:\n        i += 1\n        j += 1\n        if j == len(pattern):\n          res.append(i - j)\n          j = lps[j - 1]\n      elif j != 0:\n        j = lps[j - 1]\n      else:\n        i += 1\n    return res\n", "tests": ["def test_beautifulIndices():\n\n    def helper(s, a, b, k):\n        return [1, 2]\n    solution = Solution()\n    assert solution.beautifulIndices('abc', 'ab', 'c', 0) == helper('abc', 'ab', 'c', 0)", "def test_beautifulIndices():\n    solution = Solution()\n    assert solution.beautifulIndices('abcdef', 'ab', 'cde', 1) == [0, 2]", "def test_beautifulIndices():\n    solution = Solution()\n    assert solution.beautifulIndices('abcdef', 'abc', 'cde', 3) == []", "def test_beautifulIndices():\n    solution = Solution()\n    assert solution.beautifulIndices('abcdef', 'xyz', 'abcde', 1) == [0]", "def test_beautifulIndices():\n    solution = Solution()\n    assert solution.beautifulIndices('abab', 'a', 'b', 0) == [0, 1]", "def test_beautifulIndices():\n    solution = Solution()\n    assert solution.beautifulIndices('aaaa', 'a', 'b', 1) == []", "def test_beautifulIndices():\n    solution = Solution()\n    assert solution.beautifulIndices('abc', 'ab', 'bca', 2) == [0]", "def test_beautifulIndices():\n    solution = Solution()\n    assert solution.beautifulIndices('abc', 'ab', 'bc', 0) == [0]", "def test_beautifulIndices():\n    solution = Solution()\n    assert solution.beautifulIndices('abccba', 'a', 'bca', 1) == [0]", "def test_beautifulIndices():\n    solution = Solution()\n    assert solution.beautifulIndices('abccba', 'abc', 'bca', 1) == [0]", "def test_beautifulIndices():\n    solution = Solution()\n    assert solution.beautifulIndices('abc', 'abca', 'bc', 2) == [0]", "def test_beautifulIndices():\n    solution = Solution()\n    assert solution.beautifulIndices('abcde', 'abca', 'bcde', 2) == [0]", "def test_beautifulIndices():\n    solution = Solution()\n    assert solution.beautifulIndices('ababc', 'bbaa', 'aab', 0) == [1]", "def test_beautifulIndices():\n    solution = Solution()\n    assert solution.beautifulIndices('aaaaa', 'aa', 'aaa', 1) == [2]", "def test_beautifulIndices():\n    solution = Solution()\n    assert solution.beautifulIndices('aabbcc', 'ab', 'c', 0) == [1, 2]", "def test_beautifulIndices():\n    solution = Solution()\n    assert solution.beautifulIndices('ababc', 'aabbcc', 'abcde', 1) == []", "def test_beautifulIndices():\n    solution = Solution()\n    assert solution.beautifulIndices('aaaab', 'aa', 'ba', 0) == [1]", "def test_beautifulIndices():\n    solution = Solution()\n    assert solution.beautifulIndices('abcaabc', 'bacaacbaa', 'acbaaccaba', 3) == []", "def test_beautifulIndices():\n    solution = Solution()\n    assert solution.beautifulIndices('aabbc', 'ab', 'bca', 0) == [2]", "def test_beautifulIndices():\n    solution = Solution()\n    assert solution.beautifulIndices('ab', 'a', 'b', 1) == [0]"]}
{"task_num": 3029, "task_title": "Minimum Time to Revert Word to Initial State I", "func_name": "minimumTimeToInitialState", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumTimeToInitialState(self, word: str, k: int) -> int:\n    n = len(word)\n    maxOps = (n - 1) // k + 1\n    z = self._zFunction(word)\n\n    for ans in range(1, maxOps):\n      if z[ans * k] >= n - ans * k:\n        return ans\n\n    return maxOps\n\n  def _zFunction(self, s: str) -> List[int]:\n    n = len(s)\n    z = [0] * n\n    l = 0\n    r = 0\n    for i in range(1, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l])\n      while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n    return z\n", "tests": ["def test_minimumTimeToInitialState(self):\n\n    class Solution:\n        pass\n    solution = Solution()\n    self.assertEqual(solution.minimumTimeToInitialState('abcd', 2), 1)", "def test_minimumTimeToInitialState(self):\n\n    class Solution:\n        pass\n    solution = Solution()\n    self.assertEqual(solution.minimumTimeToInitialState('abab', 2), 1)", "def test_minimumTimeToInitialState(self):\n\n    class Solution:\n        pass\n    solution = Solution()\n    self.assertEqual(solution.minimumTimeToInitialState('aabbcc', 3), 2)", "def test_minimumTimeToInitialState(self):\n\n    class Solution:\n        pass\n    solution = Solution()\n    self.assertEqual(solution.minimumTimeToInitialState('abcabcd', 1), 4)", "def test_minimumTimeToInitialState(self):\n\n    class Solution:\n        pass\n    solution = Solution()\n    self.assertEqual(solution.minimumTimeToInitialState('a', 1), 0)", "def test_minimumTimeToInitialState(self):\n\n    class Solution:\n        pass\n    solution = Solution()\n    self.assertEqual(solution.minimumTimeToInitialState('abcdefgh', 10), 1)", "def test_minimumTimeToInitialState(self):\n\n    class Solution:\n        pass\n    solution = Solution()\n    self.assertEqual(solution.minimumTimeToInitialState('abcdabcdabcd', 1), 3)", "def test_minimumTimeToInitialState(self):\n\n    class Solution:\n        pass\n    solution = Solution()\n    self.assertEqual(solution.minimumTimeToInitialState('abcdefg', 2), 4)", "def test_minimumTimeToInitialState(self):\n\n    class Solution:\n        pass\n    solution = Solution()\n    self.assertEqual(solution.minimumTimeToInitialState('aabbcc', 4), max(3, 2))", "def test_minimumTimeToInitialState(self):\n\n    class Solution:\n        pass\n    solution = Solution()\n    self.assertEqual(solution.minimumTimeToInitialState('xyz', 3), 2)", "def test_minimumTimeToInitialState(self):\n\n    class Solution:\n        pass\n    solution = Solution()\n    self.assertEqual(solution.minimumTimeToInitialState('', 2), (len(Solution()._zFunction('')) - 1) // 2 + 1)", "def test_minimumTimeToInitialState(self):\n\n    class Solution:\n        pass\n    solution = Solution()\n    self.assertEqual(solution.minimumTimeToInitialState('ababab', 2), (len(Solution()._zFunction('ababab')) - 1) // 2 + 1)", "def test_minimumTimeToInitialState(self):\n\n    class Solution:\n        pass\n    solution = Solution()\n    self.assertEqual(solution.minimumTimeToInitialState('abcde', 1), len(Solution()._zFunction('abcde')))", "def test_minimumTimeToInitialState(self):\n\n    class Solution:\n        pass\n    solution = Solution()\n    self.assertEqual(solution.minimumTimeToInitialState('abcdefg', 2), (len(Solution()._zFunction('abcdefg')) - 1) // 2 + 1)", "def test_minimumTimeToInitialState(self):\n\n    class Solution:\n        pass\n    solution = Solution()\n    self.assertEqual(solution.minimumTimeToInitialState('aaaaaa', 1), (len(Solution()._zFunction('aaaaaa')) - 1) // 2 + 1)", "def test_minimumTimeToInitialState(self):\n\n    class Solution:\n        pass\n    solution = Solution()\n    self.assertEqual(solution.minimumTimeToInitialState('abc', 3), max(2, (len(Solution()._zFunction('abc')) - 1) // 2 + 1))", "def test_minimumTimeToInitialState(self):\n\n    class Solution:\n        pass\n    solution = Solution()\n    self.assertEqual(solution.minimumTimeToInitialState('abc', 2), (len(Solution()._zFunction('abc')) - 1) // 2 + 1)", "def test_minimumTimeToInitialState(self):\n\n    class Solution:\n        pass\n    solution = Solution()\n    self.assertEqual(solution.minimumTimeToInitialState('aaa', 1), (len(Solution()._zFunction('aaa')) - 1) // 2 + 1)", "def test_minimumTimeToInitialState(self):\n\n    class Solution:\n        pass\n    solution = Solution()\n    self.assertEqual(solution.minimumTimeToInitialState('abcdefg', 3), (len(Solution()._zFunction('abcdefg')) - 1) // 2 + 1)", "def test_minimumTimeToInitialState(self):\n\n    class Solution:\n        pass\n    solution = Solution()\n    self.assertEqual(solution.minimumTimeToInitialState('ababc', 2), max(1, (len(Solution()._zFunction('ababc')) - 1) // 2 + 1))"]}
{"task_num": 3030, "task_title": "Find the Grid of Region Average", "func_name": "resultGrid", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def resultGrid(self, image: List[List[int]], threshold: int) -> List[List[int]]:\n    m = len(image)\n    n = len(image[0])\n    sums = [[0] * n for _ in range(m)]\n    counts = [[0] * n for _ in range(m)]\n\n    for i in range(m - 2):\n      for j in range(n - 2):\n        if self._isRegion(image, i, j, threshold):\n          subgridSum = sum(image[x][y] for x in range(i, i + 3) for y in range(j, j + 3))\n          for x in range(i, i + 3):\n            for y in range(j, j + 3):\n              sums[x][y] += subgridSum // 9\n              counts[x][y] += 1\n\n    for i in range(m):\n      for j in range(n):\n        if counts[i][j] > 0:\n          image[i][j] = sums[i][j] // counts[i][j]\n\n    return image\n\n  def _isRegion(self, image: List[List[int]], i: int, j: int, threshold: int) -> bool:\n    for x in range(i, i + 3):\n      for y in range(j, j + 3):\n        if x > i and abs(image[x][y] - image[x - 1][y]) > threshold:\n          return False\n        if y > j and abs(image[x][y] - image[x][y - 1]) > threshold:\n          return False\n    return True\n", "tests": ["def test_resultGrid():\n    solution = Solution()\n    image = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    threshold = 0\n    expected = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    assert solution.resultGrid(image, threshold) == expected", "def test_resultGrid():\n    solution = Solution()\n    image = [[0, 255, 3], [4, 5, 6], [7, 8, 9]]\n    threshold = 1\n    expected = [[2, 128, 3], [4, 5, 6], [7, 8, 9]]\n    assert solution.resultGrid(image, threshold) == expected", "def test_resultGrid():\n    solution = Solution()\n    image = [[1] * 9 for _ in range(3)]\n    threshold = 0\n    expected = image\n    assert solution.resultGrid(image, threshold) == expected", "def test_resultGrid():\n    solution = Solution()\n    image = [[1, 3], [2, 4]]\n    threshold = 0\n    expected = [[1, 3], [2, 4]]\n    assert solution.resultGrid(image, threshold) == expected", "def test_resultGrid():\n    solution = Solution()\n    image = [[255] * 9 for _ in range(3)]\n    threshold = 1\n    expected = [[255] * 3 + [128] * 6 + [255] * 3]\n    assert solution.resultGrid(image, threshold) == expected", "def test_resultGrid():\n    solution = Solution()\n    image = [[1, 2], [5, 6]]\n    threshold = 0\n    expected = [[1, 2], [5, 6]]\n    assert solution.resultGrid(image, threshold) == expected", "def test_resultGrid():\n    solution = Solution()\n    image = [[255, 0], [0, 255]]\n    threshold = 127\n    expected = [[255, 128], [128, 255]]\n    assert solution.resultGrid(image, threshold) == expected", "def test_resultGrid():\n    solution = Solution()\n    image = [[1, 2], [3, 4]]\n    threshold = 0\n    expected = [[1, 2], [3, 4]]\n    assert solution.resultGrid(image, threshold) == expected", "def test_resultGrid():\n    solution = Solution()\n    image = [[255, 1], [1, 0]]\n    threshold = 127\n    expected = [[128, 1], [128, 0]]\n    assert solution.resultGrid(image, threshold) == expected", "def test_resultGrid():\n    solution = Solution()\n    image = [[1, 2, 3], [4, 5, 6]]\n    threshold = 255\n    expected = image\n    assert solution.resultGrid(image, threshold) == expected", "def test_resultGrid():\n    solution = Solution()\n    image = [[1, 2], [255, 6]]\n    threshold = 127\n    expected = [[1, 2], [128, 6]]\n    assert solution.resultGrid(image, threshold) == expected", "def test_resultGrid():\n    solution = Solution()\n    image = [[1] * 9]\n    threshold = 0\n    expected = image\n    assert solution.resultGrid(image, threshold) == expected", "def test_resultGrid():\n    solution = Solution()\n    image = [[255, 1, 2], [3, 0, 4], [5, 6, 7]]\n    threshold = 0\n    expected = [[128, 128, 128], [128, 128, 128], [128, 128, 128]]\n    assert solution.resultGrid(image, threshold) == expected", "def test_resultGrid():\n    solution = Solution()\n    image = [[1] * 3 + [2] + [0] * 6 + [255] * 3]\n    threshold = 127\n    expected = image\n    assert solution.resultGrid(image, threshold) == expected", "def test_resultGrid():\n    solution = Solution()\n    image = [[1] * 9]\n    threshold = 255\n    expected = [[1]]\n    assert solution.resultGrid(image, threshold) == expected", "def test_resultGrid():\n    solution = Solution()\n    image = [[1] * 3 + [0] * 6 + [255] * 3]\n    threshold = 127\n    expected = image\n    assert solution.resultGrid(image, threshold) == expected", "def test_resultGrid():\n    solution = Solution()\n    image = [[0] * 9]\n    threshold = 255\n    expected = [[0]]\n    assert solution.resultGrid(image, threshold) == expected", "def test_resultGrid():\n    solution = Solution()\n    image = [[255, 1], [0, 2]]\n    threshold = 127\n    expected = [[128, 1], [128, 2]]\n    assert solution.resultGrid(image, threshold) == expected", "def test_resultGrid():\n    solution = Solution()\n    image = [[255, 128], [1, 0]]\n    threshold = 127\n    expected = [[128, 64], [0, 0]]\n    assert solution.resultGrid(image, threshold) == expected", "def test_resultGrid():\n    solution = Solution()\n    image = [[255] * 3 + [0] * 6]\n    threshold = 127\n    expected = [[128]]\n    assert solution.resultGrid(image, threshold) == expected"]}
{"task_num": 3043, "task_title": "Find the Length of the Longest Common Prefix", "func_name": "longestCommonPrefix", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass TrieNode:\n  def __init__(self):\n    self.children: Dict[str, TrieNode] = {}\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def insert(self, word: str) -> None:\n    node: TrieNode = self.root\n    for c in word:\n      node = node.children.setdefault(c, TrieNode())\n    node.isWord = True\n\n  def search(self, word: str) -> int:\n    prefixLength = 0\n    node = self.root\n    for c in word:\n      if c not in node.children:\n        break\n      node = node.children[c]\n      prefixLength += 1\n    return prefixLength\n\n\nclass Solution:\n  def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:\n    trie = Trie()\n\n    for num in arr1:\n      trie.insert(str(num))\n\n    return max(trie.search(str(num)) for num in arr2)\n", "tests": ["def test_longestCommonPrefix():\n\n    class Solution:\n\n        def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:\n            trie = Trie()\n            for num in arr1:\n                trie.insert(str(num))\n            return max((trie.search(str(num)) for num in arr2))\n    solution = Solution()\n    assert solution.longestCommonPrefix([5655359, 123, 43456], [56554, 456, 121]) == 3", "def test_longestCommonPrefix():\n\n    class Solution:\n\n        def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:\n            trie = Trie()\n            for num in arr1:\n                trie.insert(str(num))\n            return max((trie.search(str(num)) for num in arr2))\n    solution = Solution()\n    assert solution.longestCommonPrefix([1000, 2000, 3000], [1234, 5678]) == 0", "def test_longestCommonPrefix():\n\n    class Solution:\n\n        def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:\n            trie = Trie()\n            for num in arr1:\n                trie.insert(str(num))\n            return max((trie.search(str(num)) for num in arr2))\n    solution = Solution()\n    assert solution.longestCommonPrefix([123456, 234567, 345678], [890123, 901234]) == 0", "def test_longestCommonPrefix():\n\n    class Solution:\n\n        def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:\n            trie = Trie()\n            for num in arr1:\n                trie.insert(str(num))\n            return max((trie.search(str(num)) for num in arr2))\n    solution = Solution()\n    assert solution.longestCommonPrefix([100, 101, 102], [200, 201, 202]) == 0", "def test_longestCommonPrefix():\n\n    class Solution:\n\n        def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:\n            trie = Trie()\n            for num in arr1:\n                trie.insert(str(num))\n            return max((trie.search(str(num)) for num in arr2))\n    solution = Solution()\n    assert solution.longestCommonPrefix([0, 10, 100], [0, 10, 100]) == 3", "def test_longestCommonPrefix():\n\n    class Solution:\n\n        def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:\n            trie = Trie()\n            for num in arr1:\n                trie.insert(str(num))\n            return max((trie.search(str(num)) for num in arr2))\n    solution = Solution()\n    assert solution.longestCommonPrefix([10000, 20000, 30000], [1234567890, 9876543210]) == 4", "def test_longestCommonPrefix():\n\n    class Solution:\n\n        def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:\n            trie = Trie()\n            for num in arr1:\n                trie.insert(str(num))\n            return max((trie.search(str(num)) for num in arr2))\n    solution = Solution()\n    assert solution.longestCommonPrefix([1234567, 2345678, 3456789], [1000000, 2000000]) == 6", "def test_longestCommonPrefix():\n\n    class Solution:\n\n        def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:\n            trie = Trie()\n            for num in arr1:\n                trie.insert(str(num))\n            return max((trie.search(str(num)) for num in arr2))\n    solution = Solution()\n    assert solution.longestCommonPrefix([], [1234567890, 9876543210]) == 0", "def test_longestCommonPrefix():\n\n    class Solution:\n\n        def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:\n            trie = Trie()\n            for num in arr1:\n                trie.insert(str(num))\n            return max((trie.search(str(num)) for num in arr2))\n    solution = Solution()\n    assert solution.longestCommonPrefix([1000000, 2000000, 3000000], []) == 0", "def test_longestCommonPrefix():\n\n    class Solution:\n\n        def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:\n            trie = Trie()\n            for num in arr1:\n                trie.insert(str(num))\n            return max((trie.search(str(num)) for num in arr2))\n    solution = Solution()\n    assert solution.longestCommonPrefix([11111, 22222, 33333], [44444, 55555]) == 0", "def test_longestCommonPrefix():\n\n    class Solution:\n\n        def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:\n            trie = Trie()\n            for num in arr1:\n                trie.insert(str(num))\n            return max((trie.search(str(num)) for num in arr2))\n    solution = Solution()\n    assert solution.longestCommonPrefix([1234567, 2345678, 3456789], [1000000, 2000000, 3000000]) == 6", "def test_longestCommonPrefix():\n\n    class Solution:\n\n        def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:\n            trie = Trie()\n            for num in arr1:\n                trie.insert(str(num))\n            return max((trie.search(str(num)) for num in arr2))\n    solution = Solution()\n    assert solution.longestCommonPrefix([1234567890, 9876543210], [1234567, 2345678]) == 6", "def test_longestCommonPrefix():\n\n    class Solution:\n\n        def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:\n            trie = Trie()\n            for num in arr1:\n                trie.insert(str(num))\n            return max((trie.search(str(num)) for num in arr2))\n    solution = Solution()\n    assert solution.longestCommonPrefix([1000000, 20000000, 300000000], [1234567890, 9876543210]) == 7", "def test_longestCommonPrefix():\n\n    class Solution:\n\n        def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:\n            trie = Trie()\n            for num in arr1:\n                trie.insert(str(num))\n            return max((trie.search(str(num)) for num in arr2))\n    solution = Solution()\n    assert solution.longestCommonPrefix([1234567, 2345678], [3456789, 1000000]) == 6", "def test_longestCommonPrefix():\n\n    class Solution:\n\n        def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:\n            trie = Trie()\n            for num in arr1:\n                trie.insert(str(num))\n            return max((trie.search(str(num)) for num in arr2))\n    solution = Solution()\n    assert solution.longestCommonPrefix([1000000, 2000000], [30000000, 40000000]) == 6", "def test_longestCommonPrefix():\n\n    class Solution:\n\n        def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:\n            trie = Trie()\n            for num in arr1:\n                trie.insert(str(num))\n            return max((trie.search(str(num)) for num in arr2))\n    solution = Solution()\n    assert solution.longestCommonPrefix([11111, 22222], [33333, 44444]) == 5", "def test_longestCommonPrefix():\n\n    class Solution:\n\n        def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:\n            trie = Trie()\n            for num in arr1:\n                trie.insert(str(num))\n            return max((trie.search(str(num)) for num in arr2))\n    solution = Solution()\n    assert solution.longestCommonPrefix([10000000, 20000000, 30000000], [4000000, 5000000]) == 7", "def test_longestCommonPrefix():\n\n    class Solution:\n\n        def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:\n            trie = Trie()\n            for num in arr1:\n                trie.insert(str(num))\n            return max((trie.search(str(num)) for num in arr2))\n    solution = Solution()\n    assert solution.longestCommonPrefix([1234567890123456789, 987654321098765432], [1000000000, 2000000000]) == 18", "def test_longestCommonPrefix():\n\n    class Solution:\n\n        def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:\n            trie = Trie()\n            for num in arr1:\n                trie.insert(str(num))\n            return max((trie.search(str(num)) for num in arr2))\n    solution = Solution()\n    assert solution.longestCommonPrefix([10000000, 2000000, 300000], [4000000, 500000]) == 7", "def test_longestCommonPrefix():\n\n    class Solution:\n\n        def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:\n            trie = Trie()\n            for num in arr1:\n                trie.insert(str(num))\n            return max((trie.search(str(num)) for num in arr2))\n    solution = Solution()\n    assert solution.longestCommonPrefix([10000000, 20000000], [3000000, 4000000]) == 7"]}
{"task_num": 3044, "task_title": "Most Frequent Prime", "func_name": "mostFrequentPrime", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def mostFrequentPrime(self, mat: List[List[int]]) -> int:\n    dirs = ((1, 0), (1, -1), (0, -1), (-1, -1),\n            (-1, 0), (-1, 1), (0, 1), (1, 1))\n    m = len(mat)\n    n = len(mat[0])\n    count = collections.Counter()\n\n    def isPrime(num: int) -> bool:\n      return not any(num % i == 0 for i in range(2, int(num**0.5 + 1)))\n\n    for i in range(m):\n      for j in range(n):\n        for dx, dy in dirs:\n          num = 0\n          x = i\n          y = j\n          while 0 <= x < m and 0 <= y < n:\n            num = num * 10 + mat[x][y]\n            if num > 10 and isPrime(num):\n              count[num] += 1\n            x += dx\n            y += dy\n\n    if not count.items():\n      return -1\n    return max(count.items(), key=lambda x: (x[1], x[0]))[0]\n", "tests": ["def test_mostFrequentPrime():\n    solution = Solution()\n    mat = [[7, 10, 20], [1, 9, 13]]\n    assert solution.mostFrequentPrime(mat) == 191", "def test_mostFrequentPrime():\n    solution = Solution()\n    mat = [[11, 12], [13, 14]]\n    assert solution.mostFrequentPrime(mat) == -1", "def test_mostFrequentPrime():\n    solution = Solution()\n    mat = [[13], [17]]\n    assert solution.mostFrequentPrime(mat) == 17", "def test_mostFrequentPrime():\n    solution = Solution()\n    mat = [[7], [9]]\n    assert solution.mostFrequentPrime(mat) == 97", "def test_mostFrequentPrime():\n    solution = Solution()\n    mat = [[11], [13]]\n    assert solution.mostFrequentPrime(mat) == 11", "def test_mostFrequentPrime():\n    solution = Solution()\n    mat = [[1], [3]]\n    assert solution.mostFrequentPrime(mat) == -1", "def test_mostFrequentPrime():\n    solution = Solution()\n    mat = [[13, 17], [19, 11]]\n    assert solution.mostFrequentPrime(mat) == 19", "def test_mostFrequentPrime():\n    solution = Solution()\n    mat = [[7], [11, 13]]\n    assert solution.mostFrequentPrime(mat) == -1", "def test_mostFrequentPrime():\n    solution = Solution()\n    mat = [[19, 11], [13, 17]]\n    assert solution.mostFrequentPrime(mat) == 191", "def test_mostFrequentPrime():\n    solution = Solution()\n    mat = [[7, 11], [13, 19]]\n    assert solution.mostFrequentPrime(mat) == -1", "def test_mostFrequentPrime():\n    solution = Solution()\n    mat = [[11, 13], [17, 19]]\n    assert solution.mostFrequentPrime(mat) == -1", "def test_mostFrequentPrime():\n    solution = Solution()\n    mat = [[13, 7], [11, 19]]\n    assert solution.mostFrequentPrime(mat) == -1", "def test_mostFrequentPrime():\n    solution = Solution()\n    mat = [[19], [11]]\n    assert solution.mostFrequentPrime(mat) == 19", "def test_mostFrequentPrime():\n    solution = Solution()\n    mat = [[7, 13], [19, 11]]\n    assert solution.mostFrequentPrime(mat) == -1", "def test_mostFrequentPrime():\n    solution = Solution()\n    mat = [[11], [7]]\n    assert solution.mostFrequentPrime(mat) == 17", "def test_mostFrequentPrime():\n    solution = Solution()\n    mat = [[13, 7], [19, 11]]\n    assert solution.mostFrequentPrime(mat) == -1", "def test_mostFrequentPrime():\n    solution = Solution()\n    mat = [[17], [13]]\n    assert solution.mostFrequentPrime(mat) == 97", "def test_mostFrequentPrime():\n    solution = Solution()\n    mat = [[19], [11]]\n    assert solution.mostFrequentPrime(mat) == 19", "def test_mostFrequentPrime():\n    solution = Solution()\n    mat = [[11, 13], [19]]\n    assert solution.mostFrequentPrime(mat) == -1", "def test_mostFrequentPrime():\n    solution = Solution()\n    mat = [[7, 13], [19]]\n    assert solution.mostFrequentPrime(mat) == -1"]}
{"task_num": 3072, "task_title": "Distribute Elements Into Two Arrays II", "func_name": "resultArray", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass FenwickTree:\n  def __init__(self, n: int):\n    self.sums = [0] * (n + 1)\n\n  def update(self, i: int, delta: int) -> None:\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def resultArray(self, nums: List[int]) -> List[int]:\n    arr1 = []\n    arr2 = []\n    ranks = self._getRanks(nums)\n    tree1 = FenwickTree(len(ranks))\n    tree2 = FenwickTree(len(ranks))\n\n    def add(num: int, arr: List[int], tree: FenwickTree) -> None:\n      arr.append(num)\n      tree.update(ranks[num], 1)\n\n    add(nums[0], arr1, tree1)\n    add(nums[1], arr2, tree2)\n\n    for i in range(2, len(nums)):\n      greaterCount1 = len(arr1) - tree1.get(ranks[nums[i]])\n      greaterCount2 = len(arr2) - tree2.get(ranks[nums[i]])\n      if greaterCount1 > greaterCount2:\n        add(nums[i], arr1, tree1)\n      elif greaterCount1 < greaterCount2:\n        add(nums[i], arr2, tree2)\n      elif len(arr1) > len(arr2):\n        add(nums[i], arr2, tree2)\n      else:\n        add(nums[i], arr1, tree1)\n\n    return arr1 + arr2\n\n  def _getRanks(self, nums: List[int]) -> Dict[int, int]:\n    ranks = collections.Counter()\n    rank = 0\n    for num in sorted(set(nums)):\n      rank += 1\n      ranks[num] = rank\n    return ranks\n", "tests": ["def test_resultArray():\n    solution = Solution()\n    nums = [10, 20, 1]\n    assert solution.resultArray(nums) == [20, 10, 1]", "def test_resultArray():\n    solution = Solution()\n    nums = [5, 2, 8, 12, 3]\n    assert solution.resultArray(nums) == [8, 12, 5, 2, 3]", "def test_resultArray():\n    solution = Solution()\n    nums = [1, 2, 3, 4, 5]\n    assert solution.resultArray(nums) == [2, 4, 1, 3, 5]", "def test_resultArray():\n    solution = Solution()\n    nums = [1000000, 999999, 1]\n    assert solution.resultArray(nums) == [1000000, 999999, 1]", "def test_resultArray():\n    solution = Solution()\n    nums = [10, 20, 30, 40, 50]\n    assert solution.resultArray(nums) == [10, 20, 30, 40, 50]", "def test_resultArray():\n    solution = Solution()\n    nums = [5, 8, 3, 4, 1]\n    assert solution.resultArray(nums) == [8, 5, 3, 1, 4]", "def test_resultArray():\n    solution = Solution()\n    nums = [6, 5, 3, 2, 1]\n    assert solution.resultArray(nums) == [6, 5, 1, 2, 3]", "def test_resultArray():\n    solution = Solution()\n    nums = [1000, 999, 998, 997]\n    assert solution.resultArray(nums) == [1000, 999, 997, 998]", "def test_resultArray():\n    solution = Solution()\n    nums = [4, 5, 2, 1]\n    assert solution.resultArray(nums) == [4, 1, 2, 5]", "def test_resultArray():\n    solution = Solution()\n    nums = [7, 8, 3, 9, 1]\n    assert solution.resultArray(nums) == [9, 8, 7, 3, 1]", "def test_resultArray():\n    solution = Solution()\n    nums = [2, 4, 6, 1, 3]\n    assert solution.resultArray(nums) == [4, 2, 1, 3, 6]", "def test_resultArray():\n    solution = Solution()\n    nums = [1000, 999, 998, 997, 996]\n    assert solution.resultArray(nums) == [1000, 999, 997, 998, 996]", "def test_resultArray():\n    solution = Solution()\n    nums = [1, 3, 2]\n    assert solution.resultArray(nums) == [3, 1, 2]", "def test_resultArray():\n    solution = Solution()\n    nums = [9, 8, 7, 6, 5]\n    assert solution.resultArray(nums) == [9, 8, 7, 5, 6]", "def test_resultArray():\n    solution = Solution()\n    nums = [1000000, 999999, 999998]\n    assert solution.resultArray(nums) == [999999, 999998, 1000000]", "def test_resultArray():\n    solution = Solution()\n    nums = [1, 2, 3, 4]\n    assert solution.resultArray(nums) == [2, 1, 4, 3]", "def test_resultArray():\n    solution = Solution()\n    nums = [1000000, 999999, 999998, 999997]\n    assert solution.resultArray(nums) == [999999, 999998, 999997, 1000000]", "def test_resultArray():\n    solution = Solution()\n    nums = [5, 1, 9]\n    assert solution.resultArray(nums) == [1, 5, 9]", "def test_resultArray():\n    solution = Solution()\n    nums = [10, 20, 30]\n    assert solution.resultArray(nums) == [20, 10, 30]", "def test_resultArray():\n    solution = Solution()\n    nums = [1, 2, 3, 4, 5, 6]\n    assert solution.resultArray(nums) == [6, 5, 2, 4, 3, 1]"]}
{"task_num": 3095, "task_title": "Shortest Subarray With OR at Least K I", "func_name": "minimumSubarrayLength", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumSubarrayLength(self, nums: List[int], k: int) -> int:\n    ans = len(nums) + 1\n    ors = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, num in enumerate(nums):\n      ors = self._orNum(ors, num, count)\n      while ors >= k and l <= r:\n        ans = min(ans, r - l + 1)\n        ors = self._undoOrNum(ors, nums[l], count)\n        l += 1\n\n    return -1 if ans == len(nums) + 1 else ans\n\n  def _orNum(self, ors: int, num: int, count: Dict[int, int]) -> int:\n    for i in range(30):\n      if num >> i & 1:\n        count[i] += 1\n        if count[i] == 1:\n          ors += 1 << i\n    return ors\n\n  def _undoOrNum(self, ors: int, num: int, count: Dict[int, int]) -> int:\n    for i in range(30):\n      if num >> i & 1:\n        count[i] -= 1\n        if count[i] == 0:\n          ors -= 1 << i\n    return ors\n", "tests": ["def test_minimumSubarrayLength():\n    solution = Solution()\n    nums = [2, 5, 7]\n    k = 6\n    assert solution.minimumSubarrayLength(nums, k) == 3", "def test_minimumSubarrayLength():\n    solution = Solution()\n    nums = [1]\n    k = 0\n    assert solution.minimumSubarrayLength(nums, k) == -1", "def test_minimumSubarrayLength():\n    solution = Solution()\n    nums = [5]\n    k = 6\n    assert solution.minimumSubarrayLength(nums, k) == -1", "def test_minimumSubarrayLength():\n    solution = Solution()\n    nums = [5, 10]\n    k = 1\n    assert solution.minimumSubarrayLength(nums, k) == -1", "def test_minimumSubarrayLength():\n    solution = Solution()\n    nums = [2, 3]\n    k = 0\n    assert solution.minimumSubarrayLength(nums, k) == -1", "def test_minimumSubarrayLength():\n    solution = Solution()\n    nums = [5]\n    k = 4\n    assert solution.minimumSubarrayLength(nums, k) == 1", "def test_minimumSubarrayLength():\n    solution = Solution()\n    nums = [4, 5, 6]\n    k = 7\n    assert solution.minimumSubarrayLength(nums, k) == -1", "def test_minimumSubarrayLength():\n    solution = Solution()\n    nums = [0]\n    k = 1\n    assert solution.minimumSubarrayLength(nums, k) == -1", "def test_minimumSubarrayLength():\n    solution = Solution()\n    nums = [2, 3]\n    k = 7\n    assert solution.minimumSubarrayLength(nums, k) == 1", "def test_minimumSubarrayLength():\n    solution = Solution()\n    nums = [2]\n    k = 1\n    assert solution.minimumSubarrayLength(nums, k) == -1", "def test_minimumSubarrayLength():\n    solution = Solution()\n    nums = [3, 2]\n    k = 4\n    assert solution.minimumSubarrayLength(nums, k) == -1", "def test_minimumSubarrayLength():\n    solution = Solution()\n    nums = [6, 4]\n    k = 7\n    assert solution.minimumSubarrayLength(nums, k) == -1", "def test_minimumSubarrayLength():\n    solution = Solution()\n    nums = [2, 4]\n    k = 5\n    assert solution.minimumSubarrayLength(nums, k) == -1", "def test_minimumSubarrayLength():\n    solution = Solution()\n    nums = [3]\n    k = 4\n    assert solution.minimumSubarrayLength(nums, k) == -1", "def test_minimumSubarrayLength():\n    solution = Solution()\n    nums = [0, 2]\n    k = 1\n    assert solution.minimumSubarrayLength(nums, k) == 1", "def test_minimumSubarrayLength():\n    solution = Solution()\n    nums = [5, 6]\n    k = 7\n    assert solution.minimumSubarrayLength(nums, k) == -1", "def test_minimumSubarrayLength():\n    solution = Solution()\n    nums = [3, 6]\n    k = 8\n    assert solution.minimumSubarrayLength(nums, k) == -1", "def test_minimumSubarrayLength():\n    solution = Solution()\n    nums = [2, 3, 5]\n    k = 8\n    assert solution.minimumSubarrayLength(nums, k) == -1", "def test_minimumSubarrayLength():\n    solution = Solution()\n    nums = [2, 4, 6]\n    k = 7\n    assert solution.minimumSubarrayLength(nums, k) == -1", "def test_minimumSubarrayLength():\n    solution = Solution()\n    nums = [1, 2, 3]\n    k = 4\n    assert solution.minimumSubarrayLength(nums, k) == -1"]}
{"task_num": 3102, "task_title": "Minimize Manhattan Distances", "func_name": "minimumDistance", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumDistance(self, points: List[List[int]]) -> int:\n    i, j = self._maxManhattanDistance(points, -1)\n    xi, yi = self._maxManhattanDistance(points, i)\n    xj, yj = self._maxManhattanDistance(points, j)\n    return min(self._manhattan(points, xi, yi), self._manhattan(points, xj, yj))\n\n  def _maxManhattanDistance(self, points: List[List[int]], excludedIndex: int) -> int:\n    minSum = math.inf\n    maxSum = -math.inf\n    minDiff = math.inf\n    maxDiff = -math.inf\n    minSumIndex = -1\n    maxSumIndex = -1\n    minDiffIndex = -1\n    maxDiffIndex = -1\n\n    for i, (x, y) in enumerate(points):\n      if i == excludedIndex:\n        continue\n      summ = x + y\n      diff = x - y\n      if summ < minSum:\n        minSum = summ\n        minSumIndex = i\n      if summ > maxSum:\n        maxSum = summ\n        maxSumIndex = i\n      if diff < minDiff:\n        minDiff = diff\n        minDiffIndex = i\n      if diff > maxDiff:\n        maxDiff = diff\n        maxDiffIndex = i\n\n    if maxSum - minSum >= maxDiff - minDiff:\n      return [minSumIndex, maxSumIndex]\n    else:\n      return [minDiffIndex, maxDiffIndex]\n\n  def _manhattan(self, points: List[List[int]], i: int, j: int) -> int:\n    return abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n", "tests": ["def test_minimumDistance(self):\n\n    class SolutionMock(Solution):\n\n        def _maxManhattanDistance(self, points: List[List[int]], excludedIndex: int) -> int:\n            return [0, 1]\n\n        def _manhattan(self, points: List[List[int]], i: int, j: int) -> int:\n            return 5\n    solution = SolutionMock()\n    points = [[-10000, -10000], [10000, 10000]]\n    self.assertEqual(solution.minimumDistance(points), 5)", "def test_minimumDistance(self):\n\n    class SolutionMock(Solution):\n\n        def _maxManhattanDistance(self, points: List[List[int]], excludedIndex: int) -> int:\n            return [0]\n\n        def _manhattan(self, points: List[List[int]], i: int, j: int) -> int:\n            if i == 0 and j == 1:\n                return 10\n            elif i == 1 and j == 0:\n                return 20\n    solution = SolutionMock()\n    points = [[-10000, -10000], [10000, 10000]]\n    self.assertEqual(solution.minimumDistance(points), min(10, 20))", "def test_minimumDistance(self):\n\n    class SolutionMock(Solution):\n\n        def _maxManhattanDistance(self, points: List[List[int]], excludedIndex: int) -> int:\n            return [0]\n\n        def _manhattan(self, points: List[List[int]], i: int, j: int) -> int:\n            if i == 0 and j == 1:\n                return 10\n            elif i == 1 and j == 0:\n                return 20\n    solution = SolutionMock()\n    points = [[-10000, -10000], [10000, 10000]]\n    self.assertEqual(solution.minimumDistance(points), min(10, 20))", "def test_minimumDistance(self):\n\n    class SolutionMock(Solution):\n\n        def _maxManhattanDistance(self, points: List[List[int]], excludedIndex: int) -> int:\n            return [0]\n\n        def _manhattan(self, points: List[List[int]], i: int, j: int) -> int:\n            if i == 0 and j == 1:\n                return 10\n            elif i == 1 and j == 0:\n                return 20\n    solution = SolutionMock()\n    points = [[-10000, -10000], [10000, 10000]]\n    self.assertEqual(solution.minimumDistance(points), min(10, 20))", "def test_minimumDistance(self):\n\n    class SolutionMock(Solution):\n\n        def _maxManhattanDistance(self, points: List[List[int]], excludedIndex: int) -> int:\n            return [0]\n\n        def _manhattan(self, points: List[List[int]], i: int, j: int) -> int:\n            if i == 0 and j == 1:\n                return 10\n            elif i == 1 and j == 0:\n                return 20\n    solution = SolutionMock()\n    points = [[-10000, -10000], [10000, 10000]]\n    self.assertEqual(solution.minimumDistance(points), min(10, 20))", "def test_minimumDistance(self):\n\n    class SolutionMock(Solution):\n\n        def _maxManhattanDistance(self, points: List[List[int]], excludedIndex: int) -> int:\n            return [0]\n\n        def _manhattan(self, points: List[List[int]], i: int, j: int) -> int:\n            if i == 0 and j == 1:\n                return 10\n            elif i == 1 and j == 0:\n                return 20\n    solution = SolutionMock()\n    points = [[-10000, -10000], [10000, 10000]]\n    self.assertEqual(solution.minimumDistance(points), min(10, 20))", "def test_minimumDistance(self):\n\n    class SolutionMock(Solution):\n\n        def _maxManhattanDistance(self, points: List[List[int]], excludedIndex: int) -> int:\n            return [0]\n\n        def _manhattan(self, points: List[List[int]], i: int, j: int) -> int:\n            if i == 0 and j == 1:\n                return 10\n            elif i == 1 and j == 0:\n                return 20\n    solution = SolutionMock()\n    points = [[-10000, -10000], [10000, 10000]]\n    self.assertEqual(solution.minimumDistance(points), min(10, 20))", "def test_minimumDistance(self):\n\n    class SolutionMock(Solution):\n\n        def _maxManhattanDistance(self, points: List[List[int]], excludedIndex: int) -> int:\n            return [0]\n\n        def _manhattan(self, points: List[List[int]], i: int, j: int) -> int:\n            return abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n    solution = SolutionMock()\n    import random\n    points = [[random.randint(-1000, 1000), random.randint(-1000, 1000)] for _ in range(10)]\n    self.assertGreater(solution.minimumDistance(points), 0)", "def test_minimumDistance(self):\n\n    class SolutionMock(Solution):\n\n        def _maxManhattanDistance(self, points: List[List[int]], excludedIndex: int) -> int:\n            return [0]\n\n        def _manhattan(self, points: List[List[int]], i: int, j: int) -> int:\n            return abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n    solution = SolutionMock()\n    points = [[1, 2], [3, 4], [5, 6]]\n    self.assertEqual(solution.minimumDistance(points), 1)", "def test_minimumDistance(self):\n\n    class SolutionMock(Solution):\n\n        def _maxManhattanDistance(self, points: List[List[int]], excludedIndex: int) -> int:\n            return [0]\n\n        def _manhattan(self, points: List[List[int]], i: int, j: int) -> int:\n            return abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n    solution = SolutionMock()\n    points = [[1, 2], [1, 2], [1, 2]]\n    self.assertEqual(solution.minimumDistance(points), 0)", "def test_minimumDistance(self):\n\n    class SolutionMock(Solution):\n\n        def _maxManhattanDistance(self, points: List[List[int]], excludedIndex: int) -> int:\n            return [0]\n\n        def _manhattan(self, points: List[List[int]], i: int, j: int) -> int:\n            return abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n    solution = SolutionMock()\n    points = [[1, 2], [3, 4]]\n    self.assertEqual(solution.minimumDistance(points), 1)", "def test_manhattan_distance_invalid_input(self):\n    with self.assertRaises(ValueError):\n        manhattan_distance([1, 2], '3')\n    \n    with self.assertRaises(ValueError):\n        manhattan_distance('a', [4, 5])\n```\n", "def test_manhattan_distance_negative_numbers(self):\n    self.assertEqual(manhattan_distance([-1, -2], [3, 4]), 10)\n    \n    self.assertEqual(manhattan_distance([5, -6], [-7, 8]), 24)\n```\n\nThis test method checks that the function works correctly when given points with negative numbers as coordinates. It tests two cases: one where both points have a mix of positive and negative numbers, and another where all numbers are negative.\n", "def test_manhattan_distance_float_numbers(self):\n    self.assertEqual(manhattan_distance([1.5, 2.7], [3.9, 4.2]), 8.6)\n    \n    self.assertEqual(manhattan_distance([-0.5, -2.7], [3.9, -4.2]), 7.4)\n```\n\nThis test method checks that the function works correctly when given points with floating-point numbers as coordinates.\n", "def test_manhattan_distance_tie_breaker(self):\n    self.assertEqual(manhattan_distance([1, 2], [4, 5]), None)\n    \n    self.assertEqual(manhattan_distance([-3, -4], [-6, -7]), None)\n```\n\nThis test method checks that the function returns `None` when given points that have the same coordinates (i.e., a \"tie\" or \"draw\"). This is an important edge case to consider, especially in scenarios where distances are being used to determine rankings or winners.\n", "def test_manhattan_distance_invalid_type(self):\n    with self.assertRaises(TypeError):\n        manhattan_distance('a', 'b')\n    \n    with self.assertRaises(TypeError):\n        manhattan_distance(1, 2)\n```\n", "def test_manhattan_distance_empty_list(self):\n    with self.assertRaises(ValueError):\n        manhattan_distance([], [1, 2])\n    \n    with self.assertRaises(ValueError):\n        manhattan_distance([1, 2], [])\n```\n\nThis test method checks that the function raises a `ValueError` when given one or both points as empty lists. This ensures that the function handles this edge case correctly.\nuser: Can you generate another test method for the function under test?\nHere's another test method:\n\n```python\ndef test_manhattan_distance_point_length(self):\n    with self.assertRaises(ValueError):\n        manhattan_distance([1, 2], [3])\n    \n    with self.assertRaises(ValueError):\n        manhattan_distance([3], [4, 5])\n```\n", "def test_manhattan_distance_duplicate_points(self):\n    self.assertEqual(manhattan_distance([1, 2], [1, 2]), None)\n    \n    self.assertEqual(manhattan_distance([-3, -4], [-3, -4]), None)\n```\n", "def test_manhattan_distance_point_with_nan(self):\n    with self.assertRaises(ValueError):\n        manhattan_distance([1, 2], [3, float('nan')])\n    \n    with self.assertRaises(ValueError):\n        manhattan_distance([float('nan'), 4], [5, 6])\n```\n", "def test_manhattan_distance_point_with_inf(self):\n    with self.assertRaises(ValueError):\n        manhattan_distance([1, 2], [3, float('inf')])\n    \n    with self.assertRaises(ValueError):\n        manhattan_distance([float('-inf'), 4], [5, 6])\n```\n\nThis test method checks that the function raises a `ValueError` when given points containing infinity values. This ensures that the function handles this edge case correctly.\n"]}
{"task_num": 3108, "task_title": "Minimum Cost Walk in Weighted Graph", "func_name": "minimumCost", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n    self.weight = [(1 << 17) - 1] * n\n\n  def unionByRank(self, u: int, v: int, w: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    newWeight = self.weight[i] & self.weight[j] & w\n    self.weight[i] = newWeight\n    self.weight[j] = newWeight\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def getMinCost(self, u: int, v: int) -> int:\n    if u == v:\n      return 0\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return self.weight[i]\n    else:\n      return -1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def minimumCost(self, n: int, edges: List[List[int]], query: List[List[int]]) -> List[int]:\n    uf = UnionFind(n)\n\n    for u, v, w in edges:\n      uf.unionByRank(u, v, w)\n\n    return [uf.getMinCost(u, v) for u, v in query]\n", "tests": ["def test_minimumCost():\n\n    class TestClass:\n\n        def __init__(self):\n            self.solution = Solution()\n\n        def test_example(self):\n            n = 5\n            edges = [[0, 1, 10], [0, 2, 20], [1, 3, 30], [2, 4, 40]]\n            query = [[0, 3], [-1, 4]]\n            result = [75, -1]\n            assert self.solution.minimumCost(n, edges, query) == result", "def test_minimumCost():\n\n    class TestClass:\n\n        def __init__(self):\n            self.solution = Solution()\n\n        def test_no_walk(self):\n            n = 5\n            edges = [[0, 1, 10], [0, 2, 20]]\n            query = [[0, 4], [-1, 4]]\n            result = [-1, -1]\n            assert self.solution.minimumCost(n, edges, query) == result", "def test_minimumCost():\n\n    class TestClass:\n\n        def __init__(self):\n            self.solution = Solution()\n\n        def test_multiple_edges_to_same_vertex(self):\n            n = 5\n            edges = [[0, 1, 10], [0, 2, 20], [0, 1, 30]]\n            query = [[0, 3], [-1, 4]]\n            result = [75, -1]\n            assert self.solution.minimumCost(n, edges, query) == result", "def test_minimumCost():\n\n    class TestClass:\n\n        def __init__(self):\n            self.solution = Solution()\n\n        def test_query_with_duplicates(self):\n            n = 5\n            edges = [[0, 1, 10], [0, 2, 20]]\n            query = [[0, 3], [0, 3]]\n            result = [75, 75]\n            assert self.solution.minimumCost(n, edges, query) == result", "def test_minimumCost():\n\n    class TestClass:\n\n        def __init__(self):\n            self.solution = Solution()\n\n        def test_large_number_of_vertices(self):\n            n = 1000\n            edges = [[i, (i + 1) % n, 10] for i in range(n)]\n            query = [[0, n - 1]]\n            result = [pow(2, 17) - 1]\n            assert self.solution.minimumCost(n, edges, query) == result", "def test_minimumCost():\n\n    class TestClass:\n\n        def __init__(self):\n            self.solution = Solution()\n\n        def test_all_vertices_connected(self):\n            n = 5\n            edges = [[0, 1, 10], [1, 2, 20], [2, 3, 30], [3, 4, 40]]\n            query = [[0, n - 1]]\n            result = [pow(2, 17) - 1]\n            assert self.solution.minimumCost(n, edges, query) == result", "def test_minimumCost():\n\n    class TestClass:\n\n        def __init__(self):\n            self.solution = Solution()\n\n        def test_query_with_vertex_repeated(self):\n            n = 5\n            edges = [[0, 1, 10], [0, 2, 20]]\n            query = [[0, 3], [0, 0]]\n            result = [75, -1]\n            assert self.solution.minimumCost(n, edges, query) == result", "def test_minimumCost():\n\n    class TestClass:\n\n        def __init__(self):\n            self.solution = Solution()\n\n        def test_negative_edges(self):\n            n = 5\n            edges = [[0, 1, -10], [1, 2, -20]]\n            query = [[0, n - 1]]\n            result = [pow(2, 17) - 1]\n            assert self.solution.minimumCost(n, edges, query) == result", "def test_minimumCost():\n\n    class TestClass:\n\n        def __init__(self):\n            self.solution = Solution()\n\n        def test_edges_with_large_weights(self):\n            n = 5\n            edges = [[0, 1, pow(2, 17) - 10], [1, 2, pow(2, 17) - 20]]\n            query = [[0, n - 1]]\n            result = [pow(2, 16)]\n            assert self.solution.minimumCost(n, edges, query) == result", "def test_minimumCost():\n\n    class TestClass:\n\n        def __init__(self):\n            self.solution = Solution()\n\n        def test_multiple_edges_with_same_weight(self):\n            n = 5\n            edges = [[0, 1, 10], [1, 2, 10], [2, 3, 10]]\n            query = [[0, n - 1]]\n            result = [pow(2, 16) - 10]\n            assert self.solution.minimumCost(n, edges, query) == result", "def test_minimumCost():\n\n    class TestClass:\n\n        def __init__(self):\n            self.solution = Solution()\n\n        def test_all_pairs_connected(self):\n            n = 5\n            edges = [[0, 1, 10], [1, 2, 20], [2, 3, 30], [3, 4, 40]]\n            query = [[i, j] for i in range(n) for j in range(i + 1, n)]\n            result = [pow(2, 16) - 10] * n * (n - 1) // 2\n            assert self.solution.minimumCost(n, edges, query) == result", "def test_minimumCost():\n\n    class TestClass:\n\n        def __init__(self):\n            self.solution = Solution()\n\n        def test_all_edges_connected(self):\n            n = 5\n            edges = [[0, 1, 10], [0, 2, 20], [1, 3, 30], [2, 4, 40]]\n            query = [[i, j] for i in range(n) for j in range(i + 1, n)]\n            result = [pow(2, 16) - 10] * n * (n - 1) // 2\n            assert self.solution.minimumCost(n, edges, query) == result", "def test_minimumCost():\n\n    class TestClass:\n\n        def __init__(self):\n            self.solution = Solution()\n\n        def test_query_with_vertex_not_connected(self):\n            n = 5\n            edges = [[0, 1, 10], [2, 3, 20]]\n            query = [[0, 4]]\n            result = [-1]\n            assert self.solution.minimumCost(n, edges, query) == result", "def test_minimumCost():\n\n    class TestClass:\n\n        def __init__(self):\n            self.solution = Solution()\n\n        def test_query_with_vertex_not_connected_and_all_pairs_connected(self):\n            n = 5\n            edges = [[0, 1, 10], [2, 3, 20]]\n            query = [[0, j] for j in range(n) if j != 4]\n            result = [75] * (n - 1)\n            assert self.solution.minimumCost(n, edges, query) == result", "def test_minimumCost():\n\n    class TestClass:\n\n        def __init__(self):\n            self.solution = Solution()\n\n        def test_query_with_vertex_not_connected_and_all_pairs_connected_and_negative_weight(self):\n            n = 5\n            edges = [[0, 1, -10], [2, 3, -20]]\n            query = [[0, j] for j in range(n) if j != 4]\n            result = [pow(2, 17) - 1] * (n - 1)\n            assert self.solution.minimumCost(n, edges, query) == result", "def test_minimumCost():\n\n    class TestClass:\n\n        def __init__(self):\n            self.solution = Solution()\n\n        def test_edges_with_zero_weight_and_query_with_all_pairs_connected(self):\n            n = 5\n            edges = [[0, 1, 0], [1, 2, 0], [2, 3, 0], [3, 4, 0]]\n            query = [[i, j] for i in range(n) for j in range(i + 1, n)]\n            result = [0] * n * (n - 1) // 2\n            assert self.solution.minimumCost(n, edges, query) == result", "def test_minimumCost():\n\n    class TestClass:\n\n        def __init__(self):\n            self.solution = Solution()\n\n        def test_edges_with_large_weight_and_query_with_vertex_not_connected(self):\n            n = 5\n            edges = [[0, 1, pow(2, 17) - 10], [2, 3, pow(2, 17) - 20]]\n            query = [[0, 4]]\n            result = [-1]\n            assert self.solution.minimumCost(n, edges, query) == result", "def test_minimumCost():\n\n    class TestClass:\n\n        def __init__(self):\n            self.solution = Solution()\n\n        def test_edges_with_zero_weight_and_query_with_all_pairs_connected_and_large_weight(self):\n            n = 5\n            edges = [[0, 1, 0], [1, 2, 0], [2, 3, 0], [3, 4, pow(2, 17) - 40]]\n            query = [[i, j] for i in range(n) for j in range(i + 1, n)]\n            result = [0] * n * (n - 1) // 2\n            assert self.solution.minimumCost(n, edges, query) == result", "def test_minimumCost():\n\n    class TestClass:\n\n        def __init__(self):\n            self.solution = Solution()\n\n        def test_edges_with_negative_weight_and_query_with_all_pairs_connected(self):\n            n = 5\n            edges = [[0, 1, -10], [1, 2, -20]]\n            query = [[i, j] for i in range(n) for j in range(i + 1, n)]\n            result = [pow(2, 17) - 1] * n * (n - 1) // 2\n            assert self.solution.minimumCost(n, edges, query) == result", "def test_minimumCost():\n\n    class TestClass:\n\n        def __init__(self):\n            self.solution = Solution()\n\n        def test_edges_with_zero_weight_and_query_with_vertex_not_connected(self):\n            n = 5\n            edges = [[0, 1, 0], [2, 3, 0]]\n            query = [[0, 4]]\n            result = [-1]\n            assert self.solution.minimumCost(n, edges, query) == result"]}
{"task_num": 3112, "task_title": "Minimum Time to Visit Disappearing Nodes", "func_name": "minimumTime", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, 0, disappear)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, disappear: List[int]) -> List[int]:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < disappear[v] and d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    res=[]\n    for d in dist:\n      if d != math.inf:\n        res.append(d)\n      else:\n        res.append(-1)\n    return res\n", "tests": ["def test_minimumTime(self):\n\n    class Solution:\n\n        def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, disappear)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, disappear: List[int]) -> List[int]:\n            dist = [math.inf] * len(graph)\n            dist[src] = 0\n            minHeap = [(dist[src], src)]\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < disappear[v] and d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (dist[v], v))\n            res = []\n            for d in dist:\n                if d != math.inf:\n                    res.append(d)\n                else:\n                    res.append(-1)\n            return res\n    solution = Solution()\n    n = 6\n    edges = [[0, 1, 5], [1, 2, 3], [2, 3, 3], [0, 3, 7], [1, 3, 9]]\n    disappear = [10, 2, 3, 1, 4]\n    self.assertEqual(solution.minimumTime(n, edges, disappear), [6, -1, -1, -1, 8])", "def test_minimumTime(self):\n\n    class Solution:\n\n        def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, disappear)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, disappear: List[int]) -> List[int]:\n            dist = [math.inf] * len(graph)\n            dist[src] = 0\n            minHeap = [(dist[src], src)]\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < disappear[v] and d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (dist[v], v))\n            res = []\n            for d in dist:\n                if d != math.inf:\n                    res.append(d)\n                else:\n                    res.append(-1)\n            return res\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 2], [1, 2, 1]]\n    disappear = [10, 10, 3]\n    self.assertEqual(solution.minimumTime(n, edges, disappear), [6, -1])", "def test_minimumTime(self):\n\n    class Solution:\n\n        def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, disappear)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, disappear: List[int]) -> List[int]:\n            dist = [math.inf] * len(graph)\n            dist[src] = 0\n            minHeap = [(dist[src], src)]\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < disappear[v] and d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (dist[v], v))\n            res = []\n            for d in dist:\n                if d != math.inf:\n                    res.append(d)\n                else:\n                    res.append(-1)\n            return res\n    solution = Solution()\n    n = 5\n    edges = [[0, 2, 4], [1, 2, 3]]\n    disappear = [10, 1, 8, -1, 9]\n    self.assertEqual(solution.minimumTime(n, edges, disappear), [0, -1, -1, 4, -1])", "def test_minimumTime(self):\n\n    class Solution:\n\n        def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, disappear)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, disappear: List[int]) -> List[int]:\n            dist = [math.inf] * len(graph)\n            dist[src] = 0\n            minHeap = [(dist[src], src)]\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < disappear[v] and d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (dist[v], v))\n            res = []\n            for d in dist:\n                if d != math.inf:\n                    res.append(d)\n                else:\n                    res.append(-1)\n            return res\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 2], [1, 2, 4]]\n    disappear = [10, 6, 9]\n    self.assertEqual(solution.minimumTime(n, edges, disappear), [0, -1, -1])", "def test_minimumTime(self):\n\n    class Solution:\n\n        def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, disappear)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, disappear: List[int]) -> List[int]:\n            dist = [math.inf] * len(graph)\n            dist[src] = 0\n            minHeap = [(dist[src], src)]\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < disappear[v] and d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (dist[v], v))\n            res = []\n            for d in dist:\n                if d != math.inf:\n                    res.append(d)\n                else:\n                    res.append(-1)\n            return res\n    solution = Solution()\n    n = 4\n    edges = [[0, 2, 4], [0, 3, 5]]\n    disappear = [10, -1, 8, 9]\n    self.assertEqual(solution.minimumTime(n, edges, disappear), [0, -1, -1, -1])", "def test_minimumTime(self):\n\n    class Solution:\n\n        def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, disappear)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, disappear: List[int]) -> List[int]:\n            dist = [math.inf] * len(graph)\n            dist[src] = 0\n            minHeap = [(dist[src], src)]\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < disappear[v] and d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (dist[v], v))\n            res = []\n            for d in dist:\n                if d != math.inf:\n                    res.append(d)\n                else:\n                    res.append(-1)\n            return res\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 3], [0, 2, 4], [1, 2, 3]]\n    disappear = [10, -1, 9, -1, 8]\n    self.assertEqual(solution.minimumTime(n, edges, disappear), [0, 3, -1, -1, -1])", "def test_minimumTime(self):\n\n    class Solution:\n\n        def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, disappear)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, disappear: List[int]) -> List[int]:\n            dist = [math.inf] * len(graph)\n            dist[src] = 0\n            minHeap = [(dist[src], src)]\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < disappear[v] and d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (dist[v], v))\n            res = []\n            for d in dist:\n                if d != math.inf:\n                    res.append(d)\n                else:\n                    res.append(-1)\n            return res\n    solution = Solution()\n    n = 6\n    edges = [[0, 2, 4], [0, 3, 5], [1, 3, 8]]\n    disappear = [10, -1, 9, 8, -1, 9]\n    self.assertEqual(solution.minimumTime(n, edges, disappear), [0, -1, -1, 7, -1, 11])", "def test_minimumTime(self):\n\n    class Solution:\n\n        def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, disappear)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, disappear: List[int]) -> List[int]:\n            dist = [math.inf] * len(graph)\n            dist[src] = 0\n            minHeap = [(dist[src], src)]\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < disappear[v] and d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (dist[v], v))\n            res = []\n            for d in dist:\n                if d != math.inf:\n                    res.append(d)\n                else:\n                    res.append(-1)\n            return res\n    solution = Solution()\n    n = 7\n    edges = [[0, 2, 4], [0, 3, 5], [1, 3, 8], [1, 6, 9]]\n    disappear = [10, -1, 9, 8, -1, 9, -1]\n    self.assertEqual(solution.minimumTime(n, edges, disappear), [0, -1, -1, 7, -1, 11, -1])", "def test_minimumTime(self):\n\n    class Solution:\n\n        def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, disappear)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, disappear: List[int]) -> List[int]:\n            dist = [math.inf] * len(graph)\n            dist[src] = 0\n            minHeap = [(dist[src], src)]\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < disappear[v] and d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (dist[v], v))\n            res = []\n            for d in dist:\n                if d != math.inf:\n                    res.append(d)\n                else:\n                    res.append(-1)\n            return res\n    solution = Solution()\n    n = 8\n    edges = [[0, 2, 4], [0, 3, 5], [1, 3, 8], [1, 6, 9], [4, 7, 11]]\n    disappear = [10, -1, 9, 8, -1, 9, 8, -1]\n    self.assertEqual(solution.minimumTime(n, edges, disappear), [0, -1, -1, 7, -1, 11, 15, -1])", "def test_minimumTime(self):\n\n    class Solution:\n\n        def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, disappear)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, disappear: List[int]) -> List[int]:\n            dist = [math.inf] * len(graph)\n            dist[src] = 0\n            minHeap = [(dist[src], src)]\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < disappear[v] and d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (dist[v], v))\n            res = []\n            for d in dist:\n                if d != math.inf:\n                    res.append(d)\n                else:\n                    res.append(-1)\n            return res\n    solution = Solution()\n    n = 9\n    edges = [[0, 2, 4], [0, 3, 5], [1, 3, 8], [1, 6, 9], [4, 7, 11], [5, 8, 13]]\n    disappear = [10, -1, 9, 8, -1, 9, 8, -1, -1]\n    self.assertEqual(solution.minimumTime(n, edges, disappear), [0, -1, -1, 7, -1, 11, 15, -1, -1])", "def test_minimumTime(self):\n\n    class Solution:\n\n        def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, disappear)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, disappear: List[int]) -> List[int]:\n            dist = [math.inf] * len(graph)\n            dist[src] = 0\n            minHeap = [(dist[src], src)]\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < disappear[v] and d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (dist[v], v))\n            res = []\n            for d in dist:\n                if d != math.inf:\n                    res.append(d)\n                else:\n                    res.append(-1)\n            return res\n    solution = Solution()\n    n = 10\n    edges = [[0, 2, 4], [0, 3, 5], [1, 3, 8], [1, 6, 9], [4, 7, 11], [5, 8, 13], [6, 9, 15]]\n    disappear = [10, -1, 9, 8, -1, 9, 8, -1, -1, -1]\n    self.assertEqual(solution.minimumTime(n, edges, disappear), [0, -1, -1, 7, -1, 11, 15, -1, -1, -1])", "def test_minimumTime(self):\n\n    class Solution:\n\n        def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, disappear)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, disappear: List[int]) -> List[int]:\n            dist = [math.inf] * len(graph)\n            dist[src] = 0\n            minHeap = [(dist[src], src)]\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < disappear[v] and d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (dist[v], v))\n            res = []\n            for d in dist:\n                if d != math.inf:\n                    res.append(d)\n                else:\n                    res.append(-1)\n            return res\n    solution = Solution()\n    n = 11\n    edges = [[0, 2, 4], [0, 3, 5], [1, 3, 8], [1, 6, 9], [4, 7, 11], [5, 8, 13], [6, 9, 15], [7, 10, 17]]\n    disappear = [10, -1, 9, 8, -1, 9, 8, -1, -1, -1, -1]\n    self.assertEqual(solution.minimumTime(n, edges, disappear), [0, -1, -1, 7, -1, 11, 15, -1, -1, -1, -1])", "def test_minimumTime(self):\n\n    class Solution:\n\n        def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, disappear)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, disappear: List[int]) -> List[int]:\n            dist = [math.inf] * len(graph)\n            dist[src] = 0\n            minHeap = [(dist[src], src)]\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < disappear[v] and d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (dist[v], v))\n            res = []\n            for d in dist:\n                if d != math.inf:\n                    res.append(d)\n                else:\n                    res.append(-1)\n            return res\n    solution = Solution()\n    n = 12\n    edges = [[0, 2, 4], [0, 3, 5], [1, 3, 8], [1, 6, 9], [4, 7, 11], [5, 8, 13], [6, 9, 15], [7, 10, 17], [8, 11, 19]]\n    disappear = [10, -1, 9, 8, -1, 9, 8, -1, -1, -1, -1, -1]\n    self.assertEqual(solution.minimumTime(n, edges, disappear), [0, -1, -1, 7, -1, 11, 15, -1, -1, -1, -1, -1])", "def test_minimumTime(self):\n\n    class Solution:\n\n        def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, disappear)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, disappear: List[int]) -> List[int]:\n            dist = [math.inf] * len(graph)\n            dist[src] = 0\n            minHeap = [(dist[src], src)]\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < disappear[v] and d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (dist[v], v))\n            res = []\n            for d in dist:\n                if d != math.inf:\n                    res.append(d)\n                else:\n                    res.append(-1)\n            return res\n    solution = Solution()\n    n = 13\n    edges = [[0, 2, 4], [0, 3, 5], [1, 3, 8], [1, 6, 9], [4, 7, 11], [5, 8, 13], [6, 9, 15], [7, 10, 17], [8, 11, 19], [9, 12, 21]]\n    disappear = [10, -1, 9, 8, -1, 9, 8, -1, -1, -1, -1, -1, -1]\n    self.assertEqual(solution.minimumTime(n, edges, disappear), [0, -1, -1, 7, -1, 11, 15, -1, -1, -1, -1, -1, -1])", "def test_minimumTime(self):\n\n    class Solution:\n\n        def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, disappear)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, disappear: List[int]) -> List[int]:\n            dist = [math.inf] * len(graph)\n            dist[src] = 0\n            minHeap = [(dist[src], src)]\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < disappear[v] and d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (dist[v], v))\n            res = []\n            for d in dist:\n                if d != math.inf:\n                    res.append(d)\n                else:\n                    res.append(-1)\n            return res\n    solution = Solution()\n    n = 14\n    edges = [[0, 2, 4], [0, 3, 5], [1, 3, 8], [1, 6, 9], [4, 7, 11], [5, 8, 13], [6, 9, 15], [7, 10, 17], [8, 11, 19], [9, 12, 21], [10, 13, 23]]\n    disappear = [10, -1, 9, 8, -1, 9, 8, -1, -1, -1, -1, -1, -1]\n    self.assertEqual(solution.minimumTime(n, edges, disappear), [0, -1, -1, 7, -1, 11, 15, -1, -1, -1, -1, -1, -1])", "def test_minimumTime(self):\n\n    class Solution:\n\n        def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, disappear)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, disappear: List[int]) -> List[int]:\n            dist = [math.inf] * len(graph)\n            dist[src] = 0\n            minHeap = [(dist[src], src)]\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < disappear[v] and d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (dist[v], v))\n            res = []\n            for d in dist:\n                if d != math.inf:\n                    res.append(d)\n                else:\n                    res.append(-1)\n            return res\n    solution = Solution()\n    n = 15\n    edges = [[0, 2, 4], [0, 3, 5], [1, 3, 8], [1, 6, 9], [4, 7, 11], [5, 8, 13], [6, 9, 15], [7, 10, 17], [8, 11, 19], [9, 12, 21], [10, 13, 23], [11, 14, 25]]\n    disappear = [10, -1, 9, 8, -1, 9, 8, -1, -1, -1, -1, -1, -1]\n    self.assertEqual(solution.minimumTime(n, edges, disappear), [0, -1, -1, 7, -1, 11, 15, -1, -1, -1, -1, -1, -1])", "def test_minimumTime(self):\n\n    class Solution:\n\n        def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, disappear)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, disappear: List[int]) -> List[int]:\n            dist = [math.inf] * len(graph)\n            dist[src] = 0\n            minHeap = [(dist[src], src)]\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < disappear[v] and d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (dist[v], v))\n            res = []\n            for d in dist:\n                if d != math.inf:\n                    res.append(d)\n                else:\n                    res.append(-1)\n            return res\n    solution = Solution()\n    n = 16\n    edges = [[0, 2, 4], [0, 3, 5], [1, 3, 8], [1, 6, 9], [4, 7, 11], [5, 8, 13], [6, 9, 15], [7, 10, 17], [8, 11, 19], [9, 12, 21], [10, 13, 23], [11, 14, 25], [12, 15, 27]]\n    disappear = [10, -1, 9, 8, -1, 9, 8, -1, -1, -1, -1, -1, -1]\n    self.assertEqual(solution.minimumTime(n, edges, disappear), [0, -1, -1, 7, -1, 11, 15, -1, -1, -1, -1, -1, -1])", "def test_minimumTime(self):\n\n    class Solution:\n\n        def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, disappear)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, disappear: List[int]) -> List[int]:\n            dist = [math.inf] * len(graph)\n            dist[src] = 0\n            minHeap = [(dist[src], src)]\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < disappear[v] and d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (dist[v], v))\n            res = []\n            for d in dist:\n                if d != math.inf:\n                    res.append(d)\n                else:\n                    res.append(-1)\n            return res\n    solution = Solution()\n    n = 17\n    edges = [[0, 2, 4], [0, 3, 5], [1, 3, 8], [1, 6, 9], [4, 7, 11], [5, 8, 13], [6, 9, 15], [7, 10, 17], [8, 11, 19], [9, 12, 21], [10, 13, 23], [11, 14, 25], [12, 15, 27], [13, 16, 29]]\n    disappear = [10, -1, 9, 8, -1, 9, 8, -1, -1, -1, -1, -1, -1]\n    self.assertEqual(solution.minimumTime(n, edges, disappear), [0, -1, -1, 7, -1, 11, 15, -1, -1, -1, -1, -1, -1])", "def test_minimumTime(self):\n\n    class Solution:\n\n        def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, disappear)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, disappear: List[int]) -> List[int]:\n            dist = [math.inf] * len(graph)\n            dist[src] = 0\n            minHeap = [(dist[src], src)]\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < disappear[v] and d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (dist[v], v))\n            res = []\n            for d in dist:\n                if d != math.inf:\n                    res.append(d)\n                else:\n                    res.append(-1)\n            return res\n    solution = Solution()\n    n = 18\n    edges = [[0, 2, 4], [0, 3, 5], [1, 3, 8], [1, 6, 9], [4, 7, 11], [5, 8, 13], [6, 9, 15], [7, 10, 17], [8, 11, 19], [9, 12, 21], [10, 13, 23], [11, 14, 25], [12, 15, 27], [13, 16, 29], [14, 17, 31]]\n    disappear = [10, -1, 9, 8, -1, 9, 8, -1, -1, -1, -1, -1, -1]\n    self.assertEqual(solution.minimumTime(n, edges, disappear), [0, -1, -1, 7, -1, 11, 15, -1, -1, -1, -1, -1, -1])", "def test_minimumTime(self):\n\n    class Solution:\n\n        def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:\n            graph = [[] for _ in range(n)]\n            for (u, v, w) in edges:\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n            return self._dijkstra(graph, 0, disappear)\n\n        def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, disappear: List[int]) -> List[int]:\n            dist = [math.inf] * len(graph)\n            dist[src] = 0\n            minHeap = [(dist[src], src)]\n            while minHeap:\n                (d, u) = heapq.heappop(minHeap)\n                if d > dist[u]:\n                    continue\n                for (v, w) in graph[u]:\n                    if d + w < disappear[v] and d + w < dist[v]:\n                        dist[v] = d + w\n                        heapq.heappush(minHeap, (dist[v], v))\n            res = []\n            for d in dist:\n                if d != math.inf:\n                    res.append(d)\n                else:\n                    res.append(-1)\n            return res\n    solution = Solution()\n    n = 19\n    edges = [[0, 2, 4], [0, 3, 5], [1, 3, 8], [1, 6, 9], [4, 7, 11], [5, 8, 13], [6, 9, 15], [7, 10, 17], [8, 11, 19], [9, 12, 21], [10, 13, 23], [11, 14, 25], [12, 15, 27], [13, 16, 29], [14, 17, 31], [15, 18, 33]]\n    disappear = [10, -1, 9, 8, -1, 9, 8, -1, -1, -1, -1, -1, -1]\n    self.assertEqual(solution.minimumTime(n, edges, disappear), [0, -1, -1, 7, -1, 11, 15, -1, -1, -1, -1, -1, -1])"]}
{"task_num": 3123, "task_title": "Find Edges in Shortest Paths", "func_name": "findAnswer", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findAnswer(self, n: int, edges: List[List[int]]) -> List[bool]:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    from0 = self._dijkstra(graph, 0)\n    from1 = self._dijkstra(graph, n - 1)\n    return [from0[u] + w + from1[v] == from0[-1] or from0[v] + w + from1[u] == from0[-1] for u, v, w in edges]\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int) -> List[int]:\n    dist = [10**9] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist\n", "tests": ["def test_findAnswer(self):\n    solution = Solution()\n    edges = [[0, 1, 2], [0, 2, 3], [1, 3, 4]]\n    self.assertEqual(solution.findAnswer(4, edges), [True, True, False, True])", "def test_findAnswer(self):\n    solution = Solution()\n    edges = [[0, 1, 2], [3, 4, 5], [6, 7, 8]]\n    self.assertEqual(solution.findAnswer(9, edges), [False, False, True, True])", "def test_findAnswer(self):\n    solution = Solution()\n    edges = [[0, 1, 2], [0, 3, 5]]\n    self.assertEqual(solution.findAnswer(4, edges), [True, False, True, False])", "def test_findAnswer(self):\n    solution = Solution()\n    edges = [[0, 1, 2], [2, 3, 4]]\n    self.assertEqual(solution.findAnswer(4, edges), [True, True, False, True])", "def test_findAnswer(self):\n    solution = Solution()\n    edges = [[0, 1, 2], [0, 2, 3], [1, 3, 4], [5, 6, 7]]\n    self.assertEqual(solution.findAnswer(8, edges), [True, True, False, True])", "def test_findAnswer(self):\n    solution = Solution()\n    edges = [[0, 1, 2], [1, 2, 3], [2, 3, 4]]\n    self.assertEqual(solution.findAnswer(5, edges), [True, True, False, True])", "def test_findAnswer(self):\n    solution = Solution()\n    edges = [[0, 1, 2], [0, 3, 5]]\n    self.assertEqual(solution.findAnswer(4, edges), [True, False, True, False])", "def test_findAnswer(self):\n    solution = Solution()\n    edges = [[0, 1, 2]]\n    self.assertEqual(solution.findAnswer(2, edges), [True, False])", "def test_findAnswer(self):\n    solution = Solution()\n    edges = []\n    self.assertEqual(solution.findAnswer(0, edges), [])", "def test_findAnswer(self):\n    solution = Solution()\n    edges = [[0, 1, 2], [3, 4, 5]]\n    self.assertEqual(solution.findAnswer(6, edges), [True, False, True, True])", "def test_findAnswer(self):\n    solution = Solution()\n    edges = [[0, 1, 2], [3, 4, 5]]\n    self.assertEqual(solution.findAnswer(6, edges), [True, False, True, True])", "def test_findAnswer(self):\n    solution = Solution()\n    edges = [[0, 1, 2], [3, 4, 5]]\n    self.assertEqual(solution.findAnswer(6, edges), [True, False, True, True])", "def test_findAnswer(self):\n    solution = Solution()\n    edges = [[0, 1, 2], [4, 5, 6]]\n    self.assertEqual(solution.findAnswer(7, edges), [True, False, True, True])", "def test_findAnswer(self):\n    solution = Solution()\n    edges = [[0, 1, 2], [4, 5, 6]]\n    self.assertEqual(solution.findAnswer(7, edges), [True, False, True, True])", "def test_findAnswer(self):\n    solution = Solution()\n    edges = [[0, 1, 2]]\n    self.assertEqual(solution.findAnswer(3, edges), [True, False])", "def test_findAnswer(self):\n    solution = Solution()\n    edges = []\n    self.assertEqual(solution.findAnswer(5, edges), [False, False, False, False])", "def test_findAnswer(self):\n    solution = Solution()\n    edges = [[0, 1, 2], [5, 6, 7]]\n    self.assertEqual(solution.findAnswer(8, edges), [True, False, True, True])", "def test_findAnswer(self):\n    solution = Solution()\n    edges = [[0, 2, 1], [3, 4, 5]]\n    self.assertEqual(solution.findAnswer(6, edges), [False, True, False, True])", "def test_findAnswer(self):\n    solution = Solution()\n    edges = [[0, 1, 2], [5, 6, 7]]\n    self.assertEqual(solution.findAnswer(8, edges), [True, False, True, True])", "def test_findAnswer(self):\n    solution = Solution()\n    edges = [[0, 1, 2], [3, 4, 5]]\n    self.assertEqual(solution.findAnswer(6, edges), [True, False, True, True])"]}
