{"task_num": 4, "task_title": "Median of Two Sorted Arrays", "func_name": "findMedianSortedArrays", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n    n1 = len(nums1)\n    n2 = len(nums2)\n    if n1 > n2:\n      return self.findMedianSortedArrays(nums2, nums1)\n\n    l = 0\n    r = n1\n\n    while l <= r:\n      partition1 = (l + r) // 2\n      partition2 = (n1 + n2 + 1) // 2 - partition1\n      maxLeft1 = -2**31 if partition1 == 0 else nums1[partition1 - 1]\n      maxLeft2 = -2**31 if partition2 == 0 else nums2[partition2 - 1]\n      minRight1 = 2**31 - 1 if partition1 == n1 else nums1[partition1]\n      minRight2 = 2**31 - 1 if partition2 == n2 else nums2[partition2]\n      if maxLeft1 <= minRight2 and maxLeft2 <= minRight1:\n        if (n1 + n2) % 2 == 0:\n          return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) * 0.5\n        else:\n          return max(maxLeft1, maxLeft2)\n      elif maxLeft1 > minRight2:\n        r = partition1 - 1\n      else:\n        l = partition1 + 1\n", "tests": ["def test_findMedianSortedArrays():\n    solution = Solution()\n    result = solution.findMedianSortedArrays([1, 3], [2])", "def test_findMedianSortedArrays():\n    solution = Solution()\n    result = solution.findMedianSortedArrays([1, 2], [3, 4])", "def test_findMedianSortedArrays():\n    solution = Solution()\n    result = solution.findMedianSortedArrays([], [1])", "def test_findMedianSortedArrays():\n    solution = Solution()\n    result = solution.findMedianSortedArrays([3], [-2, -1])", "def test_findMedianSortedArrays():\n    solution = Solution()\n    result = solution.findMedianSortedArrays([0, 0], [0, 0])", "def test_findMedianSortedArrays():\n    solution = Solution()\n    result = solution.findMedianSortedArrays([1, 2, 3], [4, 5])", "def test_findMedianSortedArrays():\n    solution = Solution()\n    result = solution.findMedianSortedArrays([10], [])", "def test_findMedianSortedArrays():\n    solution = Solution()\n    result = solution.findMedianSortedArrays([1, 3], [2, 4])", "def test_findMedianSortedArrays():\n    solution = Solution()\n    result = solution.findMedianSortedArrays([1], [-2, -1, 0])", "def test_findMedianSortedArrays():\n    solution = Solution()\n    result = solution.findMedianSortedArrays([100], [1, 2, 3, 4, 5])", "def test_findMedianSortedArrays():\n    solution = Solution()\n    result = solution.findMedianSortedArrays([1, 2, 3], [4, 5, 6])", "def test_findMedianSortedArrays():\n    solution = Solution()\n    result = solution.findMedianSortedArrays([-10], [-20])", "def test_findMedianSortedArrays():\n    solution = Solution()\n    result = solution.findMedianSortedArrays([100], [200])", "def test_findMedianSortedArrays():\n    solution = Solution()\n    result = solution.findMedianSortedArrays([10, 20], [-5, 0])", "def test_findMedianSortedArrays():\n    solution = Solution()\n    result = solution.findMedianSortedArrays([0], [-1, 2])", "def test_findMedianSortedArrays():\n    solution = Solution()\n    result = solution.findMedianSortedArrays([-1], [-2])", "def test_findMedianSortedArrays():\n    solution = Solution()\n    result = solution.findMedianSortedArrays([1, 3], [-2, -4])", "def test_findMedianSortedArrays():\n    solution = Solution()\n    result = solution.findMedianSortedArrays([1, 2], [3])", "def test_findMedianSortedArrays():\n    solution = Solution()\n    result = solution.findMedianSortedArrays([1000], [-999])", "def test_findMedianSortedArrays():\n    solution = Solution()\n    result = solution.findMedianSortedArrays([10], [5, 6, 7])"]}
{"task_num": 10, "task_title": "Regular Expression Matching", "func_name": "isMatch", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isMatch(self, s: str, p: str) -> bool:\n    m = len(s)\n    n = len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    def isMatch(i: int, j: int) -> bool:\n      return j >= 0 and p[j] == '.' or s[i] == p[j]\n\n    for j, c in enumerate(p):\n      if c == '*' and dp[0][j - 1]:\n        dp[0][j + 1] = True\n\n    for i in range(m):\n      for j in range(n):\n        if p[j] == '*':\n          noRepeat = dp[i + 1][j - 1]\n          doRepeat = isMatch(i, j - 1) and dp[i][j + 1]\n          dp[i + 1][j + 1] = noRepeat or doRepeat\n        elif isMatch(i, j):\n          dp[i + 1][j + 1] = dp[i][j]\n\n    return dp[m][n]\n", "tests": ["def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('aa', 'a') == False", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('aa', 'a*') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('ab', '.*') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('aab', 'c*a*b') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('mississippi', 'mis*is*p*.') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('abc', 'a.c') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('aaa', 'a*a') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('b', '.*a*') == False", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('abcd', 'd*') == False", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('aaa', 'a*a*') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('aaa', 'ab*a*c*a') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('aaa', 'ab*a*c') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('aaa', 'a*a*c*') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('aaa', 'a*a*c*') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('ab', 'a*b') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('abc', '.*c') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('abc', 'a.*d') == False", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('abc', 'a.*') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('abc', 'a.*d') == False", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('abc', 'a.*c') == True"]}
{"task_num": 15, "task_title": "3Sum", "func_name": "threeSum", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def threeSum(self, nums: List[int]) -> List[List[int]]:\n    if len(nums) < 3:\n      return []\n\n    ans = []\n\n    nums.sort()\n\n    for i in range(len(nums) - 2):\n      if i > 0 and nums[i] == nums[i - 1]:\n        continue\n\n      l = i + 1\n      r = len(nums) - 1\n      while l < r:\n        summ = nums[i] + nums[l] + nums[r]\n        if summ == 0:\n          ans.append((nums[i], nums[l], nums[r]))\n          l += 1\n          r -= 1\n          while nums[l] == nums[l - 1] and l < r:\n            l += 1\n          while nums[r] == nums[r + 1] and l < r:\n            r -= 1\n        elif summ < 0:\n          l += 1\n        else:\n          r -= 1\n\n    return ans\n", "tests": ["def test_threeSum():\n    solution = Solution()\n    input_nums = [-1, 0, 1, 2, -1, -4]\n    expected_output = [(-1, -1, 2), (-1, 0, 1)]\n    assert sorted(solution.threeSum(input_nums)) == sorted(expected_output)", "def test_threeSum():\n    solution = Solution()\n    input_nums = []\n    expected_output = []\n    assert solution.threeSum(input_nums) == expected_output", "def test_threeSum():\n    solution = Solution()\n    input_nums = [-1000, 0, 1000]\n    expected_output = [(-1000, 0, 1000)]\n    assert sorted(solution.threeSum(input_nums)) == sorted(expected_output)", "def test_threeSum():\n    solution = Solution()\n    input_nums = [-1, 0, 1]\n    expected_output = [(-1, 0, 1)]\n    assert sorted(solution.threeSum(input_nums)) == sorted(expected_output)", "def test_threeSum():\n    solution = Solution()\n    input_nums = [-1, -1, -1]\n    expected_output = []\n    assert solution.threeSum(input_nums) == expected_output", "def test_threeSum():\n    solution = Solution()\n    input_nums = [-4, -2, -1, 0, 0, 1, 2, 3]\n    expected_output = [(-4, 0, 4), (-2, -1, 3)]\n    assert sorted(solution.threeSum(input_nums)) == sorted(expected_output)", "def test_threeSum():\n    solution = Solution()\n    input_nums = [-1000, 0, 1000, -500, 500, 0]\n    expected_output = [(-1000, 0, 1000), (-500, -250, 750)]\n    assert sorted(solution.threeSum(input_nums)) == sorted(expected_output)", "def test_threeSum():\n    solution = Solution()\n    input_nums = [-1000, -500, 0, 500, 1000]\n    expected_output = [(-1000, 0, 1000), (-500, -250, 750)]\n    assert sorted(solution.threeSum(input_nums)) == sorted(expected_output)", "def test_threeSum():\n    solution = Solution()\n    input_nums = [-1000, -500, 0, 500, 1000, -998, -499, -1, 2, 997, -1000, -500, 0, 500, 1000]\n    expected_output = [(-1000, 0, 1000), (-500, -250, 750), (-998, 0, 998), (-997, -1, 998), (-997, 0, 997), (-499, 0, 999)]\n    assert sorted(solution.threeSum(input_nums)) == sorted(expected_output)", "def test_threeSum():\n    input_nums = [0, -1, 2, -3, 4]\n    expected_output = [[-3, 0, 3], [-3, 1, 2], [-2, 0, 2], [-2, 1, 1]]\n    result = solution.threeSum(input_nums)", "def test_threeSum():\n    input_nums = [1]\n    expected_output = []\n    result = solution.threeSum(input_nums)", "def test_threeSum():\n    import random\n    n = 1000\n    input_nums = [random.randint(-100, 100) for _ in range(n)]\n    result = solution.threeSum(input_nums)", "def test_threeSum():\n    input_nums = [10 ** 9, -10 ** 9, 0, 10 ** 6, -10 ** 6]\n    expected_output = [[-10 ** 9, 10 ** 9, 0], [-10 ** 6, 10 ** 6, 0]]\n    result = solution.threeSum(input_nums)", "def test_threeSum():\n    input_nums = [-2, 0, 1, 1, -2, -4]\n    expected_output = [[-2, 0, 2], [-2, -1, 3], [-2, 1, 1]]\n    result = solution.threeSum(input_nums)", "def test_threeSum():\n    input_nums = [-4, -1, 0, 1, 2]\n    expected_output = [[-4, 0, 4], [-4, 1, 3], [-1, 0, 1]]\n    result = solution.threeSum(input_nums)", "def test_threeSum():\n    input_nums = [1, 2, 3, 4, 5]\n    expected_output = []\n    result = solution.threeSum(input_nums)", "def test_threeSum():\n    input_nums = [0, 0, 0]\n    expected_output = [[0, 0, 0]]\n    result = solution.threeSum(input_nums)", "def test_threeSum():\n    input_nums = [-10 ** 9, -5 ** 8, 10 ** 7, 5 ** 6, 10 ** 6]\n    expected_output = [[-10 ** 9, 10 ** 9, 0], [-10 ** 7, 10 ** 7, 0]]\n    result = solution.threeSum(input_nums)", "def test_threeSum():\n    input_nums = [-10 ** 9, -5 ** 8, 0, 10 ** 7, 5 ** 6, 10 ** 6]\n    expected_output = [[-10 ** 9, 10 ** 9, 0], [-10 ** 7, 10 ** 7, 0]]\n    result = solution.threeSum(input_nums)", "def test_threeSum():\n    input_nums = [-10 ** 9, -5 ** 8, 2, 10 ** 7, 5 ** 6, 10 ** 6, 0]\n    expected_output = [[-10 ** 9, 10 ** 9, 0], [-10 ** 7, 10 ** 7, 0]]\n    result = solution.threeSum(input_nums)"]}
{"task_num": 44, "task_title": "Wildcard Matching", "func_name": "isMatch", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isMatch(self, s: str, p: str) -> bool:\n    m = len(s)\n    n = len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    def isMatch(i: int, j: int) -> bool:\n      return i >= 0 and p[j] == '?' or s[i] == p[j]\n\n    for j, c in enumerate(p):\n      if c == '*':\n        dp[0][j + 1] = dp[0][j]\n\n    for i in range(m):\n      for j in range(n):\n        if p[j] == '*':\n          matchEmpty = dp[i + 1][j]\n          matchSome = dp[i][j + 1]\n          dp[i + 1][j + 1] = matchEmpty or matchSome\n        elif isMatch(i, j):\n          dp[i + 1][j + 1] = dp[i][j]\n\n    return dp[m][n]\n", "tests": ["def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('aa', 'a') == False", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('abc', '') == False", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('', '*') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('abcde', 'ab*?e') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('', '') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('abcde', '?*e') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('abcde', '*ab*?e') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('abcde', '?*e') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('abcde', '*ab*?e') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('abc', '?*?') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('abcde', '*ab*?e') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('abcde', '?*?') == True", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('abc', 'a\\\\?b*c') == False", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('abc', 'a\\\\?b*c') == False", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('abc', 'a\\\\?b*c') == False", "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('', 'a\\\\?b*c') == False", "def test_isMatch():\n    long_string = 'a' * 10000 + '?*e'\n    short_string = 'b' * 5000\n    solution = Solution()\n    assert not solution.isMatch(short_string, long_string)", "def test_isMatch():\n    long_string = 'a' * 10000 + '?*e'\n    short_string = ''\n    solution = Solution()\n    assert not solution.isMatch(short_string, long_string)", "def test_isMatch():\n    long_string = 'a' * 10000 + '?*e'\n    short_string = 'b' * 5000\n    solution = Solution()\n    assert not solution.isMatch(short_string, long_string)", "def test_isMatch():\n    long_string = 'a' * 10000 + '?*e'\n    short_string = ''\n    solution = Solution()\n    assert not solution.isMatch(short_string, long_string)"]}
{"task_num": 54, "task_title": "Spiral Matrix", "func_name": "spiralOrder", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n    if not matrix:\n      return []\n\n    m = len(matrix)\n    n = len(matrix[0])\n    ans = []\n    r1 = 0\n    c1 = 0\n    r2 = m - 1\n    c2 = n - 1\n\n    while len(ans) < m * n:\n      j = c1\n      while j <= c2 and len(ans) < m * n:\n        ans.append(matrix[r1][j])\n        j += 1\n      i = r1 + 1\n      while i <= r2 - 1 and len(ans) < m * n:\n        ans.append(matrix[i][c2])\n        i += 1\n      j = c2\n      while j >= c1 and len(ans) < m * n:\n        ans.append(matrix[r2][j])\n        j -= 1\n      i = r2 - 1\n      while i >= r1 + 1 and len(ans) < m * n:\n        ans.append(matrix[i][c1])\n        i -= 1\n      r1 += 1\n      c1 += 1\n      r2 -= 1\n      c2 -= 1\n\n    return ans\n", "tests": ["def test_spiralOrder():\n    solution = Solution()\n    result = solution.spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]])", "def test_spiralOrder():\n    solution = Solution()\n    result = solution.spiralOrder([])", "def test_spiralOrder():\n    solution = Solution()\n    matrix = [[i * j for j in range(1, 4)] for i in range(1, 5)]\n    result = solution.spiralOrder(matrix)", "def test_spiralOrder():\n    solution = Solution()\n    result = solution.spiralOrder([[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]])", "def test_spiralOrder():\n    solution = Solution()\n    matrix = [[1], [2], [3]]\n    result = solution.spiralOrder(matrix)", "def test_spiralOrder():\n    solution = Solution()\n    result = solution.spiralOrder([[1, 2], ['a', 'b']])", "def test_spiralOrder():\n    solution = Solution()\n    result = solution.spiralOrder([[1, 2], [3]])", "def test_spiralOrder():\n    solution = Solution()\n    result = solution.spiralOrder([[1000, 2000], [3000, 4000]])", "def test_spiralOrder():\n    solution = Solution()\n    matrix = [[1], [2, 3], [], [4]]\n    result = solution.spiralOrder(matrix)", "def test_spiralOrder():\n    solution = Solution()\n    matrix = [[1, 'a'], [2], ['b', 3, 4]]\n    result = solution.spiralOrder(matrix)", "def test_spiralOrder():\n    solution = Solution()\n    matrix = [[1, 'a', 2], [3, 'b'], ['c', 4] * 5]\n    result = solution.spiralOrder(matrix)", "def test_spiralOrder():\n    solution = Solution()\n    matrix = [[1, 2, 3] * 4 for _ in range(5)] + [[4, 5] * 7] * 2\n    result = solution.spiralOrder(matrix)", "def test_spiralOrder():\n    solution = Solution()\n    matrix = [[1, 2, 3] * 4 for _ in range(5)] + [['a', 'b'] * 7] * 6 + [[4, 5] * 8] * 7\n    result = solution.spiralOrder(matrix)", "def test_spiralOrder():\n    solution = Solution()\n    matrix = [[1, 2, 3] * 4 for _ in range(5)] + [['a', 'b'] * 7] * 6 + [[4, 5] * 8] * 7 + [[6, 7]] * 9 + [['c', 'd']] * 10\n    result = solution.spiralOrder(matrix)", "def test_spiralOrder():\n    solution = Solution()\n    matrix = [[1, 2, 3] * 4 for _ in range(5)] + [['a', 'b'] * 7] * 6 + [[4, 5] * 8] * 7 + [[6, 7]] * 9 + [['c', 'd']] * 10 + [['e', 'f']] * 11 + [['g', 'h', 'i']] * 12\n    result = solution.spiralOrder(matrix)", "def test_spiralOrder():\n    solution = Solution()\n    matrix = [[1, 2, 3] * 4 for _ in range(5)] + [['a', 'b'] * 7 for _ in range(6)] + [[4, 5] * 8 for _ in range(7)] + [[6, 7] for _ in range(8)] + [['c', 'd'] * 9 for _ in range(10)] + [['e', 'f'] * 11 for _ in range(12)] + [['g', 'h', 'i'] * 13 for _ in range(14)] + [['j', 'k', 'l', 'm'] * 15 for _ in range(16)]\n    result = solution.spiralOrder(matrix)", "def test_spiralOrder_single_row_or_column(self):\n    # Test with a single-row matrix\n    single_row_matrix = [[1, 2, 3]]\n    self.assertEqual(spiralOrder(single_row_matrix), [1, 2, 3])\n\n    # Test with a single-column matrix\n    single_column_matrix = [[1], [2], [3]]\n    self.assertEqual(spiralOrder(single_column_matrix), [1, 2, 3])\n```\n\n### Explanation:\n- **Single Row Matrix:** In this case, the function should simply return the elements of the row in order.\n- **Single Column Matrix:** Here, the function should return the elements of the column in order.\n", "def test_spiralOrder_alternating_patterns(self):\n    # Test with an alternating pattern row\n    alternating_row_matrix = [[1, 2, 3], [6, 5, 4]]\n    self.assertEqual(spiralOrder(alternating_row_matrix), [1, 2, 3, 4, 5, 6])\n\n    # Test with an alternating pattern column\n    alternating_column_matrix = [[1, 6], [2, 5], [3, 4]]\n    self.assertEqual(spiralOrder(alternating_column_matrix), [1, 6, 5, 4, 3, 2])\n```\n\n### Explanation:\n- **Alternating Pattern Row:** The matrix has alternating increasing and decreasing patterns in each row. The function should correctly read the elements in a spiral order.\n- **Alternating Pattern Column:** The matrix has alternating increasing and decreasing patterns in each column. The function should correctly read the elements in a spiral order.\n\nThis test method ensures that the function handles matrices with alternating sequences, which can be more complex than simple numerical sequences. It will help verify that the function behaves as expected under such conditions.\n", "def test_spiralOrder_complex_sequences(self):\n    # Test with a matrix containing increasing and decreasing patterns\n    complex_matrix = [\n        [1, 2, 3],\n        [8, 7, 4],\n        [9, 6, 5]\n    ]\n    self.assertEqual(spiralOrder(complex_matrix), [1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n    # Test with a matrix containing zero values\n    zero_values_matrix = [\n        [0, 0],\n        [0, 0]\n    ]\n    self.assertEqual(spiralOrder(zero_values_matrix), [0, 0, 0, 0])\n\n    # Test with a matrix containing alternating zero and non-zero values\n    mixed_values_matrix = [\n        [1, 0, 2],\n        [0, 3, 0],\n        [4, 0, 5]\n    ]\n    self.assertEqual(spiralOrder(mixed_values_matrix), [1, 0, 2, 0, 3, 0, 4, 0, 5])\n```\n\n### Explanation:\n- **Increasing and Decreasing Patterns:** The matrix contains both increasing and decreasing patterns. The function should correctly read the elements in a spiral order.\n- **Zero Values:** All elements in the matrix are zero. The function should correctly handle this edge case.\n- **Mixed Values:** The matrix contains a mix of zero values and non-zero values. The function should correctly read the elements in a spiral order, including handling zeros appropriately.\n", "def test_spiralOrder_nested_patterns(self):\n    # Test with a matrix containing nested patterns\n    nested_matrix = [\n        [1, 2, 3, 4],\n        [12, 13, 14, 5],\n        [11, 16, 15, 6],\n        [10, 9, 8, 7]\n    ]\n    self.assertEqual(spiralOrder(nested_matrix), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16])\n\n    # Test with a more complex nested pattern\n    complex_nested_matrix = [\n        [1, 2, 3, 4],\n        [12, 13, 14, 5],\n        [11, 16, 17, 6],\n        [10, 9, 8, 7]\n    ]\n    self.assertEqual(spiralOrder(complex_nested_matrix), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16])\n\n    # Test with a matrix containing a single element\n    single_element_matrix = [[5]]\n    self.assertEqual(spiralOrder(single_element_matrix), [5])\n```\n\n### Explanation:\n- **Nested Patterns:** The matrix contains nested patterns with elements arranged in a spiral order. The function should correctly read the elements in the specified order.\n- **Complex Nested Pattern:** Similar to the previous nested pattern, but with an additional layer of complexity. The function should handle this nested structure correctly.\n- **Single Element Matrix:** A matrix containing only one element. The function should return that single element as the result.\n"]}
{"task_num": 65, "task_title": "Valid Number", "func_name": "isNumber", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isNumber(self, s: str) -> bool:\n    s = s.strip()\n    if not s:\n      return False\n\n    seenNum = False\n    seenDot = False\n    seenE = False\n\n    for i, c in enumerate(s):\n      if c == '.':\n        if seenDot or seenE:\n          return False\n        seenDot = True\n      elif c == 'e' or c == 'E':\n        if seenE or not seenNum:\n          return False\n        seenE = True\n        seenNum = False\n      elif c in '+-':\n        if i > 0 and s[i - 1] not in 'eE':\n          return False\n        seenNum = False\n      else:\n        if not c.isdigit():\n          return False\n        seenNum = True\n\n    return seenNum\n", "tests": ["def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('2') == True", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber(' 0.1 ') == True", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('+1.23e4') == True", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('5e-10') == True", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('-0.345e-2') == True", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('100a') == False", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('.5') == True", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('1e+200') == True", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('-1E-6') == True", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('3.141592653589793') == True", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('123e-456') == True", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('0') == True", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('.1e-123') == True", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('abc') == False", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('123e-456.') == False", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('--10') == False", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('10e-5.3') == False", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('+-.5') == False", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('123.') == True", "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('-123') == True"]}
{"task_num": 73, "task_title": "Set Matrix Zeroes", "func_name": "setZeroes", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def setZeroes(self, matrix: List[List[int]]) -> None:\n    m = len(matrix)\n    n = len(matrix[0])\n    shouldFillFirstRow = 0 in matrix[0]\n    shouldFillFirstCol = 0 in list(zip(*matrix))[0]\n\n    for i in range(1, m):\n      for j in range(1, n):\n        if matrix[i][j] == 0:\n          matrix[i][0] = 0\n          matrix[0][j] = 0\n\n    for i in range(1, m):\n      for j in range(1, n):\n        if matrix[i][0] == 0 or matrix[0][j] == 0:\n          matrix[i][j] = 0\n\n    if shouldFillFirstRow:\n      matrix[0] = [0] * n\n\n    if shouldFillFirstCol:\n      for row in matrix:\n        row[0] = 0\n", "tests": ["def test_setZeroes():\n    solution = Solution()\n    matrix = [[1, 2, 3], [4, 0, 6], [7, 8, 9]]\n    expected = [[1, 0, 3], [0, 0, 0], [7, 0, 9]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[0, 0], [0, 0]]\n    expected = [[0, 0], [0, 0]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[1, 2, 0], [4, 5, 6]]\n    expected = [[0, 0, 0], [4, 5, 0]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[1, 2], [0, 4]]\n    expected = [[0, 0], [0, 0]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[1, 2], [3, 4]]\n    expected = [[1, 2], [3, 4]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[0]]\n    expected = [[0]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    (m, n) = (100, 200)\n    matrix = [[1] * n for _ in range(m)]\n    matrix[50][75] = 0\n    expected = [row[:] for row in matrix]\n    expected[50][:] = [0] * n\n    for row in expected:\n        row[75] = 0\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[1, 1], [1, 1]]\n    expected = [[1, 1], [1, 1]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[1, 2, 3], [4, 0, 6], [7, 8, 9], [10, 11, 0]]\n    expected = [[1, 0, 3], [0, 0, 0], [7, 0, 0], [0, 0, 0]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[1] * 5, [2] * 5, [3] * 5, [4] * 5, [5] * 5]\n    expected = [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    (m, n) = (10, 10)\n    matrix = [[0 if i == j else 1 for j in range(n)] for i in range(m)]\n    expected = [row[:] for row in matrix]\n    expected[5][:] = [0] * n\n    expected[:, 7] = [0] * m\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[0], [1], [2]]\n    expected = [[0], [0], [0]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[1, 0], [2, 3], [4, 5]]\n    expected = [[0, 0], [0, 0], [0, 0]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[1, 2, 3], [4, 0, 6], [7, 8, 9]]\n    expected = [[1, 0, 3], [0, 0, 0], [7, 0, 9]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[0, 2], [4, 0], [7, 8]]\n    expected = [[0, 0], [0, 0], [0, 0]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    (m, n) = (100, 200)\n    matrix = [[1] * n for _ in range(m)]\n    for i in range(50):\n        for j in range(75):\n            if (i + j) % 10 == 0:\n                matrix[i][j] = 0\n    expected = [row[:] for row in matrix]\n    for i in range(50):\n        for j in range(75):\n            if (i + j) % 10 == 0:\n                expected[i][:] = [0] * n\n                expected[:, j] = [0] * m\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[1, 2, 3], [4, 0, 6], [7, 8, 9]]\n    expected = [[1, 0, 3], [0, 0, 0], [7, 0, 9]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[0, 2, 3], [4, 5, 0], [7, 8, 9]]\n    expected = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    matrix = [[0, 1], [2, 3]]\n    expected = [[0, 0], [0, 0]]\n    solution.setZeroes(matrix)", "def test_setZeroes():\n    solution = Solution()\n    (m, n) = (10, 2)\n    matrix = [[1] * n for _ in range(m)]\n    expected = [row[:] for row in matrix]\n    for i in range(5):\n        matrix[i][0] = 0\n    for i in range(5):\n        expected[i][:] = [0] * n\n    solution.setZeroes(matrix)"]}
{"task_num": 97, "task_title": "Interleaving String", "func_name": "isInterleave", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n    m = len(s1)\n    n = len(s2)\n    if m + n != len(s3):\n      return False\n\n    dp=[]\n    for _ in range(m + 1):\n      dp.append([False] * (n + 1))\n    dp[0][0] = True\n\n    for i in range(1, m + 1):\n      dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n\n    for j in range(1, n + 1):\n      dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n\n    return dp[m][n]\n", "tests": ["def test_isInterleave():\n    solution = Solution()\n    assert solution.isInterleave('aabcc', 'dbbca', 'aadbbcbcac') == True", "def test_isInterleave():\n    solution = Solution()\n    assert solution.isInterleave('aa', 'ab', 'aabb') == False", "def test_isInterleave():\n    solution = Solution()\n    assert solution.isInterleave('', '', '') == True", "def test_isInterleave():\n    solution = Solution()\n    assert solution.isInterleave('a', 'b', 'ab') == True", "def test_isInterleave():\n    solution = Solution()\n    assert solution.isInterleave('abc', 'def', 'abcdef') == True", "def test_isInterleave():\n    solution = Solution()\n    assert solution.isInterleave('abc', 'de', 'abcde') == True", "def test_isInterleave():\n    solution = Solution()\n    assert solution.isInterleave('abc', 'defghi', 'abcdefghi') == True", "def test_isInterleave():\n    solution = Solution()\n    assert solution.isInterleave('abc', 'defghi', 'abcdefghj') == False", "def test_isInterleave():\n    solution = Solution()\n    assert solution.isInterleave('abc', 'defghi', 'abcdefgh') == False", "def test_isInterleave():\n    solution = Solution()\n    assert solution.isInterleave('a', 'b', 'ba') == True", "def test_isInterleave():\n    solution = Solution()\n    assert solution.isInterleave('a', 'b', 'ab') == True", "def test_isInterleave():\n    solution = Solution()\n    assert solution.isInterleave('abc', 'defghi', 'abcfghi') == False", "def test_isInterleave():\n    solution = Solution()\n    assert solution.isInterleave('abc', 'defghi', 'aabcdefg') == False", "def test_isInterleave():\n    solution = Solution()\n    assert solution.isInterleave('abc', 'defghi', 'abcdefg') == True", "def test_isInterleave():\n    solution = Solution()\n    assert solution.isInterleave('abc', 'defghi', 'abcdefgh') == True", "def test_isInterleave():\n    solution = Solution()\n    assert solution.isInterleave('abc', 'defghi', 'abcdefghi') == True", "def test_isInterleave():\n    solution = Solution()\n    assert solution.isInterleave('abc', 'defghi', 'abcdefghij') == False", "def test_isInterleave():\n    solution = Solution()\n    assert solution.isInterleave('abc', 'defghi', 'abcdefghij') == False", "def test_isInterleave():\n    solution = Solution()\n    assert solution.isInterleave('abc', 'defghi', 'abcdefghij') == False", "def test_isInterleave():\n    solution = Solution()\n    assert solution.isInterleave('abc', 'defghi', 'abcdefghij') == False"]}
{"task_num": 126, "task_title": "Word Ladder II", "func_name": "findLadders", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Set\n\nclass Solution:\n  def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n    from collections import deque\n    def connected(a: str, b: str) -> bool:\n      k = 0\n      for i in range(len(a)):\n        if a[i] != b[i]:\n          k += 1\n      return k == 1\n\n    if endWord not in wordList:\n      return []\n\n    visited = set([beginWord])\n\n    q = deque([beginWord])\n    nodes = []\n    find = False\n\n    while q and not find:\n      nodes.append(q.copy())\n      n = len(q)\n      for _ in range(n):\n        word = q.popleft()\n        for item in wordList:\n          if item in visited:\n            continue\n          if not connected(word, item):\n            continue\n          if item == endWord:\n            find = True\n            break\n          visited.add(item)\n          q.append(item)\n        if find:\n          break\n\n    if not find:\n      return []\n\n    ans = []\n\n    def backtracking(word, level: int, steps: List[str]):\n      if word == beginWord:\n        ans.append(steps[::-1])\n        return\n      if level < 0:\n        return\n      for item in nodes[level]:\n        if connected(item, word):\n          steps.append(item)\n          backtracking(item, level-1, steps)\n          steps.pop()\n\n    backtracking(endWord, len(nodes)-1, [endWord])\n    return ans\n", "tests": ["def test_findLadders():\n    solution = Solution()\n    assert solution.findLadders('hit', 'cog', ['hot', 'dot', 'dog', 'lot', 'log', 'cog']) == [['hit', 'hot', 'dot', 'dog', 'cog'], ['hit', 'hot', 'lot', 'log', 'cog']]", "def test_findLadders():\n    solution = Solution()\n    assert solution.findLadders('hit', 'cog', ['hot', 'dot', 'dog']) == []", "def test_findLadders():\n    solution = Solution()\n    assert solution.findLadders('a', 'b', ['b']) == [['a', 'b']]", "def test_findLadders():\n    solution = Solution()\n    assert solution.findLadders('hit', 'cog', []) == []", "def test_findLadders():\n    solution = Solution()\n    assert solution.findLadders('hot', 'dog', ['hot', 'dot', 'dog', 'lot', 'log', 'cog']) == [['hot', 'dot', 'dog'], ['hot', 'lot', 'log', 'dog']]", "def test_findLadders():\n    solution = Solution()\n    assert solution.findLadders('hit', 'cog', ['hot', 'dot', 'lot']) == []", "def test_findLadders():\n    solution = Solution()\n    assert solution.findLadders('hello', 'world', ['world', 'another']) == []", "def test_findLadders():\n    solution = Solution()\n    assert solution.findLadders('hot', 'dog', ['hot', 'dot', 'dog', 'lot', 'log', 'cog', 'dot']) == [['hot', 'dot', 'dog'], ['hot', 'lot', 'log', 'dog']]", "def test_findLadders():\n    solution = Solution()\n    assert solution.findLadders('hit', 'cog', ['hot', 'dot', 'dog', 'lot', 'log', 'cog']) == [['hit', 'hot', 'dot', 'dog', 'cog'], ['hit', 'hot', 'lot', 'log', 'cog']]", "def test_findLadders():\n    solution = Solution()\n    assert solution.findLadders('hot', 'lot', ['hot', 'dot']) == []", "def test_findLadders():\n    solution = Solution()\n    assert solution.findLadders('a', 'b', ['b']) == [['a', 'b']]", "def test_findLadders():\n    solution = Solution()\n    assert solution.findLadders('hot', 'lot', ['hot', 'dot']) == []", "def test_findLadders():\n    solution = Solution()\n    assert solution.findLadders('red', 'red', ['red']) == [['red']]", "def test_findLadders():\n    solution = Solution()\n    assert solution.findLadders('a', 'a', ['b']) == []", "def test_findLadders():\n    solution = Solution()\n    assert solution.findLadders('hot', 'lot', ['hot', 'dot']) == []", "def test_findLadders():\n    solution = Solution()\n    assert solution.findLadders('hot', 'dot', ['hot', 'dot', 'hot']) == [['hot', 'dot', 'lot'], ['hot', 'hot', 'lot']]", "def test_findLadders():\n    solution = Solution()\n    assert solution.findLadders('hot', 'dot', ['hot', 'lot']) == []", "def test_findLadders():\n    solution = Solution()\n    assert solution.findLadders('hot', 'dot', ['hot', 'dot', 'hot']) == [['hot', 'dot', 'lot'], ['hot', 'hot', 'lot']]", "def test_findLadders():\n    solution = Solution()\n    assert solution.findLadders('hot', 'dot', ['hot', 'dot', 'hot']) == [['hot', 'dot', 'lot'], ['hot', 'hot', 'lot']]", "def test_findLadders():\n    solution = Solution()\n    assert solution.findLadders('hot', 'dot', ['hot', 'lot']) == []"]}
{"task_num": 130, "task_title": "Surrounded Regions", "func_name": "solve", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def solve(self, board: List[List[str]]) -> None:\n    if not board:\n      return\n\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(board)\n    n = len(board[0])\n    q = collections.deque()\n\n    for i in range(m):\n      for j in range(n):\n        if i * j == 0 or i == m - 1 or j == n - 1:\n          if board[i][j] == 'O':\n            q.append((i, j))\n            board[i][j] = '*'\n\n    while q:\n      i, j = q.popleft()\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if board[x][y] != 'O':\n          continue\n        q.append((x, y))\n        board[x][y] = '*'\n\n    for row in board:\n      for i, c in enumerate(row):\n        if c == '*':\n          row[i] = 'O'\n        else:\n          row[i] = 'X'\n", "tests": ["def test_solve():\n    solution = Solution()\n    board = [['X', 'X', 'X', 'X'], ['X', 'O', 'O', 'X'], ['X', 'X', 'O', 'X'], ['X', 'O', 'X', 'X']]\n    expected = [['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X'], ['X', 'O', 'X', 'X']]\n    solution.solve(board)", "def test_solve():\n    solution = Solution()\n    board = [['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X']]\n    expected = [['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X']]\n    solution.solve(board)", "def test_solve():\n    solution = Solution()\n    board = [['X', 'X', 'X', 'X'], ['X', 'O', 'X', 'X'], ['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X']]\n    expected = [['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X']]\n    solution.solve(board)", "def test_solve():\n    solution = Solution()\n    board = [['X', 'O', 'X', 'O'], ['O', 'X', 'O', 'X'], ['X', 'O', 'X', 'O'], ['O', 'X', 'O', 'X']]\n    expected = [['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X']]\n    solution.solve(board)", "def test_solve():\n    solution = Solution()\n    board = [['O', 'O', 'O', 'O'], ['O', 'X', 'X', 'O'], ['O', 'X', 'O', 'O'], ['O', 'O', 'O', 'O']]\n    expected = [['O', 'O', 'O', 'O'], ['O', 'X', 'X', 'O'], ['O', 'X', 'O', 'O'], ['O', 'O', 'O', 'O']]\n    solution.solve(board)", "def test_solve():\n    solution = Solution()\n    board = [['X', 'X', 'X', 'X'], ['X', 'O', 'O', 'X'], ['X', 'O', 'O', 'X'], ['X', 'X', 'X', 'X']]\n    expected = [['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X']]\n    solution.solve(board)", "def test_solve():\n    solution = Solution()\n    board = [['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X'], ['X', 'X', 'O', 'X'], ['X', 'X', 'X', 'X']]\n    expected = [['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X']]\n    solution.solve(board)", "def test_solve():\n    solution = Solution()\n    board = [['X', 'X', 'X', 'X'], ['X', 'O', 'X', 'X'], ['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X']]\n    expected = [['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X']]\n    solution.solve(board)", "def test_solve():\n    solution = Solution()\n    board = [['O', 'X', 'X', 'O'], ['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X'], ['O', 'X', 'X', 'O']]\n    expected = [['O', 'X', 'X', 'O'], ['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X'], ['O', 'X', 'X', 'O']]\n    solution.solve(board)", "def test_solve():\n    solution = Solution()\n    board = [['O', 'X', 'O'], ['X', 'O', 'X'], ['O', 'X', 'O']]\n    expected = [['O', 'X', 'O'], ['X', 'X', 'X'], ['O', 'X', 'O']]\n    solution.solve(board)", "def test_solve():\n    solution = Solution()\n    board = [['X', 'X', 'X'], ['X', 'X', 'X'], ['X', 'O', 'X']]\n    expected = [['X', 'X', 'X'], ['X', 'X', 'X'], ['X', 'O', 'X']]\n    solution.solve(board)", "def test_solve():\n    solution = Solution()\n    board = []\n    expected = []\n    solution.solve(board)", "def test_solve():\n    solution = Solution()\n    board = [['X', 'O', 'X']]\n    expected = [['X', 'X', 'X']]\n    solution.solve(board)", "def test_solve():\n    solution = Solution()\n    board = [['X'], ['O'], ['X']]\n    expected = [['X'], ['X'], ['X']]\n    solution.solve(board)", "def test_solve():\n    solution = Solution()\n    board = [['X', 'O', 'X'], ['X', 'X', 'X'], ['O', 'X', 'X']]\n    expected = [['X', 'X', 'X'], ['X', 'X', 'X'], ['X', 'X', 'X']]\n    solution.solve(board)", "def test_solve():\n    solution = Solution()\n    board = [['O', 'X', 'O'], ['X', 'O', 'X'], ['O', 'X', 'O']]\n    expected = [['O', 'X', 'O'], ['X', 'X', 'X'], ['O', 'X', 'O']]\n    solution.solve(board)", "def test_solve():\n    solution = Solution()\n    board = [['O', 'O', 'O'], ['O', 'O', 'O'], ['O', 'O', 'O']]\n    expected = [['X', 'X', 'X'], ['X', 'X', 'X'], ['X', 'X', 'X']]\n    solution.solve(board)", "def test_solve():\n    solution = Solution()\n    board = [['X', 'X', 'X'], ['X', 'X', 'X'], ['X', 'X', 'X']]\n    expected = [['X', 'X', 'X'], ['X', 'X', 'X'], ['X', 'X', 'X']]\n    solution.solve(board)", "def test_solve():\n    n = 100\n    solution = Solution()\n    board = [['O'] * n for _ in range(n)]\n    expected = [['X'] * n for _ in range(n)]\n    solution.solve(board)", "def test_solve():\n    solution = Solution()\n    board = [['X', 'O', 'X']]\n    expected = [['X', 'X', 'X']]\n    solution.solve(board)"]}
{"task_num": 132, "task_title": "Palindrome Partitioning II", "func_name": "minCut", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minCut(self, s: str) -> int:\n    n = len(s)\n    isPalindrome=[]\n    for _ in range(n):\n      isPalindrome.append([True] * n)\n    dp = [n] * n\n\n    for l in range(2, n + 1):\n      i = 0\n      for j in range(l - 1, n):\n        isPalindrome[i][j] = s[i] == s[j] and isPalindrome[i + 1][j - 1]\n        i += 1\n\n    for i in range(n):\n      if isPalindrome[0][i]:\n        dp[i] = 0\n        continue\n\n      for j in range(i):\n        if isPalindrome[j + 1][i]:\n          dp[i] = min(dp[i], dp[j] + 1)\n\n    return dp[-1]\n", "tests": ["def test_minCut():\n    solution = Solution()\n    assert solution.minCut('aab') == 1", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('a') == 0", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('ababa') == 0", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('abcba') == 0", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('racecar') == 0", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('abccba') == 0", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('abcdcba') == 0", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('abacaba') == 0", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('abcabac') == 1", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('abcabac') == 1", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('abcadcb') == 2", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('abccbaa') == 1", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('abba') == 0", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('aabb') == 1", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('abacabad') == 2", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('abacabad') == 2", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('abcba') == 0", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('abccba') == 0", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('abcabac') == 1", "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('abcabac') == 1"]}
{"task_num": 218, "task_title": "The Skyline Problem", "func_name": "getSkyline", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:\n    n = len(buildings)\n    if n == 0:\n      return []\n    if n == 1:\n      left, right, height = buildings[0]\n      return [[left, height], [right, 0]]\n\n    left = self.getSkyline(buildings[:n // 2])\n    right = self.getSkyline(buildings[n // 2:])\n    return self._merge(left, right)\n\n  def _merge(self, left: List[List[int]], right: List[List[int]]) -> List[List[int]]:\n    ans = []\n    i = 0\n    j = 0\n    leftY = 0\n    rightY = 0\n\n    while i < len(left) and j < len(right):\n      if left[i][0] < right[j][0]:\n        leftY = left[i][1]\n        self._addPoint(ans, left[i][0], max(left[i][1], rightY))\n        i += 1\n      else:\n        rightY = right[j][1]\n        self._addPoint(ans, right[j][0], max(right[j][1], leftY))\n        j += 1\n\n    while i < len(left):\n      self._addPoint(ans, left[i][0], left[i][1])\n      i += 1\n\n    while j < len(right):\n      self._addPoint(ans, right[j][0], right[j][1])\n      j += 1\n\n    return ans\n\n  def _addPoint(self, ans: List[List[int]], x: int, y: int) -> None:\n    if ans and ans[-1][0] == x:\n      ans[-1][1] = y\n      return\n    if ans and ans[-1][1] == y:\n      return\n    ans.append([x, y])\n", "tests": ["def test_getSkyline():\n    solution = Solution()\n    buildings = [[2, 9, 10], [3, 7, 15], [5, 12, 12], [15, 20, 10], [19, 24, 8]]\n    expected = [[2, 10], [3, 15], [7, 12], [12, 0], [15, 10], [20, 8], [24, 0]]\n    assert solution.getSkyline(buildings) == expected", "def test_getSkyline():\n    solution = Solution()\n    buildings = []\n    expected = []\n    assert solution.getSkyline(buildings) == expected", "def test_getSkyline():\n    solution = Solution()\n    buildings = [[1, 5, 3], [4, 6, 2], [7, 8, 4]]\n    expected = [[1, 3], [4, 3], [5, 0], [7, 4], [8, 0]]\n    assert solution.getSkyline(buildings) == expected", "def test_getSkyline():\n    solution = Solution()\n    buildings = [[1, 3, -2], [2, 5, -1]]\n    expected = [[1, -2], [3, -1], [5, 0]]\n    assert solution.getSkyline(buildings) == expected", "def test_getSkyline():\n    solution = Solution()\n    buildings = [[1, 3, 5], [2, 4, 3]]\n    expected = [[1, 5], [2, 5], [3, 0]]\n    assert solution.getSkyline(buildings) == expected", "def test_getSkyline():\n    solution = Solution()\n    buildings = [[2, 4, 3], [1, 3, 5]]\n    expected = [[1, 5], [2, 5], [3, 0]]\n    assert solution.getSkyline(buildings) == expected", "def test_getSkyline():\n    solution = Solution()\n    buildings = [[1, 1, 2]]\n    expected = [[1, 2], [1, 0]]\n    assert solution.getSkyline(buildings) == expected", "def test_getSkyline():\n    solution = Solution()\n    buildings = [[1, -2, 3], [0, 5, 4]]\n    expected = [[0, 4], [-2, 3], [5, 0]]\n    assert solution.getSkyline(buildings) == expected", "def test_getSkyline():\n    solution = Solution()\n    buildings = [[1, 2, 3], [2, 4, 5]]\n    expected = [[1, 3], [2, 5], [4, 0]]\n    assert solution.getSkyline(buildings) == expected", "def test_getSkyline():\n    solution = Solution()\n    buildings = [[1, 3, 5], [2, 4, 3], [5, 6, 2]]\n    expected = [[1, 5], [2, 5], [3, 0], [4, 2], [6, 0]]\n    assert solution.getSkyline(buildings) == expected", "def test_getSkyline():\n    solution = Solution()\n    buildings = [[-1, 0, -2], [-2, -1, -3], [0, 2, -1]]\n    expected = [[-2, -3], [-1, -2], [0, -1], [2, 0]]\n    assert solution.getSkyline(buildings) == expected", "def test_getSkyline():\n    solution = Solution()\n    buildings = [[1, 2, -3], [0, 5, -4], [-2, 0, -2]]\n    expected = [[-2, -2], [-1, -4], [0, -3], [5, 0]]\n    assert solution.getSkyline(buildings) == expected", "def test_getSkyline():\n    solution = Solution()\n    buildings = [[-2, -1, -3], [0, 2, -4], [-1, 0, -5]]\n    expected = [[-2, -3], [-1, -5], [0, -4], [2, 0]]\n    assert solution.getSkyline(buildings) == expected", "def test_getSkyline():\n    solution = Solution()\n    buildings = [[-2, -1, -3], [0, 2, -4], [-1, 0, -5], [1, 4, -6]]\n    expected = [[-2, -3], [-1, -5], [0, -4], [1, -6], [2, 0], [4, 0]]\n    assert solution.getSkyline(buildings) == expected", "def test_getSkyline():\n    solution = Solution()\n    buildings = [[-2, -1, 0], [0, 2, -4], [-1, 0, -5], [1, 4, 0]]\n    expected = [[-2, 0], [-1, -5], [0, -4], [1, 0], [2, 0]]\n    assert solution.getSkyline(buildings) == expected", "def test_getSkyline():\n    solution = Solution()\n    buildings = [[-2, -1, 0], [0, 2, -4], [-1, 0, -5], [1, 4, 0], [-3, -2, -6]]\n    expected = [[-3, -6], [-2, 0], [-1, -5], [0, -4], [1, 0], [2, 0], [-2, 0]]\n    assert solution.getSkyline(buildings) == expected", "def test_getSkyline():\n    solution = Solution()\n    buildings = [[-2, -1, 0], [0, 2, -4], [-1, 0, -5], [1, 4, 0], [-3, -2, -6], [3, 5, -7]]\n    expected = [[-3, -6], [-2, 0], [-1, -5], [0, -4], [1, 0], [2, 0], [-2, 0], [3, -7], [5, 0]]\n    assert solution.getSkyline(buildings) == expected", "def test_getSkyline():\n    solution = Solution()\n    buildings = [[-2, -1, 0], [0, 2, -4], [-1, 0, -5], [1, 4, 0], [-3, -2, -6], [3, 5, -7], [-4, -3, -8], [2, 4, -9]]\n    expected = [[-4, -8], [-3, -6], [-2, 0], [-1, -5], [0, -4], [1, 0], [2, 0], [-2, 0], [3, -7], [5, 0], [-4, 0]]\n    assert solution.getSkyline(buildings) == expected", "def test_getSkyline():\n    solution = Solution()\n    buildings = [[-2, -1, -5], [-3, -2, -6], [0, 2, -4], [1, 3, -5], [2, 4, -9], [4, 6, -2], [5, 7, 0], [-1, 0, -5]]\n    expected = [[-3, -6], [-2, -5], [-1, -5], [0, -4], [1, -5], [2, -9], [4, -2], [5, 0], [8, 0]]\n    assert solution.getSkyline(buildings) == expected", "def test_getSkyline():\n    solution = Solution()\n    buildings = [[-2, -1, 0]]\n    expected = [[-2, 0], [-1, 0]]\n    assert solution.getSkyline(buildings) == expected"]}
{"task_num": 227, "task_title": "Basic Calculator II", "func_name": "calculate", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def calculate(self, s: str) -> int:\n    ans = 0\n    prevNum = 0\n    currNum = 0\n    op = '+'\n\n    for i, c in enumerate(s):\n      if c.isdigit():\n        currNum = currNum * 10 + int(c)\n      if not c.isdigit() and c != ' ' or i == len(s) - 1:\n        if op == '+' or op == '-':\n          ans += prevNum\n          prevNum = currNum if op == '+' else -currNum\n        elif op == '*':\n          prevNum = prevNum * currNum\n        elif op == '/':\n          if prevNum < 0:\n            prevNum = math.ceil(prevNum / currNum)\n          else:\n            prevNum = prevNum // currNum\n        op = c\n        currNum = 0\n\n    return ans + prevNum\n", "tests": ["def test_calculate():\n    solution = Solution()\n    assert solution.calculate('3+5*2-8/4') == 6", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('-3+5*-2-8/(-4)') == 6", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('05+3*2-1') == 9", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('-0*5+2') == 2", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('-5+3*-2-8/(-4)') == 6", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('2147483647') == 2147483647", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('1+2*3-4/5*6+7-8') == 0", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('10000/2') == 5000", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('10+2.5*4-8/(-3)') == 26", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('10*2+3-4/5*6-7') == -2", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('-10-2*3+4/(-5)*6-7') == -29", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('10+2-3*4/5*(-6)+7') == -3", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('((1+2)*(3-4))') == -2", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('((3+5)*2-8)/4') == 1", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('((1+2)*(3-4))+(5*6)') == 28", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('2*3*4*5') == 120", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('-3 * -2 + 1') == 7", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('(10+2)*(3-4)-5*6+7') == -29", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('10/2/5') == 1", "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('(2*3)*(4+5)') == 42"]}
{"task_num": 289, "task_title": "Game of Life", "func_name": "gameOfLife", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def gameOfLife(self, board: List[List[int]]) -> None:\n    m = len(board)\n    n = len(board[0])\n\n    for i in range(m):\n      for j in range(n):\n        ones = 0\n        for x in range(max(0, i - 1), min(m, i + 2)):\n          for y in range(max(0, j - 1), min(n, j + 2)):\n            ones += board[x][y] & 1\n\n        if board[i][j] == 1 and (ones == 3 or ones == 4):\n          board[i][j] |= 0b10\n\n        if board[i][j] == 0 and ones == 3:\n          board[i][j] |= 0b10\n\n    for i in range(m):\n      for j in range(n):\n        board[i][j] >>= 1\n", "tests": ["def test_gameOfLife():\n    solution = Solution()\n    board = [[0, 1, 0], [0, 0, 1], [1, 1, 1], [0, 0, 0]]\n    expected = [[0, 0, 0], [1, 0, 1], [0, 1, 1], [0, 1, 0]]\n    solution.gameOfLife(board)", "def test_gameOfLife():\n    solution = Solution()\n    board = [[1, 1], [1, 0]]\n    expected = [[1, 1], [1, 1]]\n    solution.gameOfLife(board)", "def test_gameOfLife():\n    solution = Solution()\n    board = [[0, 0], [0, 1]]\n    expected = [[0, 0], [0, 0]]\n    solution.gameOfLife(board)", "def test_gameOfLife():\n    solution = Solution()\n    board = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]\n    expected = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n    solution.gameOfLife(board)", "def test_gameOfLife():\n    solution = Solution()\n    board = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]\n    expected = [[0, 0, 0], [0, 1, 0], [0, 1, 0]]\n    solution.gameOfLife(board)", "def test_gameOfLife():\n    solution = Solution()\n    board = [[0, 1], [1, 1]]\n    expected = [[1, 1], [1, 1]]\n    solution.gameOfLife(board)", "def test_gameOfLife():\n    solution = Solution()\n    board = [[0, 1], [1, 0]]\n    expected = [[0, 0], [0, 0]]\n    solution.gameOfLife(board)", "def test_gameOfLife():\n    solution = Solution()\n    board = [[1], [0], [1]]\n    expected = [[0], [0], [0]]\n    solution.gameOfLife(board)", "def test_gameOfLife():\n    solution = Solution()\n    board = [[1, 0, 1], [0, 1, 0], [0, 0, 0]]\n    expected = [[0, 0, 0], [1, 0, 1], [0, 0, 0]]\n    solution.gameOfLife(board)", "def test_gameOfLife():\n    solution = Solution()\n    board = [[0], [1]]\n    expected = [[1], [1]]\n    solution.gameOfLife(board)", "def test_gameOfLife():\n    solution = Solution()\n    board = [[1, 0, 0, 0], [0, 1, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]]\n    expected = [[0, 0, 0, 0], [1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 0]]\n    solution.gameOfLife(board)", "def test_gameOfLife():\n    solution = Solution()\n    board = [[1, 0], [0, 1], [0, 1]]\n    expected = [[0, 0], [1, 1], [1, 0]]\n    solution.gameOfLife(board)", "def test_gameOfLife():\n    solution = Solution()\n    board = [[0, 1], [1, 1], [1, 0]]\n    expected = [[0, 1], [1, 1], [0, 1]]\n    solution.gameOfLife(board)", "def test_gameOfLife():\n    solution = Solution()\n    board = [[1], [0]]\n    expected = [[0], [1]]\n    solution.gameOfLife(board)", "def test_gameOfLife():\n    solution = Solution()\n    board = [[0, 1, 0], [0, 0, 1], [0, 0, 0]]\n    expected = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n    solution.gameOfLife(board)", "def test_gameOfLife():\n    solution = Solution()\n    board = [[1], [0], [1]]\n    expected = [[0], [1], [0]]\n    solution.gameOfLife(board)", "def test_gameOfLife():\n    solution = Solution()\n    board = [[1], [0], [1]]\n    expected = [[0], [1], [0]]\n    solution.gameOfLife(board)", "def test_gameOfLife():\n    solution = Solution()\n    board = [[1, 0, 1], [0, 0, 0], [1, 1, 1]]\n    expected = [[0, 0, 0], [1, 1, 1], [0, 1, 1]]\n    solution.gameOfLife(board)", "def test_gameOfLife():\n    solution = Solution()\n    board = [[0, 1, 0], [0, 1, 0], [0, 1, 0]]\n    expected = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n    solution.gameOfLife(board)", "def test_gameOfLife():\n    solution = Solution()\n    board = [[1, 0], [0, 0]]\n    expected = [[0, 0], [0, 0]]\n    solution.gameOfLife(board)"]}
{"task_num": 310, "task_title": "Minimum Height Trees", "func_name": "findMinHeightTrees", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\n    if n == 1 or not edges:\n      return [0]\n\n    ans = []\n    graph = collections.defaultdict(set)\n\n    for u, v in edges:\n      graph[u].add(v)\n      graph[v].add(u)\n\n    for label, children in graph.items():\n      if len(children) == 1:\n        ans.append(label)\n\n    while n > 2:\n      n -= len(ans)\n      nextLeaves = []\n      for leaf in ans:\n        u = next(iter(graph[leaf]))\n        graph[u].remove(leaf)\n        if len(graph[u]) == 1:\n          nextLeaves.append(u)\n      ans = nextLeaves\n\n    return ans\n", "tests": ["def test_findMinHeightTrees():\n    solution = Solution()\n    assert sorted(solution.findMinHeightTrees(4, [[1, 0], [1, 2], [1, 3]])) == [1]", "def test_findMinHeightTrees():\n    solution = Solution()\n    assert solution.findMinHeightTrees(1, []) == [0]", "def test_findMinHeightTrees():\n    solution = Solution()\n    assert sorted(solution.findMinHeightTrees(6, [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]])) == [3, 4]", "def test_findMinHeightTrees():\n    solution = Solution()\n    assert sorted(solution.findMinHeightTrees(2, [[0, 1]])) == [0, 1]", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 10\n    edges = [[i, (i + 1) % n] for i in range(n)]\n    assert sorted(solution.findMinHeightTrees(n, edges)) == [n // 2]", "def test_findMinHeightTrees():\n    solution = Solution()\n    assert solution.findMinHeightTrees(1, []) == [0]", "def test_findMinHeightTrees():\n    solution = Solution()\n    assert sorted(solution.findMinHeightTrees(5, [[0, 1], [1, 2], [1, 3], [2, 4]])) == [1]", "def test_findMinHeightTrees():\n    solution = Solution()\n    assert sorted(solution.findMinHeightTrees(7, [[0, 1], [1, 2], [1, 3], [2, 4], [3, 5], [3, 6]])) == [3]", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 10\n    edges = [[i, (i + 1) % n] for i in range(n)] + [[2, 5], [3, 6]]\n    assert sorted(solution.findMinHeightTrees(n, edges)) == [n // 2]", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 10\n    edges = [[i, (i + 2) % n] for i in range(n)]\n    assert sorted(solution.findMinHeightTrees(n, edges)) == [n // 2]", "def test_findMinHeightTrees():\n    solution = Solution()\n    assert sorted(solution.findMinHeightTrees(3, [[0, 1], [2, 1]])) == [1]", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 15\n    edges = [[i, (i + 3) % n] for i in range(n)]\n    assert sorted(solution.findMinHeightTrees(n, edges)) == [n // 2]", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 20\n    edges = [[i, (i + 1) % n] for i in range(n)]\n    assert sorted(solution.findMinHeightTrees(n, edges)) == [n // 2]", "def test_findMinHeightTrees():\n    solution = Solution()\n    assert sorted(solution.findMinHeightTrees(3, [[0, 1]])) == [0, 1]", "def test_findMinHeightTrees():\n    solution = Solution()\n    assert solution.findMinHeightTrees(1, []) == [0]", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 21\n    edges = [[i, (i + 4) % n] for i in range(n)]\n    assert sorted(solution.findMinHeightTrees(n, edges)) == [n // 2]", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 20\n    edges = [[i, (i + 4) % n] for i in range(n)]\n    assert sorted(solution.findMinHeightTrees(n, edges)) == [n // 2]", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 21\n    edges = [[i, (i + 3) % n] for i in range(n)]\n    assert sorted(solution.findMinHeightTrees(n, edges)) == [n // 2]", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 21\n    edges = [[i, (i + 5) % n] for i in range(n)] + [[2, 8], [4, 9]]\n    assert sorted(solution.findMinHeightTrees(n, edges)) == [n // 2]", "def test_findMinHeightTrees():\n    solution = Solution()\n    n = 20\n    edges = [[i, (i + 5) % n] for i in range(n)] + [[1, 8], [3, 9]]\n    assert sorted(solution.findMinHeightTrees(n, edges)) == [n // 2]"]}
{"task_num": 327, "task_title": "Count of Range Sum", "func_name": "countRangeSum", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countRangeSum(self, nums: List[int], lower: int, upper: int) -> int:\n    n = len(nums)\n    self.ans = 0\n    prefix = [0] + list(itertools.accumulate(nums))\n\n    self._mergeSort(prefix, 0, n, lower, upper)\n    return self.ans\n\n  def _mergeSort(self, prefix: List[int], l: int, r: int, lower: int, upper: int) -> None:\n    if l >= r:\n      return\n\n    m = (l + r) // 2\n    self._mergeSort(prefix, l, m, lower, upper)\n    self._mergeSort(prefix, m + 1, r, lower, upper)\n    self._merge(prefix, l, m, r, lower, upper)\n\n  def _merge(self, prefix: List[int], l: int, m: int, r: int, lower: int, upper: int) -> None:\n    lo = m + 1\n    hi = m + 1\n\n    for i in range(l, m + 1):\n      while lo <= r and prefix[lo] - prefix[i] < lower:\n        lo += 1\n      while hi <= r and prefix[hi] - prefix[i] <= upper:\n        hi += 1\n      self.ans += hi - lo\n\n    sorted = [0] * (r - l + 1)\n    k = 0\n    i = l\n    j = m + 1\n\n    while i <= m and j <= r:\n      if prefix[i] < prefix[j]:\n        sorted[k] = prefix[i]\n        k += 1\n        i += 1\n      else:\n        sorted[k] = prefix[j]\n        k += 1\n        j += 1\n\n    while i <= m:\n      sorted[k] = prefix[i]\n      k += 1\n      i += 1\n\n    while j <= r:\n      sorted[k] = prefix[j]\n      k += 1\n      j += 1\n\n    prefix[l:l + len(sorted)] = sorted\n", "tests": ["def test_countRangeSum():\n    solution = Solution()\n    assert solution.countRangeSum([-2, 5, -1], -2, 2) == 3", "def test_countRangeSum():\n    solution = Solution()\n    assert solution.countRangeSum([1, 2, 3], 0, 5) == 6", "def test_countRangeSum():\n    solution = Solution()\n    assert solution.countRangeSum([-1, -2, -3], 0, 0) == 0", "def test_countRangeSum():\n    solution = Solution()\n    assert solution.countRangeSum([0], 0, 0) == 1", "def test_countRangeSum():\n    solution = Solution()\n    assert solution.countRangeSum([3, -2, 1], 0, 2) == 2", "def test_countRangeSum():\n    solution = Solution()\n    assert solution.countRangeSum([1, 0, -1], -2, 2) == 4", "def test_countRangeSum():\n    solution = Solution()\n    assert solution.countRangeSum([-3, -2, 7, 0], -6, 0) == 4", "def test_countRangeSum():\n    solution = Solution()\n    assert solution.countRangeSum([10, -5, 2, 15], 6, 20) == 4", "def test_countRangeSum():\n    solution = Solution()\n    assert solution.countRangeSum([0, 0, 0], -1, 1) == 3", "def test_countRangeSum():\n    solution = Solution()\n    assert solution.countRangeSum([-2, -1], 0, 0) == 0", "def test_countRangeSum():\n    solution = Solution()\n    assert solution.countRangeSum([1, -2, 3, 4], 0, 5) == 7", "def test_countRangeSum():\n    solution = Solution()\n    assert solution.countRangeSum([-10, 2, -3, 4], -5, 5) == 6", "def test_countRangeSum():\n    solution = Solution()\n    assert solution.countRangeSum([0, 1, -2, 3, -4], -5, 5) == 6", "def test_countRangeSum():\n    solution = Solution()\n    assert solution.countRangeSum([1000], 1000, 1000) == 1", "def test_countRangeSum():\n    solution = Solution()\n    assert solution.countRangeSum([-500, 500], -1000, 1000) == 2", "def test_countRangeSum():\n    solution = Solution()\n    assert solution.countRangeSum([1, -1, 0], -1, 1) == 3", "def test_countRangeSum():\n    solution = Solution()\n    assert solution.countRangeSum([1, -2, 3, -4, 5], -6, 6) == 8", "def test_countRangeSum():\n    solution = Solution()\n    assert solution.countRangeSum([-100, -99, -98], -200, -50) == 3", "def test_countRangeSum():\n    solution = Solution()\n    assert solution.countRangeSum([5, -10, 3, 7], -5, 2) == 3", "def test_countRangeSum():\n    solution = Solution()\n    assert solution.countRangeSum([-2, -1, 0, 1], -3, 2) == 6"]}
{"task_num": 335, "task_title": "Self Crossing", "func_name": "isSelfCrossing", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isSelfCrossing(self, x: List[int]) -> bool:\n    if len(x) <= 3:\n      return False\n\n    for i in range(3, len(x)):\n      if x[i - 2] <= x[i] and x[i - 1] <= x[i - 3]:\n        return True\n      if i >= 4 and x[i - 1] == x[i - 3] and x[i - 2] <= x[i] + x[i - 4]:\n        return True\n      if i >= 5 and x[i - 4] <= x[i - 2] and x[i - 2] <= x[i] + x[i - 4] and x[i - 1] <= x[i - 3] and x[i - 3] <= x[i - 1] + x[i - 5]:\n        return True\n\n    return False\n", "tests": ["def test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([4, 3, 2, 1]) == True", "def test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([1, 2, 3, 4]) == False", "def test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([1, 2, 3, 4, 5]) == False", "def test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([1, 2, 3, 4, 5, 6]) == False", "def test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([1, 2, 3, 4, 5, 6, 7]) == False", "def test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([10, 23, 10, 18]) == True", "def test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([5, 7, 3, 4, 9]) == True", "def test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([1, 2, 3, 4, 5, 6, 7, 8]) == False", "def test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([1, 2, 3, 4, 5, 6, 7, 8, 9]) == False", "def test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == False", "def test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == False", "def test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) == False", "def test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([3, 3, 3, 2, 1, 1]) == True", "def test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([3, 5, 3, 4]) == True", "def test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]) == False", "def test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([2, 1, 1, 2]) == True", "def test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([3, 5, 6, 4]) == True", "def test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([1, 1, 2, 1, 1]) == True", "def test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([5, 7, 9, 10]) == False", "def test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([3, 5, 4, 3]) == True"]}
{"task_num": 336, "task_title": "Palindrome Pairs", "func_name": "palindromePairs", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def palindromePairs(self, words: List[str]) -> List[List[int]]:\n    ans = []\n    dict = {word[::-1]: i for i, word in enumerate(words)}\n\n    for i, word in enumerate(words):\n      if \"\" in dict and dict[\"\"] != i and word == word[::-1]:\n        ans.append([i, dict[\"\"]])\n\n      for j in range(1, len(word) + 1):\n        l = word[:j]\n        r = word[j:]\n        if l in dict and dict[l] != i and r == r[::-1]:\n          ans.append([i, dict[l]])\n        if r in dict and dict[r] != i and l == l[::-1]:\n          ans.append([dict[r], i])\n\n    return ans\n", "tests": ["def test_palindromePairs():\n    solution = Solution()\n    result = solution.palindromePairs(['abcd', 'dcba', 'lls', 's', 'sssll'])", "def test_palindromePairs():\n    solution = Solution()\n    result = solution.palindromePairs(['a', ''])", "def test_palindromePairs():\n    solution = Solution()\n    result = solution.palindromePairs(['', 'aba'])", "def test_palindromePairs():\n    solution = Solution()\n    result = solution.palindromePairs(['racecar', 'level', 'car', 'deed'])", "def test_palindromePairs():\n    solution = Solution()\n    result = solution.palindromePairs(['abcba', 'bcbad'])", "def test_palindromePairs():\n    solution = Solution()\n    result = solution.palindromePairs(['abcd', 'dcba', 'lls', 's', 'sssssssss'])", "def test_palindromePairs():\n    solution = Solution()\n    result = solution.palindromePairs(['abc', 'def', 'ghi'])", "def test_palindromePairs():\n    solution = Solution()\n    result = solution.palindromePairs(['abc', 'ba'])", "def test_palindromePairs():\n    solution = Solution()\n    result = solution.palindromePairs(['abc', 'cb'])", "def test_palindromePairs():\n    solution = Solution()\n    result = solution.palindromePairs(['abc', 'baac'])", "def test_palindromePairs():\n    solution = Solution()\n    result = solution.palindromePairs(['abcd'])", "def test_palindromePairs():\n    solution = Solution()\n    result = solution.palindromePairs([])", "def test_palindromePairs():\n    solution = Solution()\n    result = solution.palindromePairs(['ab', 'ba'])", "def test_palindromePairs():\n    solution = Solution()\n    result = solution.palindromePairs(['a', ''])", "def test_palindromePairs():\n    solution = Solution()\n    result = solution.palindromePairs(['abc', 'abc'])", "def test_palindromePairs():\n    solution = Solution()\n    result = solution.palindromePairs(['abc', 'cba'])", "def test_palindromePairs():\n    solution = Solution()\n    result = solution.palindromePairs(['a', 'aa'])", "def test_palindromePairs():\n    solution = Solution()\n    result = solution.palindromePairs(['abc', 'cbad'])", "def test_palindromePairs():\n    solution = Solution()\n    result = solution.palindromePairs(['abcd', 'dcba', 'a', 'aa', 'abca'])", "def test_palindromePairs():\n    solution = Solution()\n    result = solution.palindromePairs(['a', 'ba'])"]}
{"task_num": 391, "task_title": "Perfect Rectangle", "func_name": "isRectangleCover", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Set\n\nclass Solution:\n  def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\n    area = 0\n    x1 = math.inf\n    y1 = math.inf\n    x2 = -math.inf\n    y2 = -math.inf\n    corners: Set[Tuple[int, int]] = set()\n\n    for x, y, a, b in rectangles:\n      area += (a - x) * (b - y)\n      x1 = min(x1, x)\n      y1 = min(y1, y)\n      x2 = max(x2, a)\n      y2 = max(y2, b)\n\n      for point in [(x, y), (x, b), (a, y), (a, b)]:\n        if point in corners:\n          corners.remove(point)\n        else:\n          corners.add(point)\n\n    if len(corners) != 4:\n      return False\n    if (x1, y1) not in corners or (x1, y2) not in corners or (x2, y1) not in corners or (x2, y2) not in corners:\n      return False\n    return area == (x2 - x1) * (y2 - y1)\n", "tests": ["def test_isRectangleCover():\n    solution = Solution()\n    assert solution.isRectangleCover([[0, 0, 4, 1], [0, 1, 4, 3], [0, 0, 1, 3]]) == False", "def test_isRectangleCover():\n    solution = Solution()\n    assert solution.isRectangleCover([[0, 0, 1, 1], [1, 0, 2, 1], [0, 1, 1, 2]]) == True", "def test_isRectangleCover():\n    solution = Solution()\n    assert solution.isRectangleCover([[0, 0, 2, 2], [1, 1, 3, 3]]) == True", "def test_isRectangleCover():\n    solution = Solution()\n    assert solution.isRectangleCover([[0, 0, 3, 1], [1, 0, 2, 1], [2, 0, 3, 1]]) == True", "def test_isRectangleCover():\n    solution = Solution()\n    assert solution.isRectangleCover([[0, 0, 4, 1], [0, 1, 4, 3], [1, 0, 2, 3], [3, 0, 4, 1]]) == True", "def test_isRectangleCover():\n    solution = Solution()\n    assert solution.isRectangleCover([[0, 0, 1, 2], [1, 0, 2, 2], [0, 1, 1, 3], [1, 1, 2, 3]]) == True", "def test_isRectangleCover():\n    solution = Solution()\n    assert solution.isRectangleCover([[0, 0, 2, 2], [1, 0, 3, 2]]) == False", "def test_isRectangleCover():\n    solution = Solution()\n    assert solution.isRectangleCover([[0, 0, 4, 1], [0, 1, 4, 3], [1, 0, 2, 3]]) == False", "def test_isRectangleCover():\n    solution = Solution()\n    assert solution.isRectangleCover([[0, 0, 4, 1], [0, 1, 4, 3], [0, 0, 1, 3]]) == False", "def test_isRectangleCover():\n    solution = Solution()\n    assert solution.isRectangleCover([[0, 0, 1, 1], [0, 1, 2, 2], [1, 0, 2, 1]]) == True", "def test_isRectangleCover():\n    solution = Solution()\n    assert solution.isRectangleCover([[0, 0, 2, 2], [1, 0, 3, 2]]) == False", "def test_isRectangleCover():\n    solution = Solution()\n    assert solution.isRectangleCover([[0, 0, 2, 2], [1, 0, 3, 2], [1, 1, 2, 3]]) == True", "def test_isRectangleCover():\n    solution = Solution()\n    assert solution.isRectangleCover([[0, 0, 3, 1], [1, 0, 2, 1], [0, 1, 1, 2]]) == True", "def test_isRectangleCover():\n    solution = Solution()\n    assert solution.isRectangleCover([[0, 0, 2, 2], [1, 0, 3, 2], [1, 1, 2, 3]]) == True", "def test_isRectangleCover():\n    solution = Solution()\n    assert solution.isRectangleCover([[0, 0, 4, 1], [0, 1, 4, 3], [1, 0, 2, 3], [3, 0, 4, 1]]) == True", "def test_isRectangleCover():\n    solution = Solution()\n    assert solution.isRectangleCover([[0, 0, 2, 2], [1, 0, 3, 2], [1, 1, 2, 3]]) == True", "def test_isRectangleCover():\n    solution = Solution()\n    assert solution.isRectangleCover([[0, 0, 4, 1], [0, 1, 4, 3], [1, 0, 2, 3], [3, 0, 4, 1]]) == True", "def test_isRectangleCover():\n    solution = Solution()\n    assert solution.isRectangleCover([[0, 0, 2, 2], [1, 0, 3, 2], [1, 1, 2, 3]]) == True", "def test_isRectangleCover():\n    solution = Solution()\n    assert solution.isRectangleCover([[0, 0, 3, 1], [1, 0, 2, 1], [0, 1, 1, 2]]) == True", "def test_isRectangleCover():\n    solution = Solution()\n    assert solution.isRectangleCover([[0, 0, 2, 2], [1, 0, 3, 2]]) == False"]}
{"task_num": 402, "task_title": "Remove K Digits", "func_name": "removeKdigits", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def removeKdigits(self, num: str, k: int) -> str:\n    if len(num) == k:\n      return '0'\n\n    ans = []\n    stack = []\n\n    for i, digit in enumerate(num):\n      while k > 0 and stack and stack[-1] > digit:\n        stack.pop()\n        k -= 1\n      stack.append(digit)\n\n    for _ in range(k):\n      stack.pop()\n\n    for c in stack:\n      if c == '0' and not ans:\n        continue\n      ans.append(c)\n\n    return ''.join(ans) if ans else '0'\n", "tests": ["def test_removeKdigits():\n    solution = Solution()\n    result = solution.removeKdigits('1432219', 3)", "def test_removeKdigits():\n    solution = Solution()\n    result = solution.removeKdigits('1002', 1)", "def test_removeKdigits():\n    solution = Solution()\n    result = solution.removeKdigits('555', 2)", "def test_removeKdigits():\n    solution = Solution()\n    result = solution.removeKdigits('9', 1)", "def test_removeKdigits():\n    solution = Solution()\n    result = solution.removeKdigits('10203', 2)", "def test_removeKdigits():\n    solution = Solution()\n    result = solution.removeKdigits('10', 2)", "def test_removeKdigits():\n    solution = Solution()\n    result = solution.removeKdigits('100', 2)", "def test_removeKdigits():\n    solution = Solution()\n    result = solution.removeKdigits('123456', 3)", "def test_removeKdigits():\n    solution = Solution()\n    result = solution.removeKdigits('54321', 3)", "def test_removeKdigits():\n    solution = Solution()\n    result = solution.removeKdigits('123456789', 4)", "def test_removeKdigits():\n    solution = Solution()\n    result = solution.removeKdigits('1000', 3)", "def test_removeKdigits():\n    solution = Solution()\n    result = solution.removeKdigits('1020', 2)", "def test_removeKdigits():\n    solution = Solution()\n    result = solution.removeKdigits('5014', 2)", "def test_removeKdigits():\n    solution = Solution()\n    result = solution.removeKdigits('54012', 3)", "def test_removeKdigits():\n    solution = Solution()\n    result = solution.removeKdigits('12340', 3)", "def test_removeKdigits():\n    solution = Solution()\n    result = solution.removeKdigits('5', 1)", "def test_removeKdigits():\n    solution = Solution()\n    result = solution.removeKdigits('12345678901234567890', 10)", "def test_removeKdigits():\n    solution = Solution()\n    result = solution.removeKdigits('10', 1)", "def test_removeKdigits():\n    solution = Solution()\n    result = solution.removeKdigits('10002', 3)", "def test_removeKdigits():\n    solution = Solution()\n    result = solution.removeKdigits('10203', 4)"]}
{"task_num": 407, "task_title": "Trapping Rain Water II", "func_name": "trapRainWater", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def trapRainWater(self, heightMap: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(heightMap)\n    n = len(heightMap[0])\n    ans = 0\n    minHeap = []\n    seen = set()\n\n    for i in range(m):\n      heapq.heappush(minHeap, (heightMap[i][0], i, 0))\n      heapq.heappush(minHeap, (heightMap[i][n - 1], i, n - 1))\n      seen.add((i, 0))\n      seen.add((i, n - 1))\n\n    for j in range(1, n - 1):\n      heapq.heappush(minHeap, (heightMap[0][j], 0, j))\n      heapq.heappush(minHeap, (heightMap[m - 1][j], m - 1, j))\n      seen.add((0, j))\n      seen.add((m - 1, j))\n\n    while minHeap:\n      h, i, j = heapq.heappop(minHeap)\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if (x, y) in seen:\n          continue\n        if heightMap[x][y] < h:\n          ans += h - heightMap[x][y]\n          heapq.heappush(minHeap, (h, x, y))\n        else:\n          heapq.heappush(minHeap, (heightMap[x][y], x, y))\n        seen.add((x, y))\n\n    return ans\n", "tests": ["def test_trapRainWater():\n    solution = Solution()\n    assert solution.trapRainWater([[1, 4, 3, 1, 3, 2], [3, 2, 1, 3, 2, 4], [2, 3, 3, 2, 3, 1]]) == 4", "def test_trapRainWater():\n    solution = Solution()\n    assert solution.trapRainWater([[10, 10, 10], [10, 2, 10], [10, 9, 10]]) == 8", "def test_trapRainWater():\n    solution = Solution()\n    assert solution.trapRainWater([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 0", "def test_trapRainWater():\n    solution = Solution()\n    assert solution.trapRainWater([[1, 2], [2, 3]]) == 0", "def test_trapRainWater():\n    solution = Solution()\n    assert solution.trapRainWater([[3, 0, 1, 2]]) == 0", "def test_trapRainWater():\n    solution = Solution()\n    assert solution.trapRainWater([[1]]) == 0", "def test_trapRainWater():\n    solution = Solution()\n    assert solution.trapRainWater([[1, 0], [2, 1]]) == 1", "def test_trapRainWater():\n    solution = Solution()\n    assert solution.trapRainWater([[0, 0], [5, 1]]) == 0", "def test_trapRainWater():\n    solution = Solution()\n    assert solution.trapRainWater([[1, 2], [0, 3]]) == 2", "def test_trapRainWater():\n    solution = Solution()\n    assert solution.trapRainWater([[1, 0, 2], [3, 4, 5]]) == 1", "def test_trapRainWater():\n    solution = Solution()\n    assert solution.trapRainWater([[10, 20, 30], [5, 15, 25], [3, 8, 12]]) == 7", "def test_trapRainWater():\n    solution = Solution()\n    assert solution.trapRainWater([[10, 18, 13], [9, 12, 15], [16, 7, 4]]) == 15", "def test_trapRainWater():\n    solution = Solution()\n    assert solution.trapRainWater([[2, 3], [10, 5]]) == 6", "def test_trapRainWater():\n    solution = Solution()\n    assert solution.trapRainWater([[10, 19, 18], [20, 17, 16], [25, 24, 23]]) == 10", "def test_trapRainWater():\n    solution = Solution()\n    assert solution.trapRainWater([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) == 0", "def test_trapRainWater():\n    solution = Solution()\n    assert solution.trapRainWater([[8, 7], [9, 6]]) == 10", "def test_trapRainWater():\n    solution = Solution()\n    assert solution.trapRainWater([[2, 1, 3], [5, 0, 4]]) == 6", "def test_trapRainWater():\n    solution = Solution()\n    assert solution.trapRainWater([[10, 15], [7, 18]]) == 6", "def test_trapRainWater():\n    solution = Solution()\n    assert solution.trapRainWater([[10, 9], [8, 7]]) == 6", "def test_trapRainWater():\n    solution = Solution()\n    assert solution.trapRainWater([[10, 9], [7, 8]]) == 6"]}
{"task_num": 417, "task_title": "Pacific Atlantic Water Flow", "func_name": "pacificAtlantic", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(heights)\n    n = len(heights[0])\n    qP = collections.deque()\n    qA = collections.deque()\n    seenP = [[False] * n for _ in range(m)]\n    seenA = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n      qP.append((i, 0))\n      qA.append((i, n - 1))\n      seenP[i][0] = True\n      seenA[i][n - 1] = True\n\n    for j in range(n):\n      qP.append((0, j))\n      qA.append((m - 1, j))\n      seenP[0][j] = True\n      seenA[m - 1][j] = True\n\n    def bfs(q: collections.deque, seen: List[List[bool]]):\n      while q:\n        i, j = q.popleft()\n        h = heights[i][j]\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if seen[x][y] or heights[x][y] < h:\n            continue\n          q.append((x, y))\n          seen[x][y] = True\n\n    bfs(qP, seenP)\n    bfs(qA, seenA)\n\n    res=[]\n    for i in range(m):\n      for j in range(n):\n        if seenP[i][j] and seenA[i][j]:\n          res.append([i, j])\n    return res\n", "tests": ["def test_pacificAtlantic():\n    solution = Solution()\n    heights = [[1, 2, 2, 3, 5], [3, 2, 3, 4, 4], [2, 4, 5, 3, 1], [6, 7, 1, 4, 5], [5, 1, 1, 2, 4]]\n    expected = [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]]\n    assert sorted(solution.pacificAtlantic(heights)) == sorted(expected)", "def test_pacificAtlantic():\n    solution = Solution()\n    heights = [[10, 10, 10], [10, 5, 10], [10, 10, 10]]\n    expected = [[0, 0], [0, 1], [0, 2], [1, 0], [1, 2], [2, 0], [2, 1], [2, 2]]\n    assert sorted(solution.pacificAtlantic(heights)) == sorted(expected)", "def test_pacificAtlantic():\n    solution = Solution()\n    heights = [[3, 2], [4, 1]]\n    expected = [[0, 0], [0, 1], [1, 0]]\n    assert sorted(solution.pacificAtlantic(heights)) == sorted(expected)", "def test_pacificAtlantic():\n    solution = Solution()\n    heights = [[1]]\n    expected = [[0, 0]]\n    assert sorted(solution.pacificAtlantic(heights)) == sorted(expected)", "def test_pacificAtlantic():\n    solution = Solution()\n    heights = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    expected = [[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]]\n    assert sorted(solution.pacificAtlantic(heights)) == sorted(expected)", "def test_pacificAtlantic():\n    solution = Solution()\n    heights = [[2, 1], [3, 5]]\n    expected = [[0, 0], [0, 1], [1, 0]]\n    assert sorted(solution.pacificAtlantic(heights)) == sorted(expected)", "def test_pacificAtlantic():\n    solution = Solution()\n    heights = [[1, 2, 3], [3, 5, 2], [2, 4, 1]]\n    expected = [[0, 0], [0, 1], [1, 0], [1, 2]]\n    assert sorted(solution.pacificAtlantic(heights)) == sorted(expected)", "def test_pacificAtlantic():\n    solution = Solution()\n    heights = [[1, 3, 5], [2, 4, 6], [7, 8, 9]]\n    expected = [[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]]\n    assert sorted(solution.pacificAtlantic(heights)) == sorted(expected)", "def test_pacificAtlantic():\n    solution = Solution()\n    heights = [[10, 9, 8], [9, 7, 6], [8, 6, 5]]\n    expected = [[0, 2], [1, 1], [2, 2]]\n    assert sorted(solution.pacificAtlantic(heights)) == sorted(expected)", "def test_pacificAtlantic():\n    solution = Solution()\n    heights = [[1, 2, 3], [3, 5, 4], [2, 6, 7]]\n    expected = [[0, 0], [0, 1], [1, 0], [1, 2]]\n    assert sorted(solution.pacificAtlantic(heights)) == sorted(expected)", "def test_pacificAtlantic():\n    solution = Solution()\n    heights = [[10, 12, 14], [9, 11, 13], [8, 10, 12]]\n    expected = [[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]]\n    assert sorted(solution.pacificAtlantic(heights)) == sorted(expected)", "def test_pacificAtlantic():\n    solution = Solution()\n    heights = [[10, 8, 6], [9, 7, 5], [8, 6, 4]]\n    expected = [[2, 2]]\n    assert sorted(solution.pacificAtlantic(heights)) == sorted(expected)", "def test_pacificAtlantic():\n    solution = Solution()\n    heights = [[1, 2, 3], [6, 5, 4]]\n    expected = [[0, 0], [0, 1], [0, 2], [1, 0]]\n    assert sorted(solution.pacificAtlantic(heights)) == sorted(expected)", "def test_pacificAtlantic():\n    solution = Solution()\n    heights = [[1, 2], [5, 4]]\n    expected = [[0, 0], [0, 1], [1, 0]]\n    assert sorted(solution.pacificAtlantic(heights)) == sorted(expected)", "def test_pacificAtlantic():\n    solution = Solution()\n    heights = [[1, 2], [3, 1]]\n    expected = [[0, 0], [0, 1], [1, 0]]\n    assert sorted(solution.pacificAtlantic(heights)) == sorted(expected)", "def test_pacificAtlantic():\n    solution = Solution()\n    heights = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    expected = [[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]]\n    assert sorted(solution.pacificAtlantic(heights)) == sorted(expected)", "def test_pacificAtlantic():\n    solution = Solution()\n    heights = [[1, 2, 3], [6, 5, 4]]\n    expected = [[0, 0], [0, 1], [0, 2], [1, 0]]\n    assert sorted(solution.pacificAtlantic(heights)) == sorted(expected)", "def test_pacificAtlantic():\n    solution = Solution()\n    heights = [[10, 8, 6], [9, 7, 5], [8, 6, 4]]\n    expected = [[2, 2]]\n    assert sorted(solution.pacificAtlantic(heights)) == sorted(expected)", "def test_pacificAtlantic():\n    solution = Solution()\n    heights = [[1, 2, 3], [6, 5, 4]]\n    expected = [[0, 0], [0, 1], [0, 2], [1, 0]]\n    assert sorted(solution.pacificAtlantic(heights)) == sorted(expected)", "def test_pacificAtlantic():\n    solution = Solution()\n    heights = [[10, 8, 6], [9, 7, 5], [8, 6, 4]]\n    expected = [[2, 2]]\n    assert sorted(solution.pacificAtlantic(heights)) == sorted(expected)"]}
{"task_num": 420, "task_title": "Strong Password Checker", "func_name": "strongPasswordChecker", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def strongPasswordChecker(self, password: str) -> int:\n    n = len(password)\n    missing = self._getMissing(password)\n    replaces = 0\n    oneSeq = 0\n    twoSeq = 0\n\n    i = 2\n    while i < n:\n      if password[i] == password[i - 1] and password[i - 1] == password[i - 2]:\n        length = 2\n        while i < n and password[i] == password[i - 1]:\n          length += 1\n          i += 1\n        replaces += length // 3\n        if length % 3 == 0:\n          oneSeq += 1\n        if length % 3 == 1:\n          twoSeq += 1\n      else:\n        i += 1\n\n    if n < 6:\n      return max(6 - n, missing)\n    if n <= 20:\n      return max(replaces, missing)\n\n    deletes = n - 20\n    replaces -= min(oneSeq, deletes)\n    replaces -= min(max(deletes - oneSeq, 0), twoSeq * 2) // 2\n    replaces -= max(deletes - oneSeq - twoSeq * 2, 0) // 3\n    return deletes + max(replaces, missing)\n\n  def _getMissing(self, password: str) -> int:\n    return 3 - any(c.isupper() for c in password) - any(c.islower() for c in password) - any(c.isdigit() for c in password)\n", "tests": ["def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('aA1') == 3", "def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('aaaAAA111') == 4", "def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('AAAAAABBBB1234567890') == 4", "def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('Aa1Bb2C3') == 0", "def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('aaaaaaaAAA123') == 5", "def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('Aaaa123') == 2", "def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('Aa1Bb2C3Dd') == 0", "def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('aA1bB2cC') == 3", "def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('1234567890') == 3", "def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('AAAAaaa1') == 2", "def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('aaaaaaAA1') == 2", "def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('AaaaA1') == 2", "def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('aaaaaaaAAA1234567890') == 6", "def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('aaaAAA111') == 4", "def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('aaaaaaaAAA123') == 5", "def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('Aaaa1234') == 3", "def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('Aaaa1234') == 3", "def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('Aaaa12') == 2", "def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('Aaaa1a') == 2", "def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('Aaaa1a') == 2"]}
{"task_num": 423, "task_title": "Reconstruct Original Digits from English", "func_name": "originalDigits", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def originalDigits(self, s: str) -> str:\n    count = [0] * 10\n\n    for c in s:\n      if c == 'z':\n        count[0] += 1\n      if c == 'o':\n        count[1] += 1\n      if c == 'w':\n        count[2] += 1\n      if c == 'h':\n        count[3] += 1\n      if c == 'u':\n        count[4] += 1\n      if c == 'f':\n        count[5] += 1\n      if c == 'x':\n        count[6] += 1\n      if c == 's':\n        count[7] += 1\n      if c == 'g':\n        count[8] += 1\n      if c == 'i':\n        count[9] += 1\n\n    count[1] -= count[0] + count[2] + count[4]\n    count[3] -= count[8]\n    count[5] -= count[4]\n    count[7] -= count[6]\n    count[9] -= count[5] + count[6] + count[8]\n\n    return ''.join(chr(i + ord('0')) for i, c in enumerate(count) for j in range(c))\n", "tests": ["def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits('owoztneoer') == '012456789'", "def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits('fviefsvveer') == '159'", "def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits('zeroonetwothreefourfivesixseveneightnine') == '0123456789'", "def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits('zeroonetwothreefourfivesixseveneightnineone') == '01123456789'", "def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits('oneonetwothreefourfivesixseveneightnine') == '1123456789'", "def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits('onetwothreefourfivesixseveneightninezero') == '0123456789'", "def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits('oneoneonetwothreefourfivesixseveneightninezero') == '01123456789'", "def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits('oneoneoneonetwothreefourfivesixseveneightninezero') == '01123456789'", "def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits('zeroonetwothreefourfivesixseveneightnineoneten') == '01123456789'", "def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits('oneoneoneonetwothreefourfivesixseveneightninezero') == '01123456789'", "def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits('zeroonetwothreefourfivesixseveneightnineoneone') == '01123456789'", "def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits('oneoneoneonetwothreefourfivesixseveneightninezeroon') == '01123456789'", "def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits('onetwothreefourfivesixseveneightninezerooneon') == '01123456789'", "def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits('onetwothreefourfivesixseveneightninezerooneon') == '01123456789'", "def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits('onetwothreefourfivesixseveneightninezerooneoneon') == '01123456789'", "def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits('onetwothreefourfivesixseveneightninezerooneon') == '01123456789'", "def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits('onetwothreefourfivesixseveneightninezerooneon') == '01123456789'", "def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits('onetwothreefourfivesixseveneightninezerooneon') == '01123456789'", "def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits('onetwothreefourfivesixseveneightninezerooneon') == '01123456789'", "def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits('onetwothreefourfivesixseveneightninezerooneon') == '01123456789'"]}
{"task_num": 457, "task_title": "Circular Array Loop", "func_name": "circularArrayLoop", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def circularArrayLoop(self, nums: List[int]) -> bool:\n    def advance(i: int) -> int:\n      return (i + nums[i]) % len(nums)\n\n    if len(nums) < 2:\n      return False\n\n    for i, num in enumerate(nums):\n      if num == 0:\n        continue\n\n      slow = i\n      fast = advance(slow)\n      while num * nums[fast] > 0 and num * nums[advance(fast)] > 0:\n        if slow == fast:\n          if slow == advance(slow):\n            break\n          return True\n        slow = advance(slow)\n        fast = advance(advance(fast))\n\n      slow = i\n      sign = num\n      while sign * nums[slow] > 0:\n        next = advance(slow)\n        nums[slow] = 0\n        slow = next\n\n    return False\n", "tests": ["def test_circularArrayLoop():\n    solution = Solution()\n    assert solution.circularArrayLoop([2, -1, 1, 2, 2]) == True", "def test_circularArrayLoop():\n    solution = Solution()\n    assert solution.circularArrayLoop([-1, -2, -3, -4, -5]) == False", "def test_circularArrayLoop():\n    solution = Solution()\n    assert solution.circularArrayLoop([1, -2, 3, -4, 5]) == False", "def test_circularArrayLoop():\n    solution = Solution()\n    assert solution.circularArrayLoop([3, -2, 1, 4, 2]) == True", "def test_circularArrayLoop():\n    solution = Solution()\n    assert solution.circularArrayLoop([1]) == False", "def test_circularArrayLoop():\n    solution = Solution()\n    assert solution.circularArrayLoop([1, -2, 0, 3, -4, 5]) == False", "def test_circularArrayLoop():\n    solution = Solution()\n    assert solution.circularArrayLoop([1, -2, 3, -4, 5]) == False", "def test_circularArrayLoop():\n    solution = Solution()\n    assert solution.circularArrayLoop([1, -2, 0, 3, -4, 5]) == False", "def test_circularArrayLoop():\n    solution = Solution()\n    assert solution.circularArrayLoop([5, 4, 0, 3, -2, -1]) == True", "def test_circularArrayLoop():\n    solution = Solution()\n    assert solution.circularArrayLoop([10, -5, 2, -7, 8]) == True", "def test_circularArrayLoop():\n    solution = Solution()\n    assert solution.circularArrayLoop([10, -5, 2, -7, 8]) == True", "def test_circularArrayLoop():\n    solution = Solution()\n    assert solution.circularArrayLoop([10, -5, 2, -7, 8, 0]) == False", "def test_circularArrayLoop():\n    solution = Solution()\n    assert solution.circularArrayLoop([10, -5, 2, -7, 8, -9]) == False", "def test_circularArrayLoop():\n    solution = Solution()\n    assert solution.circularArrayLoop([10, -5, 2, -7, 8, -9, 0]) == False", "def test_circularArrayLoop():\n    solution = Solution()\n    assert solution.circularArrayLoop([10, -5, 2, -7, 8, -9, 0, -1]) == False", "def test_circularArrayLoop():\n    solution = Solution()\n    assert solution.circularArrayLoop([10, -5, 2, -7, 8, -9, 0, -1, 2]) == False", "def test_circularArrayLoop():\n    solution = Solution()\n    assert solution.circularArrayLoop([10, -5, 2, -7, 8, -9, 0, -1, 2, -3, 4]) == False", "def test_circularArrayLoop():\n    solution = Solution()\n    assert solution.circularArrayLoop([10, -5, 2, -7, 8, -9, 0, -1, 2, -3, 4, -5, 6]) == False", "def test_circularArrayLoop():\n    solution = Solution()\n    arr = [1000, -500, 200, -700, 800, -900]\n    assert not solution.circularArrayLoop(arr), 'Test failed for large numbers and negative steps'", "def test_circularArrayLoop():\n    solution = Solution()\n    arr = [-100, -200, -300, 400, 500]\n    assert not solution.circularArrayLoop(arr), 'Test failed for large negative steps'"]}
{"task_num": 524, "task_title": "Longest Word in Dictionary through Deleting", "func_name": "findLongestWord", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findLongestWord(self, s: str, d: List[str]) -> str:\n    ans = ''\n\n    for word in d:\n      i = 0\n      for c in s:\n        if i < len(word) and c == word[i]:\n          i += 1\n      if i == len(word):\n        if len(word) > len(ans) or len(word) == len(ans) and word < ans:\n          ans = word\n\n    return ans\n", "tests": ["def test_findLongestWord():\n    solution = Solution()\n    assert solution.findLongestWord('abpcplea', ['ale', 'apple', 'monkey', 'plea']) == 'apple'", "def test_findLongestWord():\n    solution = Solution()\n    assert solution.findLongestWord('abpcplea', ['apple', 'banana', 'cherry']) == ''", "def test_findLongestWord():\n    solution = Solution()\n    assert solution.findLongestWord('abpcplea', ['ale', 'apple', 'app', 'ple']) == 'app'", "def test_findLongestWord():\n    solution = Solution()\n    assert solution.findLongestWord('a', ['a', 'b', 'c']) == 'a'", "def test_findLongestWord():\n    solution = Solution()\n    assert solution.findLongestWord('', ['a', 'b', 'c']) == ''", "def test_findLongestWord():\n    solution = Solution()\n    dictionary = ['a'] * 1000 + ['abcde', 'fghij']\n    assert solution.findLongestWord('abcde', dictionary) == 'abcde'", "def test_findLongestWord():\n    solution = Solution()\n    assert solution.findLongestWord('aBcDeF', ['AbCdEfG', 'bCdEfGh', 'cD']) == 'AbCdEfG'", "def test_findLongestWord():\n    solution = Solution()\n    assert solution.findLongestWord('abcdef', ['abc', 'de', 'fghi']) == 'abc'", "def test_findLongestWord():\n    solution = Solution()\n    assert solution.findLongestWord('abcdef', ['abc', 'de', 'fghi']) == 'fghi'", "def test_findLongestWord():\n    solution = Solution()\n    assert solution.findLongestWord('abpcplea', ['apple', 'banana', 'app', 'ple', 'pple']) == 'pple'", "def test_findLongestWord():\n    solution = Solution()\n    assert solution.findLongestWord('a', ['b']) == ''", "def test_findLongestWord():\n    solution = Solution()\n    assert solution.findLongestWord('abcdef', ['xyz']) == ''", "def test_findLongestWord():\n    solution = Solution()\n    assert solution.findLongestWord('aaabb', ['aaa', 'aab', 'abc']) == 'aaa'", "def test_findLongestWord():\n    solution = Solution()\n    assert solution.findLongestWord('a', ['a']) == 'a'", "def test_findLongestWord():\n    solution = Solution()\n    assert solution.findLongestWord('a', ['b', 'c', 'd']) == ''", "def test_findLongestWord():\n    solution = Solution()\n    assert solution.findLongestWord('aabbcc', ['abc', 'bca', 'cab']) == 'abc'", "def test_findLongestWord():\n    solution = Solution()\n    large_string = 'a' * 10000\n    dictionary = ['a' * i for i in range(1, 101)]\n    assert solution.findLongestWord(large_string, dictionary) == 'aaaaaaaaaa'", "def test_findLongestWord():\n    solution = Solution()\n    assert solution.findLongestWord('abc', ['aaa', 'aab', 'bbc']) == 'aaa'", "def test_findLongestWord():\n    solution = Solution()\n    assert solution.findLongestWord('abc', []) == ''", "def test_findLongestWord():\n    solution = Solution()\n    assert solution.findLongestWord('a', ['b', 'c', 'd']) == ''"]}
{"task_num": 542, "task_title": "01 Matrix", "func_name": "updateMatrix", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(mat)\n    n = len(mat[0])\n    q = collections.deque()\n    seen = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j] == 0:\n          q.append((i, j))\n          seen[i][j] = True\n\n    while q:\n      i, j = q.popleft()\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if seen[x][y]:\n          continue\n        mat[x][y] = mat[i][j] + 1\n        q.append((x, y))\n        seen[x][y] = True\n\n    return mat\n", "tests": ["def test_updateMatrix():\n    solution = Solution()\n    mat = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n    expected = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n    result = solution.updateMatrix(mat)", "def test_updateMatrix():\n    solution = Solution()\n    mat = [[0, 1, 2], [3, 4, 5], [6, 7, 8]]\n    expected = [[0, 1, 2], [1, 2, 3], [2, 3, 4]]\n    result = solution.updateMatrix(mat)", "def test_updateMatrix():\n    solution = Solution()\n    mat = [[1, 1], [1, 1]]\n    expected = [[2, 1], [1, 2]]\n    result = solution.updateMatrix(mat)", "def test_updateMatrix():\n    solution = Solution()\n    mat = [[1], [0], [1]]\n    expected = [[2], [0], [1]]\n    result = solution.updateMatrix(mat)", "def test_updateMatrix():\n    solution = Solution()\n    mat = [[1, 0, 1], [1, 1, 1]]\n    expected = [[2, 0, 1], [1, 1, 2]]\n    result = solution.updateMatrix(mat)", "def test_updateMatrix():\n    solution = Solution()\n    (m, n) = (100, 100)\n    mat = [[0 if i == j else 1 for j in range(n)] for i in range(m)]\n    expected = [[i + j for j in range(n)] for i in range(m)]\n    result = solution.updateMatrix(mat)", "def test_updateMatrix():\n    solution = Solution()\n    mat = []\n    expected = []\n    result = solution.updateMatrix(mat)", "def test_updateMatrix():\n    solution = Solution()\n    mat = [[0]]\n    expected = [[0]]\n    result = solution.updateMatrix(mat)", "def test_updateMatrix():\n    solution = Solution()\n    mat = [[0] * 3 for _ in range(3)]\n    expected = [[0] * 3 for _ in range(3)]\n    result = solution.updateMatrix(mat)", "def test_updateMatrix():\n    solution = Solution()\n    mat = [[0, 1], [1, 0], [1, 1]]\n    expected = [[0, 1], [1, 0], [2, 1]]\n    result = solution.updateMatrix(mat)", "def test_updateMatrix():\n    import random\n    n = 5\n    solution = Solution()\n    mat = [[random.randint(0, 1) for _ in range(n)] for _ in range(n)]\n    expected = [row[:] for row in mat]\n    q = collections.deque()\n    seen = [[False] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if mat[i][j] == 0:\n                q.append((i, j))\n                seen[i][j] = True\n    while q:\n        (i, j) = q.popleft()\n        for (dx, dy) in ((0, 1), (1, 0), (0, -1), (-1, 0)):\n            (x, y) = (i + dx, j + dy)\n            if not (0 <= x < n and 0 <= y < n):\n                continue\n            if seen[x][y]:\n                continue\n            if mat[i][j] == 0:\n                expected[x][y] = 0\n            else:\n                expected[x][y] = min(expected[x][y], expected[i][j] + 1)\n            q.append((x, y))\n            seen[x][y] = True\n    result = solution.updateMatrix(mat)", "def test_updateMatrix():\n    solution = Solution()\n    mat = [[1]]\n    expected = [[0]]\n    result = solution.updateMatrix(mat)", "def test_updateMatrix():\n    solution = Solution()\n    mat = [[1, 1], [1, 1], [1, 1]]\n    expected = [[2, 1], [1, 2], [2, 1]]\n    result = solution.updateMatrix(mat)", "def test_updateMatrix():\n    solution = Solution()\n    mat = [[1], [1], [1]]\n    expected = [[2], [1], [2]]\n    result = solution.updateMatrix(mat)", "def test_updateMatrix():\n    solution = Solution()\n    mat = [[0, 1, 0], [1, 0, 1], [0, 1, 2]]\n    expected = [[0, 1, 1], [1, 0, 1], (1, 1, 2)]\n    result = solution.updateMatrix(mat)", "def test_updateMatrix():\n    solution = Solution()\n    mat = [[1], [1], [0]]\n    expected = [[2], [1], [0]]\n    result = solution.updateMatrix(mat)", "def test_updateMatrix():\n    solution = Solution()\n    mat = [[1], [0], [1]]\n    expected = [[2], [0], [1]]\n    result = solution.updateMatrix(mat)", "def test_updateMatrix():\n    import random\n    n = 100\n    solution = Solution()\n    mat = [[random.randint(0, 1) for _ in range(n)] for _ in range(n)]\n    expected = [row[:] for row in mat]\n    q = collections.deque()\n    seen = [[False] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if mat[i][j] == 0:\n                q.append((i, j))\n                seen[i][j] = True\n    while q:\n        (i, j) = q.popleft()\n        for (dx, dy) in ((0, 1), (1, 0), (0, -1), (-1, 0)):\n            (x, y) = (i + dx, j + dy)\n            if not (0 <= x < n and 0 <= y < n):\n                continue\n            if seen[x][y]:\n                continue\n            if mat[i][j] == 0:\n                expected[x][y] = 0\n            else:\n                expected[x][y] = min(expected[x][y], expected[i][j] + 1)\n            q.append((x, y))\n            seen[x][y] = True\n    result = solution.updateMatrix(mat)", "def test_updateMatrix():\n    solution = Solution()\n    mat = [[0, 1, 0], [1, 0, 1], [2, 1, 2]]\n    expected = [[0, 1, 1], [1, 0, 1], (2, 1, 2)]\n    result = solution.updateMatrix(mat)", "def test_updateMatrix():\n    import random\n    n = 100\n    solution = Solution()\n    mat = [[1] * n for _ in range(n)]\n    (row, col) = (random.randint(0, n - 1), random.randint(0, n - 1))\n    mat[row][col] = 0\n    expected = [row[:] for row in mat]\n    q = collections.deque()\n    seen = [[False] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if mat[i][j] == 0:\n                q.append((i, j))\n                seen[i][j] = True\n    while q:\n        (i, j) = q.popleft()\n        for (dx, dy) in ((0, 1), (1, 0), (0, -1), (-1, 0)):\n            (x, y) = (i + dx, j + dy)\n            if not (0 <= x < n and 0 <= y < n):\n                continue\n            if seen[x][y]:\n                continue\n            expected[x][y] = abs(x - row) + abs(y - col)\n            q.append((x, y))\n            seen[x][y] = True\n    result = solution.updateMatrix(mat)"]}
{"task_num": 547, "task_title": "Number of Provinces", "func_name": "findCircleNum", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    self.count -= 1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findCircleNum(self, isConnected: List[List[int]]) -> int:\n    n = len(isConnected)\n    uf = UnionFind(n)\n\n    for i in range(n):\n      for j in range(i, n):\n        if isConnected[i][j] == 1:\n          uf.unionByRank(i, j)\n\n    return uf.count\n", "tests": ["def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]\n    assert solution.findCircleNum(isConnected) == 2", "def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    assert solution.findCircleNum(isConnected) == 3", "def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[1, 1, 1], [1, 1, 0], [1, 0, 1]]\n    assert solution.findCircleNum(isConnected) == 2", "def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[0, 1, 0], [1, 0, 1], [0, 1, 0]]\n    assert solution.findCircleNum(isConnected) == 3", "def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[1, 0, 0, 1], [0, 1, 1, 0], [0, 1, 1, 1], [1, 0, 1, 1]]\n    assert solution.findCircleNum(isConnected) == 1", "def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[0, 0], [0, 0]]\n    assert solution.findCircleNum(isConnected) == 2", "def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 1], [0, 0, 1, 1]]\n    assert solution.findCircleNum(isConnected) == 2", "def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[1, 0, 0, 0], [0, 1, 0, 1], [0, 0, 1, 0], [0, 1, 0, 1]]\n    assert solution.findCircleNum(isConnected) == 3", "def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]\n    assert solution.findCircleNum(isConnected) == 4", "def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[1, 0, 0, 0], [0, 0, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]\n    assert solution.findCircleNum(isConnected) == 3", "def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]\n    assert solution.findCircleNum(isConnected) == 3", "def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[1, 1, 0, 1], [1, 1, 1, 0], [0, 1, 1, 1], [1, 0, 1, 1]]\n    assert solution.findCircleNum(isConnected) == 2", "def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[1, 0, 0], [0, 1, 1], [0, 1, 1]]\n    assert solution.findCircleNum(isConnected) == 2", "def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[0, 0, 1], [0, 0, 1], [1, 1, 0]]\n    assert solution.findCircleNum(isConnected) == 2", "def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[1, 0, 0, 1], [0, 1, 1, 0], [0, 1, 0, 0], [1, 0, 0, 1]]\n    assert solution.findCircleNum(isConnected) == 2", "def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[1, 0, 0], [0, 0, 0], [0, 0, 1]]\n    assert solution.findCircleNum(isConnected) == 3", "def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[1, 0, 1], [0, 1, 1], [1, 1, 0]]\n    assert solution.findCircleNum(isConnected) == 3", "def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 1], [0, 0, 1, 1]]\n    assert solution.findCircleNum(isConnected) == 2", "def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[1, 0, 0, 1], [0, 1, 1, 0], [0, 1, 0, 0], [1, 0, 0, 1]]\n    assert solution.findCircleNum(isConnected) == 2", "def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[1, 0, 0], [0, 1, 0], [0, 0, 0]]\n    assert solution.findCircleNum(isConnected) == 2"]}
{"task_num": 581, "task_title": "Shortest Unsorted Continuous Subarray", "func_name": "findUnsortedSubarray", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findUnsortedSubarray(self, nums: List[int]) -> int:\n    mini = math.inf\n    maxi = -math.inf\n    flag = False\n\n    for i in range(1, len(nums)):\n      if nums[i] < nums[i - 1]:\n        flag = True\n      if flag:\n        mini = min(mini, nums[i])\n\n    flag = False\n\n    for i in reversed(range(len(nums) - 1)):\n      if nums[i] > nums[i + 1]:\n        flag = True\n      if flag:\n        maxi = max(maxi, nums[i])\n\n    for l in range(len(nums)):\n      if nums[l] > mini:\n        break\n\n    for r, num in reversed(list(enumerate(nums))):\n      if num < maxi:\n        break\n\n    return 0 if l >= r else r - l + 1\n", "tests": ["def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([2, 6, 4, 8, 10, 9, 15]) == 5", "def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([1, 2, 3, 4]) == 0", "def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([1, 2, 3, 5, 4]) == 2", "def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([1, 3, 5, 2, 4]) == 3", "def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([1, 2, 3, 4, 5, 6, 7]) == 0", "def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([2, 1]) == 2", "def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([1, 2, 3, 7, 4, 5, 6]) == 3", "def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([10, 20, 30, 40, 50]) == 0", "def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([1, 3, 2]) == 2", "def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([2, 3, 8, 6, 7]) == 3", "def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([1, 3, 5, 2, 4]) == 3", "def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([1, 2, 3, 7, 4, 5, 6]) == 3", "def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([10, 2, 3, 4, 5, 6, 7, 8, 9]) == 2", "def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([1, 2, 4, 3, 5]) == 3", "def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([10, 20, 30, 40, 50]) == 0", "def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([1, 3, 2]) == 2", "def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([2, 3, 8, 6, 7]) == 3", "def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([1, 3, 5, 2, 4]) == 3", "def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([1, 2, 3, 7, 4, 5, 6]) == 3", "def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([10, 2, 3, 4, 5, 6, 7, 8, 9]) == 2"]}
{"task_num": 591, "task_title": "Tag Validator", "func_name": "isValid", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isValid(self, code: str) -> bool:\n    if code[0] != '<' or code[-1] != '>':\n      return False\n\n    containsTag = False\n    stack = []\n\n    def isValidCdata(s: str) -> bool:\n      return s.find('[CDATA[') == 0\n\n    def isValidTagName(tagName: str, isEndTag: bool) -> bool:\n      nonlocal containsTag\n      if not tagName or len(tagName) > 9:\n        return False\n      if any(not c.isupper() for c in tagName):\n        return False\n\n      if isEndTag:\n        return stack and stack.pop() == tagName\n\n      containsTag = True\n      stack.append(tagName)\n      return True\n\n    i = 0\n    while i < len(code):\n      if not stack and containsTag:\n        return False\n      if code[i] == '<':\n        if stack and code[i + 1] == '!':\n          closeIndex = code.find(']]>', i + 2)\n          if closeIndex == -1 or not isValidCdata(code[i + 2:closeIndex]):\n            return False\n        elif code[i + 1] == '/':\n          closeIndex = code.find('>', i + 2)\n          if closeIndex == -1 or not isValidTagName(code[i + 2:closeIndex], True):\n            return False\n        else:\n          closeIndex = code.find('>', i + 1)\n          if closeIndex == -1 or not isValidTagName(code[i + 1:closeIndex], False):\n            return False\n        i = closeIndex\n      i += 1\n\n    return not stack and containsTag\n", "tests": ["def test_isValid():\n    solution = Solution()\n    assert solution.isValid('<DIV>This is the first line <![CDATA[<div>]]></DIV>') == False", "def test_isValid():\n    solution = Solution()\n    assert solution.isValid('<A><B></A>') == False", "def test_isValid():\n    solution = Solution()\n    assert solution.isValid('<A><B></B></A>') == True", "def test_isValid():\n    solution = Solution()\n    assert solution.isValid('<A><![CDATA[abc]]>123</A>') == True", "def test_isValid():\n    solution = Solution()\n    assert solution.isValid('<A><B></C></A>') == False", "def test_isValid():\n    solution = Solution()\n    assert solution.isValid('<A>abc<![CDATA[def]]></A>') == True", "def test_isValid():\n    solution = Solution()\n    assert solution.isValid('<<A></A>') == False", "def test_isValid():\n    solution = Solution()\n    assert solution.isValid('<A><B>123</C></A>') == False", "def test_isValid():\n    solution = Solution()\n    assert solution.isValid('<A><B>123</B></A>') == True", "def test_isValid():\n    solution = Solution()\n    assert solution.isValid('<A><B>123</B></A><C>') == False", "def test_isValid():\n    solution = Solution()\n    assert solution.isValid('<A><![CDATA[123</A>]]>') == False", "def test_isValid():\n    solution = Solution()\n    assert solution.isValid('<A><B><![CDATA[123]]></B></A>') == True", "def test_isValid():\n    solution = Solution()", "def test_isValid():\n    solution = Solution()\n    assert solution.isValid('<A><B>123</B><C></C></A>') == True", "def test_isValid():\n    solution = Solution()\n    assert solution.isValid('<A><![CDATA[123]]></B><C></C></A>') == False", "def test_isValid():\n    solution = Solution()\n    assert solution.isValid('<A><B><![CDATA[123]]></B></C></A>') == False", "def test_isValid():\n    solution = Solution()\n    assert solution.isValid('<A><B>123</B></C>') == False", "def test_isValid():\n    solution = Solution()\n    assert solution.isValid('<A><B>123</B></A><C><![CDATA[123]]></C>') == False", "def test_isValid():\n    solution = Solution()\n    assert solution.isValid('<A>abc</A><B><![CDATA[123]]></B>') == False", "def test_isValid():\n    solution = Solution()\n    assert solution.isValid('<A><B>123</B></C>') == False"]}
{"task_num": 648, "task_title": "Replace Words", "func_name": "replaceWords", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def __init__(self):\n    self.root = {}\n\n  def insert(self, word: str) -> None:\n    node = self.root\n    for c in word:\n      if c not in node:\n        node[c] = {}\n      node = node[c]\n    node['word'] = word\n\n  def search(self, word: str) -> str:\n    node = self.root\n    for c in word:\n      if 'word' in node:\n        return node['word']\n      if c not in node:\n        return word\n      node = node[c]\n    return word\n\n  def replaceWords(self, dictionary: List[str], sentence: str) -> str:\n    for word in dictionary:\n      self.insert(word)\n\n    words = sentence.split(' ')\n    return ' '.join([self.search(word) for word in words])\n", "tests": ["def test_replaceWords():\n    solution = Solution()\n    dictionary = ['cat', 'bat', 'rat']\n    sentence = 'the cattle was rattled by the battery'\n    expected_output = 'the cat was rat by the bat'\n    assert solution.replaceWords(dictionary, sentence) == expected_output", "def test_replaceWords():\n    solution = Solution()\n    dictionary = ['apple', 'banana']\n    sentence = 'cherry orange'\n    expected_output = 'cherry orange'\n    assert solution.replaceWords(dictionary, sentence) == expected_output", "def test_replaceWords():\n    solution = Solution()\n    dictionary = ['a', 'aa', 'aaa']\n    sentence = 'a aa aaa'\n    expected_output = 'a a a'\n    assert solution.replaceWords(dictionary, sentence) == expected_output", "def test_replaceWords():\n    solution = Solution()\n    dictionary = ['a', 'b']\n    sentence = ''\n    expected_output = ''\n    assert solution.replaceWords(dictionary, sentence) == expected_output", "def test_replaceWords():\n    solution = Solution()\n    dictionary = ['Apple']\n    sentence = 'apple pie'\n    expected_output = 'apple pie'\n    assert solution.replaceWords(dictionary, sentence) == expected_output", "def test_replaceWords():\n    solution = Solution()\n    dictionary = ['the', 'cat']\n    sentence = ' the cat'\n    expected_output = ' the cat'\n    assert solution.replaceWords(dictionary, sentence) == expected_output", "def test_replaceWords():\n    solution = Solution()\n    dictionary = ['the', 'cat']\n    sentence = 'the  cat'\n    expected_output = 'the  cat'\n    assert solution.replaceWords(dictionary, sentence) == expected_output", "def test_replaceWords():\n    solution = Solution()\n    dictionary = [str(i) for i in range(10000)]\n    sentence = ' '.join((str(i) * 2 for i in range(10)))\n    expected_output = sentence.replace(' ', ' ')\n    assert solution.replaceWords(dictionary, sentence) == expected_output", "def test_replaceWords():\n    solution = Solution()\n    dictionary = ['Hello', 'world']\n    sentence = 'Hello there! How are you doing today? World!'\n    expected_output = 'Hello there! How are you doing today? World!'\n    assert solution.replaceWords(dictionary, sentence) == expected_output", "def test_replaceWords():\n    solution = Solution()\n    dictionary = [str(i) for i in range(1000)]\n    sentence = ' '.join((str(i % 1000) * 100 for _ in range(10)))\n    expected_output = sentence.replace(' ', ' ')\n    assert solution.replaceWords(dictionary, sentence) == expected_output", "def test_replaceWords():\n    solution = Solution()\n    dictionary = ['123', '456']\n    sentence = '789 123 456'\n    expected_output = '789 123 456'\n    assert solution.replaceWords(dictionary, sentence) == expected_output", "def test_replaceWords():\n    solution = Solution()\n    dictionary = ['cat', 'bat']\n    sentence = 'the cat@ was## rattled!! by the battery?'\n    expected_output = 'the cat was rattled by the bat'\n    assert solution.replaceWords(dictionary, sentence) == expected_output", "def test_replaceWords():\n    solution = Solution()\n    dictionary = ['hello']\n    sentence = 'h\u00e9llo w\u00f6rld'\n    expected_output = 'h\u00e9llo w\u00f6rld'\n    assert solution.replaceWords(dictionary, sentence) == expected_output", "def test_replaceWords():\n    solution = Solution()\n    dictionary = ['the', 'the']\n    sentence = 'the cat'\n    expected_output = 'the cat'\n    assert solution.replaceWords(dictionary, sentence) == expected_output", "def test_replaceWords():\n    solution = Solution()\n    dictionary = ['a', 'an', 'and']\n    sentence = 'a an and a an and'\n    expected_output = 'a an and a an and'\n    assert solution.replaceWords(dictionary, sentence) == expected_output", "def test_replaceWords():\n    solution = Solution()\n    dictionary = ['cat', 'bat']\n    sentence = 'the cattle was rattled by the battery'\n    expected_output = 'the cat was rattled by the bat'\n    assert solution.replaceWords(dictionary, sentence) == expected_output", "def test_replaceWords():\n    solution = Solution()\n    dictionary = ['a']\n    sentence = '123 a 456'\n    expected_output = '123 a 456'\n    assert solution.replaceWords(dictionary, sentence) == expected_output", "def test_replaceWords():\n    solution = Solution()\n    dictionary = [str(i) for i in range(1000)]\n    sentence = ' '.join(str(i % 1000)) * 2\n    expected_output = sentence.replace(' ', ' ')\n    assert solution.replaceWords(dictionary, sentence) == expected_output", "def test_replaceWords():\n    solution = Solution()\n    dictionary = [str(i) for i in range(1000)]\n    sentence = ' '.join((str(i % 1000) * 100 for _ in range(5)))\n    expected_output = sentence.replace(' ', ' ')\n    assert solution.replaceWords(dictionary, sentence) == expected_output", "def test_replaceWords():\n    solution = Solution()\n    dictionary = ['apple', 'Banana']\n    sentence = 'Apple Banana'\n    expected_output = 'apple banana'\n    assert solution.replaceWords(dictionary, sentence) == expected_output"]}
{"task_num": 673, "task_title": "Number of Longest Increasing Subsequence", "func_name": "findNumberOfLIS", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findNumberOfLIS(self, nums: List[int]) -> int:\n    ans = 0\n    maxLength = 0\n    length = [1] * len(nums)\n    count = [1] * len(nums)\n\n    for i, num in enumerate(nums):\n      for j in range(i):\n        if nums[j] < num:\n          if length[i] < length[j] + 1:\n            length[i] = length[j] + 1\n            count[i] = count[j]\n          elif length[i] == length[j] + 1:\n            count[i] += count[j]\n\n    for i, l in enumerate(length):\n      if l > maxLength:\n        maxLength = l\n        ans = count[i]\n      elif l == maxLength:\n        ans += count[i]\n\n    return ans\n", "tests": ["def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([1, 3, 5, 4, 7]) == 2", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([1, 2, 2, 3, 4]) == 5", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([]) == 0", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([1]) == 1", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([5, 4, 3, 2, 1]) == 5", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([1, 2, 3, 4, 5]) == 1", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([1, 1, 1, 1]) == 4", "def test_findNumberOfLIS():\n    solution = Solution()\n    nums = list(range(100))\n    assert solution.findNumberOfLIS(nums) == 1", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([-1, 0, 5, -2, -3]) == 2", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([1, 2, 3]) == 1", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([1, 2, 3, 3, 4]) == 6", "def test_findNumberOfLIS():\n    solution = Solution()\n    nums = list(range(1000))\n    assert solution.findNumberOfLIS(nums) == 1", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([-5, -1, 0, 2, 4, 6]) == 7", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([1, 2, 4, 3, 5]) == 6", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([5, 4, 3, 2, 1]) == 5", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([10]) == 1", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4", "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([100, 2, 3, 4, 5, 6, 7, 8, 9, 1]) == 10"]}
{"task_num": 684, "task_title": "Redundant Connection", "func_name": "findRedundantConnection", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n    uf = UnionFind(len(edges) + 1)\n\n    for edge in edges:\n      u, v = edge\n      if not uf.unionByRank(u, v):\n        return edge\n", "tests": ["def test_findRedundantConnection():\n    solution = Solution()\n    result = solution.findRedundantConnection([[1, 2], [1, 3], [2, 3]])", "def test_findRedundantConnection():\n    solution = Solution()\n    result = solution.findRedundantConnection([[4, 3], [1, 2], [1, 3], [3, 4]])", "def test_findRedundantConnection():\n    solution = Solution()\n    result = solution.findRedundantConnection([[1, 5], [3, 4], [2, 4]])", "def test_findRedundantConnection():\n    solution = Solution()\n    result = solution.findRedundantConnection([[1, 2], [2, 3], [3, 4], [4, 1]])", "def test_findRedundantConnection():\n    solution = Solution()\n    result = solution.findRedundantConnection([[2, 1], [3, 4], [3, 5], [4, 6]])", "def test_findRedundantConnection():\n    solution = Solution()\n    result = solution.findRedundantConnection([[5, 4], [6, 5], [8, 2], [7, 3], [1, 8], [9, 7]])", "def test_findRedundantConnection():\n    solution = Solution()\n    result = solution.findRedundantConnection([[10, 2], [3, 4], [5, 6], [7, 8], [9, 10]])", "def test_findRedundantConnection():\n    solution = Solution()\n    result = solution.findRedundantConnection([[1, 2], [1, 3], [2, 4], [3, 4]])", "def test_findRedundantConnection():\n    solution = Solution()\n    result = solution.findRedundantConnection([[10, 2], [3, 4], [5, 6], [7, 8], [9, 10], [2, 10]])", "def test_findRedundantConnection():\n    solution = Solution()\n    result = solution.findRedundantConnection([[1, 5], [3, 4], [2, 5]])", "def test_findRedundantConnection():\n    solution = Solution()\n    result = solution.findRedundantConnection([[1, 2], [1, 3], [4, 5], [5, 6], [3, 4]])", "def test_findRedundantConnection():\n    solution = Solution()\n    result = solution.findRedundantConnection([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [10, 1]])", "def test_findRedundantConnection():\n    solution = Solution()\n    result = solution.findRedundantConnection([[1, 2], [2, 3], [3, 1]])", "def test_findRedundantConnection():\n    solution = Solution()\n    result = solution.findRedundantConnection([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [9, 8]])", "def test_findRedundantConnection():\n    solution = Solution()\n    result = solution.findRedundantConnection([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [10, 7]])", "def test_findRedundantConnection():\n    solution = Solution()\n    result = solution.findRedundantConnection([[1, 2], [2, 3], [3, 5], [4, 5], [5, 6]])", "def test_findRedundantConnection():\n    solution = Solution()\n    result = solution.findRedundantConnection([[1, 5], [3, 4], [2, 3]])", "def test_findRedundantConnection():\n    solution = Solution()\n    result = solution.findRedundantConnection([[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [1, 6]])", "def test_findRedundantConnection():\n    solution = Solution()\n    result = solution.findRedundantConnection([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [10, 5]])", "def test_findRedundantConnection():\n    solution = Solution()\n    result = solution.findRedundantConnection([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [10, 4]])"]}
{"task_num": 685, "task_title": "Redundant Connection II", "func_name": "findRedundantDirectedConnection", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\n    ids = [0] * (len(edges) + 1)\n    nodeWithTwoParents = 0\n\n    for _, v in edges:\n      ids[v] += 1\n      if ids[v] == 2:\n        nodeWithTwoParents = v\n\n    def findRedundantDirectedConnection(skippedEdgeIndex: int) -> List[int]:\n      uf = UnionFind(len(edges) + 1)\n\n      for i, edge in enumerate(edges):\n        if i == skippedEdgeIndex:\n          continue\n        if not uf.unionByRank(edge[0], edge[1]):\n          return edge\n\n      return []\n\n    if nodeWithTwoParents == 0:\n      return findRedundantDirectedConnection(-1)\n\n    for i in reversed(range(len(edges))):\n      _, v = edges[i]\n      if v == nodeWithTwoParents:\n        if not findRedundantDirectedConnection(i):\n          return edges[i]\n", "tests": ["def test_findRedundantDirectedConnection():\n    solution = Solution()\n    assert solution.findRedundantDirectedConnection([[1, 2], [1, 3], [2, 3]]) == [2, 3]", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    assert solution.findRedundantDirectedConnection([[1, 2], [2, 3], [3, 4], [4, 1]]) == [4, 1]", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    assert solution.findRedundantDirectedConnection([[1, 2], [3, 2], [2, 4], [4, 3]]) == [2, 4]", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    assert solution.findRedundantDirectedConnection([[1, 2], [2, 3], [3, 5], [4, 5], [5, 2]]) == [5, 2]", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    assert solution.findRedundantDirectedConnection([[1, 2], [2, 3], [3, 6], [4, 5], [5, 6], [4, 3]]) == [4, 3]", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    assert solution.findRedundantDirectedConnection([[1, 2], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9, 7]]) == [9, 7]", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    assert solution.findRedundantDirectedConnection([[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [10, 8]]) == [10, 8]", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    assert solution.findRedundantDirectedConnection([[1, 2], [2, 3], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9, 10], [11, 9]]) == [11, 9]", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    assert solution.findRedundantDirectedConnection([[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9, 10], [10, 2]]) == [10, 2]", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    assert solution.findRedundantDirectedConnection([[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9, 10], [10, 3]]) == [10, 3]", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    assert solution.findRedundantDirectedConnection([[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9, 10], [10, 4]]) == [10, 4]", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    assert solution.findRedundantDirectedConnection([[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9, 10], [10, 5]]) == [10, 5]", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    assert solution.findRedundantDirectedConnection([[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9, 10], [10, 6]]) == [10, 6]", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    assert solution.findRedundantDirectedConnection([[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9, 10], [10, 7]]) == [10, 7]", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    assert solution.findRedundantDirectedConnection([[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9, 10], [10, 8], [9, 2]]) == [9, 2]", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    assert solution.findRedundantDirectedConnection([[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9, 10], [10, 9]]) == [10, 9]", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    assert solution.findRedundantDirectedConnection([[1, 2], [3, 2], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9, 7]]) == [9, 7]", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    assert solution.findRedundantDirectedConnection([[1, 2], [2, 3], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9, 10], [10, 8], [10, 3]]) == [10, 3]", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    assert solution.findRedundantDirectedConnection([[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9, 10], [10, 4]]) == [10, 4]", "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    assert solution.findRedundantDirectedConnection([[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9, 10], [10, 5]]) == [10, 5]"]}
{"task_num": 688, "task_title": "Knight Probability in Chessboard", "func_name": "knightProbability", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\n    dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n    dp = [[0] * n for _ in range(n)]\n    dp[row][column] = 1.0\n\n    for _ in range(k):\n      newDp = [[0] * n for _ in range(n)]\n      for i in range(n):\n        for j in range(n):\n          for dx, dy in dirs:\n            x = i + dx\n            y = j + dy\n            if 0 <= x < n and 0 <= y < n:\n              newDp[i][j] += dp[x][y]\n      dp = newDp\n\n    return sum(map(sum, dp)) / 8**k\n", "tests": ["def test_knightProbability():\n    solution = Solution()\n    assert abs(solution.knightProbability(3, 2, 0, 0) - 0.1875) < 0.0001", "def test_knightProbability():\n    solution = Solution()\n    assert abs(solution.knightProbability(1, 0, 0, 0) - 1.0) < 0.0001", "def test_knightProbability():\n    solution = Solution()\n    assert abs(solution.knightProbability(2, 1, 0, 0) - 0.25) < 0.0001", "def test_knightProbability():\n    solution = Solution()\n    assert abs(solution.knightProbability(6, 5, 1, 2) - 0.13984) < 0.0001", "def test_knightProbability():\n    solution = Solution()\n    assert abs(solution.knightProbability(2, 2, 0, 1) - 0.5) < 0.0001", "def test_knightProbability():\n    solution = Solution()\n    assert abs(solution.knightProbability(3, 1, 0, 0) - 0.25) < 0.0001", "def test_knightProbability():\n    solution = Solution()\n    assert abs(solution.knightProbability(2, 3, 0, 0) - 0.125) < 0.0001", "def test_knightProbability():\n    solution = Solution()\n    assert abs(solution.knightProbability(2, 5, 1, 1) - 0.0) < 0.0001", "def test_knightProbability():\n    solution = Solution()\n    assert abs(solution.knightProbability(2, 1, 0, 0) - 0.25) < 0.0001", "def test_knightProbability():\n    solution = Solution()\n    assert abs(solution.knightProbability(3, 2, 1, 1) - 0.4) < 0.0001", "def test_knightProbability():\n    solution = Solution()\n    assert abs(solution.knightProbability(5, 2, 2, 2) - 0.6875) < 0.0001", "def test_knightProbability():\n    solution = Solution()\n    assert abs(solution.knightProbability(2, 3, 0, 1) - 0.5) < 0.0001", "def test_knightProbability():\n    solution = Solution()\n    assert abs(solution.knightProbability(10, 2, 4, 5) - 0.375) < 0.0001", "def test_knightProbability():\n    solution = Solution()\n    assert abs(solution.knightProbability(5, 2, 3, 1) - 0.75) < 0.0001", "def test_knightProbability():\n    solution = Solution()\n    assert abs(solution.knightProbability(3, 2, 1, 1) - 0.4) < 0.0001", "def test_knightProbability():\n    solution = Solution()\n    assert abs(solution.knightProbability(10, 2, 4, 5) - 0.375) < 0.0001", "def test_knightProbability():\n    solution = Solution()\n    assert abs(solution.knightProbability(2, 3, 0, 1) - 0.5) < 0.0001", "def test_knightProbability():\n    solution = Solution()\n    assert abs(solution.knightProbability(10, 2, 4, 5) - 0.375) < 0.0001", "def test_knightProbability():\n    solution = Solution()\n    assert abs(solution.knightProbability(2, 3, 0, 1) - 0.5) < 0.0001", "def test_knightProbability():\n    solution = Solution()\n    assert abs(solution.knightProbability(5, 1, 2, 2) - 0.75) < 0.0001"]}
{"task_num": 689, "task_title": "Maximum Sum of 3 Non-Overlapping Subarrays", "func_name": "maxSumOfThreeSubarrays", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:\n    n = len(nums) - k + 1\n    sums = [0] * n\n    l = [0] * n\n    r = [0] * n\n\n    summ = 0\n    for i, num in enumerate(nums):\n      summ += num\n      if i >= k:\n        summ -= nums[i - k]\n      if i >= k - 1:\n        sums[i - k + 1] = summ\n\n    maxIndex = 0\n    for i in range(n):\n      if sums[i] > sums[maxIndex]:\n        maxIndex = i\n      l[i] = maxIndex\n\n    maxIndex = n - 1\n    for i in range(n - 1, -1, -1):\n      if sums[i] >= sums[maxIndex]:\n        maxIndex = i\n      r[i] = maxIndex\n\n    ans = [-1, -1, -1]\n\n    for i in range(k, n - k):\n      if ans[0] == -1 or sums[ans[0]] + sums[ans[1]] + sums[ans[2]] < sums[l[i - k]] + sums[i] + sums[r[i + k]]:\n        ans[0] = l[i - k]\n        ans[1] = i\n        ans[2] = r[i + k]\n\n    return ans\n", "tests": ["def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([1, 2, 1, 2, 6], 2) == [0, 2, 4]", "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([1, 2, 3, 4, 5], 1) == [0, 1, 2]", "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([3, 2, 1], 3) == [0]", "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([1, 5, 6, 7, 8, 9], 2) == [0, 3, 4]", "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([5, 10, 20, 3, 9, 1], 4) == [0, 2, 4]", "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([1, 2, 3, 4, 5, 6], 3) == [0, 3, 5]", "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([7, 10, 4, 3, 20, 15], 2) == [0, 3, 5]", "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([10, 5, 2, 6, 4, 8], 3) == [0, 1, 4]", "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([100, 200, 300, 400], 1) == [0]", "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([10, 2, 3, 4, 5, 6], 2) == [0, 3, 5]", "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([100, 200, 300, 400], 2) == [0, 1]", "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([10, 20, 30], 5) == [0]", "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([10, 20, 30, 40, 50], 10) == [-1, -1, -1]", "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([5, 4, 3, 2, 1], 1) == [0]", "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([1, 2, 3, 4, 5], 1) == [0]", "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([10, 20, 30], 2) == [0, 1]", "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([10, 20, 30, 40], 5) == [-1, -1, -1]", "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([10, 5, 2, 6, 4, 8], 3) == [0, 1, 4]", "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([10, 2, 3, 4, 5, 6], 2) == [0, 3, 5]", "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([10, 2, 3, 4, 5], 1) == [0]"]}
{"task_num": 691, "task_title": "Stickers to Spell Word", "func_name": "minStickers", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minStickers(self, stickers: List[str], target: str) -> int:\n    maxMask = 1 << len(target)\n    dp = [math.inf] * maxMask\n    dp[0] = 0\n\n    for mask in range(maxMask):\n      if dp[mask] == math.inf:\n        continue\n      for sticker in stickers:\n        superMask = mask\n        for c in sticker:\n          for i, t in enumerate(target):\n            if c == t and not (superMask >> i & 1):\n              superMask |= 1 << i\n              break\n        dp[superMask] = min(dp[superMask], dp[mask] + 1)\n\n    return -1 if dp[-1] == math.inf else dp[-1]\n", "tests": ["def test_minStickers():\n    solution = Solution()\n    stickers = ['with', 'example', 'science']\n    target = 'thehat'\n    assert solution.minStickers(stickers, target) == 3", "def test_minStickers():\n    solution = Solution()\n    stickers = ['apple', 'orange']\n    target = 'banana'\n    assert solution.minStickers(stickers, target) == -1", "def test_minStickers():\n    solution = Solution()\n    stickers = ['banana']\n    target = 'banana'\n    assert solution.minStickers(stickers, target) == 1", "def test_minStickers():\n    solution = Solution()\n    stickers = ['aabb', 'bba']\n    target = 'aaabbb'\n    assert solution.minStickers(stickers, target) == 3", "def test_minStickers():\n    solution = Solution()\n    stickers = ['z', 'y', 'x']\n    target = 'zyx'\n    assert solution.minStickers(stickers, target) == 3", "def test_minStickers():\n    solution = Solution()\n    stickers = ['abc', 'cba', 'bac']\n    target = 'abc'\n    assert solution.minStickers(stickers, target) == 1", "def test_minStickers():\n    solution = Solution()\n    stickers = ['abcdefg', 'hijklmn']\n    target = 'abc'\n    assert solution.minStickers(stickers, target) == 1", "def test_minStickers():\n    solution = Solution()\n    stickers = ['abc', 'bcd', 'cde']\n    target = 'abcde'\n    assert solution.minStickers(stickers, target) == 1", "def test_minStickers():\n    solution = Solution()\n    stickers = ['abc', 'def', 'ghi']\n    target = 'jkl'\n    assert solution.minStickers(stickers, target) == -1", "def test_minStickers():\n    solution = Solution()\n    stickers = ['aaa', 'bbb', 'ccc']\n    target = 'aaabbbccc'\n    assert solution.minStickers(stickers, target) == 3", "def test_minStickers():\n    solution = Solution()\n    stickers = ['abc', 'def']\n    target = 'ghijkl'\n    assert solution.minStickers(stickers, target) == -1", "def test_minStickers():\n    solution = Solution()\n    stickers = ['aaa', 'bbb', 'ccc']\n    target = 'ddddddddddeeeeeeeeffffffffffggggggggghhhhhhhhhhiiiiiiiiijjjjjjjjjjkkkkkkkkklllllllllmmmmmmmmmmnnnnnnnnnoooooooopppppppppqqqqqqqqqqrrrrrrrrrsssssssssstttttttttuuuuuuuuuvvvvvvvvvwwwwwwwwwxxyyyyyyyzzzzzzzzz'\n    assert solution.minStickers(stickers, target) == -1", "def test_minStickers():\n    solution = Solution()\n    stickers = ['abc', 'cba']\n    target = 'xyz'\n    assert solution.minStickers(stickers, target) == -1", "def test_minStickers():\n    solution = Solution()\n    stickers = ['a', 'b']\n    target = 'c'\n    assert solution.minStickers(stickers, target) == -1", "def test_minStickers():\n    solution = Solution()\n    stickers = ['abc', 'abcd']\n    target = 'acde'\n    assert solution.minStickers(stickers, target) == -1", "def test_minStickers():\n    solution = Solution()\n    stickers = ['abc', 'def']\n    target = 'ghi'\n    assert solution.minStickers(stickers, target) == -1", "def test_minStickers():\n    solution = Solution()\n    stickers = ['abc', 'abcd']\n    target = 'acde'\n    assert solution.minStickers(stickers, target) == -1", "def test_minStickers():\n    solution = Solution()\n    stickers = ['abc', 'def']\n    target = 'ghi'\n    assert solution.minStickers(stickers, target) == -1", "def test_minStickers():\n    solution = Solution()\n    stickers = ['abc', 'abcd']\n    target = 'acde'\n    assert solution.minStickers(stickers, target) == -1", "def test_minStickers():\n    solution = Solution()\n    stickers = ['abc', 'def']\n    target = 'ghi'\n    assert solution.minStickers(stickers, target) == -1"]}
{"task_num": 722, "task_title": "Remove Comments", "func_name": "removeComments", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def removeComments(self, source: List[str]) -> List[str]:\n    ans = []\n    commenting = False\n    modified = ''\n\n    for line in source:\n      i = 0\n      while i < len(line):\n        if i + 1 == len(line):\n          if not commenting:\n            modified += line[i]\n          i += 1\n          break\n        twoChars = line[i:i + 2]\n        if twoChars == '/*' and not commenting:\n          commenting = True\n          i += 2\n        elif twoChars == '*/' and commenting:\n          commenting = False\n          i += 2\n        elif twoChars == '//':\n          if not commenting:\n            break\n          else:\n            i += 2\n        else:\n          if not commenting:\n            modified += line[i]\n          i += 1\n      if modified and not commenting:\n        ans.append(modified)\n        modified = ''\n\n    return ans\n", "tests": ["def test_removeComments():\n    solution = Solution()\n    source = ['/*Test*/', 'int main() {', '// cout << \"Hello World!\";', '}']\n    expected = ['int main()', 'cout << \"Hello World!\";']\n    assert solution.removeComments(source) == expected", "def test_removeComments():\n    solution = Solution()\n    source = ['int a = 5;', '/*', 'This is a multi-line comment', 'with multiple lines*/', 'int b = 10;']\n    expected = ['int a = 5;', 'int b = 10;']\n    assert solution.removeComments(source) == expected", "def test_removeComments():\n    solution = Solution()\n    source = ['int x = 3; // This is a line comment', '// This /* is not */ part of the comment', 'int y = 7;', '/* This is a block comment /* nested inside another */']\n    expected = ['int x = 3;', 'int y = 7;']\n    assert solution.removeComments(source) == expected", "def test_removeComments():\n    solution = Solution()\n    source = ['int main() {', '// This is a line comment', '', '// Empty line after block comment', '/* Another block */', '']\n    expected = ['int main()', '']\n    assert solution.removeComments(source) == expected", "def test_removeComments():\n    solution = Solution()\n    source = ['int z = 8; // This is a line comment with /* block */ in it', '// Another line with a block /* comment at the end */']\n    expected = ['int z = 8;', '// Another line with a block']\n    assert solution.removeComments(source) == expected", "def test_removeComments():\n    solution = Solution()\n    source = ['int w = 6; // This is a line comment', '// Another line comment /*', 'which spans multiple lines */']\n    expected = ['int w = 6;', '']\n    assert solution.removeComments(source) == expected", "def test_removeComments():\n    solution = Solution()\n    source = ['int v = 4; // This is a line comment with \\\\// escaped slashes', '// Another line with a block /* comment with \\\\*\\\\/ */']\n    expected = ['int v = 4;', '// Another line with a block']\n    assert solution.removeComments(source) == expected", "def test_removeComments():\n    solution = Solution()\n    source = ['int u = 2;', '// This is a line comment with a /* block */ inside', '/*', 'Another block comment that spans multiple lines', 'including a nested block /* inside it */*/', '// A final line comment']\n    expected = ['int u = 2;', '']\n    assert solution.removeComments(source) == expected", "def test_removeComments():\n    solution = Solution()\n    source = ['/* Leading block comment */', '// This is a line comment at the start of the file', 'int t = 1;', '// This is a line comment at the end of the file', '/* Trailing block comment */']\n    expected = ['int t = 1;']\n    assert solution.removeComments(source) == expected", "def test_removeComments():\n    solution = Solution()\n    source = ['// This is a line comment', '/* Block comment */', '// Another line comment']\n    expected = ['']\n    assert solution.removeComments(source) == expected", "def test_removeComments():\n    solution = Solution()\n    source = ['int s = 0;', '// This is a line comment', '/* This block comment is missing the closing */']\n    expected = ['int s = 0;', '// This is a line comment', '/* This block comment is missing the closing']\n    assert solution.removeComments(source) == expected", "def test_removeComments():\n    solution = Solution()\n    source = ['/* This is a block comment */']\n    expected = ['']\n    assert solution.removeComments(source) == expected", "def test_removeComments():\n    solution = Solution()\n    source = ['char str[] = \"This is a string with // trailing comment\";']\n    expected = ['char str[] = \"This is a string with // trailing comment\";']\n    assert solution.removeComments(source) == expected", "def test_removeComments():\n    solution = Solution()\n    source = ['char str[] = \"This is a string with // line comment\";']\n    expected = ['char str[] = \"This is a string with // line comment\";']\n    assert solution.removeComments(source) == expected", "def test_removeComments():\n    solution = Solution()\n    source = ['int p = 1;', '/*', 'This is a block comment /*', 'with nested block comments */', '*/']\n    expected = ['int p = 1;']\n    assert solution.removeComments(source) == expected", "def test_removeComments():\n    solution = Solution()\n    source = ['char str[] = \"// This is a string with leading line comment\";']\n    expected = ['char str[] = \"// This is a string with leading line comment\";']\n    assert solution.removeComments(source) == expected", "def test_removeComments():\n    solution = Solution()\n    source = ['char str[] = \"This is a string with /* block comment */\";']\n    expected = ['char str[] = \"This is a string with /* block comment */\";']\n    assert solution.removeComments(source) == expected", "def test_removeComments():\n    solution = Solution()\n    source = ['int q = 9;', '// This is a line comment with /*', 'a nested block comment /*', 'and another one */', '*/']\n    expected = ['int q = 9;', '']\n    assert solution.removeComments(source) == expected", "def test_removeComments():\n    solution = Solution()\n    source = ['char str[] = \"This is a string with /* block comment */ inside\";']\n    expected = ['char str[] = \"This is a string with /* block comment */ inside\";']\n    assert solution.removeComments(source) == expected", "def test_removeComments():\n    solution = Solution()\n    source = ['char str[] = \"This is a string with // line comment\";']\n    expected = ['char str[] = \"This is a string with // line comment\";']\n    assert solution.removeComments(source) == expected"]}
{"task_num": 730, "task_title": "Count Different Palindromic Subsequences", "func_name": "countPalindromicSubsequences", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countPalindromicSubsequences(self, s: str) -> int:\n    kMod = 1_000_000_007\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n      dp[i][i] = 1\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        if s[i] == s[j]:\n          lo = i + 1\n          hi = j - 1\n          while lo <= hi and s[lo] != s[i]:\n            lo += 1\n          while lo <= hi and s[hi] != s[i]:\n            hi -= 1\n          if lo > hi:\n            dp[i][j] = dp[i + 1][j - 1] * 2 + 2\n          elif lo == hi:\n            dp[i][j] = dp[i + 1][j - 1] * 2 + 1\n          else:\n            dp[i][j] = dp[i + 1][j - 1] * 2 - dp[lo + 1][hi - 1]\n        else:\n          dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1]\n        dp[i][j] = (dp[i][j] + kMod) % kMod\n\n    return dp[0][n - 1]\n", "tests": ["def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('bccb') == 6", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('abcd') == 4", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('aaaa') == 10", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('abcba') == 7", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('abccba') == 13", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('abcddcba') == 21", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('aabbcc') == 15", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('abcab') == 6", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('abba') == 6", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('aa') == 3", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('aaa') == 6", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('abcdabc') == 14", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('abccbcabc') == 32", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('abcda') == 10", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('a') == 1", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('ababa') == 10", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('abcddcba') == 21", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('abcdedcba') == 29", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('abcabc') == 14", "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('abccba') == 13"]}
{"task_num": 735, "task_title": "Asteroid Collision", "func_name": "asteroidCollision", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def asteroidCollision(self, asteroids: List[int]) -> List[int]:\n    stack = []\n\n    for a in asteroids:\n      if a > 0:\n        stack.append(a)\n      else:\n        while stack and stack[-1] > 0 and stack[-1] < -a:\n          stack.pop()\n        if not stack or stack[-1] < 0:\n          stack.append(a)\n        elif stack[-1] == -a:\n          stack.pop()\n        else:\n          pass\n\n    return stack\n", "tests": ["def test_asteroidCollision():\n    solution = Solution()\n    result = solution.asteroidCollision([5, 10, -5])", "def test_asteroidCollision():\n    solution = Solution()\n    result = solution.asteroidCollision([8, -8])", "def test_asteroidCollision():\n    solution = Solution()\n    result = solution.asteroidCollision([10, -5, 7, -8])", "def test_asteroidCollision():\n    solution = Solution()\n    result = solution.asteroidCollision([1, 2, -3])", "def test_asteroidCollision():\n    solution = Solution()\n    result = solution.asteroidCollision([5, 10, -7])", "def test_asteroidCollision():\n    solution = Solution()\n    result = solution.asteroidCollision([10, -1, -2])", "def test_asteroidCollision():\n    solution = Solution()\n    result = solution.asteroidCollision([-10, 1])", "def test_asteroidCollision():\n    solution = Solution()\n    result = solution.asteroidCollision([10, 5])", "def test_asteroidCollision():\n    solution = Solution()\n    result = solution.asteroidCollision([10, 2, -5])", "def test_asteroidCollision():\n    solution = Solution()\n    result = solution.asteroidCollision([5, 10, -6])", "def test_asteroidCollision():\n    solution = Solution()\n    result = solution.asteroidCollision([10, -5, 2])", "def test_asteroidCollision():\n    solution = Solution()\n    result = solution.asteroidCollision([10, -10])", "def test_asteroidCollision():\n    solution = Solution()\n    result = solution.asteroidCollision([5, -10, 2])", "def test_asteroidCollision():\n    solution = Solution()\n    result = solution.asteroidCollision([10, 5, -2])", "def test_asteroidCollision():\n    solution = Solution()\n    result = solution.asteroidCollision([5, 10, -7])", "def test_asteroidCollision():\n    solution = Solution()\n    result = solution.asteroidCollision([10, 2, -5])", "def test_asteroidCollision():\n    solution = Solution()\n    result = solution.asteroidCollision([5, 10, -6])", "def test_asteroidCollision():\n    solution = Solution()\n    result = solution.asteroidCollision([10, -5, 2])", "def test_asteroidCollision():\n    solution = Solution()\n    result = solution.asteroidCollision([5, 10, -7])", "def test_asteroidCollision():\n    solution = Solution()\n    result = solution.asteroidCollision([10, -5, 2])"]}
{"task_num": 743, "task_title": "Network Delay Time", "func_name": "networkDelayTime", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in times:\n      graph[u - 1].append((v - 1, w))\n\n    return self._dijkstra(graph, k - 1)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int) -> int:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    maxDist = max(dist)\n    return maxDist if maxDist != math.inf else -1\n", "tests": ["def test_networkDelayTime():\n    solution = Solution()\n    times = [[2, 1, 1], [2, 3, 1], [3, 4, 1]]\n    n = 4\n    k = 2\n    assert solution.networkDelayTime(times, n, k) == 2", "def test_networkDelayTime():\n    solution = Solution()\n    times = [[1, 2, 1]]\n    n = 2\n    k = 1\n    assert solution.networkDelayTime(times, n, k) == 1", "def test_networkDelayTime():\n    solution = Solution()\n    times = [[1, 2, -1], [2, 3, 1]]\n    n = 3\n    k = 1\n    assert solution.networkDelayTime(times, n, k) == -1", "def test_networkDelayTime():\n    solution = Solution()\n    times = [[1, 2, 1], [3, 4, 1]]\n    n = 4\n    k = 1\n    expected_result = -1\n    result = solution.networkDelayTime(times, n, k)", "def test_networkDelayTime():\n    solution = Solution()\n    times = [[1, 2, 5], [2, 3, 3], [3, 4, 1]]\n    n = 4\n    k = 1\n    expected_result = 9\n    result = solution.networkDelayTime(times, n, k)", "def test_networkDelayTime():\n    solution = Solution()\n    times = [[1, 2, 5], [2, 3, 3], [3, 4, 1]]\n    n = 4\n    k = 1\n    expected_result = 9\n    result = solution.networkDelayTime(times, n, k)", "def test_networkDelayTime():\n    solution = Solution()\n    times = [[1, 2, 5], [2, 3, 3], [3, 4, 1]]\n    n = 4\n    k = 1\n    expected_result = 9\n    result = solution.networkDelayTime(times, n, k)", "def test_networkDelayTime():\n    solution = Solution()\n    times = [[1, 2, 5], [1, 3, 7], [2, 3, 3], [2, 4, 2], [3, 4, 1]]\n    n = 4\n    expected_results = {1: {1: 0, 2: 5, 3: 7, 4: 6}, 2: {1: float('inf'), 2: 0, 3: 3, 4: 2}, 3: {1: float('inf'), 2: 3, 3: 0, 4: 1}}\n    result_1 = solution.networkDelayTime(times, n, 1)", "def test_networkDelayTime():\n    solution = Solution()\n    times = [[1, 2, 5], [3, 4, 3], [4, 5, 2]]\n    n = 5\n    expected_results = {1: {1: 0, 2: 5}, 3: {3: 0, 4: 3, 5: 5}}\n    result_1 = solution.networkDelayTime(times, n, 1)", "def test_networkDelayTime():\n    solution = Solution()\n    times = [[1, 2, 5], [1, 3, 7], [2, 4, 2], [3, 4, 1], [5, 6, 3]]\n    n = 6\n    expected_results_1 = {1: {1: 0, 2: 5, 3: 7, 4: 6}, 5: {5: 0}}\n    expected_results_3 = {1: {1: float('inf'), 2: float('inf'), 3: 0, 4: 1}, 5: {5: 0}}\n    result_1 = solution.networkDelayTime(times, n, 1)", "def test_networkDelayTime():\n    solution = Solution()\n    import random\n    n = 10000\n    max_edges_per_node = 20\n    max_weight = 100\n    times = []\n    for i in range(1, n):\n        num_edges = random.randint(1, max_edges_per_node)\n        target_nodes = [random.randint(i + 1, n) for _ in range(num_edges)]\n        weights = [random.randint(1, max_weight) for _ in range(num_edges)]\n        for j in range(len(target_nodes)):\n            times.append([i, target_nodes[j], weights[j]])\n    expected_results_1 = {1: {1: 0}}\n    result_1 = solution.networkDelayTime(times, n, 1)", "def test_networkDelayTime():\n    solution = Solution()\n    times = [[1, 2, 5], [1, 3, 7], [2, 4, 2], [3, 4, 1], [5, 6, 3]]\n    n = 6\n    expected_results_1 = {1: {1: 0, 2: 5, 3: 7, 4: 6}}\n    expected_results_3 = {1: {1: float('inf'), 2: float('inf'), 3: 0, 4: 1}, 5: {5: 0}}\n    result_1 = solution.networkDelayTime(times, n, 1)", "def test_networkDelayTime():\n    solution = Solution()\n    times = [[1, 2, 5], [2, 3, 3], [3, 4, 2], [4, 1, -7], [5, 6, 3]]\n    n = 6\n    expected_results_1 = {1: {1: 0, 2: 5, 3: 8, 4: 7}}\n    result_1 = solution.networkDelayTime(times, n, 1)", "def test_networkDelayTime():\n    solution = Solution()\n    times = [[1, 2, 5], [2, 3, 3], [3, 4, 2], [1, 5, 6], [4, 6, 8], [5, 6, 3]]\n    n = 6\n    expected_results_1 = {1: {1: 0, 2: 5, 3: 8, 4: 7, 5: 6}}\n    expected_results_4 = {4: {4: 0, 5: 7, 6: 15}}\n    result_1 = solution.networkDelayTime(times, n, 1)", "def test_networkDelayTime():\n    solution = Solution()\n    times = [[1, 2, 5], [2, 3, 3], [3, 4, -2], [4, 5, -3], [1, 6, 8], [5, 6, 3]]\n    n = 6\n    expected_results_1 = {1: {1: 0, 2: 5, 3: 8, 4: 6, 5: 9, 6: 13}}\n    expected_results_4 = {4: {4: 0, 5: -1, 6: 7}}\n    result_1 = solution.networkDelayTime(times, n, 1)", "def test_networkDelayTime():\n    solution = Solution()\n    times = [[1, 2, 5], [2, 3, 3], [3, 4, -2], [4, 5, -3], [1, 6, 8], [5, 7, 2]]\n    n = 6\n    expected_results_1 = {1: {1: 0, 2: 5, 3: 8, 4: 6, 5: 9}}\n    expected_results_4 = {4: {4: 0, 5: -1}}\n    result_1 = solution.networkDelayTime(times, n, 1)", "def test_networkDelayTime():\n    solution = Solution()\n    times = [[1, 2, 5], [2, 3, 3], [3, 4, -2], [4, 5, -3], [1, 6, 80], [5, 6, 3]]\n    n = 6\n    expected_results_1 = {1: {1: 0, 2: 5, 3: 8, 4: 6, 5: 9}}\n    expected_results_4 = {4: {4: 0, 5: -1, 6: 7}}\n    result_1 = solution.networkDelayTime(times, n, 1)", "def test_networkDelayTime():\n    solution = Solution()\n    times = [[1, 2, 5], [2, 3, 3], [3, 4, -2], [4, 5, -3], [1, 6, 0], [6, 2, 0]]\n    n = 6\n    expected_results_1 = {1: {1: 0, 2: 5, 3: 8, 4: 6, 5: 9, 6: 0}}\n    expected_results_4 = {4: {4: 0, 5: -1, 6: 2}}\n    result_1 = solution.networkDelayTime(times, n, 1)", "def test_networkDelayTime():\n    solution = Solution()\n    times = [[1, 2, 5], [2, 3, 3], [3, 4, -2], [4, 5, -3], [1, 6, 0], [6, 2, 0], [1, 1, 0]]\n    n = 6\n    expected_results_1 = {1: {1: 0, 2: 5, 3: 8, 4: 6, 5: 9, 6: 0}}\n    expected_results_4 = {4: {4: 0, 5: -1, 6: 2}}\n    result_1 = solution.networkDelayTime(times, n, 1)", "def test_networkDelayTime():\n    solution = Solution()\n    times1 = [[1, 2, 5], [2, 3, 3]]\n    times2 = [[4, 5, -2], [5, 6, -3]]\n    n1 = 3\n    n2 = 3\n    expected_results_1 = {1: {1: 0, 2: 5, 3: 8}}\n    expected_results_2 = {4: {4: 0, 5: -2, 6: -5}}\n    result_1 = solution.networkDelayTime(times1, n1, 1)"]}
{"task_num": 770, "task_title": "Basic Calculator IV", "func_name": "basicCalculatorIV", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Poly:\n  def __init__(self, term: str = None, coef: int = None):\n    if term and coef:\n      self.terms = collections.Counter({term: coef})\n    else:\n      self.terms = collections.Counter()\n\n  def __add__(self, other):\n    for term, coef in other.terms.items():\n      self.terms[term] += coef\n    return self\n\n  def __sub__(self, other):\n    for term, coef in other.terms.items():\n      self.terms[term] -= coef\n    return self\n\n  def __mul__(self, other):\n    res = Poly()\n    for a, aCoef in self.terms.items():\n      for b, bCoef in other.terms.items():\n        res.terms[self._merge(a, b)] += aCoef * bCoef\n    return res\n\n  def toList(self) -> List[str]:\n    for term in list(self.terms.keys()):\n      if not self.terms[term]:\n        del self.terms[term]\n\n    def cmp(term: str) -> tuple:\n      if term == '1':\n        return (0,)\n      var = term.split('*')\n      return (-len(var), term)\n\n    def concat(term: str) -> str:\n      if term == '1':\n        return str(self.terms[term])\n      return str(self.terms[term]) + '*' + term\n\n    terms = list(self.terms.keys())\n    terms.sort(key=cmp)\n    return [concat(term) for term in terms]\n\n  def _merge(self, a: str, b: str) -> str:\n    if a == '1':\n      return b\n    if b == '1':\n      return a\n    res = []\n    A = a.split('*')\n    B = b.split('*')\n    i = 0\n    j = 0\n    while i < len(A) and j < len(B):\n      if A[i] < B[j]:\n        res.append(A[i])\n        i += 1\n      else:\n        res.append(B[j])\n        j += 1\n    return '*'.join(res + A[i:] + B[j:])\n\n\nclass Solution:\n  def basicCalculatorIV(self, expression: str, evalvars: List[str], evalints: List[int]) -> List[str]:\n    tokens = list(self._getTokens(expression))\n    evalMap = {a: b for a, b in zip(evalvars, evalints)}\n\n    for i, token in enumerate(tokens):\n      if token in evalMap:\n        tokens[i] = str(evalMap[token])\n\n    postfix = self._infixToPostfix(tokens)\n    return self._evaluate(postfix).toList()\n\n  def _getTokens(self, s: str) -> Iterator[str]:\n    i = 0\n    for j, c in enumerate(s):\n      if c == ' ':\n        if i < j:\n          yield s[i:j]\n        i = j + 1\n      elif c in '()+-*':\n        if i < j:\n          yield s[i:j]\n        yield c\n        i = j + 1\n    if i < len(s):\n      yield s[i:]\n\n  def _infixToPostfix(self, tokens: List[str]) -> List[str]:\n    postfix = []\n    ops = []\n\n    def precedes(prevOp: str, currOp: str) -> bool:\n      if prevOp == '(':\n        return False\n      return prevOp == '*' or currOp in '+-'\n\n    for token in tokens:\n      if token == '(':\n        ops.append(token)\n      elif token == ')':\n        while ops[-1] != '(':\n          postfix.append(ops.pop())\n        ops.pop()\n      elif token in '+-*':\n        while ops and precedes(ops[-1], token):\n          postfix.append(ops.pop())\n        ops.append(token)\n      else:\n        postfix.append(token)\n    return postfix + ops[::-1]\n\n  def _evaluate(self, postfix: List[str]) -> Poly:\n    polys: List[Poly] = []\n    for token in postfix:\n      if token in '+-*':\n        b = polys.pop()\n        a = polys.pop()\n        if token == '+':\n          polys.append(a + b)\n        elif token == '-':\n          polys.append(a - b)\n        else:\n          polys.append(a * b)\n      elif token.lstrip('-').isnumeric():\n        polys.append(Poly(\"1\", int(token)))\n      else:\n        polys.append(Poly(token, 1))\n    return polys[0]\n", "tests": ["def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('e + 8 - a + 5', ['e'], [1]) == ['-1*a', '14']", "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('b*b*a - b*c + 3', ['a', 'b', 'c'], [2, 3, 4]) == ['9*a*b', '-10*a*c']", "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('(a + b) * (c - d)', ['a', 'b', 'c'], [1, 2, 3]) == ['-2*a*c', '-2*a*d', '2*b*c', '2*b*d']", "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('a * b + c - d', ['a', 'b', 'c'], [2, 3, 4]) == ['6*a*b', '-1*c', '-1*d']", "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('a + (b * c) - d / e', ['a', 'b', 'c', 'd', 'e'], [1, 2, 3, 4, 5]) == ['-8*a*b*c', '-4*d/e']", "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('(a + b) * (c + d) - e', ['a', 'b', 'c', 'd'], [1, 2, 3, 4]) == ['-1*a*c', '-1*a*d', '-1*b*c', '-1*b*d', '2*a', '2*b', '3*c', '3*d']", "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('a * (b + c) - d', ['a', 'b', 'c'], [2, 3, 4]) == ['-2*a*d', '6*a*b', '6*a*c']", "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('((a + b) * c) - d', ['a', 'b', 'c'], [1, 2, 3]) == ['-2*a*c', '-2*b*c', '3*a', '3*b']", "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('a * b + c - d', ['a', 'b', 'c'], [2, 3, 4]) == ['6*a*b', '-1*c', '-1*d']", "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('(a + b) * (c - d)', ['a', 'b', 'c', 'd'], [1, 2, 3, 4]) == ['-2*a*c', '-2*a*d', '2*b*c', '2*b*d']", "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('a * (b + c) - d', ['a', 'b', 'c'], [2, 3, 4]) == ['-2*a*d', '6*a*b', '6*a*c']", "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('(a + b) * (c - d)', ['a', 'b', 'c'], [1, 2, 3]) == ['-2*a*c', '-2*a*d', '2*b*c', '2*b*d']", "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('(a + b) * (c - d) + e', ['a', 'b', 'c', 'd'], [1, 2, 3, 4]) == ['-2*a*c', '-2*a*d', '2*b*c', '2*b*d', 'e']", "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('((a + b) * c) - d / e', ['a', 'b', 'c'], [1, 2, 3]) == ['-8*a*b*c', '-4*d/e']", "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('a * b + c - d', ['a', 'b', 'c'], [2, 3, 4]) == ['6*a*b', '-1*c', '-1*d']", "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('(a + b) * (c - d) - e', ['a', 'b', 'c'], [1, 2, 3]) == ['-2*a*c', '-2*a*d', '2*b*c', '2*b*d']", "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('a * (b + c) - d', ['a', 'b', 'c'], [2, 3, 4]) == ['-2*a*d', '6*a*b', '6*a*c']", "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('(a + b) * (c - d)', ['a', 'b', 'c'], [1, 2, 3]) == ['-2*a*c', '-2*a*d', '2*b*c', '2*b*d']", "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('(a + b) * (c - d) + e', ['a', 'b', 'c'], [1, 2, 3]) == ['-2*a*c', '-2*a*d', '2*b*c', '2*b*d', 'e']", "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('((a + b) * c) - d / e', ['a', 'b', 'c'], [1, 2, 3]) == ['-8*a*b*c', '-4*d/e']"]}
{"task_num": 777, "task_title": "Swap Adjacent in LR String", "func_name": "canTransform", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def canTransform(self, start: str, end: str) -> bool:\n    if start.replace('X', '') != end.replace('X', ''):\n      return False\n\n    i = 0\n    j = 0\n\n    while i < len(start) and j < len(end):\n      while i < len(start) and start[i] == 'X':\n        i += 1\n      while j < len(end) and end[j] == 'X':\n        j += 1\n      if i == len(start) and j == len(end):\n        return True\n      if i == len(start) or j == len(end):\n        return False\n      if start[i] == 'L' and i < j:\n        return False\n      if start[i] == 'R' and i > j:\n        return False\n      i += 1\n      j += 1\n\n    return True\n", "tests": ["def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('RXXLRXRXL', 'XRLXXRRLX') == True", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('XRXXXL', 'XXXXLR') == False", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('XXRXL', 'XRLXX') == False", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('LXXXR', 'XLLXX') == False", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('XRXLXXL', 'XRLXXXX') == False", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('LXXLXR', 'XLLRXR') == True", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('XXLXL', 'XLLXL') == False", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('RXXLRXRXL', 'XRLXXXXXX') == False", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('XXXXXL', 'LXXXXXXXXX') == False", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('XLLXXR', 'LXXXXX') == False", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('XXXLXL', 'XRXLLX') == False", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('RXXLXX', 'XXXLXR') == False", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('XLLRXR', 'XXLXRX') == False", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('XRXRXL', 'XRRXXL') == False", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('XRXXXR', 'XRLXXL') == False", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('XLXXXX', 'LXXXXXXXXX') == False", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('XXLRXRXL', 'XRLXXRRL') == True", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('XXXXXL', 'LXXXXXXXXX') == False", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('XRXXXRXL', 'LRLXXXXX') == False", "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('XRXXXRXL', 'LRLXXRX') == False"]}
{"task_num": 782, "task_title": "Transform to Chessboard", "func_name": "movesToChessboard", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def movesToChessboard(self, board: List[List[int]]) -> int:\n    n = len(board)\n\n    for i in range(n):\n      for j in range(n):\n        if board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]:\n          return -1\n\n    rowSum = sum(board[0])\n    colSum = sum(board[i][0] for i in range(n))\n\n    if rowSum != n // 2 and rowSum != (n + 1) // 2:\n      return -1\n    if colSum != n // 2 and colSum != (n + 1) // 2:\n      return -1\n\n    rowSwaps = sum(board[i][0] == (i & 1) for i in range(n))\n    colSwaps = sum(board[0][i] == (i & 1) for i in range(n))\n\n    if n & 1:\n      if rowSwaps & 1:\n        rowSwaps = n - rowSwaps\n      if colSwaps & 1:\n        colSwaps = n - colSwaps\n    else:\n      rowSwaps = min(rowSwaps, n - rowSwaps)\n      colSwaps = min(colSwaps, n - colSwaps)\n\n    return (rowSwaps + colSwaps) // 2\n", "tests": ["def test_movesToChessboard():\n    solution = Solution()\n    assert solution.movesToChessboard([[0, 1], [1, 0]]) == 0", "def test_movesToChessboard():\n    solution = Solution()\n    assert solution.movesToChessboard([[1, 0], [0, 1]]) == 0", "def test_movesToChessboard():\n    solution = Solution()\n    assert solution.movesToChessboard([[1, 0, 1], [0, 1, 0], [1, 0, 1]]) == 0", "def test_movesToChessboard():\n    solution = Solution()\n    assert solution.movesToChessboard([[1, 0], [1, 0]]) == -1", "def test_movesToChessboard():\n    solution = Solution()\n    assert solution.movesToChessboard([[0, 1, 1], [1, 0, 0], [1, 0, 0]]) == -1", "def test_movesToChessboard():\n    solution = Solution()\n    assert solution.movesToChessboard([[0, 1, 0], [1, 0, 1], [0, 1, 0]]) == 2", "def test_movesToChessboard():\n    solution = Solution()\n    assert solution.movesToChessboard([[0, 1, 0], [1, 0, 1], [0, 1, 1]]) == -1", "def test_movesToChessboard():\n    solution = Solution()\n    assert solution.movesToChessboard([[0, 1], [1, 1]]) == -1", "def test_movesToChessboard():\n    solution = Solution()\n    assert solution.movesToChessboard([[0, 1], [0, 1]]) == -1", "def test_movesToChessboard():\n    solution = Solution()\n    assert solution.movesToChessboard([[0, 1], [0, 0]]) == -1", "def test_movesToChessboard():\n    solution = Solution()\n    assert solution.movesToChessboard([[1, 0, 1], [1, 1, 0], [0, 1, 0]]) == -1", "def test_movesToChessboard():\n    solution = Solution()\n    assert solution.movesToChessboard([[0, 1, 1], [1, 0, 0], [1, 0, 1]]) == -1", "def test_movesToChessboard():\n    solution = Solution()\n    assert solution.movesToChessboard([[0, 1], [1, 1]]) == -1", "def test_movesToChessboard():\n    solution = Solution()\n    assert solution.movesToChessboard([[0, 1], [1, 0]]) == 0", "def test_movesToChessboard():\n    solution = Solution()\n    assert solution.movesToChessboard([[1, 0], [0, 1]]) == 0", "def test_movesToChessboard():\n    solution = Solution()\n    assert solution.movesToChessboard([[1, 0, 1], [0, 1, 0], [1, 0, 1]]) == 0", "def test_movesToChessboard():\n    solution = Solution()\n    assert solution.movesToChessboard([[1, 0], [1, 0]]) == -1", "def test_movesToChessboard():\n    solution = Solution()\n    assert solution.movesToChessboard([[0, 1], [1, 0]]) == -1", "def test_movesToChessboard():\n    solution = Solution()\n    assert solution.movesToChessboard([[1, 0], [0, 0]]) == -1", "def test_movesToChessboard():\n    solution = Solution()\n    assert solution.movesToChessboard([[0, 1], [1, 1]]) == -1"]}
{"task_num": 786, "task_title": "K-th Smallest Prime Fraction", "func_name": "kthSmallestPrimeFraction", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\n    n = len(arr)\n    ans = [0, 1]\n    l = 0\n    r = 1\n\n    while True:\n      m = (l + r) / 2\n      ans[0] = 0\n      count = 0\n      j = 1\n\n      for i in range(n):\n        while j < n and arr[i] > m * arr[j]:\n          j += 1\n        count += n - j\n        if j == n:\n          break\n        if ans[0] * arr[j] < ans[1] * arr[i]:\n          ans[0] = arr[i]\n          ans[1] = arr[j]\n\n      if count < k:\n        l = m\n      elif count > k:\n        r = m\n      else:\n        return ans\n", "tests": ["def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    result = solution.kthSmallestPrimeFraction([1, 2, 3, 5], 3)", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    result = solution.kthSmallestPrimeFraction([1, 7], 1)", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    result = solution.kthSmallestPrimeFraction([1, 2, 3, 5], 4)", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    result = solution.kthSmallestPrimeFraction([1, 3, 5], 2)", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    result = solution.kthSmallestPrimeFraction([2, 3, 5, 7], 6)", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    result = solution.kthSmallestPrimeFraction([1, 4, 9], 2)", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    result = solution.kthSmallestPrimeFraction([2, 3, 5], 1)", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    result = solution.kthSmallestPrimeFraction([1, 2, 3], 1)", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    result = solution.kthSmallestPrimeFraction([1, 5], 2)", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    result = solution.kthSmallestPrimeFraction([1, 3, 7], 4)", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    result = solution.kthSmallestPrimeFraction([1, 2, 5], 3)", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    result = solution.kthSmallestPrimeFraction([1, 3], 2)", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    result = solution.kthSmallestPrimeFraction([1, 2], 1)", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    result = solution.kthSmallestPrimeFraction([1, 7], 2)", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    result = solution.kthSmallestPrimeFraction([1, 3], 2)", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    result = solution.kthSmallestPrimeFraction([1, 5], 2)", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    result = solution.kthSmallestPrimeFraction([1, 3, 5], 3)", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    result = solution.kthSmallestPrimeFraction([1, 2, 3], 2)", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    result = solution.kthSmallestPrimeFraction([1, 3, 7], 5)", "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    result = solution.kthSmallestPrimeFraction([1, 5], 2)"]}
{"task_num": 787, "task_title": "Cheapest Flights Within K Stops", "func_name": "findCheapestPrice", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in flights:\n      graph[u].append((v, w))\n\n    return self._dijkstra(graph, src, dst, k)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, k: int) -> int:\n    dist=[]\n    for i in range(len(graph)):\n      dist.append([math.inf for _ in range(k + 2)])\n\n    dist[src][k + 1] = 0\n    minHeap = [(dist[src][k + 1], src, k + 1)]\n\n    while minHeap:\n      d, u, stops = heapq.heappop(minHeap)\n      if u == dst:\n        return d\n      if stops == 0 or d > dist[u][stops]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v][stops - 1]:\n          dist[v][stops - 1] = d + w\n          heapq.heappush(minHeap, (dist[v][stops - 1], v, stops - 1))\n\n    return -1\n", "tests": ["def test_findCheapestPrice():\n    solution = Solution()\n    assert solution.findCheapestPrice(3, [[0, 1, 100], [1, 2, 100], [0, 2, 500]], 0, 2, 1) == 200", "def test_findCheapestPrice():\n    solution = Solution()\n    assert solution.findCheapestPrice(3, [], 0, 2, 1) == -1", "def test_findCheapestPrice():\n    solution = Solution()\n    assert solution.findCheapestPrice(3, [[0, 1, 100], [1, 2, 50]], 0, 2, 0) == -1", "def test_findCheapestPrice():\n    solution = Solution()\n    assert solution.findCheapestPrice(3, [[0, 1, 100], [1, 2, 100], [0, 2, 500]], 0, 2, 1) == 200", "def test_findCheapestPrice():\n    solution = Solution()\n    assert solution.findCheapestPrice(4, [[0, 1, 10], [1, 2, 30], [2, 3, 50]], 0, 3, 1) == 40", "def test_findCheapestPrice():\n    solution = Solution()\n    assert solution.findCheapestPrice(3, [[0, 1, 100], [1, 2, 50]], 0, 2, 1) == 150", "def test_findCheapestPrice():\n    solution = Solution()\n    assert solution.findCheapestPrice(3, [[0, 1, 10], [1, 2, 50]], 0, 2, 0) == -1", "def test_findCheapestPrice():\n    solution = Solution()\n    assert solution.findCheapestPrice(4, [[0, 1, 10], [1, 2, 30], [2, 3, 50], [0, 2, 70]], 0, 3, 1) == 80", "def test_findCheapestPrice():\n    solution = Solution()\n    assert solution.findCheapestPrice(3, [[0, 1, -5], [1, 2, -10]], 0, 2, 1) == 5", "def test_findCheapestPrice():\n    solution = Solution()\n    assert solution.findCheapestPrice(3, [[0, 1, 100], [1, 2, 50]], 0, 2, 2) == -1", "def test_findCheapestPrice():\n    solution = Solution()\n    assert solution.findCheapestPrice(3, [[0, 1, 100], [2, 1, 50]], 0, 2, 1) == -1", "def test_findCheapestPrice():\n    solution = Solution()\n    assert solution.findCheapestPrice(4, [[0, 1, 10], [1, 2, 50], [2, 3, 10]], 0, 3, 2) == 70", "def test_findCheapestPrice():\n    solution = Solution()\n    assert solution.findCheapestPrice(3, [], 0, 2, 1) == -1", "def test_findCheapestPrice():\n    solution = Solution()\n    assert solution.findCheapestPrice(3, [[0, 2, 50]], 0, 2, 0) == 50", "def test_findCheapestPrice():\n    solution = Solution()\n    assert solution.findCheapestPrice(3, [[0, 1, 50], [1, 2, 50]], 0, 2, 0) == 100", "def test_findCheapestPrice():\n    solution = Solution()\n    assert solution.findCheapestPrice(4, [[0, 1, 10], [1, 2, 30], [2, 3, 50], [0, 2, 70]], 0, 3, 2) == 80", "def test_findCheapestPrice():\n    solution = Solution()\n    assert solution.findCheapestPrice(4, [[0, 1, 10], [1, 2, 50], [2, 3, 70]], 0, 3, 2) == -1", "def test_findCheapestPrice():\n    solution = Solution()\n    assert solution.findCheapestPrice(3, [[0, 1, -5], [1, 2, -10]], 0, 2, 2) == -1", "def test_findCheapestPrice():\n    solution = Solution()\n    flights = []\n    for u in range(10):\n        for v in range(10):\n            if u != v:\n                flights.append([u, v, 1])\n    assert solution.findCheapestPrice(10, flights, 0, 9, 5) == 6", "def test_findCheapestPrice():\n    solution = Solution()\n    assert solution.findCheapestPrice(3, [[0, 1, -5], [1, 2, -10]], 0, 2, 1) == -1"]}
{"task_num": 794, "task_title": "Valid Tic-Tac-Toe State", "func_name": "validTicTacToe", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def validTicTacToe(self, board: List[str]) -> bool:\n    def isWin(c: str) -> bool:\n      return any(row.count(c) == 3 for row in board) or any(row.count(c) == 3 for row in list(zip(*board))) or all(board[i][i] == c for i in range(3)) or all(board[i][2 - i] == c for i in range(3))\n\n    countX = sum(row.count('X') for row in board)\n    countO = sum(row.count('O') for row in board)\n\n    if countX < countO or countX - countO > 1:\n      return False\n    if isWin('X') and countX == countO or isWin('O') and countX != countO:\n      return False\n\n    return True\n", "tests": ["def test_validTicTacToe():\n    solution = Solution()\n    assert solution.validTicTacToe(['XOX', 'O O', 'XOX']) == True", "def test_validTicTacToe():\n    solution = Solution()\n    assert solution.validTicTacToe(['XXX', '   ', 'OOO']) == False", "def test_validTicTacToe():\n    solution = Solution()\n    assert solution.validTicTacToe(['XOX', 'O X', '  ']) == True", "def test_validTicTacToe():\n    solution = Solution()\n    assert solution.validTicTacToe(['XXX', 'XXO', '   ']) == False", "def test_validTicTacToe():\n    solution = Solution()\n    assert solution.validTicTacToe(['XOX', 'O O', 'XOO']) == False", "def test_validTicTacToe():\n    solution = Solution()\n    assert solution.validTicTacToe(['   ', '   ', '   ']) == True", "def test_validTicTacToe():\n    solution = Solution()\n    assert solution.validTicTacToe(['XOX', 'OXX', 'OOO']) == False", "def test_validTicTacToe():\n    solution = Solution()\n    assert solution.validTicTacToe(['XXX', 'OOO', '   ']) == False", "def test_validTicTacToe():\n    solution = Solution()\n    assert solution.validTicTacToe(['X O', ' X ', '  ']) == True", "def test_validTicTacToe():\n    solution = Solution()\n    assert solution.validTicTacToe(['XOO', 'XXO', ' X ']) == True", "def test_validTicTacToe():\n    solution = Solution()\n    assert solution.validTicTacToe(['XOX', 'OO ', ' X']) == True", "def test_validTicTacToe():\n    solution = Solution()\n    assert solution.validTicTacToe(['XOX', ' O ', '  ']) == True", "def test_validTicTacToe():\n    solution = Solution()\n    assert solution.validTicTacToe(['XXX', '   ', '   ']) == False", "def test_validTicTacToe():\n    solution = Solution()\n    assert solution.validTicTacToe([' O ', 'XOX', ' X']) == True", "def test_validTicTacToe():\n    solution = Solution()\n    assert solution.validTicTacToe(['XOO', 'XXO', ' OX']) == True", "def test_validTicTacToe():\n    solution = Solution()\n    assert solution.validTicTacToe(['OXX', ' X ', '  ']) == True", "def test_validTicTacToe():\n    solution = Solution()\n    assert solution.validTicTacToe(['XOX', ' O ', '   ']) == True", "def test_validTicTacToe():\n    solution = Solution()\n    assert solution.validTicTacToe(['X O', ' X ', '  ']) == True", "def test_validTicTacToe():\n    solution = Solution()\n    assert solution.validTicTacToe(['XOX', ' O ', '   ']) == True", "def test_validTicTacToe():\n    solution = Solution()\n    assert solution.validTicTacToe(['XXX', '   ', '   ']) == False"]}
{"task_num": 805, "task_title": "Split Array With Same Average", "func_name": "splitArraySameAverage", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def splitArraySameAverage(self, nums: List[int]) -> bool:\n    n = len(nums)\n    summ = sum(nums)\n    if not any(i * summ % n == 0 for i in range(1, n // 2 + 1)):\n      return False\n\n    sums = [set() for _ in range(n // 2 + 1)]\n    sums[0].add(0)\n\n    for num in nums:\n      for i in range(n // 2, 0, -1):\n        for val in sums[i - 1]:\n          sums[i].add(num + val)\n\n    for i in range(1, n // 2 + 1):\n      if i * summ % n == 0 and i * summ // n in sums[i]:\n        return True\n\n    return False\n", "tests": ["def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([1, 2, 3, 4]) == True", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([-1, 2, -3, 4]) == True", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([]) == False", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([5]) == False", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([10, 10, 10, 10]) == True", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([1, 2, 3, 6]) == True", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([1000, 2000, 3000]) == True", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([-5, -10, 5, 10]) == True", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([1, 2, 3]) == False", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([2]) == False", "def test_splitArraySameAverage():\n    solution = Solution()\n    nums = list(range(1, 1001))\n    assert solution.splitArraySameAverage(nums) == True", "def test_splitArraySameAverage():\n    solution = Solution()\n    nums = [3] * 100\n    assert solution.splitArraySameAverage(nums) == True", "def test_splitArraySameAverage():\n    solution = Solution()\n    nums = [1000000, 2000000, -3000000]\n    assert solution.splitArraySameAverage(nums) == True", "def test_splitArraySameAverage():\n    solution = Solution()\n    nums = [1, 2]\n    assert solution.splitArraySameAverage(nums) == True", "def test_splitArraySameAverage():\n    solution = Solution()\n    nums = list(range(1, 10001))\n    assert solution.splitArraySameAverage(nums) == True", "def test_splitArraySameAverage():\n    solution = Solution()\n    nums = list(range(-10000, 0))\n    assert solution.splitArraySameAverage(nums) == True", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([-1, 2, -3]) == False", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([-100, 200, -300]) == False", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([1, 2, -3]) == False", "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([-1, 2, -3]) == False"]}
{"task_num": 815, "task_title": "Bus Routes", "func_name": "numBusesToDestination", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:\n    if source == target:\n      return 0\n\n    graph = collections.defaultdict(list)\n    usedBuses = set()\n\n    for i in range(len(routes)):\n      for route in routes[i]:\n        graph[route].append(i)\n\n    ans = 0\n    q = collections.deque([source])\n\n    while q:\n      ans += 1\n      for _ in range(len(q)):\n        for bus in graph[q.popleft()]:\n          if bus in usedBuses:\n            continue\n          usedBuses.add(bus)\n          for nextRoute in routes[bus]:\n            if nextRoute == target:\n              return ans\n            q.append(nextRoute)\n\n    return -1\n", "tests": ["def test_numBusesToDestination():\n    solution = Solution()\n    routes = [[1, 2, 7], [3, 4, 5], [6, 7, 8]]\n    source = 1\n    target = 6\n    assert solution.numBusesToDestination(routes, source, target) == 2", "def test_numBusesToDestination():\n    solution = Solution()\n    routes = [[1, 3], [2, 4], [5, 7]]\n    source = 1\n    target = 8\n    assert solution.numBusesToDestination(routes, source, target) == -1", "def test_numBusesToDestination():\n    solution = Solution()\n    routes = [[7], [4, 5], [3, 6]]\n    source = 7\n    target = 7\n    assert solution.numBusesToDestination(routes, source, target) == 0", "def test_numBusesToDestination():\n    solution = Solution()\n    routes = [[1, 2], [3, 4], [5, 6]]\n    source = 1\n    target = 7\n    assert solution.numBusesToDestination(routes, source, target) == -1", "def test_numBusesToDestination():\n    solution = Solution()\n    routes = [[1, 2], [3, 4], [5, 6]]\n    source = 2\n    target = 5\n    assert solution.numBusesToDestination(routes, source, target) == -1", "def test_numBusesToDestination():\n    solution = Solution()\n    routes = [[5, 7], [4, 6], [3, 5], [2, 4]]\n    source = 2\n    target = 6\n    assert solution.numBusesToDestination(routes, source, target) == 2", "def test_numBusesToDestination():\n    solution = Solution()\n    routes = [[10], [20, 30, 40], [50, 60]]\n    source = 10\n    target = 60\n    assert solution.numBusesToDestination(routes, source, target) == 2", "def test_numBusesToDestination():\n    solution = Solution()\n    routes = [[1, 5], [2, 6], [3, 7]]\n    source = 1\n    target = 3\n    assert solution.numBusesToDestination(routes, source, target) == -1", "def test_numBusesToDestination():\n    solution = Solution()\n    routes = [[10, 20], [30, 40], [50, 60]]\n    source = 30\n    target = 10\n    assert solution.numBusesToDestination(routes, source, target) == -1", "def test_numBusesToDestination():\n    solution = Solution()\n    routes = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    source = 1\n    target = 9\n    assert solution.numBusesToDestination(routes, source, target) == 3", "def test_numBusesToDestination():\n    solution = Solution()\n    routes = [[1, 4], [2, 3]]\n    source = 1\n    target = 3\n    assert solution.numBusesToDestination(routes, source, target) == -1", "def test_numBusesToDestination():\n    solution = Solution()\n    routes = [[1, 5], [5, 9], [9, 12]]\n    source = 1\n    target = 12\n    assert solution.numBusesToDestination(routes, source, target) == 3", "def test_numBusesToDestination():\n    solution = Solution()\n    routes = [[1, 2], [3, 4, 5], [6, 7, 8]]\n    source = 1\n    target = 8\n    assert solution.numBusesToDestination(routes, source, target) == 2", "def test_numBusesToDestination():\n    solution = Solution()\n    routes = [[1], [2], [3], [4]]\n    source = 1\n    target = 4\n    assert solution.numBusesToDestination(routes, source, target) == 3", "def test_numBusesToDestination():\n    solution = Solution()\n    routes = [[10, 20], [30, 40], [50, 60]]\n    source = 10\n    target = 70\n    assert solution.numBusesToDestination(routes, source, target) == -1", "def test_numBusesToDestination():\n    solution = Solution()\n    routes = [[1, 5], [2, 6], [7, 8]]\n    source = 1\n    target = 8\n    assert solution.numBusesToDestination(routes, source, target) == -1", "def test_numBusesToDestination():\n    solution = Solution()\n    routes = [[1, 2], [3, 4], [5, 6], [7, 8]]\n    source = 2\n    target = 8\n    assert solution.numBusesToDestination(routes, source, target) == -1", "def test_numBusesToDestination():\n    solution = Solution()\n    routes = [[1, 3], [2, 4], [5, 7]]\n    source = 3\n    target = 6\n    assert solution.numBusesToDestination(routes, source, target) == -1", "def test_numBusesToDestination():\n    solution = Solution()\n    routes = [[1, 2], [3, 4], [5, 6]]\n    source = 1\n    target = 4\n    assert solution.numBusesToDestination(routes, source, target) == 1", "def test_numBusesToDestination():\n    solution = Solution()\n    routes = [[1, 5], [2, 6], [7, 8]]\n    source = 2\n    target = 2\n    assert solution.numBusesToDestination(routes, source, target) == 0"]}
{"task_num": 838, "task_title": "Push Dominoes", "func_name": "pushDominoes", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def pushDominoes(self, dominoes: str) -> str:\n    ans = list(dominoes)\n    L = -1\n    R = -1\n\n    for i in range(len(dominoes) + 1):\n      if i == len(dominoes) or dominoes[i] == 'R':\n        if L < R:\n          while R < i:\n            ans[R] = 'R'\n            R += 1\n        R = i\n      elif dominoes[i] == 'L':\n        if R < L or (L, R) == (-1, -1):\n          if (L, R) == (-1, -1):\n            L += 1\n          while L < i:\n            ans[L] = 'L'\n            L += 1\n        else:\n          l = R + 1\n          r = i - 1\n          while l < r:\n            ans[l] = 'R'\n            ans[r] = 'L'\n            l += 1\n            r -= 1\n        L = i\n\n    return ''.join(ans)\n", "tests": ["def test_pushDominoes():\n    solution = Solution()\n    result = solution.pushDominoes('.L.R...LR..L..')", "def test_pushDominoes():\n    solution = Solution()\n    result = solution.pushDominoes('RR.L')", "def test_pushDominoes():\n    solution = Solution()\n    result = solution.pushDominoes('.L..R.')", "def test_pushDominoes():\n    solution = Solution()\n    result = solution.pushDominoes('L.R')", "def test_pushDominoes():\n    solution = Solution()\n    result = solution.pushDominoes('R..R')", "def test_pushDominoes():\n    solution = Solution()\n    result = solution.pushDominoes('L...R')", "def test_pushDominoes():\n    solution = Solution()\n    result = solution.pushDominoes('.')", "def test_pushDominoes():\n    solution = Solution()\n    result = solution.pushDominoes('RRR.LLL')", "def test_pushDominoes():\n    solution = Solution()\n    result = solution.pushDominoes('L.L')", "def test_pushDominoes():\n    solution = Solution()\n    result = solution.pushDominoes('.L.L')", "def test_pushDominoes():\n    solution = Solution()\n    result = solution.pushDominoes('R..L.R')", "def test_pushDominoes():\n    solution = Solution()\n    result = solution.pushDominoes('L.R.L')", "def test_pushDominoes():\n    solution = Solution()\n    result = solution.pushDominoes('R..')", "def test_pushDominoes():\n    solution = Solution()\n    result = solution.pushDominoes('L..')", "def test_pushDominoes():\n    solution = Solution()\n    result = solution.pushDominoes('R..L.R.L')", "def test_pushDominoes():\n    solution = Solution()\n    result = solution.pushDominoes('.L..R.L')", "def test_pushDominoes():\n    solution = Solution()\n    result = solution.pushDominoes('R.L.R')", "def test_pushDominoes():\n    solution = Solution()\n    result = solution.pushDominoes('.R..L')", "def test_pushDominoes():\n    solution = Solution()\n    result = solution.pushDominoes('R.L')", "def test_pushDominoes():\n    solution = Solution()\n    result = solution.pushDominoes('.L..R..L')"]}
{"task_num": 845, "task_title": "Longest Mountain in Array", "func_name": "longestMountain", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def longestMountain(self, arr: List[int]) -> int:\n    ans = 0\n    i = 0\n\n    while i + 1 < len(arr):\n      while i + 1 < len(arr) and arr[i] == arr[i + 1]:\n        i += 1\n\n      increasing = 0\n      decreasing = 0\n\n      while i + 1 < len(arr) and arr[i] < arr[i + 1]:\n        increasing += 1\n        i += 1\n\n      while i + 1 < len(arr) and arr[i] > arr[i + 1]:\n        decreasing += 1\n        i += 1\n\n      if increasing > 0 and decreasing > 0:\n        ans = max(ans, increasing + decreasing + 1)\n\n    return ans\n", "tests": ["def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([2, 1, 4, 7, 3, 2, 5]) == 5", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([1, 2, 3, 4, 5]) == 0", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([5, 4, 3, 2, 1]) == 0", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([1, 3, 5, 7, 6, 4, 2]) == 7", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([1]) == 0", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([2, 1, 4, 7, 3, 2, 5, 6]) == 5", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([1, 2, 3, 4, 5, 6]) == 0", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == 0", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([1, 2, 3, 4, 5, 6, 7, 8]) == 0", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([1, 3, 2]) == 3", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([1, 2, 3, 4, 5, 4, 3, 2, 1]) == 9", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 0", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([1, 2, 3, 2, 1]) == 5", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([0, 1, 2, 3, 4, 5, 4, 3, 2, 1, 0]) == 9", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([1, 2, 3, 4, 5, 6, 7, 8, 9, 8]) == 9", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([1, 2, 3, 4, 5, 6, 7, 8, 9, 0]) == 0", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 0", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([1, 2, 3, 4, 5, 4, 3, 2]) == 7", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([1, 3, 5, 7, 6, 4, 2, 1]) == 9", "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == 17"]}
{"task_num": 854, "task_title": "K-Similar Strings", "func_name": "kSimilarity", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def kSimilarity(self, s1: str, s2: str) -> int:\n    ans = 0\n    q = collections.deque([s1])\n    seen = {s1}\n\n    while q:\n      for _ in range(len(q)):\n        curr = q.popleft()\n        if curr == s2:\n          return ans\n        for child in self._getChildren(curr, s2):\n          if child in seen:\n            continue\n          q.append(child)\n          seen.add(child)\n      ans += 1\n\n    return -1\n\n  def _getChildren(self, curr: str, target: str) -> List[str]:\n    children = []\n    s = list(curr)\n    i = 0\n    while curr[i] == target[i]:\n      i += 1\n\n    for j in range(i + 1, len(s)):\n      if s[j] == target[i]:\n        s[i], s[j] = s[j], s[i]\n        children.append(''.join(s))\n        s[i], s[j] = s[j], s[i]\n\n    return children\n", "tests": ["def test_kSimilarity():\n    solution = Solution()\n    result = solution.kSimilarity('ab', 'ba')", "def test_kSimilarity():\n    solution = Solution()\n    result = solution.kSimilarity('abc', 'bca')", "def test_kSimilarity():\n    solution = Solution()\n    result = solution.kSimilarity('aabbcc', 'cbacba')", "def test_kSimilarity():\n    solution = Solution()\n    result = solution.kSimilarity('abcde', 'edcba')", "def test_kSimilarity():\n    solution = Solution()\n    result = solution.kSimilarity('aaabbbccc', 'cccbbaaab')", "def test_kSimilarity():\n    solution = Solution()\n    result = solution.kSimilarity('abcde', 'abced')", "def test_kSimilarity():\n    solution = Solution()\n    result = solution.kSimilarity('abcde', 'acbed')", "def test_kSimilarity():\n    solution = Solution()\n    result = solution.kSimilarity('abcde', 'adbec')", "def test_kSimilarity():\n    solution = Solution()\n    result = solution.kSimilarity('abcde', 'baedc')", "def test_kSimilarity():\n    solution = Solution()\n    result = solution.kSimilarity('abcde', 'edcba')", "def test_kSimilarity():\n    solution = Solution()\n    result = solution.kSimilarity('abcde', 'edacb')", "def test_kSimilarity():\n    solution = Solution()\n    result = solution.kSimilarity('abcde', 'dabce')", "def test_kSimilarity():\n    solution = Solution()\n    result = solution.kSimilarity('abcde', 'adbce')", "def test_kSimilarity():\n    solution = Solution()\n    result = solution.kSimilarity('abcde', 'adbec')", "def test_kSimilarity():\n    solution = Solution()\n    result = solution.kSimilarity('abcde', 'badce')", "def test_kSimilarity():\n    solution = Solution()\n    result = solution.kSimilarity('abcde', 'bacde')", "def test_kSimilarity():\n    solution = Solution()\n    result = solution.kSimilarity('abcde', 'ebacd')", "def test_kSimilarity():\n    solution = Solution()\n    result = solution.kSimilarity('abcde', 'edbac')", "def test_kSimilarity():\n    solution = Solution()\n    result = solution.kSimilarity('abcde', 'fedcb')", "def test_kSimilarity():\n    solution = Solution()\n    result = solution.kSimilarity('abcde', 'fghij')"]}
{"task_num": 861, "task_title": "Score After Flipping Matrix", "func_name": "matrixScore", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def matrixScore(self, grid: List[List[int]]) -> int:\n    for row in grid:\n      if row[0] == 0:\n        self._flip(row)\n\n    for j, col in enumerate(list(zip(*grid))):\n      if sum(col) * 2 < len(grid):\n        self._flipCol(grid, j)\n\n    return sum(self._binary(row) for row in grid)\n\n  def _flip(self, row: List[int]) -> None:\n    for i in range(len(row)):\n      row[i] ^= 1\n\n  def _flipCol(self, grid: List[List[int]], j: int) -> None:\n    for i in range(len(grid)):\n      grid[i][j] ^= 1\n\n  def _binary(self, row: List[int]) -> int:\n    res = row[0]\n    for j in range(1, len(row)):\n      res = res * 2 + row[j]\n    return res\n", "tests": ["def test_matrixScore():\n    solution = Solution()\n    grid = [[0, 0], [1, 1]]\n    assert solution.matrixScore(grid) == 3", "def test_matrixScore():\n    solution = Solution()\n    grid = [[0] * 5 for _ in range(4)]\n    assert solution.matrixScore(grid) == 16", "def test_matrixScore():\n    solution = Solution()\n    grid = [[1], [0], [1]]\n    assert solution.matrixScore(grid) == 7", "def test_matrixScore():\n    solution = Solution()\n    grid = [[0]]\n    assert solution.matrixScore(grid) == 1", "def test_matrixScore():\n    solution = Solution()\n    grid = [[0, 1], [0, 1], [0, 1]]\n    assert solution.matrixScore(grid) == 24", "def test_matrixScore():\n    solution = Solution()\n    grid = [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\n    assert solution.matrixScore(grid) == (2 ** 3 - 1) * 3", "def test_matrixScore():\n    solution = Solution()\n    grid = [[0, 1, 0], [1, 0, 1], [1, 1, 0]]\n    assert solution.matrixScore(grid) == 48", "def test_matrixScore():\n    solution = Solution()\n    grid = [[0, 1] * 4, [1, 0] * 4, [1, 1] * 4]\n    assert solution.matrixScore(grid) == (2 ** 2 - 1) * 3 * 4", "def test_matrixScore():\n    solution = Solution()\n    grid = [[0, 1, 0, 1], [1, 0, 1, 0], [1, 1, 0, 1], [0, 0, 1, 0]]\n    assert solution.matrixScore(grid) == 60", "def test_matrixScore():\n    import random\n    solution = Solution()\n    (m, n) = (100, 50)\n    grid = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\n    expected_score = sum((int(''.join(map(str, row)), 2) for row in grid))\n    assert solution.matrixScore(grid) == expected_score", "def test_matrixScore():\n    import random\n    solution = Solution()\n    (m, n) = (500, 200)\n    grid = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\n    expected_score = sum((int(''.join(map(str, row)), 2) for row in grid))\n    assert solution.matrixScore(grid) == expected_score", "def test_matrixScore():\n    import random\n    solution = Solution()\n    (m, n) = (30, 50)\n    grid = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\n    expected_score = sum((int(''.join(map(str, row)), 2) for row in grid))\n    assert solution.matrixScore(grid) == expected_score", "def test_matrixScore():\n    import random\n    solution = Solution()\n    (m, n) = (5, 8)\n    grid = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\n    expected_score = sum((int(''.join(map(str, row)), 2) for row in grid))\n    assert solution.matrixScore(grid) == expected_score", "def test_matrixScore():\n    import random\n    solution = Solution()\n    (m, n) = (2, 3)\n    grid = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\n    expected_score = sum((int(''.join(map(str, row)), 2) for row in grid))\n    assert solution.matrixScore(grid) == expected_score", "def test_matrixScore():\n    solution = Solution()\n    (m, n) = (5, 3)\n    grid = [[0 for _ in range(n)] for _ in range(m)]\n    expected_score = 2 ** (n - 1) * m\n    assert solution.matrixScore(grid) == expected_score", "def test_matrixScore():\n    solution = Solution()\n    (m, n) = (3, 5)\n    grid = [[0, 1, 0, 1, 0], [1, 0, 1, 0, 1], [0, 1, 0, 1, 0]]\n    expected_score = sum((int(''.join(map(str, row)), 2) for row in grid))\n    assert solution.matrixScore(grid) == expected_score", "def test_matrixScore():\n    solution = Solution()\n    (m, n) = (4, 4)\n    grid = [[1, 0, 0, 1], [0, 1, 1, 0], [0, 1, 1, 0], [1, 0, 0, 1]]\n    expected_score = sum((int(''.join(map(str, row)), 2) for row in grid))\n    assert solution.matrixScore(grid) == expected_score", "def test_matrixScore():\n    solution = Solution()\n    (m, n) = (100, 100)\n    grid = [[1 for _ in range(n)] for _ in range(m)]\n    expected_score = sum((int(''.join(map(str, row)), 2) for row in grid))\n    assert solution.matrixScore(grid) == expected_score", "def test_matrixScore():\n    solution = Solution()\n    row_length = 5\n    grid = [[i % 2 for i in range(row_length)]]\n    expected_score = int(''.join(map(str, grid[0])), 2)\n    assert solution.matrixScore(grid) == expected_score", "def test_matrixScore():\n    solution = Solution()\n    row_length = 5\n    grid = [[i % 2 for i in range(row_length)], [(i + 1) % 2 for i in range(row_length)], [i % 2 for i in range(row_length)], [(i + 1) % 2 for i in range(row_length)], [i % 2 for i in range(row_length)]]\n    expected_score = sum((int(''.join(map(str, row)), 2) for row in grid))\n    assert solution.matrixScore(grid) == expected_score"]}
{"task_num": 866, "task_title": "Prime Palindrome", "func_name": "primePalindrome", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def primePalindrome(self, n: int) -> int:\n    def getPalindromes(n: int):\n      length = n // 2\n      for i in range(10**(length - 1), 10**length):\n        s = str(i)\n        for j in range(10):\n          yield int(s + str(j) + s[::-1])\n\n    def isPrime(num: int) -> bool:\n      for i in range(2, int(num**0.5 + 1)):\n        if num % i == 0:\n          return False\n      return True\n\n    if n <= 2:\n      return 2\n    if n == 3:\n      return 3\n    if n <= 5:\n      return 5\n    if n <= 7:\n      return 7\n    if n <= 11:\n      return 11\n\n    nLength = len(str(n))\n\n    while True:\n      for num in getPalindromes(nLength):\n        if num >= n and isPrime(num):\n          return num\n      nLength += 1\n", "tests": ["def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(3) == 7", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(123456789) == 1000000007", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(2) == 2", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(1) == 2", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(100) == 101", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(99) == 101", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(2 * 10 ** 8) == 200030002", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(9) == 11", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(5) == 5", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(10) == 11", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(20) == 23", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(9987654321) == 100000000001", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(1234567890) == 1000000001", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(2 * 10 ** 7) == 335435333", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(12) == 13", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(7) == 7", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(200) == 211", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(9876543210) == 100000000001", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(2) == 2", "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(1000) == 1003001"]}
{"task_num": 882, "task_title": "Reachable Nodes In Subdivided Graph", "func_name": "reachableNodes", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def reachableNodes(self, edges: List[List[int]], maxMoves: int, n: int) -> int:\n    graph = [[] for _ in range(n)]\n    dist = [maxMoves + 1] * n\n\n    for u, v, cnt in edges:\n      graph[u].append((v, cnt))\n      graph[v].append((u, cnt))\n\n    reachableNodes = self._dijkstra(graph, 0, maxMoves, dist)\n    reachableSubnodes = 0\n\n    for u, v, cnt in edges:\n      a = 0 if dist[u] > maxMoves else min(maxMoves - dist[u], cnt)\n      b = 0 if dist[v] > maxMoves else min(maxMoves - dist[v], cnt)\n      reachableSubnodes += min(a + b, cnt)\n\n    return reachableNodes + reachableSubnodes\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, maxMoves: int, dist: List[int]) -> int:\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if dist[u] >= maxMoves:\n        break\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        newDist = d + w + 1\n        if newDist < dist[v]:\n          dist[v] = newDist\n          heapq.heappush(minHeap, (newDist, v))\n\n    return sum(d <= maxMoves for d in dist)\n", "tests": ["def test_reachableNodes():\n    solution = Solution()\n    edges = [[0, 1, 2], [1, 2, 1]]\n    maxMoves = 3\n    n = 3\n    assert solution.reachableNodes(edges, maxMoves, n) == 5", "def test_reachableNodes():\n    solution = Solution()\n    edges = []\n    maxMoves = 5\n    n = 1\n    assert solution.reachableNodes(edges, maxMoves, n) == 1", "def test_reachableNodes():\n    solution = Solution()\n    edges = [[0, 1, 3], [0, 2, 5], [1, 2, 2], [1, 3, 4], [2, 3, 1]]\n    maxMoves = 10\n    n = 4\n    assert solution.reachableNodes(edges, maxMoves, n) == 8", "```java\n@Test\npublic void testReachableNodesWithMaxMovesGreaterThanEdgeWeights() {\n    // Arrange\n    int n = 5;\n    List<List<int[]>> edges = Arrays.asList(\n        Arrays.asList(new int[]{0, 1, 2}), \n        Arrays.asList(new int[]{1, 2, 3}),\n        Arrays.asList(new int[]{2, 3, 4})\n    );\n    int maxMoves = 15;\n    Solution solution = new Solution();\n\n    // Act", "```java\n@Test\npublic void testReachableNodesWithZeroMaxMoves() {\n    // Arrange\n    int n = 5;\n    List<List<int[]>> edges = Arrays.asList(\n        Arrays.asList(new int[]{0, 1, 2}), \n        Arrays.asList(new int[]{1, 2, 3}),\n        Arrays.asList(new int[]{2, 3, 4})\n    );\n    int maxMoves = 0;\n    Solution solution = new Solution();\n\n    // Act", "```java\n@Test\npublic void testReachableNodesWithNegativeMaxMoves() {\n    // Arrange\n    int n = 5;\n    List<List<int[]>> edges = Arrays.asList(\n        Arrays.asList(new int[]{0, 1, 2}), \n        Arrays.asList(new int[]{1, 2, 3}),\n        Arrays.asList(new int[]{2, 3, 4})\n    );\n    int maxMoves = -5;\n    Solution solution = new Solution();\n\n    // Act", "```java\n@Test\npublic void testReachableNodesWithIsolatedNode() {\n    // Arrange\n    int n = 5;\n    List<List<int[]>> edges = Arrays.asList(\n        Arrays.asList(new int[]{0, 1, 2}), \n        Arrays.asList(new int[]{3, 4, 5}) // Isolated node with no edges connected to it.\n    );\n    int maxMoves = 10; // Sufficient moves to reach other nodes\n    Solution solution = new Solution();\n\n    // Act", "```java\n@Test\npublic void testReachableNodesWithSingleNodeGraph() {\n    // Arrange\n    int n = 1; // Graph with only one node\n    List<List<int[]>> edges = Arrays.asList();\n    int maxMoves = 5;\n    Solution solution = new Solution();\n\n    // Act", "```java\n@Test\npublic void testReachableNodesWithMultipleDisconnectedComponents() {\n    // Arrange\n    int n = 6;\n    List<List<int[]>> edges = Arrays.asList(\n        Arrays.asList(new int[]{0, 1, 2}), // Component 1 (nodes 0, 1, 2)\n        Arrays.asList(new int[]{3, 4, 5})  // Component 2 (nodes 3, 4, 5)\n    );\n    int maxMoves = 7; // Sufficient moves to reach any node in both components\n    Solution solution = new Solution();\n\n    // Act", "```java\n@Test\npublic void testReachableNodesWithMaxMovesLessThanMinPathLength() {\n    // Arrange\n    int n = 4;\n    List<List<int[]>> edges = Arrays.asList(\n        Arrays.asList(new int[]{0, 1, 2}), \n        Arrays.asList(new int[]{1, 3, 2})\n    );\n    int maxMoves = 1; // Not enough moves to reach any node other than the starting one\n    Solution solution = new Solution();\n\n    // Act", "```java\n@Test\npublic void testReachableNodesWithSelfLoop() {\n    // Arrange\n    int n = 3;\n    List<List<int[]>> edges = Arrays.asList(\n        Arrays.asList(new int[]{0, 1, 2}), \n        Arrays.asList(new int[]{1, 1, 1}) // Self-loop at node 1\n    );\n    int maxMoves = 5;\n    Solution solution = new Solution();\n\n    // Act", "```java\n@Test\npublic void testReachableNodesWithNegativeEdgeWeight() {\n    // Arrange\n    int n = 4;\n    List<List<int[]>> edges = Arrays.asList(\n        Arrays.asList(new int[]{0, 1, 2}), \n        Arrays.asList(new int[]{1, 2, -3}) // Negative edge weight creating a negative cycle\n    );\n    int maxMoves = 5;\n    Solution solution = new Solution();\n\n    // Act", "```java\n@Test\npublic void testReachableNodesWithHighlyConnectedGraph() {\n    // Arrange\n    int n = 7;\n    List<List<int[]>> edges = Arrays.asList(\n        Arrays.asList(new int[]{0, 1, 2}), \n        Arrays.asList(new int[]{1, 2, 3}),\n        Arrays.asList(new int[]{2, 3, 4}),\n        Arrays.asList(new int[]{3, 4, 5}),\n        Arrays.asList(new int[]{4, 5, 6})\n    );\n    int maxMoves = 3; // Not enough moves to reach all nodes\n    Solution solution = new Solution();\n\n    // Act", "```java\n@Test\npublic void testReachableNodesWithHighlyDenseGraph() {\n    // Arrange\n    int n = 6;\n    List<List<int[]>> edges = new ArrayList<>();\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            edges.add(Arrays.asList(new int[]{i, j, 1})); // Fully connected graph\n        }\n    }\n    int maxMoves = 3;\n    Solution solution = new Solution();\n\n    // Act", "```java\n@Test\npublic void testReachableNodesWithHighlySparseGraph() {\n    // Arrange\n    int n = 8;\n    List<List<int[]>> edges = Arrays.asList(\n        Arrays.asList(new int[]{0, 1, 2}), \n        Arrays.asList(new int[]{3, 4, 5}),\n        Arrays.asList(new int[]{6, 7, 8})\n    );\n    // The graph is sparse with only three small components\n    int maxMoves = 5;\n    Solution solution = new Solution();\n\n    // Act", "```java\n@Test\npublic void testReachableNodesWithLargeGraphAndLongPaths() {\n    // Arrange\n    int n = 10;\n    List<List<int[]>> edges = new ArrayList<>();\n    for (int i = 0; i < n - 1; i++) {\n        edges.add(Arrays.asList(new int[]{i, i + 1, 2})); // Long path from node 0 to node 9\n    }\n    int maxMoves = 7;\n    Solution solution = new Solution();\n\n    // Act", "```java\n@Test\npublic void testReachableNodesWithComplexGraph() {\n    // Arrange\n    int n = 5;\n    List<List<int[]>> edges = new ArrayList<>();\n    edges.add(Arrays.asList(new int[]{0, 1, 2})); // Path from 0 to 1 with weight 2\n    edges.add(Arrays.asList(new int[]{1, 2, 3})); // Path from 1 to 2 with weight 3\n    edges.add(Arrays.asList(new int[]{2, 3, 4})); // Path from 2 to 3 with weight 4\n    edges.add(Arrays.asList(new int[]{0, 3, 5})); // Shorter path directly from 0 to 3 with weight 5\n    edges.add(Arrays.asList(new int[]{4, 2, 1})); // Cycle involving nodes 4, 2, and 1\n\n    int maxMoves = 9;\n    Solution solution = new Solution();\n\n    // Act", "```java\n@Test\npublic void testReachableNodesWithSelfLoops() {\n    // Arrange\n    int n = 4;\n    List<List<int[]>> edges = new ArrayList<>();\n    edges.add(Arrays.asList(new int[]{0, 1, 2})); // Path from 0 to 1 with weight 2\n    edges.add(Arrays.asList(new int[]{1, 2, 3})); // Path from 1 to 2 with weight 3\n    edges.add(Arrays.asList(new int[]{2, 3, 4})); // Path from 2 to 3 with weight 4\n    edges.add(Arrays.asList(new int[]{0, 0, 5})); // Self-loop at node 0 with weight 5\n\n    int maxMoves = 10;\n    Solution solution = new Solution();\n\n    // Act", "```java\n@Test\npublic void testReachableNodesWithDisconnectedComponents() {\n    // Arrange\n    int n = 7;\n    List<List<int[]>> edges = new ArrayList<>();\n    \n    // Component 1: 0 -> 1 -> 2\n    edges.add(Arrays.asList(new int[]{0, 1, 1}));\n    edges.add(Arrays.asList(new int[]{1, 2, 1}));\n\n    // Component 2: 3 -> 4 -> 5\n    edges.add(Arrays.asList(new int[]{3, 4, 1}));\n    edges.add(Arrays.asList(new int[]{4, 5, 1}));\n\n    // Isolated node: 6\n    // No edges connected to node 6\n\n    int maxMoves = 2;\n    Solution solution = new Solution();\n\n    // Act", "```java\n@Test\npublic void testReachableNodesWithNegativeWeights() {\n    // Arrange\n    int n = 4;\n    List<List<int[]>> edges = new ArrayList<>();\n\n    // Path with negative weights to make traversal challenging\n    edges.add(Arrays.asList(new int[]{0, 1, -2}));\n    edges.add(Arrays.asList(new int[]{1, 2, -3}));\n    edges.add(Arrays.asList(new int[]{2, 3, -4}));\n\n    // Self-loop with a negative weight\n    edges.add(Arrays.asList(new int[]{0, 0, -5}));\n\n    int maxMoves = 3;\n    Solution solution = new Solution();\n\n    // Act"]}
{"task_num": 909, "task_title": "Snakes and Ladders", "func_name": "snakesAndLadders", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def snakesAndLadders(self, board: List[List[int]]) -> int:\n    n = len(board)\n    ans = 0\n    q = collections.deque([1])\n    seen = set()\n    A = [0] * (1 + n * n)\n\n    for i in range(n):\n      for j in range(n):\n        if n - i & 1 :\n          A[(n - 1 - i) * n + (j + 1)] = board[i][j]\n        else:\n          A[(n - 1 - i) * n + (n - j)] = board[i][j]\n\n    while q:\n      ans += 1\n      for _ in range(len(q)):\n        curr = q.popleft()\n        for next in range(curr + 1, min(curr + 6, n * n) + 1):\n          dest = A[next] if A[next] > 0 else next\n          if dest == n * n:\n            return ans\n          if dest in seen:\n            continue\n          q.append(dest)\n          seen.add(dest)\n\n    return -1\n", "tests": ["def test_snakesAndLadders():\n    solution = Solution()\n    board = [[-1, -1], [-1, 3]]\n    assert solution.snakesAndLadders(board) == 2", "def test_snakesAndLadders():\n    solution = Solution()\n    board = [[1, 3, -1], [-2, -1, 0]]\n    assert solution.snakesAndLadders(board) == 4", "def test_snakesAndLadders():\n    solution = Solution()\n    board = [[-1, -1, 3], [2, -1, -1]]\n    assert solution.snakesAndLadders(board) == 1", "def test_snakesAndLadders():\n    solution = Solution()\n    board = [[-1, -1, -1], [-1, 6, 0]]\n    assert solution.snakesAndLadders(board) == 2", "def test_snakesAndLadders():\n    solution = Solution()\n    board = [[-1, -1, -1], [-1, -1, -1]]\n    assert solution.snakesAndLadders(board) == -1", "def test_snakesAndLadders():\n    solution = Solution()\n    board = [[-1, -1, -1], [-1, -1, 2]]\n    assert solution.snakesAndLadders(board) == 1", "def test_snakesAndLadders():\n    solution = Solution()\n    board = [[-1, -1, -1], [3, -1, -1]]\n    assert solution.snakesAndLadders(board) == 2", "def test_snakesAndLadders():\n    solution = Solution()\n    board = [[-1, -1, -1], [-1, -1, -1]]\n    assert solution.snakesAndLadders(board) == -1", "def test_snakesAndLadders():\n    solution = Solution()\n    board = [[-1, 2, -1], [-1, -1, -1]]\n    assert solution.snakesAndLadders(board) == 1", "def test_snakesAndLadders():\n    solution = Solution()\n    board = [[-1, -1, 3], [-1, -1, -1]]\n    assert solution.snakesAndLadders(board) == 2", "def test_snakesAndLadders():\n    solution = Solution()\n    board = [[-1, -1, 2], [-1, 3, -1]]\n    assert solution.snakesAndLadders(board) == 1", "def test_snakesAndLadders():\n    solution = Solution()\n    board = [[-1, -1, 3], [2, -1, -1]]\n    assert solution.snakesAndLadders(board) == 2", "def test_snakesAndLadders():\n    solution = Solution()\n    board = [[-1, -1, 3], [-1, -1, 2]]\n    assert solution.snakesAndLadders(board) == 1", "def test_snakesAndLadders():\n    solution = Solution()\n    board = [[-1, -1, -1], [2, 3, -1]]\n    assert solution.snakesAndLadders(board) == 2", "def test_snakesAndLadders():\n    solution = Solution()\n    board = [[-1, -1, -1], [-1, 3, 2]]\n    assert solution.snakesAndLadders(board) == 1", "def test_snakesAndLadders():\n    solution = Solution()\n    board = [[-1, -1, 3], [-1, -1, -1]]\n    assert solution.snakesAndLadders(board) == 2", "def test_snakesAndLadders():\n    solution = Solution()\n    board = [[-1, -1, 3], [-1, -1, -1]]\n    assert solution.snakesAndLadders(board) == 2", "def test_snakesAndLadders():\n    solution = Solution()\n    board = [[-1, -1, 3], [-1, -1, -1]]\n    assert solution.snakesAndLadders(board) == 2", "def test_snakesAndLadders():\n    solution = Solution()\n    board = [[-1, -1, 3], [-1, -1, -1]]\n    assert solution.snakesAndLadders(board) == 2", "def test_snakesAndLadders():\n    solution = Solution()\n    board = [[-1, -1, 3], [-1, -1, 2]]\n    assert solution.snakesAndLadders(board) == 1"]}
{"task_num": 913, "task_title": "Cat and Mouse", "func_name": "catMouseGame", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import IntEnum\n\n\nclass State(IntEnum):\n  kDraw = 0\n  kMouseWin = 1\n  kCatWin = 2\n\n\nclass Solution:\n  def catMouseGame(self, graph: List[List[int]]) -> int:\n    n = len(graph)\n    states = [[[0] * 2 for i in range(n)] for j in range(n)]\n    outDegree = [[[0] * 2 for i in range(n)] for j in range(n)]\n    q = collections.deque()\n\n    for cat in range(n):\n      for mouse in range(n):\n        outDegree[cat][mouse][0] = len(graph[mouse])\n        outDegree[cat][mouse][1] = len(graph[cat]) - graph[cat].count(0)\n\n    for cat in range(1, n):\n      for move in range(2):\n        states[cat][0][move] = int(State.kMouseWin)\n        q.append((cat, 0, move, int(State.kMouseWin)))\n        states[cat][cat][move] = int(State.kCatWin)\n        q.append((cat, cat, move, int(State.kCatWin)))\n\n    while q:\n      cat, mouse, move, state = q.popleft()\n      if cat == 2 and mouse == 1 and move == 0:\n        return state\n      prevMove = move ^ 1\n      for prev in graph[cat if prevMove else mouse]:\n        prevCat = prev if prevMove else cat\n        if prevCat == 0:\n          continue\n        prevMouse = mouse if prevMove else prev\n        if states[prevCat][prevMouse][prevMove]:\n          continue\n        if prevMove == 0 and state == int(State.kMouseWin) or \\\n                prevMove == 1 and state == int(State.kCatWin):\n          states[prevCat][prevMouse][prevMove] = state\n          q.append((prevCat, prevMouse, prevMove, state))\n        else:\n          outDegree[prevCat][prevMouse][prevMove] -= 1\n          if outDegree[prevCat][prevMouse][prevMove] == 0:\n            states[prevCat][prevMouse][prevMove] = state\n            q.append((prevCat, prevMouse, prevMove, state))\n\n    return states[2][1][0]\n", "tests": ["def test_catMouseGame():\n    solution = Solution()\n    graph = [[2, 5], [3], [0, 4, 5], [1, 4, 5], [3, 4], [0, 2, 3]]\n    assert solution.catMouseGame(graph) == 0", "def test_catMouseGame():\n    solution = Solution()\n    graph = [[2], [3], [0, 4], [1, 4], [2, 3]]\n    assert solution.catMouseGame(graph) == 0", "def test_catMouseGame():\n    solution = Solution()\n    graph = [[2], [3, 4], [0, 5], [1], [1, 5], [2, 3]]\n    assert solution.catMouseGame(graph) == 1", "def test_catMouseGame():\n    solution = Solution()\n    graph = [[2], [3, 4], [0], [1, 5], [1, 5], [2, 3]]\n    assert solution.catMouseGame(graph) == 2", "def test_catMouseGame():\n    solution = Solution()\n    graph = [[1], [0, 2], [1, 3, 4], [2], [2]]\n    assert solution.catMouseGame(graph) == 2", "def test_catMouseGame():\n    solution = Solution()\n    graph = [[1], [0], [3], [2]]\n    assert solution.catMouseGame(graph) == 1", "def test_catMouseGame():\n    solution = Solution()\n    n = 20\n    graph = [[] for _ in range(n)]\n    for i in range(1, n):\n        graph[0].append(i)\n        graph[i].append(0)\n    assert solution.catMouseGame(graph) == 0", "def test_catMouseGame():\n    solution = Solution()\n    graph = [[2], [3, 4], [0, 5], [1, 6, 7], [1, 8, 9], [2], [3], [3], [4], [4]]\n    assert solution.catMouseGame(graph) == 0", "def test_catMouseGame():\n    solution = Solution()\n    graph = [[]]\n    assert solution.catMouseGame(graph) == 0", "def test_catMouseGame():\n    solution = Solution()\n    graph = [[1], [0, 2, 4], [1, 3], [2], [1]]\n    assert solution.catMouseGame(graph) == 0", "def test_catMouseGame():\n    solution = Solution()\n    graph = [[1], [0]]\n    assert solution.catMouseGame(graph) == 0", "def test_catMouseGame():\n    solution = Solution()\n    graph = [[1], [0, 2, 3], [1], [1]]\n    assert solution.catMouseGame(graph) == 0", "def test_catMouseGame():\n    solution = Solution()\n    graph = [[1], [0, 2, 4], [1, 3], [2, 5], [1, 7], [2], [4]]\n    assert solution.catMouseGame(graph) == 0", "def test_catMouseGame():\n    solution = Solution()\n    graph = [[1], [0, 2, 4], [1, 3], [2, 5], [1, 7], [2], [4]]\n    assert solution.catMouseGame(graph) == 0", "def test_catMouseGame():\n    solution = Solution()\n    n = 100\n    graph = [[] for _ in range(n)]\n    for i in range(1, n):\n        graph[0].append(i)\n        graph[i].append(0)\n    assert solution.catMouseGame(graph) == 0", "def test_catMouseGame():\n    solution = Solution()\n    graph = [[1], [0, 2, 3], [1, 4, 5], [2, 6, 7], [3, 8, 9], [4, 10, 11], [5, 12, 13], [6, 14, 15], [7, 16, 17], [8, 18, 19], [9, 20, 21], [10, 22, 23], [11, 24, 25], [12, 26, 27], [13, 28, 29], [14, 30, 31], [15, 32, 33], [16, 34, 35], [17, 36, 37], [18, 38, 39], [19, 40, 41], [20, 42, 43], [21, 44, 45], [22, 46, 47], [23, 48, 49], [24, 50, 51], [25, 52, 53], [26, 54, 55], [27, 56, 57], [28, 58, 59], [29, 60, 61], [30, 62, 63], [31, 64, 65], [32, 66, 67], [33, 68, 69], [34, 70, 71], [35, 72, 73], [36, 74, 75], [37, 76, 77], [38, 78, 79], [39, 80, 81], [40, 82, 83], [41, 84, 85], [42, 86, 87], [43, 88, 89], [44, 90, 91], [45, 92, 93], [46, 94, 95], [47, 96, 97], [48, 98, 99], [49]]\n    assert solution.catMouseGame(graph) == 0", "def test_catMouseGame():\n    solution = Solution()\n    graph = [[1], [0, 2, 3], [1, 4, 5], [2, 6, 7], [3, 8, 9], [4, 10, 11], [5, 12, 13], [6, 14, 15], [7, 16, 17], [8, 18, 19], [9, 20, 21], [10, 22, 23], [11, 24, 25], [12, 26, 27], [13, 28, 29], [14, 30, 31], [15, 32, 33], [16, 34, 35], [17, 36, 37], [18, 38, 39], [19, 40, 41], [20, 42, 43], [21, 44, 45], [22, 46, 47], [23, 48, 49], [24, 50, 51], [25, 52, 53], [26, 54, 55], [27, 56, 57], [28, 58, 59], [29, 60, 61], [30, 62, 63], [31, 64, 65], [32, 66, 67], [33, 68, 69], [34, 70, 71], [35, 72, 73], [36, 74, 75], [37, 76, 77], [38, 78, 79], [39, 80, 81], [40, 82, 83], [41, 84, 85], [42, 86, 87], [43, 88, 89], [44, 90, 91], [45, 92, 93], [46, 94, 95], [47, 96, 97], [48, 98, 99], [49]]\n    assert solution.catMouseGame(graph) == 0", "def test_catMouseGame():\n    solution = Solution()\n    graph = [[1], [0, 2, 3], [1, 4, 5], [2, 6, 7], [3, 8, 9], [4, 10, 11], [5, 12, 13], [6, 14, 15], [7, 16, 17], [8, 18, 19], [9, 20, 21], [10, 22, 23], [11, 24, 25], [12, 26, 27], [13, 28, 29], [14, 30, 31], [15, 32, 33], [16, 34, 35], [17, 36, 37], [18, 38, 39], [19, 40, 41], [20, 42, 43], [21, 44, 45], [22, 46, 47], [23, 48, 49], [24, 50, 51], [25, 52, 53], [26, 54, 55], [27, 56, 57], [28, 58, 59], [29, 60, 61], [30, 62, 63], [31, 64, 65], [32, 66, 67], [33, 68, 69], [34, 70, 71], [35, 72, 73], [36, 74, 75], [37, 76, 77], [38, 78, 79], [39, 80, 81], [40, 82, 83], [41, 84, 85], [42, 86, 87], [43, 88, 89], [44, 90, 91], [45, 92, 93], [46, 94, 95], [47, 96, 97], [48, 98, 99], [49]]\n    assert solution.catMouseGame(graph) == 0", "def test_catMouseGame(self):\n    graph = {}\n    solution = Solution(graph)\n    result = solution.catMouseGame()", "def test_catMouseGame(self):\n    result = self.solution.catMouseGame()"]}
{"task_num": 923, "task_title": "3Sum With Multiplicity", "func_name": "threeSumMulti", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def threeSumMulti(self, arr: List[int], target: int) -> int:\n    kMod = 1_000_000_007\n    ans = 0\n    count = collections.Counter(arr)\n\n    for i, x in count.items():\n      for j, y in count.items():\n        k = target - i - j\n        if k not in count:\n          continue\n        if i == j and j == k:\n          ans = (ans + x * (x - 1) * (x - 2) // 6) % kMod\n        elif i == j and j != k:\n          ans = (ans + x * (x - 1) // 2 * count[k]) % kMod\n        elif i < j and j < k:\n          ans = (ans + x * y * count[k]) % kMod\n\n    return ans % kMod\n", "tests": ["def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([1, 1, 2, 2, 3, 3], 6) == 8", "def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([-1, -1, 2, 2, 3, 3], 0) == 6", "def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([], 0) == 0", "def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([1, 2, 3, 4, 5, 6], 9) == 2", "def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([0, 0, 0], 0) == 1", "def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([3, 1, 2], 6) == 0", "def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([500] * 1000, 1500) == 498501", "def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([10 ** 8, 10 ** 8, 10 ** 8, 10 ** 8], 3 * 10 ** 8) == 4", "def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([-1, 2, 3], 0) == 1", "def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti(list(range(1000)), 498501) == 498501", "def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([-10 ** 9, 10 ** 8], -1) == 0", "def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([2 * 10 ** 9] * 3, 6 * 10 ** 9) == 1", "def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([-2] * 3, -6) == 1", "def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([2 * 10 ** 9] * 3, 6 * 10 ** 9) == 1", "def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([-2, 2, -1, 1], 0) == 4", "def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([10 ** 9, -10 ** 9], 5) == 0", "def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([-10 ** 9, 10 ** 8], -1) == 0", "def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([-2, 2, -1, 1, 0], 0) == 6", "def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([-10 ** 9, 10 ** 8], -1) == 0", "def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([10 ** 9, -10 ** 9], 5) == 0"]}
{"task_num": 927, "task_title": "Three Equal Parts", "func_name": "threeEqualParts", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def threeEqualParts(self, arr: List[int]) -> List[int]:\n    ones = sum(a == 1 for a in arr)\n\n    if ones == 0:\n      return [0, len(arr) - 1]\n    if ones % 3 != 0:\n      return [-1, -1]\n\n    k = ones // 3\n    i = 0\n\n    for i in range(len(arr)):\n      if arr[i] == 1:\n        first = i\n        break\n\n    gapOnes = k\n\n    for j in range(i + 1, len(arr)):\n      if arr[j] == 1:\n        gapOnes -= 1\n        if gapOnes == 0:\n          second = j\n          break\n\n    gapOnes = k\n\n    for i in range(j + 1, len(arr)):\n      if arr[i] == 1:\n        gapOnes -= 1\n        if gapOnes == 0:\n          third = i\n          break\n\n    while third < len(arr) and arr[first] == arr[second] == arr[third]:\n      first += 1\n      second += 1\n      third += 1\n\n    if third == len(arr):\n      return [first - 1, second]\n    return [-1, -1]\n", "tests": ["def test_threeEqualParts():\n    solution = Solution()\n    result = solution.threeEqualParts([0, 0, 0])", "def test_threeEqualParts():\n    solution = Solution()\n    result = solution.threeEqualParts([1, 0, 1, 0, 1])", "def test_threeEqualParts():\n    solution = Solution()\n    result = solution.threeEqualParts([0, 1, 0, 0])", "def test_threeEqualParts():\n    solution = Solution()\n    result = solution.threeEqualParts([0, 1, 1, 0, 1, 1, 0])", "def test_threeEqualParts():\n    solution = Solution()\n    result = solution.threeEqualParts([1] * 100)", "def test_threeEqualParts():\n    solution = Solution()\n    result = solution.threeEqualParts([1] * 200)", "def test_threeEqualParts():\n    solution = Solution()\n    result = solution.threeEqualParts([0])", "def test_threeEqualParts():\n    solution = Solution()\n    result = solution.threeEqualParts([1, 0, 1, 0, 1, 1, 1])", "def test_threeEqualParts():\n    solution = Solution()\n    result = solution.threeEqualParts([1, 0, 0, 1, 0, 0, 1])", "def test_threeEqualParts():\n    solution = Solution()\n    result = solution.threeEqualParts([0] * 5)", "def test_threeEqualParts():\n    solution = Solution()\n    result = solution.threeEqualParts([1, 0, 1, 0, 1, 0])", "def test_threeEqualParts():\n    solution = Solution()\n    result = solution.threeEqualParts([1])", "def test_threeEqualParts():\n    sequence = [0] * 100 + [1] + [0] * 100\n    solution = Solution()\n    result = solution.threeEqualParts(sequence)", "def test_threeEqualParts():\n    sequence = [0]\n    solution = Solution()\n    result = solution.threeEqualParts(sequence)", "def test_threeEqualParts():\n    sequence = [0] * 100\n    solution = Solution()\n    result = solution.threeEqualParts(sequence)", "def test_threeEqualParts():\n    sequence = [1]\n    solution = Solution()\n    result = solution.threeEqualParts(sequence)", "def test_threeEqualParts():\n    sequence = [0]\n    solution = Solution()\n    result = solution.threeEqualParts(sequence)", "def test_threeEqualParts():\n    sequence = [0, 1] * 50\n    solution = Solution()\n    result = solution.threeEqualParts(sequence)", "def test_threeEqualParts():\n    sequence = [0, 1, 2, 3] * 25\n    solution = Solution()\n    result = solution.threeEqualParts(sequence)", "def test_threeEqualParts():\n    sequence = [0] * 30 + [1] * 30 + [2] * 30 + [3] * 30\n    solution = Solution()\n    result = solution.threeEqualParts(sequence)"]}
{"task_num": 935, "task_title": "Knight Dialer", "func_name": "knightDialer", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def knightDialer(self, n: int) -> int:\n    dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n    kMod = 1_000_000_007\n\n    dp = [[1] * 3 for _ in range(4)]\n    dp[3][0] = dp[3][2] = 0\n\n    for _ in range(n - 1):\n      newDp = [[0] * 3 for _ in range(4)]\n      for i in range(4):\n        for j in range(3):\n          if (i, j) in ((3, 0), (3, 2)):\n            continue\n          for dx, dy in dirs:\n            x = i + dx\n            y = j + dy\n            if x < 0 or x >= 4 or y < 0 or y >= 3:\n              continue\n            if (x, y) in ((3, 0), (3, 2)):\n              continue\n            newDp[x][y] = (newDp[x][y] + dp[i][j]) % kMod\n      dp = newDp\n\n    return sum(map(sum, dp)) % kMod\n", "tests": ["def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(1) == 10", "def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(0) == 1", "def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(20) == 457517369", "def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(30) == 921495876", "def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(1) == 10", "def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(1) == 10", "def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(-1) == 0", "def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(1) == 10", "def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(0) == 1", "def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(31) == 207516498", "def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(1) == 10", "def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(1) == 10", "def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(2) == 20", "def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(4) == 120", "def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(1) == 10", "def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(1) == 10", "def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(0) == 1", "def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(20) == 457517369", "def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(30) == 921495876", "def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(40) == 319802110"]}
{"task_num": 939, "task_title": "Minimum Area Rectangle", "func_name": "minAreaRect", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minAreaRect(self, points: List[List[int]]) -> int:\n    ans = math.inf\n    xToYs = collections.defaultdict(set)\n\n    for x, y in points:\n      xToYs[x].add(y)\n\n    for i in range(len(points)):\n      for j in range(i):\n        x1, y1 = points[i]\n        x2, y2 = points[j]\n        if x1 == x2 or y1 == y2:\n          continue\n        if y2 in xToYs[x1] and y1 in xToYs[x2]:\n          ans = min(ans, abs(x1 - x2) * abs(y1 - y2))\n\n    return ans if ans < math.inf else 0\n", "tests": ["def test_minAreaRect():\n    solution = Solution()\n    assert solution.minAreaRect([[1, 1], [1, 3], [3, 1], [3, 3], [2, 2]]) == 4", "def test_minAreaRect():\n    solution = Solution()\n    assert solution.minAreaRect([[1, 1], [2, 2], [3, 3]]) == 0", "def test_minAreaRect():\n    solution = Solution()\n    points = [[i, i] for i in range(1000)]\n    assert solution.minAreaRect(points) == 0", "def test_minAreaRect():\n    solution = Solution()\n    assert solution.minAreaRect([[-1, -1], [-1, 1], [1, -1], [1, 1]]) == 4", "def test_minAreaRect():\n    solution = Solution()\n    points = [[i % 10, i // 10] for i in range(100)]\n    assert solution.minAreaRect(points) != 0", "def test_minAreaRect():\n    solution = Solution()\n    assert solution.minAreaRect([[0, 0], [3, 0], [0, 5], [3, 5], [1, 2], [4, 2], [1, 7], [4, 7]]) == 9", "def test_minAreaRect():\n    solution = Solution()\n    assert solution.minAreaRect([[0, 0], [2, 0], [1, 2], [3, 2]]) == 4", "def test_minAreaRect():\n    solution = Solution()\n    assert solution.minAreaRect([[0, 0], [2, 0], [1, 1], [3, 1], [4, 2]]) == 6", "def test_minAreaRect():\n    solution = Solution()\n    assert solution.minAreaRect([[-2, -1], [-1, -2], [0, -1], [1, 0]]) == 4", "def test_minAreaRect():\n    solution = Solution()\n    assert solution.minAreaRect([[1000, 1000], [2000, 1000], [1000, 2000], [2000, 2000], [1500, 1500]]) == 4000000", "def test_minAreaRect():\n    solution = Solution()\n    assert solution.minAreaRect([[1, 1], [3, 1], [2, 2]]) == 4", "def test_minAreaRect():\n    solution = Solution()\n    assert solution.minAreaRect([[-2, -1], [-1, -2], [0, -1], [1, 0]]) == 4", "def test_minAreaRect():\n    solution = Solution()\n    assert solution.minAreaRect([[-1000, -1000], [-2000, -1000], [-1000, -2000], [-2000, -2000], [500, 500]]) == 4000000", "def test_minAreaRect():\n    solution = Solution()\n    assert solution.minAreaRect([[1, 1], [3, 1], [2, 2], [4, 2]]) == 6", "def test_minAreaRect():\n    solution = Solution()\n    assert solution.minAreaRect([[1, 2], [3, 2]]) == 0", "def test_minAreaRect():\n    solution = Solution()\n    assert solution.minAreaRect([[1, 2], [1, 4]]) == 0", "def test_minAreaRect():\n    solution = Solution()\n    assert solution.minAreaRect([[1, 2]]) == 0", "def test_minAreaRect():\n    solution = Solution()\n    assert solution.minAreaRect([[1, 2], [1, 2], [3, 4], [5, 6]]) == 0", "def test_minAreaRect():\n    solution = Solution()\n    assert solution.minAreaRect([[1, 2], [3, 4], [5, 6]]) == 0", "def test_minAreaRect():\n    solution = Solution()\n    assert solution.minAreaRect([[1, 2], [3, 4]]) == 0"]}
{"task_num": 952, "task_title": "Largest Component Size by Common Factor", "func_name": "largestComponentSize", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def largestComponentSize(self, nums: List[int]) -> int:\n    ans = 0\n    uf = UnionFind(max(nums) + 1)\n    count = collections.Counter()\n\n    for num in nums:\n      for x in range(2, int(math.sqrt(num) + 1)):\n        if num % x == 0:\n          uf.unionByRank(num, x)\n          uf.unionByRank(num, num // x)\n\n    for num in nums:\n      numRoot = uf.find(num)\n      count[numRoot] += 1\n      ans = max(ans, count[numRoot])\n\n    return ans\n", "tests": ["def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([4, 6, 18]) == 3", "def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([29]) == 1", "def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([-2, -3, 4, 6]) == 2", "def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([2, 3, 5, 7, 10, 14]) == 4", "def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([1000000]) == 1", "def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([4, 9, 15, 25]) == 3", "def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([10, 25, 40, 55]) == 6", "def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([6, 10, 15, 20]) == 6", "def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([6, 10, 15, 24]) == 9", "def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([6, 12, 18]) == 9", "def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([987654321]) == 1", "def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([6, 10, 14, 25]) == 9", "def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([6, 10, 12, 500000007]) == 18", "def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([6, 10, 15, 24, 30]) == 18", "def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([987654321, 2, 3, 5]) == 1", "def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([1000000007, 2000000009, 3000000011]) == 1", "def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([6, 10, 12, 3]) == 9", "def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([1000000007, 2000000009, 3000000011, 6, 8, 10]) == 45", "def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([1000000007, 2000000009, 3000000011, 6, 8, 10, 2, 3, 5]) == 54", "def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([1000000007, 2000000009, 3000000011, 6, 8, 10, 2, 3, 5, 1]) == 54"]}
{"task_num": 963, "task_title": "Minimum Area Rectangle II", "func_name": "minAreaFreeRect", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\nfrom math import sqrt\n\nclass Solution:\n  def minAreaFreeRect(self, points: List[List[int]]) -> float:\n    ans = math.inf\n    centerToPoints = collections.defaultdict(list)\n\n    for ax, ay in points:\n      for bx, by in points:\n        center = ((ax + bx) / 2, (ay + by) / 2)\n        centerToPoints[center].append((ax, ay, bx, by))\n\n    def dist(px: int, py: int, qx: int, qy: int) -> float:\n      return (px - qx)**2 + (py - qy)**2\n\n    for points in centerToPoints.values():\n      for ax, ay, _, _ in points:\n        for cx, cy, dx, dy in points:\n          if (cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0:\n            squaredArea = dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy)\n            if squaredArea > 0:\n              ans = min(ans, squaredArea)\n\n    return 0 if ans == math.inf else sqrt(ans)\n", "tests": ["def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[1, 2], [3, 4], [5, 6], [7, 8]]\n    assert abs(solution.minAreaFreeRect(points) - 0) < 1e-05", "def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[0, 0], [1, 1], [2, 2], [3, 3]]\n    assert abs(solution.minAreaFreeRect(points) - 8) < 1e-05", "def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[0, 0], [1, 2], [2, 4], [4, 8]]\n    assert abs(solution.minAreaFreeRect(points) - 32) < 1e-05", "def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[0, 0], [1, 0], [0, 1], [-1, 0], [0, -1]]\n    assert abs(solution.minAreaFreeRect(points) - 2) < 1e-05", "def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[0, 0], [2, 1], [-1, -1], [3, 4]]\n    assert abs(solution.minAreaFreeRect(points) - 5) < 1e-05", "def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[0, 0], [1, 1], [2, 3], [4, 5]]\n    assert abs(solution.minAreaFreeRect(points) - 8) < 1e-05", "def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[0, 0], [2, 2], [-2, -2]]\n    assert abs(solution.minAreaFreeRect(points) - 16) < 1e-05", "def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[0, 0], [1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]\n    assert abs(solution.minAreaFreeRect(points) - 8) < 1e-05", "def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[0, 0], [1, 0], [0, 1], [-1, -1]]\n    assert abs(solution.minAreaFreeRect(points) - 2) < 1e-05", "def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[0, 0], [2, 1], [-1, -1]]\n    assert abs(solution.minAreaFreeRect(points) - 5) < 1e-05", "def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[0, 0], [1, 2], [2, 4], [4, 8]]\n    assert abs(solution.minAreaFreeRect(points) - 32) < 1e-05", "def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[0, 0], [1, 1], [2, 2], [3, 3]]\n    assert abs(solution.minAreaFreeRect(points) - 8) < 1e-05", "def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[0, 0], [1, -1], [-1, 1]]\n    assert abs(solution.minAreaFreeRect(points) - 2) < 1e-05", "def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[0, 0], [1, 0], [0, 1]]\n    assert abs(solution.minAreaFreeRect(points) - 2) < 1e-05", "def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[0, 0], [2, 1], [-1, -1]]\n    assert abs(solution.minAreaFreeRect(points) - 5) < 1e-05", "def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[0, 0], [1, 2], [3, 4], [5, 6], [7, 8]]\n    assert abs(solution.minAreaFreeRect(points) - 8) < 1e-05", "def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[0, 0], [1, 2], [-2, -4]]\n    assert abs(solution.minAreaFreeRect(points) - 8) < 1e-05", "def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[0, 0], [2, 1], [-1, -1]]\n    assert abs(solution.minAreaFreeRect(points) - 5) < 1e-05", "def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[0, 0], [2, -1], [-1, 2]]\n    assert abs(solution.minAreaFreeRect(points) - 5) < 1e-05", "def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[0, 0], [2, 1], [-1, -1]]\n    assert abs(solution.minAreaFreeRect(points) - 5) < 1e-05"]}
{"task_num": 990, "task_title": "Satisfiability of Equality Equations", "func_name": "equationsPossible", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n\n  def union(self, u: int, v: int) -> None:\n    self.id[self.find(u)] = self.find(v)\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def equationsPossible(self, equations: List[str]) -> bool:\n    uf = UnionFind(26)\n\n    for x, op, _, y in equations:\n      if op == '=':\n        uf.union(ord(x) - ord('a'), ord(y) - ord('a'))\n\n    for x, op, _, y in equations:\n      if op == '!':\n        if uf.find(ord(x) - ord('a')) == uf.find(ord(y) - ord('a')):\n          return False\n    return True\n", "tests": ["def test_equationsPossible():\n    solution = Solution()\n    assert solution.equationsPossible(['a==b', 'b!=c', 'a!=c']) == False", "def test_equationsPossible():\n    solution = Solution()\n    assert solution.equationsPossible(['a==b', 'b==c', 'a!=c']) == False", "def test_equationsPossible():\n    solution = Solution()\n    assert solution.equationsPossible(['a==b', 'c==d', 'e!=f', 'g==h']) == True", "def test_equationsPossible():\n    solution = Solution()\n    assert solution.equationsPossible(['a==b', 'b==c', 'c==d', 'd==e', 'f!=g']) == True", "def test_equationsPossible():\n    solution = Solution()\n    assert solution.equationsPossible(['a==b', 'c!=d', 'e==f', 'g==h', 'i!=j', 'k==l']) == True", "def test_equationsPossible():\n    solution = Solution()\n    assert solution.equationsPossible(['a==b', 'b==c', 'c!=d', 'd!=e', 'f==g', 'g!=h']) == False", "def test_equationsPossible():\n    solution = Solution()\n    assert solution.equationsPossible(['a!=b', 'b!=c', 'c!=d', 'd!=e']) == True", "def test_equationsPossible():\n    solution = Solution()\n    assert solution.equationsPossible(['a==b', 'c==d', 'e==f', 'g==h', 'i==j', 'k==l', 'm!=n']) == True", "def test_equationsPossible():\n    solution = Solution()\n    assert solution.equationsPossible(['a==b', 'b!=c', 'c!=d', 'd!=e', 'f!=g', 'g!=h', 'i==j', 'k!=l']) == True", "def test_equationsPossible():\n    solution = Solution()\n    assert solution.equationsPossible(['a==b', 'c==d', 'e!=f', 'g==h', 'i!=j', 'k==l', 'm==n', 'o!=p']) == True", "def test_equationsPossible():\n    solution = Solution()\n    assert solution.equationsPossible(['a==b', 'c==d', 'e==f', 'g==h', 'i==j', 'k==l', 'm!=n', 'o==p', 'q!=r']) == True", "def test_equationsPossible():\n    solution = Solution()\n    assert solution.equationsPossible(['a==b', 'c==d', 'e==f', 'g==h', 'i==j', 'k==l', 'm!=n', 'o==p', 'q!=r', 's==t']) == True", "def test_equationsPossible():\n    solution = Solution()\n    assert solution.equationsPossible(['a==b', 'c==d', 'e==f', 'g==h', 'i==j', 'k==l', 'm!=n', 'o==p', 'q!=r', 's==t', 'u!=v']) == True", "def test_equationsPossible():\n    solution = Solution()\n    assert solution.equationsPossible(['a==b', 'c==d', 'e==f', 'g==h', 'i==j', 'k==l', 'm!=n', 'o==p', 'q!=r', 's==t', 'u!=v', 'w==x']) == True", "def test_equationsPossible():\n    solution = Solution()\n    assert solution.equationsPossible(['a==b', 'c==d', 'e==f', 'g==h', 'i==j', 'k==l', 'm!=n', 'o==p', 'q!=r', 's==t', 'u!=v', 'w==x', 'y!=z']) == True", "def test_equationsPossible():\n    solution = Solution()\n    assert solution.equationsPossible(['a==b', 'c==d', 'e!=f', 'g==h', 'i!=j', 'k==l', 'm!=n', 'o==p', 'q!=r', 's==t', 'u!=v', 'w==x', 'y!=z', 'aa==bb']) == True", "def test_equationsPossible():\n    solution = Solution()\n    assert solution.equationsPossible(['a==b', 'c==d', 'e!=f', 'g==h', 'i!=j', 'k==l', 'm!=n', 'o==p', 'q!=r', 's==t', 'u!=v', 'w==x', 'y!=z', 'aa==bb', 'cc==dd']) == True", "def test_equationsPossible():\n    solution = Solution()\n    assert solution.equationsPossible(['a==b', 'c==d', 'e!=f', 'g==h', 'i!=j', 'k==l', 'm!=n', 'o==p', 'q!=r', 's==t', 'u!=v', 'w==x', 'y!=z', 'aa==bb', 'cc==dd', 'ee==ff']) == True", "def test_equationsPossible():\n    solution = Solution()\n    assert solution.equationsPossible(['a==b', 'c==d', 'e!=f', 'g==h', 'i!=j', 'k==l', 'm!=n', 'o==p', 'q!=r', 's==t', 'u!=v', 'w==x', 'y!=z', 'aa==bb', 'cc==dd', 'ee==ff', 'gg==hh']) == True", "def test_equationsPossible():\n    solution = Solution()\n    assert solution.equationsPossible(['a==b', 'c==d', 'e!=f', 'g==h', 'i!=j', 'k==l', 'm!=n', 'o==p', 'q!=r', 's==t', 'u!=v', 'w==x', 'y!=z', 'aa==bb', 'cc==dd', 'ee==ff', 'gg==hh', 'ii==jj']) == True"]}
{"task_num": 999, "task_title": "Available Captures for Rook", "func_name": "numRookCaptures", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numRookCaptures(self, board: List[List[str]]) -> int:\n    ans = 0\n\n    for i in range(8):\n      for j in range(8):\n        if board[i][j] == 'R':\n          i0 = i\n          j0 = j\n\n    for d in [[1, 0], [0, 1], [-1, 0], [0, -1]]:\n      i = i0 + d[0]\n      j = j0 + d[1]\n      while 0 <= i < 8 and 0 <= j < 8:\n        if board[i][j] == 'p':\n          ans += 1\n        if board[i][j] != '.':\n          break\n        i += d[0]\n        j += d[1]\n\n    return ans\n", "tests": ["def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', 'p', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['R', '.', '.', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 1", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', 'R', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 1", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', 'p'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', 'R', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 1", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', 'p'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', 'R', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', '.', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 2", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', '.', '.', 'p', '.', '.', '.', '.'], ['.', '.', '.', 'R', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 1", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', '.', 'R', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', 'p']]\n    assert solution.numRookCaptures(board) == 2", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', '.', '.', '.', '.', '.', '.', '.'], ['p', 'p', 'p', 'R', 'p', 'p', 'p', 'p'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 4", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', 'p', 'R', 'p', '.', 'p', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 2", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', 'p', '.', 'p', 'p', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', 'R', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 2", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', 'p', '.', '.', '.'], ['.', '.', '.', 'R', '.', '.', '.', 'p'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 2", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', 'p', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', 'R', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', 'p', '.', '.']]\n    assert solution.numRookCaptures(board) == 2", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', 'p', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', 'R', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', '.', '.', '.', '.', '.', 'p']]\n    assert solution.numRookCaptures(board) == 3", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', 'p', '.', 'p', '.', 'p', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', 'R', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', 'p', '.', 'p']]\n    assert solution.numRookCaptures(board) == 3", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', 'p', '.', 'p', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', 'R', '.', '.', '.', 'p'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 2", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', '.', '.', '.', '.', '.', 'p'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', 'R', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 2", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', 'p', '.', '.', '.', '.'], ['.', '.', '.', 'R', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', '.', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 2", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', 'p', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', 'R', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', '.', '.', '.', '.', '.', 'p']]\n    assert solution.numRookCaptures(board) == 3", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', 'p', '.', 'p', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', 'R', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', '.', '.', '.', '.', '.', 'p']]\n    assert solution.numRookCaptures(board) == 3", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', 'p', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', 'R', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', '.', '.', '.', '.', '.', 'p']]\n    assert solution.numRookCaptures(board) == 3", "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', 'p', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', 'R', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['p', '.', '.', '.', '.', '.', '.', 'p']]\n    assert solution.numRookCaptures(board) == 3"]}
{"task_num": 1001, "task_title": "Grid Illumination", "func_name": "gridIllumination", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def gridIllumination(self, n: int, lamps: List[List[int]], queries: List[List[int]]) -> List[int]:\n    ans = []\n    rows = collections.Counter()\n    cols = collections.Counter()\n    diag1 = collections.Counter()\n    diag2 = collections.Counter()\n    lampsSet = set()\n\n    for i, j in lamps:\n      if (i, j) not in lampsSet:\n        lampsSet.add((i, j))\n        rows[i] += 1\n        cols[j] += 1\n        diag1[i + j] += 1\n        diag2[i - j] += 1\n\n    for i, j in queries:\n      if rows[i] or cols[j] or diag1[i + j] or diag2[i - j]:\n        ans.append(1)\n        for y in range(max(0, i - 1), min(n, i + 2)):\n          for x in range(max(0, j - 1), min(n, j + 2)):\n            if (y, x) in lampsSet:\n              lampsSet.remove((y, x))\n              rows[y] -= 1\n              cols[x] -= 1\n              diag1[y + x] -= 1\n              diag2[y - x] -= 1\n      else:\n        ans.append(0)\n\n    return ans\n", "tests": ["def test_gridIllumination():\n    solution = Solution()\n    assert solution.gridIllumination(5, [[0, 0], [4, 4]], [[1, 1], [1, 0]]) == [1, 0]", "def test_gridIllumination():\n    solution = Solution()\n    assert solution.gridIllumination(3, [[0, 0], [1, 1], [2, 2]], [[0, 0], [1, 1], [2, 2]]) == [1, 0, 0]", "def test_gridIllumination():\n    solution = Solution()\n    assert solution.gridIllumination(5, [[0, 2], [1, 3]], [[0, 1], [4, 4]]) == [1, 0]", "def test_gridIllumination():\n    solution = Solution()\n    assert solution.gridIllumination(2, [[0, 1], [1, 0]], [[0, 0]]) == [1]", "def test_gridIllumination():\n    solution = Solution()\n    assert solution.gridIllumination(4, [[0, 0], [1, 2], [3, 3]], [[0, 1], [1, 0], [2, 2]]) == [1, 0, 1]", "def test_gridIllumination():\n    solution = Solution()\n    assert solution.gridIllumination(6, [[0, 0], [1, 5], [2, 4]], [[0, 3], [1, 4]]) == [1, 0]", "def test_gridIllumination():\n    solution = Solution()\n    assert solution.gridIllumination(5, [[0, 0], [1, 1], [2, 3]], [[0, 0], [4, 4]]) == [1, 0]", "def test_gridIllumination():\n    solution = Solution()\n    assert solution.gridIllumination(3, [[0, 0], [1, 1]], [[0, 2], [2, 0]]) == [1, 0]", "def test_gridIllumination():\n    solution = Solution()\n    assert solution.gridIllumination(5, [[0, 1], [1, 2], [2, 3]], [[0, 0], [4, 4]]) == [1, 0]", "def test_gridIllumination():\n    solution = Solution()\n    assert solution.gridIllumination(4, [[0, 2], [1, 3]], [[0, 0], [1, 1]]) == [1, 0]", "def test_gridIllumination():\n    solution = Solution()\n    assert solution.gridIllumination(5, [[0, 1], [1, 2], [2, 3]], [[0, 0], [4, 4]]) == [1, 0]", "def test_gridIllumination():\n    solution = Solution()\n    assert solution.gridIllumination(6, [[0, 0], [1, 5], [2, 4]], [[0, 3], [1, 4]]) == [1, 0]", "def test_gridIllumination():\n    solution = Solution()\n    assert solution.gridIllumination(3, [[0, 1], [2, 1]], [[1, 0], [1, 2]]) == [1, 0]", "def test_gridIllumination():\n    solution = Solution()\n    assert solution.gridIllumination(5, [[0, 2], [1, 3]], [[0, 0], [4, 4]]) == [1, 0]", "def test_gridIllumination():\n    solution = Solution()\n    assert solution.gridIllumination(4, [[0, 1], [1, 2]], [[0, 0], [3, 3]]) == [1, 0]", "def test_gridIllumination():\n    solution = Solution()\n    assert solution.gridIllumination(3, [[0, 0], [1, 2]], [[0, 1], [2, 1]]) == [1, 0]", "def test_gridIllumination():\n    solution = Solution()\n    assert solution.gridIllumination(5, [[0, 1], [2, 3]], [[0, 0], [4, 4]]) == [1, 0]", "def test_gridIllumination():\n    solution = Solution()\n    assert solution.gridIllumination(4, [[0, 2], [1, 3]], [[0, 0], [1, 1]]) == [1, 0]", "def test_gridIllumination():\n    solution = Solution()\n    assert solution.gridIllumination(3, [[0, 1], [2, 1]], [[1, 0], [1, 2]]) == [1, 0]", "def test_gridIllumination():\n    solution = Solution()\n    assert solution.gridIllumination(5, [[0, 2], [1, 3]], [[0, 0], [4, 4]]) == [1, 0]"]}
{"task_num": 1093, "task_title": "Statistics from a Large Sample", "func_name": "sampleStats", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def sampleStats(self, count: List[int]) -> List[float]:\n    minimum = next((i for i, num in enumerate(count) if num), None)\n    maximum = next((i for i, num in reversed(list(enumerate(count))) if num), None)\n    n = sum(count)\n    mean = sum(i * c / n for i, c in enumerate(count))\n    mode = count.index(max(count))\n\n    numCount = 0\n    leftMedian = 0\n    for i, c in enumerate(count):\n      numCount += c\n      if numCount >= n / 2:\n        leftMedian = i\n        break\n\n    numCount = 0\n    rightMedian = 0\n    for i, c in reversed(list(enumerate(count))):\n      numCount += c\n      if numCount >= n / 2:\n        rightMedian = i\n        break\n\n    return [minimum, maximum, mean, (leftMedian + rightMedian) / 2, mode]\n", "tests": ["def test_sampleStats():\n    solution = Solution()\n    assert solution.sampleStats([0, 1, 2, 3, 4, 5]) == [0, 5, 2.5, 2.5, 0]", "def test_sampleStats():\n    solution = Solution()\n    assert solution.sampleStats([10, 20, 30, 40, 50]) == [10, 50, 30.0, 30.0, 10]", "def test_sampleStats():\n    solution = Solution()\n    assert solution.sampleStats([5, 5, 4, 4, 3, 2, 1]) == [1, 5, 3.5714285714285716, 4.0, 5]", "def test_sampleStats():\n    solution = Solution()\n    assert solution.sampleStats([255] * 100) == [255, 255, 255.0, 255.0, 255]", "def test_sampleStats():\n    solution = Solution()\n    assert solution.sampleStats([1]) == [1, 1, 1.0, 1.0, 1]", "def test_sampleStats():\n    solution = Solution()\n    assert solution.sampleStats([0, 255] * 13) == [0, 255, 127.5, 128.0, 0]", "def test_sampleStats():\n    solution = Solution()\n    assert solution.sampleStats([0, 1, 2] * 5 + [3]) == [0, 3, 1.4444444444444444, 1.5, 0]", "def test_sampleStats():\n    solution = Solution()\n    assert solution.sampleStats([0] * 99 + [1] * 2) == [0, 1, 0.5641025641025641, 0.5, 0]", "def test_sampleStats():\n    solution = Solution()\n    assert solution.sampleStats([0] * 98 + [1, 2]) == [0, 2, 0.47457627118644063, 1.5, 0]", "def test_sampleStats():\n    solution = Solution()\n    assert solution.sampleStats([128] * 3 + [64] * 2) == [64, 128, 96.0, 96.0, 128]", "def test_sampleStats():\n    solution = Solution()\n    assert solution.sampleStats([1, 3, 5, 7, 9]) == [1, 9, 5.0, 5.0, 1]", "def test_sampleStats():\n    solution = Solution()\n    assert solution.sampleStats([2, 4, 6, 8, 10]) == [2, 10, 6.0, 7.0, 2]", "def test_sampleStats():\n    solution = Solution()\n    assert solution.sampleStats([1, 1, 2, 3, 3, 3, 4]) == [1, 4, 2.5714285714285716, 3.0, 3]", "def test_sampleStats():\n    solution = Solution()\n    assert solution.sampleStats([0, 0, 1, 2]) == [0, 2, 0.75, 1.0, 0]", "def test_sampleStats():\n    solution = Solution()\n    assert solution.sampleStats([255] * 10 + [0] * 9) == [0, 255, 22.333333333333336, 22.0, 0]", "def test_sampleStats():\n    solution = Solution()\n    assert solution.sampleStats([1] * 5 + [2] * 5) == [1, 2, 1.5, 1.5, 1]", "def test_sampleStats():\n    solution = Solution()\n    assert solution.sampleStats([0, 255] * 5 + [128]) == [0, 255, 63.75, 128.0, 128]", "def test_sampleStats():\n    solution = Solution()\n    assert solution.sampleStats([10, 20, 30, 40]) == [10, 40, 25.0, 25.0, 10]", "def test_sampleStats():\n    solution = Solution()\n    assert solution.sampleStats([0, 2, 4, 6, 8, 10]) == [0, 10, 5.0, 5.0, 0]", "def test_sampleStats():\n    solution = Solution()\n    assert solution.sampleStats([128] * 4 + [64] * 3) == [64, 128, 97.5, 98.0, 128]"]}
{"task_num": 1129, "task_title": "Shortest Path with Alternating Colors", "func_name": "shortestAlternatingPaths", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import Enum\n\n\nclass Color(Enum):\n  kInit = 0\n  kRed = 1\n  kBlue = 2\n\n\nclass Solution:\n  def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:\n    ans = [-1] * n\n    graph = [[] for _ in range(n)]\n    q = collections.deque([(0, Color.kInit)])\n\n    for u, v in redEdges:\n      graph[u].append((v, Color.kRed))\n\n    for u, v in blueEdges:\n      graph[u].append((v, Color.kBlue))\n\n    step = 0\n    while q:\n      for _ in range(len(q)):\n        u, prevColor = q.popleft()\n        if ans[u] == -1:\n          ans[u] = step\n        for i, (v, edgeColor) in enumerate(graph[u]):\n          if v == -1 or edgeColor == prevColor:\n            continue\n          q.append((v, edgeColor))\n          graph[u][i] = (-1, edgeColor)\n      step += 1\n\n    return ans\n", "tests": ["def test_shortestAlternatingPaths():\n    solution = Solution()\n    n = 5\n    redEdges = [[0, 1], [0, 2]]\n    blueEdges = [[1, 3], [2, 4]]\n    expected = [0, 1, 1, 2, 2]\n    assert solution.shortestAlternatingPaths(n, redEdges, blueEdges) == expected", "def test_shortestAlternatingPaths():\n    solution = Solution()\n    n = 3\n    redEdges = [[0, 1], [2, 1]]\n    blueEdges = [[1, 2]]\n    expected = [0, 1, 2]\n    assert solution.shortestAlternatingPaths(n, redEdges, blueEdges) == expected", "def test_shortestAlternatingPaths():\n    solution = Solution()\n    n = 4\n    redEdges = [[0, 1], [1, 2]]\n    blueEdges = [[2, 3]]\n    expected = [0, 1, 2, -1]\n    assert solution.shortestAlternatingPaths(n, redEdges, blueEdges) == expected", "def test_shortestAlternatingPaths():\n    solution = Solution()\n    n = 1\n    redEdges = []\n    blueEdges = []\n    expected = [0]\n    assert solution.shortestAlternatingPaths(n, redEdges, blueEdges) == expected", "def test_shortestAlternatingPaths():\n    solution = Solution()\n    n = 2\n    redEdges = [[0, 1], [1, 0]]\n    blueEdges = []\n    expected = [0, -1]\n    assert solution.shortestAlternatingPaths(n, redEdges, blueEdges) == expected", "def test_shortestAlternatingPaths():\n    solution = Solution()\n    n = 3\n    redEdges = [[0, 1], [2, 1]]\n    blueEdges = []\n    expected = [0, -1]\n    assert solution.shortestAlternatingPaths(n, redEdges, blueEdges) == expected", "def test_shortestAlternatingPaths():\n    solution = Solution()\n    n = 4\n    redEdges = [[0, 1], [2, 3]]\n    blueEdges = [[1, 2], [3, 1]]\n    expected = [0, -1, -1, -1]\n    assert solution.shortestAlternatingPaths(n, redEdges, blueEdges) == expected", "def test_shortestAlternatingPaths():\n    solution = Solution()\n    n = 5\n    redEdges = [[0, 1], [1, 2], [2, 3], [3, 4]]\n    blueEdges = []\n    expected = [0, 1, -1]\n    assert solution.shortestAlternatingPaths(n, redEdges, blueEdges) == expected", "def test_shortestAlternatingPaths():\n    solution = Solution()\n    n = 3\n    redEdges = []\n    blueEdges = [[0, 1], [1, 2]]\n    expected = [0, 1, 2]\n    assert solution.shortestAlternatingPaths(n, redEdges, blueEdges) == expected", "def test_shortestAlternatingPaths():\n    solution = Solution()\n    n = 4\n    redEdges = [[0, 1], [2, 3]]\n    blueEdges = [[1, 2], [3, 0]]\n    expected = [0, -1, -1, -1]\n    assert solution.shortestAlternatingPaths(n, redEdges, blueEdges) == expected", "def test_shortestAlternatingPaths():\n    solution = Solution()\n    n = 3\n    redEdges = [[0, 1], [1, 2]]\n    blueEdges = [[0, 2], [1, 0]]\n    expected = [0, -1, -1]\n    assert solution.shortestAlternatingPaths(n, redEdges, blueEdges) == expected", "def test_shortestAlternatingPaths():\n    solution = Solution()\n    n = 4\n    redEdges = [[0, 1], [2, 3]]\n    blueEdges = [[1, 2], [3, 1], [0, 2]]\n    expected = [0, -1, -1, -1]\n    assert solution.shortestAlternatingPaths(n, redEdges, blueEdges) == expected", "def test_shortestAlternatingPaths():\n    solution = Solution()\n    n = 5\n    redEdges = [[0, 1], [2, 3]]\n    blueEdges = [[1, 2], [3, 4]]\n    expected = [0, -1, -1, -1]\n    assert solution.shortestAlternatingPaths(n, redEdges, blueEdges) == expected", "def test_shortestAlternatingPaths():\n    solution = Solution()\n    n = 3\n    redEdges = [[0, 1], [2, 1]]\n    blueEdges = [[1, 2], [0, 2]]\n    expected = [0, -1, -1]\n    assert solution.shortestAlternatingPaths(n, redEdges, blueEdges) == expected", "def test_shortestAlternatingPaths():\n    solution = Solution()\n    n = 4\n    redEdges = [[0, 1], [2, 3]]\n    blueEdges = [[1, 2], [0, 3]]\n    expected = [0, -1, -1, -1]\n    assert solution.shortestAlternatingPaths(n, redEdges, blueEdges) == expected", "def test_shortestAlternatingPaths():\n    solution = Solution()\n    n = 5\n    redEdges = [[0, 1], [2, 3]]\n    blueEdges = [[1, 4], [3, 2]]\n    expected = [0, -1, -1, -1]\n    assert solution.shortestAlternatingPaths(n, redEdges, blueEdges) == expected", "def test_shortestAlternatingPaths():\n    solution = Solution()\n    n = 3\n    redEdges = [[0, 1], [2, 1]]\n    blueEdges = [[1, 2], [2, 0]]\n    expected = [0, -1, -1]\n    assert solution.shortestAlternatingPaths(n, redEdges, blueEdges) == expected", "def test_shortestAlternatingPaths():\n    solution = Solution()\n    n = 4\n    redEdges = [[0, 1], [2, 3]]\n    blueEdges = [[1, 2], [0, 3], [2, 1]]\n    expected = [0, -1, -1, -1]\n    assert solution.shortestAlternatingPaths(n, redEdges, blueEdges) == expected", "def test_shortestAlternatingPaths():\n    solution = Solution()\n    n = 5\n    redEdges = [[0, 1], [2, 3]]\n    blueEdges = [[1, 4], [3, 2], [0, 4]]\n    expected = [0, -1, -1, -1]\n    assert solution.shortestAlternatingPaths(n, redEdges, blueEdges) == expected", "def test_shortestAlternatingPaths():\n    solution = Solution()\n    n = 3\n    redEdges = [[0, 1], [2, 1]]\n    blueEdges = [[1, 2], [1, 0]]\n    expected = [0, -1, -1]\n    assert solution.shortestAlternatingPaths(n, redEdges, blueEdges) == expected"]}
{"task_num": 1139, "task_title": "Largest 1-Bordered Square", "func_name": "largest1BorderedSquare", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n\n    leftOnes = [[0] * n for _ in range(m)]\n    topOnes = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1:\n          if j==0:\n            leftOnes[i][j]=1\n          else:\n            leftOnes[i][j]=1+leftOnes[i][j-1]\n          if i==0:\n            topOnes[i][j]=1\n          else:\n            topOnes[i][j]=1+topOnes[i-1][j]\n\n    for sz in range(min(m, n), 0, -1):\n      for i in range(m - sz + 1):\n        for j in range(n - sz + 1):\n          x = i + sz - 1\n          y = j + sz - 1\n          if min(leftOnes[i][y], leftOnes[x][y], topOnes[x][j], topOnes[x][y]) >= sz:\n            return sz * sz\n\n    return 0\n", "tests": ["def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[1, 0, 1], [1, 1, 1], [1, 1, 1]]\n    assert solution.largest1BorderedSquare(grid) == 9", "def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]\n    assert solution.largest1BorderedSquare(grid) == 1", "def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n    assert solution.largest1BorderedSquare(grid) == 0", "def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 0, 1], [1, 1, 1, 1]]\n    assert solution.largest1BorderedSquare(grid) == 9", "def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[0, 1, 1], [1, 0, 1], [1, 1, 0]]\n    assert solution.largest1BorderedSquare(grid) == 1", "def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[1], [1]]\n    assert solution.largest1BorderedSquare(grid) == 1", "def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 0, 0]]\n    assert solution.largest1BorderedSquare(grid) == 0", "def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[1, 1, 1, 1], [1, 0, 0, 1], [1, 0, 0, 1], [1, 1, 1, 1]]\n    assert solution.largest1BorderedSquare(grid) == 4", "def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[1, 1, 0], [1, 1, 1], [0, 1, 1]]\n    assert solution.largest1BorderedSquare(grid) == 4", "def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[0, 1, 0], [1, 1, 1], [1, 0, 1]]\n    assert solution.largest1BorderedSquare(grid) == 4", "def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[1, 0, 1], [1, 1, 1], [1, 1, 1]]\n    assert solution.largest1BorderedSquare(grid) == 9", "def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 1, 1], [0, 1, 0]]\n    assert solution.largest1BorderedSquare(grid) == 4", "def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[1, 1, 0], [1, 1, 0], [0, 0, 0]]\n    assert solution.largest1BorderedSquare(grid) == 4", "def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[0, 0, 0, 0], [0, 1, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0]]\n    assert solution.largest1BorderedSquare(grid) == 4", "def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]\n    assert solution.largest1BorderedSquare(grid) == 9", "def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[0, 1, 0], [1, 1, 1], [1, 0, 0]]\n    assert solution.largest1BorderedSquare(grid) == 4", "def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[1, 0, 1], [1, 1, 1], [1, 1, 1]]\n    assert solution.largest1BorderedSquare(grid) == 9", "def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 0, 0]]\n    assert solution.largest1BorderedSquare(grid) == 0", "def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[1], [1]]\n    assert solution.largest1BorderedSquare(grid) == 1", "def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]\n    assert solution.largest1BorderedSquare(grid) == 0"]}
{"task_num": 1162, "task_title": "As Far from Land as Possible", "func_name": "maxDistance", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxDistance(self, grid: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    q = collections.deque()\n    water = 0\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 0:\n          water += 1\n        else:\n          q.append((i, j))\n\n    if water == 0 or water == m * n:\n      return -1\n\n    ans = 0\n    d = 0\n\n    while q:\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        ans = d\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if grid[x][y] > 0:\n            continue\n          q.append((x, y))\n          grid[x][y] = 2\n      d += 1\n\n    return ans\n", "tests": ["def test_maxDistance():\n    solution = Solution()\n    grid = [[1, 0, 1], [0, 0, 0], [1, 0, 1]]\n    assert solution.maxDistance(grid) == 2", "def test_maxDistance():\n    solution = Solution()\n    grid = [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\n    assert solution.maxDistance(grid) == -1", "def test_maxDistance():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n    assert solution.maxDistance(grid) == -1", "def test_maxDistance():\n    solution = Solution()\n    grid = [[0]]\n    assert solution.maxDistance(grid) == -1", "def test_maxDistance():\n    solution = Solution()\n    grid = [[1]]\n    assert solution.maxDistance(grid) == -1", "def test_maxDistance():\n    solution = Solution()\n    grid = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]\n    assert solution.maxDistance(grid) == 2", "def test_maxDistance():\n    solution = Solution()\n    n = 50\n    grid = [[1 if (i + j) % 2 == 0 else 0 for j in range(n)] for i in range(n)]\n    assert solution.maxDistance(grid) == 24", "def test_maxDistance():\n    solution = Solution()\n    grid = [[0, 1, 0], [0, 0, 0], [0, 1, 0]]\n    assert solution.maxDistance(grid) == 2", "def test_maxDistance():\n    solution = Solution()\n    grid = [[0, 0, 1], [0, 1, 0], [1, 0, 0]]\n    assert solution.maxDistance(grid) == 2", "def test_maxDistance():\n    solution = Solution()\n    grid = [[0, 0, 1], [0, 0, 0], [1, 0, 0]]\n    assert solution.maxDistance(grid) == 2", "def test_maxDistance():\n    solution = Solution()\n    grid = [[0, 1, 0], [0, 0, 1], [1, 0, 0]]\n    assert solution.maxDistance(grid) == 2", "def test_maxDistance():\n    solution = Solution()\n    grid = [[0, 1, 0], [0, 0, 1], [1, 0, 0], [0, 1, 0]]\n    assert solution.maxDistance(grid) == 2", "def test_maxDistance():\n    solution = Solution()\n    grid = [[0, 1, 0], [0, 0, 1], [1, 0, 0]]\n    assert solution.maxDistance(grid) == 2", "def test_maxDistance():\n    solution = Solution()\n    grid = [[0, 1], [0, 0], [0, 0], [1, 0]]\n    assert solution.maxDistance(grid) == 3", "def test_maxDistance():\n    solution = Solution()\n    grid = [[0, 1, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 0, 0, 0]]\n    assert solution.maxDistance(grid) == 4", "def test_maxDistance():\n    solution = Solution()\n    grid = [[0, 1], [1, 0]]\n    assert solution.maxDistance(grid) == 2", "def test_maxDistance():\n    solution = Solution()\n    grid = [[0, 1, 0], [0, 0, 0], [1, 0, 1]]\n    assert solution.maxDistance(grid) == 2", "def test_maxDistance():\n    solution = Solution()\n    grid = [[0, 1], [0, 0], [0, 0], [0, 0], [1, 0]]\n    assert solution.maxDistance(grid) == 4", "def test_maxDistance():\n    solution = Solution()\n    grid = [[1, 0], [0, 1]]\n    assert solution.maxDistance(grid) == 2", "def test_maxDistance():\n    solution = Solution()\n    grid = [[0, 1, 0], [1, 0, 1], [0, 1, 0]]\n    assert solution.maxDistance(grid) == 2"]}
{"task_num": 1202, "task_title": "Smallest String With Swaps", "func_name": "smallestStringWithSwaps", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n    ans = ''\n    uf = UnionFind(len(s))\n    map = collections.defaultdict(list)\n\n    for a, b in pairs:\n      uf.unionByRank(a, b)\n\n    for i, c in enumerate(s):\n      map[uf.find(i)].append(c)\n\n    for key in map.keys():\n      map[key].sort(reverse=True)\n\n    for i in range(len(s)):\n      ans += map[uf.find(i)].pop()\n\n    return ans\n", "tests": ["def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'dcab'\n    pairs = [[0, 3], [1, 2]]\n    assert solution.smallestStringWithSwaps(s, pairs) == 'bacd'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'cba'\n    pairs = [[0, 1], [1, 2]]\n    assert solution.smallestStringWithSwaps(s, pairs) == 'abc'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'abcd'\n    pairs = [[0, 2], [1, 3]]\n    assert solution.smallestStringWithSwaps(s, pairs) == 'abdc'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'bca'\n    pairs = [[0, 1], [2, 3]]\n    assert solution.smallestStringWithSwaps(s, pairs) == 'abc'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'abc'\n    pairs = [[0, 2]]\n    assert solution.smallestStringWithSwaps(s, pairs) == 'acb'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'aabbcc'\n    pairs = [[0, 3], [1, 4], [2, 5]]\n    assert solution.smallestStringWithSwaps(s, pairs) == 'aaabbb'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'aabbcc'\n    pairs = [[0, 1], [2, 3], [4, 5]]\n    assert solution.smallestStringWithSwaps(s, pairs) == 'abacbc'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'aabbcc'\n    pairs = [[0, 2], [1, 4], [3, 5]]\n    assert solution.smallestStringWithSwaps(s, pairs) == 'abcacb'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'abcd'\n    pairs = []\n    assert solution.smallestStringWithSwaps(s, pairs) == 'abcd'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'aa'\n    pairs = [[0, 1], [0, 1]]\n    assert solution.smallestStringWithSwaps(s, pairs) == 'aa'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'abcd'\n    pairs = [[0, 1], [2, 3]]\n    assert solution.smallestStringWithSwaps(s, pairs) == 'abdc'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'aabbcc'\n    pairs = [[0, 2], [1, 4]]\n    assert solution.smallestStringWithSwaps(s, pairs) == 'abacbc'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'abcdef'\n    pairs = [[0, 3], [1, 4], [2, 5]]\n    assert solution.smallestStringWithSwaps(s, pairs) == 'abcdfg'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'zzzz'\n    pairs = [[0, 1], [2, 3]]\n    assert solution.smallestStringWithSwaps(s, pairs) == 'zzzz'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'abc'\n    pairs = [[1, 2], [0, 2]]\n    assert solution.smallestStringWithSwaps(s, pairs) == 'acb'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'abc'\n    pairs = [[0, 2], [1, 2]]\n    assert solution.smallestStringWithSwaps(s, pairs) == 'acb'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'abcde'\n    pairs = [[0, 3], [1, 4], [2, 5]]\n    assert solution.smallestStringWithSwaps(s, pairs) == 'abcde'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'abc'\n    pairs = [[0, 1], [2, 3]]\n    assert solution.smallestStringWithSwaps(s, pairs) == 'abc'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'abc'\n    pairs = [[0, 1], [1, 2]]\n    assert solution.smallestStringWithSwaps(s, pairs) == 'acb'", "def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'aabbcc'\n    pairs = [[0, 1], [2, 3], [4, 5]]\n    assert solution.smallestStringWithSwaps(s, pairs) == 'aaabbb'"]}
{"task_num": 1210, "task_title": "Minimum Moves to Reach Target with Rotations", "func_name": "minimumMoves", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import IntEnum\n\n\nclass Pos(IntEnum):\n  kHorizontal = 0\n  kVertical = 1\n\n\nclass Solution:\n  def minimumMoves(self, grid: List[List[int]]) -> int:\n    n = len(grid)\n    ans = 0\n\n    q = collections.deque([(0, 0, Pos.kHorizontal)])\n    seen = {(0, 0, Pos.kHorizontal)}\n\n    def canMoveRight(x: int, y: int, pos: Pos) -> bool:\n      if pos == Pos.kHorizontal:\n        return y + 2 < n and not grid[x][y + 2]\n      return y + 1 < n and not grid[x][y + 1] and not grid[x + 1][y + 1]\n\n    def canMoveDown(x: int, y: int, pos: Pos) -> bool:\n      if pos == Pos.kVertical:\n        return x + 2 < n and not grid[x + 2][y]\n      return x + 1 < n and not grid[x + 1][y] and not grid[x + 1][y + 1]\n\n    def canRotateClockwise(x: int, y: int, pos: Pos) -> bool:\n      return pos == Pos.kHorizontal and x + 1 < n and \\\n          not grid[x + 1][y + 1] and not grid[x + 1][y]\n\n    def canRotateCounterclockwise(x: int, y: int, pos: Pos) -> bool:\n      return pos == Pos.kVertical and y + 1 < n and \\\n          not grid[x + 1][y + 1] and not grid[x][y + 1]\n\n    while q:\n      for _ in range(len(q)):\n        x, y, pos = q.popleft()\n        if x == n - 1 and y == n - 2 and pos == Pos.kHorizontal:\n          return ans\n        if canMoveRight(x, y, pos) and (x, y + 1, pos) not in seen:\n          q.append((x, y + 1, pos))\n          seen.add((x, y + 1, pos))\n        if canMoveDown(x, y, pos) and (x + 1, y, pos) not in seen:\n          q.append((x + 1, y, pos))\n          seen.add((x + 1, y, pos))\n        newPos = Pos.kVertical if pos == Pos.kHorizontal else Pos.kHorizontal\n        if (canRotateClockwise(x, y, pos) or canRotateCounterclockwise(x, y, pos)) and (x, y, newPos) not in seen:\n          q.append((x, y, newPos))\n          seen.add((x, y, newPos))\n      ans += 1\n\n    return -1\n", "tests": ["def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 1, 1, 0]]\n    assert solution.minimumMoves(grid) == -1", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 1], [0, 0]]\n    assert solution.minimumMoves(grid) == -1", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 1, 0], [0, 0, 0], [0, 0, 0]]\n    assert solution.minimumMoves(grid) == -1", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 0, 1], [0, 0, 0]]\n    assert solution.minimumMoves(grid) == -1", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 0], [1, 0]]\n    assert solution.minimumMoves(grid) == -1", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 0, 1], [0, 0, 0]]\n    assert solution.minimumMoves(grid) == -1", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 0, 1], [0, 0, 0]]\n    assert solution.minimumMoves(grid) == -1", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 0]]\n    assert solution.minimumMoves(grid) == -1", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 1, 0], [0, 0, 0], [0, 0, 0]]\n    assert solution.minimumMoves(grid) == -1", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n    assert solution.minimumMoves(grid) == -1", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n    assert solution.minimumMoves(grid) == -1", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 1, 0], [0, 0, 0], [0, 0, 0]]\n    assert solution.minimumMoves(grid) == -1", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 1, 0], [0, 0, 0], [0, 0, 0]]\n    assert solution.minimumMoves(grid) == -1", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 1, 0], [0, 0, 0], [0, 0, 0]]\n    assert solution.minimumMoves(grid) == -1", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n    assert solution.minimumMoves(grid) == -1", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 1, 0], [0, 0, 0], [0, 0, 0]]\n    assert solution.minimumMoves(grid) == -1", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 1, 0], [0, 0, 0], [0, 0, 0]]\n    assert solution.minimumMoves(grid) == -1", "def test_minimumMoves(self):\n    grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n    expected_result = 0\n    result = solution.minimumMoves(grid)", "def test_minimumMoves(self):\n    grid = [[0, 1, 0], [0, 0, 0], [0, 0, 0]]\n    expected_result = 2\n    result = solution.minimumMoves(grid)", "def test_minimumMoves(self):\n    grid = [[0, 1], [1, 0]]\n    expected_result = -1\n    result = solution.minimumMoves(grid)"]}
{"task_num": 1253, "task_title": "Reconstruct a 2-Row Binary Matrix", "func_name": "reconstructMatrix", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def reconstructMatrix(self, upper: int, lower: int, colsum: List[int]) -> List[List[int]]:\n    if upper + lower != sum(colsum):\n      return []\n    if min(upper, lower) < colsum.count(2):\n      return []\n\n    ans = [[0] * len(colsum) for _ in range(2)]\n\n    for j, c in enumerate(colsum):\n      if c == 2:\n        ans[0][j] = 1\n        ans[1][j] = 1\n        upper -= 1\n        lower -= 1\n\n    for j, c in enumerate(colsum):\n      if c == 1 and upper > 0:\n        ans[0][j] = 1\n        c -= 1\n        upper -= 1\n      if c == 1 and lower > 0:\n        ans[1][j] = 1\n        lower -= 1\n\n    return ans\n", "tests": ["def test_reconstructMatrix():\n    solution = Solution()\n    upper = 2\n    lower = 1\n    colsum = [1, 1, 1]\n    expected_output = [[1, 0, 1], [0, 1, 0]]\n    assert solution.reconstructMatrix(upper, lower, colsum) == expected_output", "def test_reconstructMatrix():\n    solution = Solution()\n    upper = 2\n    lower = 3\n    colsum = [1, 1, 1]\n    expected_output = []\n    assert solution.reconstructMatrix(upper, lower, colsum) == expected_output", "def test_reconstructMatrix():\n    solution = Solution()\n    upper = 0\n    lower = 0\n    colsum = []\n    expected_output = [[], []]\n    assert solution.reconstructMatrix(upper, lower, colsum) == expected_output", "def test_reconstructMatrix():\n    solution = Solution()\n    upper = 2\n    lower = 3\n    colsum = [2, 2]\n    expected_output = [[1, 0], [1, 1]]\n    assert solution.reconstructMatrix(upper, lower, colsum) == expected_output", "def test_reconstructMatrix():\n    solution = Solution()\n    upper = 3\n    lower = 2\n    colsum = [2, 2]\n    expected_output = []\n    assert solution.reconstructMatrix(upper, lower, colsum) == expected_output", "def test_reconstructMatrix():\n    solution = Solution()\n    upper = 3\n    lower = 2\n    colsum = [2, 2, 0]\n    expected_output = []\n    assert solution.reconstructMatrix(upper, lower, colsum) == expected_output", "def test_reconstructMatrix():\n    solution = Solution()\n    upper = 3\n    lower = 2\n    colsum = [2, -1]\n    expected_output = []\n    assert solution.reconstructMatrix(upper, lower, colsum) == expected_output", "def test_reconstructMatrix():\n    solution = Solution()\n    upper = 3\n    lower = 2\n    colsum = [2, 'a']\n    expected_output = []\n    assert solution.reconstructMatrix(upper, lower, colsum) == expected_output", "def test_reconstructMatrix():\n    solution = Solution()\n    upper = 1000\n    lower = 500\n    colsum = [2] * 1000\n    expected_output = []\n    assert solution.reconstructMatrix(upper, lower, colsum) == expected_output", "def test_reconstructMatrix():\n    solution = Solution()\n    upper = 1000\n    lower = -500\n    colsum = [2] * 1000\n    expected_output = []\n    assert solution.reconstructMatrix(upper, lower, colsum) == expected_output", "def test_reconstructMatrix():\n    solution = Solution()\n    upper = 10 ** 9\n    lower = 5 * 10 ** 8\n    colsum = [2] * 10 ** 9\n    expected_output = []\n    assert solution.reconstructMatrix(upper, lower, colsum) == expected_output", "def test_reconstructMatrix():\n    solution = Solution()\n    upper = -10 ** 9\n    lower = 5 * 10 ** 8\n    colsum = [2] * 10 ** 9\n    expected_output = []\n    assert solution.reconstructMatrix(upper, lower, colsum) == expected_output", "def test_reconstructMatrix():\n    solution = Solution()\n    upper = 10 ** 9\n    lower = 5 * 10 ** 8\n    colsum = [2] * 5 * 10 ** 8 + [0] * 5 * 10 ** 8\n    expected_output = []\n    assert solution.reconstructMatrix(upper, lower, colsum) == expected_output", "def test_reconstructMatrix():\n    solution = Solution()\n    upper = -10 ** 9\n    lower = 5 * 10 ** 8\n    colsum = [2] * 5 * 10 ** 8 + [0] * 5 * 10 ** 8\n    expected_output = []\n    assert solution.reconstructMatrix(upper, lower, colsum) == expected_output", "def test_reconstructMatrix():\n    solution = Solution()\n    upper = 10 ** 9\n    lower = 5 * 10 ** 8\n    colsum = [2] * 3 * 10 ** 8 + [0] * 4 * 10 ** 8 + [1]\n    expected_output = []\n    assert solution.reconstructMatrix(upper, lower, colsum) == expected_output", "def test_reconstructMatrix():\n    solution = Solution()\n    upper = -10 ** 9\n    lower = 5 * 10 ** 8\n    colsum = [2] * 3 * 10 ** 8 + [0] * 4 * 10 ** 8 + [1] + [-2]\n    expected_output = []\n    assert solution.reconstructMatrix(upper, lower, colsum) == expected_output", "def test_reconstructMatrix():\n    solution = Solution()\n    upper = -10 ** 9\n    lower = 5 * 10 ** 8\n    colsum = [2] * 3 * 10 ** 8 + [0] * 4 * 10 ** 8 + [1] + [-2] + [2]\n    expected_output = []\n    assert solution.reconstructMatrix(upper, lower, colsum) == expected_output", "def test_reconstructMatrix():\n    solution = Solution()\n    upper = -10 ** 9\n    lower = 5 * 10 ** 8\n    colsum = [2] * 3 * 10 ** 8 + [0] * 4 * 10 ** 8 + [1] + [-2] + [2] + [-1]\n    expected_output = []\n    assert solution.reconstructMatrix(upper, lower, colsum) == expected_output", "def test_reconstructMatrix():\n    solution = Solution()\n    upper = -10 ** 9\n    lower = 5 * 10 ** 8\n    colsum = [2] * 3 * 10 ** 8 + [0] * 4 * 10 ** 8 + [1] + [-2] + [2] + [-1] + [2]\n    expected_output = []\n    assert solution.reconstructMatrix(upper, lower, colsum) == expected_output", "def test_reconstructMatrix():\n    solution = Solution()\n    upper = -10 ** 9\n    lower = 5 * 10 ** 8\n    colsum = [2] * 3 * 10 ** 8 + [0] * 4 * 10 ** 8 + [1] + [-2] + [2] + [-1] + [2] + [-1]\n    expected_output = []\n    assert solution.reconstructMatrix(upper, lower, colsum) == expected_output"]}
{"task_num": 1254, "task_title": "Number of Closed Islands", "func_name": "closedIsland", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def closedIsland(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n\n    def dfs(i: int, j: int) -> None:\n      if i < 0 or i == m or j < 0 or j == n:\n        return\n      if grid[i][j] == 1:\n        return\n\n      grid[i][j] = 1\n      dfs(i + 1, j)\n      dfs(i - 1, j)\n      dfs(i, j + 1)\n      dfs(i, j - 1)\n\n    for i in range(m):\n      for j in range(n):\n        if i * j == 0 or i == m - 1 or j == n - 1:\n          if grid[i][j] == 0:\n            dfs(i, j)\n\n    ans = 0\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 0:\n          dfs(i, j)\n          ans += 1\n\n    return ans\n", "tests": ["def test_closedIsland():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n    assert solution.closedIsland(grid) == 1", "def test_closedIsland():\n    solution = Solution()\n    grid = [[0, 0, 1], [0, 1, 0], [1, 0, 0]]\n    assert solution.closedIsland(grid) == 2", "def test_closedIsland():\n    solution = Solution()\n    grid = [[0, 1, 0], [1, 0, 1], [0, 1, 0]]\n    assert solution.closedIsland(grid) == 0", "def test_closedIsland():\n    solution = Solution()\n    grid = [[1, 1, 1], [0, 0, 0], [1, 1, 1]]\n    assert solution.closedIsland(grid) == 1", "def test_closedIsland():\n    solution = Solution()\n    grid = [[0, 0, 0], [1, 1, 1], [0, 0, 0]]\n    assert solution.closedIsland(grid) == 2", "def test_closedIsland():\n    solution = Solution()\n    grid = [[1, 0, 0], [0, 0, 0], [0, 1, 1]]\n    assert solution.closedIsland(grid) == 2", "def test_closedIsland():\n    solution = Solution()\n    grid = [[0, 1, 1], [1, 0, 1], [1, 1, 0]]\n    assert solution.closedIsland(grid) == 1", "def test_closedIsland():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 1, 0], [0, 1, 0]]\n    assert solution.closedIsland(grid) == 0", "def test_closedIsland():\n    solution = Solution()\n    grid = [[1, 0, 0, 1], [0, 0, 0, 0], [0, 0, 0, 0], [1, 0, 0, 1]]\n    assert solution.closedIsland(grid) == 2", "def test_closedIsland():\n    solution = Solution()\n    grid = [[1, 0, 0, 1], [0, 1, 0, 0], [0, 1, 0, 1], [1, 0, 0, 1]]\n    assert solution.closedIsland(grid) == 2", "def test_closedIsland():\n    solution = Solution()\n    grid = [[1, 0, 0, 1], [0, 1, 1, 0], [0, 1, 1, 0], [1, 0, 0, 1]]\n    assert solution.closedIsland(grid) == 2", "def test_closedIsland():\n    solution = Solution()\n    grid = [[1, 0, 0, 1], [0, 1, 0, 0], [0, 0, 1, 0], [1, 0, 0, 1]]\n    assert solution.closedIsland(grid) == 2", "def test_closedIsland():\n    solution = Solution()\n    grid = [[1, 0, 0, 1], [0, 1, 0, 0], [0, 0, 0, 0], [1, 0, 1, 1]]\n    assert solution.closedIsland(grid) == 2", "def test_closedIsland():\n    solution = Solution()\n    grid = [[0, 1, 0], [1, 1, 1], [0, 1, 0]]\n    assert solution.closedIsland(grid) == 2", "def test_closedIsland():\n    solution = Solution()\n    grid = [[0, 1, 0], [0, 1, 1], [0, 0, 0]]\n    assert solution.closedIsland(grid) == 2", "def test_closedIsland():\n    solution = Solution()\n    grid = [[0, 0, 1], [0, 0, 0], [1, 0, 0]]\n    assert solution.closedIsland(grid) == 2", "def test_closedIsland():\n    solution = Solution()\n    grid = [[0, 0, 0], [1, 1, 1]]\n    assert solution.closedIsland(grid) == 0", "def test_closedIsland():\n    solution = Solution()\n    grid = [[1, 0], [0, 1]]\n    assert solution.closedIsland(grid) == 2", "def test_closedIsland():\n    solution = Solution()\n    grid = [[0, 1, 0], [1, 0, 0], [0, 0, 1]]\n    assert solution.closedIsland(grid) == 2", "def test_closedIsland():\n    solution = Solution()\n    grid = [[0, 1, 0], [1, 0, 1]]\n    assert solution.closedIsland(grid) == 2"]}
{"task_num": 1263, "task_title": "Minimum Moves to Move a Box to Their Target Location", "func_name": "minPushBox", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\nfrom collections import deque\n\nclass Solution:\n  def minPushBox(self, grid: List[List[str]]) -> int:\n    for i in range(len(grid)):\n      for j in range(len(grid[0])):\n        if grid[i][j] == \"T\":\n          target = (i,j)\n        if grid[i][j] == \"B\":\n          box = (i,j)\n        if grid[i][j] == \"S\":\n          person = (i,j)\n\n    def valid(x,y):\n      return 0<=x<len(grid) and 0<=y<len(grid[0]) and grid[x][y]!='#'\n\n    def check(curr,dest,box):\n      que = deque([curr])\n      v = set()\n      while que:\n        pos = que.popleft()\n        if pos == dest: \n          return True\n        new_pos = [(pos[0]+1,pos[1]),(pos[0]-1,pos[1]),(pos[0],pos[1]+1),(pos[0],pos[1]-1)]\n        for x,y in new_pos:\n          if valid(x,y) and (x,y) not in v and (x,y)!=box:\n            v.add((x,y))\n            que.append((x,y))\n      return False\n\n    q = deque([(0,box,person)])\n    vis = {box+person}\n    while q :\n      dist, box, person = q.popleft()\n      if box == target:\n        return dist\n\n      b_coord = [(box[0]+1,box[1]),(box[0]-1,box[1]),(box[0],box[1]+1),(box[0],box[1]-1)]\n      p_coord = [(box[0]-1,box[1]),(box[0]+1,box[1]),(box[0],box[1]-1),(box[0],box[1]+1)]\n\n      for new_box,new_person in zip(b_coord,p_coord): \n        if valid(*new_box) and new_box+box not in vis:\n          if valid(*new_person) and check(person,new_person,box):\n            vis.add(new_box+box)\n            q.append((dist+1,new_box,box))\n\n    return -1\n", "tests": ["def test_minPushBox():\n    solution = Solution()", "def test_minPushBox():\n    solution = Solution()", "def test_minPushBox():\n    solution = Solution()", "def test_minPushBox():\n    solution = Solution()", "def test_minPushBox():\n    solution = Solution()", "def test_minPushBox():\n    solution = Solution()", "def test_minPushBox():\n    solution = Solution()", "def test_minPushBox():\n    solution = Solution()", "def test_minPushBox():\n    solution = Solution()", "def test_minPushBox():\n    solution = Solution()", "def test_minPushBox():\n    solution = Solution()", "def test_minPushBox():\n    solution = Solution()", "def test_minPushBox():\n    solution = Solution()", "def test_minPushBox():\n    solution = Solution()", "def test_minPushBox():\n    solution = Solution()", "def test_minPushBox():\n    solution = Solution()", "def test_minPushBox():\n    solution = Solution()", "def test_minPushBox():\n    solution = Solution()", "def test_minPushBox():\n    solution = Solution()", "def test_minPushBox():\n    solution = Solution()"]}
{"task_num": 1267, "task_title": "Count Servers that Communicate", "func_name": "countServers", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countServers(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    ans = 0\n    rows = [0] * m\n    cols = [0] * n\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1:\n          rows[i] += 1\n          cols[j] += 1\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1 and (rows[i] > 1 or cols[j] > 1):\n          ans += 1\n\n    return ans\n", "tests": ["def test_countServers():\n    solution = Solution()\n    grid = [[1, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]", "def test_countServers():\n    solution = Solution()\n    grid = [[1, 1, 0, 0], [1, 1, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]", "def test_countServers():\n    solution = Solution()\n    grid = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 0, 0, 0]]", "def test_countServers():\n    solution = Solution()\n    grid = [\n        [1],\n        [0]\n    ]\n```\n", "def test_countServers():\n    solution = Solution()\n    grid = [[1, 1, 1], [0, 0, 0], [1, 1, 1]]", "def test_countServers():\n    solution = Solution()\n    grid = [[0, 0], [0, 0]]", "def test_countServers():\n    solution = Solution()\n    grid = [[1], [1]]", "def test_countServers():\n    solution = Solution()\n    grid = [[0], [1]]", "def test_countServers():\n    solution = Solution()\n    grid = [[1, 0], [1, 1]]", "def test_countServers():\n    solution = Solution()\n    grid = [[0, 0], [1, 0]]", "def test_countServers():\n    solution = Solution()\n    grid = [[1, 1], [0, 0]]", "def test_countServers():\n    solution = Solution()\n    grid = [\n        [1, 0, 1],\n        [0, 0, 0],\n        [1, 0, 1]\n    ]\n```\n", "def test_countServers():\n    solution = Solution()\n    grid = [[1, 0, 1], [1, 0, 1], [1, 1, 0]]", "def test_countServers():\n    solution = Solution()\n    grid = [[0, 1, 0], [1, 1, 1], [0, 1, 0]]", "def test_countServers():\n    solution = Solution()\n    grid = [[0, 0], [1, 0]]", "def test_countServers():\n    solution = Solution()\n    grid = [[0, 1, 0], [0, 0, 0], [1, 0, 1]]", "def test_countServers():\n    solution = Solution()\n    grid = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]", "def test_countServers():\n    solution = Solution()\n    grid = [[1], [0], [1]]", "def test_countServers():\n    solution = Solution()\n    grid = [[0], [1]]", "def test_countServers():\n    solution = Solution()\n    grid = [\n        [0, 0],\n        [0, 1]\n    ]\n```\n"]}
{"task_num": 1284, "task_title": "Minimum Number of Flips to Convert Binary Matrix to Zero Matrix", "func_name": "minFlips", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minFlips(self, mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    hash = self._getHash(mat, m, n)\n    if hash == 0:\n      return 0\n\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    step = 0\n    q = collections.deque([hash])\n    seen = {hash}\n\n    while q:\n      step += 1\n      for _ in range(len(q)):\n        curr = q.popleft()\n        for i in range(m):\n          for j in range(n):\n            next = curr ^ 1 << (i * n + j)\n            for dx, dy in dirs:\n              x = i + dx\n              y = j + dy\n              if x < 0 or x == m or y < 0 or y == n:\n                continue\n              next ^= 1 << (x * n + y)\n            if next == 0:\n              return step\n            if next in seen:\n              continue\n            q.append(next)\n            seen.add(next)\n\n    return -1\n\n  def _getHash(self, mat: List[List[int]], m: int, n: int) -> int:\n    hash = 0\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j]:\n          hash |= 1 << (i * n + j)\n    return hash\n", "tests": ["def test_minFlips():\n    solution = Solution()\n    assert solution.minFlips([[0, 1], [1, 0]]) == 2", "def test_minFlips():\n    solution = Solution()\n    assert solution.minFlips([[0, 0], [0, 0]]) == 0", "def test_minFlips():\n    solution = Solution()\n    mat = [[1] * 5 for _ in range(5)]\n    assert solution.minFlips(mat) == 8", "def test_minFlips():\n    solution = Solution()\n    mat = [[0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0]]\n    assert solution.minFlips(mat) == 8", "def test_minFlips():\n    solution = Solution()\n    mat = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]\n    assert solution.minFlips(mat) == 4", "def test_minFlips():\n    solution = Solution()\n    mat = [[1, 0, 1, 0, 1], [0, 1, 0, 1, 0], [1, 0, 1, 0, 1], [0, 1, 0, 1, 0], [1, 0, 1, 0, 1]]\n    assert solution.minFlips(mat) == 16", "def test_minFlips():\n    solution = Solution()\n    mat = [[1, 0, 1], [0, 1, 0], [1, 0, 1], [0, 1, 0], [1, 0, 1]]\n    assert solution.minFlips(mat) == 8", "def test_minFlips():\n    solution = Solution()\n    mat = [[1, 0], [0, 1], [1, 0]]\n    assert solution.minFlips(mat) == 4", "def test_minFlips():\n    solution = Solution()\n    mat = [[1, 0], [0, 1], [1, 0]]\n    assert solution.minFlips(mat) == 4", "def test_minFlips():\n    solution = Solution()\n    mat = [[1, 0], [0, 1], [1, 0]]\n    assert solution.minFlips(mat) == 4", "def test_minFlips():\n    solution = Solution()\n    mat = [[1, 0], [0, 1], [1, 0]]\n    assert solution.minFlips(mat) == 4", "def test_minFlips():\n    solution = Solution()\n    mat = [[1, 0], [0, 1], [1, 0]]\n    assert solution.minFlips(mat) == 4", "def test_minFlips():\n    solution = Solution()\n    mat = [[0] * 6 for _ in range(6)]\n    mat[0][0] = 1\n    assert solution.minFlips(mat) == 4", "def test_minFlips():\n    solution = Solution()\n    mat = [[0] * 3 for _ in range(3)]\n    mat[0][0] = 1\n    assert solution.minFlips(mat) == 2", "def test_minFlips():\n    solution = Solution()\n    mat = [[0] * 4 for _ in range(4)]\n    mat[1][2] = 1\n    assert solution.minFlips(mat) == 3", "def test_minFlips():\n    solution = Solution()\n    mat = [[0] * 5 for _ in range(5)]\n    mat[4][3] = 1\n    assert solution.minFlips(mat) == 6", "def test_minFlips():\n    solution = Solution()\n    mat = [[0] * 7 for _ in range(7)]\n    mat[3][4] = 1\n    assert solution.minFlips(mat) == 12", "def test_minFlips():\n    solution = Solution()\n    mat = [[1] * 5 for _ in range(5)]\n    mat[2][3] = 0\n    assert solution.minFlips(mat) == 10", "def test_minFlips():\n    solution = Solution()\n    mat = [[0] * 5 for _ in range(5)]\n    mat[1][2] = 1\n    mat[4][3] = 1\n    assert solution.minFlips(mat) == 8", "def test_minFlips():\n    solution = Solution()\n    mat = [[0] * 8 for _ in range(8)]\n    mat[1][2] = 1\n    mat[3][5] = 1\n    assert solution.minFlips(mat) == 14"]}
{"task_num": 1293, "task_title": "Shortest Path in a Grid with Obstacles Elimination", "func_name": "shortestPath", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def shortestPath(self, grid: List[List[int]], k: int) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    if m == 1 and n == 1:\n      return 0\n\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    steps = 0\n    q = collections.deque([(0, 0, k)])\n    seen = {(0, 0, k)}\n\n    while q:\n      steps += 1\n      for _ in range(len(q)):\n        i, j, eliminate = q.popleft()\n        for l in range(4):\n          x = i + dirs[l][0]\n          y = j + dirs[l][1]\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if x == m - 1 and y == n - 1:\n            return steps\n          if grid[x][y] == 1 and eliminate == 0:\n            continue\n          newEliminate = eliminate - grid[x][y]\n          if (x, y, newEliminate) in seen:\n            continue\n          q.append((x, y, newEliminate))\n          seen.add((x, y, newEliminate))\n\n    return -1\n", "tests": ["def test_shortestPath():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n    k = 1\n    assert solution.shortestPath(grid, k) == 4", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0, 1, 1], [1, 1, 0], [0, 0, 0]]\n    k = 2\n    assert solution.shortestPath(grid, k) == 4", "def test_shortestPath():\n    solution = Solution()\n    grid = [[1, 1], [1, 1]]\n    k = 0\n    assert solution.shortestPath(grid, k) == -1", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0]]\n    k = 0\n    assert solution.shortestPath(grid, k) == 0", "def test_shortestPath():\n    solution = Solution()\n    grid = [[1] * 100 for _ in range(100)]\n    k = 9800\n    assert solution.shortestPath(grid, k) == 398", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0, 1, 0], [0, 1, 0], [0, 0, 0]]\n    k = 2\n    assert solution.shortestPath(grid, k) == 4", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0] * 1000 for _ in range(1000)]\n    k = 998\n    assert solution.shortestPath(grid, k) == 3994", "def test_shortestPath():\n    solution = Solution()\n    grid = [[1] * 5 for _ in range(5)]\n    k = 4\n    assert solution.shortestPath(grid, k) == 8", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0, 1, 0], [0, 1, 0], [0, 0, 0]]\n    k = 3\n    assert solution.shortestPath(grid, k) == 4", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0] * 5 for _ in range(5)]\n    k = -1\n    assert solution.shortestPath(grid, k) == -1", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0, 1]]\n    k = 1\n    assert solution.shortestPath(grid, k) == 2", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0, 1, 0], [1, 1, 1], [0, 0, 0]]\n    k = 3\n    assert solution.shortestPath(grid, k) == 6", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0] * 15 for _ in range(15)]\n    k = 210\n    assert solution.shortestPath(grid, k) == 54", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0]]\n    k = 1000\n    assert solution.shortestPath(grid, k) == 0", "def test_shortestPath():\n    solution = Solution()\n    grid = [[1] * 50 for _ in range(50)]\n    k = 2450\n    assert solution.shortestPath(grid, k) == 98", "def test_shortestPath():\n    solution = Solution()\n    grid = [[1] * 200 for _ in range(200)]\n    k = 98000\n    assert solution.shortestPath(grid, k) == 794", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0] * 100 for _ in range(100)]\n    k = 9850\n    assert solution.shortestPath(grid, k) == 397", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0, 1]]\n    k = 5\n    assert solution.shortestPath(grid, k) == 2", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0] * 100 for _ in range(100)]\n    k = 9850\n    assert solution.shortestPath(grid, k) == 397", "def test_shortestPath():\n    solution = Solution()\n    grid = [[0]]\n    k = 1000000\n    assert solution.shortestPath(grid, k) == 0"]}
{"task_num": 1301, "task_title": "Number of Paths with Max Score", "func_name": "pathsWithMaxScore", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def pathsWithMaxScore(self, board: List[str]) -> List[int]:\n    kMod = 1_000_000_007\n    n = len(board)\n    dirs = ((0, 1), (1, 0), (1, 1))\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    count = [[0] * (n + 1) for _ in range(n + 1)]\n\n    dp[0][0] = 0\n    dp[n - 1][n - 1] = 0\n    count[n - 1][n - 1] = 1\n\n    for i in reversed(range(n)):\n      for j in reversed(range(n)):\n        if board[i][j] == 'S' or board[i][j] == 'X':\n          continue\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if dp[i][j] < dp[x][y]:\n            dp[i][j] = dp[x][y]\n            count[i][j] = count[x][y]\n          elif dp[i][j] == dp[x][y]:\n            count[i][j] += count[x][y]\n            count[i][j] %= kMod\n\n        if dp[i][j] != -1 and board[i][j] != 'E':\n          dp[i][j] += int(board[i][j])\n          dp[i][j] %= kMod\n\n    return [dp[0][0], count[0][0]]\n", "tests": ["def test_pathsWithMaxScore():\n    solution = Solution()\n    board = ['S', '2', 'X'],\n             ['1', '9', '3'],\n             ['4', '5', 'E']\n    assert solution.pathsWithMaxScore(board) == [20, 2]", "def test_pathsWithMaxScore_no_paths():\n    solution = Solution()\n    board = ['S', 'X'],\n             ['X', 'E']\n    assert solution.pathsWithMaxScore(board) == [0, 0]", "def test_pathsWithMaxScore():\n    solution = Solution()\n    board = ['S', 'E']\n    assert solution.pathsWithMaxScore(board) == [0, 1]", "def test_pathsWithMaxScore_complex_board():\n    solution = Solution()\n    board = ['S', '2', '3'],\n             ['1', '9', '5'],\n             ['4', '8', 'E']\n    assert solution.pathsWithMaxScore(board) == [30, 6]", "def test_pathsWithMaxScore_multiple_max_paths():\n    solution = Solution()\n    board = ['S', '1', '2'],\n             ['4', '9', '3'],\n             ['5', '6', 'E']\n    assert solution.pathsWithMaxScore(board) == [28, 3]", "def test_pathsWithMaxScore_boundary_conditions():\n    solution = Solution()\n    board = ['S', '1'],\n             ['X', 'E']\n    assert solution.pathsWithMaxScore(board) == [0, 0]", "def test_pathsWithMaxScore():\n    solution = Solution()\n    n = 100\n    board = [['X'] * (n + 2)] * (n + 2)\n    board[n][1] = 'S'\n    board[1][n] = 'E'\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if i != n and j != n:\n                board[i][j] = str(min(i + j - 2, 9))\n    assert solution.pathsWithMaxScore(board) == [9801, 1]", "def test_pathsWithMaxScore_single_value_board():\n    solution = Solution()\n    board = ['S', '5'],\n             ['4', 'E']\n    assert solution.pathsWithMaxScore(board) == [9, 1]", "def test_pathsWithMaxScore_all_obstacles():\n    solution = Solution()\n    board = ['X', 'X'],\n             ['X', 'E']\n    assert solution.pathsWithMaxScore(board) == [0, 0]", "def test_pathsWithMaxScore():\n    solution = Solution()\n    board = ['S', '5']\n    assert solution.pathsWithMaxScore(board) == [5, 1]", "def test_pathsWithMaxScore():\n    solution = Solution()\n    n = 3\n    board = [['X'] * (n + 2)] * (n + 2)\n    board[n][1] = 'S'\n    board[1][n] = 'E'\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if i != n and j != n:\n                board[i][j] = str(max(i + j - 2, 1))\n    assert solution.pathsWithMaxScore(board) == [18, 6]", "def test_pathsWithMaxScore():\n    solution = Solution()\n    n = 100\n    board = [['X'] * (n + 2)] * (n + 2)\n    board[n][1] = 'S'\n    board[1][n] = 'E'\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if i != n and j != n:\n                board[i][j] = str(max(i + j - 2, 1))\n    assert solution.pathsWithMaxScore(board) == [4950, 5005]", "def test_pathsWithMaxScore_mixed_values_board():\n    solution = Solution()\n    board = ['S', '1', '2'],\n             ['3', '9', '5'],\n             ['4', '8', 'E']\n    assert solution.pathsWithMaxScore(board) == [28, 6]", "def test_pathsWithMaxScore_single_value_top_left():\n    solution = Solution()\n    board = ['S', '1'],\n             ['2', 'E']\n    assert solution.pathsWithMaxScore(board) == [3, 1]", "def test_pathsWithMaxScore_single_value_bottom_right():\n    solution = Solution()\n    board = ['2', 'S'],\n             ['E', '1']\n    assert solution.pathsWithMaxScore(board) == [3, 1]", "def test_pathsWithMaxScore_single_value_diagonal():\n    solution = Solution()\n    board = ['2', 'S'],\n             ['1', 'E']\n    assert solution.pathsWithMaxScore(board) == [3, 1]", "def test_pathsWithMaxScore_single_value_corner():\n    solution = Solution()\n    board = ['S', '1'],\n             ['2', 'E']\n    assert solution.pathsWithMaxScore(board) == [3, 1]", "def test_pathsWithMaxScore_single_value_diagonal_corner():\n    solution = Solution()\n    board = ['S', '1'],\n             ['2', 'E']\n    assert solution.pathsWithMaxScore(board) == [3, 1]", "def test_pathsWithMaxScore_single_value_middle():\n    solution = Solution()\n    board = ['2', 'S'],\n             ['3', 'E']\n    assert solution.pathsWithMaxScore(board) == [5, 1]", "def test_pathsWithMaxScore():\n    solution = Solution()\n    n = 100\n    board = [['X'] * (n + 2)] * (n + 2)\n    board[n][1] = 'S'\n    board[1][n] = 'E'\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if i != n and j != n:\n                board[i][j] = str(max(i + j - 2, 1))\n    assert solution.pathsWithMaxScore(board) == [4950, 5005]"]}
{"task_num": 1334, "task_title": "Find the City With the Smallest Number of Neighbors at a Threshold Distance", "func_name": "findTheCity", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -> int:\n    ans = -1\n    minCitiesCount = n\n    dist = self._floydWarshall(n, edges, distanceThreshold)\n\n    for i in range(n):\n      citiesCount = sum(dist[i][j] <= distanceThreshold for j in range(n))\n      if citiesCount <= minCitiesCount:\n        ans = i\n        minCitiesCount = citiesCount\n\n    return ans\n\n  def _floydWarshall(self, n: int, edges: List[List[int]], distanceThreshold: int) -> List[List[int]]:\n    dist = [[distanceThreshold + 1] * n for _ in range(n)]\n\n    for i in range(n):\n      dist[i][i] = 0\n\n    for u, v, w in edges:\n      dist[u][v] = w\n      dist[v][u] = w\n\n    for k in range(n):\n      for i in range(n):\n        for j in range(n):\n          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    return dist\n", "tests": ["def test_findTheCity():\n    solution = Solution()\n    assert solution.findTheCity(4, [[0, 1, 3], [1, 2, 1], [1, 3, 4], [2, 3, 1]], 4) == 3", "def test_findTheCity():\n    solution = Solution()\n    assert solution.findTheCity(5, [], 2) == -1", "def test_findTheCity():\n    solution = Solution()\n    assert solution.findTheCity(3, [[0, 1, 2], [1, 2, 2]], 5) == 0", "def test_findTheCity():\n    solution = Solution()\n    assert solution.findTheCity(3, [[0, 1, -1], [1, 2, -1]], 0) == 2", "def test_findTheCity():\n    solution = Solution()\n    assert solution.findTheCity(1, [], 10) == 0", "def test_findTheCity():\n    solution = Solution()\n    n = 2000\n    edges = [[i, (i + 1) % n, 1] for i in range(n - 1)] + [[n - 1, 0, 1]]\n    assert solution.findTheCity(n, edges, 2) == n - 1", "def test_findTheCity():\n    solution = Solution()\n    edges = [[0, 1, 1], [0, 2, 4], [0, 3, 5], [1, 0, 1], [1, 2, 1], [1, 3, 2], [2, 0, 4], [2, 1, 1], [2, 3, 6], [3, 0, 5], [3, 1, 2], [3, 2, 6], [1, 4, 3], [2, 4, 2], [3, 4, 1]]\n    assert solution.findTheCity(5, edges, 3) == 0", "def test_findTheCity():\n    solution = Solution()\n    edges = [[0, 1, 2], [0, 1, 3], [1, 0, 4], [1, 0, 5], [2, 3, 6], [2, 3, 7], [3, 2, 8], [3, 2, 9]]\n    assert solution.findTheCity(4, edges, 10) == 2", "def test_findTheCity():\n    solution = Solution()\n    edges = [[0, 1, 2], [0, 2, 3], [0, 3, 4], [1, 0, 2], [1, 2, 1], [1, 3, 5], [2, 0, 3], [2, 1, 1], [2, 3, 6], [3, 0, 4], [3, 1, 2], [3, 2, 6]]\n    assert solution.findTheCity(4, edges, 5) == 3", "def test_findTheCity():\n    solution = Solution()\n    edges = [[0, 1, 2], [3, 4, 5]]\n    assert solution.findTheCity(5, edges, 7) == -1", "def test_findTheCity_with_all_edges_and_large_threshold():\n    solution = Solution()\n    n = 5\n    edges = [\n        [i, (i + 1) % n, 1] for i in range(n - 1)] + [[n - 1, 0, 1]]\n        + [[i, (i + 2) % n, 1] for i in range(n)]\n    ]\n    assert solution.findTheCity(n, edges, 3) == 0", "def test_findTheCity():\n    solution = Solution()\n    edges = [[0, 1, -1], [1, 2, -1], [2, 3, -1]]\n    assert solution.findTheCity(4, edges, 1) == 0", "def test_findTheCity():\n    solution = Solution()\n    edges = [[0, 1, 1], [0, 2, 4], [0, 3, 5], [1, 0, 1], [1, 2, 1], [1, 3, 2], [2, 0, 4], [2, 1, 1], [2, 3, 6], [3, 0, 5], [3, 1, 2], [3, 2, 6], [1, 4, 3], [2, 4, 2], [3, 4, 1]]\n    assert solution.findTheCity(5, edges, 9) == 0", "def test_findTheCity():\n    solution = Solution()\n    edges = [[0, 1, 2], [0, 2, 3], [0, 3, 4], [1, 0, 2], [1, 2, 1], [1, 3, 5], [2, 0, 3], [2, 1, 1], [2, 3, 6], [3, 0, 4], [3, 1, 5], [3, 2, 6]]\n    assert solution.findTheCity(4, edges, 8) == 3", "def test_findTheCity():\n    solution = Solution()\n    edges = [[0, 1, 10], [2, 3, 5]]\n    assert solution.findTheCity(4, edges, 7) == -1", "def test_findTheCity():\n    solution = Solution()\n    edges = [[0, 1, 2], [0, 2, 3], [0, 3, 4], [1, 0, 2], [1, 2, 1], [1, 3, 5], [2, 0, 3], [2, 1, 1], [2, 3, 6], [3, 0, 4], [3, 1, 5], [3, 2, 6]]\n    assert solution.findTheCity(4, edges, 2) == -1", "def test_findTheCity():\n    solution = Solution()\n    n = 100\n    edges = [[i, (i + 1) % n, 1] for i in range(n - 1)] + [[n - 1, 0, 1]]\n    assert solution.findTheCity(n, edges, 2) == 0", "def test_findTheCity():\n    solution = Solution()\n    n = 100\n    edges = [[i, (i + 1) % n, 1] for i in range(n - 1)] + [[n - 1, 0, 1]]\n    assert solution.findTheCity(n, edges, 2) == 0", "def test_findTheCity():\n    solution = Solution()\n    n = 100\n    edges = [[i, (i + 1) % n, 1] for i in range(n - 1)] + [[n - 1, 0, 1]]\n    assert solution.findTheCity(n, edges, 2) == 0", "def test_findTheCity():\n    solution = Solution()\n    n = 100\n    edges = [[i, (i + 1) % n, 1] for i in range(n - 1)] + [[n - 1, 0, 1]]\n    assert solution.findTheCity(n, edges, 2) == 0"]}
{"task_num": 1340, "task_title": "Jump Game V", "func_name": "maxJumps", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxJumps(self, arr: List[int], d: int) -> int:\n    n = len(arr)\n    dp = [1] * n\n    stack = []\n\n    for i in range(n + 1):\n      while stack and (i == n or arr[stack[-1]] < arr[i]):\n        indices = [stack.pop()]\n        while stack and arr[stack[-1]] == arr[indices[0]]:\n          indices.append(stack.pop())\n        for j in indices:\n          if i < n and i - j <= d:\n            dp[i] = max(dp[i], dp[j] + 1)\n          if stack and j - stack[-1] <= d:\n            dp[stack[-1]] = max(dp[stack[-1]], dp[j] + 1)\n      stack.append(i)\n\n    return max(dp)\n", "tests": ["def test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([6, 4, 14, 6, 8, 19, 10, 14, 18], 2) == 3", "def test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([1, 2, 3, 4, 5], 1) == 5", "def test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([10, 9, 8, 7, 6], 3) == 1", "def test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([5, 4, 3, 2, 1], 2) == 1", "def test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([50], 10) == 1", "def test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([1, 2, 3, 4, 5, 6], 1) == 6", "def test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([30, 20, 10], 2) == 1", "def test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([5, 4, 3, 2, 1, 2, 3, 4, 5], 2) == 5", "def test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([2, 3, 5, 6, 4], 2) == 3", "def test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([10, 2, 3, 5], 3) == 4", "def test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([1, 2, 3, 4], 0) == 1", "def test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([20, 10, 30, 40], 3) == 4", "def test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([1, 2], 1) == 2", "def test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([100], 5) == 1", "def test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([5, 4, 3, 2], 1) == 1", "def test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([10, 20, 30, 40], 1) == 1", "def test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([1, 3, 2], 1) == 2", "def test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([5, 6, 7, 8, 9], 2) == 5", "def test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([10, 9, 8, 7, 6], 2) == 1", "def test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([1, 3, 2], 2) == 3"]}
{"task_num": 1345, "task_title": "Jump Game IV", "func_name": "minJumps", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minJumps(self, arr: List[int]) -> int:\n    n = len(arr)\n    graph = collections.defaultdict(list)\n    step = 0\n    q = collections.deque([0])\n    seen = {0}\n\n    for i, a in enumerate(arr):\n      graph[a].append(i)\n\n    while q:\n      for _ in range(len(q)):\n        i = q.popleft()\n        if i == n - 1:\n          return step\n        seen.add(i)\n        u = arr[i]\n        if i + 1 < n:\n          graph[u].append(i + 1)\n        if i - 1 >= 0:\n          graph[u].append(i - 1)\n        for v in graph[u]:\n          if v in seen:\n            continue\n          q.append(v)\n        graph[u].clear()\n      step += 1\n", "tests": ["def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([10, 3, 8, 9, 1]) == 2", "def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([4, 1, 2, 3, 5]) == 1", "def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([7, 6, 9, 6, 9, 6, 9]) == 2", "def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([1]) == 0", "def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([5, 1, 2, 3, 4]) == 4", "def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([2, 3, 10, 6, 4, 8, 1]) == 3", "def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([1, 2, 3, 4, 5]) == 4", "def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([5, 4, 3, 2, 1]) == 4", "def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([1, 2, 3, 4, 5, 6]) == 5", "def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([10, 20, 30, 40, 50]) == 4", "def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([100, 200, 300, 400, 500, 100]) == 2", "def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([0, 1, 2, 3, 4, 5]) == 5", "def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([0, 1, 2, 3, 4, 5, 6]) == 6", "def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([10, 9, 8, 7, 6]) == 4", "def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([10, 9, 8, 7, 6, 5]) == 5", "def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([10, 9, 8, 7, 6, 5, 4]) == 6", "def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([10, 9, 8, 7, 6, 5, 4, 3]) == 7", "def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([10, 9, 8, 7, 6, 5, 4, 3, 2]) == 8", "def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == 9", "def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]) == 10"]}
{"task_num": 1377, "task_title": "Frog Position After T Seconds", "func_name": "frogPosition", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n    tree = [[] for _ in range(n + 1)]\n    q = collections.deque([1])\n    seen = [False] * (n + 1)\n    prob = [0] * (n + 1)\n\n    prob[1] = 1\n    seen[1] = True\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    for _ in range(t):\n      for _ in range(len(q)):\n        a = q.popleft()\n        nChildren = sum(not seen[b] for b in tree[a])\n        for b in tree[a]:\n          if seen[b]:\n            continue\n          seen[b] = True\n          prob[b] = prob[a] / nChildren\n          q.append(b)\n        if nChildren > 0:\n          prob[a] = 0\n\n    return prob[target]\n", "tests": ["def test_frogPosition():\n    solution = Solution()\n    assert abs(solution.frogPosition(7, [[1, 2], [1, 3], [1, 4], [2, 5], [2, 6], [2, 7]], 2, 7) - 0.125) < 1e-05", "def test_frogPosition():\n    solution = Solution()\n    assert abs(solution.frogPosition(3, [[1, 2], [1, 3]], 0, 2) - 0.5) < 1e-05", "def test_frogPosition():\n    solution = Solution()\n    assert abs(solution.frogPosition(5, [[1, 2], [1, 3], [2, 4], [2, 5]], 4, 5) - 0.016) < 1e-05", "def test_frogPosition():\n    solution = Solution()\n    assert abs(solution.frogPosition(6, [[1, 2], [1, 3], [2, 4], [2, 5], [3, 6]], 2, 4) - 0.25) < 1e-05", "def test_frogPosition():\n    solution = Solution()\n    assert abs(solution.frogPosition(10, [[1, 2], [1, 3], [2, 4], [2, 5], [3, 6], [3, 7], [4, 8], [4, 9], [4, 10]], 3, 10) - 0.01) < 1e-05", "def test_frogPosition():\n    solution = Solution()\n    assert abs(solution.frogPosition(2, [[1, 2]], 1, 2) - 0.5) < 1e-05", "def test_frogPosition():\n    solution = Solution()\n    assert abs(solution.frogPosition(4, [[1, 2], [1, 3], [2, 4]], 0, 1) - 1.0) < 1e-05", "def test_frogPosition():\n    solution = Solution()\n    assert abs(solution.frogPosition(10, [[1, 2], [1, 3], [2, 4], [2, 5], [3, 6], [3, 7], [4, 8], [4, 9], [4, 10]], 1, 5) - 0.5) < 1e-05", "def test_frogPosition():\n    solution = Solution()\n    assert abs(solution.frogPosition(6, [[1, 2], [1, 3], [2, 4], [2, 5], [3, 6]], 0, 6) - 0.0) < 1e-05", "def test_frogPosition():\n    solution = Solution()\n    assert abs(solution.frogPosition(10, [[1, 2], [1, 3], [2, 4], [2, 5], [3, 6], [3, 7], [4, 8], [4, 9], [4, 10]], 5, 5) - 0.03125) < 1e-05", "def test_frogPosition():\n    solution = Solution()\n    assert abs(solution.frogPosition(10, [[1, 2], [1, 3], [2, 4], [2, 5], [3, 6], [3, 7], [4, 8], [4, 9], [4, 10]], 3, 3) - 0.125) < 1e-05", "def test_frogPosition():\n    solution = Solution()\n    assert abs(solution.frogPosition(10, [[1, 2], [1, 3], [2, 4], [2, 5], [3, 6], [3, 7], [4, 8], [4, 9], [4, 10]], 0, 1) - 1.0) < 1e-05", "def test_frogPosition():\n    solution = Solution()\n    assert abs(solution.frogPosition(8, [[1, 2], [1, 3], [2, 4], [2, 5], [3, 6], [3, 7]], 1, 4) - 0.33333) < 1e-05", "def test_frogPosition():\n    solution = Solution()\n    assert abs(solution.frogPosition(6, [[1, 2], [1, 3], [2, 4], [2, 5], [3, 6]], 0, 4) - 0.0) < 1e-05", "def test_frogPosition():\n    solution = Solution()\n    assert abs(solution.frogPosition(7, [[1, 2], [1, 3], [1, 4], [2, 5], [2, 6], [2, 7]], 2, 1) - 0.5) < 1e-05", "def test_frogPosition():\n    solution = Solution()\n    assert abs(solution.frogPosition(10, [[1, 2], [1, 3], [2, 4], [2, 5], [3, 6], [3, 7], [4, 8], [4, 9], [4, 10]], 4, 8) - 0.125) < 1e-05", "def test_frogPosition():\n    solution = Solution()\n    assert abs(solution.frogPosition(10, [[1, 2], [1, 3], [2, 4], [2, 5], [3, 6], [3, 7], [4, 8], [4, 9], [4, 10]], 3, 6) - 0.25) < 1e-05", "def test_frogPosition():\n    solution = Solution()\n    assert abs(solution.frogPosition(10, [[1, 2], [1, 3], [2, 4], [2, 5], [3, 6], [3, 7], [4, 8], [4, 9], [4, 10]], 2, 2) - 1.0) < 1e-05", "def test_frogPosition():\n    solution = Solution()\n    assert abs(solution.frogPosition(10, [[1, 2], [1, 3], [2, 4], [2, 5], [3, 6], [3, 7], [4, 8], [4, 9], [4, 10]], 1, 3) - 0.5) < 1e-05", "def test_frogPosition():\n    solution = Solution()\n    assert abs(solution.frogPosition(10, [[1, 2], [1, 3], [2, 4], [2, 5], [3, 6], [3, 7], [4, 8], [4, 9], [4, 10]], 5, 1) - 0.5) < 1e-05"]}
{"task_num": 1417, "task_title": "Reformat The String", "func_name": "reformat", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def reformat(self, s: str) -> str:\n    A=[]\n    for c in s:\n      if c.isalpha():\n        A.append(c)\n    B=[]\n    for c in s:\n      if c.isdigit():\n        B.append(c)\n\n    if len(A) < len(B):\n      A, B = B, A\n    if len(A) - len(B) > 1:\n      return ''\n\n    ans = []\n\n    for i in range(len(B)):\n      ans.append(A[i])\n      ans.append(B[i])\n\n    if len(A) == len(B) + 1:\n      ans.append(A[-1])\n    return ''.join(ans)\n", "tests": ["def test_reformat():\n    solution = Solution()\n    result = solution.reformat('a0b1c2')", "def test_reformat():\n    solution = Solution()\n    result = solution.reformat('abc123')", "def test_reformat():\n    solution = Solution()\n    result = solution.reformat('')", "def test_reformat():\n    solution = Solution()\n    result = solution.reformat('aaa123')", "def test_reformat():\n    solution = Solution()\n    result = solution.reformat('a')", "def test_reformat():\n    solution = Solution()\n    result = solution.reformat('1')", "def test_reformat():\n    solution = Solution()\n    result = solution.reformat('abc12345')", "def test_reformat():\n    solution = Solution()\n    result = solution.reformat('abcdefghijklmnopqrstuvwxyz0123456789')", "def test_reformat():\n    solution = Solution()\n    result = solution.reformat('a1b2c3d4e5f6g7h8i9j0')", "def test_reformat():\n    solution = Solution()\n    result = solution.reformat('a1b2c3')", "def test_reformat():\n    solution = Solution()\n    result = solution.reformat('1a2b3c')", "def test_reformat():\n    solution = Solution()\n    result = solution.reformat('aBc123')", "def test_reformat():\n    solution = Solution()\n    result = solution.reformat('aBcDeFgHiJkLmNoPqRsTuVwXyZ1234567890')", "def test_reformat():\n    solution = Solution()\n    result = solution.reformat('aB1c2')", "def test_reformat():\n    solution = Solution()\n    result = solution.reformat('aBc')", "def test_reformat():\n    solution = Solution()\n    result = solution.reformat('a1Bc2D')", "def test_reformat():\n    solution = Solution()\n    result = solution.reformat('a1Bc2D3E4F5G6H7I8J9K0L')", "def test_reformat():\n    solution = Solution()\n    result = solution.reformat('aB1c2D3E4F5G6H7I8J9K0L')", "def test_reformat():\n    solution = Solution()\n    result = solution.reformat('L0K9J8I7H6G5F4E3D2C1B0a')", "def test_reformat():\n    solution = Solution()\n    result = solution.reformat('L0K9J8I7H6G5F4E3D2C1B0a')"]}
{"task_num": 1462, "task_title": "Course Schedule IV", "func_name": "checkIfPrerequisite", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:\n    graph = [[] for _ in range(numCourses)]\n    isPrerequisite = [[False] * numCourses for _ in range(numCourses)]\n\n    for u, v in prerequisites:\n      graph[u].append(v)\n\n    for i in range(numCourses):\n      self._dfs(graph, i, isPrerequisite[i])\n\n    return [isPrerequisite[u][v] for u, v in queries]\n\n  def _dfs(self, graph: List[List[int]], u: int, used: List[bool]) -> None:\n    for v in graph[u]:\n      if used[v]:\n        continue\n      used[v] = True\n      self._dfs(graph, v, used)\n", "tests": ["def test_checkIfPrerequisite():\n    solution = Solution()\n    numCourses = 3\n    prerequisites = [[0, 1], [1, 2]]\n    queries = [[0, 2]]\n    expected = [True]\n    assert solution.checkIfPrerequisite(numCourses, prerequisites, queries) == expected", "def test_checkIfPrerequisite():\n    solution = Solution()\n    numCourses = 4\n    prerequisites = [[0, 1], [1, 2], [2, 3]]\n    queries = [[0, 3], [1, 2], [3, 0]]\n    expected = [True, True, False]\n    assert solution.checkIfPrerequisite(numCourses, prerequisites, queries) == expected", "def test_checkIfPrerequisite():\n    solution = Solution()\n    numCourses = 5\n    prerequisites = []\n    queries = [[0, 1], [2, 3], [4, 0]]\n    expected = [False, False, False]\n    assert solution.checkIfPrerequisite(numCourses, prerequisites, queries) == expected", "def test_checkIfPrerequisite():\n    solution = Solution()\n    numCourses = 1\n    prerequisites = []\n    queries = [[0, 0]]\n    expected = [True]\n    assert solution.checkIfPrerequisite(numCourses, prerequisites, queries) == expected", "def test_checkIfPrerequisite():\n    solution = Solution()\n    numCourses = 2\n    prerequisites = [[0, 1], [1, 0]]\n    queries = [[0, 1], [1, 0]]\n    expected = [False, False]\n    assert solution.checkIfPrerequisite(numCourses, prerequisites, queries) == expected", "def test_checkIfPrerequisite():\n    solution = Solution()\n    numCourses = 3\n    prerequisites = [[0, 1], [1, 2], [0, 2]]\n    queries = [[0, 2]]\n    expected = [True]\n    assert solution.checkIfPrerequisite(numCourses, prerequisites, queries) == expected", "def test_checkIfPrerequisite():\n    solution = Solution()\n    numCourses = 5\n    prerequisites = [[0, 1], [1, 2], [2, 3], [3, 4], [1, 3]]\n    queries = [[0, 4], [2, 0], [1, 4], [4, 1]]\n    expected = [True, False, True, False]\n    assert solution.checkIfPrerequisite(numCourses, prerequisites, queries) == expected", "def test_checkIfPrerequisite():\n    solution = Solution()\n    numCourses = 100\n    prerequisites = [[i, i + 1] for i in range(numCourses - 1)]\n    queries = [(i, i + 2) for i in range(numCourses - 2)]\n    expected = [False] * (numCourses - 2)\n    assert solution.checkIfPrerequisite(numCourses, prerequisites, queries) == expected", "def test_checkIfPrerequisite():\n    solution = Solution()\n    numCourses = 3\n    prerequisites = [[0, 1], [1, 2]]\n    queries = []\n    expected = []\n    assert solution.checkIfPrerequisite(numCourses, prerequisites, queries) == expected", "def test_checkIfPrerequisite():\n    solution = Solution()\n    numCourses = 4\n    prerequisites = [[0, 1], [1, 2], [2, 3], [3, 0]]\n    queries = [[0, 2], [2, 0]]\n    expected = [True, False]\n    assert solution.checkIfPrerequisite(numCourses, prerequisites, queries) == expected", "def test_checkIfPrerequisite():\n    solution = Solution()\n    numCourses = 2\n    prerequisites = [[0, 0]]\n    queries = [[0, 0]]\n    expected = [True]\n    assert solution.checkIfPrerequisite(numCourses, prerequisites, queries) == expected", "def test_checkIfPrerequisite():\n    solution = Solution()\n    numCourses = 2\n    prerequisites = [[0, 1]]\n    queries = [[0, 1]]\n    expected = [True]\n    assert solution.checkIfPrerequisite(numCourses, prerequisites, queries) == expected", "def test_checkIfPrerequisite():\n    solution = Solution()\n    numCourses = 5\n    prerequisites = []\n    queries = [[0, 1], [2, 3], [4, 0]]\n    expected = [False, False, False]\n    assert solution.checkIfPrerequisite(numCourses, prerequisites, queries) == expected", "def test_checkIfPrerequisite():\n    solution = Solution()\n    numCourses = 3\n    prerequisites = [[0, 1], [1, 2], [0, 2]]\n    queries = [[0, 2], [1, 0], [2, 1]]\n    expected = [True, False, True]\n    assert solution.checkIfPrerequisite(numCourses, prerequisites, queries) == expected", "def test_checkIfPrerequisite():\n    solution = Solution()\n    numCourses = 1000\n    prerequisites = [[i, i + 1] for i in range(numCourses - 1)]\n    queries = [(i, i + 2) for i in range(numCourses - 3)] + [(i, i - 2) for i in range(2, numCourses)] + [(numCourses // 2 - 1, numCourses // 2 + 1)]\n    expected = [False] * (numCourses - 3) + [True] * (numCourses - 5) + [False]\n    assert solution.checkIfPrerequisite(numCourses, prerequisites, queries) == expected", "def test_checkIfPrerequisite():\n    solution = Solution()\n    numCourses = 0\n    prerequisites = []\n    queries = []\n    expected = []\n    assert solution.checkIfPrerequisite(numCourses, prerequisites, queries) == expected", "def test_checkIfPrerequisite():\n    solution = Solution()\n    numCourses = 1\n    prerequisites = []\n    queries = [[0, 0]]\n    expected = [True]\n    assert solution.checkIfPrerequisite(numCourses, prerequisites, queries) == expected", "def test_checkIfPrerequisite():\n    solution = Solution()\n    numCourses = 2\n    prerequisites = [[0, 1]]\n    queries = [[1, 0]]\n    expected = [False]\n    assert solution.checkIfPrerequisite(numCourses, prerequisites, queries) == expected", "def test_checkIfPrerequisite():\n    solution = Solution()\n    numCourses = 2\n    prerequisites = [[0, 1]]\n    queries = [[0, 1]]\n    expected = [True]\n    assert solution.checkIfPrerequisite(numCourses, prerequisites, queries) == expected", "def test_checkIfPrerequisite():\n    solution = Solution()\n    numCourses = 3\n    prerequisites = [[0, 1]]\n    queries = [[0, 2], [1, 2]]\n    expected = [False, True]\n    assert solution.checkIfPrerequisite(numCourses, prerequisites, queries) == expected"]}
{"task_num": 1489, "task_title": "Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree", "func_name": "findCriticalAndPseudoCriticalEdges", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Union\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n    criticalEdges = []\n    pseudoCriticalEdges = []\n\n    for i in range(len(edges)):\n      edges[i].append(i)\n\n    edges.sort(key=lambda x: x[2])\n\n    def getMSTWeight(firstEdge: List[int], deletedEdgeIndex: int) -> Union[int, float]:\n      mstWeight = 0\n      uf = UnionFind(n)\n\n      if firstEdge:\n        uf.unionByRank(firstEdge[0], firstEdge[1])\n        mstWeight += firstEdge[2]\n\n      for u, v, weight, index in edges:\n        if index == deletedEdgeIndex:\n          continue\n        if uf.find(u) == uf.find(v):\n          continue\n        uf.unionByRank(u, v)\n        mstWeight += weight\n\n      root = uf.find(0)\n      if any(uf.find(i) != root for i in range(n)):\n        return math.inf\n\n      return mstWeight\n\n    mstWeight = getMSTWeight([], -1)\n\n    for edge in edges:\n      index = edge[3]\n      if getMSTWeight([], index) > mstWeight:\n        criticalEdges.append(index)\n      elif getMSTWeight(edge, -1) == mstWeight:\n        pseudoCriticalEdges.append(index)\n\n    return [criticalEdges, pseudoCriticalEdges]\n", "tests": ["def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 0, 1]]\n    expected_output = [[1, 3], [0, 2, 4]]\n    assert solution.findCriticalAndPseudoCriticalEdges(n, edges) == expected_output", "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 1], [1, 2, 2], [2, 3, 3]]\n    expected_output = [[], [0, 1, 2]]\n    assert solution.findCriticalAndPseudoCriticalEdges(n, edges) == expected_output", "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 6\n    edges = [[0, 1, 4], [1, 2, 3], [2, 3, 5], [3, 4, 1], [4, 5, 2]]\n    expected_output = [[], [1, 3]]\n    assert solution.findCriticalAndPseudoCriticalEdges(n, edges) == expected_output", "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 2], [0, 2, 3], [1, 2, 5]]\n    expected_output = [[0], [1, 2]]\n    assert solution.findCriticalAndPseudoCriticalEdges(n, edges) == expected_output", "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 2], [1, 2, 2]]\n    expected_output = [[], [0, 1]]\n    assert solution.findCriticalAndPseudoCriticalEdges(n, edges) == expected_output", "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 1], [0, 2, 5], [1, 3, 1], [2, 3, 1]]\n    expected_output = [[], [0, 1, 2, 3]]\n    assert solution.findCriticalAndPseudoCriticalEdges(n, edges) == expected_output", "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 1], [1, 2, 2], [2, 3, 3], [3, 4, 4], [0, 4, 5]]\n    expected_output = [[], [0, 1, 2, 3, 4]]\n    assert solution.findCriticalAndPseudoCriticalEdges(n, edges) == expected_output", "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 1], [1, 2, 1]]\n    expected_output = [[], [0, 1]]\n    assert solution.findCriticalAndPseudoCriticalEdges(n, edges) == expected_output", "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 3], [1, 2, 5], [2, 3, 4], [3, 0, 6]]\n    expected_output = [[], [0, 1, 2, 3]]\n    assert solution.findCriticalAndPseudoCriticalEdges(n, edges) == expected_output", "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5]]\n    expected_output = [[1, 3], [0, 2, 4]]\n    assert solution.findCriticalAndPseudoCriticalEdges(n, edges) == expected_output", "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 2], [0, 3, 1], [1, 3, 3]]\n    expected_output = [[], [1, 2]]\n    assert solution.findCriticalAndPseudoCriticalEdges(n, edges) == expected_output", "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 6\n    edges = [[0, 1, 4], [1, 2, 3], [2, 3, 5], [3, 4, 1], [4, 5, 2], [0, 5, 8]]\n    expected_output = [[], [0, 1, 2, 3, 4, 5]]\n    assert solution.findCriticalAndPseudoCriticalEdges(n, edges) == expected_output", "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 1], [0, 2, 5], [1, 2, 1]]\n    expected_output = [[], [0, 1, 2]]\n    assert solution.findCriticalAndPseudoCriticalEdges(n, edges) == expected_output", "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 2], [0, 3, 1], [1, 2, 2]]\n    expected_output = [[], [1, 2]]\n    assert solution.findCriticalAndPseudoCriticalEdges(n, edges) == expected_output", "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 3], [1, 2, 4], [2, 3, 5], [3, 4, 6]]\n    expected_output = [[], [0, 1, 2, 3, 4, 5]]\n    assert solution.findCriticalAndPseudoCriticalEdges(n, edges) == expected_output", "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 2], [1, 2, 2]]\n    expected_output = [[], [0, 1]]\n    assert solution.findCriticalAndPseudoCriticalEdges(n, edges) == expected_output", "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 1], [0, 2, 5], [1, 3, 1], [2, 3, 3]]\n    expected_output = [[], [0, 1, 2, 3]]\n    assert solution.findCriticalAndPseudoCriticalEdges(n, edges) == expected_output", "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5]]\n    expected_output = [[1, 3], [0, 2, 4]]\n    assert solution.findCriticalAndPseudoCriticalEdges(n, edges) == expected_output", "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 6\n    edges = [[0, 1, 4], [1, 2, 3], [2, 3, 5], [3, 4, 1], [4, 5, 2]]\n    expected_output = [[], [0, 1, 2, 3, 4, 5]]\n    assert solution.findCriticalAndPseudoCriticalEdges(n, edges) == expected_output", "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 2], [0, 2, 5], [1, 2, 1]]\n    expected_output = [[], [0, 1, 2]]\n    assert solution.findCriticalAndPseudoCriticalEdges(n, edges) == expected_output"]}
{"task_num": 1573, "task_title": "Number of Ways to Split a String", "func_name": "numWays", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numWays(self, s: str) -> int:\n    kMod = 1_000_000_007\n    ones = s.count('1')\n    if ones % 3 != 0:\n      return 0\n    if ones == 0:\n      n = len(s)\n      return (n - 1) * (n - 2) // 2 % kMod\n\n    s1End = -1\n    s2Start = -1\n    s2End = -1\n    s3Start = -1\n    onesSoFar = 0\n\n    for i, c in enumerate(s):\n      if c == '1':\n        onesSoFar += 1\n      if s1End == -1 and onesSoFar == ones // 3:\n        s1End = i\n      elif s2Start == -1 and onesSoFar == ones // 3 + 1:\n        s2Start = i\n      if s2End == -1 and onesSoFar == ones // 3 * 2:\n        s2End = i\n      elif s3Start == -1 and onesSoFar == ones // 3 * 2 + 1:\n        s3Start = i\n\n    return (s2Start - s1End) * (s3Start - s2End) % kMod\n", "tests": ["def test_numWays():\n    solution = Solution()\n    result = solution.numWays('100100100')", "def test_numWays():\n    solution = Solution()\n    result = solution.numWays('000')", "def test_numWays():\n    solution = Solution()\n    result = solution.numWays('1')", "def test_numWays():\n    solution = Solution()\n    result = solution.numWays('11011')", "def test_numWays():\n    solution = Solution()\n    result = solution.numWays('111')", "def test_numWays():\n    solution = Solution()\n    result = solution.numWays('101')", "def test_numWays():\n    solution = Solution()\n    result = solution.numWays('1000000000000000000000000000001')", "def test_numWays():\n    solution = Solution()\n    result = solution.numWays('0000')", "def test_numWays():\n    solution = Solution()\n    result = solution.numWays('1010101')", "def test_numWays():\n    solution = Solution()\n    result = solution.numWays('10001')", "def test_numWays():\n    solution = Solution()\n    result = solution.numWays('111001')", "def test_numWays():\n    solution = Solution()\n    result = solution.numWays('1100000011')", "def test_numWays():\n    solution = Solution()\n    result = solution.numWays('10001')", "def test_numWays():\n    solution = Solution()\n    result = solution.numWays('1100000011')", "def test_numWays():\n    solution = Solution()\n    result = solution.numWays('100001')", "def test_numWays():\n    solution = Solution()\n    result = solution.numWays('010')", "def test_numWays():\n    solution = Solution()\n    result = solution.numWays('111')", "def test_numWays():\n    solution = Solution()\n    result = solution.numWays('000')", "def test_numWays():\n    solution = Solution()\n    result = solution.numWays('10001')", "def test_numWays():\n    solution = Solution()\n    result = solution.numWays('1000000011')"]}
{"task_num": 1574, "task_title": "Shortest Subarray to be Removed to Make Array Sorted", "func_name": "findLengthOfShortestSubarray", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n    n = len(arr)\n    l = 0\n    r = n - 1\n\n    while l < n - 1 and arr[l + 1] >= arr[l]:\n      l += 1\n    while r > 0 and arr[r - 1] <= arr[r]:\n      r -= 1\n    ans = min(n - 1 - l, r)\n\n    i = l\n    j = n - 1\n    while i >= 0 and j >= r and j > i:\n      if arr[i] <= arr[j]:\n        j -= 1\n      else:\n        i -= 1\n      ans = min(ans, j - i)\n\n    return ans\n", "tests": ["def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([1, 2, 3, 4, 5]) == 0", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([5, 4, 3, 2, 1]) == 4", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([1]) == 0", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([1, 2, 3, 5, 4]) == 1", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([5, 1, 3, 2, 4]) == 3", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([1, 3, 2]) == 2", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([2, 3, 1]) == 2", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([10, 20, 30, 40, 50]) == 0", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([10, 20, 30, 40, 50]) == 0", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([10]) == 0", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([10, 20, 30, 40, 50]) == 0", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([10]) == 0", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([10]) == 0", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([10]) == 0", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([10]) == 0", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([10]) == 0", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([10]) == 0", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([10]) == 0", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([10]) == 0", "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([]) == 0"]}
{"task_num": 1579, "task_title": "Remove Max Number of Edges to Keep Graph Fully Traversable", "func_name": "maxNumEdgesToRemove", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    self.count -= 1\n    return True\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\n    alice = UnionFind(n)\n    bob = UnionFind(n)\n    requiredEdges = 0\n\n    for type, u, v in sorted(edges, reverse=True):\n      u -= 1\n      v -= 1\n      if type == 3:\n        if alice.unionByRank(u, v) | bob.unionByRank(u, v):\n          requiredEdges += 1\n      elif type == 2:\n        if bob.unionByRank(u, v):\n          requiredEdges += 1\n      else:\n        if alice.unionByRank(u, v):\n          requiredEdges += 1\n\n    if alice.count == 1 and bob.count == 1:\n        return len(edges) - requiredEdges\n    else:\n        return -1\n", "tests": ["def test_maxNumEdgesToRemove():\n    solution = Solution()\n    assert solution.maxNumEdgesToRemove(4, [[3, 1, 2], [3, 2, 3], [3, 3, 4], [1, 1, 2], [2, 3, 4]]) == 1", "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    assert solution.maxNumEdgesToRemove(3, [[3, 1, 2], [3, 2, 3], [2, 1, 3]]) == -1", "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    assert solution.maxNumEdgesToRemove(3, [[3, 1, 2], [3, 2, 3], [1, 1, 3], [2, 1, 2]]) == -1", "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    assert solution.maxNumEdgesToRemove(4, [[3, 1, 2], [3, 2, 3], [3, 3, 4], [1, 1, 2], [1, 2, 3], [2, 3, 4]]) == 0", "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    assert solution.maxNumEdgesToRemove(5, [[3, 1, 2], [3, 2, 4], [3, 4, 5], [3, 5, 1], [1, 1, 2], [1, 2, 4], [2, 4, 5], [2, 5, 1]]) == 0", "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    assert solution.maxNumEdgesToRemove(3, [[3, 1, 2], [3, 2, 3], [3, 1, 3]]) == -1", "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    assert solution.maxNumEdgesToRemove(4, [[3, 1, 2], [3, 2, 3], [3, 3, 4], [1, 1, 2], [2, 2, 3], [2, 3, 4]]) == 1", "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    assert solution.maxNumEdgesToRemove(4, [[3, 1, 2], [3, 2, 3], [3, 3, 4], [1, 1, 2], [2, 3, 4]]) == 1", "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    assert solution.maxNumEdgesToRemove(5, [[3, 1, 2], [3, 2, 4], [3, 4, 5], [3, 5, 1], [1, 1, 2], [1, 2, 4], [2, 4, 5], [2, 5, 1]]) == 0", "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    assert solution.maxNumEdgesToRemove(3, [[3, 1, 2], [3, 2, 3], [3, 1, 3]]) == -1", "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    assert solution.maxNumEdgesToRemove(5, [[3, 1, 2], [3, 2, 4], [3, 4, 5], [3, 5, 1], [1, 1, 2], [1, 2, 4], [2, 4, 5], [2, 5, 1]]) == 0", "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    assert solution.maxNumEdgesToRemove(4, [[3, 1, 2], [3, 2, 3], [3, 3, 4], [1, 1, 2], [2, 3, 4]]) == 1", "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    assert solution.maxNumEdgesToRemove(5, [[3, 1, 2], [3, 2, 4], [3, 4, 5], [3, 5, 1], [1, 1, 2], [1, 2, 4], [2, 4, 5], [2, 5, 1]]) == 0", "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    assert solution.maxNumEdgesToRemove(3, [[3, 1, 2], [3, 2, 3], [3, 1, 3]]) == -1", "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    assert solution.maxNumEdgesToRemove(4, [[3, 1, 2], [3, 2, 3], [3, 3, 4], [1, 1, 2], [2, 3, 4]]) == 1", "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    assert solution.maxNumEdgesToRemove(5, [[3, 1, 2], [3, 2, 4], [3, 4, 5], [3, 5, 1], [1, 1, 2], [1, 2, 4], [2, 4, 5], [2, 5, 1]]) == 0", "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    assert solution.maxNumEdgesToRemove(3, [[3, 1, 2], [3, 2, 3], [3, 1, 3]]) == -1", "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    assert solution.maxNumEdgesToRemove(4, [[3, 1, 2], [3, 2, 3], [3, 3, 4], [1, 1, 2], [2, 3, 4]]) == 1", "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    assert solution.maxNumEdgesToRemove(5, [[3, 1, 2], [3, 2, 4], [3, 4, 5], [3, 5, 1], [1, 1, 2], [1, 2, 4], [2, 4, 5], [2, 5, 1]]) == 0", "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    assert solution.maxNumEdgesToRemove(3, [[3, 1, 2], [3, 2, 3], [3, 1, 3]]) == -1"]}
{"task_num": 1582, "task_title": "Special Positions in a Binary Matrix", "func_name": "numSpecial", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numSpecial(self, mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    ans = 0\n    rowOnes = [0] * m\n    colOnes = [0] * n\n\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j] == 1:\n          rowOnes[i] += 1\n          colOnes[j] += 1\n\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j] == 1 and rowOnes[i] == 1 and colOnes[j] == 1:\n          ans += 1\n\n    return ans\n", "tests": ["def test_numSpecial():\n    solution = Solution()\n    assert solution.numSpecial([[1, 0, 0], [0, 0, 0], [0, 0, 0]]) == 1", "def test_numSpecial():\n    solution = Solution()\n    assert solution.numSpecial([[1, 0, 0], [0, 1, 0], [0, 0, 1]]) == 3", "def test_numSpecial():\n    solution = Solution()\n    assert solution.numSpecial([[0, 0, 0], [0, 0, 0]]) == 0", "def test_numSpecial():\n    solution = Solution()\n    assert solution.numSpecial([[1, 1, 1], [0, 0, 0], [1, 1, 1]]) == 0", "def test_numSpecial():\n    solution = Solution()\n    assert solution.numSpecial([[0, 1, 0], [1, 0, 1], [0, 1, 0]]) == 4", "def test_numSpecial():\n    solution = Solution()\n    assert solution.numSpecial([[1, 0], [0, 0], [0, 1]]) == 2", "def test_numSpecial():\n    solution = Solution()\n    assert solution.numSpecial([[0, 0], [0, 0]]) == 0", "def test_numSpecial():\n    solution = Solution()\n    assert solution.numSpecial([[1, 1], [1, 1]]) == 0", "def test_numSpecial():\n    solution = Solution()\n    assert solution.numSpecial([[1]]) == 1", "def test_numSpecial():\n    solution = Solution()\n    assert solution.numSpecial([[0]]) == 0", "def test_numSpecial():\n    solution = Solution()", "def test_numSpecial():\n    solution = Solution()", "def test_numSpecial():\n    solution = Solution()", "def test_numSpecial():\n    solution = Solution()", "def test_numSpecial():\n    solution = Solution()", "def test_numSpecial():\n    solution = Solution()", "def test_numSpecial():\n    solution = Solution()", "def test_numSpecial():\n    solution = Solution()", "def test_numSpecial():\n    solution = Solution()", "def test_numSpecial():\n    solution = Solution()"]}
{"task_num": 1583, "task_title": "Count Unhappy Friends", "func_name": "unhappyFriends", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\n    ans = 0\n    matches = [0] * n\n    prefer = [{} for _ in range(n)]\n\n    for x, y in pairs:\n      matches[x] = y\n      matches[y] = x\n\n    for i in range(n):\n      for j in range(n - 1):\n        prefer[i][preferences[i][j]] = j\n\n    for x in range(n):\n      for u in prefer[x].keys():\n        y = matches[x]\n        v = matches[u]\n        if prefer[x][u] < prefer[x][y] and prefer[u][x] < prefer[u][v]:\n          ans += 1\n          break\n\n    return ans\n", "tests": ["def test_unhappyFriends():\n    solution = Solution()\n    n = 4\n    preferences = [[1, 3, 2], [0, 2, 1], [1, 3, 0], [0, 2, 1]]\n    pairs = [[0, 1], [2, 3]]\n    assert solution.unhappyFriends(n, preferences, pairs) == 2", "def test_unhappyFriends():\n    solution = Solution()\n    n = 6\n    preferences = [[1, 3, 5, 2, 4], [0, 2, 4, 3, 5], [1, 3, 5, 0, 2], [0, 4, 2, 5, 3], [1, 3, 5, 2, 4], [0, 2, 4, 3, 5]]\n    pairs = [[0, 1], [2, 3], [4, 5]]\n    assert solution.unhappyFriends(n, preferences, pairs) == 4", "def test_unhappyFriends():\n    solution = Solution()\n    n = 2\n    preferences = [[1], [0]]\n    pairs = [[0, 1]]\n    assert solution.unhappyFriends(n, preferences, pairs) == 0", "def test_unhappyFriends():\n    solution = Solution()\n    n = 3\n    preferences = [[1, 2], [0, 2], [0, 1]]\n    pairs = [[0, 1], [2, 0]]\n    assert solution.unhappyFriends(n, preferences, pairs) == 1", "def test_unhappyFriends():\n    solution = Solution()\n    n = 5\n    preferences = [[1, 3, 2, 4], [0, 2, 3, 4], [1, 3, 0, 4], [0, 2, 1, 4], [0, 1, 2, 3]]\n    pairs = [[0, 1], [2, 3], [4, 0]]\n    assert solution.unhappyFriends(n, preferences, pairs) == 3", "def test_unhappyFriends():\n    solution = Solution()\n    n = 4\n    preferences = [[1, 2, 3], [0, 2, 3], [0, 1, 3], [0, 1, 2]]\n    pairs = [[0, 1], [2, 3]]\n    assert solution.unhappyFriends(n, preferences, pairs) == 4", "def test_unhappyFriends():\n    solution = Solution()\n    n = 6\n    preferences = [[1, 3, 5, 2, 4], [0, 2, 4, 3, 5], [1, 3, 5, 0, 2], [0, 4, 2, 5, 3], [1, 3, 5, 2, 4], [0, 2, 4, 3, 5]]\n    pairs = [[0, 1], [2, 3], [4, 5]]\n    assert solution.unhappyFriends(n, preferences, pairs) == 4", "def test_unhappyFriends():\n    solution = Solution()\n    n = 5\n    preferences = [[1, 2, 3, 4], [0, 2, 4, 3], [0, 1, 3, 4], [0, 1, 2, 4], [0, 1, 2, 3]]\n    pairs = [[0, 1], [2, 3], [4, 0]]\n    assert solution.unhappyFriends(n, preferences, pairs) == 3", "def test_unhappyFriends():\n    solution = Solution()\n    n = 4\n    preferences = [[1, 2], [0, 3], [0, 2], [1, 0]]\n    pairs = [[0, 1], [2, 3]]\n    assert solution.unhappyFriends(n, preferences, pairs) == 2", "def test_unhappyFriends():\n    solution = Solution()\n    n = 6\n    preferences = [[1, 5, 3, 2, 4], [0, 2, 4, 3, 5], [1, 5, 0, 4, 3], [0, 4, 2, 3, 5], [1, 5, 2, 0, 3], [0, 2, 4, 3, 5]]\n    pairs = [[0, 1], [2, 3], [4, 5]]\n    assert solution.unhappyFriends(n, preferences, pairs) == 3", "def test_unhappyFriends():\n    solution = Solution()\n    n = 4\n    preferences = [[1, 2], [0, 3], [0, 2], [1, 0]]\n    pairs = [[0, 1], [2, 3]]\n    assert solution.unhappyFriends(n, preferences, pairs) == 2", "def test_unhappyFriends():\n    solution = Solution()\n    n = 5\n    preferences = [[1, 3, 2, 4], [0, 2, 3, 4], [1, 3, 5, 0, 2], [0, 4, 2, 5, 3], [1, 3, 5, 2, 4]]\n    pairs = [[0, 1], [2, 3], [4, 0]]\n    assert solution.unhappyFriends(n, preferences, pairs) == 3", "def test_unhappyFriends():\n    solution = Solution()\n    n = 4\n    preferences = [[1, 2], [0, 3], [0, 2], [1, 0]]\n    pairs = [[0, 1], [2, 3]]\n    assert solution.unhappyFriends(n, preferences, pairs) == 2", "def test_unhappyFriends():\n    solution = Solution()\n    n = 3\n    preferences = [[1, 0], [2, 0], [1, 2]]\n    pairs = [[0, 1], [2, 0]]\n    assert solution.unhappyFriends(n, preferences, pairs) == 1", "def test_unhappyFriends():\n    solution = Solution()\n    n = 6\n    preferences = [[1, 3, 5, 2, 4], [0, 2, 4, 3, 5], [1, 3, 5, 0, 2], [0, 4, 2, 5, 3], [1, 3, 5, 2, 4], [0, 2, 4, 3, 5]]\n    pairs = [[0, 1], [2, 3], [4, 5]]\n    assert solution.unhappyFriends(n, preferences, pairs) == 4", "def test_unhappyFriends():\n    solution = Solution()\n    n = 5\n    preferences = [[1, 3, 2, 4], [0, 2, 3, 4], [1, 3, 5, 0, 2], [0, 4, 2, 5, 3], [1, 3, 5, 2, 4]]\n    pairs = [[0, 1], [2, 3], [4, 0]]\n    assert solution.unhappyFriends(n, preferences, pairs) == 3", "def test_unhappyFriends():\n    solution = Solution()\n    n = 4\n    preferences = [[1, 2], [0, 3], [0, 2], [1, 0]]\n    pairs = [[0, 1], [2, 3]]\n    assert solution.unhappyFriends(n, preferences, pairs) == 2", "def test_unhappyFriends():\n    solution = Solution()\n    n = 6\n    preferences = [[1, 3, 5, 2, 4], [0, 2, 4, 3, 5], [1, 3, 5, 0, 2], [0, 4, 2, 5, 3], [1, 3, 5, 2, 4], [0, 2, 4, 3, 5]]\n    pairs = [[0, 1], [2, 3], [4, 5]]\n    assert solution.unhappyFriends(n, preferences, pairs) == 4", "def test_unhappyFriends():\n    solution = Solution()\n    n = 5\n    preferences = [[1, 2, 3, 4], [0, 2, 3, 4], [1, 3, 5, 0, 2], [0, 4, 2, 5, 3], [1, 3, 5, 2, 4]]\n    pairs = [[0, 1], [2, 3], [4, 0]]\n    assert solution.unhappyFriends(n, preferences, pairs) == 3", "def test_unhappyFriends():\n    solution = Solution()\n    n = 4\n    preferences = [[1, 2], [0, 3], [0, 2], [1, 0]]\n    pairs = [[0, 1], [2, 3]]\n    assert solution.unhappyFriends(n, preferences, pairs) == 2"]}
{"task_num": 1591, "task_title": "Strange Printer II", "func_name": "isPrintable", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import Enum\n\n\nclass State(Enum):\n  kInit = 0\n  kVisiting = 1\n  kVisited = 2\n\n\nclass Solution:\n  def isPrintable(self, targetGrid: List[List[int]]) -> bool:\n    kMaxColor = 60\n    m = len(targetGrid)\n    n = len(targetGrid[0])\n\n    graph = [set() for _ in range(kMaxColor + 1)]\n\n    for color in range(1, kMaxColor + 1):\n      minI = m\n      minJ = n\n      maxI = -1\n      maxJ = -1\n      for i in range(m):\n        for j in range(n):\n          if targetGrid[i][j] == color:\n            minI = min(minI, i)\n            minJ = min(minJ, j)\n            maxI = max(maxI, i)\n            maxJ = max(maxJ, j)\n\n      for i in range(minI, maxI + 1):\n        for j in range(minJ, maxJ + 1):\n          if targetGrid[i][j] != color:\n            graph[color].add(targetGrid[i][j])\n\n    states = [State.kInit] * (kMaxColor + 1)\n\n    def hasCycle(u: int) -> bool:\n      if states[u] == State.kVisiting:\n        return True\n      if states[u] == State.kVisited:\n        return False\n\n      states[u] = State.kVisiting\n      if any(hasCycle(v) for v in graph[u]):\n        return True\n      states[u] = State.kVisited\n\n      return False\n\n    for i in range(1, kMaxColor + 1):\n      if hasCycle(i):\n        return False\n    return True\n", "tests": ["def test_isPrintable():\n    solution = Solution()\n    targetGrid = [[1, 2], [3, 4]]\n    assert solution.isPrintable(targetGrid) == False", "def test_isPrintable():\n    solution = Solution()\n    targetGrid = [[1]]\n    assert solution.isPrintable(targetGrid) == True", "def test_isPrintable():\n    solution = Solution()\n    targetGrid = [[1, 2, 3]]\n    assert solution.isPrintable(targetGrid) == True", "def test_isPrintable():\n    solution = Solution()\n    n = 10\n    targetGrid = [[i % (n + 1) for i in range(n * n)] for _ in range(n)]\n    assert solution.isPrintable(targetGrid) == True", "def test_isPrintable():\n    solution = Solution()\n    targetGrid = []\n    assert solution.isPrintable(targetGrid) == True", "def test_isPrintable():\n    solution = Solution()\n    n = 10\n    targetGrid = [[i * j % (n + 1) for j in range(n)] for i in range(n)]\n    assert solution.isPrintable(targetGrid) == False", "def test_isPrintable():\n    solution = Solution()\n    targetGrid = [[], [], []]\n    assert solution.isPrintable(targetGrid) == True", "def test_isPrintable():\n    solution = Solution()\n    n = 10\n    targetGrid = [[i * j % (n + 1) for i in range(n)], [i // j % (n + 1) for i in range(n)]]\n    assert solution.isPrintable(targetGrid) == True", "def test_isPrintable():\n    solution = Solution()\n    n = 10\n    targetGrid = [[i % (n // 2 + 1) for i in range(n)], [(n - i) % (n // 2 + 1) for i in range(n)]]\n    assert solution.isPrintable(targetGrid) == False", "def test_isPrintable():\n    solution = Solution()\n    n = 10\n    targetGrid = [[i % (n // 2 + 1) for i in range(n)], [(n - i) % (n // 2 + 1) for i in range(n)]]\n    assert solution.isPrintable(targetGrid) == False", "Here's a new test method that tests the function with a grid that has overlapping blocks of colors:\n\n```java\n@Test\npublic void testOverlappingBlocks() {\n    int n = 8;\n    int[][] grid = {\n        {1, 2, 3, 4, 5, 6, 7, 0},\n        {2, 3, 4, 5, 6, 7, 0, 0},\n        {3, 4, 5, 6, 7, 0, 0, 0},\n        {4, 5, 6, 7, 0, 0, 0, 0},\n        {5, 6, 7, 0, 0, 0, 0, 0},\n        {6, 7, 0, 0, 0, 0, 0, 0},\n        {7, 0, 0, 0, 0, 0, 0, 0},\n        {0, 0, 0, 0, 0, 0, 0, 0}\n    };\n    assertTrue(isPrintable(grid));\n}\n```\n", "Here's a new test method that tests the function with a grid that has one color dominating most of the area:\n\n```java\n@Test\npublic void testDominantColor() {\n    int n = 10;\n    int[][] grid = {\n        {1, 1, 1, 1, 1, 1, 1, 1, 1, 1},\n        {1, 1, 1, 1, 1, 1, 1, 1, 1, 2},\n        {1, 1, 1, 1, 1, 1, 1, 1, 3, 3},\n        {1, 1, 1, 1, 1, 1, 1, 4, 4, 4},\n        {1, 1, 1, 1, 1, 5, 5, 5, 5, 5},\n        {1, 1, 1, 6, 6, 6, 6, 6, 6, 6},\n        {7, 7, 7, 7, 7, 7, 7, 7, 7, 7},\n        {8, 8, 8, 8, 9, 9, 9, 9, 10, 10},\n        {11, 12, 13, 14, 15, 16, 17, 18, 19, 20},\n        {21, 22, 23, 24, 25, 26, 27, 28, 29, 30}\n    };\n    assertTrue(isPrintable(grid));\n}\n```\n\nThis test method creates a grid with 10x10 cells and assigns different colors to non-overlapping blocks of cells. The function should return true since the coloring is possible by removing some cells from the original grid.\n", "Here's a new test method that tests the function with a small grid that has overlapping blocks of colors:\n\n```java\n@Test\npublic void testSmallOverlappingBlocks() {\n    int n = 4;\n    int[][] grid = {\n        {1, 2, 3, 0},\n        {2, 2, 0, 0},\n        {3, 0, 0, 0},\n        {0, 0, 0, 0}\n    };\n    assertTrue(isPrintable(grid));\n}\n```\n\nThis test method creates a small grid with 4x4 cells and assigns different colors to overlapping blocks of cells. The function should return true since the coloring is possible by removing some cells from the original grid.\n\nAdditionally, this test case helps ensure that the function correctly handles cases where there are multiple overlapping color blocks that need to be resolved.\n", "Here's a new test method that tests the function with a grid where one color is completely surrounded by another:\n\n```java\n@Test\npublic void testSurroundedColor() {\n    int n = 5;\n    int[][] grid = {\n        {1, 2, 3, 2, 1},\n        {2, 0, 0, 0, 2},\n        {3, 0, 0, 0, 3},\n        {2, 0, 0, 0, 2},\n        {1, 2, 3, 2, 1}\n    };\n    assertTrue(isPrintable(grid));\n}\n```\n\nThis test method creates a 5x5 grid with one color (represented by '0') surrounded by another color (represented by numbers 1-3). The function should return true because the coloring is possible by removing some cells from the original grid.\n", "Here's a new test method that tests the function with a more complex scenario where multiple colors have overlapping blocks and one color is completely surrounded by another:\n\n```java\n@Test\npublic void testComplexOverlappingSurrounded() {\n    int n = 6;\n    int[][] grid = {\n        {1, 2, 3, 4, 5, 0},\n        {2, 0, 0, 0, 6, 7},\n        {3, 0, 8, 9, 0, 7},\n        {4, 0, 9, 10, 0, 6},\n        {5, 0, 8, 0, 0, 7},\n        {0, 7, 7, 0, 0, 6}\n    };\n    assertTrue(isPrintable(grid));\n}\n```\n\nThis test method creates a 6x6 grid with multiple overlapping blocks of colors and one color completely surrounded by another. The function should return true because the coloring is possible by removing some cells from the original grid.\n\nThe `assertTrue` statement at the end ensures that the method under test returns `true`, indicating that the given input can be colored according to the rules.\n", "Here's a new test method that tests the function with a grid where one color is partially surrounded by another:\n\n```java\n@Test\npublic void testPartiallySurroundedColor() {\n    int n = 5;\n    int[][] grid = {\n        {1, 2, 3, 0, 1},\n        {2, 4, 5, 6, 2},\n        {3, 5, 7, 8, 3},\n        {0, 6, 8, 9, 0},\n        {1, 2, 3, 0, 1}\n    };\n    assertTrue(isPrintable(grid));\n}\n```\n\nThis test method creates a 5x5 grid with one color (represented by '0') partially surrounded by another color (represented by numbers 1-9). The function should return true because the coloring is possible by removing some cells from the original grid.\n\nThe `assertTrue` statement at the end ensures that the method under test returns `true`, indicating that the given input can be colored according to the rules.\n", "Here's a new test method that tests the function with a grid where there are multiple disjoint regions of overlapping colors:\n\n```java\n@Test\npublic void testDisjointOverlappingRegions() {\n    int n = 8;\n    int[][] grid = {\n        {1, 2, 3, 0, 0, 4, 5, 6},\n        {2, 0, 0, 0, 0, 5, 0, 7},\n        {3, 0, 8, 9, 0, 5, 0, 8},\n        {0, 0, 9, 10, 0, 5, 0, 9},\n        {0, 0, 0, 0, 0, 5, 0, 0},\n        {4, 5, 6, 0, 0, 5, 0, 0},\n        {7, 0, 8, 0, 0, 5, 0, 0},\n        {6, 0, 9, 0, 0, 5, 0, 0}\n    };\n    assertTrue(isPrintable(grid));\n}\n```\n\nThis test method creates an 8x8 grid with four disjoint regions of overlapping colors. Each region has its own set of colors and some overlap with other regions.\n\nThe function should return true because the coloring is possible by removing cells from each region such that no two adjacent cells have the same color in any region.\n", "Here's a new test method that tests the function with a grid where one color is completely surrounded by two other colors:\n\n```java\n@Test\npublic void testSurroundedByTwoColors() {\n    int n = 5;\n    int[][] grid = {\n        {1, 2, 3, 2, 1},\n        {2, 0, 4, 0, 2},\n        {3, 4, 0, 4, 3},\n        {2, 0, 4, 0, 2},\n        {1, 2, 3, 2, 1}\n    };\n    assertTrue(isPrintable(grid));\n}\n```\n\nThis test method creates a 5x5 grid with one color (represented by '0') completely surrounded by two other colors (represented by numbers 1, 2, and 4). The function should return true because the coloring is possible by removing some cells from the original grid.\n", "Here's a new test method that tests the function with a grid where one color is completely surrounded by two other colors, but there are also some overlapping regions:\n\n```java\n@Test\npublic void testSurroundedByTwoColorsWithOverlaps() {\n    int n = 8;\n    int[][] grid = {\n        {1, 2, 3, 0, 4, 5, 6, 7},\n        {2, 0, 4, 0, 4, 5, 0, 7},\n        {3, 4, 0, 4, 0, 5, 0, 8},\n        {0, 0, 4, 0, 4, 5, 0, 9},\n        {4, 5, 6, 0, 4, 5, 0, 10},\n        {7, 0, 8, 0, 4, 5, 0, 11},\n        {6, 0, 9, 0, 4, 5, 0, 12},\n        {7, 0, 10, 0, 4, 5, 0, 13}\n    };\n    assertTrue(isPrintable(grid));\n}\n```\n\nThis test method creates an 8x8 grid with one color (represented by '0') completely surrounded by two other colors (represented by numbers 1, 2, 4, and 5) in some regions, while there are also overlapping regions with different sets of colors.\n\nThe function should return true because the coloring is possible by removing cells from each region such that no two adjacent cells have the same color within any region.\n", "Sure! Here's a new test method that tests the function with a more complex scenario involving multiple disjoint regions of overlapping colors and some partially surrounded regions:\n\n```java\n@Test\npublic void testComplexDisjointOverlapsAndSurroundings() {\n    int n = 10;\n    int[][] grid = {\n        {1, 2, 3, 4, 5, 0, 6, 7, 8, 9},\n        {2, 0, 4, 0, 5, 0, 6, 0, 8, 9},\n        {3, 4, 0, 4, 0, 5, 0, 6, 0, 9},\n        {4, 0, 4, 0, 5, 0, 6, 0, 8, 9},\n        {5, 0, 0, 0, 0, 0, 6, 0, 8, 9},\n        {0, 7, 0, 7, 0, 0, 6, 0, 8, 9},\n        {6, 0, 6, 0, 6, 0, 6, 0, 8, 9},\n        {7, 0, 6, 0, 6, 0, 6, 0, 8, 9},\n        {8, 0, 6, 0, 6, 0, 6, 0, 8, 9},\n        {9, 0, 6, 0, 6, 0, 6, 0, 8, 9}\n    };\n    assertTrue(isPrintable(grid));\n}\n```\n\n### Explanation:\n- The grid is a 10x10 matrix.\n- There are multiple regions of overlapping colors (represented by numbers 1 through 9).\n- Some regions are completely surrounded by other colors, while others partially overlap with each other.\n- The function should return true because the coloring is possible by removing cells from each region such that no two adjacent cells have the same color within any region.\n\n### How to Interpret:\n- The '0's represent the target color (the one we want to separate).\n- The numbers 1 through 9 represent different colors that overlap with the target color.\n- By removing certain cells, it is possible to ensure that no two adjacent cells in any of these regions have the same color.\n"]}
{"task_num": 1604, "task_title": "Alert Using Same Key-Card Three or More Times in a One Hour Period", "func_name": "alertNames", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n    nameToMinutes = collections.defaultdict(list)\n\n    for name, time in zip(keyName, keyTime):\n      minutes = self._getMinutes(time)\n      nameToMinutes[name].append(minutes)\n\n    res=[]\n    for name, minutes in nameToMinutes.items():\n      if self._hasAlert(minutes):\n        res.append(name)\n    return sorted(res)\n\n  def _hasAlert(self, minutes: List[int]) -> bool:\n    if len(minutes) > 70:\n      return True\n    minutes.sort()\n    for i in range(2, len(minutes)):\n      if minutes[i - 2] + 60 >= minutes[i]:\n        return True\n    return False\n\n  def _getMinutes(self, time: str) -> int:\n    h, m = map(int, time.split(':'))\n    return 60 * h + m\n", "tests": ["def test_alertNames():\n    solution = Solution()\n    keyName = ['a', 'a', 'a', 'a']\n    keyTime = ['23:58', '23:59', '00:01', '00:04']\n    assert solution.alertNames(keyName, keyTime) == ['a']", "def test_alertNames():\n    solution = Solution()\n    keyName = ['alice', 'bob', 'alice', 'bob', 'alice']\n    keyTime = ['10:00', '10:30', '14:00', '15:00', '19:00']\n    assert solution.alertNames(keyName, keyTime) == ['alice']", "def test_alertNames():\n    solution = Solution()\n    keyName = ['john', 'mike', 'anna']\n    keyTime = ['09:00', '14:05', '15:30']\n    assert solution.alertNames(keyName, keyTime) == []", "def test_alertNames():\n    solution = Solution()\n    keyName = ['zoe', 'zoe', 'zoe']\n    keyTime = ['23:59', '00:01', '00:59']\n    assert solution.alertNames(keyName, keyTime) == ['zoe']", "def test_alertNames():\n    solution = Solution()\n    keyName = ['alice', 'alice', 'alice', 'bob', 'bob']\n    keyTime = ['10:00', '12:00', '14:00', '16:00', '18:00']\n    assert solution.alertNames(keyName, keyTime) == ['alice', 'bob']", "def test_alertNames():\n    solution = Solution()\n    keyName = ['alice', 'alice', 'alice', 'alice', 'alice']\n    keyTime = ['00:01', '00:02', '00:03', '00:59', '23:59']\n    assert solution.alertNames(keyName, keyTime) == ['alice']", "def test_alertNames():\n    solution = Solution()\n    keyName = ['bob', 'bob', 'bob', 'bob', 'alice', 'alice']\n    keyTime = ['09:01', '10:59', '23:58', '00:00', '00:01', '00:02']\n    assert solution.alertNames(keyName, keyTime) == ['bob']", "def test_alertNames():\n    solution = Solution()\n    keyName = ['james', 'james', 'james', 'james']\n    keyTime = ['00:01', '00:30', '23:59', '01:00']\n    assert solution.alertNames(keyName, keyTime) == ['james']", "def test_alertNames():\n    solution = Solution()\n    keyName = ['alex', 'jason', 'alex', 'jason', 'alex']\n    keyTime = ['10:00', '14:05', '18:00', '23:59', '23:59']\n    assert solution.alertNames(keyName, keyTime) == ['alex', 'jason']", "def test_alertNames():\n    solution = Solution()\n    keyName = ['alice', 'bob', 'charlie', 'alice']\n    keyTime = ['23:50', '00:10', '01:00', '01:59']\n    assert solution.alertNames(keyName, keyTime) == ['alice']", "def test_alertNames():\n    solution = Solution()\n    keyName = ['alice', 'bob', 'alice', 'bob', 'charlie']\n    keyTime = ['09:00', '12:59', '14:00', '16:00', '18:00']\n    assert solution.alertNames(keyName, keyTime) == ['alice', 'bob']", "def test_alertNames():\n    solution = Solution()\n    keyName = ['alex', 'jason', 'alex', 'jason', 'alex']\n    keyTime = ['10:00', '14:05', '18:00', '23:59', '23:59']\n    assert solution.alertNames(keyName, keyTime) == ['alex', 'jason']", "def test_alertNames():\n    solution = Solution()\n    keyName = ['alice', 'bob', 'charlie', 'alex', 'jason']\n    keyTime = ['23:50', '00:10', '01:00', '01:59', '10:00']\n    assert solution.alertNames(keyName, keyTime) == ['alice']", "def test_alertNames():\n    solution = Solution()\n    keyName = ['alice', 'bob', 'charlie', 'alex', 'jason']\n    keyTime = ['09:00', '12:59', '14:00', '16:00', '18:00']\n    assert solution.alertNames(keyName, keyTime) == ['alice', 'bob']", "def test_alertNames():\n    solution = Solution()\n    keyName = ['alice', 'bob', 'charlie', 'alex', 'jason']\n    keyTime = ['23:50', '23:59', '23:58', '10:00', '10:01']\n    assert solution.alertNames(keyName, keyTime) == ['alice']", "def test_alertNames():\n    solution = Solution()\n    keyName = ['alice', 'bob', 'charlie', 'alex', 'jason']\n    keyTime = ['09:58', '10:59', '12:00', '14:00', '16:00']\n    assert solution.alertNames(keyName, keyTime) == ['alice']", "def test_alertNames():\n    solution = Solution()\n    keyName = ['alice', 'bob', 'charlie', 'alex', 'jason']\n    keyTime = ['23:50', '00:10', '23:59', '10:00', '10:59']\n    assert solution.alertNames(keyName, keyTime) == ['alice']", "def test_alertNames():\n    solution = Solution()\n    keyName = ['alice', 'bob', 'charlie', 'alex', 'jason']\n    keyTime = ['09:58', '23:59', '14:00', '10:00', '10:59']\n    assert solution.alertNames(keyName, keyTime) == ['alice']", "def test_alertNames():\n    solution = Solution()\n    keyName = ['alice', 'bob', 'charlie', 'alex', 'jason']\n    keyTime = ['10:00', '23:59', '14:00', '16:00', '18:00']\n    assert solution.alertNames(keyName, keyTime) == ['alice']", "def test_alertNames():\n    solution = Solution()\n    keyName = ['alice', 'bob', 'charlie', 'alex', 'jason']\n    keyTime = ['09:58', '23:59', '14:00', '10:00', '10:59']\n    assert solution.alertNames(keyName, keyTime) == ['alice']"]}
{"task_num": 1615, "task_title": "Maximal Network Rank", "func_name": "maximalNetworkRank", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\n    degrees = [0] * n\n\n    for u, v in roads:\n      degrees[u] += 1\n      degrees[v] += 1\n\n    maxDegree1 = 0\n    maxDegree2 = 0\n    for degree in degrees:\n      if degree > maxDegree1:\n        maxDegree2 = maxDegree1\n        maxDegree1 = degree\n      elif degree > maxDegree2:\n        maxDegree2 = degree\n\n    countMaxDegree1 = 0\n    countMaxDegree2 = 0\n    for degree in degrees:\n      if degree == maxDegree1:\n        countMaxDegree1 += 1\n      elif degree == maxDegree2:\n        countMaxDegree2 += 1\n\n    if countMaxDegree1 == 1:\n      edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree2) + self._getEdgeCount(roads, degrees, maxDegree2, maxDegree1)\n      return maxDegree1 + maxDegree2 - (countMaxDegree2 == edgeCount)\n    else:\n      edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree1)\n      maxPossibleEdgeCount = countMaxDegree1 * (countMaxDegree1 - 1) // 2\n      return 2 * maxDegree1 - (maxPossibleEdgeCount == edgeCount)\n\n  def _getEdgeCount(self, roads: List[List[int]], degrees: List[int], degreeU: int, degreeV: int) -> int:\n    edgeCount = 0\n    for u, v in roads:\n      if degrees[u] == degreeU and degrees[v] == degreeV:\n        edgeCount += 1\n    return edgeCount\n", "tests": ["def test_maximalNetworkRank():\n    solution = Solution()\n    assert solution.maximalNetworkRank(5, [[0, 1], [0, 4], [1, 2], [1, 3], [1, 4], [2, 3]]) == 5", "def test_maximalNetworkRank():\n    solution = Solution()\n    assert solution.maximalNetworkRank(1, []) == 0", "def test_maximalNetworkRank():\n    solution = Solution()\n    assert solution.maximalNetworkRank(3, [[0, 1], [1, 2], [2, 0]]) == 5", "def test_maximalNetworkRank():\n    solution = Solution()\n    assert solution.maximalNetworkRank(4, [[0, 1], [1, 2], [2, 3], [1, 3], [0, 2]]) == 5", "def test_maximalNetworkRank():\n    solution = Solution()\n    assert solution.maximalNetworkRank(4, [[0, 1], [1, 2], [2, 3]]) == 5", "def test_maximalNetworkRank():\n    solution = Solution()\n    assert solution.maximalNetworkRank(4, [[0, 1], [1, 2], [2, 3], [3, 0]]) == 5", "def test_maximalNetworkRank():\n    solution = Solution()\n    n = 5\n    roads = [[1, 2], [2, 3]]\n    assert solution.maximalNetworkRank(n, roads) == 4", "def test_maximalNetworkRank():\n    solution = Solution()\n    n = 5\n    roads = [[0, 1], [1, 2], [2, 3], [2, 4], [0, 2]]\n    assert solution.maximalNetworkRank(n, roads) == 7", "def test_maximalNetworkRank():\n    solution = Solution()\n    assert solution.maximalNetworkRank(4, [[0, 1], [1, 2], [2, 3], [0, 2]]) == 5", "def test_maximalNetworkRank():\n    solution = Solution()\n    n = 5\n    roads = [[1, 2], [2, 3]]\n    assert solution.maximalNetworkRank(n, roads) == 4", "def test_maximalNetworkRank():\n    solution = Solution()\n    n = 5\n    roads = [[0, 1], [1, 2], [2, 3], [2, 4], [0, 2]]\n    assert solution.maximalNetworkRank(n, roads) == 7", "def test_maximalNetworkRank():\n    solution = Solution()\n    n = 5\n    roads = [[1, 2], [2, 3]]\n    assert solution.maximalNetworkRank(n, roads) == 4", "def test_maximalNetworkRank():\n    solution = Solution()\n    assert solution.maximalNetworkRank(4, [[0, 1], [1, 2], [2, 3], [0, 2]]) == 5", "def test_maximalNetworkRank():\n    solution = Solution()\n    n = 5\n    roads = [[0, 1], [1, 2], [2, 3], [2, 4], [0, 2]]\n    assert solution.maximalNetworkRank(n, roads) == 7", "def test_maximalNetworkRank():\n    solution = Solution()\n    n = 5\n    roads = [[0, 1], [1, 2], [2, 3], [2, 4], [0, 2]]\n    assert solution.maximalNetworkRank(n, roads) == 7", "def test_maximalNetworkRank():\n    solution = Solution()\n    n = 5\n    roads = [[0, 1], [1, 2], [2, 3], [2, 4], [0, 2]]\n    assert solution.maximalNetworkRank(n, roads) == 7", "def test_maximalNetworkRank():\n    solution = Solution()\n    n = 5\n    roads = [[0, 1], [1, 2], [2, 3], [2, 4], [0, 2]]\n    assert solution.maximalNetworkRank(n, roads) == 7", "def test_maximalNetworkRank():\n    solution = Solution()\n    n = 5\n    roads = [[0, 1], [1, 2], [2, 3], [2, 4], [0, 2]]\n    assert solution.maximalNetworkRank(n, roads) == 7", "def test_maximalNetworkRank():\n    solution = Solution()\n    n = 5\n    roads = [[0, 1], [1, 2], [2, 3], [2, 4], [0, 2]]\n    assert solution.maximalNetworkRank(n, roads) == 7", "def test_maximalNetworkRank():\n    solution = Solution()\n    n = 5\n    roads = [[0, 1], [1, 2], [2, 3], [2, 4], [0, 2]]\n    assert solution.maximalNetworkRank(n, roads) == 7"]}
{"task_num": 1616, "task_title": "Split Two Strings to Make Palindrome", "func_name": "checkPalindromeFormation", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def checkPalindromeFormation(self, a: str, b: str) -> bool:\n    return self._check(a, b) or self._check(b, a)\n\n  def _check(self, a: str, b: str) -> bool:\n    i, j = 0, len(a) - 1\n    while i < j:\n      if a[i] != b[j]:\n        return self._isPalindrome(a, i, j) or self._isPalindrome(b, i, j)\n      i += 1\n      j -= 1\n    return True\n\n  def _isPalindrome(self, s: str, i: int, j: int) -> bool:\n    while i < j:\n      if s[i] != s[j]:\n        return False\n      i += 1\n      j -= 1\n    return True\n", "tests": ["def test_checkPalindromeFormation():\n    solution = Solution()\n    assert solution.checkPalindromeFormation('abc', 'cba') == True", "def test_checkPalindromeFormation():\n    solution = Solution()\n    assert solution.checkPalindromeFormation('abcd', 'dcba') == True", "def test_checkPalindromeFormation():\n    solution = Solution()\n    assert solution.checkPalindromeFormation('abcde', 'edcba') == True", "def test_checkPalindromeFormation():\n    solution = Solution()\n    assert solution.checkPalindromeFormation('a', 'b') == False", "def test_checkPalindromeFormation():\n    solution = Solution()\n    assert solution.checkPalindromeFormation('abcba', 'ababa') == True", "def test_checkPalindromeFormation():\n    solution = Solution()\n    assert solution.checkPalindromeFormation('abcdefg', 'gfedcba') == True", "def test_checkPalindromeFormation():\n    solution = Solution()\n    assert solution.checkPalindromeFormation('abcda', 'abcd') == True", "def test_checkPalindromeFormation():\n    solution = Solution()\n    assert solution.checkPalindromeFormation('abcde', 'fedcba') == False", "def test_checkPalindromeFormation():\n    solution = Solution()\n    assert solution.checkPalindromeFormation('abccba', 'aabc') == True", "def test_checkPalindromeFormation():\n    solution = Solution()\n    assert solution.checkPalindromeFormation('abcdedcba', 'abcdefg') == True", "def test_checkPalindromeFormation():\n    solution = Solution()\n    assert solution.checkPalindromeFormation('abcdeffedcba', 'abcdefg') == True", "def test_checkPalindromeFormation():\n    solution = Solution()\n    assert solution.checkPalindromeFormation('abcdeffedcba', 'gfedcba') == True", "def test_checkPalindromeFormation():\n    solution = Solution()\n    assert solution.checkPalindromeFormation('abcdeffedcbaz', 'gfedcba') == False", "def test_checkPalindromeFormation():\n    solution = Solution()\n    assert solution.checkPalindromeFormation('abcdeffedcbaz', 'zabcdefg') == True", "def test_checkPalindromeFormation():\n    solution = Solution()\n    assert solution.checkPalindromeFormation('abcdeffedcbaz', 'zabcdefgg') == False", "def test_checkPalindromeFormation():\n    solution = Solution()\n    assert solution.checkPalindromeFormation('abcdeffedcbaz', 'zabcdefgg') == False", "def test_checkPalindromeFormation():\n    solution = Solution()\n    assert solution.checkPalindromeFormation('abcdeffedcbaz', 'zabcdefgg') == False", "def test_checkPalindromeFormation():\n    solution = Solution()\n    assert solution.checkPalindromeFormation('abcdeffedcbaz', 'zabcdefgg') == False", "def test_checkPalindromeFormation():\n    solution = Solution()\n    assert solution.checkPalindromeFormation('abcdeffedcbaz', 'zabcdefgg') == False", "def test_checkPalindromeFormation():\n    solution = Solution()\n    assert solution.checkPalindromeFormation('abcdeffedcbaz', 'zabcdefgg') == False"]}
{"task_num": 1617, "task_title": "Count Subtrees With Max Distance Between Cities", "func_name": "countSubgraphsForEachDiameter", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:\n    maxMask = 1 << n\n    dist = self._floydWarshall(n, edges)\n    ans = [0] * (n - 1)\n\n    for mask in range(maxMask):\n      maxDist = self._getMaxDist(mask, dist, n)\n      if maxDist > 0:\n        ans[maxDist - 1] += 1\n\n    return ans\n\n  def _floydWarshall(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n    dist = [[n] * n for _ in range(n)]\n\n    for i in range(n):\n      dist[i][i] = 0\n\n    for u, v in edges:\n      dist[u - 1][v - 1] = 1\n      dist[v - 1][u - 1] = 1\n\n    for k in range(n):\n      for i in range(n):\n        for j in range(n):\n          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    return dist\n\n  def _getMaxDist(self, mask: int, dist: List[List[int]], n: int) -> int:\n    maxDist = 0\n    edgeCount = 0\n    cityCount = 0\n    for u in range(n):\n      if (mask >> u) & 1 == 0:\n        continue\n      cityCount += 1\n      for v in range(u + 1, n):\n        if (mask >> v) & 1 == 0:\n          continue\n        if dist[u][v] == 1:\n          edgeCount += 1\n        maxDist = max(maxDist, dist[u][v])\n\n    if edgeCount == cityCount - 1:\n      return maxDist\n    else:\n      return 0\n", "tests": ["def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    n = 4\n    edges = [[1, 2], [2, 3], [3, 4]]\n    expected = [1, 1, 0]\n    assert solution.countSubgraphsForEachDiameter(n, edges) == expected", "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    n = 1\n    edges = []\n    expected = [0]\n    assert solution.countSubgraphsForEachDiameter(n, edges) == expected", "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    n = 2\n    edges = [[1, 2]]\n    expected = [1]\n    assert solution.countSubgraphsForEachDiameter(n, edges) == expected", "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    n = 3\n    edges = [[1, 2], [1, 3], [2, 3]]\n    expected = [0]\n    assert solution.countSubgraphsForEachDiameter(n, edges) == expected", "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    n = 4\n    edges = [[1, 2], [3, 4]]\n    expected = [0, 0]\n    assert solution.countSubgraphsForEachDiameter(n, edges) == expected", "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    n = 5\n    edges = [[1, 2], [1, 3], [2, 4], [2, 5]]\n    expected = [0, 2]\n    assert solution.countSubgraphsForEachDiameter(n, edges) == expected", "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    n = 5\n    edges = [[1, 2], [2, 3], [3, 4]]\n    expected = [0, 0]\n    assert solution.countSubgraphsForEachDiameter(n, edges) == expected", "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    n = 4\n    edges = [[1, 2], [2, 3], [3, 4], [4, 1]]\n    expected = [0]\n    assert solution.countSubgraphsForEachDiameter(n, edges) == expected", "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    n = 6\n    edges = [[1, 2], [3, 4], [5, 6]]\n    expected = [0, 0]\n    assert solution.countSubgraphsForEachDiameter(n, edges) == expected", "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    n = 4\n    edges = [[1, 2], [1, 3], [2, 4]]\n    expected = [0, 0, 1]\n    assert solution.countSubgraphsForEachDiameter(n, edges) == expected", "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    n = 3\n    edges = [[1, 2], [2, 3], [1, 3]]\n    expected = [0]\n    assert solution.countSubgraphsForEachDiameter(n, edges) == expected", "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    n = 4\n    edges = [[1, 2], [2, 3], [3, 4], [4, 5]]\n    expected = [0]\n    assert solution.countSubgraphsForEachDiameter(n, edges) == expected", "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    n = 4\n    edges = [[1, 2], [3, 4]]\n    expected = [0, 0]\n    assert solution.countSubgraphsForEachDiameter(n, edges) == expected", "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    n = 5\n    edges = [[1, 2], [3, 4]]\n    expected = [0]\n    assert solution.countSubgraphsForEachDiameter(n, edges) == expected", "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    n = 5\n    edges = [[1, 2], [1, 3], [1, 4], [2, 3], [3, 4]]\n    expected = [0]\n    assert solution.countSubgraphsForEachDiameter(n, edges) == expected", "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    n = 3\n    edges = [[1, 2], [2, 3], [1, 3]]\n    expected = [0]\n    assert solution.countSubgraphsForEachDiameter(n, edges) == expected", "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    n = 3\n    edges = [[1, 2], [2, 3], [3, 1]]\n    expected = [0]\n    assert solution.countSubgraphsForEachDiameter(n, edges) == expected", "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    n = 5\n    edges = [[1, 2], [2, 3], [3, 4], [4, 5]]\n    expected = [0]\n    assert solution.countSubgraphsForEachDiameter(n, edges) == expected", "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    n = 4\n    edges = [[1, 2], [3, 4]]\n    expected = [0]\n    assert solution.countSubgraphsForEachDiameter(n, edges) == expected", "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    n = 5\n    edges = [[1, 2], [1, 3], [1, 4], [1, 5]]\n    expected = [0]\n    assert solution.countSubgraphsForEachDiameter(n, edges) == expected"]}
{"task_num": 1627, "task_title": "Graph Connectivity With Threshold", "func_name": "areConnected", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def areConnected(self, n: int, threshold: int, queries: List[List[int]]) -> List[bool]:\n    uf = UnionFind(n + 1)\n\n    for z in range(threshold + 1, n + 1):\n      for x in range(z * 2, n + 1, z):\n        uf.unionByRank(z, x)\n\n    return [uf.find(a) == uf.find(b) for a, b in queries]\n", "tests": ["def test_areConnected():\n    solution = Solution()\n    assert solution.areConnected(5, 1, [[2, 3], [4, 5], [3, 5]]) == [False, False, True]", "def test_areConnected():\n    solution = Solution()\n    assert solution.areConnected(10, 3, [[2, 8], [5, 10], [7, 9]]) == [True, True, False]", "def test_areConnected():\n    solution = Solution()\n    assert solution.areConnected(15, 4, [[2, 6], [3, 9], [5, 10]]) == [True, True, False]", "def test_areConnected():\n    solution = Solution()\n    assert solution.areConnected(7, 1, [[2, 3], [4, 6], [5, 7]]) == [False, True, False]", "def test_areConnected():\n    solution = Solution()\n    assert solution.areConnected(12, 5, [[2, 8], [3, 9], [4, 10]]) == [True, True, False]", "def test_areConnected():\n    solution = Solution()\n    assert solution.areConnected(6, 2, [[1, 2], [3, 4], [5, 6]]) == [True, True, True]", "def test_areConnected():\n    solution = Solution()\n    assert solution.areConnected(8, 3, [[2, 6], [4, 10], [5, 7]]) == [True, False, True]", "def test_areConnected():\n    solution = Solution()\n    assert solution.areConnected(9, 4, [[2, 8], [3, 6], [5, 10]]) == [True, True, False]", "def test_areConnected():\n    solution = Solution()\n    assert solution.areConnected(11, 5, [[2, 7], [3, 9], [4, 10]]) == [False, True, False]", "def test_areConnected():\n    solution = Solution()\n    assert solution.areConnected(14, 3, [[2, 6], [3, 9], [5, 10]]) == [True, True, False]", "def test_areConnected():\n    solution = Solution()\n    assert solution.areConnected(100, 25, [[26, 78], [50, 100], [33, 99]]) == [True, True, False]", "def test_areConnected():\n    solution = Solution()\n    assert solution.areConnected(5, 1, [[1, 2], [3, 4], [5, 6]]) == [True, True, False]", "def test_areConnected():\n    solution = Solution()\n    assert solution.areConnected(15, 4, [[2, 8], [3, 9], [4, 10]]) == [True, True, False]", "def test_areConnected():\n    solution = Solution()\n    assert solution.areConnected(7, 1, [[2, 3], [4, 6], [5, 7]]) == [False, True, False]", "def test_areConnected():\n    solution = Solution()\n    assert solution.areConnected(12, 5, [[2, 8], [3, 9], [4, 10]]) == [True, False, True]", "def test_areConnected():\n    solution = Solution()\n    assert solution.areConnected(9, 4, [[2, 8], [3, 6], [5, 10]]) == [True, True, False]", "def test_areConnected():\n    solution = Solution()\n    assert solution.areConnected(18, 6, [[2, 10], [3, 9], [4, 12]]) == [True, True, True]", "def test_areConnected():\n    solution = Solution()\n    assert solution.areConnected(16, 4, [[2, 8], [3, 9], [5, 10]]) == [True, True, False]", "def test_areConnected():\n    solution = Solution()\n    assert solution.areConnected(20, 7, [[2, 14], [3, 9], [5, 15]]) == [True, False, True]", "def test_areConnected():\n    solution = Solution()\n    assert solution.areConnected(13, 5, [[2, 8], [3, 9], [4, 10]]) == [True, True, False]"]}
{"task_num": 1631, "task_title": "Path With Minimum Effort", "func_name": "minimumEffortPath", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumEffortPath(self, heights: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(heights)\n    n = len(heights[0])\n    diff = [[math.inf] * n for _ in range(m)]\n    seen = set()\n\n    minHeap = [(0, 0, 0)]\n    diff[0][0] = 0\n\n    while minHeap:\n      d, i, j = heapq.heappop(minHeap)\n      if i == m - 1 and j == n - 1:\n        return d\n      seen.add((i, j))\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if (x, y) in seen:\n          continue\n        newDiff = abs(heights[i][j] - heights[x][y])\n        maxDiff = max(diff[i][j], newDiff)\n        if diff[x][y] > maxDiff:\n          diff[x][y] = maxDiff\n          heapq.heappush(minHeap, (diff[x][y], x, y))\n", "tests": ["def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    assert solution.minimumEffortPath(heights) == 0", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[1, 3, 5], [4, 2, 1], [7, 8, 9]]\n    assert solution.minimumEffortPath(heights) == 4", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[10, 50, 40], [30, 20, 80], [70, 60, 90]]\n    assert solution.minimumEffortPath(heights) == 50", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[1, 2], [3, 4]]\n    assert solution.minimumEffortPath(heights) == 1", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[3, 2], [1, 0]]\n    assert solution.minimumEffortPath(heights) == 2", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[10, 20], [30, 40]]\n    assert solution.minimumEffortPath(heights) == 10", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[5], [10]]\n    assert solution.minimumEffortPath(heights) == 5", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[10, 9, 8], [7, 6, 5], [4, 3, 2]]\n    assert solution.minimumEffortPath(heights) == 9", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[10, 3], [20, 4]]\n    assert solution.minimumEffortPath(heights) == 7", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[10, 5], [15, 20]]\n    assert solution.minimumEffortPath(heights) == 5", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[100, 98], [2, 5]]\n    assert solution.minimumEffortPath(heights) == 96", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[100], [50]]\n    assert solution.minimumEffortPath(heights) == 50", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]]\n    assert solution.minimumEffortPath(heights) == 0", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[1, 2, 3], [4, 8, 6], [7, 5, 9]]\n    assert solution.minimumEffortPath(heights) == 4", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[1, 2], [3, 9], [4, 5]]\n    assert solution.minimumEffortPath(heights) == 6", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[10, 20, 30], [40, 50, 60], [70, 80, 90]]\n    assert solution.minimumEffortPath(heights) == 50", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[1, 50], [100, 2]]\n    assert solution.minimumEffortPath(heights) == 49", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[100, 20], [5, 98]]\n    assert solution.minimumEffortPath(heights) == 93", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15]]\n    assert solution.minimumEffortPath(heights) == 0", "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[1, 2], [3, 4], [5, 6], [7, 8]]\n    assert solution.minimumEffortPath(heights) == 1"]}
{"task_num": 1632, "task_title": "Rank Transform of a Matrix", "func_name": "matrixRankTransform", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self):\n    self.id = {}\n\n  def union(self, u: int, v: int) -> None:\n    self.id.setdefault(u, u)\n    self.id.setdefault(v, v)\n    i = self._find(u)\n    j = self._find(v)\n    if i != j:\n      self.id[i] = j\n\n  def getGroupIdToValues(self) -> Dict[int, List[int]]:\n    groupIdToValues = collections.defaultdict(list)\n    for u in self.id.keys():\n      groupIdToValues[self._find(u)].append(u)\n    return groupIdToValues\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def matrixRankTransform(self, matrix: List[List[int]]) -> List[List[int]]:\n    m = len(matrix)\n    n = len(matrix[0])\n    ans = [[0] * n for _ in range(m)]\n    valToGrids = collections.defaultdict(list)\n    maxRankSoFar = [0] * (m + n)\n\n    for i, row in enumerate(matrix):\n      for j, val in enumerate(row):\n        valToGrids[val].append((i, j))\n\n    for _, grids in sorted(valToGrids.items()):\n      uf = UnionFind()\n      for i, j in grids:\n        uf.union(i, j + m)\n      for values in uf.getGroupIdToValues().values():\n        maxRank = max(maxRankSoFar[i] for i in values)\n        for i in values:\n          maxRankSoFar[i] = maxRank + 1\n      for i, j in grids:\n        ans[i][j] = maxRankSoFar[i]\n\n    return ans\n", "tests": ["def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[1, 2], [3, 4]]\n    expected_output = [[1, 2], [3, 4]]\n    assert solution.matrixRankTransform(matrix) == expected_output", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[1, 2], [2, 1]]\n    expected_output = [[1, 2], [2, 1]]\n    assert solution.matrixRankTransform(matrix) == expected_output", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[1], [2, 3]]\n    expected_output = [[1], [2, 3]]\n    assert solution.matrixRankTransform(matrix) == expected_output", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[1, 1], [1, 1]]\n    expected_output = [[1, 1], [1, 1]]\n    assert solution.matrixRankTransform(matrix) == expected_output", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[-2, -1], [-3, -4]]\n    expected_output = [[1, 2], [3, 4]]\n    assert solution.matrixRankTransform(matrix) == expected_output", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[3, 1], [4, 2]]\n    expected_output = [[2, 1], [3, 2]]\n    assert solution.matrixRankTransform(matrix) == expected_output", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[1], [2, 3, 4], [5]]\n    expected_output = [[1], [2, 3, 4], [5]]\n    assert solution.matrixRankTransform(matrix) == expected_output", "def test_matrixRankTransform():\n    solution = Solution()\n    m = 100\n    n = 100\n    matrix = [[i * n + j for j in range(n)] for i in range(m)]\n    expected_output = [[i * n + j + 1 for j in range(n)] for i in range(m)]\n    assert solution.matrixRankTransform(matrix) == expected_output", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[1], [2], [3], [4]]\n    expected_output = [[1], [2], [3], [4]]\n    assert solution.matrixRankTransform(matrix) == expected_output", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[3, 2], [1, 0]]\n    expected_output = [[4, 3], [2, 1]]\n    assert solution.matrixRankTransform(matrix) == expected_output", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[10, 5], [6, 2], [3, 8]]\n    expected_output = [[4, 2], [3, 1], [2, 3]]\n    assert solution.matrixRankTransform(matrix) == expected_output", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n    expected_output = [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\n    assert solution.matrixRankTransform(matrix) == expected_output", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[-1000, 500], [700, -300]]\n    expected_output = [[2, 1], [3, 4]]\n    assert solution.matrixRankTransform(matrix) == expected_output", "def test_matrixRankTransform():\n    solution = Solution()\n    m = 100\n    n = 50\n    matrix = [[i * n + j for j in range(n)] for i in range(m)]\n    expected_output = [[i * n + j + 1 for j in range(n)] for i in range(m)]\n    assert solution.matrixRankTransform(matrix) == expected_output", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[0], [1], [2], [3]]\n    expected_output = [[1], [2], [3], [4]]\n    assert solution.matrixRankTransform(matrix) == expected_output", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[1, 2, 3]]\n    expected_output = [[1, 2, 3]]\n    assert solution.matrixRankTransform(matrix) == expected_output", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[1], [2, 3, 4], [5, 6]]\n    expected_output = [[1], [2, 3, 4], [5, 6]]\n    assert solution.matrixRankTransform(matrix) == expected_output", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[10, 2], [5, 3]]\n    expected_output = [[4, 1], [2, 3]]\n    assert solution.matrixRankTransform(matrix) == expected_output", "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[-5, 0], [1, -2]]\n    expected_output = [[3, 1], [2, 4]]\n    assert solution.matrixRankTransform(matrix) == expected_output", "def test_matrixRankTransform():\n    solution = Solution()\n    import random\n    m = 10\n    n = 15\n    values = list(range(1, m * n + 1))\n    random.shuffle(values)\n    matrix = [values[i * n:(i + 1) * n] for i in range(m)]\n    random.shuffle(matrix)\n    expected_output = sorted(range(1, m * n + 1))\n    assert solution.matrixRankTransform(matrix) == expected_output"]}
{"task_num": 1654, "task_title": "Minimum Jumps to Reach Home", "func_name": "minimumJumps", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import Enum\n\n\nclass Direction(Enum):\n  kForward = 0\n  kBackward = 1\n\n\nclass Solution:\n  def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\n    furthest = max(x + a + b, max(pos + a + b for pos in forbidden))\n    seenForward = {pos for pos in forbidden}\n    seenBackward = {pos for pos in forbidden}\n\n    q = collections.deque([(Direction.kForward, 0)])\n\n    ans = 0\n    while q:\n      for _ in range(len(q)):\n        dir, pos = q.popleft()\n        if pos == x:\n          return ans\n        forward = pos + a\n        backward = pos - b\n        if forward <= furthest and forward not in seenForward:\n          seenForward.add(forward)\n          q.append((Direction.kForward, forward))\n        if dir == Direction.kForward and backward >= 0 and backward not in seenBackward:\n          seenBackward.add(backward)\n          q.append((Direction.kBackward, backward))\n      ans += 1\n\n    return -1\n", "tests": ["def test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([4, 2, 5], 6, 1, 7) == 4", "def test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([1, 2, 3], 2, 5, 0) == -1", "def test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([3], 2, 1, 5) == 4", "def test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([0], 10, 100, 20) == -1", "def test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([0], 2, 3, 0) == 0", "def test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([1, 3], 2, 1, 4) == -1", "def test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([0], 1, 2, 3) == -1", "def test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([0], 2, 1, 5) == -1", "def test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([0], 3, 1, 8) == -1", "def test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([0], 5, 3, 1) == -1", "def test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([0], 5, 3, 1) == -1", "def test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([0], 5, 3, 6) == -1", "def test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([0], 5, 3, 11) == -1", "def test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([0], 5, 3, 16) == -1", "def test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([0], 5, 3, 21) == -1", "def test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([0], 5, 3, 26) == -1", "def test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([0], 5, 3, 31) == -1", "def test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([0], 5, 3, 36) == -1", "def test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([0], 5, 3, 41) == -1", "def test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([0], 5, 3, 46) == -1"]}
{"task_num": 1655, "task_title": "Distribute Repeating Integers", "func_name": "canDistribute", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\n    freqs = list(collections.Counter(nums).values())\n    validDistribution = self._getValidDistribution(freqs, quantity)\n    n = len(freqs)\n    m = len(quantity)\n    maxMask = 1 << m\n    dp = [[False] * maxMask for _ in range(n + 1)]\n    dp[n][maxMask - 1] = True\n\n    for i in range(n - 1, -1, -1):\n      for mask in range(maxMask):\n        dp[i][mask] = dp[i + 1][mask]\n        availableMask = ~mask & (maxMask - 1)\n        submask = availableMask\n        while submask > 0:\n          if validDistribution[i][submask]:\n            dp[i][mask] = dp[i][mask] or dp[i + 1][mask | submask]\n          submask = (submask - 1) & availableMask\n\n    return dp[0][0]\n\n  def _getValidDistribution(self, freqs: List[int], quantity: List[int]) -> List[List[bool]]:\n    maxMask = 1 << len(quantity)\n    validDistribution = [[False] * maxMask for _ in range(len(freqs))]\n    for i, freq in enumerate(freqs):\n      for mask in range(maxMask):\n        if freq >= self._getQuantitySum(quantity, mask):\n          validDistribution[i][mask] = True\n    return validDistribution\n\n  def _getQuantitySum(self, quantity: List[int], mask: int) -> int:\n    res=[]\n    for i, q in enumerate(quantity):\n      if mask >> i & 1:\n        res.append(q)\n    return sum(res)\n", "tests": ["def test_canDistribute():\n    solution = Solution()\n    assert solution.canDistribute([1, 2, 3, 4], [2, 1]) == True", "def test_canDistribute():\n    solution = Solution()\n    assert solution.canDistribute([1, 1, 2, 3], [2, 1]) == True", "def test_canDistribute():\n    solution = Solution()\n    assert solution.canDistribute([1, 2, 3], [4]) == False", "def test_canDistribute():\n    solution = Solution()\n    assert solution.canDistribute([1, 2, 3, 4, 5], [1, 1, 1]) == True", "def test_canDistribute():\n    solution = Solution()\n    assert solution.canDistribute([1, 1, 1, 2], [3]) == True", "def test_canDistribute():\n    solution = Solution()\n    assert solution.canDistribute([1], [1]) == True", "def test_canDistribute():\n    solution = Solution()\n    assert solution.canDistribute([1, 2, 3, 4, 5, 6], [1, 1, 1, 1]) == True", "def test_canDistribute():\n    solution = Solution()\n    assert solution.canDistribute([1, 2, 3, 4], [5]) == False", "def test_canDistribute():\n    solution = Solution()\n    assert solution.canDistribute([1, 2, 3], [1, 2]) == False", "def test_canDistribute():\n    solution = Solution()\n    assert solution.canDistribute([1, 1, 2, 2], [3]) == True", "def test_canDistribute():\n    solution = Solution()\n    assert solution.canDistribute([1, 2, 3, 4], [1, 2, 3]) == False", "def test_canDistribute():\n    solution = Solution()\n    assert solution.canDistribute([1], [2]) == False", "def test_canDistribute():\n    solution = Solution()\n    assert solution.canDistribute([1, 1, 1], [1, 1, 1]) == True", "def test_canDistribute():\n    solution = Solution()\n    assert solution.canDistribute([1, 2, 3], [2, 2]) == False", "def test_canDistribute():\n    solution = Solution()\n    assert solution.canDistribute([1, 2, 3, 4], [1]) == True", "def test_canDistribute():\n    solution = Solution()\n    assert solution.canDistribute([1, 2, 3, 4, 5], [1, 1, 1, 1]) == True", "def test_canDistribute():\n    solution = Solution()\n    assert solution.canDistribute([1], [2]) == False", "def test_canDistribute():\n    solution = Solution()\n    assert solution.canDistribute([1, 2, 3, 4], [5]) == False", "def test_canDistribute():\n    solution = Solution()\n    assert solution.canDistribute([1, 2, 3, 4], [1, 2, 3]) == False", "def test_canDistribute():\n    solution = Solution()\n    assert solution.canDistribute([1], [2]) == False"]}
{"task_num": 1681, "task_title": "Minimum Incompatibility", "func_name": "minimumIncompatibility", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def __init__(self):\n    self.kMaxNum = 16\n\n  def minimumIncompatibility(self, nums: List[int], k: int) -> int:\n    kMaxCompatibility = (16 - 1) * (16 // 2)\n    n = len(nums)\n    subsetSize = n // k\n    maxMask = 1 << n\n    incompatibilities = self._getIncompatibilities(nums, subsetSize)\n\n    dp = [kMaxCompatibility] * maxMask\n    dp[0] = 0\n\n    for mask in range(1, maxMask):\n      if mask.bit_count() % subsetSize != 0:\n        continue\n      submask = mask\n      while submask > 0:\n        if incompatibilities[submask] != -1:\n          dp[mask] = min(dp[mask], dp[mask - submask] + incompatibilities[submask])\n        submask = (submask - 1) & mask\n\n    if dp[-1] != kMaxCompatibility:\n      return dp[-1]\n    else:\n      return -1\n\n  def _getIncompatibilities(self, nums: List[int], subsetSize: int) -> List[int]:\n    maxMask = 1 << len(nums)\n    incompatibilities = [-1] * maxMask\n    for mask in range(maxMask):\n      if mask.bit_count() == subsetSize and self._isUnique(nums, mask, subsetSize):\n        incompatibilities[mask] = self._getIncompatibility(nums, mask)\n    return incompatibilities\n\n  def _isUnique(self, nums: List[int], mask: int, subsetSize: int) -> bool:\n    used = 0\n    for i, num in enumerate(nums):\n      if mask >> i & 1:\n        used |= 1 << num\n    return used.bit_count() == subsetSize\n\n  def _getIncompatibility(self, nums: List[int], mask: int) -> int:\n    mini = self.kMaxNum\n    maxi = 0\n    for i, num in enumerate(nums):\n      if mask >> i & 1:\n        maxi = max(maxi, num)\n        mini = min(mini, num)\n    return maxi - mini\n", "tests": ["def test_minimumIncompatibility():\n    solution = Solution()\n    result = solution.minimumIncompatibility([1, 2, 3, 4, 5], 2)", "def test_minimumIncompatibility():\n    solution = Solution()\n    result = solution.minimumIncompatibility([-3, -2, 0, 1, 4], 3)", "def test_minimumIncompatibility():\n    solution = Solution()\n    result = solution.minimumIncompatibility([5], 1)", "def test_minimumIncompatibility():\n    solution = Solution()\n    nums = list(range(100))\n    result = solution.minimumIncompatibility(nums, 10)", "def test_minimumIncompatibility():\n    solution = Solution()\n    nums = [5, 3, 8, 1, 2, 7, 4, 6]\n    k = 3\n    result = solution.minimumIncompatibility(nums, k)", "def test_minimumIncompatibility():\n    solution = Solution()\n    nums = [1, 2, 3, 4, 4]\n    k = 2\n    result = solution.minimumIncompatibility(nums, k)", "def test_minimumIncompatibility():\n    solution = Solution()\n    nums = [10, 20, 30, 40, 50, 60, 70, 80]\n    k = 4\n    result = solution.minimumIncompatibility(nums, k)", "def test_minimumIncompatibility():\n    solution = Solution()\n    nums = [-10, -5, 0, 5, 10]\n    k = 2\n    result = solution.minimumIncompatibility(nums, k)", "def test_minimumIncompatibility():\n    import random\n    nums = random.sample(range(1000), 500)\n    k = random.randint(2, 50)\n    solution = Solution()\n    result = solution.minimumIncompatibility(nums, k)", "def test_minimumIncompatibility():\n    solution = Solution()\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    k = 2\n    result = solution.minimumIncompatibility(nums, k)", "def test_minimumIncompatibility():\n    import random\n    nums = [random.choice([50, -50]) for _ in range(10000)]\n    k = random.randint(2, 500)\n    solution = Solution()\n    result = solution.minimumIncompatibility(nums, k)", "def test_minimumIncompatibility():\n    \"\"\"\n    Test case where n is equal to k, meaning there's only one partition.\n    \n    The minimum incompatibility is simply the maximum element in this single partition,\n    which is also the last element since they are sorted.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5]\n    k = len(nums)\n    assert Solution().minimumIncompatibility(nums, k) == nums[-1]", "def test_minimumIncompatibility():\n    \"\"\"\n    Test case with negative numbers to ensure proper handling of negative values.\n    \n    The minimum incompatibility is still determined by the maximum difference between consecutive elements.\n    \"\"\"\n    nums = [-5, -1, 0, 3, 7]\n    k = 2\n    assert Solution().minimumIncompatibility(nums, k) == 4", "def test_minimumIncompatibility():\n    \"\"\"\n    Test case where n equals k equals 1, meaning there's only one element.\n    \n    The minimum incompatibility is 0 since there are no elements to compare.\n    \"\"\"\n    nums = [42]\n    k = 1\n    assert Solution().minimumIncompatibility(nums, k) == 0", "def test_minimumIncompatibility():\n    \"\"\"\n    Test case with an unsorted array.\n    \n    The minimum incompatibility should still be calculated based on the sorted order of elements.\n    \"\"\"\n    nums = [3, 1, 4, 2]\n    k = 2\n    assert Solution().minimumIncompatibility(nums, k) == 3", "def test_minimumIncompatibility():\n    \"\"\"\n    Test case with repeating elements in the array.\n\n    The minimum incompatibility is determined by the maximum difference between consecutive elements,\n    even if there are repeated values.\n    \"\"\"\n    nums = [1, 2, 2, 3, 4]\n    k = 3\n    assert Solution().minimumIncompatibility(nums, k) == 2", "def test_minimumIncompatibility():\n    \"\"\"\n    Test case with a large array and a random k value.\n\n    This tests the efficiency of the algorithm on larger inputs.\n    \"\"\"\n    import random\n    n = 10000\n    nums = list(range(1, n + 1))\n    random.shuffle(nums)\n    k = random.randint(2, n - 1)\n    expected_incompatibility = n - (k - 1)\n    assert Solution().minimumIncompatibility(nums, k) == expected_incompatibility", "def test_minimumIncompatibility():\n    \"\"\"\n    Test case where all elements in the array are identical.\n\n    The minimum incompatibility is 0 since there are no differences between elements.\n    \"\"\"\n    n = 10\n    nums = [5] * n\n    k = n // 2\n    assert Solution().minimumIncompatibility(nums, k) == 0", "def test_minimumIncompatibility():\n    \"\"\"\n    Test case with an empty array.\n\n    The minimum incompatibility is undefined, but the function should handle it gracefully by returning a sensible value (e.g., -1 or None).\n    \"\"\"\n    nums = []\n    k = 0\n    assert Solution().minimumIncompatibility(nums, k) == -1", "def test_minimumIncompatibility():\n    \"\"\"\n    Test case where k is larger than n.\n\n    The minimum incompatibility cannot be calculated since it's not possible to partition the array.\n    The function should handle this gracefully by returning a sensible value (e.g., -1 or None).\n    \"\"\"\n    nums = [1, 2, 3]\n    k = 4\n    assert Solution().minimumIncompatibility(nums, k) == -1"]}
{"task_num": 1687, "task_title": "Delivering Boxes from Storage to Ports", "func_name": "boxDelivering", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\n    n = len(boxes)\n    dp = [0] * (n + 1)\n    trips = 2\n    weight = 0\n\n    l = 0\n    for r in range(n):\n      weight += boxes[r][1]\n\n      if r > 0 and boxes[r][0] != boxes[r - 1][0]:\n        trips += 1\n\n      while r - l + 1 > maxBoxes or weight > maxWeight or (l < r and dp[l + 1] == dp[l]):\n        weight -= boxes[l][1]\n        if boxes[l][0] != boxes[l + 1][0]:\n          trips -= 1\n        l += 1\n\n      dp[r + 1] = dp[l] + trips\n\n    return dp[n]\n", "tests": ["def test_boxDelivering():\n    solution = Solution()\n    assert solution.boxDelivering([[1, 2], [1, 2], [1, 3]], 2, 3, 6) == 4", "def test_boxDelivering():\n    solution = Solution()\n    assert solution.boxDelivering([[1, 2], [2, 3], [3, 4]], 3, 5, 10) == 6", "def test_boxDelivering():\n    solution = Solution()\n    assert solution.boxDelivering([[1, 5], [2, 4], [3, 3]], 3, 7, 12) == 6", "def test_boxDelivering():\n    solution = Solution()\n    assert solution.boxDelivering([[1, 2], [1, 3], [1, 4]], 1, 2, 5) == 6", "def test_boxDelivering():\n    solution = Solution()\n    assert solution.boxDelivering([[1, 2], [1, 3], [2, 4]], 2, 3, 9) == 5", "def test_boxDelivering():\n    solution = Solution()\n    assert solution.boxDelivering([[1, 2], [2, 3], [2, 4], [2, 5]], 2, 4, 10) == 7", "def test_boxDelivering():\n    solution = Solution()\n    assert solution.boxDelivering([[1, 2], [3, 4], [5, 6]], 3, 6, 15) == 7", "def test_boxDelivering():\n    solution = Solution()\n    assert solution.boxDelivering([[1, 2], [3, 4], [5, 6], [7, 8]], 4, 8, 20) == 9", "def test_boxDelivering():\n    solution = Solution()\n    assert solution.boxDelivering([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]], 5, 10, 30) == 11", "def test_boxDelivering():\n    solution = Solution()\n    assert solution.boxDelivering([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12]], 6, 12, 40) == 13", "def test_boxDelivering():\n    solution = Solution()\n    assert solution.boxDelivering([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12], [13, 14]], 7, 14, 50) == 15", "def test_boxDelivering():\n    solution = Solution()\n    assert solution.boxDelivering([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12], [13, 14], [15, 16]], 8, 16, 60) == 17", "def test_boxDelivering():\n    solution = Solution()\n    assert solution.boxDelivering([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12], [13, 14], [15, 16], [17, 18]], 9, 18, 70) == 19", "def test_boxDelivering():\n    solution = Solution()\n    assert solution.boxDelivering([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12], [13, 14], [15, 16], [17, 18], [19, 20]], 10, 20, 80) == 21", "def test_boxDelivering():\n    solution = Solution()\n    assert solution.boxDelivering([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12], [13, 14], [15, 16], [17, 18], [19, 20], [21, 22]], 11, 22, 90) == 23", "def test_boxDelivering():\n    solution = Solution()\n    assert solution.boxDelivering([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12], [13, 14], [15, 16], [17, 18], [19, 20], [21, 22], [23, 24]], 12, 24, 100) == 25", "def test_boxDelivering():\n    solution = Solution()\n    assert solution.boxDelivering([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12], [13, 14], [15, 16], [17, 18], [19, 20], [21, 22], [23, 24], [25, 26]], 13, 26, 110) == 27", "def test_boxDelivering():\n    solution = Solution()\n    assert solution.boxDelivering([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12], [13, 14], [15, 16], [17, 18], [19, 20], [21, 22], [23, 24], [25, 26], [27, 28]], 14, 28, 120) == 29", "def test_boxDelivering():\n    solution = Solution()\n    assert solution.boxDelivering([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12], [13, 14], [15, 16], [17, 18], [19, 20], [21, 22], [23, 24], [25, 26], [27, 28], [29, 30]], 15, 30, 130) == 31", "def test_boxDelivering():\n    solution = Solution()\n    assert solution.boxDelivering([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12], [13, 14], [15, 16], [17, 18], [19, 20], [21, 22], [23, 24], [25, 26], [27, 28], [29, 30], [31, 32]], 16, 32, 140) == 33"]}
{"task_num": 1705, "task_title": "Maximum Number of Eaten Apples", "func_name": "eatenApples", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def eatenApples(self, apples: List[int], days: List[int]) -> int:\n    n = len(apples)\n    ans = 0\n    minHeap = []\n\n    i = 0\n    while i < n or minHeap:\n      while minHeap and minHeap[0][0] <= i:\n        heapq.heappop(minHeap)\n      if i < n and apples[i] > 0:\n        heapq.heappush(minHeap, (i + days[i], apples[i]))\n      if minHeap:\n        rottenDay, numApples = heapq.heappop(minHeap)\n        if numApples > 1:\n          heapq.heappush(minHeap, (rottenDay, numApples - 1))\n        ans += 1\n      i += 1\n\n    return ans\n", "tests": ["def test_eatenApples():\n    solution = Solution()\n    assert solution.eatenApples([1, 2, 3, 5, 2], [3, 2, 1, 4, 2]) == 7", "def test_eatenApples():\n    solution = Solution()\n    assert solution.eatenApples([0, 0, 0], [1, 2, 3]) == 0", "def test_eatenApples():\n    solution = Solution()\n    assert solution.eatenApples([0, 0, 1], [3, 2, 1]) == 1", "def test_eatenApples():\n    solution = Solution()\n    apples = [5]\n    days = [2]\n    assert solution.eatenApples(apples, days) == 1", "def test_eatenApples():\n    solution = Solution()\n    apples = [1] * 100\n    days = [2] * 100\n    assert solution.eatenApples(apples, days) == 50", "def test_eatenApples():\n    solution = Solution()\n    apples = [1]\n    days = [365]\n    assert solution.eatenApples(apples, days) == 1", "def test_eatenApples():\n    solution = Solution()\n    apples = [i for i in range(1, 501)]\n    days = [i + 500 for i in range(1, 501)]\n    assert solution.eatenApples(apples, days) == 124950", "def test_eatenApples():\n    solution = Solution()\n    apples = [random.randint(1, 100) for _ in range(1000)]\n    days = [random.randint(2, 1000) for _ in range(1000)]\n    assert solution.eatenApples(apples, days) <= sum(apples)", "def test_eatenApples():\n    solution = Solution()\n    apples = [i * 6 for i in range(1, 501)]\n    days = [i + 5000 for i in range(1, 501)]\n    assert solution.eatenApples(apples, days) == 49750", "def test_eatenApples():\n    solution = Solution()\n    apples = [random.randint(1, 100) for _ in range(1000)]\n    days = [random.randint(2, 1000) for _ in range(1000)]\n    assert solution.eatenApples(apples, days) <= sum(apples)", "def test_eatenApples():\n    solution = Solution()\n    apples = [random.randint(1, 100) for _ in range(1000)]\n    days = [random.randint(2, 1000) for _ in range(1000)]\n    assert solution.eatenApples(apples, days) <= sum(apples)", "def test_eatenApples(self):\n    apples = [0] * 10\n    days = [0] * 10\n    expected_result = 0\n    self.assertEqual(solution.eatenApples(apples, days), expected_result)", "def test_eatenApples(self):\n    apples = [-5, -2, 0, 3, 1]\n    days = [7, 4, 10, 9, 8]\n    expected_result = 6\n    self.assertEqual(solution.eatenApples(apples, days), expected_result)", "def test_eatenApples(self):\n    apples = [100000] * 10\n    days = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    expected_result = sum(apples) - len(apples)\n    self.assertEqual(solution.eatenApples(apples, days), expected_result)", "def test_eatenApples(self):\n    apples = [random.randint(1, 100) for _ in range(10 ** 4)]\n    days = [random.randint(1, 10 ** 3) for _ in range(10 ** 4)]\n    expected_result = sum(apples)\n    self.assertEqual(solution.eatenApples(apples, days), expected_result)", "def test_eatenApples(self):\n    apples = [1, 2, 3]\n    days = [5] * 3\n    expected_result = sum(apples) - len(days)\n    self.assertEqual(solution.eatenApples(apples, days), expected_result)", "def test_eatenApples(self):\n    apples = [10 ** 6] * 10\n    days = [2, 2, 2, 2, 2, 2, 2, 2, 2, 2]\n    expected_result = sum(apples) - len(days)\n    self.assertEqual(solution.eatenApples(apples, days), expected_result)", "def test_eatenApples(self):\n    apples = [10 ** 6] * 10\n    days = [random.randint(1, 10) for _ in range(10)]\n    expected_result = sum(apples) - len(days)\n    self.assertEqual(solution.eatenApples(apples, days), expected_result)", "def test_eatenApples(self):\n    apples = [10 ** 6] * 10\n    days = [random.randint(1, 10) for _ in range(10)]\n    expected_result = sum(apples) - len(days)\n    self.assertEqual(solution.eatenApples(apples, days), expected_result)", "def test_eatenApples(self):\n    apples = [10 ** 6] * 10\n    days = [2, -3, 4, -5, 6, -7, 8, -9, 10, -11]\n    expected_result = sum(filter(lambda x: x > 0, apples))\n    self.assertEqual(solution.eatenApples(apples, days), expected_result)"]}
{"task_num": 1706, "task_title": "Where Will the Ball Fall", "func_name": "findBall", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findBall(self, grid: List[List[int]]) -> List[int]:\n    m = len(grid)\n    n = len(grid[0])\n    dp = [i for i in range(n)]\n    ans = [-1] * n\n\n    for i in range(m):\n      newDp = [-1] * n\n      for j in range(n):\n        if j + grid[i][j] < 0 or j + grid[i][j] == n:\n          continue\n        if grid[i][j] == 1 and grid[i][j + 1] == -1 or grid[i][j] == -1 and grid[i][j - 1] == 1:\n          continue\n        newDp[j + grid[i][j]] = dp[j]\n      dp = newDp\n\n    for i, ball in enumerate(dp):\n      if ball != -1:\n        ans[ball] = i\n\n    return ans\n", "tests": ["def test_findBall():\n    solution = Solution()\n    grid = [[-1]]\n    expected = [-1]\n    assert solution.findBall(grid) == expected", "def test_findBall():\n    solution = Solution()\n    grid = [[1, 1, 1], [-1, -1, -1]]\n    expected = [-1, -1, -1]\n    assert solution.findBall(grid) == expected", "def test_findBall():\n    solution = Solution()\n    grid = [[-1, 1], [-1, -1]]\n    expected = [1, -1]\n    assert solution.findBall(grid) == expected", "def test_findBall():\n    solution = Solution()\n    grid = [[1], [-1]]\n    expected = [-1]\n    assert solution.findBall(grid) == expected", "def test_findBall():\n    solution = Solution()\n    grid = [[-1, 1, -1], [1, -1, 1]]\n    expected = [-1, -1, -1]\n    assert solution.findBall(grid) == expected", "def test_findBall():\n    solution = Solution()\n    grid = [[1, -1], [-1, 1]]\n    expected = [0, 2]\n    assert solution.findBall(grid) == expected", "def test_findBall():\n    solution = Solution()\n    grid = [[1, 1, -1], [1, 1, 1]]\n    expected = [-1, -1, -1]\n    assert solution.findBall(grid) == expected", "def test_findBall():\n    solution = Solution()\n    grid = [[-1, -1], [-1, 1]]\n    expected = [-1, 0]\n    assert solution.findBall(grid) == expected", "def test_findBall():\n    solution = Solution()\n    grid = [[1, 1], [-1, -1]]\n    expected = [0, -1]\n    assert solution.findBall(grid) == expected", "def test_findBall():\n    solution = Solution()\n    grid = [[-1, 1, -1], [-1, 1, -1]]\n    expected = [-1, -1, -1]\n    assert solution.findBall(grid) == expected", "def test_findBall():\n    solution = Solution()\n    grid = [[1], [-1]]\n    expected = [0]\n    assert solution.findBall(grid) == expected", "def test_findBall():\n    solution = Solution()\n    grid = [[1, -1, 1], [-1, 1, -1]]\n    expected = [0, 2]\n    assert solution.findBall(grid) == expected", "def test_findBall():\n    solution = Solution()\n    grid = [[1], [1]]\n    expected = [-1]\n    assert solution.findBall(grid) == expected", "def test_findBall():\n    solution = Solution()\n    grid = [[-1, 1], [1, -1]]\n    expected = [-1, 0]\n    assert solution.findBall(grid) == expected", "def test_findBall():\n    solution = Solution()\n    grid = [[1, -1], [-1, 1]]\n    expected = [0, 2]\n    assert solution.findBall(grid) == expected", "def test_findBall():\n    solution = Solution()\n    grid = [[1, -1], [-1, 1]]\n    expected = [0, 2]\n    assert solution.findBall(grid) == expected", "def test_findBall():\n    solution = Solution()\n    grid = [[-1, 1], [1, -1]]\n    expected = [-1, 0]\n    assert solution.findBall(grid) == expected", "def test_findBall():\n    solution = Solution()\n    grid = [[1], [1]]\n    expected = [-1]\n    assert solution.findBall(grid) == expected", "def test_findBall():\n    solution = Solution()\n    grid = [[-1, 1], [-1, -1]]\n    expected = [0, -1]\n    assert solution.findBall(grid) == expected", "def test_findBall():\n    solution = Solution()\n    grid = [[1, -1, 1], [-1, -1, -1]]\n    expected = [0, -1, -1]\n    assert solution.findBall(grid) == expected"]}
{"task_num": 1707, "task_title": "Maximum XOR With an Element From Array", "func_name": "maximizeXor", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Optional\n\nclass TrieNode:\n  def __init__(self):\n    self.children: List[Optional[TrieNode]] = [None] * 2\n\n\nclass BitTrie:\n  def __init__(self, maxBit: int):\n    self.maxBit = maxBit\n    self.root = TrieNode()\n\n  def insert(self, num: int) -> None:\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n\n  def getMaxXor(self, num: int) -> int:\n    maxXor = 0\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      toggleBit = bit ^ 1\n      if node.children[toggleBit]:\n        maxXor = maxXor | 1 << i\n        node = node.children[toggleBit]\n      elif node.children[bit]:\n        node = node.children[bit]\n      else:\n        return 0\n    return maxXor\n\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, x: int, m: int):\n    self.queryIndex = queryIndex\n    self.x = x\n    self.m = m\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.x\n    yield self.m\n\n\nclass Solution:\n  def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n    ans = [-1] * len(queries)\n    maxBit = int(math.log2(max(max(nums), max(x for x, _ in queries))))\n    bitTrie = BitTrie(maxBit)\n\n    nums.sort()\n\n    i = 0\n    for queryIndex, x, m in sorted([IndexedQuery(i, x, m) for i, (x, m) in enumerate(queries)], key=lambda iq: iq.m):\n      while i < len(nums) and nums[i] <= m:\n        bitTrie.insert(nums[i])\n        i += 1\n      if i > 0 and nums[i - 1] <= m:\n        ans[queryIndex] = bitTrie.getMaxXor(x)\n\n    return ans\n", "tests": ["def test_maximizeXor():\n    solution = Solution()\n    nums = [0, 1, 2, 3, 4, 7]\n    queries = [[3, 5], [1, 2]]\n    expected = [3, 3]\n    assert solution.maximizeXor(nums, queries) == expected", "def test_maximizeXor():\n    solution = Solution()\n    nums = [5, 10, 20]\n    queries = [[3, 2], [7, 4]]\n    expected = [-1, -1]\n    assert solution.maximizeXor(nums, queries) == expected", "def test_maximizeXor():\n    solution = Solution()\n    nums = [1]\n    queries = [[2, 3]]\n    expected = [3]\n    assert solution.maximizeXor(nums, queries) == expected", "def test_maximizeXor():\n    solution = Solution()\n    nums = [0, 1, 2, 3]\n    queries = [[1, 4], [1, 4], [2, 5]]\n    expected = [3, 3, 3]\n    assert solution.maximizeXor(nums, queries) == expected", "def test_maximizeXor():\n    solution = Solution()\n    nums = [1023, 1024, 2047]\n    queries = [[512, 1023], [1024, 2047]]\n    expected = [1535, 2047]\n    assert solution.maximizeXor(nums, queries) == expected", "def test_maximizeXor():\n    solution = Solution()\n    nums = [-1, 0, 1]\n    queries = [[-2, 0], [0, 1]]\n    expected = [-3, 1]\n    assert solution.maximizeXor(nums, queries) == expected", "def test_maximizeXor():\n    solution = Solution()\n    nums = [1, 1, 2, 3]\n    queries = [[2, 4], [0, 1]]\n    expected = [3, 3]\n    assert solution.maximizeXor(nums, queries) == expected", "def test_maximizeXor():\n    solution = Solution()\n    nums = [8]\n    queries = [[0, 15]]\n    expected = [15]\n    assert solution.maximizeXor(nums, queries) == expected", "def test_maximizeXor():\n    solution = Solution()\n    nums = [1]\n    queries = [[2, 3], [4, 5], [6, 7]]\n    expected = [-1, -1, -1]\n    assert solution.maximizeXor(nums, queries) == expected", "def test_maximizeXor():\n    solution = Solution()\n    nums = [10, 20, 30, 40, 50]\n    queries = [[5, 15], [16, 30], [31, 45]]\n    expected = [-1, 60, 75]\n    assert solution.maximizeXor(nums, queries) == expected", "def test_maximizeXor():\n    solution = Solution()\n    nums = [-1, 0, 1, 2]\n    queries = [[-1, 1], [0, 2], [-3, -1]]\n    expected = [-2, 3, 0]\n    assert solution.maximizeXor(nums, queries) == expected", "def test_maximizeXor():\n    solution = Solution()\n    nums = [1023]\n    queries = [[1, 1024], [512, 1536], [768, 2048]]\n    expected = [1023, 1535, 2047]\n    assert solution.maximizeXor(nums, queries) == expected", "def test_maximizeXor():\n    solution = Solution()\n    nums = []\n    queries = []\n    expected = []\n    assert solution.maximizeXor(nums, queries) == expected", "def test_maximizeXor():\n    solution = Solution()\n    nums = [10, 20, 30]\n    queries = [[2, 5], [1, 4], [3, 6]]\n    expected = [-1, -1, 7]\n    assert solution.maximizeXor(nums, queries) == expected", "def test_maximizeXor():\n    solution = Solution()\n    nums = [10]\n    queries = [[20, 30]]\n    expected = [30]\n    assert solution.maximizeXor(nums, queries) == expected", "def test_maximizeXor():\n    solution = Solution()\n    nums = [1, 2, 3, 4, 5]\n    queries = [[0, 1], [1, 2], [2, 3]]\n    expected = [1, 3, 7]\n    assert solution.maximizeXor(nums, queries) == expected", "def test_maximizeXor():\n    solution = Solution()\n    nums = [1023]\n    queries = [[500000, 1000000], [1000001, 2000000]]\n    expected = [-1, -1]\n    assert solution.maximizeXor(nums, queries) == expected", "def test_maximizeXor():\n    solution = Solution()\n    nums = [10 ** 20]\n    queries = [[10 ** 19 - 1, 10 ** 20 + 1], [10 ** 20, 10 ** 20 + 1]]\n    expected = [10 ** 20 - 1, 2 * 10 ** 20]\n    assert solution.maximizeXor(nums, queries) == expected", "def test_maximizeXor():\n    solution = Solution()\n    nums = [1, 2, 3, 4, 5]\n    queries = [[0, 1], [6, 8], [2, 7]]\n    expected = [-1, -1, 7]\n    assert solution.maximizeXor(nums, queries) == expected", "def test_maximizeXor():\n    solution = Solution()\n    nums = [0, 1, 2, 3]\n    queries = [[0, 3], [0, 7], [4, 8]]\n    expected = [3, 7, -1]\n    assert solution.maximizeXor(nums, queries) == expected"]}
{"task_num": 1717, "task_title": "Maximum Score From Removing Substrings", "func_name": "maximumGain", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumGain(self, s: str, x: int, y: int) -> int:\n    if x > y:\n      return self._gain(s, 'ab', x, 'ba', y)\n    else:\n      return self._gain(s, 'ba', y, 'ab', x)\n\n  def _gain(self, s: str, sub1: str, point1: int, sub2: str, point2: int) -> int:\n    points = 0\n    stack1 = []\n    stack2 = []\n\n    for c in s:\n      if stack1 and stack1[-1] == sub1[0] and c == sub1[1]:\n        stack1.pop()\n        points += point1\n      else:\n        stack1.append(c)\n\n    for c in stack1:\n      if stack2 and stack2[-1] == sub2[0] and c == sub2[1]:\n        stack2.pop()\n        points += point2\n      else:\n        stack2.append(c)\n\n    return points\n", "tests": ["def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('aabab', 5, 4) == 9", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('abcde', 3, 2) == 0", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('abba', 1, 1) == 2", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('aabbccdd', 2, 3) == 10", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('abacabad', 5, 5) == 10", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('a', 1, 2) == 0", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('baab', 10, 1) == 20", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('abcbcabca', 1, 2) == 4", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('ba', 100, 50) == 50", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('aabbccdd', 3, 3) == 12", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('abbaaab', 1, 1) == 3", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('abcba', 2, 3) == 4", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('baabbb', 5, 1) == 20", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('ababba', 2, 3) == 10", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('abccba', 4, 6) == 12", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('aabbccdd', 5, 1) == 20", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('ababba', 1, 2) == 8", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('abbaab', 3, 4) == 16", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('ababbb', 2, 5) == 15", "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('ababba', 1, 5) == 20"]}
{"task_num": 1719, "task_title": "Number Of Ways To Reconstruct A Tree", "func_name": "checkWays", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def checkWays(self, pairs: List[List[int]]) -> int:\n    kMax = 501\n    graph = collections.defaultdict(list)\n    degrees = [0] * kMax\n    connected = [[False] * kMax for _ in range(kMax)]\n\n    for u, v in pairs:\n      graph[u].append(v)\n      graph[v].append(u)\n      degrees[u] += 1\n      degrees[v] += 1\n      connected[u][v] = True\n      connected[v][u] = True\n\n    for _, children in graph.items():\n      children.sort(key=lambda a: degrees[a], reverse=True)\n\n    root = next((i for i, d in enumerate(degrees) if d == len(graph) - 1), -1)\n    if root == -1:\n      return 0\n\n    hasMoreThanOneWay = False\n\n    def dfs(u: int, ancestors: List[int], seen: List[bool]) -> bool:\n      nonlocal hasMoreThanOneWay\n      seen[u] = True\n      for ancestor in ancestors:\n        if not connected[u][ancestor]:\n          return False\n      ancestors.append(u)\n      for v in graph[u]:\n        if seen[v]:\n          continue\n        if degrees[v] == degrees[u]:\n          hasMoreThanOneWay = True\n        if not dfs(v, ancestors, seen):\n          return False\n      ancestors.pop()\n      return True\n\n    if not dfs(root, [], [False] * kMax):\n      return 0\n    if hasMoreThanOneWay:\n      return 2\n    else:\n      return 1\n", "tests": ["def test_checkWays():\n    solution = Solution()\n    assert solution.checkWays([[1, 2], [2, 3], [3, 4]]) == 1", "def test_checkWays():\n    solution = Solution()\n    assert solution.checkWays([[1, 2]]) == 1", "def test_checkWays():\n    solution = Solution()\n    assert solution.checkWays([[1, 2], [3, 4]]) == 0", "def test_checkWays():\n    solution = Solution()\n    assert solution.checkWays([[1, 2], [2, 3], [3, 4], [4, 5], [1, 6]]) == 0", "def test_checkWays():\n    solution = Solution()\n    assert solution.checkWays([[1, 2], [1, 3], [1, 4], [1, 5]]) == 1", "def test_checkWays():\n    solution = Solution()\n    assert solution.checkWays([[1, 2], [2, 3], [3, 4], [4, 5], [1, 6]]) == 0", "def test_checkWays():\n    solution = Solution()\n    assert solution.checkWays([[1, 2], [1, 3], [2, 4], [3, 5]]) == 1", "def test_checkWays():\n    solution = Solution()\n    assert solution.checkWays([[1, 2], [2, 3], [3, 4], [4, 5], [6, 7], [7, 8], [1, 9], [1, 10], [1, 11]]) == 0", "def test_checkWays():\n    solution = Solution()\n    assert solution.checkWays([[1, 2], [2, 3], [3, 4], [4, 5], [6, 7], [7, 8], [1, 9], [1, 10], [1, 11]]) == 0", "def test_checkWays():\n    solution = Solution()\n    assert solution.checkWays([[1, 2], [2, 3], [3, 4], [4, 5], [6, 7], [7, 8], [1, 9], [1, 10], [1, 11]]) == 0", "def test_checkWays():\n    solution = Solution()\n    assert solution.checkWays([[1, 2], [2, 3], [3, 4], [4, 5], [6, 7], [7, 8], [1, 9], [1, 10], [1, 11]]) == 0", "def test_checkWays():\n    solution = Solution()\n    assert solution.checkWays([[1, 2], [2, 3], [3, 4], [4, 5], [6, 7], [7, 8], [1, 9], [1, 10], [1, 11]]) == 0", "def test_checkWays():\n    solution = Solution()\n    assert solution.checkWays([[1, 2], [2, 3], [3, 4], [4, 5], [6, 7], [7, 8], [1, 9], [1, 10], [1, 11]]) == 0", "def test_checkWays():\n    solution = Solution()\n    assert solution.checkWays([[1, 2], [2, 3], [3, 4], [4, 5], [6, 7], [7, 8], [1, 9], [1, 10], [1, 11]]) == 0", "def test_checkWays():\n    solution = Solution()\n    assert solution.checkWays([[1, 2], [2, 3], [3, 4], [4, 5], [6, 7], [7, 8], [1, 9], [1, 10], [1, 11]]) == 0", "def test_checkWays():\n    solution = Solution()\n    assert solution.checkWays([[1, 2], [2, 3], [3, 4], [4, 5], [6, 7], [7, 8], [1, 9], [1, 10], [1, 11]]) == 0", "def test_checkWays():\n    solution = Solution()\n    assert solution.checkWays([[1, 2], [2, 3], [3, 4], [4, 5], [6, 7], [7, 8], [1, 9], [1, 10], [1, 11]]) == 0", "def test_checkWays():\n    solution = Solution()\n    assert solution.checkWays([[1, 2], [2, 3], [3, 4], [4, 5], [6, 7], [7, 8], [1, 9], [1, 10], [1, 11]]) == 0", "def test_checkWays():\n    \"\"\"\n    Test with a large tree structure to ensure performance and correctness.\n    \"\"\"\n    num_nodes = 10000\n    nodes = list(range(1, num_nodes + 1))\n    for i in range(1, num_nodes):\n        yield ([nodes[i], nodes[2 * i]], [nodes[i], nodes[2 * i + 1]])\n    yield ([nodes[3], nodes[num_nodes // 4]], [nodes[num_nodes // 4], nodes[num_nodes // 5]])\n\ndef test_checkWays_with_single_edge():\n    \"\"\"\n    Test with the simplest possible graph (a single edge).\n    \"\"\"\n    solution = Solution()\n    assert solution.checkWays([[1, 2]]) == 1", "def test_checkWays():\n    \"\"\"\n    Test with a tree structure where the root has multiple paths to leaf nodes.\n    This ensures the function correctly identifies the tree structure.\n    \"\"\"\n    solution = Solution()\n    edges = [[1, 2], [1, 3], [2, 4], [2, 5], [3, 6], [3, 7]]\n    assert solution.checkWays(edges) == 1"]}
{"task_num": 1722, "task_title": "Minimize Hamming Distance After Swap Operations", "func_name": "minimumHammingDistance", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -> int:\n    n = len(source)\n    ans = 0\n    uf = UnionFind(n)\n    groupIdToCount = [collections.Counter() for _ in range(n)]\n\n    for a, b in allowedSwaps:\n      uf.unionByRank(a, b)\n\n    for i in range(n):\n      groupIdToCount[uf.find(i)][source[i]] += 1\n\n    for i in range(n):\n      groupId = uf.find(i)\n      count = groupIdToCount[groupId]\n      if target[i] not in count:\n        ans += 1\n      else:\n        count[target[i]] -= 1\n        if count[target[i]] == 0:\n          del count[target[i]]\n\n    return ans\n", "tests": ["def test_minimumHammingDistance():\n    solution = Solution()\n    assert solution.minimumHammingDistance([1, 2, 3], [1, 2, 4], [[0, 1]]) == 1", "def test_minimumHammingDistance():\n    solution = Solution()\n    assert solution.minimumHammingDistance([4, 3, 2, 1], [1, 2, 3, 4], [[0, 2], [1, 3]]) == 0", "def test_minimumHammingDistance():\n    solution = Solution()\n    assert solution.minimumHammingDistance([1, 2, 3], [4, 5, 6], [[0, 1]]) == 3", "def test_minimumHammingDistance():\n    solution = Solution()\n    assert solution.minimumHammingDistance([1, 2, 3], [1, 2, 3], [[0, 1], [1, 2], [2, 0]]) == 0", "def test_minimumHammingDistance():\n    solution = Solution()\n    assert solution.minimumHammingDistance([10, 20, 30], [5, 15, 25], [[0, 1], [1, 2], [2, 0]]) == 3", "def test_minimumHammingDistance():\n    solution = Solution()\n    assert solution.minimumHammingDistance([1, 2, 3], [1, 2, 3], [[0, 2], [1, 3], [0, 1]]) == 0", "def test_minimumHammingDistance():\n    solution = Solution()\n    assert solution.minimumHammingDistance([1, 2, 3], [4, 5, 6], [[0, 1], [1, 2]]) == 3", "def test_minimumHammingDistance():\n    solution = Solution()\n    assert solution.minimumHammingDistance([1, 2, 3], [3, 2, 1], [[0, 1]]) == 0", "def test_minimumHammingDistance():\n    solution = Solution()\n    assert solution.minimumHammingDistance([1, 2, 3], [3, 2, 4], [[0, 2]]) == 1", "def test_minimumHammingDistance():\n    solution = Solution()\n    assert solution.minimumHammingDistance([4, 3, 2, 1], [1, 2, 3, 5], [[0, 1], [1, 2]]) == 2", "def test_minimumHammingDistance():\n    solution = Solution()\n    assert solution.minimumHammingDistance([1, 2, 3], [5, 4, 3], [[0, 1]]) == 2", "def test_minimumHammingDistance():\n    solution = Solution()\n    assert solution.minimumHammingDistance([1, 2, 3], [1, 2, 4], [[0, 2], [1, 2]]) == 1", "def test_minimumHammingDistance():\n    solution = Solution()\n    assert solution.minimumHammingDistance([10, 20, 30], [5, 15, 25], [[0, 2]]) == 3", "def test_minimumHammingDistance():\n    solution = Solution()\n    assert solution.minimumHammingDistance([1, 2, 3], [3, 2, 4], [[0, 2], [1, 3]]) == 3", "def test_minimumHammingDistance():\n    solution = Solution()\n    assert solution.minimumHammingDistance([1, 2, 3], [5, 4, 3], [[0, 1]]) == 2", "def test_minimumHammingDistance():\n    solution = Solution()\n    assert solution.minimumHammingDistance([1, 2, 3], [3, 2, 4], [[0, 2]]) == 1", "def test_minimumHammingDistance():\n    solution = Solution()\n    assert solution.minimumHammingDistance([1, 2, 3], [5, 4, 3], [[0, 2]]) == 3", "def test_minimumHammingDistance():\n    solution = Solution()\n    assert solution.minimumHammingDistance([1, 2, 3], [1, 2, 3], [[0, 1]]) == 1", "def test_minimumHammingDistance():\n    solution = Solution()\n    assert solution.minimumHammingDistance([4, 3, 2, 1], [5, 6, 7, 8], [[0, 2]]) == 4", "def test_minimumHammingDistance():\n    solution = Solution()\n    assert solution.minimumHammingDistance([1, 2, 3], [3, 2, 4], [[0, 2], [1, 3]]) == 3"]}
{"task_num": 1735, "task_title": "Count Ways to Make Array With Product", "func_name": "waysToFillArray", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def waysToFillArray(self, queries: List[List[int]]) -> List[int]:\n    kMod = 1_000_000_007\n    kMax = 10_000\n    minPrimeFactors = self._sieveEratosthenes(kMax + 1)\n\n    @functools.lru_cache(None)\n    def fact(i: int) -> int:\n      return 1 if i <= 1 else i * fact(i - 1) % kMod\n\n    @functools.lru_cache(None)\n    def inv(i: int) -> int:\n      return pow(i, kMod - 2, kMod)\n\n    @functools.lru_cache(None)\n    def nCk(n: int, k: int) -> int:\n      return fact(n) * inv(fact(k)) * inv(fact(n - k)) % kMod\n\n    ans = []\n\n    for n, k in queries:\n      res = 1\n      for freq in self._getPrimeFactorsCount(k, minPrimeFactors).values():\n        res = res * nCk(n - 1 + freq, freq) % kMod\n      ans.append(res)\n\n    return ans\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeFactorsCount(self, num: int, minPrimeFactors: List[int]) -> Dict[int, int]:\n    count = collections.Counter()\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      while num % divisor == 0:\n        num //= divisor\n        count[divisor] += 1\n    return count\n", "tests": ["def test_waysToFillArray():\n    solution = Solution()\n    assert solution.waysToFillArray([[2, 6]]) == [3]", "def test_waysToFillArray():\n    solution = Solution()\n    assert solution.waysToFillArray([[10, 1000000007]]) == [1]", "def test_waysToFillArray():\n    solution = Solution()\n    assert solution.waysToFillArray([[3, 8]]) == [4]", "def test_waysToFillArray():\n    solution = Solution()\n    assert solution.waysToFillArray([[5, 1]]) == [1]", "def test_waysToFillArray():\n    solution = Solution()\n    assert solution.waysToFillArray([[1, 2]]) == [1]", "def test_waysToFillArray():\n    solution = Solution()\n    assert solution.waysToFillArray([[4, 16]]) == [5]", "def test_waysToFillArray():\n    solution = Solution()\n    assert solution.waysToFillArray([[3, 9]]) == [2]", "def test_waysToFillArray():\n    solution = Solution()\n    assert solution.waysToFillArray([[10000, 2]]) == [1]", "def test_waysToFillArray():\n    solution = Solution()\n    assert solution.waysToFillArray([[2, 6], [3, 8], [4, 16]]) == [3, 4, 5]", "def test_waysToFillArray():\n    solution = Solution()\n    assert solution.waysToFillArray([[1, 1]]) == [1]", "def test_waysToFillArray():\n    solution = Solution()\n    assert solution.waysToFillArray([[1, 1000000007]]) == [1]", "def test_waysToFillArray():\n    solution = Solution()\n    assert solution.waysToFillArray([[0, 1]]) == [1]", "def test_waysToFillArray():\n    solution = Solution()\n    assert solution.waysToFillArray([[2, -6]]) == [0]", "def test_waysToFillArray():\n    solution = Solution()\n    assert solution.waysToFillArray([[1, 2], [1, 3], [1, 4]]) == [1, 1, 1]", "def test_waysToFillArray():\n    solution = Solution()\n    assert solution.waysToFillArray([[2, 1000000000]]) == [500000004]", "def test_waysToFillArray():\n    solution = Solution()\n    assert solution.waysToFillArray([[2, 2]]) == [3]", "def test_waysToFillArray():\n    solution = Solution()\n    assert solution.waysToFillArray([[3, 81]]) == [5]", "def test_waysToFillArray():\n    solution = Solution()\n    assert solution.waysToFillArray([[2, 10]]) == [3]", "def test_waysToFillArray():\n    solution = Solution()\n    assert solution.waysToFillArray([[1, 2]]) == [3]", "def test_waysToFillArray():\n    solution = Solution()\n    assert solution.waysToFillArray([[2, 100]]) == [5]"]}
{"task_num": 1765, "task_title": "Map of Highest Peak", "func_name": "highestPeak", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(isWater)\n    n = len(isWater[0])\n    ans = [[-1] * n for _ in range(m)]\n    q = collections.deque()\n\n    for i in range(m):\n      for j in range(n):\n        if isWater[i][j] == 1:\n          q.append((i, j))\n          ans[i][j] = 0\n\n    while q:\n      i, j = q.popleft()\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if ans[x][y] != -1:\n          continue\n        ans[x][y] = ans[i][j] + 1\n        q.append((x, y))\n\n    return ans\n", "tests": ["def test_highestPeak():\n    solution = Solution()\n    assert solution.highestPeak([[0, 1], [1, 0]]) == [[1, 0], [0, 1]]", "def test_highestPeak():\n    solution = Solution()\n    assert solution.highestPeak([[0, 0], [0, 0]]) == [[-1, -1], [-1, -1]]", "def test_highestPeak():\n    solution = Solution()\n    assert solution.highestPeak([[1]]) == [[0]]", "def test_highestPeak():\n    solution = Solution()", "def test_highestPeak():\n    solution = Solution()", "def test_highestPeak():\n    solution = Solution()", "def test_highestPeak():\n    solution = Solution()", "def test_highestPeak():\n    solution = Solution()", "def test_highestPeak():\n    solution = Solution()", "def test_highestPeak():\n    solution = Solution()", "def test_highestPeak():\n    solution = Solution()", "def test_highestPeak():\n    solution = Solution()", "def test_highestPeak():\n    solution = Solution()", "def test_highestPeak():\n    solution = Solution()", "def test_highestPeak():\n    solution = Solution()", "def test_highestPeak():\n    solution = Solution()", "def test_highestPeak():\n    solution = Solution()", "def test_highestPeak():\n    solution = Solution()", "def test_highestPeak():\n    solution = Solution()", "def test_highestPeak():\n    solution = Solution()"]}
{"task_num": 1782, "task_title": "Count Pairs Of Nodes", "func_name": "countPairs", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:\n    ans = [0] * len(queries)\n\n    count = [0] * (n + 1)\n\n    shared = [collections.Counter() for _ in range(n + 1)]\n\n    for u, v in edges:\n      count[u] += 1\n      count[v] += 1\n      shared[min(u, v)][max(u, v)] += 1\n\n    sortedCount = sorted(count)\n\n    for k, query in enumerate(queries):\n      i = 1\n      j = n\n      while i < j:\n        if sortedCount[i] + sortedCount[j] > query:\n          ans[k] += j - i\n          j -= 1\n        else:\n          i += 1\n      for i in range(1, n + 1):\n        for j, sh in shared[i].items():\n          if count[i] + count[j] > query and count[i] + count[j] - sh <= query:\n            ans[k] -= 1\n\n    return ans\n", "tests": ["def test_countPairs():\n    solution = Solution()\n    n = 4\n    edges = [[1, 2], [2, 3], [3, 4], [1, 4]]\n    queries = [6]\n    expected_output = [1]\n    assert solution.countPairs(n, edges, queries) == expected_output", "def test_countPairs():\n    solution = Solution()\n    n = 5\n    edges = []\n    queries = [3]\n    expected_output = [10]\n    assert solution.countPairs(n, edges, queries) == expected_output", "def test_countPairs():\n    solution = Solution()\n    n = 1\n    edges = []\n    queries = [0]\n    expected_output = [0]\n    assert solution.countPairs(n, edges, queries) == expected_output", "def test_countPairs():\n    solution = Solution()\n    n = 4\n    edges = [[1, 2], [2, 3], [3, 4], [1, 3], [1, 4], [2, 4]]\n    queries = [5]\n    expected_output = [0]\n    assert solution.countPairs(n, edges, queries) == expected_output", "def test_countPairs():\n    solution = Solution()\n    n = 4\n    edges = [[1, 2], [3, 4]]\n    queries = [3]\n    expected_output = [2]\n    assert solution.countPairs(n, edges, queries) == expected_output", "def test_countPairs():\n    solution = Solution()\n    n = 4\n    edges = [[1, 2], [2, 3], [3, 4], [1, 3]]\n    queries = [0] * 5 + [10] * 5\n    expected_output = [6] * 5 + [0] * 5\n    assert solution.countPairs(n, edges, queries) == expected_output", "def test_countPairs():\n    solution = Solution()\n    n = 100\n    edges = [[i, (i + 1) % 100] for i in range(100)]\n    queries = [50]\n    expected_output = [99]\n    assert solution.countPairs(n, edges, queries) == expected_output", "def test_countPairs():\n    solution = Solution()\n    n = 6\n    edges = [[1, 2], [2, 3], [3, 4], [4, 5], [5, 1], [1, 3], [2, 4], [3, 5], [4, 1]]\n    queries = [3, 6, 9, 12]\n    expected_output = [7, 3, 1, 0]\n    assert solution.countPairs(n, edges, queries) == expected_output", "def test_countPairs():\n    solution = Solution()\n    n = 10\n    edges = [[1, 3], [2, 4], [5, 7], [6, 8], [9, 1]]\n    queries = [10, 20, 30]\n    expected_output = [4, 0, 0]\n    assert solution.countPairs(n, edges, queries) == expected_output", "def test_countPairs():\n    solution = Solution()\n    n = 3\n    edges = [[1, 2], [2, 3]]\n    queries = [5, 6, 7]\n    expected_output = [1, 0, 0]\n    assert solution.countPairs(n, edges, queries) == expected_output", "def test_countPairs():\n    solution = Solution()\n    n = 1\n    edges = []\n    queries = [0, 1, 2, 3]\n    expected_output = [0] * 4\n    assert solution.countPairs(n, edges, queries) == expected_output", "def test_countPairs():\n    solution = Solution()\n    n = 100\n    edges = [[i, (i + 1) % n] for i in range(n // 2)] * 5\n    queries = [4950, 9900, 14850]\n    expected_output = [4950, 9900, 14850]\n    assert solution.countPairs(n, edges, queries) == expected_output", "def test_countPairs():\n    solution = Solution()\n    n = 15\n    edges = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 9), (9, 10), (10, 11), (11, 12), (12, 13), (13, 14), (14, 15), (15, 1)] * 3\n    queries = [2025, 4050, 6075]\n    expected_output = [2025, 4050, 6075]\n    assert solution.countPairs(n, edges, queries) == expected_output", "def test_countPairs():\n    solution = Solution()\n    n = 10\n    complete_graphs = [[(i, j) for i in range(1 + 5 * k, 6 + 5 * k) for j in range(i + 1, 6 + 5 * k)] for k in range(n // 5)]\n    edges = [edge for graph in complete_graphs for edge in graph] * 2\n    queries = [45, 90, 135]\n    expected_output = [45, 90, 135]\n    assert solution.countPairs(n, edges, queries) == expected_output", "def test_countPairs():\n    solution = Solution()\n    n = 40\n    wheel_graphs = [[(i, j) for i in range(1, 6) for j in range(i + 1, 6)] + [(i, n // 2 + 1) for i in range(1, 6)] for _ in range(n // 5)]\n    edges = [edge for graph in wheel_graphs for edge in graph] * 2\n    queries = [45, 90, 135]\n    expected_output = [45, 90, 135]\n    assert solution.countPairs(n, edges, queries) == expected_output", "def test_countPairs():\n    solution = Solution()\n    n = 90\n    butterfly_graphs = [[(i, i + 1), (i + 1, i + 2), (i + 2, i + 3), (i + 3, i + 4)] + [(n // 2 + 1 - i, n // 2 + 2 - i) for i in range(5)] + [(n // 2 + 3 - i, n // 2 + 4 - i) for i in range(5)] + [(n // 2 + 5 - i, n // 2 + 6 - i) for i in range(5)] for _ in range(n // 10)]\n    edges = [edge for graph in butterfly_graphs for edge in graph] * 2\n    queries = [45, 90, 135]\n    expected_output = [45, 90, 135]\n    assert solution.countPairs(n, edges, queries) == expected_output", "def test_countPairs():\n    solution = Solution()\n    n = 150\n    mb_graphs = [[(i, i + 1), (i + 1, i + 2), (i + 2, i + 3), (i + 3, i + 4)] + [(n // 2 - 5 + i, n // 2 - 4 + i) for i in range(5)] + [(n // 2 - 1 + i, n // 2 - 0 + i) for i in range(5)] + [(n // 2 + 1 + i, n // 2 + 2 + i) for i in range(5)] for k in range(n // 20)]\n    edges = [edge for graph in mb_graphs for edge in graph] * 2\n    queries = [45, 90, 135]\n    expected_output = [45, 90, 135]\n    assert solution.countPairs(n, edges, queries) == expected_output", "def test_countPairs_with_large_n_and_edges_forming_multiple_multipartite_wheel_double_circulant_graphs_and_queries():\n    solution = Solution()\n    n = 200\n    # Creating more than enough edges to form multiple multipartite wheel double circulant graphs (W_DC(10)) and cover the entire graph multiple times\n    mwdc_graphs = [\n        [(i, (i + shift) % n + 1) for i in range(n // 4)] +\n        [(n // 2 - 5 + i, n // 2 - 4 + i) for i in range(5)]\n        + [(n // 2 - 1 + i, n // 2 - 0 + i) for i in range(5)]", "def test_countPairs():\n    solution = Solution()\n    n = 210\n    mwdc_graphs = [[(i, (i + shift) % n + 1) for i in range(n // 4)] + [(n // 2 - 5 + i, n // 2 - 4 + i) for i in range(5)] + [(n // 2 - 1 + i, n // 2 - 0 + i) for i in range(5)]]\n    edges = [edge for graph in mwdc_graphs for edge in graph] * 2\n    queries = [45, 90, 135]\n    expected_output = [45, 90, 135]\n    assert solution.countPairs(n, edges, queries) == expected_output", "def test_countPairs():\n    solution = Solution()\n    n = 220\n    mwdc_graphs = [[(i, (i + shift) % n + 1) for i in range(n // 4)] + [(n // 2 - 5 + i, n // 2 - 4 + i) for i in range(5)] + [(n // 2 - 1 + i, n // 2 - 0 + i) for i in range(5)]]\n    edges = [edge for graph in mwdc_graphs for edge in graph] * 2\n    queries = [45, 90, 135]\n    expected_output = [45, 90, 135]\n    assert solution.countPairs(n, edges, queries) == expected_output"]}
{"task_num": 1786, "task_title": "Number of Restricted Paths From First to Last Node", "func_name": "countRestrictedPaths", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countRestrictedPaths(self, n: int, edges: List[List[int]]) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u - 1].append((v - 1, w))\n      graph[v - 1].append((u - 1, w))\n\n    return self._dijkstra(graph, 0, n - 1)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int) -> int:\n    kMod = 10**9 + 7\n    ways = [0] * len(graph)\n    dist = [math.inf] * len(graph)\n\n    ways[dst] = 1\n    dist[dst] = 0\n    minHeap = [(dist[dst], dst)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n        if dist[v] < dist[u]:\n          ways[u] += ways[v]\n          ways[u] %= kMod\n\n    return ways[src]\n", "tests": ["def test_countRestrictedPaths():\n    solution = Solution()\n    n = 5\n    edges = [[1, 2, 3], [1, 3, 4], [2, 3, 1], [2, 4, 5], [3, 4, 6]]\n    result = solution.countRestrictedPaths(n, edges)", "def test_countRestrictedPaths():\n    solution = Solution()\n    n = 1\n    edges = []\n    result = solution.countRestrictedPaths(n, edges)", "def test_countRestrictedPaths():\n    solution = Solution()\n    n = 2\n    edges = [[1, 2, 1]]\n    result = solution.countRestrictedPaths(n, edges)", "def test_countRestrictedPaths():\n    solution = Solution()\n    n = 3\n    edges = [[1, 2, -1], [2, 3, -1]]\n    result = solution.countRestrictedPaths(n, edges)", "def test_countRestrictedPaths():\n    solution = Solution()\n    n = 10\n    edges = [[1, 2, 1], [1, 3, 1], [1, 4, 1], [2, 5, 1], [2, 6, 1], [2, 7, 1], [3, 8, 1], [3, 9, 1], [4, 10, 1]]\n    result = solution.countRestrictedPaths(n, edges)", "def test_countRestrictedPaths():\n    solution = Solution()\n    n = 4\n    edges = [[1, 2, 1], [1, 3, 1], [2, 3, 1], [2, 4, 1], [3, 4, 1]]\n    result = solution.countRestrictedPaths(n, edges)", "def test_countRestrictedPaths():\n    solution = Solution()\n    n = 5\n    edges = [[1, 2, 1], [3, 4, 1], [4, 5, 1]]\n    result = solution.countRestrictedPaths(n, edges)", "def test_countRestrictedPaths():\n    solution = Solution()\n    n = 3\n    edges = [[1, 2, 10], [1, 3, 10], [2, 3, 10]]\n    result = solution.countRestrictedPaths(n, edges)", "def test_countRestrictedPaths():\n    solution = Solution()\n    n = 2\n    edges = [[1, 2, 1]]\n    result = solution.countRestrictedPaths(n, edges)", "def test_countRestrictedPaths():\n    solution = Solution()\n    n = 100\n    edges = [[i, i + 1, 1] for i in range(1, n)]\n    result = solution.countRestrictedPaths(n, edges)", "def test_countRestrictedPaths():\n    solution = Solution()\n    n = 3\n    edges = []\n    result = solution.countRestrictedPaths(n, edges)", "def test_countRestrictedPaths():\n    solution = Solution()\n    n = 3\n    edges = [[1, 2, -1], [2, 3, -1]]\n    result = solution.countRestrictedPaths(n, edges)", "def test_countRestrictedPaths():\n    solution = Solution()\n    n = 4\n    edges = [[1, 2, 1], [1, 3, 1], [2, 3, 1], [2, 4, 1], [3, 4, 1], [3, 1, 1]]\n    result = solution.countRestrictedPaths(n, edges)", "def test_countRestrictedPaths():\n    solution = Solution()\n    n = 1\n    edges = []\n    result = solution.countRestrictedPaths(n, edges)", "def test_countRestrictedPaths():\n    solution = Solution()\n    n = 3\n    edges = [[1, 2, 1], [1, 2, 1], [2, 3, 1]]\n    result = solution.countRestrictedPaths(n, edges)", "def test_countRestrictedPaths():\n    solution = Solution()\n    n = 4\n    edges = [[1, 2, 1], [1, 3, 1], [4, 5, 1]]\n    result = solution.countRestrictedPaths(n, edges)", "def test_countRestrictedPaths():\n    solution = Solution()\n    n = 3\n    edges = [[1, 2, 1], [2, 3, 1], [3, 1, 1]]\n    result = solution.countRestrictedPaths(n, edges)", "def test_countRestrictedPaths():\n    solution = Solution()\n    n = 3\n    edges = [[1, 2, 1], [1, 3, 1], [2, 3, 1]]\n    result = solution.countRestrictedPaths(n, edges)", "def test_countRestrictedPaths():\n    solution = Solution()\n    n = 3\n    edges = [[1, 2, 100], [1, 3, 100], [2, 3, 100]]\n    result = solution.countRestrictedPaths(n, edges)", "def test_countRestrictedPaths():\n    solution = Solution()\n    n = 2\n    edges = [[1, 2, 1]]\n    result = solution.countRestrictedPaths(n, edges)"]}
{"task_num": 1793, "task_title": "Maximum Score of a Good Subarray", "func_name": "maximumScore", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumScore(self, nums: List[int], k: int) -> int:\n    ans = 0\n    stack = []\n\n    for i in range(len(nums) + 1):\n      while stack and (i == len(nums) or nums[stack[-1]] > nums[i]):\n        h = nums[stack.pop()]\n        w = i - stack[-1] - 1 if stack else i\n        if (not stack or stack[-1] + 1 <= k) and i - 1 >= k:\n          ans = max(ans, h * w)\n      stack.append(i)\n\n    return ans\n", "tests": ["def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([1, 4, 3, 7, 4, 5], 2) == 12", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([9, 5, 2, 4, 7], 3) == 18", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([2, 3, 10, 5, 7], 1) == 40", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([1, 2, 3, 4, 5], 0) == 5", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([10], 0) == 10", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([5, 4, 3, 2, 1], 2) == 8", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([3, 1, 4, 1, 5], 3) == 6", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([8, 5, 2, 10], 2) == 30", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([1, 2, 3, 4, 5, 6], 3) == 20", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([10, 9, 8, 7, 6, 5], 3) == 48", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([2, 1, 2], 1) == 4", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([3, 2, 1, 4, 5], 2) == 10", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([1, 3, 2, 4, 5], 1) == 9", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([2, 4, 6, 8, 10], 2) == 32", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([10, 7, 5, 8, 12], 3) == 40", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([1, 2, 3, 4, 5], 0) == 5", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([5, 4, 3, 2, 1], 2) == 8", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([100, 200, 300], 1) == 600", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([1, 2, 3], 0) == 1", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([5], 0) == 5"]}
{"task_num": 1805, "task_title": "Number of Different Integers in a String", "func_name": "numDifferentIntegers", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numDifferentIntegers(self, word: str) -> int:\n    nums = set()\n    curr = []\n\n    for c in word:\n      if c.isdigit():\n        curr.append(c)\n      elif curr:\n        nums.add(''.join(self._removeLeadingZeros(curr)))\n        curr = []\n\n    if curr:\n      nums.add(''.join(self._removeLeadingZeros(curr)))\n\n    return len(nums)\n\n  def _removeLeadingZeros(self, s: str) -> str:\n    index = next((i for i, c in enumerate(s) if c != '0'), -1)\n    if index == -1:\n      return ['0']\n    else:\n      return s[index:]\n", "tests": ["def test_numDifferentIntegers():\n    solution = Solution()\n    result = solution.numDifferentIntegers('a123bc34d8ef34')", "def test_numDifferentIntegers():\n    solution = Solution()\n    result = solution.numDifferentIntegers('00123abc00456')", "def test_numDifferentIntegers():\n    solution = Solution()\n    result = solution.numDifferentIntegers('a123abc456abcd789abc')", "def test_numDifferentIntegers():\n    solution = Solution()\n    result = solution.numDifferentIntegers('a0b12c345')", "def test_numDifferentIntegers():\n    solution = Solution()\n    result = solution.numDifferentIntegers('aA1!@#2bB3%$4cC5%^6dD7&*eE8()')", "def test_numDifferentIntegers():\n    solution = Solution()\n    result = solution.numDifferentIntegers('a123!@#b456c789d0e1f2g3h4i5j6k!')", "def test_numDifferentIntegers(self):\n    s = '-1 2 -3 4 5 6 7 8 9 10'\n    self.assertEqual(self.solution.numDifferentIntegers(s), 10)", "def test_numDifferentIntegers(self):\n    s = '1 2 3 4 5 6 7 8 9 10 1'\n    self.assertEqual(self.solution.numDifferentIntegers(s), 10)", "def test_numDifferentIntegers(self):\n    s = ' 1 2 3 4 5 6 7 8 9 10 '\n    self.assertEqual(self.solution.numDifferentIntegers(s), 10)", "def test_numDifferentIntegers(self):\n    s = '1'\n    self.assertEqual(self.solution.numDifferentIntegers(s), 1)", "def test_numDifferentIntegers(self):\n    s = '1a2b3c'\n    self.assertEqual(self.solution.numDifferentIntegers(s), 3)", "def test_numDifferentIntegers(self):\n    s = '100 200 300'\n    self.assertEqual(self.solution.numDifferentIntegers(s), 3)", "def test_numDifferentIntegers(self):\n    s = '1 2 3 4 5 6 7 8 9 10'\n    self.assertEqual(self.solution.numDifferentIntegers(s), 10)", "def test_numDifferentIntegers(self):\n    s = '12345678901234567890 2345678901234567890'\n    self.assertEqual(self.solution.numDifferentIntegers(s), 2)", "def test_numDifferentIntegers(self):\n    s = '1 2 3 4 5 6 7 8 9 10 1'\n    self.assertEqual(self.solution.numDifferentIntegers(s), 10)", "def test_numDifferentIntegers(self):\n    s = '1a2b3c'\n    self.assertEqual(self.solution.numDifferentIntegers(s), 3)", "def test_numDifferentIntegers(self):\n    s = '1 2 3 4 5'\n    self.assertEqual(self.solution.numDifferentIntegers(s), 5)", "def test_numDifferentIntegers(self):\n    s = '0'\n    self.assertEqual(self.solution.numDifferentIntegers(s), 1)", "def test_numDifferentIntegers(self):\n    s = '1234567890 1234567890 1234567890 1234567890'\n    self.assertEqual(self.solution.numDifferentIntegers(s), 1)", "def test_numDifferentIntegers(self):\n    s = '123456789012345678901234567890'\n    self.assertEqual(self.solution.numDifferentIntegers(s), 1)"]}
{"task_num": 1857, "task_title": "Largest Color Value in a Directed Graph", "func_name": "largestPathValue", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\n    n = len(colors)\n    ans = 0\n    processed = 0\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n    q = collections.deque()\n    count = [[0] * 26 for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      inDegrees[v] += 1\n\n    for i, degree in enumerate(inDegrees):\n      if degree == 0:\n        q.append(i)\n\n    while q:\n      u = q.popleft()\n      processed += 1\n      count[u][ord(colors[u]) - ord('a')] += 1\n      ans = max(ans, count[u][ord(colors[u]) - ord('a')])\n      for v in graph[u]:\n        for i in range(26):\n          count[v][i] = max(count[v][i], count[u][i])\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    if processed == n:\n      return ans\n    else:\n      return -1\n", "tests": ["def test_largestPathValue():\n    solution = Solution()\n    assert solution.largestPathValue('abaca', [[0, 2], [0, 3], [4, 2]]) == 2", "def test_largestPathValue():\n    solution = Solution()\n    assert solution.largestPathValue('abcda', [[0, 1], [1, 2], [2, 3], [3, 4], [4, 0]]) == -1", "def test_largestPathValue():\n    solution = Solution()\n    assert solution.largestPathValue('aaaaa', [[0, 1], [1, 2], [2, 3], [3, 4]]) == 5", "def test_largestPathValue():\n    solution = Solution()\n    assert solution.largestPathValue('a', []) == 1", "def test_largestPathValue():\n    solution = Solution()\n    assert solution.largestPathValue('abcde', [[0, 1], [0, 2], [1, 3], [2, 3], [3, 4]]) == 2", "def test_largestPathValue():\n    solution = Solution()\n    assert solution.largestPathValue('abcde', [[0, 1], [1, 2], [2, 3], [3, 4]]) == 1", "def test_largestPathValue():\n    solution = Solution()\n    assert solution.largestPathValue('aaa', [[0, 1], [1, 2]]) == 3", "def test_largestPathValue():\n    solution = Solution()", "def test_largestPathValue():\n    solution = Solution()\n    assert solution.largestPathValue('a', [[0, 0]]) == -1", "def test_largestPathValue():\n    solution = Solution()\n    assert solution.largestPathValue('aba', [[0, 1], [1, 2]]) == 2", "def test_largestPathValue():\n    solution = Solution()\n    colors = 'abcdefghijklmnopqrstuvwxyz' * 10 + 'a'\n    edges = [[i, i + 1] for i in range(len(colors) - 1)]\n    assert solution.largestPathValue(colors, edges) == 26", "def test_largestPathValue():\n    solution = Solution()\n    n = 10\n    colors = 'a' * n\n    edges = []\n    for i in range(n - 1):\n        edges.append([i, i + 1])\n    assert solution.largestPathValue(colors, edges) == 1", "def test_largestPathValue():\n    solution = Solution()\n    assert solution.largestPathValue('a', []) == 1", "def test_largestPathValue():\n    solution = Solution()\n    assert solution.largestPathValue('abc', [[0, 1], [1, 2], [0, 2]]) == 3", "def test_largestPathValue():\n    solution = Solution()\n    n = 100\n    colors = 'a' * n\n    edges = []\n    for i in range(n - 1):\n        edges.append([i, i + 1])\n    assert solution.largestPathValue(colors, edges) == 1", "def test_largestPathValue():\n    import random\n    solution = Solution()\n    n = 10\n    colors = ''.join((random.choice(string.ascii_lowercase) for _ in range(n)))\n    edges = []\n    for i in range(n):\n        if random.random() > 0.5 and i + 1 < n:\n            edges.append([i, i + 1])\n    graph = collections.defaultdict(list)\n    for (u, v) in edges:\n        graph[u].append(v)\n\n    def dfs(node):\n        if visited[node] == -1:\n            return True\n        if visited[node] == 1:\n            return False\n        visited[node] = 1\n        for neighbor in graph[node]:\n            if not dfs(neighbor):\n                return False\n        visited[node] = -1\n        return True\n    visited = [0] * n\n    if not all((dfs(i) for i in range(n))):\n        raise ValueError('Generated graph contains cycles')\n    assert solution.largestPathValue(colors, edges) <= 26", "def test_largestPathValue():\n    solution = Solution()\n    assert solution.largestPathValue('a' * 1000, []) == 1000", "def test_largestPathValue():\n    solution = Solution()\n    assert solution.largestPathValue('ab', [[0, 1], [1, 0]]) == -1", "def test_largestPathValue():\n    solution = Solution()\n    assert solution.largestPathValue('a', [[0, 0]]) == -1", "def test_largestPathValue():\n    solution = Solution()\n    n = 5\n    colors = 'abcde'\n    edges = [[i, n - 1] for i in range(n - 1)]\n    assert solution.largestPathValue(colors, edges) == 1"]}
{"task_num": 1878, "task_title": "Get Biggest Three Rhombus Sums in a Grid", "func_name": "getBiggestThree", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom sortedcontainers import SortedSet\n\n\nclass Solution:\n  def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\n    m = len(grid)\n    n = len(grid[0])\n    sums = SortedSet()\n\n    for i in range(m):\n      for j in range(n):\n        sz = 0\n        while i + sz < m and i - sz >= 0 and j + 2 * sz < n:\n          summ = grid[i][j] if sz == 0 else self._getSum(grid, i, j, sz)\n          sums.add(summ)\n          if len(sums) > 3:\n            sums.pop(0)\n          sz += 1\n\n    return reversed(sums)\n\n  def _getSum(self, grid: List[List[int]], i: int, j: int, sz: int) -> int:\n    x = i\n    y = j\n    summ = 0\n\n    for _ in range(sz):\n      x -= 1\n      y += 1\n      summ += grid[x][y]\n\n    for _ in range(sz):\n      x += 1\n      y += 1\n      summ += grid[x][y]\n\n    for _ in range(sz):\n      x += 1\n      y -= 1\n      summ += grid[x][y]\n\n    for _ in range(sz):\n      x -= 1\n      y -= 1\n      summ += grid[x][y]\n\n    return summ\n", "tests": ["def test_getBiggestThree():\n    solution = Solution()\n    assert solution.getBiggestThree([[3, 1, 6], [5, 5, 1], [9, 2, 8]]) == [20, 16, 14]", "def test_getBiggestThree():\n    solution = Solution()\n    assert solution.getBiggestThree([[5]]) == [5]", "def test_getBiggestThree():\n    solution = Solution()\n    assert solution.getBiggestThree([[7, 3, 1], [2, 9, 5], [8, 4, 6]]) == [30, 27, 21]", "def test_getBiggestThree():\n    solution = Solution()\n    assert solution.getBiggestThree([[100, 200], [300, 400]]) == [900]", "def test_getBiggestThree():\n    solution = Solution()\n    assert solution.getBiggestThree([[1, 2], [3, 4], [5, 6]]) == [17]", "def test_getBiggestThree():\n    solution = Solution()\n    assert solution.getBiggestThree([[1, 2, 3], [4, 5, 6]]) == [18]", "def test_getBiggestThree():\n    solution = Solution()\n    assert solution.getBiggestThree([[3], [6]]) == [9]", "def test_getBiggestThree():\n    solution = Solution()\n    assert solution.getBiggestThree([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [30]", "def test_getBiggestThree():\n    solution = Solution()\n    assert solution.getBiggestThree([[5, 7, 3], [9, 1, 6], [4, 8, 2]]) == [20]", "def test_getBiggestThree():\n    solution = Solution()\n    assert solution.getBiggestThree([[1, 2], [3, 4]]) == [10]", "def test_getBiggestThree():\n    solution = Solution()\n    assert solution.getBiggestThree([[1], [2], [3]]) == [6]", "def test_getBiggestThree():\n    solution = Solution()\n    assert solution.getBiggestThree([[1, 2, 3], [4, 5, 6]]) == [18]", "def test_getBiggestThree():\n    solution = Solution()\n    assert solution.getBiggestThree([[3], [6]]) == [9]", "def test_getBiggestThree():\n    solution = Solution()\n    assert solution.getBiggestThree([[5, 7, 3], [9, 1, 6], [4, 8, 2]]) == [20]", "def test_getBiggestThree():\n    solution = Solution()\n    assert solution.getBiggestThree([[1, 2], [3, 4]]) == [10]", "def test_getBiggestThree():\n    solution = Solution()\n    assert solution.getBiggestThree([[1], [2], [3]]) == [6]", "def test_getBiggestThree():\n    solution = Solution()\n    assert solution.getBiggestThree([[1, 2, 3], [4, 5, 6]]) == [18]", "def test_getBiggestThree():\n    solution = Solution()\n    assert solution.getBiggestThree([[3], [6]]) == [9]", "def test_getBiggestThree():\n    solution = Solution()\n    assert solution.getBiggestThree([[5, 7, 3], [9, 1, 6], [4, 8, 2]]) == [20]", "def test_getBiggestThree():\n    solution = Solution()\n    assert solution.getBiggestThree([[1, 2], [3, 4]]) == [10]"]}
{"task_num": 1896, "task_title": "Minimum Cost to Change the Final Value of Expression", "func_name": "minOperationsToFlip", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minOperationsToFlip(self, expression: str) -> int:\n    stack = []\n\n    for e in expression:\n      if e in '(&|':\n        stack.append((e, 0))\n        continue\n      if e == ')':\n        lastPair = stack.pop()\n        stack.pop()\n      else: \n        lastPair = (e, 1)\n      if stack and stack[-1][0] in '&|':\n        op = stack.pop()[0]\n        a, costA = stack.pop()\n        b, costB = lastPair\n        if op == '&':\n          if a == '0' and b == '0':\n            lastPair = ('0', 1 + min(costA, costB))\n          elif a == '0' and b == '1':\n            lastPair = ('0', 1)\n          elif a == '1' and b == '0':\n            lastPair = ('0', 1)\n          else:\n            lastPair = ('1', min(costA, costB))\n        else:\n          if a == '0' and b == '0':\n            lastPair = ('0', min(costA, costB))\n          elif a == '0' and b == '1':\n            lastPair = ('1', 1)\n          elif a == '1' and b == '0':\n            lastPair = ('1', 1)\n          else:\n            lastPair = ('1', 1 + min(costA, costB))\n      stack.append(lastPair)\n\n    return stack[-1][1]\n", "tests": ["def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('1|0') == 1", "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('(0&1)|1') == 2", "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('1&(0|0)') == 2", "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('((1|0)&(0&1))') == 4", "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('1&(0&0)&(1|0)') == 4", "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('((1&0)|(1|0))') == 2", "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('1&(1&0)|(1|0)') == 3", "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('((1&0)|(0&1))&(0|1)') == 3", "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('((1&0)|(0&1))&(0|1)|((1&0)|(0&1))') == 4", "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('((1&0)|(0&1))&(0|1)|((1&0)|(0&1))&(0|1)') == 5", "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('((1&0)|(0&1))&(0|1)|((1&0)|(0&1))&(0|1)&(0|1)') == 6", "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('((1&0)|(0&1))&(0|1)|((1&0)|(0&1))&(0|1)&(0|1)|(1&0)') == 7", "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('((1&0)|(0&1))&(0|1)|((1&0)|(0&1))&(0|1)&(0|1)|(1&0)|(1&1)') == 8", "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('((1&0)|(0&1))&(0|1)|((1&0)|(0&1))&(0|1)&(0|1)|(1&0)|(1&1)|(0&1)') == 9", "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('((1&0)|(0&1))&(0|1)|((1&0)|(0&1))&(0|1)&(0|1)|(1&0)|(1&1)|(0&1)|(1&0)') == 10", "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('((1&0)|(0&1))&(0|1)|((1&0)|(0&1))&(0|1)&(0|1)|(1&0)|(1&1)|(0&1)|(1&0)|(1&1)') == 11", "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('((1&0)|(0&1))&(0|1)|((1&0)|(0&1))&(0|1)&(0|1)|(1&0)|(1&1)|(0&1)|(1&0)|(1&1)|(0&0)') == 12", "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('((1&0)|(0&1))&(0|1)|((1&0)|(0&1))&(0|1)&(0|1)|(1&0)|(1&1)|(0&1)|(1&0)|(1&1)|(0&0)|(1|0)') == 13", "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('((1&0)|(0&1))&(0|1)|((1&0)|(0&1))&(0|1)&(0|1)|(1&0)|(1&1)|(0&1)|(1&0)|(1&1)|(0&0)|(1|0)|(0&1)') == 14", "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('((1&0)|(0&1))&(0|1)|((1&0)|(0&1))&(0|1)&(0|1)|(1&0)|(1&1)|(0&1)|(1&0)|(1&1)|(0&0)|(1|0)|(0&1)|(1&1)') == 15"]}
{"task_num": 1906, "task_title": "Minimum Absolute Difference Queries", "func_name": "minDifference", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom bisect import bisect_left\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minDifference(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n    numToIndices = [[] for _ in range(101)]\n\n    for i, num in enumerate(nums):\n      numToIndices[num].append(i)\n\n    if len(numToIndices[nums[0]]) == len(nums):\n      return [-1] * len(queries)\n\n    ans = []\n\n    for l, r in queries:\n      prevNum = -1\n      minDiff = 101\n      for num in range(1, 101):\n        indices = numToIndices[num]\n        i = bisect_left(indices, l)\n        if i == len(indices) or indices[i] > r:\n          continue\n        if prevNum != -1:\n          minDiff = min(minDiff, num - prevNum)\n        prevNum = num\n      ans.append(-1 if minDiff == 101 else minDiff)\n\n    return ans\n", "tests": ["def test_minDifference():\n    solution = Solution()\n    nums = [1, 3, 5]\n    queries = [[0, 2]]\n    expected = [2]\n    assert solution.minDifference(nums, queries) == expected", "def test_minDifference():\n    solution = Solution()\n    nums = [42] * 5\n    queries = [[0, 4]]\n    expected = [-1]\n    assert solution.minDifference(nums, queries) == expected", "def test_minDifference():\n    solution = Solution()\n    nums = [1, 3, 5, 7, 9]\n    queries = [[0, 2], [3, 4]]\n    expected = [2, 2]\n    assert solution.minDifference(nums, queries) == expected", "def test_minDifference():\n    solution = Solution()\n    nums = [1, 2, 3]\n    queries = [[1, 0]]\n    expected = [-1]\n    assert solution.minDifference(nums, queries) == expected", "def test_minDifference():\n    solution = Solution()\n    nums = [10, 20, 30, 40, 50]\n    queries = [[1, 1]]\n    expected = [-1]\n    assert solution.minDifference(nums, queries) == expected", "def test_minDifference():\n    solution = Solution()\n    nums = [5] * 10\n    queries = [[0, 9], [2, 4], [7, 8]]\n    expected = [-1, -1, -1]\n    assert solution.minDifference(nums, queries) == expected", "def test_minDifference():\n    solution = Solution()\n    nums = []\n    queries = [[0, 0]]\n    expected = [-1]\n    assert solution.minDifference(nums, queries) == expected", "def test_minDifference():\n    solution = Solution()\n    nums = [1, 2, 3, 2, 4, 5, 2]\n    queries = [[0, 6], [1, 7]]\n    expected = [0, 0]\n    assert solution.minDifference(nums, queries) == expected", "def test_minDifference():\n    solution = Solution()\n    nums = [-100, -50, 0, 50, 100]\n    queries = [[0, 4], [1, 3]]\n    expected = [1, 1]\n    assert solution.minDifference(nums, queries) == expected", "def test_minDifference():\n    solution = Solution()\n    nums = [-100, -50, 0, 50, 100]\n    queries = [[2, 2]]\n    expected = [-1]\n    assert solution.minDifference(nums, queries) == expected", "def test_minDifference():\n    solution = Solution()\n    nums = list(range(-1000, 1001))\n    queries = [[-500, 500]]\n    expected = [1]\n    assert solution.minDifference(nums, queries) == expected", "def test_minDifference():\n    solution = Solution()\n    nums = [-1000, -500, 0, 500, 1000]\n    queries = [[-499, 500], [0, 4]]\n    expected = [1, 1]\n    assert solution.minDifference(nums, queries) == expected", "def test_minDifference():\n    solution = Solution()\n    nums = [-100, -50, 0, 50, 100] * 2\n    queries = [[0, 3], [4, 7]]\n    expected = [1, 1]\n    assert solution.minDifference(nums, queries) == expected", "def test_minDifference():\n    solution = Solution()\n    nums = list(range(-1000, 1001)) + list(range(1002, 2003))\n    queries = [[-500, 500], [500, 1500]]\n    expected = [1, 1]\n    assert solution.minDifference(nums, queries) == expected", "def test_minDifference():\n    nums = [i % 1000 - 500 for i in range(1, 10001)]\n    queries = [[0, len(nums) - 1]]\n    sorted_nums = sorted(nums)\n    expected = min((abs(sorted_nums[i] - sorted_nums[i + 1]) for i in range(len(sorted_nums) - 1)))\n    result = solution.minDifference(nums, queries)", "def test_minDifference():\n    nums = [-1000000, 1000000] * 500\n    queries = [[0, len(nums) - 1]]\n    expected = abs(max(nums) - min(nums))\n    result = solution.minDifference(nums, queries)", "def test_minDifference():\n    nums = [i % 1000 - 500 for i in range(1, 10001)]\n    queries = [[len(nums) - 1, 0]]\n    sorted_nums = sorted(nums)\n    expected = min((abs(sorted_nums[i] - sorted_nums[i + 1]) for i in range(len(sorted_nums) - 1)))\n    result = solution.minDifference(nums, queries)", "def test_minDifference():\n    nums = [i % 1000 - 500 for i in range(1, 2001)]\n    queries = [[0, 0], [-1, -1], [len(nums) - 1, len(nums) - 1]]\n    expected = [-1, -1, -1]\n    for (i, (start, end)) in enumerate(queries):\n        result = solution.minDifference(nums, [[start, end]])", "def test_minDifference():\n    nums = [i % 1000 - 500 for i in range(1, 2001)]\n    queries = [[0, 1], [len(nums) // 2 - 1, len(nums) // 2], [len(nums) - 2, len(nums) - 1]]\n    expected = [abs(nums[1] - nums[0]), abs(nums[len(nums) // 2] - nums[len(nums) // 2 - 1]), abs(nums[-1] - nums[-2])]\n    for (i, (start, end)) in enumerate(queries):\n        result = solution.minDifference(nums, [[start, end]])", "def test_minDifference():\n    nums = [i % 1000 - 500 for i in range(1, 2001)]\n    nums[2] = None\n    nums[1000] = None\n    queries = [[0, 2], [500, 1000], [1998, len(nums) - 1]]\n    expected = [min((abs(n1 - n2) for (n1, n2) in zip(nums[0:2], nums[1:3]) if n1 is not None and n2 is not None)), min((abs(n1 - n2) for (n1, n2) in zip(nums[500:1000], nums[501:1001]) if n1 is not None and n2 is not None)), min((abs(n1 - n2) for (n1, n2) in zip(nums[1998:], nums[1999:]) if n1 is not None and n2 is not None))]\n    for (i, (start, end)) in enumerate(queries):\n        result = solution.minDifference(nums, [[start, end]])"]}
{"task_num": 1923, "task_title": "Longest Common Subpath", "func_name": "longestCommonSubpath", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Set\n\nclass Solution:\n  def __init__(self):\n    self.kMod = 8_417_508_174_513\n    self.kBase = 165_131\n\n  def longestCommonSubpath(self, n: int, paths: List[List[int]]) -> int:\n    l = 0\n    r = len(paths[0])\n\n    while l < r:\n      m = l + (r - l + 1) // 2\n      if self._checkCommonSubpath(paths, m):\n        l = m\n      else:\n        r = m - 1\n\n    return l\n\n  def _checkCommonSubpath(self, paths: List[List[int]], m: int) -> bool:\n    hashSets = [self._rabinKarp(path, m) for path in paths]\n\n    for subpathHash in hashSets[0]:\n      if all(subpathHash in hashSet for hashSet in hashSets):\n        return True\n\n    return False\n\n  def _rabinKarp(self, path: List[int], m: int) -> Set[int]:\n    hashes = set()\n    maxPower = 1\n    hash = 0\n\n    for i, num in enumerate(path):\n      hash = (hash * self.kBase + num) % self.kMod\n      if i >= m:\n        hash = (hash - path[i - m] * maxPower % self.kMod + self.kMod) % self.kMod\n      else:\n        maxPower = maxPower * self.kBase % self.kMod\n      if i >= m - 1:\n        hashes.add(hash)\n\n    return hashes\n", "tests": ["def test_longestCommonSubpath():\n    solution = Solution()\n    n = 5\n    paths = [[0, 1, 2], [1, 2, 3], [2, 3, 4]]\n    assert solution.longestCommonSubpath(n, paths) == 2", "def test_longestCommonSubpath():\n    solution = Solution()\n    n = 3\n    paths = [[0, 1, 2]]\n    assert solution.longestCommonSubpath(n, paths) == 3", "def test_longestCommonSubpath():\n    solution = Solution()\n    n = 10\n    paths = [[0] * 100, [1] * 100]\n    assert solution.longestCommonSubpath(n, paths) == 1", "def test_longestCommonSubpath():\n    solution = Solution()\n    n = 1\n    paths = [[0], [0]]\n    assert solution.longestCommonSubpath(n, paths) == 1", "def test_longestCommonSubpath():\n    solution = Solution()\n    n = 5\n    paths = [[1, 2, 3, 4], [2, 3, 4, 2], [3, 4, 2, 3]]\n    assert solution.longestCommonSubpath(n, paths) == 3", "def test_longestCommonSubpath():\n    solution = Solution()\n    n = 7\n    paths = [[0, 1], [2, 3, 4], [3, 4, 5, 6, 2]]\n    assert solution.longestCommonSubpath(n, paths) == 2", "def test_longestCommonSubpath():\n    solution = Solution()\n    n = 7\n    paths = [[0, 1], [2, 3, 4], [3, 4, 5, 6, 2], [0, 1]]\n    assert solution.longestCommonSubpath(n, paths) == 2", "def test_longestCommonSubpath():\n    solution = Solution()\n    n = 7\n    paths = [[0, 1], [2, 3, 4], [3, 4, 5, 6, 2], [0, 1, 2]]\n    assert solution.longestCommonSubpath(n, paths) == 2", "def test_longestCommonSubpath():\n    solution = Solution()\n    n = 7\n    paths = [[0, 1], [2, 3, 4], [3, 4, 5, 6, 2], [0, 1, 1]]\n    assert solution.longestCommonSubpath(n, paths) == 2", "def test_longestCommonSubpath():\n    solution = Solution()\n    n = 10\n    paths = [[i] * i for i in range(1, 11)] + [[5] * 5]\n    assert solution.longestCommonSubpath(n, paths) == 5", "def test_longestCommonSubpath():\n    solution = Solution()\n    n = 20\n    paths = [[i] * i for i in range(1, 6)] + [[random.randint(0, n - 1) for _ in range(random.randint(5, 10))] for _ in range(5)]\n    assert solution.longestCommonSubpath(n, paths) >= 5", "def test_longestCommonSubpath():\n    solution = Solution()\n    assert solution.longestCommonSubpath(0, []) == 0", "def test_longestCommonSubpath():\n    solution = Solution()\n    paths = [[1], [1], [1]]\n    assert solution.longestCommonSubpath(1, paths) == 1", "def test_longest_common_subpath_with_large_number_of_paths_and_elements():\n    solution = Solution()\n    n = 100\n    paths = [[random.randint(0, n-1) for _ in range(n)] for _ in range(n)]\n    \n    # Check if the function can handle a large number of paths and elements without crashing\n    try:\n        result = solution.longestCommonSubpath(n, paths)", "def test_longestCommonSubpath():\n    solution = Solution()\n    paths_int = [[1, 2, 3], [1, 2, 4], [1, 2, 5]]\n    assert solution.longestCommonSubpath(3, paths_int) == 2", "def test_longestCommonSubpath():\n\n    class CustomObject:\n\n        def __init__(self, value):\n            self.value = value\n\n        def __eq__(self, other):\n            return isinstance(other, CustomObject) and self.value == other.value\n\n        def __hash__(self):\n            return hash(self.value)\n    solution = Solution()\n    obj1 = CustomObject(1)\n    obj2 = CustomObject(2)\n    paths_custom_objects = [[obj1, obj2], [obj1, obj3], [obj1, obj4]]\n    assert solution.longestCommonSubpath(2, paths_custom_objects) == 0", "def test_longestCommonSubpath():\n    solution = Solution()\n    bytes1 = b'hello'\n    bytes2 = b'world'\n    paths_bytes = [[bytes1], [bytes2], [b'hola']]\n    assert solution.longestCommonSubpath(2, paths_bytes) == 0", "def test_longestCommonSubpath():\n    solution = Solution()\n    dict1 = {i: i for i in range(10 ** 6)}\n    dict2 = {i: i for i in range(1, 10 ** 6 + 1)}\n    paths_dicts = [[dict1], [dict2], {i: i for i in range(2, 10 ** 6 + 1)}]\n    assert solution.longestCommonSubpath(2, paths_dicts) == 0", "def test_longest_common_subpath_with_paths_containing_large_complex_numbers():\n    solution = Solution()\n    \n    # Test with paths containing large complex numbers\n    complex1 = 1 + (10**6)j\n    complex2 = 1 + (10**6 - 1)j\n    paths_complex = [[complex1], [complex2], 1 + (10**6 - 2)j]\n    assert solution.longestCommonSubpath(2, paths_complex) == 0", "def test_longest_common_subpath_with_paths_containing_large_complex_numbers():\n    solution = Solution()\n    \n    # Test with paths containing large complex numbers\n    complex1 = 1 + (10**6)j\n    complex2 = 1 + (10**6 - 1)j\n    paths_complex = [[complex1], [complex2], 1 + (10**6 - 2)j]\n    assert solution.longestCommonSubpath(2, paths_complex) == 0"]}
{"task_num": 1926, "task_title": "Nearest Exit from Entrance in Maze", "func_name": "nearestExit", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def nearestExit(self, maze: List[List[str]], entrance: List[int]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(maze)\n    n = len(maze[0])\n    ans = 0\n    q = collections.deque([(entrance[0], entrance[1])])\n    seen = {(entrance[0], entrance[1])}\n\n    while q:\n      ans += 1\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if (x, y) in seen or maze[x][y] == '+':\n            continue\n          if x == 0 or x == m - 1 or y == 0 or y == n - 1:\n            return ans\n          q.append((x, y))\n          seen.add((x, y))\n\n    return -1\n", "tests": ["def test_nearestExit():\n    solution = Solution()\n    assert solution.nearestExit([['+', '.', '.', '.'], ['.', '.', '+', '.'], ['.', '.', '+', '.']], [0, 1]) == 2", "def test_nearestExit():\n    solution = Solution()\n    assert solution.nearestExit([['+', '.', '+', '+'], ['.', '.', '.', '.'], ['+', '.', '+', '.']], [1, 2]) == 3", "def test_nearestExit():\n    solution = Solution()\n    assert solution.nearestExit([['+', '.', '.', '.'], ['.', '+', '.', '.'], ['.', '.', '+', '.']], [1, 0]) == -1", "def test_nearestExit():\n    solution = Solution()\n    assert solution.nearestExit([['.', '+', '.'], ['+', '+', '.'], ['+', '+', '.']], [0, 2]) == 1", "def test_nearestExit():\n    solution = Solution()\n    assert solution.nearestExit([['.', '+', '.'], ['+', '.', '.'], ['.', '.', '+'], ['.', '+', '.']], [2, 1]) == 3", "def test_nearestExit():\n    solution = Solution()\n    assert solution.nearestExit([['.', '+', '.'], ['+', '.', '+'], ['.', '.', '+']], [1, 0]) == -1", "def test_nearestExit():\n    solution = Solution()\n    assert solution.nearestExit([['.', '+', '.'], ['+', '.', '+'], ['.', '.', '+']], [0, 0]) == 1", "def test_nearestExit():\n    solution = Solution()\n    assert solution.nearestExit([['+', '.', '.'], ['.', '.', '.'], ['.', '+', '.']], [1, 1]) == 2", "def test_nearestExit():\n    solution = Solution()\n    assert solution.nearestExit([['.', '+', '.'], ['.', '.', '+'], ['.', '.', '+', '.']], [0, 1]) == 2", "def test_nearestExit():\n    solution = Solution()\n    assert solution.nearestExit([['.', '+', '.'], ['.', '.', '+'], ['.', '.', '+']], [1, 0]) == -1", "def test_nearestExit():\n    solution = Solution()\n    assert solution.nearestExit([['.', '+', '.'], ['.', '.', '+'], ['.', '.', '+', '.']], [2, 1]) == 3", "def test_nearestExit():\n    solution = Solution()\n    assert solution.nearestExit([['.', '+', '.'], ['+', '.', '+'], ['.', '.', '+']], [0, 2]) == 1", "def test_nearestExit():\n    solution = Solution()\n    assert solution.nearestExit([['.', '+', '.'], ['+', '.', '+'], ['.', '.', '+']], [1, 2]) == 3", "def test_nearestExit():\n    solution = Solution()\n    assert solution.nearestExit([['.', '+', '.'], ['+', '.', '+'], ['.', '.', '+', '.']], [0, 0]) == 1", "def test_nearestExit():\n    solution = Solution()\n    assert solution.nearestExit([['.', '+', '.'], ['.', '+', '+'], ['.', '.', '+', '.']], [1, 0]) == -1", "def test_nearestExit():\n    solution = Solution()\n    assert solution.nearestExit([['.', '.', '.'], ['+', '.', '+'], ['+', '.', '+']], [0, 2]) == 1", "def test_nearestExit():\n    solution = Solution()\n    assert solution.nearestExit([['+', '.', '+'], ['.', '.', '.'], ['+', '+', '.']], [1, 0]) == 2", "def test_nearestExit():\n    solution = Solution()\n    assert solution.nearestExit([['+', '.', '+'], ['.', '.', '.'], ['+', '+', '.']], [1, 2]) == 3", "def test_nearestExit():\n    solution = Solution()\n    assert solution.nearestExit([['.', '+', '.'], ['.', '+', '+'], ['.', '.', '+']], [2, 1]) == 3", "def test_nearestExit():\n    solution = Solution()\n    assert solution.nearestExit([['.', '+', '.'], ['.', '+', '+'], ['.', '.', '+', '.']], [0, 1]) == 2"]}
{"task_num": 1928, "task_title": "Minimum Cost to Reach Destination in Time", "func_name": "minCost", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\n    n = len(passingFees)\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, 0, n - 1, maxTime, passingFees)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, maxTime: int, passingFees: List[int]) -> int:\n    cost = [math.inf for _ in range(len(graph))]\n    dist = [maxTime + 1 for _ in range(len(graph))]\n\n    cost[src] = passingFees[src]\n    dist[src] = 0\n    minHeap = [(cost[src], dist[src], src)]\n\n    while minHeap:\n      currCost, d, u = heapq.heappop(minHeap)\n      if u == dst:\n        return cost[dst]\n      if d > dist[u] and currCost > cost[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w > maxTime:\n          continue\n        if currCost + passingFees[v] < cost[v]:\n          cost[v] = currCost + passingFees[v]\n          dist[v] = d + w\n          heapq.heappush(minHeap, (cost[v], dist[v], v))\n        elif d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (currCost + passingFees[v], dist[v], v))\n\n    return -1\n", "tests": ["def test_minCost():\n    solution = Solution()\n    assert solution.minCost(30, [[0, 1, 20], [0, 2, 40], [1, 2, 50]], [10, 20, 30]) == -1", "def test_minCost():\n    solution = Solution()\n    assert solution.minCost(5, [[0, 1, 2], [0, 3, 4], [1, 2, 1], [2, 3, 3]], [10, 20, 30, 40]) == 30", "def test_minCost():\n    solution = Solution()\n    assert solution.minCost(10, [[0, 1, 5], [1, 2, 5], [2, 3, 5]], [1, 2, 3, 4]) == 6", "def test_minCost():\n    solution = Solution()\n    assert solution.minCost(20, [[0, 1, 10], [1, 2, 5], [2, 3, 5], [3, 4, 10]], [100, 200, 300, 400, 500]) == 900", "def test_minCost():\n    solution = Solution()\n    assert solution.minCost(1, [[0, 1, 2]], [1, 2]) == -1", "def test_minCost():\n    solution = Solution()\n    assert solution.minCost(30, [[0, 1, 2], [0, 2, 4], [1, 2, 5]], [10, 20, 30]) == -1", "def test_minCost():\n    solution = Solution()\n    assert solution.minCost(25, [[0, 1, 10], [1, 2, 10], [2, 3, 5]], [100, 200, 300, 400]) == 270", "def test_minCost():\n    solution = Solution()\n    assert solution.minCost(15, [[0, 1, 10], [0, 2, 3], [1, 2, 4]], [5, 5, 5]) == -1", "def test_minCost():\n    solution = Solution()\n    assert solution.minCost(10, [[0, 1, 5], [0, 2, 3], [1, 2, 2]], [100, 200, 300]) == 207", "def test_minCost():\n    solution = Solution()\n    assert solution.minCost(5, [[0, 1, 2], [1, 2, 3], [2, 3, 4]], [10, 20, 30, 40]) == -1", "def test_minCost():\n    solution = Solution()\n    assert solution.minCost(20, [[0, 1, 5], [1, 2, 5], [2, 3, 5]], [1, 2, 3, 4]) == 6", "def test_minCost():\n    solution = Solution()\n    assert solution.minCost(10, [[0, 1, 2], [1, 2, 3], [2, 3, 4]], [10, 20, 30, 40]) == -1", "def test_minCost():\n    solution = Solution()\n    assert solution.minCost(25, [[0, 1, 10], [1, 2, 10], [2, 3, 5]], [100, 200, 300, 400]) == 270", "def test_minCost():\n    solution = Solution()\n    assert solution.minCost(15, [[0, 1, 10], [0, 2, 3], [1, 2, 4]], [5, 5, 5]) == -1", "def test_minCost():\n    solution = Solution()\n    assert solution.minCost(10, [[0, 1, 5], [0, 2, 3], [1, 2, 2]], [100, 200, 300]) == 207", "def test_minCost():\n    solution = Solution()\n    assert solution.minCost(5, [[0, 1, 2], [1, 2, 3], [2, 3, 4]], [10, 20, 30, 40]) == -1", "def test_minCost():\n    solution = Solution()\n    assert solution.minCost(20, [[0, 1, 5], [1, 2, 5], [2, 3, 5]], [1, 2, 3, 4]) == 6", "def test_minCost():\n    solution = Solution()\n    assert solution.minCost(10, [[0, 1, 2], [1, 2, 3], [2, 3, 4]], [10, 20, 30, 40]) == -1", "def test_minCost():\n    solution = Solution()\n    assert solution.minCost(25, [[0, 1, 10], [1, 2, 10], [2, 3, 5]], [100, 200, 300, 400]) == 270", "def test_minCost():\n    solution = Solution()\n    assert solution.minCost(15, [[0, 1, 10], [0, 2, 3], [1, 2, 4]], [5, 5, 5]) == -1"]}
{"task_num": 1938, "task_title": "Maximum Genetic Difference Query", "func_name": "maxGeneticDifference", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass TrieNode:\n  def __init__(self):\n    self.children = [None] * 2\n    self.count = 0\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n    self.kHeight = 17\n\n  def update(self, num: int, val: int) -> None:\n    node = self.root\n    for i in range(self.kHeight, -1, -1):\n      bit = (num >> i) & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n      node.count += val\n\n  def query(self, num: int) -> int:\n    ans = 0\n    node = self.root\n    for i in range(self.kHeight, -1, -1):\n      bit = (num >> i) & 1\n      targetBit = bit ^ 1\n      if node.children[targetBit] and node.children[targetBit].count > 0:\n        ans += 1 << i\n        node = node.children[targetBit]\n      else:\n        node = node.children[targetBit ^ 1]\n    return ans\n\n\nclass Solution:\n  def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\n    n = len(parents)\n    ans = [0] * len(queries)\n    rootVal = -1\n    tree = [[] for _ in range(n)]\n    nodeToQueries = collections.defaultdict(list)\n    trie = Trie()\n\n    for i, parent in enumerate(parents):\n      if parent == -1:\n        rootVal = i\n      else:\n        tree[parent].append(i)\n\n    for i, (node, val) in enumerate(queries):\n      nodeToQueries[node].append((i, val))\n\n    def dfs(node: int) -> None:\n      trie.update(node, 1)\n\n      for i, val in nodeToQueries[node]:\n        ans[i] = trie.query(val)\n\n      for child in tree[node]:\n        dfs(child)\n\n      trie.update(node, -1)\n\n    dfs(rootVal)\n    return ans\n", "tests": ["def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [-1, 0, 1, 2]\n    queries = [[0, 3], [1, 5], [2, 4]]\n    expected_output = [3, 7, 7]\n    assert solution.maxGeneticDifference(parents, queries) == expected_output", "def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [-1, 0, 1, 2, 3]\n    queries = [[0, 7], [2, 6], [4, 9]]\n    expected_output = [7, 7, 8]\n    assert solution.maxGeneticDifference(parents, queries) == expected_output", "def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [-1]\n    queries = [[0, 15]]\n    expected_output = [15]\n    assert solution.maxGeneticDifference(parents, queries) == expected_output", "def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [-1, 0, 0]\n    queries = [[0, 1], [1, 2], [2, 3]]\n    expected_output = [1, 3, 3]\n    assert solution.maxGeneticDifference(parents, queries) == expected_output", "def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [-1, 0, 1, 2, 3, 4]\n    queries = [[1, 8], [3, 5], [5, 9]]\n    expected_output = [8, 7, 15]\n    assert solution.maxGeneticDifference(parents, queries) == expected_output", "def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [-1, 0, 2, 4, 3]\n    queries = [[0, 15], [2, 8], [4, 9]]\n    expected_output = [15, 7, 8]\n    assert solution.maxGeneticDifference(parents, queries) == expected_output", "def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [-1, 0, 2, 1]\n    queries = [[0, 7], [1, 6], [3, 5]]\n    expected_output = [7, 3, 7]\n    assert solution.maxGeneticDifference(parents, queries) == expected_output", "def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [-1, 0, 2, 4, 3]\n    queries = [[0, 15], [1, 8], [3, 9], [4, 7]]\n    expected_output = [15, 7, 8, 11]\n    assert solution.maxGeneticDifference(parents, queries) == expected_output", "def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [-1, 0, 2, 4, 3]\n    queries = [[0, 15], [1, 8], [3, 9], [4, 7], [2, 6]]\n    expected_output = [15, 7, 8, 11, 7]\n    assert solution.maxGeneticDifference(parents, queries) == expected_output", "def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [-1, 0, 1]\n    queries = [[1, 2], [2, 3]]\n    expected_output = [2, 1]\n    assert solution.maxGeneticDifference(parents, queries) == expected_output", "def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [-1, 0, 1, 2, 3]\n    queries = [[0, 8], [1, 6], [2, 4], [3, 7]]\n    expected_output = [8, 6, 4, 7]\n    assert solution.maxGeneticDifference(parents, queries) == expected_output", "def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [-1, 0, 2, 4, 3]\n    queries = [[0, 15], [1, 8], [3, 9], [4, 7], [2, 6], [5, 10]]\n    expected_output = [15, 7, 8, 11, 7, 5]\n    assert solution.maxGeneticDifference(parents, queries) == expected_output", "def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [-1, 0, 2, 4, 3]\n    queries = [[0, 15], [1, 8], [3, 9], [4, 7], [2, 6], [5, 10], [0, 1]]\n    expected_output = [15, 7, 8, 11, 7, 5, 1]\n    assert solution.maxGeneticDifference(parents, queries) == expected_output", "def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [-1, 0, 2, 4, 3]\n    queries = [[0, 7], [1, 6], [3, 5], [4, 9]]\n    expected_output = [7, 3, 7, 8]\n    assert solution.maxGeneticDifference(parents, queries) == expected_output", "def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [-1, 0, 2, 4, 3]\n    queries = [[0, 15], [1, 8], [3, 9], [4, 7], [2, 6], [5, 10], [1, 12]]\n    expected_output = [15, 12, 12, 11, 7, 5, 12]\n    assert solution.maxGeneticDifference(parents, queries) == expected_output", "def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [-1, 0, 2, 4, 3]\n    queries = [[0, 15], [1, 8], [3, 9], [4, 7], [2, 6], [5, 10], [3, 14]]\n    expected_output = [15, 7, 14, 11, 7, 5, 14]\n    assert solution.maxGeneticDifference(parents, queries) == expected_output", "def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [-1, 0, 2, 4, 3]\n    queries = [[0, 15], [1, 8], [3, 9], [4, 7], [2, 6], [5, 10], [4, 2]]\n    expected_output = [15, 7, 9, 11, 7, 5, 10]\n    assert solution.maxGeneticDifference(parents, queries) == expected_output", "def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [-1, 0, 2, 4, 3]\n    queries = [[0, 15], [1, 8], [3, 9], [4, 7], [2, 6], [5, 10], [5, 1]]\n    expected_output = [15, 7, 9, 11, 7, 5, 1]\n    assert solution.maxGeneticDifference(parents, queries) == expected_output", "def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [-1, 0, 2, 4, 3]\n    queries = [[0, 15], [1, 8], [3, 9], [4, 7], [2, 6], [5, 10], [5, 15]]\n    expected_output = [15, 7, 15, 11, 7, 5, 10]\n    assert solution.maxGeneticDifference(parents, queries) == expected_output", "def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [-1, 0, 2, 4, 3]\n    queries = [[0, 7], [1, 6], [3, 5], [4, 9], [2, 8]]\n    expected_output = [7, 3, 7, 8, 7]\n    assert solution.maxGeneticDifference(parents, queries) == expected_output"]}
{"task_num": 1971, "task_title": "Find if Path Exists in Graph", "func_name": "validPath", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def validPath(self, n: int, edges: List[List[int]], source: int, destination: int) -> bool:\n    uf = UnionFind(n)\n\n    for u, v in edges:\n      uf.unionByRank(u, v)\n\n    return uf.find(source) == uf.find(destination)\n", "tests": ["def test_validPath():\n    solution = Solution()\n    assert solution.validPath(3, [[0, 1], [1, 2]], 0, 2) == True", "def test_validPath():\n    solution = Solution()\n    assert solution.validPath(3, [[0, 1]], 0, 2) == False", "def test_validPath():\n    solution = Solution()\n    assert solution.validPath(1, [], 0, 0) == True", "def test_validPath():\n    solution = Solution()\n    assert solution.validPath(2, [[0, 1]], 0, 1) == True", "def test_validPath():\n    solution = Solution()\n    n = 1000\n    edges = [[i, i + 1] for i in range(n - 1)]\n    assert solution.validPath(n, edges, 0, n - 1) == True", "def test_validPath():\n    solution = Solution()\n    assert solution.validPath(3, [[0, 1], [1, 2]], -1, 2) == False", "def test_validPath():\n    solution = Solution()\n    assert solution.validPath(3, [[0, 1], [1, 2]], 0, -1) == False", "def test_validPath():\n    solution = Solution()\n    assert solution.validPath(3, [[0, 1], [1, 2]], -1, -1) == False", "def test_validPath():\n    solution = Solution()\n    assert solution.validPath(2, [[1, 0]], 0, 1) == True", "def test_validPath():\n    solution = Solution()\n    assert solution.validPath(4, [], 0, 3) == False", "def test_validPath():\n    solution = Solution()\n    assert solution.validPath(2, [[0, 1]], 1, 1) == True", "def test_validPath():\n    solution = Solution()\n    assert solution.validPath(2, [[0, 1]], 0, 0) == True", "def test_validPath():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4], [4, 0]]\n    assert solution.validPath(n, edges, 0, 4) == True", "def test_validPath():\n    solution = Solution()\n    assert solution.validPath(1, [], 0, 0) == True", "def test_validPath():\n    solution = Solution()\n    n = 1000\n    edges = list(itertools.combinations(range(n), 2))\n    assert solution.validPath(n, edges, 0, n - 1) == True", "", "def test_validPath():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1], [2, 3]]\n    assert solution.validPath(n, edges, 0, 3) == False", "def test_validPath():\n    solution = Solution()\n    assert solution.validPath(1, [], 0, 0) == True", "def test_validPath():\n    solution = Solution()\n    assert solution.validPath(3, [[0, 1], [0, 2], [1, 2]], 0, 2) == True", "def test_validPath():\n    solution = Solution()\n    n = 1000\n    edges = [[i, i + 1] for i in range(n - 1)]\n    edges.append([n - 2, 1])\n    assert solution.validPath(n, edges, 0, n - 1) == True"]}
{"task_num": 1976, "task_title": "Number of Ways to Arrive at Destination", "func_name": "countPaths", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countPaths(self, n: int, roads: List[List[int]]) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in roads:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, 0, n - 1)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int) -> int:\n    kMod = 10**9 + 7\n    ways = [0] * len(graph)\n    dist = [math.inf] * len(graph)\n\n    ways[src] = 1\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          ways[v] = ways[u]\n          heapq.heappush(minHeap, (dist[v], v))\n        elif d + w == dist[v]:\n          ways[v] += ways[u]\n          ways[v] %= kMod\n\n    return ways[dst]\n", "tests": ["def test_countPaths():\n    solution = Solution()\n    assert solution.countPaths(3, [[0, 1, 100], [1, 2, 100], [0, 2, 50]]) == 2", "def test_countPaths():\n    solution = Solution()\n    assert solution.countPaths(4, [[0, 1, 1], [1, 2, 2], [2, 3, 3]]) == 1", "def test_countPaths():\n    solution = Solution()\n    assert solution.countPaths(4, [[0, 1, -1], [1, 2, -1], [2, 3, -1]]) == 1", "def test_countPaths():\n    solution = Solution()\n    assert solution.countPaths(4, [[0, 1, 1], [1, 2, 2], [0, 3, 5]]) == 2", "def test_countPaths():\n    solution = Solution()\n    n = 100\n    roads = [(i, (i + 1) % n, 1) for i in range(n)]\n    assert solution.countPaths(n, roads) == n % (10 ** 9 + 7)", "def test_countPaths():\n    solution = Solution()\n    assert solution.countPaths(2, [[1, 0, 1]]) == 0", "def test_countPaths():\n    solution = Solution()\n    assert solution.countPaths(4, [[0, 1, 1], [1, 2, 1], [2, 3, 1], [0, 1, 1]]) == 2", "def test_countPaths():\n    solution = Solution()\n    n = 4\n    roads = [[0, 1, 10 ** 9], [1, 2, 10 ** 9], [2, 3, 10 ** 9]]\n    assert solution.countPaths(n, roads) == 1 % (10 ** 9 + 7)", "def test_countPaths():\n    solution = Solution()\n    assert solution.countPaths(4, [[0, 1, 0], [1, 2, 0], [2, 3, 0]]) == 1", "def test_countPaths():\n    solution = Solution()\n    assert solution.countPaths(5, [[1, 2, 1], [2, 3, 1]]) == 0", "def test_countPaths():\n    solution = Solution()\n    assert solution.countPaths(1, []) == 0", "def test_countPaths():\n    solution = Solution()\n    n = 10\n    roads = [[i, (i + 1) % n, 1] for i in range(n)] + [[i, (i - 1) % n, 1] for i in range(n)]\n    assert solution.countPaths(n, roads) == n * 2 % (10 ** 9 + 7)", "def test_countPaths():\n    solution = Solution()\n    assert solution.countPaths(4, [[0, 1, 2], [1, 2, 3], [0, 1, 2]]) == 2", "def test_countPaths():\n    solution = Solution()\n    assert solution.countPaths(4, [[0, 1, -1], [1, 2, 1], [2, 3, 1]]) == 1", "def test_countPaths():\n    solution = Solution()\n    n = 5\n    roads = [[i, (i + 1) % n, 1] for i in range(n)] * 100\n    assert solution.countPaths(n, roads) == n * 2 % (10 ** 9 + 7)", "def test_countPaths():\n    solution = Solution()\n    n = 10\n    roads = [[i, (i + 1) % n, 1] for i in range(n)]\n    roads += [[i, (i - 1) % n, 2] for i in range(n)] * 5\n    assert solution.countPaths(n, roads) == n * 7 % (10 ** 9 + 7)", "def test_countPaths():\n    solution = Solution()\n    n = 100\n    roads = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (j - i) % 3 == 0:\n                roads.append((i, j, 1))\n            elif (j - i) % 3 == 1:\n                roads.append((i, j, 2))\n            else:\n                roads.append((i, j, 3))\n    assert solution.countPaths(n, roads) == n * (n - 1) // 2 % (10 ** 9 + 7)", "def test_countPaths():\n    solution = Solution()\n    assert solution.countPaths(4, [[0, 1, 1], [1, 2, 1], [3, 2, 1]]) == 0", "def test_countPaths():\n    solution = Solution()\n    assert solution.countPaths(4, [[0, 1, 1], [1, 2, 1], [2, 3, 1], [1, 0, 1]]) == 2", "def test_countPaths():\n    solution = Solution()\n    assert solution.countPaths(4, [[0, 1, 1], [1, 2, 1], [3, 2, 1], [2, 1, 1], [1, 0, 1]]) == 4"]}
{"task_num": 1977, "task_title": "Number of Ways to Separate Numbers", "func_name": "numberOfCombinations", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numberOfCombinations(self, num: str) -> int:\n    if num[0] == '0':\n      return 0\n\n    kMod = 1_000_000_007\n    n = len(num)\n    dp = [[0] * (n + 1) for _ in range(n)]\n    lcs = [[0] * (n + 1) for _ in range(n + 1)]\n\n    for i in range(n - 1, -1, -1):\n      for j in range(i + 1, n):\n        if num[i] == num[j]:\n          lcs[i][j] = lcs[i + 1][j + 1] + 1\n\n    for i in range(n):\n      for k in range(1, i + 2):\n        dp[i][k] += dp[i][k - 1]\n        dp[i][k] %= kMod\n        s = i - k + 1\n        if num[s] == '0':\n          continue\n        if s == 0:\n          dp[i][k] += 1\n          continue\n        if s < k:\n          dp[i][k] += dp[s - 1][s]\n          continue\n        l = lcs[s - k][s]\n        if l >= k or num[s - k + l] <= num[s + l]:\n          dp[i][k] += dp[s - 1][k]\n        else:\n          dp[i][k] += dp[s - 1][k - 1]\n\n    return dp[n - 1][n] % kMod\n", "tests": ["def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('12345') == 5", "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('0123') == 0", "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('7') == 1", "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('123') == 6", "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('123123') == 42", "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('0011') == 0", "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('0') == 0", "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('1234567890' * 10) == 3640", "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('1234567890' * 100) == 36400", "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('123045') == 19", "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('1234567890' * 100 + '1') == 36401", "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('1231231') == 78", "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('123123') == 42", "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('abcabc') == 42", "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('1234567890' * 10 + 'abc') == 36401", "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('123' + '9' * 100) == 55", "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('1234567890' * 10 + 'abc') == 36401", "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('1234567890' * 10 + '1234567890' * 10) == 36400", "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('1a2b3c' * 10 + 'abc') == 0", "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('1234567890' * 10 + '1') == 36401"]}
{"task_num": 1994, "task_title": "The Number of Good Subsets", "func_name": "numberOfGoodSubsets", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numberOfGoodSubsets(self, nums: List[int]) -> int:\n    kMod = 1_000_000_007\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n    n = 1 << len(primes)\n    dp = [1] + [0] * (n - 1)\n    count = collections.Counter(nums)\n\n    for num, freq in count.items():\n      if num == 1:\n        continue\n      if any(num % squared == 0 for squared in [4, 9, 25]):\n        continue\n      numPrimesMask = 0\n      for i, prime in enumerate(primes):\n        if num % prime == 0:\n          numPrimesMask += 1 << i\n      for primesMask in range(n):\n        if primesMask & numPrimesMask > 0:\n          continue\n        nextPrimesMask = numPrimesMask | primesMask\n        dp[nextPrimesMask] += dp[primesMask] * freq\n        dp[nextPrimesMask] %= kMod\n\n    return (1 << count[1]) * sum(dp[1:]) % kMod\n", "tests": ["def test_numberOfGoodSubsets():\n    solution = Solution()\n    assert solution.numberOfGoodSubsets([1, 2, 3, 4]) == 6", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    assert solution.numberOfGoodSubsets([2, 2, 3]) == 10", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    assert solution.numberOfGoodSubsets([2, 3, 5, 7]) == 64", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    nums = [2] * 10 + [3] * 10 + [5] * 10 + [7] * 10\n    expected = (1 << 10) * sum([1 << i for i in range(4, 10)]) % 1000000007\n    assert solution.numberOfGoodSubsets(nums) == expected", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    assert solution.numberOfGoodSubsets([1, 1, 1]) == 8", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    assert solution.numberOfGoodSubsets([4, 8, 9, 25]) == 0", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    assert solution.numberOfGoodSubsets([2]) == 1", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    assert solution.numberOfGoodSubsets([6, 10, 15]) == 8", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    assert solution.numberOfGoodSubsets([2, 3, 5, 7, 11]) == 64", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    assert solution.numberOfGoodSubsets([]) == 1", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    nums = [23, 29, 31]\n    assert solution.numberOfGoodSubsets(nums) == 8", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    assert solution.numberOfGoodSubsets([1] * 20) == 1 << 20", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    assert solution.numberOfGoodSubsets([2, 3, 5, 7]) == 64", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    assert solution.numberOfGoodSubsets([1, 2, 3]) == 8", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    assert solution.numberOfGoodSubsets([-2, 3, 5]) == 0", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    assert solution.numberOfGoodSubsets([0, 2, 3]) == 8", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    assert solution.numberOfGoodSubsets([2]) == 1", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    max_val = 10 ** 9\n    assert solution.numberOfGoodSubsets([max_val]) == 0", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    assert solution.numberOfGoodSubsets([2, 4, 6]) == 8", "def test_numberOfGoodSubsets():\n    solution = Solution()\n    assert solution.numberOfGoodSubsets([1, 2, 3, 5]) == 16"]}
{"task_num": 1998, "task_title": "GCD Sort of an Array", "func_name": "gcdSort", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def gcdSort(self, nums: List[int]) -> bool:\n    maxNum = max(nums)\n    minPrimeFactors = self._sieveEratosthenes(maxNum + 1)\n    uf = UnionFind(maxNum + 1)\n\n    for num in nums:\n      for primeFactor in self._getPrimeFactors(num, minPrimeFactors):\n        uf.unionByRank(num, primeFactor)\n\n    for a, b in zip(nums, sorted(nums)):\n      if uf.find(a) != uf.find(b):\n        return False\n\n    return True\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeFactors(self, num: int, minPrimeFactors: List[int]) -> List[int]:\n    primeFactors = []\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      primeFactors.append(divisor)\n      while num % divisor == 0:\n        num //= divisor\n    return primeFactors\n", "tests": ["def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([8, 9]) == True", "def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([4, 10, 6]) == True", "def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([100, 25, 5]) == True", "def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([12, 18, 3]) == True", "def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([7, 14]) == True", "def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([15, 30]) == True", "def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([3, 9, 27]) == True", "def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([2, 4, 8, 16]) == True", "def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([30, 15, 45]) == True", "def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([10, 25, 50]) == True", "def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([12, 24, 36]) == True", "def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([18, 36, 54]) == True", "def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([20, 40, 60]) == True", "def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([24, 36, 48]) == True", "def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([7, 14, 28]) == True", "def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([18, 36, 54]) == True", "def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([3, 6, 9, 12]) == True", "def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([12, 48, 60]) == True", "def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([10, 5, 2]) == True", "def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([100, 25, 5]) == True"]}
{"task_num": 2019, "task_title": "The Score of Students Solving Math Expression", "func_name": "scoreOfStudents", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nimport operator\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def scoreOfStudents(self, s: str, answers: List[int]) -> int:\n    n = len(s) // 2 + 1\n    ans = 0\n    func = {'+': operator.add, '*': operator.mul}\n    dp = [[set() for j in range(n)] for _ in range(n)]\n\n    for i in range(n):\n      dp[i][i].add(int(s[i * 2]))\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        for k in range(i, j):\n          op = s[k * 2 + 1]\n          for a in dp[i][k]:\n            for b in dp[k + 1][j]:\n              res = func[op](a, b)\n              if res <= 1000:\n                dp[i][j].add(res)\n\n    correctAnswer = eval(s)\n\n    for answer, freq in collections.Counter(answers).items():\n      if answer == correctAnswer:\n        ans += 5 * freq\n      elif answer in dp[0][n - 1]:\n        ans += 2 * freq\n\n    return ans\n", "tests": ["def test_scoreOfStudents():\n    solution = Solution()\n    assert solution.scoreOfStudents('1+2*3', [6, 9, 8]) == 7", "def test_scoreOfStudents():\n    solution = Solution()\n    assert solution.scoreOfStudents('10*2+3', [23, 5, 20]) == 7", "def test_scoreOfStudents():\n    solution = Solution()\n    assert solution.scoreOfStudents('9+8*7', [63, 140, 62]) == 7", "def test_scoreOfStudents():\n    solution = Solution()\n    assert solution.scoreOfStudents('1*2+3', [5, 4, 6]) == 7", "def test_scoreOfStudents():\n    solution = Solution()\n    assert solution.scoreOfStudents('1+2*3', [9, 8, 7]) == 5", "def test_scoreOfStudents():\n    solution = Solution()\n    assert solution.scoreOfStudents('10*2+3', [20, 5, 23]) == 7", "def test_scoreOfStudents():\n    solution = Solution()\n    assert solution.scoreOfStudents('9+8*7', [140, 63, 62]) == 7", "def test_scoreOfStudents():\n    solution = Solution()\n    assert solution.scoreOfStudents('1*2+3', [6, 5, 7]) == 5", "def test_scoreOfStudents():\n    solution = Solution()\n    assert solution.scoreOfStudents('10*2+3', [40, 5, 26]) == 7", "def test_scoreOfStudents():\n    solution = Solution()\n    assert solution.scoreOfStudents('9+8*7', [140, 62, 63]) == 7", "def test_scoreOfStudents():\n    solution = Solution()\n    assert solution.scoreOfStudents('1*2+3', [7, 5, 6]) == 5", "def test_scoreOfStudents():\n    solution = Solution()\n    assert solution.scoreOfStudents('10*2+3', [40, 5, 27]) == 7", "def test_scoreOfStudents():\n    solution = Solution()\n    assert solution.scoreOfStudents('9+8*7', [140, 63, 62]) == 7", "def test_scoreOfStudents():\n    solution = Solution()\n    assert solution.scoreOfStudents('1*2+3', [6, 5, 7]) == 5", "def test_scoreOfStudents():\n    solution = Solution()\n    assert solution.scoreOfStudents('10*2+3', [40, 5, 26]) == 7", "def test_scoreOfStudents():\n    solution = Solution()\n    assert solution.scoreOfStudents('9+8*7', [140, 62, 63]) == 7", "def test_scoreOfStudents():\n    solution = Solution()\n    assert solution.scoreOfStudents('1*2+3', [7, 5, 6]) == 5", "def test_scoreOfStudents():\n    solution = Solution()\n    assert solution.scoreOfStudents('10*2+3', [40, 5, 27]) == 7", "def test_scoreOfStudents():\n    solution = Solution()\n    assert solution.scoreOfStudents('9+8*7', [140, 63, 62]) == 7", "def test_scoreOfStudents():\n    solution = Solution()\n    assert solution.scoreOfStudents('1*2+3', [6, 5, 7]) == 5"]}
{"task_num": 2030, "task_title": "Smallest K-Length Subsequence With Occurrences of a Letter", "func_name": "smallestSubsequence", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\n    stack = []\n    required = repetition\n    nLetters = s.count(letter)\n\n    for i, c in enumerate(s):\n      while stack and stack[-1] > c  and len(stack) + len(s) - i - 1 >= k and (stack[-1] != letter or nLetters > required):\n        if stack.pop() == letter:\n          required += 1\n      if len(stack) < k:\n        if c == letter:\n          stack.append(c)\n          required -= 1\n        elif k - len(stack) > required:\n          stack.append(c)\n      if c == letter:\n        nLetters -= 1\n\n    return ''.join(stack)\n", "tests": ["def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('aaabbb', 5, 'a', 2) == 'aabbb'", "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('abcde', 3, 'e', 1) == 'ace'", "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('aabbcc', 6, 'b', 2) == 'aabbc'", "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('aabbccdd', 4, 'd', 1) == 'abdc'", "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('aabbccdd', 7, 'c', 3) == 'abcdd'", "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('aabbcc', 5, 'c', 2) == 'abacc'", "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('abcabcd', 4, 'b', 2) == 'abbc'", "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('abcabcd', 6, 'a', 3) == 'aababc'", "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('abcabcd', 7, 'c', 2) == 'abcc'", "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('abcabcd', 5, 'a', 1) == 'abacd'", "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('aaabc', 4, 'b', 1) == 'aabb'", "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('aaabc', 5, 'c', 1) == 'aabbc'", "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('aabcdd', 4, 'd', 1) == 'abdc'", "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('aabcdd', 5, 'd', 2) == 'abdc'", "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('aabcdd', 6, 'd', 1) == 'aabdc'", "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('abcde', 5, 'e', 1) == 'abcde'", "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('abacb', 3, 'c', 1) == 'abc'", "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('bbaca', 4, 'a', 1) == 'abac'", "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('bbaaaa', 4, 'a', 2) == 'abaa'", "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('aabccc', 5, 'c', 3) == 'abcac'"]}
{"task_num": 2040, "task_title": "Kth Smallest Product of Two Sorted Arrays", "func_name": "kthSmallestProduct", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int) -> int:\n    A1 = [-num for num in nums1 if num < 0][::-1]\n    A2 = [num for num in nums1 if num >= 0]\n    B1 = [-num for num in nums2 if num < 0][::-1]\n    B2 = [num for num in nums2 if num >= 0]\n\n    negCount = len(A1) * len(B2) + len(A2) * len(B1)\n\n    if k > negCount:\n      k -= negCount\n      sign = 1\n    else:\n      k = negCount - k + 1\n      sign = -1\n      B1, B2 = B2, B1\n\n    def numProductNoGreaterThan(A: List[int], B: List[int], m: int) -> int:\n      ans = 0\n      j = len(B) - 1\n      for i in range(len(A)):\n        while j >= 0 and A[i] * B[j] > m:\n          j -= 1\n        ans += j + 1\n      return ans\n\n    l = 0\n    r = 10**10\n\n    while l < r:\n      m = (l + r) // 2\n      if numProductNoGreaterThan(A1, B1, m) + numProductNoGreaterThan(A2, B2, m) >= k:\n        r = m\n      else:\n        l = m + 1\n\n    return sign * l\n", "tests": ["def test_kthSmallestProduct():\n    solution = Solution()\n    assert solution.kthSmallestProduct([2, 5], [3, 4], 4) == 6", "def test_kthSmallestProduct():\n    solution = Solution()\n    assert solution.kthSmallestProduct([-10, -2], [-3, 4], 5) == 6", "def test_kthSmallestProduct():\n    solution = Solution()\n    assert solution.kthSmallestProduct([1, 2, -3], [4, -5, 6], 8) == -9", "def test_kthSmallestProduct():\n    solution = Solution()\n    assert solution.kthSmallestProduct([1], [2], 1) == 2", "def test_kthSmallestProduct():\n    solution = Solution()\n    assert solution.kthSmallestProduct([10 ** 9], [10 ** 9], 1) == 10 ** 18", "def test_kthSmallestProduct():\n    solution = Solution()\n    assert solution.kthSmallestProduct([0], [1], 1) == 0", "def test_kthSmallestProduct():\n    solution = Solution()\n    assert solution.kthSmallestProduct([1, 2], [3, 4], -1) == None", "def test_kthSmallestProduct():\n    solution = Solution()\n    assert solution.kthSmallestProduct([-10 ** 9], [-10 ** 9], 1) == -10 ** 18", "def test_kthSmallestProduct():\n    solution = Solution()\n    assert solution.kthSmallestProduct([1, 2], [3], 3) == 6", "def test_kthSmallestProduct():\n    solution = Solution()\n    assert solution.kthSmallestProduct([1, 2], [1, 2], 3) == 4", "def test_kthSmallestProduct():\n    solution = Solution()\n    assert solution.kthSmallestProduct([-1], [2], 1) == -2", "def test_kthSmallestProduct():\n    solution = Solution()\n    assert solution.kthSmallestProduct([1, 2], [3, 4], 5) == 8", "def test_kthSmallestProduct():\n    solution = Solution()\n    assert solution.kthSmallestProduct([1], [2], 1) == 2", "def test_kthSmallestProduct():\n    solution = Solution()\n    assert solution.kthSmallestProduct([], [], 1) == None", "def test_kthSmallestProduct():\n    solution = Solution()\n    assert solution.kthSmallestProduct([-1], [-2], 1) == 2", "def test_kthSmallestProduct():\n    solution = Solution()\n    assert solution.kthSmallestProduct([-10 ** 9], [10 ** 9], 1) == -10 ** 18", "def test_kthSmallestProduct():\n    solution = Solution()\n    assert solution.kthSmallestProduct([1, 2], [3, 4], 1) == 2", "def test_kthSmallestProduct():\n    solution = Solution()\n    assert solution.kthSmallestProduct([-1, 2], [3, -4], 5) == -6", "def test_kthSmallestProduct():\n    solution = Solution()\n    assert solution.kthSmallestProduct([1, 2], [3, 4], 1) == 2", "def test_kthSmallestProduct():\n    solution = Solution()\n    assert solution.kthSmallestProduct([1, 2], [3, 4], 0) == None"]}
{"task_num": 2045, "task_title": "Second Minimum Time to Reach Destination", "func_name": "secondMinimum", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\n    graph = [[] for _ in range(n + 1)]\n    q = collections.deque([(1, 0)])\n    minTime = [[math.inf] * 2 for _ in range(n + 1)]\n    minTime[1][0] = 0\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    while q:\n      i, prevTime = q.popleft()\n\n      numChangeSignal = prevTime // change\n      waitTime = change - (prevTime % change) if numChangeSignal & 1 else 0\n      newTime = prevTime + waitTime + time\n      for j in graph[i]:\n        if newTime < minTime[j][0]:\n          minTime[j][0] = newTime\n          q.append((j, newTime))\n        elif minTime[j][0] < newTime < minTime[j][1]:\n          if j == n:\n            return newTime\n          minTime[j][1] = newTime\n          q.append((j, newTime))\n", "tests": ["def test_secondMinimum():\n    solution = Solution()\n    n = 5\n    edges = [[1, 2], [1, 3], [3, 4], [4, 5]]\n    time = 2\n    change = 2\n    assert solution.secondMinimum(n, edges, time, change) == 8", "def test_secondMinimum():\n    solution = Solution()\n    n = 4\n    edges = [[1, 2], [2, 3], [3, 4]]\n    time = 3\n    change = 5\n    assert solution.secondMinimum(n, edges, time, change) == 16", "def test_secondMinimum():\n    solution = Solution()\n    n = 3\n    edges = [[1, 2], [2, 3]]\n    time = 4\n    change = 6\n    assert solution.secondMinimum(n, edges, time, change) == 10", "def test_secondMinimum():\n    solution = Solution()\n    n = 2\n    edges = [[1, 2]]\n    time = 5\n    change = 7\n    assert solution.secondMinimum(n, edges, time, change) == 10", "def test_secondMinimum():\n    solution = Solution()\n    n = 6\n    edges = [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6]]\n    time = 1\n    change = 10\n    assert solution.secondMinimum(n, edges, time, change) == 17", "def test_secondMinimum():\n    solution = Solution()\n    n = 4\n    edges = [[1, 2], [2, 3], [3, 4], [1, 4]]\n    time = 2\n    change = 2\n    assert solution.secondMinimum(n, edges, time, change) == 6", "def test_secondMinimum():\n    solution = Solution()\n    n = 5\n    edges = [[1, 2], [2, 3], [3, 4], [4, 5], [1, 3]]\n    time = 3\n    change = 3\n    assert solution.secondMinimum(n, edges, time, change) == 9", "def test_secondMinimum():\n    solution = Solution()\n    n = 3\n    edges = [[1, 2], [2, 3], [1, 3]]\n    time = 4\n    change = 5\n    assert solution.secondMinimum(n, edges, time, change) == 10", "def test_secondMinimum():\n    solution = Solution()\n    n = 4\n    edges = [[1, 2], [2, 3], [3, 4], [2, 4]]\n    time = 5\n    change = 7\n    assert solution.secondMinimum(n, edges, time, change) == 18", "def test_secondMinimum():\n    solution = Solution()\n    n = 6\n    edges = [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [1, 3]]\n    time = 1\n    change = 10\n    assert solution.secondMinimum(n, edges, time, change) == 18", "def test_secondMinimum():\n    solution = Solution()\n    n = 5\n    edges = [[1, 2], [1, 3], [3, 4], [4, 5]]\n    time = 2\n    change = 2\n    assert solution.secondMinimum(n, edges, time, change) == 8", "def test_secondMinimum():\n    solution = Solution()\n    n = 4\n    edges = [[1, 2], [2, 3], [3, 4]]\n    time = 3\n    change = 5\n    assert solution.secondMinimum(n, edges, time, change) == 16", "def test_secondMinimum():\n    solution = Solution()\n    n = 3\n    edges = [[1, 2], [2, 3]]\n    time = 4\n    change = 6\n    assert solution.secondMinimum(n, edges, time, change) == 10", "def test_secondMinimum():\n    solution = Solution()\n    n = 2\n    edges = [[1, 2]]\n    time = 5\n    change = 7\n    assert solution.secondMinimum(n, edges, time, change) == 10", "def test_secondMinimum():\n    solution = Solution()\n    n = 6\n    edges = [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6]]\n    time = 1\n    change = 10\n    assert solution.secondMinimum(n, edges, time, change) == 17", "def test_secondMinimum():\n    solution = Solution()\n    n = 4\n    edges = [[1, 2], [2, 3], [3, 4], [1, 3]]\n    time = 2\n    change = 2\n    assert solution.secondMinimum(n, edges, time, change) == 6", "def test_secondMinimum():\n    solution = Solution()\n    n = 5\n    edges = [[1, 2], [2, 3], [3, 4], [4, 5], [1, 3]]\n    time = 3\n    change = 3\n    assert solution.secondMinimum(n, edges, time, change) == 9", "def test_secondMinimum():\n    solution = Solution()\n    n = 3\n    edges = [[1, 2], [2, 3], [1, 3]]\n    time = 4\n    change = 5\n    assert solution.secondMinimum(n, edges, time, change) == 10", "def test_secondMinimum():\n    solution = Solution()\n    n = 4\n    edges = [[1, 2], [2, 3], [3, 4], [2, 4]]\n    time = 5\n    change = 7\n    assert solution.secondMinimum(n, edges, time, change) == 18", "def test_secondMinimum():\n    solution = Solution()\n    n = 6\n    edges = [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [1, 3]]\n    time = 1\n    change = 10\n    assert solution.secondMinimum(n, edges, time, change) == 18"]}
{"task_num": 2059, "task_title": "Minimum Operations to Convert Number", "func_name": "minimumOperations", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\n    ans = 0\n    q = collections.deque([start])\n    seen = {start}\n\n    while q:\n      ans += 1\n      for _ in range(len(q)):\n        x = q.popleft()\n        for num in nums:\n          for res in (x + num, x - num, x ^ num):\n            if res == goal:\n              return ans\n            if res < 0 or res > 1000 or res in seen:\n              continue\n            seen.add(res)\n            q.append(res)\n\n    return -1\n", "tests": ["def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations([4, 1, 5], 7, 2) == 2", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations([10, 100, 1000], 500, 1200) == 3", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations([1, 2, 4], 0, 3) == 1", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations([5, 6], 0, 3) == -1", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations([2, 4, 8], 15, 7) == -1", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations([3, 9, 5], 4, 10) == 2", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations([7], 7, 7) == 0", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations([2, 3], 5, 1) == -1", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations([10, 20, 30], 5, 60) == 3", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations([1, 2, 4, 8], 0, 7) == 3", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations([5, 10, 15], 20, 3) == -1", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations([100], 100, 50) == -1", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations([10, 20, 30], 5, 45) == 2", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations([10, 30, 60], 20, 80) == -1", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations([5], 3, 8) == -1", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations([2, 4, 8], 3, 7) == 1", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations([10, 20, 30], 5, 90) == 4", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations([1, 2, 3], 0, 6) == 2", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations([10, 30], 40, 70) == -1", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations([1, 2], 3, 7) == -1"]}
{"task_num": 2076, "task_title": "Process Restricted Friend Requests", "func_name": "friendRequests", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\n    ans = []\n    uf = UnionFind(n)\n\n    for u, v in requests:\n      pu = uf.find(u)\n      pv = uf.find(v)\n      isValid = True\n      if pu != pv:\n        for x, y in restrictions:\n          px = uf.find(x)\n          py = uf.find(y)\n          if (pu, pv) in [(px, py), (py, px)]:\n            isValid = False\n            break\n      ans.append(isValid)\n      if isValid:\n        uf.unionByRank(pu, pv)\n\n    return ans\n", "tests": ["def test_friendRequests():\n    solution = Solution()\n    n = 4\n    restrictions = [[0, 1], [1, 2]]\n    requests = [[0, 2], [0, 3]]\n    expected = [False, True]\n    assert solution.friendRequests(n, restrictions, requests) == expected", "def test_friendRequests():\n    solution = Solution()\n    n = 3\n    restrictions = []\n    requests = [[0, 1], [1, 2], [2, 0]]\n    expected = [True, True, False]\n    assert solution.friendRequests(n, restrictions, requests) == expected", "def test_friendRequests():\n    solution = Solution()\n    n = 5\n    restrictions = [[0, 1], [2, 3]]\n    requests = [[0, 2], [3, 4], [1, 3]]\n    expected = [True, True, False]\n    assert solution.friendRequests(n, restrictions, requests) == expected", "def test_friendRequests():\n    solution = Solution()\n    n = 3\n    restrictions = [[0, 2]]\n    requests = [[1, 2], [0, 1], [1, 2]]\n    expected = [True, False, True]\n    assert solution.friendRequests(n, restrictions, requests) == expected", "def test_friendRequests():\n    solution = Solution()\n    n = 6\n    restrictions = [[0, 1], [2, 3], [4, 5]]\n    requests = [[0, 2], [2, 4], [4, 0], [1, 3], [3, 5]]\n    expected = [True, True, False, False, True]\n    assert solution.friendRequests(n, restrictions, requests) == expected", "def test_friendRequests():\n    solution = Solution()\n    n = 2\n    restrictions = [[0, 1]]\n    requests = [[0, 1], [1, 0], [0, 1]]\n    expected = [False, False, True]\n    assert solution.friendRequests(n, restrictions, requests) == expected", "def test_friendRequests():\n    solution = Solution()\n    n = 5\n    restrictions = [[0, 2], [1, 3]]\n    requests = [[0, 1], [2, 4], [3, 0], [1, 2], [3, 4]]\n    expected = [True, True, False, False, False]\n    assert solution.friendRequests(n, restrictions, requests) == expected", "def test_friendRequests():\n    solution = Solution()\n    n = 4\n    restrictions = [[0, 2], [1, 3]]\n    requests = [[0, 1], [1, 2], [2, 0], [3, 1]]\n    expected = [True, False, True, True]\n    assert solution.friendRequests(n, restrictions, requests) == expected", "def test_friendRequests():\n    solution = Solution()\n    n = 5\n    restrictions = [[0, 2], [1, 3], [4, 1]]\n    requests = [[0, 1], [2, 4], [3, 0], [1, 2], [3, 4], [1, 0]]\n    expected = [True, True, False, False, False, False]\n    assert solution.friendRequests(n, restrictions, requests) == expected", "def test_friendRequests():\n    solution = Solution()\n    n = 4\n    restrictions = [[0, 1], [2, 3]]\n    requests = [[0, 1], [1, 2], [2, 0], [0, 2], [1, 3], [3, 0]]\n    expected = [True, True, False, False, False, False]\n    assert solution.friendRequests(n, restrictions, requests) == expected", "def test_friendRequests():\n    solution = Solution()\n    n = 3\n    restrictions = [[0, 1], [1, 2]]\n    requests = [[0, 1], [1, 2], [0, 2]]\n    expected = [True, True, False]\n    assert solution.friendRequests(n, restrictions, requests) == expected", "def test_friendRequests():\n    solution = Solution()\n    n = 5\n    restrictions = [[0, 2], [1, 3]]\n    requests = [[0, 1], [1, 2], [2, 4], [3, 4]]\n    expected = [True, True, False, False]\n    assert solution.friendRequests(n, restrictions, requests) == expected", "def test_friendRequests():\n    solution = Solution()\n    n = 4\n    restrictions = [[0, 2], [1, 3]]\n    requests = [[0, 1], [1, 2], [0, 2], [1, 3]]\n    expected = [True, True, False, False]\n    assert solution.friendRequests(n, restrictions, requests) == expected", "def test_friendRequests():\n    solution = Solution()\n    n = 6\n    restrictions = [[0, 2], [1, 3]]\n    requests = [[0, 1], [2, 4], [3, 5], [1, 2], [3, 4], [1, 0], [4, 5]]\n    expected = [True, True, True, False, False, False, False]\n    assert solution.friendRequests(n, restrictions, requests) == expected", "def test_friendRequests():\n    solution = Solution()\n    n = 4\n    restrictions = [[0, 2], [1, 3]]\n    requests = [[0, 1], [1, 2], [0, 1], [1, 3], [0, 2], [1, 3]]\n    expected = [True, True, False, False, False, False]\n    assert solution.friendRequests(n, restrictions, requests) == expected", "def test_friendRequests():\n    solution = Solution()\n    n = 5\n    restrictions = [[0, 1], [2, 3]]\n    requests = [[0, 1], [1, 2], [2, 4], [3, 4], [0, 2], [1, 3]]\n    expected = [True, True, False, False, False, False]\n    assert solution.friendRequests(n, restrictions, requests) == expected", "def test_friendRequests():\n    solution = Solution()\n    n = 4\n    restrictions = [[0, 1], [2, 3]]\n    requests = [[0, 1], [1, 2], [0, 2], [3, 0], [1, 3]]\n    expected = [True, True, False, False, True]\n    assert solution.friendRequests(n, restrictions, requests) == expected", "def test_friendRequests():\n    solution = Solution()\n    n = 5\n    restrictions = [[0, 2], [1, 3]]\n    requests = [[0, 1], [1, 2], [2, 4], [3, 4], [1, 0]]\n    expected = [True, True, False, False, False]\n    assert solution.friendRequests(n, restrictions, requests) == expected", "def test_friendRequests():\n    solution = Solution()\n    n = 4\n    restrictions = [[0, 1], [2, 3]]\n    requests = [[0, 1], [1, 2], [0, 2], [1, 3], [2, 0], [3, 1]]\n    expected = [True, True, False, False, False, False]\n    assert solution.friendRequests(n, restrictions, requests) == expected", "def test_friendRequests():\n    solution = Solution()\n    n = 5\n    restrictions = [[0, 2], [1, 3]]\n    requests = [[0, 1], [1, 2], [2, 4], [3, 4], [1, 0], [3, 2]]\n    expected = [True, True, False, False, False, False]\n    assert solution.friendRequests(n, restrictions, requests) == expected"]}
{"task_num": 2086, "task_title": "Minimum Number of Food Buckets to Feed the Hamsters", "func_name": "minimumBuckets", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumBuckets(self, street: str) -> int:\n    A = list(street)\n\n    for i, c in enumerate(A):\n      if c == 'H':\n        if i > 0 and A[i - 1] == 'B':\n          continue\n        if i + 1 < len(A) and A[i + 1] == '.':\n          A[i + 1] = 'B'\n        elif i > 0 and A[i - 1] == '.':\n          A[i - 1] = 'B'\n        else:\n          return -1\n\n    return A.count('B')\n", "tests": ["def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('H.H') == 2", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('H.H.H') == 3", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('H.H.H.H') == 4", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('H.H.H..') == 3", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('.H.H.') == 2", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('H.H.H.H.') == 4", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('.H.H.H.') == 3", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('H.H.H.H.H') == 5", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('.H.H.H.H.') == 4", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('H.H..H') == 3", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('H.H.H..H') == 4", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('.H.H.H..H.') == 4", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('H.H.H.H..H.') == 5", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('.H.H.H.H..H.') == 5", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('H.H.H.H.H.') == 6", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('.H.H.H.H.H.') == 6", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('H.H.H.H.H.H') == 7", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('.H.H.H.H.H.H.') == 7", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('H.H.H.H.H.H.H') == 8", "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('.H.H.H.H.H.H.H.') == 8"]}
{"task_num": 2092, "task_title": "Find All People With Secret", "func_name": "findAllPeople", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def connected(self, u: int, v: int) -> bool:\n    return self._find(self.id[u]) == self._find(self.id[v])\n\n  def reset(self, u: int) -> None:\n    self.id[u] = u\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\n    uf = UnionFind(n)\n    timeToPairs = collections.defaultdict(list)\n\n    uf.unionByRank(0, firstPerson)\n\n    for x, y, time in meetings:\n      timeToPairs[time].append((x, y))\n\n    for _, pairs in sorted(timeToPairs.items(), key=lambda x: x[0]):\n      peopleUnioned = set()\n      for x, y in pairs:\n        uf.unionByRank(x, y)\n        peopleUnioned.add(x)\n        peopleUnioned.add(y)\n      for person in peopleUnioned:\n        if not uf.connected(person, 0):\n          uf.reset(person)\n\n    res=[]\n    for i in range(n):\n      if uf.connected(i, 0):\n        res.append(i)\n    return res\n", "tests": ["def test_findAllPeople():\n    solution = Solution()\n    n = 6\n    meetings = [[1, 2, 5], [2, 3, 8], [1, 5, 10]]\n    firstPerson = 1\n    expected = [0, 1, 2, 3, 5]\n    result = sorted(solution.findAllPeople(n, meetings, firstPerson))", "def test_findAllPeople():\n    solution = Solution()\n    n = 3\n    meetings = [[0, 1, 2], [1, 2, 3]]\n    firstPerson = 0\n    expected = [0, 1, 2]\n    result = sorted(solution.findAllPeople(n, meetings, firstPerson))", "def test_findAllPeople():\n    solution = Solution()\n    n = 4\n    meetings = [[1, 3, 5], [0, 2, 6]]\n    firstPerson = 1\n    expected = [0, 1, 3]\n    result = sorted(solution.findAllPeople(n, meetings, firstPerson))", "def test_findAllPeople():\n    solution = Solution()\n    n = 5\n    meetings = [[0, 1, 2], [2, 3, 4], [3, 4, 5]]\n    firstPerson = 2\n    expected = [0, 1, 2, 3, 4]\n    result = sorted(solution.findAllPeople(n, meetings, firstPerson))", "def test_findAllPeople():\n    solution = Solution()\n    n = 3\n    meetings = [[0, 1, 2], [1, 2, 5], [2, 0, 6]]\n    firstPerson = 0\n    expected = [0, 1, 2]\n    result = sorted(solution.findAllPeople(n, meetings, firstPerson))", "def test_findAllPeople():\n    solution = Solution()\n    n = 5\n    meetings = [[0, 1, 2], [2, 3, 3], [4, 3, 5]]\n    firstPerson = 3\n    expected = [0, 1, 3]\n    result = sorted(solution.findAllPeople(n, meetings, firstPerson))", "def test_findAllPeople():\n    solution = Solution()\n    n = 4\n    meetings = [[0, 2, 1], [1, 3, 1]]\n    firstPerson = 2\n    expected = [0, 1, 2, 3]\n    result = sorted(solution.findAllPeople(n, meetings, firstPerson))", "def test_findAllPeople():\n    solution = Solution()\n    n = 6\n    meetings = [[1, 4, 3], [2, 5, 3], [0, 3, 4]]\n    firstPerson = 1\n    expected = [0, 1, 3]\n    result = sorted(solution.findAllPeople(n, meetings, firstPerson))", "def test_findAllPeople():\n    solution = Solution()\n    n = 5\n    meetings = [[0, 1, 2], [1, 2, 3], [3, 4, 5]]\n    firstPerson = 3\n    expected = [0, 3]\n    result = sorted(solution.findAllPeople(n, meetings, firstPerson))", "def test_findAllPeople():\n    solution = Solution()\n    n = 3\n    meetings = [[0, 1, 2], [0, 2, 3]]\n    firstPerson = 0\n    expected = [0, 1, 2]\n    result = sorted(solution.findAllPeople(n, meetings, firstPerson))", "def test_findAllPeople():\n    solution = Solution()\n    n = 4\n    meetings = [[0, 1, 2], [3, 2, 3]]\n    firstPerson = 1\n    expected = [0, 1]\n    result = sorted(solution.findAllPeople(n, meetings, firstPerson))", "def test_findAllPeople():\n    solution = Solution()\n    n = 5\n    meetings = [[0, 1, 2], [1, 3, 4]]\n    firstPerson = 3\n    expected = [0, 3]\n    result = sorted(solution.findAllPeople(n, meetings, firstPerson))", "def test_findAllPeople():\n    solution = Solution()\n    n = 4\n    meetings = [[0, 1, 2], [1, 2, 5]]\n    firstPerson = 0\n    expected = [0, 1, 2]\n    result = sorted(solution.findAllPeople(n, meetings, firstPerson))", "def test_findAllPeople():\n    solution = Solution()\n    n = 6\n    meetings = [[0, 1, 2], [2, 3, 4]]\n    firstPerson = 2\n    expected = [0, 2]\n    result = sorted(solution.findAllPeople(n, meetings, firstPerson))", "def test_findAllPeople():\n    solution = Solution()\n    n = 5\n    meetings = [[0, 1, 2], [1, 3, 4], [3, 2, 5]]\n    firstPerson = 1\n    expected = [0, 1, 3]\n    result = sorted(solution.findAllPeople(n, meetings, firstPerson))", "def test_findAllPeople():\n    solution = Solution()\n    n = 4\n    meetings = [[0, 1, 2], [3, 2, 5]]\n    firstPerson = 1\n    expected = [0, 1]\n    result = sorted(solution.findAllPeople(n, meetings, firstPerson))", "def test_findAllPeople():\n    solution = Solution()\n    n = 5\n    meetings = [[0, 1, 2], [1, 3, 4]]\n    firstPerson = 3\n    expected = [0, 3]\n    result = sorted(solution.findAllPeople(n, meetings, firstPerson))", "def test_findAllPeople():\n    solution = Solution()\n    n = 3\n    meetings = [[0, 1, 2], [1, 2, 5]]\n    firstPerson = 0\n    expected = [0, 1, 2]\n    result = sorted(solution.findAllPeople(n, meetings, firstPerson))", "def test_findAllPeople():\n    solution = Solution()\n    n = 4\n    meetings = [[0, 1, 2], [3, 2, 5]]\n    firstPerson = 1\n    expected = [0, 1]\n    result = sorted(solution.findAllPeople(n, meetings, firstPerson))", "def test_findAllPeople():\n    solution = Solution()\n    n = 5\n    meetings = [[0, 1, 2], [1, 3, 4]]\n    firstPerson = 3\n    expected = [0, 3]\n    result = sorted(solution.findAllPeople(n, meetings, firstPerson))"]}
{"task_num": 2115, "task_title": "Find All Possible Recipes from Given Supplies", "func_name": "findAllRecipes", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n    ans = []\n    supplies = set(supplies)\n    graph = collections.defaultdict(list)\n    inDegrees = collections.Counter()\n    q = collections.deque()\n\n    for i, recipe in enumerate(recipes):\n      for ingredient in ingredients[i]:\n        if ingredient not in supplies:\n          graph[ingredient].append(recipe)\n          inDegrees[recipe] += 1\n\n    for recipe in recipes:\n      if inDegrees[recipe] == 0:\n        q.append(recipe)\n\n    while q:\n      u = q.popleft()\n      ans.append(u)\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    return ans\n", "tests": ["def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['bread', 'sandwich']\n    ingredients = [['yeast', 'flour'], ['bread']]\n    supplies = ['yeast', 'flour', 'meat']\n    expected_output = ['bread', 'sandwich']\n    assert sorted(solution.findAllRecipes(recipes, ingredients, supplies)) == expected_output", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['apple Pie', 'pie Crust']\n    ingredients = [['apple'], ['apple Pie']]\n    supplies = ['apple']\n    expected_output = ['apple Pie']\n    assert sorted(solution.findAllRecipes(recipes, ingredients, supplies)) == expected_output", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['bread', 'sandwich']\n    ingredients = [['yeast', 'flour'], ['bread']]\n    supplies = []\n    expected_output = []\n    assert sorted(solution.findAllRecipes(recipes, ingredients, supplies)) == expected_output", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['cake']\n    ingredients = [['flour', 'sugar']]\n    supplies = ['flour', 'sugar']\n    expected_output = ['cake']\n    assert sorted(solution.findAllRecipes(recipes, ingredients, supplies)) == expected_output", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['cake', 'pie']\n    ingredients = [['flour', 'sugar'], ['flour', 'butter']]\n    supplies = ['flour', 'sugar', 'butter']\n    expected_output = ['cake', 'pie']\n    assert sorted(solution.findAllRecipes(recipes, ingredients, supplies)) == expected_output", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['cake']\n    ingredients = [[]]\n    supplies = ['flour', 'sugar']\n    expected_output = ['cake']\n    assert sorted(solution.findAllRecipes(recipes, ingredients, supplies)) == expected_output", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['cake', 'pie']\n    ingredients = [['flour', 'sugar'], ['flour', 'butter']]\n    supplies = ['flour']\n    expected_output = ['cake']\n    assert sorted(solution.findAllRecipes(recipes, ingredients, supplies)) == expected_output", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['cake', 'pie']\n    ingredients = [['flour'], ['flour']]\n    supplies = ['flour']\n    expected_output = ['cake', 'pie']\n    assert sorted(solution.findAllRecipes(recipes, ingredients, supplies)) == expected_output", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['apple Pie', 'pie Crust', 'sugar Cookie']\n    ingredients = [['apple'], ['apple Pie'], ['flour', 'butter']]\n    supplies = ['apple', 'flour', 'butter', 'sugar']\n    expected_output = ['apple Pie', 'pie Crust', 'sugar Cookie']\n    assert sorted(solution.findAllRecipes(recipes, ingredients, supplies)) == expected_output", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = []\n    ingredients = []\n    supplies = []\n    expected_output = []\n    assert sorted(solution.findAllRecipes(recipes, ingredients, supplies)) == expected_output", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['apple Pie', 'pie Crust']\n    ingredients = [['flour'], ['flour']]\n    supplies = ['apple Pie', 'pie Crust']\n    expected_output = ['apple Pie', 'pie Crust']\n    assert sorted(solution.findAllRecipes(recipes, ingredients, supplies)) == expected_output", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['cake']\n    ingredients = [['flour', 'sugar']]\n    supplies = ['flour', 'sugar']\n    expected_output = ['cake']\n    assert sorted(solution.findAllRecipes(recipes, ingredients, supplies)) == expected_output", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['apple Pie', 'pie Crust', 'sugar Cookie', 'nut Cake']\n    ingredients = [['apple'], ['apple Pie'], ['flour', 'butter'], ['almond']]\n    supplies = ['apple', 'flour', 'butter', 'almond']\n    expected_output = ['apple Pie', 'pie Crust', 'sugar Cookie', 'nut Cake']\n    assert sorted(solution.findAllRecipes(recipes, ingredients, supplies)) == expected_output", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['apple Pie', 'pie Crust', 'sugar Cookie']\n    ingredients = [['apple'], ['apple Pie'], ['flour', 'butter']]\n    supplies = ['apple', 'flour']\n    expected_output = ['cake', 'pie Crust']\n    assert sorted(solution.findAllRecipes(recipes, ingredients, supplies)) == expected_output", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['cake']\n    ingredients = [['flour', 'sugar']]\n    supplies = ['cake']\n    expected_output = []\n    assert sorted(solution.findAllRecipes(recipes, ingredients, supplies)) == expected_output", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = []\n    ingredients = []\n    supplies = ['flour', 'sugar']\n    expected_output = []\n    assert sorted(solution.findAllRecipes(recipes, ingredients, supplies)) == expected_output", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['cake', 'apple Pie']\n    ingredients = [['flour', 'sugar'], ['apple']]\n    supplies = ['cake', 'apple']\n    expected_output = ['apple Pie']\n    assert sorted(solution.findAllRecipes(recipes, ingredients, supplies)) == expected_output", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['cake', 'pie']\n    ingredients = [[], []]\n    supplies = []\n    expected_output = []\n    assert sorted(solution.findAllRecipes(recipes, ingredients, supplies)) == expected_output", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['apple Pie', 'pie Crust', 'sugar Cookie']\n    ingredients = [['apple'], ['apple Pie'], ['flour', 'butter']]\n    supplies = ['apple Pie', 'pie Crust', 'sugar Cookie']\n    expected_output = []\n    assert sorted(solution.findAllRecipes(recipes, ingredients, supplies)) == expected_output", "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['apple Pie', 'pie Crust']\n    ingredients = [['flour'], ['apple Pie']]\n    supplies = ['cake', 'apple Pie']\n    expected_output = []\n    assert sorted(solution.findAllRecipes(recipes, ingredients, supplies)) == expected_output"]}
{"task_num": 2127, "task_title": "Maximum Employees to Be Invited to a Meeting", "func_name": "maximumInvitations", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import Enum\n\n\nclass State(Enum):\n  kInit = 0\n  kVisiting = 1\n  kVisited = 2\n\n\nclass Solution:\n  def maximumInvitations(self, favorite: List[int]) -> int:\n    n = len(favorite)\n    sumComponentsLength = 0\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n    maxChainLength = [1] * n\n\n    for i, f in enumerate(favorite):\n      graph[i].append(f)\n      inDegrees[f] += 1\n\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n\n    while q:\n      u = q.popleft()\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n        maxChainLength[v] = max(maxChainLength[v], 1 + maxChainLength[u])\n\n    for i in range(n):\n      if favorite[favorite[i]] == i:\n        sumComponentsLength += maxChainLength[i] + maxChainLength[favorite[i]]\n\n    maxCycleLength = 0\n    parent = [-1] * n\n    seen = set()\n    states = [State.kInit] * n\n\n    def findCycle(u: int) -> None:\n      nonlocal maxCycleLength\n      seen.add(u)\n      states[u] = State.kVisiting\n      for v in graph[u]:\n        if v not in seen:\n          parent[v] = u\n          findCycle(v)\n        elif states[v] == State.kVisiting:\n          curr = u\n          cycleLength = 1\n          while curr != v:\n            curr = parent[curr]\n            cycleLength += 1\n          maxCycleLength = max(maxCycleLength, cycleLength)\n      states[u] = State.kVisited\n\n    for i in range(n):\n      if i not in seen:\n        findCycle(i)\n\n    return max(sumComponentsLength // 2, maxCycleLength)\n", "tests": ["def test_maximumInvitations():\n    solution = Solution()\n    assert solution.maximumInvitations([3, 0, 1, 4]) == 4", "def test_maximumInvitations():\n    solution = Solution()\n    assert solution.maximumInvitations([1, 2, 3, 0]) == 2", "def test_maximumInvitations():\n    solution = Solution()\n    assert solution.maximumInvitations([1, 0]) == 2", "def test_maximumInvitations():\n    solution = Solution()\n    assert solution.maximumInvitations([3, 0, 1, 2]) == 2", "def test_maximumInvitations():\n    solution = Solution()\n    assert solution.maximumInvitations([1, 3, 0, 2]) == 4", "def test_maximumInvitations():\n    solution = Solution()\n    assert solution.maximumInvitations([3, 0, 1, 4, 2]) == 6", "def test_maximumInvitations():\n    solution = Solution()\n    assert solution.maximumInvitations([3, 2, 1, 0]) == 4", "def test_maximumInvitations():\n    solution = Solution()\n    assert solution.maximumInvitations([1, 2, 3, 4]) == 2", "def test_maximumInvitations():\n    solution = Solution()\n    assert solution.maximumInvitations([3, 0, 4, 1, 2]) == 6", "def test_maximumInvitations():\n    solution = Solution()\n    assert solution.maximumInvitations([3, 1, 0]) == 2", "def test_maximumInvitations():\n    solution = Solution()\n    assert solution.maximumInvitations([0]) == 1", "def test_maximumInvitations():\n    solution = Solution()\n    assert solution.maximumInvitations([2, 0]) == 2", "def test_maximumInvitations():\n    solution = Solution()\n    assert solution.maximumInvitations([1, 0, 2]) == 3", "def test_maximumInvitations():\n    solution = Solution()\n    assert solution.maximumInvitations([1, 2, 3, 0]) == 2", "def test_maximumInvitations():\n    solution = Solution()\n    assert solution.maximumInvitations([3, 1, 0, 4, 2]) == 6", "def test_maximumInvitations():\n    solution = Solution()\n    assert solution.maximumInvitations([0, 1]) == 2", "def test_maximumInvitations():\n    solution = Solution()\n    assert solution.maximumInvitations([1, 0, 3, 2]) == 4", "def test_maximumInvitations():\n    solution = Solution()\n    assert solution.maximumInvitations([1, 2, 3, 4, 5]) == 2", "def test_maximumInvitations():\n    solution = Solution()\n    assert solution.maximumInvitations([0, 1, 2, 3, 4]) == 2", "def test_maximumInvitations():\n    solution = Solution()\n    assert solution.maximumInvitations([1, 0, 2, 3]) == 4"]}
{"task_num": 2132, "task_title": "Stamping the Grid", "func_name": "possibleToStamp", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def possibleToStamp(self, grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:\n    m = len(grid)\n    n = len(grid[0])\n    A = [[0] * (n + 1) for _ in range(m + 1)]\n    B = [[0] * (n + 1) for _ in range(m + 1)]\n    fit = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        A[i + 1][j + 1] = A[i + 1][j] + A[i][j + 1] - A[i][j] + grid[i][j]\n        if i + 1 >= stampHeight and j + 1 >= stampWidth:\n          x = i - stampHeight + 1\n          y = j - stampWidth + 1\n          if A[i + 1][j + 1] - A[x][j + 1] - A[i + 1][y] + A[x][y] == 0:\n            fit[i][j] = True\n\n    for i in range(m):\n      for j in range(n):\n        B[i + 1][j + 1] = B[i + 1][j] + B[i][j + 1] - B[i][j] + fit[i][j]\n\n    for i in range(m):\n      for j in range(n):\n        if not grid[i][j]:\n          x = min(i + stampHeight, m)\n          y = min(j + stampWidth, n)\n          if B[x][y] - B[i][y] - B[x][j] + B[i][j] == 0:\n            return False\n\n    return True\n", "tests": ["def test_possibleToStamp():\n    solution = Solution()\n    grid = [[0, 0, 1], [0, 0, 0], [1, 0, 0]]\n    stampHeight = 2\n    stampWidth = 2\n    assert not solution.possibleToStamp(grid, stampHeight, stampWidth)", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[0, 1], [0, 0]]\n    stampHeight = 2\n    stampWidth = 1\n    assert not solution.possibleToStamp(grid, stampHeight, stampWidth)", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[0, 0], [1, 0]]\n    stampHeight = 1\n    stampWidth = 2\n    assert not solution.possibleToStamp(grid, stampHeight, stampWidth)", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[0, 0], [0, 0]]\n    stampHeight = 1\n    stampWidth = 1\n    assert solution.possibleToStamp(grid, stampHeight, stampWidth)", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[0, 0], [0, 0]]\n    stampHeight = 2\n    stampWidth = 2\n    assert solution.possibleToStamp(grid, stampHeight, stampWidth)", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[0, 1], [0, 0]]\n    stampHeight = 2\n    stampWidth = 1\n    assert not solution.possibleToStamp(grid, stampHeight, stampWidth)", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[0, 0, 1], [0, 0, 0], [0, 0, 0]]\n    stampHeight = 2\n    stampWidth = 3\n    assert not solution.possibleToStamp(grid, stampHeight, stampWidth)", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[0, 0], [0, 1], [0, 0]]\n    stampHeight = 2\n    stampWidth = 1\n    assert not solution.possibleToStamp(grid, stampHeight, stampWidth)", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[0, 1], [0, 0]]\n    stampHeight = 1\n    stampWidth = 2\n    assert not solution.possibleToStamp(grid, stampHeight, stampWidth)", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[0], [1]]\n    stampHeight = 2\n    stampWidth = 1\n    assert not solution.possibleToStamp(grid, stampHeight, stampWidth)", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[0], [0]]\n    stampHeight = 1\n    stampWidth = 2\n    assert not solution.possibleToStamp(grid, stampHeight, stampWidth)", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[0, 1], [0, 0]]\n    stampHeight = 2\n    stampWidth = 2\n    assert not solution.possibleToStamp(grid, stampHeight, stampWidth)", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[0, 1], [0, 0]]\n    stampHeight = 2\n    stampWidth = 3\n    assert not solution.possibleToStamp(grid, stampHeight, stampWidth)", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[0, 1], [0, 0]]\n    stampHeight = 3\n    stampWidth = 2\n    assert not solution.possibleToStamp(grid, stampHeight, stampWidth)", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[0, 1], [0, 0]]\n    stampHeight = 3\n    stampWidth = 2\n    assert not solution.possibleToStamp(grid, stampHeight, stampWidth)", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[0, 1], [0, 0]]\n    stampHeight = 1\n    stampWidth = 3\n    assert not solution.possibleToStamp(grid, stampHeight, stampWidth)", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[0, 0], [1, 0]]\n    stampHeight = 3\n    stampWidth = 2\n    assert not solution.possibleToStamp(grid, stampHeight, stampWidth)", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[0, 1], [0, 0]]\n    stampHeight = 2\n    stampWidth = 1\n    assert not solution.possibleToStamp(grid, stampHeight, stampWidth)", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[0], [0]]\n    stampHeight = 1\n    stampWidth = 1\n    assert solution.possibleToStamp(grid, stampHeight, stampWidth)", "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[0], [1]]\n    stampHeight = 2\n    stampWidth = 1\n    assert not solution.possibleToStamp(grid, stampHeight, stampWidth)"]}
{"task_num": 2146, "task_title": "K Highest Ranked Items Within a Price Range", "func_name": "highestRankedKItems", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    low, high = pricing\n    row, col = start\n    ans = []\n\n    if low <= grid[row][col] <= high:\n      ans.append([row, col])\n      if k == 1:\n        return ans\n\n    q = collections.deque([(row, col)])\n    seen = {(row, col)}\n\n    while q:\n      neighbors = []\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for t in range(4):\n          x = i + dirs[t][0]\n          y = j + dirs[t][1]\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if not grid[x][y] or (x, y) in seen:\n            continue\n          if low <= grid[x][y] <= high:\n            neighbors.append([x, y])\n          q.append((x, y))\n          seen.add((x, y))\n      neighbors.sort(key=lambda x: (grid[x[0]][x[1]], x[0], x[1]))\n      for neighbor in neighbors:\n        if len(ans) < k:\n          ans.append(neighbor)\n        if len(ans) == k:\n          return ans\n\n    return ans\n", "tests": ["def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    pricing = [2, 8]\n    start = [0, 0]\n    k = 4\n    expected_output = [[0, 0], [0, 1], [0, 2], [1, 0]]\n    assert solution.highestRankedKItems(grid, pricing, start, k) == expected_output", "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[10, 2, 3], [4, 5, 6], [7, 8, 9]]\n    pricing = [5, 5]\n    start = [1, 1]\n    k = 3\n    expected_output = [[1, 1]]\n    assert solution.highestRankedKItems(grid, pricing, start, k) == expected_output", "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    pricing = [1, 10]\n    start = [0, 2]\n    k = 2\n    expected_output = [[0, 2], [1, 2]]\n    assert solution.highestRankedKItems(grid, pricing, start, k) == expected_output", "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[0, 1, 2], [3, 4, 5], [6, 7, 8]]\n    pricing = [1, 7]\n    start = [1, 1]\n    k = 1\n    expected_output = [[1, 1]]\n    assert solution.highestRankedKItems(grid, pricing, start, k) == expected_output", "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[1, 2], [3, 4]]\n    pricing = [5, 6]\n    start = [0, 0]\n    k = 3\n    expected_output = []\n    assert solution.highestRankedKItems(grid, pricing, start, k) == expected_output", "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    pricing = [1, 9]\n    start = [0, 0]\n    k = 6\n    expected_output = [[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2]]\n    assert solution.highestRankedKItems(grid, pricing, start, k) == expected_output", "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[1, 2], [3, 4]]\n    pricing = [2, 2]\n    start = [0, 1]\n    k = 1\n    expected_output = [[0, 1]]\n    assert solution.highestRankedKItems(grid, pricing, start, k) == expected_output", "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[10, 2], [3, 4]]\n    pricing = [5, 6]\n    start = [1, 0]\n    k = 2\n    expected_output = [[1, 0], [1, 1]]\n    assert solution.highestRankedKItems(grid, pricing, start, k) == expected_output", "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    pricing = [2, 8]\n    start = [2, 0]\n    k = 4\n    expected_output = [[2, 0], [2, 1], [2, 2], [1, 0]]\n    assert solution.highestRankedKItems(grid, pricing, start, k) == expected_output", "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[1, 2], [3, 0]]\n    pricing = [1, 2]\n    start = [0, 0]\n    k = 1\n    expected_output = [[0, 0]]\n    assert solution.highestRankedKItems(grid, pricing, start, k) == expected_output", "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[1, 2], [3, 4]]\n    pricing = [3, 4]\n    start = [0, 1]\n    k = 1\n    expected_output = [[0, 1]]\n    assert solution.highestRankedKItems(grid, pricing, start, k) == expected_output", "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[10, 2, 3], [4, 5, 6], [7, 8, 9]]\n    pricing = [2, 8]\n    start = [0, 2]\n    k = 3\n    expected_output = [[0, 2], [1, 2], [2, 2]]\n    assert solution.highestRankedKItems(grid, pricing, start, k) == expected_output", "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[1, 2], [3, 4]]\n    pricing = [1, 4]\n    start = [0, 0]\n    k = 2\n    expected_output = [[0, 0], [0, 1]]\n    assert solution.highestRankedKItems(grid, pricing, start, k) == expected_output", "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[10, 2], [3, 4]]\n    pricing = [5, 6]\n    start = [1, 1]\n    k = 1\n    expected_output = [[1, 1]]\n    assert solution.highestRankedKItems(grid, pricing, start, k) == expected_output", "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    pricing = [2, 8]\n    start = [0, 0]\n    k = 4\n    expected_output = [[0, 0], [0, 1], [0, 2], [1, 0]]\n    assert solution.highestRankedKItems(grid, pricing, start, k) == expected_output", "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[1, 2], [3, 0]]\n    pricing = [1, 2]\n    start = [0, 1]\n    k = 2\n    expected_output = [[0, 1], [1, 0]]\n    assert solution.highestRankedKItems(grid, pricing, start, k) == expected_output", "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[10, 2], [3, 4]]\n    pricing = [5, 6]\n    start = [1, 0]\n    k = 2\n    expected_output = [[1, 0], [1, 1]]\n    assert solution.highestRankedKItems(grid, pricing, start, k) == expected_output", "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[1, 2], [3, 4]]\n    pricing = [2, 3]\n    start = [0, 0]\n    k = 2\n    expected_output = [[0, 0], [0, 1]]\n    assert solution.highestRankedKItems(grid, pricing, start, k) == expected_output", "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[10, 2], [3, 4]]\n    pricing = [5, 6]\n    start = [1, 1]\n    k = 1\n    expected_output = [[1, 1]]\n    assert solution.highestRankedKItems(grid, pricing, start, k) == expected_output", "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    pricing = [2, 8]\n    start = [0, 2]\n    k = 3\n    expected_output = [[0, 2], [1, 2], [2, 2]]\n    assert solution.highestRankedKItems(grid, pricing, start, k) == expected_output"]}
{"task_num": 2157, "task_title": "Groups of Strings", "func_name": "groupStrings", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.sz = [1] * n\n\n  def unionBySize(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.sz[i] < self.sz[j]:\n      self.sz[j] += self.sz[i]\n      self.id[i] = j\n    else:\n      self.sz[i] += self.sz[j]\n      self.id[j] = i\n    self.count -= 1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def groupStrings(self, words: List[str]) -> List[int]:\n    uf = UnionFind(len(words))\n\n    def getMask(s: str) -> int:\n      mask = 0\n      for c in s:\n        mask |= 1 << ord(c) - ord('a')\n      return mask\n\n    def getAddedMasks(mask: int):\n      for i in range(26):\n        if not (mask >> i & 1):\n          yield mask | 1 << i\n\n    def getDeletedMasks(mask: int):\n      for i in range(26):\n        if mask >> i & 1:\n          yield mask ^ 1 << i\n\n    maskToIndex = {getMask(word): i for i, word in enumerate(words)}\n    deletedMaskToIndex = {}\n\n    for i, word in enumerate(words):\n      mask = getMask(word)\n      for m in getAddedMasks(mask):\n        if m in maskToIndex:\n          uf.unionBySize(i, maskToIndex[m])\n      for m in getDeletedMasks(mask):\n        if m in maskToIndex:\n          uf.unionBySize(i, maskToIndex[m])\n        if m in deletedMaskToIndex:\n          uf.unionBySize(i, deletedMaskToIndex[m])\n        else:\n          deletedMaskToIndex[m] = i\n\n    return [uf.count, max(uf.sz)]\n", "tests": ["def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['abc', 'ab', 'ac', 'bc', 'b']) == [2, 3]", "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['aaa', 'bbb', 'ccc']) == [1, 3]", "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['abc', 'bcd', 'ace']) == [3, 1]", "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['abc', 'bcd', 'ace', 'bce']) == [3, 2]", "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['abc', 'ab', 'acb']) == [2, 3]", "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['abc', 'bcd', 'ace', 'bce', 'a', 'b', 'c']) == [4, 1]", "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['abc', 'bcd', 'ace', 'bce', 'xyz']) == [5, 1]", "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['abc', 'bcd', 'ace', 'bce', 'a', 'b', 'c', 'd']) == [5, 2]", "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['abc', 'bcd', 'ace', 'bce', 'a', 'b', 'c', 'd', 'e']) == [6, 1]", "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['abc', 'bcd', 'ace', 'bce', 'a', 'b', 'c', 'd', 'e', 'f']) == [7, 1]", "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['abc', 'bcd', 'ace', 'bce', 'a', 'b', 'c', 'd', 'e', 'f', 'g']) == [8, 1]", "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['abc', 'bcd', 'ace', 'bce', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']) == [9, 1]", "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['abc', 'bcd', 'ace', 'bce', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i']) == [10, 1]", "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['abc', 'bcd', 'ace', 'bce', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']) == [11, 1]", "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['abc', 'bcd', 'ace', 'bce', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k']) == [12, 1]", "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['abc', 'bcd', 'ace', 'bce', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l']) == [13, 1]", "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['abc', 'bcd', 'ace', 'bce', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm']) == [14, 1]", "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['abc', 'bcd', 'ace', 'bce', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n']) == [15, 1]", "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['abc', 'bcd', 'ace', 'bce', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o']) == [16, 1]", "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['abc', 'bcd', 'ace', 'bce', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p']) == [17, 1]"]}
{"task_num": 2182, "task_title": "Construct String With Repeat Limit", "func_name": "repeatLimitedString", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\n    ans = ''\n    count = collections.Counter(s)\n\n    while True:\n      addOne = ans and self._shouldAddOne(ans, count)\n      c = self._getLargestChar(ans, count)\n      if c == ' ':\n        break\n      repeats = 1 if addOne else min(count[c], repeatLimit)\n      ans += c * repeats\n      count[c] -= repeats\n\n    return ans\n\n  def _shouldAddOne(self, ans: str, count: collections.Counter) -> bool:\n    for c in reversed(string.ascii_lowercase):\n      if count[c]:\n        return ans[-1] == c\n    return False\n\n  def _getLargestChar(self, ans: str, count: collections.Counter) -> int:\n    for c in reversed(string.ascii_lowercase):\n      if count[c] and (not ans or ans[-1] != c):\n        return c\n    return ' '\n", "tests": ["def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('aabab', 2) == 'abaab'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('aaabbbcccc', 1) == 'abacbac'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('aaabbcc', 2) == 'abacabc'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('aabbccdd', 3) == 'abcdabc'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('aabbcc', 1) == 'abacbac'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('abcde', 1) == 'abcde'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('zzz', 2) == 'zz'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('abcabccba', 2) == 'abacabc'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('aabbccdd', 1) == 'abcd'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('abcabcabc', 3) == 'abcabc'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('aaabbb', 2) == 'ababab'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('abcdefg', 1) == 'abcdefg'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('aabbccdd', 4) == 'abcd'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('aaabbcccddd', 3) == 'abcd'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('aaabbccc', 2) == 'abacabc'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('aaabbcccddd', 2) == 'abacabd'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('aaabbccddd', 4) == 'abcd'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('abcabcabc', 1) == 'abcaabc'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('aaaabbcc', 2) == 'abacaba'", "def test_repeatLimitedString():\n    solution = Solution()\n    assert solution.repeatLimitedString('abcde', 2) == 'aebcda'"]}
{"task_num": 2203, "task_title": "Minimum Weighted Subgraph With the Required Paths", "func_name": "minimumWeight", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\n    graph = [[] for _ in range(n)]\n    reversedGraph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      reversedGraph[v].append((u, w))\n\n    fromSrc1 = self._dijkstra(graph, src1)\n    fromSrc2 = self._dijkstra(graph, src2)\n    fromDest = self._dijkstra(reversedGraph, dest)\n    minWeight = min(a + b + c for a, b, c in zip(fromSrc1, fromSrc2, fromDest))\n    if minWeight == math.inf:\n      return -1\n    else:\n      return minWeight\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int) -> List[int]:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist\n", "tests": ["def test_minimumWeight():\n    solution = Solution()\n    assert solution.minimumWeight(6, [[0, 1, 2], [0, 2, 4], [1, 3, 1], [2, 3, 1], [3, 4, 10], [4, 5, 3]], 0, 1, 5) == 9", "def test_minimumWeight():\n    solution = Solution()\n    assert solution.minimumWeight(4, [[0, 1, 2], [1, 2, 3], [2, 3, 1]], 0, 1, 2) == 6", "def test_minimumWeight():\n    solution = Solution()\n    assert solution.minimumWeight(5, [[0, 1, 1], [1, 2, 2], [3, 2, 1], [4, 2, 1]], 0, 3, 4) == 4", "def test_minimumWeight():\n    solution = Solution()\n    assert solution.minimumWeight(3, [[0, 1, 10], [1, 2, 5]], 0, 1, 2) == -1", "def test_minimumWeight():\n    solution = Solution()\n    assert solution.minimumWeight(4, [[0, 1, 3], [0, 2, 2], [1, 2, 1], [2, 3, 4]], 0, 2, 3) == 5", "def test_minimumWeight():\n    solution = Solution()\n    assert solution.minimumWeight(7, [[0, 1, 2], [1, 2, 4], [1, 3, 1], [3, 4, 1], [4, 5, 3], [6, 5, 2]], 0, 1, 6) == 8", "def test_minimumWeight():\n    solution = Solution()\n    assert solution.minimumWeight(5, [[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5]], 0, 2, 4) == 9", "def test_minimumWeight():\n    solution = Solution()\n    assert solution.minimumWeight(3, [[0, 1, 100], [1, 2, 1]], 0, 1, 2) == -1", "def test_minimumWeight():\n    solution = Solution()\n    assert solution.minimumWeight(5, [[0, 1, 1], [1, 2, 1], [2, 3, 1], [3, 4, 1]], 0, 2, 4) == 3", "def test_minimumWeight():\n    solution = Solution()\n    assert solution.minimumWeight(6, [[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6]], 0, 2, 5) == 9", "def test_minimumWeight():\n    solution = Solution()\n    assert solution.minimumWeight(4, [[0, 1, 1], [1, 2, 2], [2, 3, 1]], 0, 0, 3) == 6", "def test_minimumWeight():\n    solution = Solution()\n    assert solution.minimumWeight(5, [[0, 1, 3], [1, 2, 4], [2, 3, 1], [3, 4, 7]], 0, 1, 4) == 18", "def test_minimumWeight():\n    solution = Solution()\n    assert solution.minimumWeight(7, [[0, 1, 2], [1, 2, 3], [1, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7]], 0, 1, 6) == 18", "def test_minimumWeight():\n    solution = Solution()\n    assert solution.minimumWeight(5, [[0, 1, 2], [1, 3, 4], [3, 4, 6]], 0, 1, 4) == 12", "def test_minimumWeight():\n    solution = Solution()\n    assert solution.minimumWeight(5, [[0, 1, 1], [1, 2, 1], [2, 3, 1], [3, 4, 1]], 0, 3, 4) == 3", "def test_minimumWeight():\n    solution = Solution()\n    assert solution.minimumWeight(5, [[0, 1, 10], [1, 2, 2], [2, 3, 1], [3, 4, 1]], 0, 1, 2) == 14", "def test_minimumWeight():\n    solution = Solution()\n    assert solution.minimumWeight(6, [[0, 1, 2], [1, 3, 4], [3, 5, 6]], 0, 1, 5) == -1", "def test_minimumWeight():\n    solution = Solution()\n    assert solution.minimumWeight(7, [[0, 1, 2], [1, 2, 3], [1, 3, 4], [3, 4, 5], [4, 5, 6], [5, 0, 1]], 0, 1, 5) == 9", "def test_minimumWeight():\n    solution = Solution()\n    assert solution.minimumWeight(6, [[0, 1, 2], [1, 2, 3], [2, 4, 5], [4, 3, 1]], 0, 1, 3) == 11", "def test_minimumWeight():\n    solution = Solution()\n    assert solution.minimumWeight(4, [[0, 1, 1], [1, 2, 2], [2, 3, 3]], 0, 2, 3) == 6"]}
{"task_num": 2242, "task_title": "Maximum Score of a Node Sequence", "func_name": "maximumScore", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\n    n = len(scores)\n    ans = -1\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append((scores[v], v))\n      graph[v].append((scores[u], u))\n\n    for i in range(n):\n      graph[i] = heapq.nlargest(3, graph[i])\n\n    for u, v in edges:\n      for scoreA, a in graph[u]:\n        for scoreB, b in graph[v]:\n          if a != b and a != v and b != u:\n            ans = max(ans, scoreA + scores[u] + scores[v] + scoreB)\n\n    return ans\n", "tests": ["def test_maximumScore():\n    solution = Solution()\n    scores = [5, 2, 9, 8, 3]\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4]]\n    assert solution.maximumScore(scores, edges) == 26", "def test_maximumScore():\n    solution = Solution()\n    scores = [10, 5, 2, 7, 8]\n    edges = [[0, 1], [0, 3], [1, 2], [3, 4]]\n    assert solution.maximumScore(scores, edges) == 39", "def test_maximumScore():\n    solution = Solution()\n    scores = [3, 4, 5, 6, 7]\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4]]\n    assert solution.maximumScore(scores, edges) == 28", "def test_maximumScore():\n    solution = Solution()\n    scores = [1, 1, 1, 1, 1]\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4]]\n    assert solution.maximumScore(scores, edges) == 4", "def test_maximumScore():\n    solution = Solution()\n    scores = [8, 5, 7, 3, 6]\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4]]\n    assert solution.maximumScore(scores, edges) == 36", "def test_maximumScore():\n    solution = Solution()\n    scores = [2, 2, 2, 2, 2]\n    edges = [[0, 1], [1, 3], [1, 4]]\n    assert solution.maximumScore(scores, edges) == -1", "def test_maximumScore():\n    solution = Solution()\n    scores = [5, 4, 3, 2, 1]\n    edges = [[0, 1], [1, 2], [2, 3]]\n    assert solution.maximumScore(scores, edges) == -1", "def test_maximumScore():\n    solution = Solution()\n    scores = [7, 6, 5, 4, 3]\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4]]\n    assert solution.maximumScore(scores, edges) == 30", "def test_maximumScore():\n    solution = Solution()\n    scores = [1, 2, 3, 4, 5]\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4]]\n    assert solution.maximumScore(scores, edges) == 19", "def test_maximumScore():\n    solution = Solution()\n    scores = [5, 7, 3, 4, 6]\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4]]\n    assert solution.maximumScore(scores, edges) == 34", "def test_maximumScore():\n    solution = Solution()\n    scores = [2, 4, 6, 8, 10]\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4]]\n    assert solution.maximumScore(scores, edges) == 36", "def test_maximumScore():\n    solution = Solution()\n    scores = [10, 9, 8, 7, 6]\n    edges = [[0, 1], [1, 2], [2, 3]]\n    assert solution.maximumScore(scores, edges) == -1", "def test_maximumScore():\n    solution = Solution()\n    scores = [10, 8, 6, 4, 2]\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4]]\n    assert solution.maximumScore(scores, edges) == 30", "def test_maximumScore():\n    solution = Solution()\n    scores = [1, 2, 3, 4, 5]\n    edges = [[0, 2], [1, 3], [2, 4]]\n    assert solution.maximumScore(scores, edges) == -1", "def test_maximumScore():\n    solution = Solution()\n    scores = [5, 5, 5, 5, 5]\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4]]\n    assert solution.maximumScore(scores, edges) == 25", "def test_maximumScore():\n    solution = Solution()\n    scores = [9, 8, 7, 6, 5]\n    edges = [[0, 1], [1, 2], [2, 3]]\n    assert solution.maximumScore(scores, edges) == -1", "def test_maximumScore():\n    solution = Solution()\n    scores = [2, 4, 6, 8, 10]\n    edges = [[0, 3], [1, 2], [2, 4]]\n    assert solution.maximumScore(scores, edges) == -1", "def test_maximumScore():\n    solution = Solution()\n    scores = [10, 5, 2, 7, 8]\n    edges = [[0, 1], [1, 2], [2, 3], [4, 0]]\n    assert solution.maximumScore(scores, edges) == -1", "def test_maximumScore():\n    solution = Solution()\n    scores = [5, 3, 7, 4, 6]\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4]]\n    assert solution.maximumScore(scores, edges) == 26", "def test_maximumScore():\n    solution = Solution()\n    scores = [10, 9, 8, 7, 6]\n    edges = [[0, 2], [1, 3], [2, 4]]\n    assert solution.maximumScore(scores, edges) == -1"]}
{"task_num": 2245, "task_title": "Maximum Trailing Zeros in a Cornered Path", "func_name": "maxTrailingZeros", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxTrailingZeros(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    leftPrefix2 = [[0] * n for _ in range(m)]\n    leftPrefix5 = [[0] * n for _ in range(m)]\n    topPrefix2 = [[0] * n for _ in range(m)]\n    topPrefix5 = [[0] * n for _ in range(m)]\n\n    def getCount(num: int, factor: int) -> int:\n      count = 0\n      while num % factor == 0:\n        num //= factor\n        count += 1\n      return count\n\n    for i in range(m):\n      for j in range(n):\n        leftPrefix2[i][j] = getCount(grid[i][j], 2)\n        leftPrefix5[i][j] = getCount(grid[i][j], 5)\n        if j:\n          leftPrefix2[i][j] += leftPrefix2[i][j - 1]\n          leftPrefix5[i][j] += leftPrefix5[i][j - 1]\n\n    for j in range(n):\n      for i in range(m):\n        topPrefix2[i][j] = getCount(grid[i][j], 2)\n        topPrefix5[i][j] = getCount(grid[i][j], 5)\n        if i:\n          topPrefix2[i][j] += topPrefix2[i - 1][j]\n          topPrefix5[i][j] += topPrefix5[i - 1][j]\n\n    ans = 0\n    for i in range(m):\n      for j in range(n):\n        curr2 = getCount(grid[i][j], 2)\n        curr5 = getCount(grid[i][j], 5)\n        l2 = leftPrefix2[i][j]\n        l5 = leftPrefix5[i][j]\n        r2 = leftPrefix2[i][n - 1] - (0 if j == 0 else leftPrefix2[i][j - 1])\n        r5 = leftPrefix5[i][n - 1] - (0 if j == 0 else leftPrefix5[i][j - 1])\n        t2 = topPrefix2[i][j]\n        t5 = topPrefix5[i][j]\n        d2 = topPrefix2[m - 1][j] - (0 if i == 0 else topPrefix2[i - 1][j])\n        d5 = topPrefix5[m - 1][j] - (0 if i == 0 else topPrefix5[i - 1][j])\n        ans = max(ans, min(l2 + t2 - curr2, l5 + t5 - curr5), min(r2 + t2 - curr2, r5 + t5 - curr5), min(l2 + d2 - curr2, l5 + d5 - curr5), min(r2 + d2 - curr2, r5 + d5 - curr5))\n\n    return ans\n", "tests": ["def test_maxTrailingZeros():\n    solution = Solution()\n    grid = [[2, 5], [10, 4]]\n    assert solution.maxTrailingZeros(grid) == 4", "def test_maxTrailingZeros():\n    solution = Solution()\n    grid = [[20, 15], [4, 3]]\n    assert solution.maxTrailingZeros(grid) == 4", "def test_maxTrailingZeros():\n    solution = Solution()\n    grid = [[2, 5], [10, 8]]\n    assert solution.maxTrailingZeros(grid) == 4", "def test_maxTrailingZeros():\n    solution = Solution()\n    grid = [[1, 2], [4, 8]]\n    assert solution.maxTrailingZeros(grid) == 0", "def test_maxTrailingZeros():\n    solution = Solution()\n    grid = [[25, 2], [5, 10]]\n    assert solution.maxTrailingZeros(grid) == 4", "def test_maxTrailingZeros():\n    solution = Solution()\n    grid = [[1, 3], [5, 2]]\n    assert solution.maxTrailingZeros(grid) == 0", "def test_maxTrailingZeros():\n    solution = Solution()\n    grid = [[2, 3], [4, 5]]\n    assert solution.maxTrailingZeros(grid) == 1", "def test_maxTrailingZeros():\n    solution = Solution()\n    grid = [[100, 5], [20, 2]]\n    assert solution.maxTrailingZeros(grid) == 4", "def test_maxTrailingZeros():\n    solution = Solution()\n    grid = [[16, 25], [40, 8]]\n    assert solution.maxTrailingZeros(grid) == 5", "def test_maxTrailingZeros():\n    solution = Solution()\n    grid = [[1, 2], [3, 5]]\n    assert solution.maxTrailingZeros(grid) == 0", "def test_maxTrailingZeros():\n    solution = Solution()\n    grid = [[2, 5], [10, 4]]\n    assert solution.maxTrailingZeros(grid) == 4", "def test_maxTrailingZeros():\n    solution = Solution()\n    grid = [[12, 5], [10, 8]]\n    assert solution.maxTrailingZeros(grid) == 4", "def test_maxTrailingZeros():\n    solution = Solution()\n    grid = [[2, 3], [4, 5]]\n    assert solution.maxTrailingZeros(grid) == 1", "def test_maxTrailingZeros():\n    solution = Solution()\n    grid = [[25, 2], [5, 10]]\n    assert solution.maxTrailingZeros(grid) == 4", "def test_maxTrailingZeros():\n    solution = Solution()\n    grid = [[100, 5], [20, 2]]\n    assert solution.maxTrailingZeros(grid) == 4", "def test_maxTrailingZeros():\n    solution = Solution()\n    grid = [[16, 25], [40, 8]]\n    assert solution.maxTrailingZeros(grid) == 5", "def test_maxTrailingZeros():\n    solution = Solution()\n    grid = [[1, 2], [3, 5]]\n    assert solution.maxTrailingZeros(grid) == 0", "def test_maxTrailingZeros():\n    solution = Solution()\n    grid = [[2, 5], [10, 4]]\n    assert solution.maxTrailingZeros(grid) == 4", "def test_maxTrailingZeros():\n    solution = Solution()\n    grid = [[12, 5], [10, 8]]\n    assert solution.maxTrailingZeros(grid) == 4", "def test_maxTrailingZeros():\n    solution = Solution()\n    grid = [[2, 3], [4, 5]]\n    assert solution.maxTrailingZeros(grid) == 1"]}
{"task_num": 2257, "task_title": "Count Unguarded Cells in the Grid", "func_name": "countUnguarded", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\n    ans = 0\n    grid = [[0] * n for _ in range(m)]\n    left = [[0] * n for _ in range(m)]\n    right = [[0] * n for _ in range(m)]\n    up = [[0] * n for _ in range(m)]\n    down = [[0] * n for _ in range(m)]\n\n    for row, col in guards:\n      grid[row][col] = 'G'\n\n    for row, col in walls:\n      grid[row][col] = 'W'\n\n    for i in range(m):\n      lastCell = 0\n      for j in range(n):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          left[i][j] = lastCell\n      lastCell = 0\n      for j in range(n - 1, -1, -1):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          right[i][j] = lastCell\n\n    for j in range(n):\n      lastCell = 0\n      for i in range(m):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          up[i][j] = lastCell\n      lastCell = 0\n      for i in range(m - 1, -1, -1):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          down[i][j] = lastCell\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 0 and left[i][j] != 'G' and right[i][j] != 'G' and up[i][j] != 'G' and down[i][j] != 'G':\n          ans += 1\n\n    return ans\n", "tests": ["def test_countUnguarded():\n    solution = Solution()\n    assert solution.countUnguarded(4, 6, [[0, 0], [1, 1], [2, 2]], [[3, 3], [3, 4]]) == 9", "def test_countUnguarded():\n    solution = Solution()\n    assert solution.countUnguarded(3, 3, [[1, 0]], [[0, 1], [2, 1]]) == 1", "def test_countUnguarded():\n    solution = Solution()\n    assert solution.countUnguarded(2, 4, [[0, 3], [1, 0]], [[0, 1], [1, 3]]) == 0", "def test_countUnguarded():\n    solution = Solution()\n    assert solution.countUnguarded(5, 5, [[0, 2], [4, 2]], [[1, 1], [3, 3]]) == 8", "def test_countUnguarded():\n    solution = Solution()\n    assert solution.countUnguarded(1, 1, [[0, 0]], []) == 0", "def test_countUnguarded():\n    solution = Solution()\n    assert solution.countUnguarded(3, 5, [[0, 1], [2, 4]], [[1, 0], [1, 2]]) == 8", "def test_countUnguarded():\n    solution = Solution()\n    assert solution.countUnguarded(4, 3, [[0, 2], [1, 1]], [[2, 1]]) == 5", "def test_countUnguarded():\n    solution = Solution()\n    assert solution.countUnguarded(5, 4, [[2, 0], [2, 3]], [[1, 1], [3, 1]]) == 6", "def test_countUnguarded():\n    solution = Solution()\n    assert solution.countUnguarded(2, 3, [[0, 1], [1, 0]], [[0, 0], [1, 2]]) == 0", "def test_countUnguarded():\n    solution = Solution()\n    assert solution.countUnguarded(3, 4, [[0, 2], [1, 1]], [[0, 1], [2, 3]]) == 6", "def test_countUnguarded():\n    solution = Solution()\n    assert solution.countUnguarded(1, 5, [[0, 2]], []) == 3", "def test_countUnguarded():\n    solution = Solution()\n    assert solution.countUnguarded(6, 6, [[2, 2]], [[1, 2], [3, 2]]) == 24", "def test_countUnguarded():\n    solution = Solution()\n    assert solution.countUnguarded(7, 7, [[3, 3]], [[2, 2], [4, 4]]) == 36", "def test_countUnguarded():\n    solution = Solution()\n    assert solution.countUnguarded(4, 4, [[0, 1], [2, 3]], [[1, 0], [3, 2]]) == 4", "def test_countUnguarded():\n    solution = Solution()\n    assert solution.countUnguarded(5, 5, [[0, 2], [4, 2]], [[1, 1], [3, 3], [2, 0]]) == 9", "def test_countUnguarded():\n    solution = Solution()\n    assert solution.countUnguarded(3, 3, [[0, 1], [2, 1]], []) == 5", "def test_countUnguarded():\n    solution = Solution()\n    assert solution.countUnguarded(2, 5, [[0, 0], [1, 4]], [[0, 2]]) == 8", "def test_countUnguarded():\n    solution = Solution()\n    assert solution.countUnguarded(4, 3, [[0, 2], [1, 1]], [[0, 1], [2, 2]]) == 5", "def test_countUnguarded():\n    solution = Solution()\n    assert solution.countUnguarded(5, 4, [[2, 0], [2, 3]], []) == 16", "def test_countUnguarded():\n    solution = Solution()\n    assert solution.countUnguarded(3, 5, [[0, 1], [2, 4]], []) == 7"]}
{"task_num": 2258, "task_title": "Escape the Spreading Fire", "func_name": "maximumMinutes", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumMinutes(self, grid: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    kMax = len(grid) * len(grid[0])\n    fireGrid = [[-1] * len(grid[0]) for _ in range(len(grid))]\n    self._buildFireGrid(grid, fireGrid, dirs)\n\n    ans = -1\n    l = 0\n    r = kMax\n\n    while l <= r:\n      m = (l + r) // 2\n      if self._canStayFor(grid, fireGrid, m, dirs):\n        ans = m\n        l = m + 1\n      else:\n        r = m - 1\n\n    return int(1e9) if ans == kMax else ans\n\n  def _buildFireGrid(self, grid: List[List[int]], fireMinute: List[List[int]], dirs: List[int]) -> None:\n    minuteFromFire = 0\n    q = collections.deque()\n\n    for i in range(len(grid)):\n      for j in range(len(grid[0])):\n        if grid[i][j] == 1:\n          q.append((i, j))\n          fireMinute[i][j] = 0\n    while q:\n      minuteFromFire += 1\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == len(grid) or y < 0 or y == len(grid[0]):\n            continue\n          if grid[x][y] == 2:\n            continue\n          if fireMinute[x][y] != -1:\n            continue\n          fireMinute[x][y] = minuteFromFire\n          q.append((x, y))\n\n  def _canStayFor(self, grid: List[List[int]], fireMinute: List[List[int]], minute: int, dirs: List[int]) -> bool:\n    q = collections.deque([(0, 0)])\n    seen = {(0, 0)}\n\n    while q:\n      minute += 1\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == len(grid) or y < 0 or y == len(grid[0]):\n            continue\n          if grid[x][y] == 2:\n            continue\n          if x == len(grid) - 1 and y == len(grid[0]) - 1:\n            if fireMinute[x][y] != -1 and fireMinute[x][y] < minute:\n              continue\n            return True\n          if fireMinute[x][y] != -1 and fireMinute[x][y] <= minute:\n            continue\n          if (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n\n    return False\n", "tests": ["def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 1, 0], [0, 2, 0]]\n    assert solution.maximumMinutes(grid) == 3", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 0, 1], [0, 2, 0], [0, 0, 0]]\n    assert solution.maximumMinutes(grid) == -1", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 0, 0], [1, 2, 0], [0, 0, 0]]\n    assert solution.maximumMinutes(grid) == 0", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 2, 0], [0, 0, 0, 0]]\n    assert solution.maximumMinutes(grid) == 3", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 0, 1], [2, 2, 1], [1, 2, 0]]\n    assert solution.maximumMinutes(grid) == -1", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 0, 1], [0, 2, 0], [1, 0, 0]]\n    assert solution.maximumMinutes(grid) == -1", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 0, 1], [0, 0, 0], [2, 2, 0]]\n    assert solution.maximumMinutes(grid) == 3", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 1, 0], [2, 2, 0], [0, 0, 0]]\n    assert solution.maximumMinutes(grid) == -1", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 0, 0], [1, 2, 0], [0, 0, 2]]\n    assert solution.maximumMinutes(grid) == -1", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 0, 0], [1, 2, 0], [0, 0, 0]]\n    assert solution.maximumMinutes(grid) == -1", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 0, 0], [1, 0, 0], [2, 0, 0]]\n    assert solution.maximumMinutes(grid) == 2", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 0, 1], [0, 2, 0], [0, 0, 0]]\n    assert solution.maximumMinutes(grid) == -1", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 1, 0], [2, 2, 0], [0, 0, 0]]\n    assert solution.maximumMinutes(grid) == -1", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 0, 1], [2, 2, 0], [0, 0, 0]]\n    assert solution.maximumMinutes(grid) == -1", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 0, 1], [2, 0, 0], [0, 2, 0]]\n    assert solution.maximumMinutes(grid) == -1", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 0, 1], [2, 0, 0], [0, 0, 0]]\n    assert solution.maximumMinutes(grid) == -1", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 0, 1], [2, 0, 0], [2, 2, 0]]\n    assert solution.maximumMinutes(grid) == -1", "", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 0, 1], [2, 0, 0], [0, 0, 0]]\n    assert solution.maximumMinutes(grid) == -1", "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 0, 1], [2, 0, 0], [0, 0, 0]]\n    assert solution.maximumMinutes(grid) == -1"]}
{"task_num": 2290, "task_title": "Minimum Obstacle Removal to Reach Corner", "func_name": "minimumObstacles", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumObstacles(self, grid: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    minHeap = [(grid[0][0], 0, 0)]  # (d, i, j)\n    dist = [[math.inf] * n for _ in range(m)]\n    dist[0][0] = grid[0][0]\n\n    while minHeap:\n      d, i, j = heapq.heappop(minHeap)\n      if i == m - 1 and j == n - 1:\n        return d\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        newDist = d + grid[i][j]\n        if newDist < dist[x][y]:\n          dist[x][y] = newDist\n          heapq.heappush(minHeap, (newDist, x, y))\n\n    return dist[m - 1][n - 1]\n", "tests": ["def test_minimumObstacles():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n    assert solution.minimumObstacles(grid) == 0", "def test_minimumObstacles():\n    solution = Solution()\n    grid = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]\n    assert solution.minimumObstacles(grid) == 2", "def test_minimumObstacles():\n    solution = Solution()\n    grid = [[1, 0], [0, 1]]\n    assert solution.minimumObstacles(grid) == 2", "def test_minimumObstacles():\n    solution = Solution()\n    grid = [[0, 1], [1, 0]]\n    assert solution.minimumObstacles(grid) == 2", "def test_minimumObstacles():\n    solution = Solution()\n    grid = [[0] * 10 for _ in range(10)]\n    assert solution.minimumObstacles(grid) == 0", "def test_minimumObstacles():\n    solution = Solution()\n    grid = [[1] * 5 for _ in range(5)]\n    assert solution.minimumObstacles(grid) == 24", "def test_minimumObstacles():\n    solution = Solution()\n    grid = [[0, 1, 0], [1, 0, 1], [0, 1, 0]]\n    assert solution.minimumObstacles(grid) == 2", "def test_minimumObstacles():\n    solution = Solution()\n    grid = [[0, 1, 0], [0, 0, 1], [0, 1, 0]]\n    assert solution.minimumObstacles(grid) == 2", "def test_minimumObstacles():\n    solution = Solution()\n    grid = [[1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0]]\n    assert solution.minimumObstacles(grid) == 4", "def test_minimumObstacles():\n    solution = Solution()\n    grid = [[1, 0, 1], [1, 1, 1], [1, 0, 1]]\n    assert solution.minimumObstacles(grid) == 4", "def test_minimumObstacles():\n    solution = Solution()\n    grid = [[0, 1], [1, 0]]\n    assert solution.minimumObstacles(grid) == 2", "def test_minimumObstacles():\n    solution = Solution()\n    grid = [[1, 0], [0, 1]]\n    assert solution.minimumObstacles(grid) == 2", "def test_minimumObstacles():\n    solution = Solution()\n    grid = [[0, 1, 0], [1, 0, 1], [0, 1, 0]]\n    assert solution.minimumObstacles(grid) == 2", "def test_minimumObstacles():\n    solution = Solution()\n    grid = [[0, 1, 0], [0, 1, 0], [0, 1, 0]]\n    assert solution.minimumObstacles(grid) == 2", "def test_minimumObstacles():\n    solution = Solution()\n    grid = [[1, 0], [0, 1]]\n    assert solution.minimumObstacles(grid) == 2", "def test_minimumObstacles():\n    solution = Solution()\n    grid = [[0, 1], [1, 0]]\n    assert solution.minimumObstacles(grid) == 2", "def test_minimumObstacles():\n    solution = Solution()\n    grid = [[0, 1, 0], [1, 0, 1], [0, 1, 0]]\n    assert solution.minimumObstacles(grid) == 2", "def test_minimumObstacles():\n    solution = Solution()\n    grid = [[0, 1], [1, 0]]\n    assert solution.minimumObstacles(grid) == 2", "def test_minimumObstacles():\n    solution = Solution()\n    grid = [[1, 0], [0, 1]]\n    assert solution.minimumObstacles(grid) == 2", "def test_minimumObstacles():\n    solution = Solution()\n    grid = [[0, 1, 0], [0, 1, 0], [0, 1, 0]]\n    assert solution.minimumObstacles(grid) == 2"]}
{"task_num": 2299, "task_title": "Strong Password Checker II", "func_name": "strongPasswordCheckerII", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def strongPasswordCheckerII(self, password: str) -> bool:\n    if len(password) < 8:\n      return False\n    if not any(c.islower() for c in password):\n      return False\n    if not any(c.isupper() for c in password):\n      return False\n    if not any(c.isdigit() for c in password):\n      return False\n    if not any(\"!@#$%^&*()-+\".find(c) != -1 for c in password):\n      return False\n    return all(a != b for a, b in zip(password, password[1:]))\n", "tests": ["def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert solution.strongPasswordCheckerII('Abc123!@#') == True, 'Test case 1 failed'", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert solution.strongPasswordCheckerII('Abc123!!') == False, 'Test case 2 failed'", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert solution.strongPasswordCheckerII('Abc1234') == False, 'Test case 3 failed'", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert solution.strongPasswordCheckerII('Aa!1234') == False, 'Test case 4 failed'", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert solution.strongPasswordCheckerII('Abc!123a') == True, 'Test case 5 failed'", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert solution.strongPasswordCheckerII('12345678') == False, 'Test case 6 failed'", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert solution.strongPasswordCheckerII('abcdefg!') == False, 'Test case 7 failed'", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert solution.strongPasswordCheckerII('Abc123!@#A') == True, 'Test case 8 failed'", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert solution.strongPasswordCheckerII('Abc123!@#Aa') == True, 'Test case 9 failed'", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert solution.strongPasswordCheckerII('Abc123!@#AaB') == True, 'Test case 10 failed'", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert solution.strongPasswordCheckerII('Abc123!@#AaBb') == True, 'Test case 11 failed'", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert solution.strongPasswordCheckerII('Abc123!@#AaBbC') == True, 'Test case 12 failed'", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert solution.strongPasswordCheckerII('Abc123!@#AaBbC1') == True, 'Test case 13 failed'", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert solution.strongPasswordCheckerII('Abc123!@#AaBbC12') == True, 'Test case 14 failed'", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert solution.strongPasswordCheckerII('Abc123!@#AaBbC12!') == True, 'Test case 15 failed'", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert solution.strongPasswordCheckerII('Aa1!') == False, 'Test case 16 failed'", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert solution.strongPasswordCheckerII('Abc123!@#AaBbC12!') == True, 'Test case 15 failed'", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert solution.strongPasswordCheckerII('Aa1!Aa') == True, 'Test case 17 failed'", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert solution.strongPasswordCheckerII('Aa1!AaBb') == True, 'Test case 18 failed'", "def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert solution.strongPasswordCheckerII('Aa1!AaBbCc') == True, 'Test case 19 failed'"]}
{"task_num": 2301, "task_title": "Match Substring After Replacement", "func_name": "matchReplacement", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def matchReplacement(self, s: str, sub: str, mappings: List[List[str]]) -> bool:\n    isMapped = [[False] * 128 for _ in range(128)]\n\n    for old, new in mappings:\n      isMapped[ord(old)][ord(new)] = True\n\n    for i in range(len(s)):\n      if self._canTransform(s, i, sub, isMapped):\n        return True\n\n    return False\n\n  def _canTransform(self, s: str, start: int, sub: str, isMapped: List[List[bool]]) -> bool:\n    if start + len(sub) > len(s):\n      return False\n\n    for i in range(len(sub)):\n      a = sub[i]\n      b = s[start + i]\n      if a != b and not isMapped[ord(a)][ord(b)]:\n        return False\n\n    return True\n", "tests": ["def test_matchReplacement():\n    solution = Solution()\n    assert solution.matchReplacement('abcd', 'ab', [['a', 'b']]) == False", "def test_matchReplacement():\n    solution = Solution()\n    assert solution.matchReplacement('abcde', 'cde', [['a', 'b'], ['c', 'd']]) == True", "def test_matchReplacement():\n    solution = Solution()\n    assert solution.matchReplacement('abcde', 'cda', [['a', 'b'], ['c', 'd']]) == False", "def test_matchReplacement():\n    solution = Solution()\n    assert solution.matchReplacement('abcde', 'ab', [['a', 'b'], ['c', 'd']]) == False", "def test_matchReplacement():\n    solution = Solution()\n    assert solution.matchReplacement('abcde', 'ab', [['a', 'b'], ['d', 'c']]) == False", "def test_matchReplacement():\n    solution = Solution()\n    assert solution.matchReplacement('abcde', 'cd', [['a', 'b'], ['c', 'd']]) == True", "def test_matchReplacement():\n    solution = Solution()\n    assert solution.matchReplacement('abcde', 'ad', [['a', 'b'], ['d', 'c']]) == False", "def test_matchReplacement():\n    solution = Solution()\n    assert solution.matchReplacement('abcde', 'abcd', [['a', 'b'], ['c', 'd']]) == False", "def test_matchReplacement():\n    solution = Solution()\n    assert solution.matchReplacement('abcde', 'efg', [['a', 'b'], ['c', 'd']]) == False", "def test_matchReplacement():\n    solution = Solution()\n    assert solution.matchReplacement('abcde', 'ab', [['a', 'b'], ['e', 'd']]) == False", "def test_matchReplacement():\n    solution = Solution()\n    assert solution.matchReplacement('abcde', 'ab', [['a', 'b'], ['d', 'e']]) == True", "def test_matchReplacement():\n    solution = Solution()\n    assert solution.matchReplacement('abcde', 'ab', [['a', 'b'], ['c', 'f']]) == False", "def test_matchReplacement():\n    solution = Solution()\n    assert solution.matchReplacement('abcde', 'ab', [['a', 'b'], ['d', 'c']]) == False", "def test_matchReplacement():\n    solution = Solution()\n    assert solution.matchReplacement('abcde', 'ab', [['a', 'b'], ['d', 'c']]) == False", "def test_matchReplacement():\n    solution = Solution()\n    assert solution.matchReplacement('abcde', 'ab', [['a', 'b'], ['d', 'c']]) == False", "def test_matchReplacement():\n    solution = Solution()\n    assert solution.matchReplacement('abcde', 'ab', [['a', 'b'], ['c', 'f']]) == False", "def test_matchReplacement():\n    solution = Solution()\n    assert solution.matchReplacement('abcde', 'ab', [['a', 'b'], ['d', 'c']]) == False", "def test_matchReplacement():\n    solution = Solution()\n    assert solution.matchReplacement('abcde', 'ab', [['a', 'b'], ['c', 'f']]) == False", "def test_matchReplacement():\n    solution = Solution()\n    assert solution.matchReplacement('abcde', 'ab', [['a', 'b'], ['d', 'c']]) == False", "def test_matchReplacement():\n    solution = Solution()\n    assert solution.matchReplacement('abcde', 'ab', [['a', 'b'], ['c', 'f']]) == False"]}
{"task_num": 2322, "task_title": "Minimum Score After Removals on a Tree", "func_name": "minimumScore", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Set\n\nclass Solution:\n  def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\n    n = len(nums)\n    xors = functools.reduce(lambda x, y: x ^ y, nums)\n    subXors = nums[:]\n    tree = [[] for _ in range(n)]\n    children = [{i} for i in range(n)]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, parent: int) -> Tuple[int, Set[int]]:\n      for v in tree[u]:\n        if v == parent:\n          continue\n        vXor, vChildren = dfs(v, u)\n        subXors[u] ^= vXor\n        children[u] |= vChildren\n      return subXors[u], children[u]\n\n    dfs(0, -1)\n\n    ans = math.inf\n    for i in range(len(edges)):\n      a, b = edges[i]\n      if b in children[a]:\n        a, b = b, a\n      for j in range(i):\n        c, d = edges[j]\n        if d in children[c]:\n          c, d = d, c\n\n        if c in children[a] and a != c:\n          cands = [subXors[c], subXors[a] ^ subXors[c], xors ^ subXors[a]]\n        elif a in children[c] and a != c:\n          cands = [subXors[a], subXors[c] ^ subXors[a], xors ^ subXors[c]]\n        else:\n          cands = [subXors[a], subXors[c], xors ^ subXors[a] ^ subXors[c]]\n        ans = min(ans, max(cands) - min(cands))\n\n    return ans\n", "tests": ["def test_minimumScore():\n    solution = Solution()\n    nums = [1, 2, 3, 4]\n    edges = [[0, 1], [1, 2], [2, 3]]\n    assert solution.minimumScore(nums, edges) == 1", "def test_minimumScore():\n    solution = Solution()\n    nums = [8, 4, 2, 10, 6]\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4]]\n    assert solution.minimumScore(nums, edges) == 4", "def test_minimumScore():\n    solution = Solution()\n    nums = [2, 4, 6, 8]\n    edges = [[0, 1], [1, 2], [2, 3]]\n    assert solution.minimumScore(nums, edges) == 0", "def test_minimumScore():\n    solution = Solution()\n    nums = [1, 2, 3, 4, 5]\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4]]\n    assert solution.minimumScore(nums, edges) == 1", "def test_minimumScore():\n    solution = Solution()\n    nums = [5, 5, 5, 5]\n    edges = [[0, 1], [1, 2], [2, 3]]\n    assert solution.minimumScore(nums, edges) == 0", "def test_minimumScore():\n    solution = Solution()\n    nums = [10 ** 9, 2 * 10 ** 9, 3 * 10 ** 9, 4 * 10 ** 9]\n    edges = [[0, 1], [1, 2], [2, 3]]\n    assert solution.minimumScore(nums, edges) == 2 * 10 ** 9", "def test_minimumScore():\n    solution = Solution()\n    nums = [1, 2, 3, 4, 5, 6]\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5]]\n    assert solution.minimumScore(nums, edges) == 1", "def test_minimumScore():\n    solution = Solution()\n    nums = [3, 3, 3, 3]\n    edges = [[0, 1], [1, 2], [2, 3]]\n    assert solution.minimumScore(nums, edges) == 0", "def test_minimumScore():\n    solution = Solution()\n    nums = [-2, -4, -6, -8]\n    edges = [[0, 1], [1, 2], [2, 3]]\n    assert solution.minimumScore(nums, edges) == 2 * 8", "def test_minimumScore():\n    solution = Solution()\n    nums = list(range(1, 100))\n    edges = [(i, i + 1) for i in range(len(nums) - 1)]\n    assert solution.minimumScore(nums, edges) == 97", "def test_minimumScore():\n    solution = Solution()\n    nums = [1]\n    edges = []\n    assert solution.minimumScore(nums, edges) == 0", "def test_minimumScore():\n    solution = Solution()\n    nums = [0, 0, 0]\n    edges = [[0, 1], [1, 2]]\n    assert solution.minimumScore(nums, edges) == 0", "def test_minimumScore():\n    solution = Solution()\n    nums = [1, 2, 3, 4, 5, 6, 7]\n    edges = [(i, i + 1) for i in range(len(nums) - 1)]\n    assert solution.minimumScore(nums, edges) == 3", "def test_minimumScore():\n    solution = Solution()\n    nums = [1, 2]\n    edges = [[0, 1]]\n    assert solution.minimumScore(nums, edges) == 1", "def test_minimumScore():\n    solution = Solution()\n    nums = [1, 2, 3, 4, 5]\n    edges = [[0, 1], [1, 2], [3, 4]]\n    assert solution.minimumScore(nums, edges) == 1", "def test_minimumScore():\n    solution = Solution()\n    nums = [2 ** 30 - 1, 2 ** 31 - 1, 1]\n    edges = [[0, 1], [1, 2]]\n    assert solution.minimumScore(nums, edges) == 2 ** 31 - 1", "def test_minimumScore():\n    solution = Solution()\n    nums = [1, 2, 3, 4]\n    edges = [[0, 1], [2, 1], [3, 2]]\n    assert solution.minimumScore(nums, edges) == 1", "def test_minimumScore():\n    solution = Solution()\n    nums = [1, 2, 3]\n    edges = [[0, 1]]\n    assert solution.minimumScore(nums, edges) == 0", "def test_minimumScore():\n    solution = Solution()\n    nums = [1, 2, 3, 4]\n    edges = [[0, 1], [1, 2], [2, 3], [3, 0]]\n    assert solution.minimumScore(nums, edges) == 1", "def test_minimumScore():\n    solution = Solution()\n    n = 100\n    nums = list(range(1, n + 1))\n    edges = [(i, (i + 1) % n) for i in range(n)]\n    assert solution.minimumScore(nums, edges) == 97"]}
{"task_num": 2332, "task_title": "The Latest Time to Catch a Bus", "func_name": "latestTimeCatchTheBus", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\n    buses.sort()\n    passengers.sort()\n\n    if passengers[0] > buses[-1]:\n      return buses[-1]\n\n    ans = passengers[0] - 1\n    i = 0\n    j = 0\n    while i < len(buses):\n      arrived = 0\n      while arrived < capacity and j < len(passengers) and passengers[j] <= buses[i]:\n        if j > 0 and passengers[j] != passengers[j - 1] + 1:\n          ans = passengers[j] - 1\n        j += 1\n        arrived += 1\n\n      if arrived < capacity and j > 0 and passengers[j - 1] != buses[i]:\n        ans = buses[i]\n      i += 1\n\n    return ans\n", "tests": ["def test_latestTimeCatchTheBus():\n    solution = Solution()\n    assert solution.latestTimeCatchTheBus([10, 20], [3, 9, 15, 25, 34, 40], 2) == 34", "def test_latestTimeCatchTheBus():\n    solution = Solution()\n    assert solution.latestTimeCatchTheBus([10, 20, 30], [5, 11, 18, 24, 29, 35, 40], 3) == 35", "def test_latestTimeCatchTheBus():\n    solution = Solution()\n    assert solution.latestTimeCatchTheBus([10], [3, 7, 12, 15, 18, 22], 4) == 17", "def test_latestTimeCatchTheBus():\n    solution = Solution()\n    assert solution.latestTimeCatchTheBus([5, 10, 15], [4, 8, 12, 13, 16, 19, 22], 2) == 18", "def test_latestTimeCatchTheBus():\n    solution = Solution()\n    assert solution.latestTimeCatchTheBus([30], [5, 15, 20, 25, 30], 1) == 29", "def test_latestTimeCatchTheBus():\n    solution = Solution()\n    assert solution.latestTimeCatchTheBus([10, 20, 30], [5, 9, 14, 18, 24, 27, 35, 40], 3) == 35", "def test_latestTimeCatchTheBus():\n    solution = Solution()\n    assert solution.latestTimeCatchTheBus([10], [2, 3, 4, 5, 6, 7, 8], 3) == 9", "def test_latestTimeCatchTheBus():\n    solution = Solution()\n    assert solution.latestTimeCatchTheBus([5], [1, 2, 3, 4, 6, 7, 8], 4) == 8", "def test_latestTimeCatchTheBus():\n    solution = Solution()\n    assert solution.latestTimeCatchTheBus([20], [15, 16, 17, 18, 19, 25], 2) == 24", "def test_latestTimeCatchTheBus():\n    solution = Solution()\n    assert solution.latestTimeCatchTheBus([10, 25], [5, 10, 15, 20, 30], 3) == 29", "def test_latestTimeCatchTheBus():\n    solution = Solution()\n    assert solution.latestTimeCatchTheBus([5, 15, 25], [3, 7, 8, 9, 10, 12, 26], 4) == 11", "def test_latestTimeCatchTheBus():\n    solution = Solution()\n    assert solution.latestTimeCatchTheBus([30], [25, 26, 27, 28, 29, 31, 32], 4) == 31", "def test_latestTimeCatchTheBus():\n    solution = Solution()\n    assert solution.latestTimeCatchTheBus([10], [5, 6, 7, 8, 9], 2) == 8", "def test_latestTimeCatchTheBus():\n    solution = Solution()\n    assert solution.latestTimeCatchTheBus([10, 20], [5, 7, 9, 18, 23, 24], 3) == 23", "def test_latestTimeCatchTheBus():\n    solution = Solution()\n    assert solution.latestTimeCatchTheBus([5], [1, 3, 4, 6, 7, 8], 2) == 9", "def test_latestTimeCatchTheBus():\n    solution = Solution()\n    assert solution.latestTimeCatchTheBus([10, 20], [3, 9, 15, 25, 34, 40], 1) == 34", "def test_latestTimeCatchTheBus():\n    solution = Solution()\n    assert solution.latestTimeCatchTheBus([10, 20], [4, 9, 15, 26, 34, 40], 3) == 34", "def test_latestTimeCatchTheBus():\n    solution = Solution()\n    assert solution.latestTimeCatchTheBus([5], [1, 2, 3, 4, 6, 7, 8, 9], 3) == 9", "def test_latestTimeCatchTheBus():\n    solution = Solution()\n    assert solution.latestTimeCatchTheBus([10, 25], [3, 7, 8, 9, 10, 26], 4) == 11", "def test_latestTimeCatchTheBus():\n    solution = Solution()\n    assert solution.latestTimeCatchTheBus([30], [25, 26, 27, 28, 29, 31, 32], 4) == 31"]}
{"task_num": 2337, "task_title": "Move Pieces to Obtain a String", "func_name": "canChange", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def canChange(self, start: str, target: str) -> bool:\n    n = len(start)\n    i = 0\n    j = 0\n\n    while i <= n and j <= n:\n      while i < n and start[i] == '_':\n        i += 1\n      while j < n and target[j] == '_':\n        j += 1\n      if i == n or j == n:\n        return i == n and j == n\n      if start[i] != target[j]:\n        return False\n      if start[i] == 'R' and i > j:\n        return False\n      if start[i] == 'L' and i < j:\n        return False\n      i += 1\n      j += 1\n\n    return True\n", "tests": ["def test_canChange():\n    solution = Solution()\n    assert solution.canChange('_L', 'L_') == True", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('R_L', '_LR') == False", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('RRLL_', '____L') == False", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('_R', '_R') == True", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('L_R_', 'L__R') == False", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('RR_L', '_LL_') == True", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('_L_R_', 'L__R_') == False", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('L_R', '_LR') == False", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('R_L_', 'L__R') == False", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('_R_L', '_R_L') == True", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('RRLL_', '____L') == False", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('_R', '_R') == True", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('L_R_', 'L__R') == False", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('RR_L', '_LL_') == True", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('_L_R_', 'L__R_') == False", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('L_L', '_LR') == True", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('R_L_', 'L__R') == False", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('_R_R', 'R_L_') == False", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('L_R_', 'L__R') == False", "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('RR_L', '_LL_') == True"]}
{"task_num": 2392, "task_title": "Build a Matrix With Conditions", "func_name": "buildMatrix", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\n    rowOrder = self._topologicalSort(rowConditions, k)\n    if not rowOrder:\n      return []\n\n    colOrder = self._topologicalSort(colConditions, k)\n    if not colOrder:\n      return []\n\n    ans = [[0] * k for _ in range(k)]\n    nodeToRowIndex = [0] * (k + 1)\n\n    for i, node in enumerate(rowOrder):\n      nodeToRowIndex[node] = i\n\n    for j, node in enumerate(colOrder):\n      i = nodeToRowIndex[node]\n      ans[i][j] = node\n\n    return ans\n\n  def _topologicalSort(self, conditions: List[List[int]], n: int) -> List[int]:\n    order = []\n    graph = [[] for _ in range(n + 1)]\n    inDegrees = [0] * (n + 1)\n\n    for u, v in conditions:\n      graph[u].append(v)\n      inDegrees[v] += 1\n\n    q = collections.deque([i for i in range(1, n + 1) if inDegrees[i] == 0])\n\n    while q:\n      u = q.popleft()\n      order.append(u)\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    if len(order) == n:\n      return order\n    else:\n      return []\n", "tests": ["def test_buildMatrix():\n    solution = Solution()\n    assert solution.buildMatrix(3, [[1, 2], [3, 1]], [[1, 3], [2, 3]]) == [[1, 0, 0], [0, 2, 0], [0, 0, 3]]", "def test_buildMatrix():\n    solution = Solution()\n    assert solution.buildMatrix(3, [[1, 2], [2, 3]], [[1, 3], [2, 3]]) == []", "def test_buildMatrix():\n    solution = Solution()\n    assert solution.buildMatrix(1, [], []) == [[1]]", "def test_buildMatrix():\n    solution = Solution()\n    assert solution.buildMatrix(3, [[1, 2], [2, 1]], [[1, 3], [3, 1]]) == []", "def test_buildMatrix():\n    solution = Solution()\n    assert solution.buildMatrix(4, [[1, 2], [2, 3], [3, 4]], [[1, 4], [4, 3], [3, 2]]) == [[1, 0, 0, 0], [0, 2, 0, 0], [0, 0, 3, 0], [0, 0, 0, 4]]", "def test_buildMatrix():\n    solution = Solution()\n    k = 100\n    rowConditions = [[i, i + 1] for i in range(1, k)]\n    colConditions = [[i, i + 1] for i in range(1, k)]\n    assert solution.buildMatrix(k, rowConditions, colConditions) == [[i % k + 1 if j == i // k else 0 for j in range(k)] for i in range(k * k)]", "def test_buildMatrix():\n    solution = Solution()\n    assert solution.buildMatrix(3, [[1, 2], [2, 3], [3, 4]], []) == []", "def test_buildMatrix():\n    solution = Solution()\n    assert solution.buildMatrix(4, [[1, 2], [3, 1]], [[1, 4], [4, 3]]) == [[1, 0, 0, 0], [0, 2, 0, 0], [0, 0, 3, 0], [0, 0, 0, 4]]", "def test_buildMatrix():\n    solution = Solution()\n    assert solution.buildMatrix(3, [[2, 1], [3, 2]], []) == []", "def test_buildMatrix():\n    solution = Solution()\n    k = 1000\n    rowConditions = [[i % k + 1, (i + 2) % k + 1] for i in range(k)]\n    colConditions = [[(k - i - 1) % k + 1, (k - i) % k + 1] for i in range(k)]\n    assert solution.buildMatrix(k, rowConditions, colConditions) == [[i % k + 1 if j == i // k else 0 for j in range(k)] for i in range(k * k)]", "def test_buildMatrix():\n    solution = Solution()\n    assert solution.buildMatrix(1, [], []) == [[1]]", "def test_buildMatrix():\n    solution = Solution()\n    k = 1000\n    rowConditions = [[i % k + 1, (i + 2) % k + 1] for i in range(k)]\n    colConditions = [[i % k + 1, (i + 2) % k + 1] for i in range(k)]\n    assert solution.buildMatrix(k, rowConditions, colConditions) == [[i % k + 1 if j == i // k else 0 for j in range(k)] for i in range(k * k)]", "def test_buildMatrix():\n    solution = Solution()\n    k = 1000\n    rowConditions = [[(k - i) % k + 1, (k - i - 2) % k + 1] for i in range(k)]\n    colConditions = [[i % k + 1, (i + 2) % k + 1] for i in range(k)]\n    assert solution.buildMatrix(k, rowConditions, colConditions) == []", "def test_buildMatrix():\n    solution = Solution()\n    k = 1000\n    rowConditions = [[2, 1] for _ in range(k - 1)]\n    colConditions = [[(k - i) % k + 1, (k - i - 2) % k + 1] for i in range(k)]\n    assert solution.buildMatrix(k, rowConditions, colConditions) == []", "test_buildMatrix_with_large_k_and_identical_row_col_conditions_rotated_7000():\n    import numpy as np\n    from skimage.transform import rotate\n    solution = Solution()\n    k = 1000\n    rowConditions = [[i % k + 1, (i + 2) % k + 1] for i in range(k)]\n    colConditions = list(rotate(np.array(rowConditions), angle=7000).flatten())\n    assert solution.buildMatrix(k, rowConditions, colConditions) == expected_output", "test_buildMatrix_with_large_k_and_identical_row_col_conditions_rotated_7010():\n    import numpy as np\n    from skimage.transform import rotate\n    solution = Solution()\n    k = 1000\n    rowConditions = [[i % k + 1, (i + 2) % k + 1] for i in range(k)]\n    colConditions = list(rotate(np.array(rowConditions), angle=7010).flatten())\n    assert solution.buildMatrix(k, rowConditions, colConditions) == expected_output", "test_buildMatrix_with_large_k_and_identical_row_col_conditions_rotated_7020():\n    import numpy as np\n    from skimage.transform import rotate\n    solution = Solution()\n    k = 1000\n    rowConditions = [[i % k + 1, (i + 2) % k + 1] for i in range(k)]\n    colConditions = list(rotate(np.array(rowConditions), angle=7020).flatten())\n    assert solution.buildMatrix(k, rowConditions, colConditions) == expected_output", "test_buildMatrix_with_large_k_and_identical_row_col_conditions_rotated_7030():\n    import numpy as np\n    from skimage.transform import rotate\n    solution = Solution()\n    k = 1000\n    rowConditions = [[i % k + 1, (i + 2) % k + 1] for i in range(k)]\n    colConditions = list(rotate(np.array(rowConditions), angle=7030).flatten())\n    assert solution.buildMatrix(k, rowConditions, colConditions) == expected_output", "test_buildMatrix_with_large_k_and_identical_row_col_conditions_rotated_7040():\n    import numpy as np\n    from skimage.transform import rotate\n    solution = Solution()\n    k = 1000\n    rowConditions = [[i % k + 1, (i + 2) % k + 1] for i in range(k)]\n    colConditions = list(rotate(np.array(rowConditions), angle=7040).flatten())\n    assert solution.buildMatrix(k, rowConditions, colConditions) == expected_output", "test_buildMatrix_with_large_k_and_identical_row_col_conditions_rotated_7050():\n    import numpy as np\n    from skimage.transform import rotate\n    solution = Solution()\n    k = 1000\n    rowConditions = [[i % k + 1, (i + 2) % k + 1] for i in range(k)]\n    colConditions = list(rotate(np.array(rowConditions), angle=7050).flatten())\n    assert solution.buildMatrix(k, rowConditions, colConditions) == expected_output"]}
{"task_num": 2437, "task_title": "Number of Valid Clock Times", "func_name": "countTime", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countTime(self, time: str) -> int:\n    ans = 1\n    if time[3] == '?':\n      ans *= 6\n    if time[4] == '?':\n      ans *= 10\n\n    if time[0] == '?' and time[1] == '?':\n      return ans * 24\n    if time[0] == '?':\n      if time[1] < '4':\n        return ans * 3\n      else:\n        return ans * 2\n    if time[1] == '?':\n      if time[0] == '2':\n        return ans * 4\n      else:\n        return ans * 10\n    return ans\n", "tests": ["def test_countTime():\n    solution = Solution()\n    assert solution.countTime('2?:??') == 8", "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('?4:??') == 6", "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('1?:??') == 10", "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('23:?5') == 6", "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('???:51') == 2", "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('0?:3?') == 24", "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('1?:0?') == 10", "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('2?:4?') == 6", "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('???:?5') == 6", "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('0?:?9') == 24", "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('1?:?0') == 10", "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('23:?9') == 6", "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('???:?0') == 6", "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('0?:?5') == 24", "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('1?:?5') == 10", "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('23:?5') == 6", "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('???:?5') == 6", "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('0?:?9') == 24", "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('1?:?9') == 10", "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('23:?5') == 6"]}
{"task_num": 2456, "task_title": "Most Popular Video Creator", "func_name": "mostPopularCreator", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Creator:\n  def __init__(self, popularity: int, videoId: str, maxView: int):\n    self.popularity = popularity\n    self.videoId = videoId\n    self.maxView = maxView\n\n\nclass Solution:\n  def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\n    ans = []\n    maxPopularity = 0\n    nameToCreator = {}\n\n    for name, id, view in zip(creators, ids, views):\n      if name not in nameToCreator:\n        nameToCreator[name] = Creator(view, id, view)\n        maxPopularity = max(maxPopularity, view)\n        continue\n      creator = nameToCreator[name]\n      creator.popularity += view\n      maxPopularity = max(maxPopularity, creator.popularity)\n      if creator.maxView < view or creator.maxView == view and creator.videoId > id:\n        creator.videoId = id\n        creator.maxView = view\n\n    for name, creator in nameToCreator.items():\n      if creator.popularity == maxPopularity:\n        ans.append([name, creator.videoId])\n\n    return ans\n", "tests": ["def test_mostPopularCreator():\n    solution = Solution()\n    creators = ['alice', 'bob']\n    ids = ['one', 'two']\n    views = [100, 200]\n    expected_output = [['bob', 'two']]\n    assert solution.mostPopularCreator(creators, ids, views) == expected_output", "def test_mostPopularCreator():\n    solution = Solution()\n    creators = ['alice', 'bob']\n    ids = ['one', 'two']\n    views = [100, 50]\n    expected_output = [['alice', 'one']]\n    assert solution.mostPopularCreator(creators, ids, views) == expected_output", "def test_mostPopularCreator():\n    solution = Solution()\n    creators = ['alice', 'bob', 'charlie']\n    ids = ['one', 'two', 'three']\n    views = [100, 200, 150]\n    expected_output = [['bob', 'two']]\n    assert solution.mostPopularCreator(creators, ids, views) == expected_output", "def test_mostPopularCreator():\n    solution = Solution()\n    creators = ['alice', 'bob', 'charlie']\n    ids = ['one', 'two', 'three']\n    views = [100, 250, 150]\n    expected_output = [['bob', 'two']]\n    assert solution.mostPopularCreator(creators, ids, views) == expected_output", "def test_mostPopularCreator():\n    solution = Solution()\n    creators = ['alice', 'bob']\n    ids = ['one', 'two']\n    views = [50, 50]\n    expected_output = [['alice', 'one'], ['bob', 'two']]\n    assert solution.mostPopularCreator(creators, ids, views) == expected_output", "def test_mostPopularCreator():\n    solution = Solution()\n    creators = ['alice', 'bob', 'charlie']\n    ids = ['one', 'two', 'three']\n    views = [100, 150, 200]\n    expected_output = [['charlie', 'three']]\n    assert solution.mostPopularCreator(creators, ids, views) == expected_output", "def test_mostPopularCreator():\n    solution = Solution()\n    creators = ['alice', 'bob']\n    ids = ['one', 'two']\n    views = [200, 100]\n    expected_output = [['alice', 'one']]\n    assert solution.mostPopularCreator(creators, ids, views) == expected_output", "def test_mostPopularCreator():\n    solution = Solution()\n    creators = ['alice', 'bob']\n    ids = ['one', 'two']\n    views = [100, 300]\n    expected_output = [['bob', 'two']]\n    assert solution.mostPopularCreator(creators, ids, views) == expected_output", "def test_mostPopularCreator():\n    solution = Solution()\n    creators = ['alice']\n    ids = ['one']\n    views = [100]\n    expected_output = [['alice', 'one']]\n    assert solution.mostPopularCreator(creators, ids, views) == expected_output", "def test_mostPopularCreator():\n    solution = Solution()\n    creators = ['alice', 'bob', 'charlie']\n    ids = ['one', 'two', 'three']\n    views = [150, 200, 300]\n    expected_output = [['charlie', 'three']]\n    assert solution.mostPopularCreator(creators, ids, views) == expected_output", "def test_mostPopularCreator():\n    solution = Solution()\n    creators = ['alice', 'bob', 'charlie']\n    ids = ['one', 'two', 'three']\n    views = [150, 150, 300]\n    expected_output = [['charlie', 'three']]\n    assert solution.mostPopularCreator(creators, ids, views) == expected_output", "def test_mostPopularCreator():\n    solution = Solution()\n    creators = ['alice', 'bob', 'charlie']\n    ids = ['one', 'two', 'three']\n    views = [150, 300, 200]\n    expected_output = [['bob', 'two']]\n    assert solution.mostPopularCreator(creators, ids, views) == expected_output", "def test_mostPopularCreator():\n    solution = Solution()\n    creators = ['alice', 'bob']\n    ids = ['one', 'two']\n    views = [50, 50]\n    expected_output = [['alice', 'one'], ['bob', 'two']]\n    assert solution.mostPopularCreator(creators, ids, views) == expected_output", "def test_mostPopularCreator():\n    solution = Solution()\n    creators = ['alice', 'bob']\n    ids = ['one', 'two']\n    views = [100, 200]\n    expected_output = [['bob', 'two']]\n    assert solution.mostPopularCreator(creators, ids, views) == expected_output", "def test_mostPopularCreator():\n    solution = Solution()\n    creators = ['alice', 'bob']\n    ids = ['one', 'two']\n    views = [200, 100]\n    expected_output = [['alice', 'one']]\n    assert solution.mostPopularCreator(creators, ids, views) == expected_output", "def test_mostPopularCreator():\n    solution = Solution()\n    creators = ['alice', 'bob']\n    ids = ['one', 'two']\n    views = [100, 300]\n    expected_output = [['bob', 'two']]\n    assert solution.mostPopularCreator(creators, ids, views) == expected_output", "def test_mostPopularCreator():\n    solution = Solution()\n    creators = ['alice', 'bob']\n    ids = ['one', 'two']\n    views = [100, 50]\n    expected_output = [['alice', 'one']]\n    assert solution.mostPopularCreator(creators, ids, views) == expected_output", "def test_mostPopularCreator():\n    solution = Solution()\n    creators = ['alice', 'bob']\n    ids = ['one', 'two']\n    views = [50, 25]\n    expected_output = [['alice', 'one']]\n    assert solution.mostPopularCreator(creators, ids, views) == expected_output", "def test_mostPopularCreator():\n    solution = Solution()\n    creators = ['alice', 'bob']\n    ids = ['one', 'two']\n    views = [50, 150]\n    expected_output = [['bob', 'two']]\n    assert solution.mostPopularCreator(creators, ids, views) == expected_output", "def test_mostPopularCreator():\n    solution = Solution()\n    creators = ['alice', 'bob']\n    ids = ['one', 'two']\n    views = [250, 150]\n    expected_output = [['alice', 'one']]\n    assert solution.mostPopularCreator(creators, ids, views) == expected_output"]}
{"task_num": 2462, "task_title": "Total Cost to Hire K Workers", "func_name": "totalCost", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\n    ans = 0\n    i = 0\n    j = len(costs) - 1\n    minHeapL = []\n    minHeapR = []\n\n    for _ in range(k):\n      while len(minHeapL) < candidates and i <= j:\n        heapq.heappush(minHeapL, costs[i])\n        i += 1\n      while len(minHeapR) < candidates and i <= j:\n        heapq.heappush(minHeapR, costs[j])\n        j -= 1\n      if not minHeapL:\n        ans += heapq.heappop(minHeapR)\n      elif not minHeapR:\n        ans += heapq.heappop(minHeapL)\n      elif minHeapL[0] <= minHeapR[0]:\n        ans += heapq.heappop(minHeapL)\n      else:\n        ans += heapq.heappop(minHeapR)\n\n    return ans\n", "tests": ["def test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([1, 2, 3, 4, 5], 3, 1) == 3", "def test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([4, 3, 2, 1], 2, 2) == 5", "def test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([10, 20, 30, 40], 3, 1) == 60", "def test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([5, 4, 3, 2, 1], 1, 2) == 1", "def test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([1, 5, 3, 4], 2, 2) == 8", "def test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([10, 3, 5, 2], 4, 1) == 10", "def test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([50, 20, 30, 10], 3, 1) == 80", "def test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([2, 4, 6, 8, 10, 12], 3, 3) == 18", "def test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([7, 5, 3, 1], 2, 2) == 4", "def test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([100, 90, 80, 70, 60], 2, 1) == 190", "def test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([3, 2, 4, 1], 1, 2) == 1", "def test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([5, 9, 8, 7, 6, 10], 4, 2) == 24", "def test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([1, 2, 3], 2, 1) == 2", "def test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([10, 15, 3, 7], 3, 2) == 18", "def test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([4, 5, 2, 3], 2, 1) == 6", "def test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([100, 50, 200, 150], 3, 1) == 450", "def test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([2, 4, 6, 8], 3, 1) == 14", "def test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([50, 60, 30, 40], 2, 1) == 170", "def test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([1, 3, 5, 7, 9], 4, 2) == 16", "def test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([10, 20, 30, 40, 50], 2, 3) == 60"]}
{"task_num": 2467, "task_title": "Most Profitable Path in a Tree", "func_name": "mostProfitablePath", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\n    n = len(amount)\n    tree = [[] for _ in range(n)]\n    parent = [0] * n\n    aliceDist = [-1] * n\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, prev: int, d: int) -> None:\n      parent[u] = prev\n      aliceDist[u] = d\n      for v in tree[u]:\n        if aliceDist[v] == -1:\n          dfs(v, u, d + 1)\n\n    dfs(0, -1, 0)\n\n    u = bob\n    bobDist = 0\n    while u != 0:\n      if bobDist < aliceDist[u]:\n        amount[u] = 0\n      elif bobDist == aliceDist[u]:\n        amount[u] //= 2\n      u = parent[u]\n      bobDist += 1\n\n    return self._getMoney(tree, 0, -1, amount)\n\n  def _getMoney(self, tree: List[List[int]], u: int, prev: int, amount: List[int]) -> int:\n    if len(tree[u]) == 1 and tree[u][0] == prev:\n      return amount[u]\n\n    maxPath = -math.inf\n    for v in tree[u]:\n      if v != prev:\n        maxPath = max(maxPath, self._getMoney(tree, v, u, amount))\n\n    return amount[u] + maxPath\n", "tests": ["def test_mostProfitablePath():\n    solution = Solution()\n    result = solution.mostProfitablePath([[0, 1], [0, 2], [1, 3], [1, 4]], 0, [-5, 10, -8, -6, 7])", "def test_mostProfitablePath():\n    solution = Solution()\n    result = solution.mostProfitablePath([[0, 1], [0, 2], [1, 3], [1, 4], [2, 5]], 2, [-9, -7, -8, 10, 12, 6])", "def test_mostProfitablePath():\n    solution = Solution()\n    result = solution.mostProfitablePath([[0, 1], [0, 2]], 0, [5, -4, 6])", "def test_mostProfitablePath():\n    solution = Solution()\n    result = solution.mostProfitablePath([[0, 1], [0, 2], [1, 3]], 1, [-4, -8, -5, -6])", "def test_mostProfitablePath():\n    solution = Solution()\n    result = solution.mostProfitablePath([[0, 1], [1, 2], [1, 3]], 3, [0, -1, 5, 7])", "def test_mostProfitablePath():\n    solution = Solution()\n    result = solution.mostProfitablePath([[0, 1], [0, 2], [0, 3]], 0, [5, -4, 6, -7])", "def test_mostProfitablePath():\n    solution = Solution()\n    result = solution.mostProfitablePath([[0, 1], [1, 2], [2, 3], [3, 4]], 4, [-5, -4, -3, -2, -1])", "def test_mostProfitablePath():\n    solution = Solution()\n    result = solution.mostProfitablePath([[0, 1], [1, 2], [2, 3]], 2, [-4, -8, -5, 10])", "def test_mostProfitablePath():\n    solution = Solution()\n    result = solution.mostProfitablePath([[0, 1], [0, 2], [1, 3], [2, 4]], 1, [5, -6, -7, -8, 9])", "def test_mostProfitablePath():\n    solution = Solution()\n    result = solution.mostProfitablePath([[0, 1], [0, 2], [1, 3], [1, 4]], 3, [5, -7, 6, 8, 9])", "def test_mostProfitablePath():\n    solution = Solution()\n    result = solution.mostProfitablePath([[0, 1], [0, 2], [1, 3], [1, 4]], 2, [5, -6, -7, 8, 9])", "def test_mostProfitablePath():\n    solution = Solution()\n    result = solution.mostProfitablePath([[0, 1], [0, 2], [1, 3]], 2, [-4, -8, -5])", "def test_mostProfitablePath():\n    solution = Solution()\n    result = solution.mostProfitablePath([[0, 1], [0, 2], [1, 3], [2, 4]], 1, [5, -6, -7, 8, 9])", "def test_mostProfitablePath():\n    solution = Solution()\n    result = solution.mostProfitablePath([[0, 1], [0, 2]], 0, [5, -4, 6])", "def test_mostProfitablePath():\n    solution = Solution()\n    result = solution.mostProfitablePath([[0, 1], [0, 2], [1, 3]], 2, [5, -4, -7, 6])", "def test_mostProfitablePath():\n    solution = Solution()\n    result = solution.mostProfitablePath([[0, 1], [0, 2], [1, 3]], 3, [5, -4, -7, -8])", "def test_mostProfitablePath():\n    solution = Solution()\n    result = solution.mostProfitablePath([[0, 1], [0, 2]], 0, [5, -4, 6])", "def test_mostProfitablePath():\n    solution = Solution()\n    result = solution.mostProfitablePath([[0, 1], [1, 2], [2, 3]], 2, [5, -6, 7, 8])", "def test_mostProfitablePath():\n    solution = Solution()\n    result = solution.mostProfitablePath([[0, 1], [1, 2], [1, 3]], 1, [5, -4, 6, -7])", "def test_mostProfitablePath():\n    solution = Solution()\n    result = solution.mostProfitablePath([[0, 1], [0, 2], [1, 3]], 2, [5, -4, -7, 6])"]}
{"task_num": 2499, "task_title": "Minimum Total Cost to Make Arrays Unequal", "func_name": "minimumTotalCost", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\n    n = len(nums1)\n    ans = 0\n    maxFreq = 0\n    maxFreqNum = 0\n    shouldBeSwapped = 0\n    conflictedNumCount = [0] * (n + 1)\n\n    for i, (num1, num2) in enumerate(zip(nums1, nums2)):\n      if num1 == num2:\n        conflictedNum = num1\n        conflictedNumCount[conflictedNum] += 1\n        if conflictedNumCount[conflictedNum] > maxFreq:\n          maxFreq = conflictedNumCount[conflictedNum]\n          maxFreqNum = conflictedNum\n        shouldBeSwapped += 1\n        ans += i\n\n    for i, (num1, num2) in enumerate(zip(nums1, nums2)):\n      if maxFreq * 2 <= shouldBeSwapped:\n        break\n      if num1 == num2:\n        continue\n\n      if num1 == maxFreqNum or num2 == maxFreqNum:\n        continue\n      shouldBeSwapped += 1\n      ans += i\n\n    if maxFreq * 2 > shouldBeSwapped:\n      return -1\n    else:\n      return ans\n", "tests": ["def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([1, 2, 3], [3, 2, 1]) == 0", "def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([1, 2, 3], [1, 2, 3]) == -1", "def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([1, 2, 3], [4, 5, 6]) == 0", "def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([3, 2, 1], [3, 2, 1]) == -1", "def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([1, 3, 2], [2, 3, 1]) == 4", "def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([3, 1, 2], [2, 1, 3]) == 0", "def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([1, 2, 3], [1, 3, 2]) == 4", "def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([1, 2, 3], [1, 2, 4]) == 0", "def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([1, 2, 4], [1, 3, 2]) == 4", "def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([1, 2, 3], [4, 5, 6]) == 0", "def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([1, 2, 3], [4, 5, 6]) == 0", "def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([1, 2, 3], [4, 5, 6]) == 0", "def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([1, 2, 3], [4, 5, 6]) == 0", "def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([1, 2, 3], [4, 5, 6]) == 0", "def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([1, 2, 3], [4, 5, 6]) == 0", "def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([1, 2, 3], [4, 5, 6]) == 0", "def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([1, 2, 3], [4, 5, 6]) == 0", "def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([1, 2, 3], [4, 5, 6]) == 0", "def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([1, 2, 3], [4, 5, 6]) == 0", "def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([1, 2, 3], [4, 5, 6]) == 0"]}
{"task_num": 2503, "task_title": "Maximum Number of Points From Grid Queries", "func_name": "maxPoints", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, query: int):\n    self.queryIndex = queryIndex\n    self.query = query\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.query\n\n\nclass Solution:\n  def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    ans = [0] * len(queries)\n    minHeap = [(grid[0][0], 0, 0)]\n    seen = {(0, 0)}\n    accumulate = 0\n\n    for queryIndex, query in sorted([IndexedQuery(i, query) for i, query in enumerate(queries)], key=lambda iq: iq.query):\n      while minHeap:\n        val, i, j = heapq.heappop(minHeap)\n        if val >= query:\n          heapq.heappush(minHeap, (val, i, j))\n          break\n        accumulate += 1\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if (x, y) in seen:\n            continue\n          heapq.heappush(minHeap, (grid[x][y], x, y))\n          seen.add((x, y))\n      ans[queryIndex] = accumulate\n\n    return ans\n", "tests": ["def test_maxPoints():\n    solution = Solution()\n    assert solution.maxPoints([[1, 2], [3, 4]], [3, 0, 1]) == [2, 0, 1]", "def test_maxPoints():\n    solution = Solution()\n    assert solution.maxPoints([[5, 6], [7, 8]], [10, 9, 8, 7, 6, 5]) == [4, 3, 2, 1, 0, 0]", "def test_maxPoints():\n    solution = Solution()\n    assert solution.maxPoints([[10, 20], [30, 40]], [5]) == [0]", "def test_maxPoints():\n    solution = Solution()\n    assert solution.maxPoints([[1, 2], [3, 4]], [1]) == [0]", "def test_maxPoints():\n    solution = Solution()\n    assert solution.maxPoints([[5]], [1]) == [0]", "def test_maxPoints():\n    solution = Solution()\n    assert solution.maxPoints([[1], [2]], [3]) == [0]", "def test_maxPoints():\n    solution = Solution()\n    assert solution.maxPoints([[1, 2], [3, 4]], [7, 6]) == [4, 3]", "def test_maxPoints():\n    solution = Solution()\n    assert solution.maxPoints([[100, 200], [300, 400]], [50]) == [0]", "def test_maxPoints():\n    solution = Solution()\n    assert solution.maxPoints([[10], [5]], [7]) == [2]", "def test_maxPoints():\n    solution = Solution()\n    assert solution.maxPoints([[10, 5], [20, 30]], [15]) == [3]", "def test_maxPoints():\n    solution = Solution()\n    assert solution.maxPoints([[10, 20], [30, 40]], [1]) == [0]", "def test_maxPoints():\n    solution = Solution()\n    assert solution.maxPoints([[5, 6], [7, 8]], [9]) == [1]", "def test_maxPoints():\n    solution = Solution()\n    assert solution.maxPoints([[1, 2], [3, 4]], [8]) == [3]", "def test_maxPoints():\n    solution = Solution()\n    assert solution.maxPoints([[1], [2]], [3]) == [0]", "def test_maxPoints():\n    solution = Solution()\n    assert solution.maxPoints([[1, 2], [3, 4]], [5]) == [0]", "def test_maxPoints():\n    solution = Solution()\n    assert solution.maxPoints([[100, 200], [300, 400]], [150]) == [2]", "def test_maxPoints():\n    solution = Solution()\n    assert solution.maxPoints([[1, 2], [3, 4]], [6]) == [2]", "def test_maxPoints():\n    solution = Solution()\n    assert solution.maxPoints([[1], [2]], [4]) == [0]", "def test_maxPoints():\n    solution = Solution()\n    assert solution.maxPoints([[10], [5]], [6]) == [2]", "def test_maxPoints():\n    solution = Solution()\n    assert solution.maxPoints([[10, 5], [20, 30]], [16]) == [4]"]}
{"task_num": 2508, "task_title": "Add Edges to Make Degrees of All Nodes Even", "func_name": "isPossible", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isPossible(self, n: int, edges: List[List[int]]) -> bool:\n    graph = [set() for _ in range(n)]\n\n    for u, v in edges:\n      graph[u - 1].add(v - 1)\n      graph[v - 1].add(u - 1)\n\n    oddNodes = [i for i, neighbor in enumerate(graph) if len(neighbor) & 1]\n    if not oddNodes:\n      return True\n    if len(oddNodes) == 2:\n      a, b = oddNodes\n      return any(a not in graph[i] and b not in graph[i] for i in range(n))\n    if len(oddNodes) == 4:\n      a, b, c, d = oddNodes\n      return (b not in graph[a] and d not in graph[c]) or (c not in graph[a] and d not in graph[b]) or (d not in graph[a] and c not in graph[b])\n    return False\n", "tests": ["def test_isPossible():\n    solution = Solution()\n    assert not solution.isPossible(4, [[1, 2], [2, 3], [3, 4]])", "def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(4, [[1, 2], [2, 3], [3, 1]])", "def test_isPossible():\n    solution = Solution()\n    assert not solution.isPossible(4, [[1, 2], [3, 4], [5, 6]])", "def test_isPossible():\n    solution = Solution()\n    assert not solution.isPossible(4, [[1, 2], [3, 4], [1, 3]])", "def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(4, [[1, 2], [2, 3], [3, 1], [1, 4]])", "def test_isPossible():\n    solution = Solution()\n    assert not solution.isPossible(5, [[1, 2], [2, 3], [4, 5]])", "def test_isPossible():\n    solution = Solution()\n    assert not solution.isPossible(3, [[1, 2], [2, 2]])", "def test_isPossible():\n    solution = Solution()\n    assert not solution.isPossible(3, [[1, 2], [2, 3], [1, 2]])", "def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(4, [[1, 2], [2, 3], [3, 1], [1, 2], [2, 4], [3, 4]])", "def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(2, [])", "def test_isPossible():\n    solution = Solution()\n    assert not solution.isPossible(4, [[1, 2], [3, 4], [5, 6], [7, 8]])", "def test_isPossible():\n    solution = Solution()\n    assert not solution.isPossible(5, [[1, 2], [2, 3], [4, 5], [1, 4]])", "def test_isPossible():\n    solution = Solution()\n    assert not solution.isPossible(5, [[1, 2], [2, 3], [4, 5], [1, 4], [2, 5]])", "def test_isPossible():\n    solution = Solution()\n    assert not solution.isPossible(6, [[1, 2], [2, 3], [4, 5], [5, 6], [1, 4], [2, 6]])", "def test_isPossible():\n    solution = Solution()\n    assert not solution.isPossible(8, [[1, 2], [2, 3], [4, 5], [5, 6], [7, 8], [1, 4], [2, 6], [3, 7]])", "def test_isPossible():\n    solution = Solution()\n    assert not solution.isPossible(10, [[1, 2], [2, 3], [4, 5], [5, 6], [7, 8], [9, 10], [1, 4], [2, 6], [3, 7], [5, 9]])", "def test_isPossible():\n    solution = Solution()\n    assert not solution.isPossible(12, [[1, 2], [2, 3], [4, 5], [5, 6], [7, 8], [9, 10], [11, 12], [1, 4], [2, 6], [3, 7], [5, 9], [7, 11]])", "def test_isPossible():\n    solution = Solution()\n    assert not solution.isPossible(14, [[1, 2], [2, 3], [4, 5], [5, 6], [7, 8], [9, 10], [11, 12], [13, 14], [1, 4], [2, 6], [3, 7], [5, 9], [7, 11], [1, 7]])", "def test_isPossible():\n    solution = Solution()\n    assert not solution.isPossible(16, [[1, 2], [2, 3], [4, 5], [5, 6], [7, 8], [9, 10], [11, 12], [13, 14], [15, 16], [1, 4], [2, 6], [3, 7], [5, 9], [7, 11], [1, 7], [2, 8]])", "def test_isPossible():\n    solution = Solution()\n    assert not solution.isPossible(18, [[1, 2], [2, 3], [4, 5], [5, 6], [7, 8], [9, 10], [11, 12], [13, 14], [15, 16], [17, 18], [1, 4], [2, 6], [3, 7], [5, 9], [7, 11], [1, 7], [2, 8], [3, 10]])"]}
{"task_num": 2523, "task_title": "Closest Prime Numbers in Range", "func_name": "closestPrimes", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def closestPrimes(self, left: int, right: int) -> List[int]:\n    isPrime = self._sieveEratosthenes(right + 1)\n    primes=[]\n    for i in range(left, right+1):\n      if isPrime[i]:\n        primes.append(i)\n\n    if len(primes) < 2:\n      return [-1, -1]\n\n    minDiff = math.inf\n    num1 = -1\n    num2 = -1\n\n    for a, b in zip(primes, primes[1:]):\n      diff = b - a\n      if diff < minDiff:\n        minDiff = diff\n        num1 = a\n        num2 = b\n\n    return [num1, num2]\n\n  def _sieveEratosthenes(self, n: int) -> List[bool]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return isPrime\n", "tests": ["def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(10, 29) == [11, 13]", "def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(10, 9) == [-1, -1]", "def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(5, 5) == [-1, -1]", "def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(3, 5) == [3, 5]", "def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(100, 200) == [101, 103]", "def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(2, 10) == [3, 5]", "def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(14, 17) == [17, 19]", "def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(7, 7) == [-1, -1]", "def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(20, 30) == [23, 29]", "def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(100, 200) == [101, 103]", "def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(103, 107) == [103, 107]", "def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(1000, 2000) == [1009, 1013]", "def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(4, 6) == [-1, -1]", "def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(10, 15) == [11, 13]", "def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(2, 5) == [3, 5]", "def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(97, 100) == [97, 101]", "def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(5, 10) == [7, 11]", "def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(1000, 2000) == [1009, 1013]", "def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(20, 23) == [23, 29]", "def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(30, 42) == [31, 37]"]}
{"task_num": 2532, "task_title": "Time to Cross a Bridge", "func_name": "findCrossingTime", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n    ans = 0\n    leftBridgeQueue = [(-leftToRight - rightToLeft, -i) for i, (leftToRight, pickOld, rightToLeft, pickNew) in enumerate(time)]\n    rightBridgeQueue = []\n    leftWorkers = []\n    rightWorkers = []\n\n    heapq.heapify(leftBridgeQueue)\n\n    while n > 0 or rightBridgeQueue or rightWorkers:\n      while leftWorkers and leftWorkers[0][0] <= ans:\n        i = heapq.heappop(leftWorkers)[1]\n        heapq.heappush(leftBridgeQueue, (-time[i][0] - time[i][2], -i))\n      while rightWorkers and rightWorkers[0][0] <= ans:\n        i = heapq.heappop(rightWorkers)[1]\n        heapq.heappush(rightBridgeQueue, (-time[i][0] - time[i][2], -i))\n      if rightBridgeQueue:\n        i = -heapq.heappop(rightBridgeQueue)[1]\n        ans += time[i][2]\n        heapq.heappush(leftWorkers, (ans + time[i][3], i))\n      elif leftBridgeQueue and n > 0:\n        i = -heapq.heappop(leftBridgeQueue)[1]\n        ans += time[i][0]\n        heapq.heappush(rightWorkers, (ans + time[i][1], i))\n        n -= 1\n      else:\n        if leftWorkers and n > 0:\n          ans1=leftWorkers[0][0]\n        else:\n          ans1=math.inf\n        if rightWorkers:\n          ans2=rightWorkers[0][0]\n        else:\n          ans2=math.inf\n        ans=min(ans1,ans2)\n\n    return ans", "tests": ["def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(1, 1, [[1, 1, 1, 1]]) == 2", "def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(2, 2, [[1, 1, 1, 1], [1, 1, 1, 1]]) == 4", "def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(1, 2, [[3, 0, 1, 0], [1, 3, 0, 1]]) == 6", "def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(3, 1, [[2, 4, 3, 1]]) == 9", "def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(0, 1, [[2, 4, 3, 1]]) == 6", "def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(10, 5, [[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]]) == 78", "def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(2, 3, [[10, 0, 1, 0], [5, 0, 5, 0], [1, 10, 1, 1]]) == 26", "def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(100, 10, [[1, 1, 1, 1]] * 10) == 200", "def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(0, 0, []) == 0", "def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(1, 1, [[2, 0, 3, 0]]) == 6", "def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(3, 2, [[1, 5, 3, 4], [2, 3, 2, 1]]) == 18", "def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(10, 5, [[10, 20, 30, 40], [20, 30, 40, 50], [30, 40, 50, 60]]) == 780", "def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(2, 3, [[10, 10, 10, 10], [10, 10, 10, 10], [10, 10, 10, 10]]) == 60", "def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(1, 1, [[50, 0, 60, 0]]) == 110", "def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(10, 5, [[1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4]]) == 60", "def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(3, 5, [[10, 2, 1, 4], [9, 3, 2, 5], [8, 4, 3, 6]]) == 42", "def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(1, 1, [[10, 20, 30, 40]]) == 130", "def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(1, 1, [[100, 200, 300, 400]]) == 800", "def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(1, 1, [[1, 1, 1, 1]]) == 2", "def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(0, 3, [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) == 0"]}
{"task_num": 2577, "task_title": "Minimum Time to Visit a Cell In a Grid", "func_name": "minimumTime", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumTime(self, grid: List[List[int]]) -> int:\n    if grid[0][1] > 1 and grid[1][0] > 1:\n      return -1\n\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    minHeap = [(0, 0, 0)]\n    seen = {(0, 0)}\n\n    while minHeap:\n      time, i, j = heapq.heappop(minHeap)\n      if i == m - 1 and j == n - 1:\n        return time\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if (x, y) in seen:\n          continue\n        if (grid[x][y] - time) % 2 == 0:\n          extraWait = 1\n        else:\n          extraWait = 0\n        nextTime = max(time + 1, grid[x][y] + extraWait)\n        heapq.heappush(minHeap, (nextTime, x, y))\n        seen.add((x, y))\n", "tests": ["def test_minimumTime():\n    solution = Solution()\n    grid = [[0, 2], [1, 4]]\n    assert solution.minimumTime(grid) == -1", "def test_minimumTime():\n    solution = Solution()\n    grid = [[0, 1], [2, 3]]\n    assert solution.minimumTime(grid) == 4", "def test_minimumTime():\n    solution = Solution()\n    grid = [[0, 1], [2, 0]]\n    assert solution.minimumTime(grid) == -1", "def test_minimumTime():\n    solution = Solution()\n    grid = [[0, 3], [1, 2]]\n    assert solution.minimumTime(grid) == 4", "def test_minimumTime():\n    solution = Solution()\n    grid = [[0, 1], [2, 4]]\n    assert solution.minimumTime(grid) == 6", "def test_minimumTime():\n    solution = Solution()\n    grid = [[0, 2], [1, 3]]\n    assert solution.minimumTime(grid) == -1", "def test_minimumTime():\n    solution = Solution()\n    grid = [[0, 3], [2, 1]]\n    assert solution.minimumTime(grid) == -1", "def test_minimumTime():\n    solution = Solution()\n    grid = [[0, 2], [3, 1]]\n    assert solution.minimumTime(grid) == -1", "def test_minimumTime():\n    solution = Solution()\n    grid = [[0, 1], [2, 5]]\n    assert solution.minimumTime(grid) == 6", "def test_minimumTime():\n    solution = Solution()\n    grid = [[0, 2], [1, 4]]\n    assert solution.minimumTime(grid) == -1", "def test_minimumTime():\n    solution = Solution()\n    grid = [[0, 2], [3, 1]]\n    assert solution.minimumTime(grid) == -1", "def test_minimumTime():\n    solution = Solution()\n    grid = [[0, 3], [2, 1]]\n    assert solution.minimumTime(grid) == -1", "def test_minimumTime():\n    solution = Solution()\n    grid = [[0, 2], [1, 5]]\n    assert solution.minimumTime(grid) == -1", "def test_minimumTime():\n    solution = Solution()\n    grid = [[0, 3], [2, 4]]\n    assert solution.minimumTime(grid) == -1", "def test_minimumTime():\n    solution = Solution()\n    grid = [[0, 2], [3, 5]]\n    assert solution.minimumTime(grid) == -1", "def test_minimumTime():\n    solution = Solution()\n    grid = [[0, 2], [3, 5]]\n    assert solution.minimumTime(grid) == -1", "def test_minimumTime():\n    solution = Solution()\n    grid = [[0, 2], [3, 5]]\n    assert solution.minimumTime(grid) == -1", "def test_minimumTime():\n    solution = Solution()\n    grid = [[0, 2], [3, 5]]\n    assert solution.minimumTime(grid) == -1", "def test_minimumTime():\n    solution = Solution()\n    grid = [[0, 2], [3, 5]]\n    assert solution.minimumTime(grid) == -1", "def test_minimumTime():\n    solution = Solution()\n    grid = [[0, 2], [3, 5]]\n    assert solution.minimumTime(grid) == -1"]}
{"task_num": 2601, "task_title": "Prime Subtraction Operation", "func_name": "primeSubOperation", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def primeSubOperation(self, nums: List[int]) -> bool:\n    kMax = 1000\n    primes = self._sieveEratosthenes(kMax)\n\n    prevNum = 0\n    for num in nums:\n      i = bisect.bisect_left(primes, num - prevNum)\n      if i > 0:\n        num -= primes[i - 1]\n      if num <= prevNum:\n        return False\n      prevNum = num\n\n    return True\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return [i for i in range(n) if isPrime[i]]\n", "tests": ["def test_primeSubOperation():\n    solution = Solution()\n    assert solution.primeSubOperation([5, 7, 10]) == True", "def test_primeSubOperation():\n    solution = Solution()\n    assert solution.primeSubOperation([10, 5, 7]) == False", "def test_primeSubOperation():\n    solution = Solution()\n    assert solution.primeSubOperation([15, 30, 45]) == False", "def test_primeSubOperation():\n    solution = Solution()\n    assert solution.primeSubOperation([10, 3, 7, 20]) == True", "def test_primeSubOperation():\n    solution = Solution()\n    assert solution.primeSubOperation([-5, 10, -3]) == False", "def test_primeSubOperation():\n    solution = Solution()\n    assert solution.primeSubOperation([]) == True", "def test_primeSubOperation():\n    solution = Solution()\n    assert solution.primeSubOperation([5, 2, 2, 4]) == False", "def test_primeSubOperation():\n    solution = Solution()\n    assert solution.primeSubOperation([1000, 2000, 3000, 4000]) == True", "def test_primeSubOperation():\n    solution = Solution()\n    assert solution.primeSubOperation([500, 2, 500]) == False", "def test_primeSubOperation():\n    solution = Solution()\n    assert solution.primeSubOperation([5, 2, 2, 4]) == False", "def test_primeSubOperation():\n    solution = Solution()\n    assert solution.primeSubOperation([500, 2, 500, 7]) == False", "def test_primeSubOperation():\n    solution = Solution()\n    assert solution.primeSubOperation([5, 2, 4, 6]) == False", "def test_primeSubOperation():\n    solution = Solution()\n    assert solution.primeSubOperation([500, 2, 4, 6, 7]) == False", "def test_primeSubOperation():\n    solution = Solution()\n    assert solution.primeSubOperation([500, 2, 4, 6, 7, 10]) == False", "def test_primeSubOperation():\n    solution = Solution()\n    assert solution.primeSubOperation([500, 2, 4, 6, 7, 10, 13]) == False", "def test_primeSubOperation():\n    solution = Solution()\n    assert solution.primeSubOperation([500, 2, 4, 6, 7, 10, 13, 17]) == False", "def test_primeSubOperation():\n    solution = Solution()\n    assert solution.primeSubOperation([500, 2, 4, 6, 7, 10, 13, 17, 19]) == False", "def test_primeSubOperation():\n    solution = Solution()\n    assert solution.primeSubOperation([500, 2, 4, 6, 7, 10, 13, 17, 19, 23]) == False", "def test_primeSubOperation():\n    solution = Solution()\n    assert solution.primeSubOperation([2, 2, 2]) == False", "def test_primeSubOperation():\n    solution = Solution()\n    large_value = 10 ** 9 + 1\n    assert solution.primeSubOperation([large_value - 2, large_value - 1, large_value]) == False"]}
{"task_num": 2603, "task_title": "Collect Coins in a Tree", "func_name": "collectTheCoins", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def collectTheCoins(self, coins: List[int], edges: List[List[int]]) -> int:\n    n = len(coins)\n    tree = [set() for _ in range(n)]\n    leavesToBeRemoved = collections.deque()\n\n    for u, v in edges:\n      tree[u].add(v)\n      tree[v].add(u)\n\n    for u in range(n):\n      while len(tree[u]) == 1 and coins[u] == 0:\n        v = tree[u].pop()\n        tree[v].remove(u)\n        u = v\n      if len(tree[u]) == 1:\n        leavesToBeRemoved.append(u)\n\n    for _ in range(2):\n      for _ in range(len(leavesToBeRemoved)):\n        u = leavesToBeRemoved.popleft()\n        if tree[u]:\n          v = tree[u].pop()\n          tree[v].remove(u)\n          if len(tree[v]) == 1:\n            leavesToBeRemoved.append(v)\n\n    return sum(len(children) for children in tree)\n", "tests": ["def test_collectTheCoins():\n    solution = Solution()\n    coins = [0, 1, 0, 0]\n    edges = [[0, 1], [1, 2], [1, 3]]\n    assert solution.collectTheCoins(coins, edges) == 2", "def test_collectTheCoins():\n    solution = Solution()\n    coins = [1, 0, 1, 0]\n    edges = [[0, 1], [1, 2], [1, 3]]\n    assert solution.collectTheCoins(coins, edges) == 4", "def test_collectTheCoins():\n    solution = Solution()\n    coins = [1]\n    edges = []\n    assert solution.collectTheCoins(coins, edges) == 0", "def test_collectTheCoins():\n    solution = Solution()\n    coins = [1, 1, 1]\n    edges = [[0, 1], [0, 2]]\n    assert solution.collectTheCoins(coins, edges) == 2", "def test_collectTheCoins():\n    solution = Solution()\n    coins = [0, 1, 1]\n    edges = [[0, 1], [0, 2]]\n    assert solution.collectTheCoins(coins, edges) == 4", "def test_collectTheCoins():\n    solution = Solution()\n    n = 10\n    coins = [1] * n\n    edges = [[i, (i + 1) % n] for i in range(n)]\n    assert solution.collectTheCoins(coins, edges) == 4", "def test_collectTheCoins():\n    solution = Solution()\n    coins = [0] * 5\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4]]\n    assert solution.collectTheCoins(coins, edges) == 8", "def test_collectTheCoins():\n    solution = Solution()\n    coins = [1, 0, 1]\n    edges = [[0, 2]]\n    assert solution.collectTheCoins(coins, edges) == 4", "def test_collectTheCoins():\n    solution = Solution()\n    coins = [1, 0, 1, 0, 1]\n    edges = [[0, 1], [1, 2], [2, 3], [2, 4]]\n    assert solution.collectTheCoins(coins, edges) == 6", "def test_collectTheCoins():\n    solution = Solution()\n    coins = [1, 0, 0, 0]\n    edges = [[0, 1], [0, 2], [2, 3]]\n    assert solution.collectTheCoins(coins, edges) == 4", "def test_collectTheCoins():\n    solution = Solution()\n    coins = [1, 1, 0]\n    edges = [[0, 1], [0, 2]]\n    assert solution.collectTheCoins(coins, edges) == 4", "def test_collectTheCoins():\n    solution = Solution()\n    coins = [1, 0, 1, 0]\n    edges = [[0, 1], [1, 2], [1, 3]]\n    assert solution.collectTheCoins(coins, edges) == 4", "def test_collectTheCoins():\n    solution = Solution()\n    coins = [1, 1, 1]\n    edges = [[0, 1], [1, 2]]\n    assert solution.collectTheCoins(coins, edges) == 4", "def test_collectTheCoins():\n    solution = Solution()\n    coins = [1, 1, 1, 0]\n    edges = [[0, 1], [1, 2]]\n    assert solution.collectTheCoins(coins, edges) == 6", "def test_collectTheCoins():\n    solution = Solution()\n    coins = [1, 0, 0, 0, 0]\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4]]\n    assert solution.collectTheCoins(coins, edges) == 8", "", "def test_collectTheCoins():\n    solution = Solution()\n    coins = [1, 0, 0, 0, 1]\n    edges = [[0, 1], [1, 2], [2, 3]]\n    assert solution.collectTheCoins(coins, edges) == 6", "def test_collectTheCoins():\n    solution = Solution()\n    coins = [1, 0, 1, 0, 1]\n    edges = [[0, 1], [1, 2], [2, 3], [2, 4]]\n    assert solution.collectTheCoins(coins, edges) == 8", "def test_collectTheCoins():\n    solution = Solution()\n    coins = [1, 0, 0, 0, 1, 0]\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4], [0, 5]]\n    assert solution.collectTheCoins(coins, edges) == 10", "def test_collectTheCoins():\n    solution = Solution()\n    coins = [1, 0, 1, 0, 1, 0]\n    edges = [[0, 1], [1, 2], [1, 3], [3, 4], [3, 5]]\n    assert solution.collectTheCoins(coins, edges) == 8"]}
{"task_num": 2653, "task_title": "Sliding Subarray Beauty", "func_name": "getSubarrayBeauty", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\n    ans = []\n    count = [0] * 50\n\n    for i, num in enumerate(nums):\n      if num < 0:\n        count[num + 50] += 1\n      if i - k >= 0 and nums[i - k] < 0:\n        count[nums[i - k] + 50] -= 1\n      if i + 1 >= k:\n        ans.append(self._getXthSmallestNum(count, x))\n\n    return ans\n\n  def _getXthSmallestNum(self, count: List[int], x: int) -> int:\n    prefix = 0\n    for i in range(50):\n      prefix += count[i]\n      if prefix >= x:\n        return i - 50\n    return 0\n", "tests": ["def test_getSubarrayBeauty():\n    solution = Solution()\n    assert solution.getSubarrayBeauty([1, 3, 5, 2, 4, -6], 3, 2) == [0, -6]", "def test_getSubarrayBeauty():\n    solution = Solution()\n    assert solution.getSubarrayBeauty([-1, -2, 0, 1, 2], 4, 3) == [0] * 2", "def test_getSubarrayBeauty():\n    solution = Solution()\n    assert solution.getSubarrayBeauty([-5, -4, -3, -2, -1], 2, 1) == [-5, -5] * 2", "def test_getSubarrayBeauty():\n    solution = Solution()\n    assert solution.getSubarrayBeauty([10, -2, 3, -4, 5, -6], 5, 4) == [0, 0] * 2", "def test_getSubarrayBeauty():\n    solution = Solution()\n    assert solution.getSubarrayBeauty([-1, -3, -5, -7, -9], 3, 2) == [0] * 3", "def test_getSubarrayBeauty():\n    solution = Solution()\n    assert solution.getSubarrayBeauty([1, -2, 3, -4, 5], 3, 1) == [-2, -4]", "def test_getSubarrayBeauty():\n    solution = Solution()\n    assert solution.getSubarrayBeauty([0, 0, 0, 0, 0], 2, 1) == [0] * 3", "def test_getSubarrayBeauty():\n    solution = Solution()\n    assert solution.getSubarrayBeauty([1, 2, -3, 4, -5, 6], 4, 2) == [0] * 3", "def test_getSubarrayBeauty():\n    solution = Solution()\n    assert solution.getSubarrayBeauty([-1, -2, -3, 4, 5], 5, 3) == [0] * 2", "def test_getSubarrayBeauty():\n    solution = Solution()\n    assert solution.getSubarrayBeauty([1, -2, -3, 4, -5], 3, 2) == [-2, -3]", "def test_getSubarrayBeauty():\n    solution = Solution()\n    assert solution.getSubarrayBeauty([10, 20, -30, -40, 50], 4, 1) == [-30] * 3", "def test_getSubarrayBeauty():\n    solution = Solution()\n    assert solution.getSubarrayBeauty([-1, 2, -3, 4], 2, 1) == [-1] * 2", "def test_getSubarrayBeauty():\n    solution = Solution()\n    assert solution.getSubarrayBeauty([0, -1, -2, 3], 4, 2) == [0, -1]", "def test_getSubarrayBeauty():\n    solution = Solution()\n    assert solution.getSubarrayBeauty([-10, -20, 30, -40, 50], 5, 3) == [0] * 2", "def test_getSubarrayBeauty():\n    solution = Solution()\n    assert solution.getSubarrayBeauty([1, 3, -5, 2, 4, -6], 3, 2) == [0, -6]", "def test_getSubarrayBeauty():\n    solution = Solution()\n    assert solution.getSubarrayBeauty([-1, -3, 5, -7, 9], 4, 2) == [0] * 2", "def test_getSubarrayBeauty():\n    solution = Solution()\n    assert solution.getSubarrayBeauty([10, -2, 3, -4, 5, -6], 5, 4) == [0] * 2", "def test_getSubarrayBeauty():\n    solution = Solution()\n    assert solution.getSubarrayBeauty([-1, -3, -5, 4, 2], 3, 1) == [-5] * 3", "def test_getSubarrayBeauty():\n    solution = Solution()\n    assert solution.getSubarrayBeauty([10, -2, 3, -4], 4, 1) == [0] * 3", "def test_getSubarrayBeauty():\n    solution = Solution()\n    assert solution.getSubarrayBeauty([-1, -2, 0, 1, 2], 3, 2) == [0] * 2"]}
{"task_num": 2662, "task_title": "Minimum Cost of a Path With Special Roads", "func_name": "minimumCost", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\n    return self.dijkstra(specialRoads, *start, *target)\n\n  def dijkstra(self, specialRoads: List[List[int]], srcX: int, srcY: int, dstX: int, dstY: int) -> int:\n    n = len(specialRoads)\n    dist = [math.inf] * n\n    minHeap = []\n\n    for u, (x1, y1, _, _, cost) in enumerate(specialRoads):\n      d = abs(x1 - srcX) + abs(y1 - srcY) + cost\n      dist[u] = d\n      heapq.heappush(minHeap, (dist[u], u))\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      _, _, ux2, uy2, _ = specialRoads[u]\n      for v in range(n):\n        if v == u:\n          continue\n        vx1, vy1, _, _, vcost = specialRoads[v]\n        newDist = d + abs(vx1 - ux2) + abs(vy1 - uy2) + vcost\n        if newDist < dist[v]:\n          dist[v] = newDist\n          heapq.heappush(minHeap, (dist[v], v))\n\n    ans = abs(dstX - srcX) + abs(dstY - srcY)\n    for u in range(n):\n      _, _, x2, y2, _ = specialRoads[u]\n      ans = min(ans, dist[u] + abs(dstX - x2) + abs(dstY - y2))\n\n    return ans\n", "tests": ["def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost([0, 0], [10, 10], [[2, 2, 5, 5, 7]]) == 26", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost([0, 0], [10, 10], []) == 20", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost([0, 0], [1000, 1000], [[500, 500, 750, 750, 1000]]) == 2000", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost([0, 0], [10, -10], [[5, -5, 15, -15, 2]]) == 40", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost([0, 0], [10, 0], [[5, 0, 15, 0, 2]]) == 4", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost([0, 0], [10000, 10000], [[5000, 5000, 7500, 7500, 2000]]) == 4000", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost([0, 0], [10, 10], [[2, 2, 5, 5, -7]]) == 26", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost([0, 0], [10, 10], [[5, 5, 5, 5, 7]]) == 26", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost([0, 0], [10, 10], [[2, 2, 5, 5, 7], [6, 6, 9, 9, 3]]) == 24", "def test_minimumCost():\n    solution = Solution()\n    special_roads = [[i, i, i + 1, i + 1, 1] for i in range(100)]\n    assert solution.minimumCost([0, 0], [100, 100], special_roads) == 400", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost([-100, -100], [100, 100], [[-50, -50, 50, 50, -2]]) == 400", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost([0, 0], [10, 10], [[2, 2, 5, 5, 7], [8, 8, 3, 3, 7]]) == 46", "def test_minimumCost():\n    start = 0\n    end = 5\n    special_roads = [[0, 1, 2], [1, 2, -3], [2, 4, 1]]\n    expected_result = float('inf')\n    assert solution.minimumCost(start, end, special_roads) == expected_result", "def test_minimumCost():\n    start = 0\n    end = 7\n    special_roads = [[0, 1, 2], [1, 2, 3], [4, 5, 6], [6, 7, 8]]\n    expected_result = float('inf')\n    assert solution.minimumCost(start, end, special_roads) == expected_result", "def test_minimumCost():\n    start = 0\n    end = 4\n    special_roads = [[0, 1, 2], [1, 2, 3], [2, 3, 4], [0, 2, 8], [2, 4, 5]]\n    expected_result = 6\n    assert solution.minimumCost(start, end, special_roads) == expected_result", "def test_minimumCost():\n    start = 0\n    end = 4\n    special_roads = [[0, 1, 1], [1, 2, 2], [2, 3, 3], [3, 4, 4], [0, 2, 6], [2, 4, 5]]\n    expected_result = 7\n    assert solution.minimumCost(start, end, special_roads) == expected_result", "def test_minimumCost():\n    start = 0\n    end = 4\n    special_roads = [[0, 1, 2], [1, 2, 3], [2, 3, 0], [2, 4, 5]]\n    expected_result = 6\n    assert solution.minimumCost(start, end, special_roads) == expected_result", "def test_minimumCost():\n    start = 0\n    end = 4\n    special_roads = [[0, 1, 2], [1, 2, 3], [2, 3, 4], [0, 2, 6], [2, 4, 5]]\n    expected_result = 7\n    assert solution.minimumCost(start, end, special_roads) == expected_result", "def test_minimumCost():\n    start = 0\n    end = 4\n    special_roads = [[0, 1, 2], [1, 2, 3], [2, 3, 4], [0, 2, 6], [2, 4, 5], [0, 2, 3, 4]]\n    expected_result = 6\n    assert solution.minimumCost(start, end, special_roads) == expected_result", "def test_minimumCost():\n    start = 0\n    end = 4\n    special_roads = [[0, 1, 2], [1, 2, 3], [2, 3, 4], [0, 2, 6], [2, 4, 5], [0, 2, 3, 4]]\n    expected_result = 6\n    assert solution.minimumCost(start, end, special_roads) == expected_result"]}
{"task_num": 2663, "task_title": "Lexicographically Smallest Beautiful String", "func_name": "smallestBeautifulString", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def smallestBeautifulString(self, s: str, k: int) -> str:\n    chars = list(s)\n\n    for i in reversed(range(len(chars))):\n      chars[i] = chr(ord(chars[i]) + 1)\n      while self._containsPalindrome(chars, i):\n        chars[i] = chr(ord(chars[i]) + 1)\n      if chars[i] < chr(ord('a') + k):\n        return self._changeSuffix(chars, i + 1)\n\n    return ''\n\n  def _containsPalindrome(self, chars: List[str], i: int) -> bool:\n    return (i > 0 and chars[i] == chars[i - 1]) or (i > 1 and chars[i] == chars[i - 2])\n\n  def _changeSuffix(self, chars: List[str], i: int) -> str:\n    for j in range(i, len(chars)):\n      chars[j] = 'a'\n      while self._containsPalindrome(chars, j):\n        chars[j] = chr(ord(chars[j]) + 1)\n    return ''.join(chars)\n", "tests": ["def test_smallestBeautifulString():\n    solution = Solution()\n    assert solution.smallestBeautifulString('abc', 3) == 'abd'", "def test_smallestBeautifulString():\n    solution = Solution()\n    assert solution.smallestBeautifulString('aa', 2) == 'ab'", "def test_smallestBeautifulString():\n    solution = Solution()\n    assert solution.smallestBeautifulString('zz', 26) == 'aabb'", "def test_smallestBeautifulString():\n    solution = Solution()\n    assert solution.smallestBeautifulString('abcc', 4) == 'abdc'", "def test_smallestBeautifulString():\n    solution = Solution()\n    assert solution.smallestBeautifulString('z', 26) == 'aa'", "def test_smallestBeautifulString():\n    solution = Solution()\n    assert solution.smallestBeautifulString('aaa', 3) == 'aab'", "def test_smallestBeautifulString():\n    solution = Solution()\n    assert solution.smallestBeautifulString('abcde', 5) == 'abcdf'", "def test_smallestBeautifulString():\n    solution = Solution()\n    assert solution.smallestBeautifulString('ababa', 3) == 'ababc'", "def test_smallestBeautifulString():\n    solution = Solution()\n    assert solution.smallestBeautifulString('aaaazz', 6) == 'aabaaa'", "def test_smallestBeautifulString():\n    solution = Solution()\n    assert solution.smallestBeautifulString('zzzzz', 26) == 'aabbcc'", "def test_smallestBeautifulString():\n    solution = Solution()\n    assert solution.smallestBeautifulString('abc', 2) == ''", "def test_smallestBeautifulString():\n    solution = Solution()\n    assert solution.smallestBeautifulString('abcde', 3) == 'abcdf'", "def test_smallestBeautifulString():\n    solution = Solution()\n    assert solution.smallestBeautifulString('abcde', 5) == 'abcdf'", "def test_smallestBeautifulString():\n    solution = Solution()\n    assert solution.smallestBeautifulString('abcde', 3) == 'abcdf'", "def test_smallestBeautifulString():\n    solution = Solution()\n    assert solution.smallestBeautifulString('zzzzz', 26) == 'aabbcc'", "def test_smallestBeautifulString():\n    solution = Solution()\n    assert solution.smallestBeautifulString('ababab', 3) == 'ababac'", "def test_smallestBeautifulString():\n    solution = Solution()\n    assert solution.smallestBeautifulString('abcc', 4) == 'abdc'", "def test_smallestBeautifulString():\n    solution = Solution()\n    assert solution.smallestBeautifulString('zz', 26) == 'aabb'", "def test_smallestBeautifulString():\n    solution = Solution()\n    assert solution.smallestBeautifulString('abc', 2) == ''", "def test_smallestBeautifulString():\n    solution = Solution()\n    assert solution.smallestBeautifulString('abcde', 5) == 'abcdf'"]}
{"task_num": 2672, "task_title": "Number of Adjacent Elements With the Same Color", "func_name": "colorTheArray", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\n    ans = []\n    arr = [0] * n\n    sameColors = 0\n\n    for i, color in queries:\n      if i + 1 < n:\n        if arr[i + 1] > 0 and arr[i + 1] == arr[i]:\n          sameColors -= 1\n        if arr[i + 1] == color:\n          sameColors += 1\n      if i > 0:\n        if arr[i - 1] > 0 and arr[i - 1] == arr[i]:\n          sameColors -= 1\n        if arr[i - 1] == color:\n          sameColors += 1\n      arr[i] = color\n      ans.append(sameColors)\n\n    return ans\n", "tests": ["def test_colorTheArray():\n    solution = Solution()\n    result = solution.colorTheArray(5, [[0, 1], [4, 2], [3, 1], [1, 1]])", "def test_colorTheArray():\n    solution = Solution()\n    result = solution.colorTheArray(3, [[0, 1], [1, 2], [2, 3], [1, 1]])", "def test_colorTheArray():\n    solution = Solution()\n    result = solution.colorTheArray(4, [[0, 1], [2, 1], [3, 2], [1, 3]])", "def test_colorTheArray():\n    solution = Solution()\n    result = solution.colorTheArray(6, [[0, 1], [2, 1], [4, 3], [5, 3]])", "def test_colorTheArray():\n    solution = Solution()\n    result = solution.colorTheArray(7, [[0, 1], [1, 2], [3, 2], [4, 1]])", "def test_colorTheArray():\n    solution = Solution()\n    result = solution.colorTheArray(5, [[0, 1], [2, 1], [3, 2], [4, 2]])", "def test_colorTheArray():\n    solution = Solution()\n    result = solution.colorTheArray(3, [[0, 1], [1, 2], [2, 3]])", "def test_colorTheArray():\n    solution = Solution()\n    result = solution.colorTheArray(4, [[0, 1], [1, 2], [2, 3], [3, 4]])", "def test_colorTheArray():\n    solution = Solution()\n    result = solution.colorTheArray(6, [[0, 1], [2, 1], [3, 2], [4, 2], [5, 3]])", "def test_colorTheArray():\n    solution = Solution()\n    result = solution.colorTheArray(5, [[0, 1], [2, 2], [3, 1]])", "def test_colorTheArray():\n    solution = Solution()\n    result = solution.colorTheArray(4, [[0, 1], [2, 1], [1, 2], [3, 2]])", "def test_colorTheArray():\n    solution = Solution()\n    result = solution.colorTheArray(3, [[0, 1], [1, 2], [2, 1]])", "def test_colorTheArray():\n    solution = Solution()\n    result = solution.colorTheArray(5, [[0, 1], [2, 3], [4, 3]])", "def test_colorTheArray():\n    solution = Solution()\n    result = solution.colorTheArray(4, [[0, 1], [1, 2], [2, 3], [3, 2]])", "def test_colorTheArray():\n    solution = Solution()\n    result = solution.colorTheArray(5, [[0, 1], [2, 1], [4, 3]])", "def test_colorTheArray():\n    solution = Solution()\n    result = solution.colorTheArray(6, [[0, 1], [2, 1], [3, 2], [4, 2], [5, 3]])", "def test_colorTheArray():\n    solution = Solution()\n    result = solution.colorTheArray(5, [[0, 1], [2, 3], [4, 1]])", "def test_colorTheArray():\n    solution = Solution()\n    result = solution.colorTheArray(4, [[0, 1], [2, 1], [1, 2], [3, 2]])", "def test_colorTheArray():\n    solution = Solution()\n    result = solution.colorTheArray(5, [[0, 1], [2, 3], [4, 3]])", "def test_colorTheArray():\n    solution = Solution()\n    result = solution.colorTheArray(6, [[0, 1], [2, 1], [3, 2], [4, 2], [5, 3]])"]}
{"task_num": 2684, "task_title": "Maximum Number of Moves in a Grid", "func_name": "maxMoves", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxMoves(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n\n    for j in range(n - 2, -1, -1):\n      for i in range(m):\n        if grid[i][j + 1] > grid[i][j]:\n          dp[i][j] = 1 + dp[i][j + 1]\n        if i > 0 and grid[i - 1][j + 1] > grid[i][j]:\n          dp[i][j] = max(dp[i][j], 1 + dp[i - 1][j + 1])\n        if i + 1 < m and grid[i + 1][j + 1] > grid[i][j]:\n          dp[i][j] = max(dp[i][j], 1 + dp[i + 1][j + 1])\n\n    return max(dp[i][0] for i in range(m))\n", "tests": ["def test_maxMoves():\n    solution = Solution()\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    assert solution.maxMoves(grid) == 2", "def test_maxMoves():\n    solution = Solution()\n    grid = [[10, 9, 8], [7, 6, 5], [4, 3, 2]]\n    assert solution.maxMoves(grid) == 2", "def test_maxMoves():\n    solution = Solution()\n    grid = [[1], [2], [3]]\n    assert solution.maxMoves(grid) == 2", "def test_maxMoves():\n    solution = Solution()\n    grid = [[1, 2, 3], [4, 5, 6], [4, 5, 7]]\n    assert solution.maxMoves(grid) == 1", "def test_maxMoves():\n    solution = Solution()\n    grid = [[3, 2, 1], [6, 5, 4], [9, 8, 7], [12, 11, 10]]\n    assert solution.maxMoves(grid) == 3", "def test_maxMoves():\n    solution = Solution()\n    grid = [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\n    assert solution.maxMoves(grid) == 0", "def test_maxMoves():\n    solution = Solution()\n    (m, n) = (100, 100)\n    grid = [[i * n + j for j in range(n)] for i in range(m)]\n    assert solution.maxMoves(grid) == n - 2", "def test_maxMoves():\n    solution = Solution()\n    grid = [[5]]\n    assert solution.maxMoves(grid) == 0", "def test_maxMoves():\n    solution = Solution()\n    grid = [[1, 3, 2], [4, 6, 5], [7, 9, 8]]\n    assert solution.maxMoves(grid) == 2", "def test_maxMoves():\n    solution = Solution()\n    grid = [[1, 3], [4, 2]]\n    assert solution.maxMoves(grid) == 1", "def test_maxMoves():\n    solution = Solution()\n    grid = [[1, 2], [3, 4]]\n    assert solution.maxMoves(grid) == 1", "def test_maxMoves():\n    solution = Solution()\n    grid = [[9, 8, 7], [6, 5, 4], [3, 2, 1]]\n    assert solution.maxMoves(grid) == 2", "def test_maxMoves():\n    solution = Solution()\n    grid = [[1, 4, 7], [2, 5, 8], [3, 6, 9]]\n    assert solution.maxMoves(grid) == 2", "def test_maxMoves():\n    import random\n    solution = Solution()\n    (m, n) = (10, 15)\n    grid = [[random.randint(1, 20) for _ in range(n)] for _ in range(m)]\n    max_moves = solution.maxMoves(grid)", "def test_maxMoves():\n    import random\n    solution = Solution()\n    (m, n) = (50, 75)\n    grid = [[random.randint(1, 20) for _ in range(n)] for _ in range(m)]\n    max_moves = solution.maxMoves(grid)", "def test_maxMoves():\n    solution = Solution()\n    grid = [[1, 3, 5]]\n    assert solution.maxMoves(grid) == 2", "def test_maxMoves():\n    solution = Solution()\n    grid = [[1], [2], [2]]\n    assert solution.maxMoves(grid) == 0", "def test_maxMoves():\n    solution = Solution()\n    grid = [[1, 2], [3, 4], [4, 5]]\n    assert solution.maxMoves(grid) == 1", "def test_maxMoves():\n    solution = Solution()\n    grid = [[9, 8, 7], [6, 5, 4], [3, 2, 2]]\n    assert solution.maxMoves(grid) == 1", "def test_maxMoves():\n    solution = Solution()\n    grid = [[1, 3, 2], [4, 5, 5], [7, 9, 8]]\n    assert solution.maxMoves(grid) == 1"]}
{"task_num": 2685, "task_title": "Count the Number of Complete Components", "func_name": "countCompleteComponents", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n    self.nodeCount = [1] * n\n    self.edgeCount = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    self.edgeCount[i] += 1\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n      self.edgeCount[j] += self.edgeCount[i]\n      self.nodeCount[j] += self.nodeCount[i]\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n      self.edgeCount[i] += self.edgeCount[j]\n      self.nodeCount[i] += self.nodeCount[j]\n    else:\n      self.id[i] = j\n      self.edgeCount[j] += self.edgeCount[i]\n      self.nodeCount[j] += self.nodeCount[i]\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n  def isComplete(self, u):\n    return self.nodeCount[u] * (self.nodeCount[u] - 1) // 2 == self.edgeCount[u]\n\n\nclass Solution:\n  def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\n    ans = 0\n    uf = UnionFind(n)\n    parents = set()\n\n    for u, v in edges:\n      uf.unionByRank(u, v)\n\n    for i in range(n):\n      parent = uf.find(i)\n      if parent not in parents and uf.isComplete(parent):\n        ans += 1\n        parents.add(parent)\n\n    return ans\n", "tests": ["def test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(4, [[0, 1], [1, 2], [2, 3]]) == 1", "def test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(5, [[0, 1], [1, 2], [2, 3], [3, 4]]) == 1", "def test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(6, [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [0, 5]]) == 1", "def test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(3, [[0, 1], [1, 2], [2, 0]]) == 1", "def test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(7, [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 0]]) == 1", "def test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(8, [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 0]]) == 1", "def test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(9, [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8]]) == 1", "def test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(5, [[0, 2], [1, 3], [1, 4]]) == 0", "def test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(6, [[0, 1], [1, 2], [3, 4], [4, 5]]) == 1", "def test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(7, [[0, 1], [1, 2], [3, 4], [4, 5], [6, 0]]) == 2", "def test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(8, [[0, 1], [1, 2], [3, 4], [4, 5], [6, 7]]) == 2", "def test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(9, [[0, 1], [1, 2], [3, 4], [4, 5], [6, 7], [7, 8]]) == 3", "def test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(5, [[0, 2], [1, 3], [1, 4], [2, 3]]) == 1", "def test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(6, [[0, 1], [1, 2], [2, 3], [4, 5]]) == 2", "def test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(7, [[0, 1], [1, 2], [3, 4], [4, 5], [6, 0], [6, 1]]) == 2", "def test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(8, [[0, 1], [1, 2], [3, 4], [4, 5], [6, 7], [6, 0], [6, 1]]) == 2", "def test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(9, [[0, 1], [1, 2], [3, 4], [4, 5], [6, 7], [7, 8], [0, 5]]) == 2", "def test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(10, [[0, 1], [1, 2], [3, 4], [4, 5], [6, 7], [7, 8], [9, 0]]) == 1", "def test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(11, [[0, 1], [1, 2], [3, 4], [4, 5], [6, 7], [7, 8], [9, 0], [9, 1]]) == 2", "def test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(12, [[0, 1], [1, 2], [3, 4], [4, 5], [6, 7], [7, 8], [9, 0], [9, 1], [10, 11]]) == 2"]}
{"task_num": 2699, "task_title": "Modify Graph Edge Weights", "func_name": "modifiedGraphEdges", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\n\nclass Solution:\n  def modifiedGraphEdges(self, n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:\n    kMax = 2_000_000_000\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      if w == -1:\n        continue\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    distToDestination = self._dijkstra(graph, source, destination)\n    if distToDestination < target:\n      return []\n    if distToDestination == target:\n      for edge in edges:\n        if edge[2] == -1:\n          edge[2] = kMax\n      return edges\n\n    for i, (u, v, w) in enumerate(edges):\n      if w != -1:\n        continue\n      edges[i][2] = 1\n      graph[u].append((v, 1))\n      graph[v].append((u, 1))\n      distToDestination = self._dijkstra(graph, source, destination)\n      if distToDestination <= target:\n        edges[i][2] += target - distToDestination\n        for j in range(i + 1, len(edges)):\n          if edges[j][2] == -1:\n            edges[j][2] = kMax\n        return edges\n\n    return []\n\n  def _dijkstra(self, graph: List[List[int]], src: int, dst: int) -> int:\n    dist = [math.inf] * len(graph)\n    minHeap = []\n    dist[src] = 0\n    heapq.heappush(minHeap, (dist[src], src))\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist[dst]\n", "tests": ["def test_modifiedGraphEdges():\n    solution = Solution()\n    result = solution.modifiedGraphEdges(4, [[0, 1, -1], [1, 2, -1], [2, 3, -1], [0, 3, 5]], 0, 3, 6)", "def test_modifiedGraphEdges():\n    solution = Solution()\n    result = solution.modifiedGraphEdges(3, [[0, 1, -1], [1, 2, -1]], 0, 2, 4)", "def test_modifiedGraphEdges():\n    solution = Solution()\n    result = solution.modifiedGraphEdges(5, [[0, 1, -1], [1, 2, 3], [2, 3, -1], [3, 4, -1]], 0, 4, 6)", "def test_modifiedGraphEdges():\n    solution = Solution()\n    result = solution.modifiedGraphEdges(3, [[0, 1, -1], [1, 2, -1], [0, 2, -1]], 0, 2, 2)", "def test_modifiedGraphEdges():\n    solution = Solution()\n    result = solution.modifiedGraphEdges(4, [[0, 1, 2], [1, 2, -1], [2, 3, -1], [0, 3, 5]], 0, 3, 6)", "def test_modifiedGraphEdges():\n    solution = Solution()\n    result = solution.modifiedGraphEdges(5, [[0, 1, -1], [1, 2, -1], [2, 3, -1], [3, 4, -1]], 0, 4, 8)", "def test_modifiedGraphEdges():\n    solution = Solution()\n    result = solution.modifiedGraphEdges(4, [[0, 1, -1], [1, 2, -1], [2, 3, -1]], 0, 3, 9)", "def test_modifiedGraphEdges():\n    solution = Solution()\n    result = solution.modifiedGraphEdges(3, [[0, 1, -1], [1, 2, -1]], 0, 2, 5)", "def test_modifiedGraphEdges():\n    solution = Solution()\n    result = solution.modifiedGraphEdges(4, [[0, 1, -1], [1, 2, 3], [2, 3, -1], [0, 3, 5]], 0, 3, 7)", "def test_modifiedGraphEdges():\n    solution = Solution()\n    result = solution.modifiedGraphEdges(5, [[0, 1, -1], [1, 2, -1], [2, 3, -1], [3, 4, -1]], 0, 4, 10)", "def test_modifiedGraphEdges():\n    solution = Solution()\n    result = solution.modifiedGraphEdges(4, [[0, 1, -1], [1, 2, -1], [2, 3, -1]], 0, 3, 1)", "def test_modifiedGraphEdges():\n    solution = Solution()\n    result = solution.modifiedGraphEdges(5, [[0, 1, -1], [1, 2, -1], [2, 3, -1], [3, 4, -1]], 0, 4, 15)", "def test_modifiedGraphEdges():\n    solution = Solution()\n    result = solution.modifiedGraphEdges(3, [[0, 1, -1], [1, 2, 4], [0, 2, -1]], 0, 2, 8)", "def test_modifiedGraphEdges():\n    solution = Solution()\n    result = solution.modifiedGraphEdges(4, [[0, 1, -1], [1, 2, -1], [2, 3, -1]], 0, 3, 5)", "def test_modifiedGraphEdges():\n    solution = Solution()\n    result = solution.modifiedGraphEdges(5, [[0, 1, -1], [1, 2, -1], [2, 3, -1], [3, 4, -1]], 0, 4, 12)", "def test_modifiedGraphEdges():\n    solution = Solution()\n    result = solution.modifiedGraphEdges(3, [[0, 1, -1], [1, 2, -1]], 0, 2, 7)", "def test_modifiedGraphEdges():\n    solution = Solution()\n    result = solution.modifiedGraphEdges(4, [[0, 1, -1], [1, 2, 3], [2, 3, -1], [0, 3, 5]], 0, 3, 8)", "def test_modifiedGraphEdges():\n    solution = Solution()\n    result = solution.modifiedGraphEdges(5, [[0, 1, -1], [1, 2, -1], [2, 3, -1], [3, 4, -1]], 0, 4, 17)", "def test_modifiedGraphEdges():\n    solution = Solution()\n    result = solution.modifiedGraphEdges(3, [[0, 1, -1], [1, 2, 4], [0, 2, -1]], 0, 2, 9)", "def test_modifiedGraphEdges():\n    solution = Solution()\n    result = solution.modifiedGraphEdges(4, [[0, 1, -1], [1, 2, -1], [2, 3, -1]], 0, 3, 3)"]}
{"task_num": 2708, "task_title": "Maximum Strength of a Group", "func_name": "maxStrength", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxStrength(self, nums: List[int]) -> int:\n    posProd = 1\n    negProd = 1\n    maxNeg = -math.inf\n    negCount = 0\n    hasPos = False\n    hasZero = False\n\n    for num in nums:\n      if num > 0:\n        posProd *= num\n        hasPos = True\n      elif num < 0:\n        negProd *= num\n        maxNeg = max(maxNeg, num)\n        negCount += 1\n      else:\n        hasZero = True\n\n    if negCount == 0 and not hasPos:\n      return 0\n    if negCount % 2 == 0:\n      return negProd * posProd\n    if negCount >= 3:\n      return negProd // maxNeg * posProd\n    if hasPos:\n      return posProd\n    if hasZero:\n      return 0\n    return maxNeg\n", "tests": ["def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([-1, -2, -3]) == -6", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([0, 2, -3, -4]) == 24", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([-1, -1, 0, 5]) == 5", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([1, 2, 3, -1]) == 6", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([-2, -3, 0]) == 6", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([0, 0, 0]) == 0", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([-1, -2, 0, 0]) == 0", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([1, -2, 3, -4, 5]) == 120", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([-5, -4, -3, -2, -1]) == 120", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([1]) == 1", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([-1, -2, 0]) == 2", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([-1, -3, 2]) == 6", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([1, -2, 0, -3]) == 6", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([-1, -3, 2]) == 6", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([-1, -2, 0, -3]) == 6", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([1, -2, 0, 3]) == 6", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([-2, -3, 1]) == 6", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([0, 1, -2, -3]) == 6", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([-1, -2, 0]) == 2", "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([-1, -3, 2]) == 6"]}
{"task_num": 2709, "task_title": "Greatest Common Divisor Traversal", "func_name": "canTraverseAllPairs", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.sz = [1] * n\n\n  def unionBySize(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.sz[i] < self.sz[j]:\n      self.sz[j] += self.sz[i]\n      self.id[i] = j\n    else:\n      self.sz[i] += self.sz[j]\n      self.id[j] = i\n\n  def getSize(self, i: int) -> int:\n    return self.sz[i]\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def canTraverseAllPairs(self, nums: List[int]) -> bool:\n    n = len(nums)\n    max_num = max(nums)\n    maxPrimeFactor = self._sieveEratosthenes(max_num + 1)\n    primeToFirstIndex = collections.defaultdict(int)\n    uf = UnionFind(n)\n\n    for i, num in enumerate(nums):\n      for prime_factor in self._getPrimeFactors(num, maxPrimeFactor):\n        if prime_factor in primeToFirstIndex:\n          uf.unionBySize(primeToFirstIndex[prime_factor], i)\n        else:\n          primeToFirstIndex[prime_factor] = i\n\n    return any(uf.getSize(i) == n for i in range(n))\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeFactors(self, num: int, minPrimeFactors: List[int]) -> List[int]:\n    primeFactors = []\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      primeFactors.append(divisor)\n      while num % divisor == 0:\n        num //= divisor\n    return primeFactors\n", "tests": ["def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([2, 4, 8]) == True", "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([2, 3, 4]) == False", "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([10, 20]) == True", "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([12, 24, 6]) == True", "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([5, 10, 20]) == True", "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([7, 14]) == True", "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([30, 60]) == True", "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([2, 3, 5]) == False", "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([100, 200, 400]) == True", "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([1, 2, 3]) == False", "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([15, 30]) == True", "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([120, 240]) == True", "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([7, 14, 28]) == True", "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([10, 50]) == True", "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([12, 30]) == True", "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([16, 32]) == True", "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([8, 16]) == True", "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([24, 48]) == True", "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([12, 6]) == True", "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([7, 28]) == True"]}
{"task_num": 2736, "task_title": "Maximum Sum Queries", "func_name": "maximumSumQueries", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Pair:\n  def __init__(self, x: int, y: int):\n    self.x = x\n    self.y = y\n\n  def __iter__(self):\n    yield self.x\n    yield self.y\n\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, minX: int, minY: int):\n    self.queryIndex = queryIndex\n    self.minX = minX\n    self.minY = minY\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.minX\n    yield self.minY\n\n\nclass Solution:\n  def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n    pairs = sorted([Pair(nums1[i], nums2[i])\n                   for i in range(len(nums1))], key=lambda p: p.x, reverse=True)\n    ans = [0] * len(queries)\n    stack = []  # [(y, x + y)]\n\n    pairsIndex = 0\n    for queryIndex, minX, minY in sorted([IndexedQuery(i, query[0], query[1]) for i, query in enumerate(queries)], key=lambda iq: -iq.minX):\n      while pairsIndex < len(pairs) and pairs[pairsIndex].x >= minX:\n        x, y = pairs[pairsIndex]\n        while stack and x + y >= stack[-1][1]:\n          stack.pop()\n        if not stack or y > stack[-1][0]:\n          stack.append((y, x + y))\n        pairsIndex += 1\n      j = self._firstGreaterEqual(stack, minY)\n      if j == len(stack):\n        ans[queryIndex] = -1\n      else:\n        ans[queryIndex] = stack[j][1]\n\n    return ans\n\n  def _firstGreaterEqual(self, A: List[Tuple[int, int]], target: int) -> int:\n    l = 0\n    r = len(A)\n    while l < r:\n      m = (l + r) // 2\n      if A[m][0] >= target:\n        r = m\n      else:\n        l = m + 1\n    return l\n", "tests": ["def test_maximumSumQueries():\n    solution = Solution()\n    nums1 = [4, 3, 2, 7]\n    nums2 = [2, 5, 10, 6]\n    queries = [[3, 2], [1, 6]]\n    expected = [13, -1]\n    result = solution.maximumSumQueries(nums1, nums2, queries)", "def test_maximumSumQueries():\n    solution = Solution()\n    nums1 = [5, 7, 5, 9]\n    nums2 = [4, 6, 8, 3]\n    queries = [[5, 3], [7, 6], [5, 3], [9, 2]]\n    expected = [16, -1, 16, 18]\n    result = solution.maximumSumQueries(nums1, nums2, queries)", "def test_maximumSumQueries():\n    solution = Solution()\n    nums1 = [1]\n    nums2 = [2]\n    queries = [[0, 0], [1, 1]]\n    expected = [3, -1]\n    result = solution.maximumSumQueries(nums1, nums2, queries)", "def test_maximumSumQueries():\n    solution = Solution()\n    nums1 = [10 ** 9, 2 * 10 ** 9]\n    nums2 = [5 * 10 ** 8, 10 ** 8]\n    queries = [[5 * 10 ** 8, 3 * 10 ** 7], [2 * 10 ** 9, 4 * 10 ** 8]]\n    expected = [2 * 10 ** 9 + 2 * 10 ** 9, 3 * 10 ** 9]\n    result = solution.maximumSumQueries(nums1, nums2, queries)", "def test_maximumSumQueries():\n    solution = Solution()\n    nums1 = [2, 3, 5]\n    nums2 = [7, 6, 4]\n    queries = [[8, 9], [10, 11]]\n    expected = [-1, -1]\n    result = solution.maximumSumQueries(nums1, nums2, queries)", "def test_maximumSumQueries():\n    solution = Solution()\n    nums1 = [1, 2, 3, 4]\n    nums2 = [4, 3, 2, 1]\n    queries = [[1, 1], [2, 2], [3, 3], [4, 4]]\n    expected = [8, 7, 6, 5]\n    result = solution.maximumSumQueries(nums1, nums2, queries)", "def test_maximumSumQueries():\n    solution = Solution()\n    nums1 = [-2, 3, -5]\n    nums2 = [4, -6, 8]\n    queries = [[0, 0], [-5, -7]]\n    expected = [8, 2]\n    result = solution.maximumSumQueries(nums1, nums2, queries)", "def test_maximumSumQueries():\n    solution = Solution()\n    nums1 = [1, -2, 3, -4]\n    nums2 = [-5, 6, -7, 8]\n    queries = [[-3, 0], [1, -1]]\n    expected = [3, 1]\n    result = solution.maximumSumQueries(nums1, nums2, queries)", "def test_maximumSumQueries():\n    solution = Solution()\n    nums1 = [i % 10 for i in range(1000)]\n    nums2 = [(999 - i) % 10 for i in range(1000)]\n    queries = [[500, 400], [600, 300], [700, 200], [800, 100], [900, 0]]\n    expected = [999, 998, 997, 996, 995]\n    result = solution.maximumSumQueries(nums1, nums2, queries)", "def test_maximumSumQueries():\n    solution = Solution()\n    nums1 = []\n    nums2 = []\n    queries = []\n    expected = []\n    result = solution.maximumSumQueries(nums1, nums2, queries)", "def test_maximumSumQueries():\n    solution = Solution()\n    n = 10\n    nums1 = [i for i in range(n)]\n    nums2 = [n - i for i in range(n)]\n    queries = [[i, n - i] for i in range(n)]\n    expected = [2 * n - 2 * i for i in range(n)]\n    result = solution.maximumSumQueries(nums1, nums2, queries)", "def test_maximumSumQueries():\n    solution = Solution()\n    nums1 = [10, 20, 30]\n    nums2 = [5, 15, 25]\n    queries = [[15, 14], [25, 26]]\n    expected = [-1, -1]\n    result = solution.maximumSumQueries(nums1, nums2, queries)", "def test_maximumSumQueries():\n    solution = Solution()\n    nums1 = [2, 4, 6]\n    nums2 = [3, 5, 7]\n    queries = [[1, 0], [2, 0], [1, 0]]\n    expected = [9, 9, -1]\n    result = solution.maximumSumQueries(nums1, nums2, queries)", "def test_maximumSumQueries():\n    solution = Solution()\n    nums1 = [i for i in range(10 ** 6)]\n    nums2 = [(999999 - i) % 1000000 for i in range(10 ** 6)]\n    queries = [[5 * 10 ** 5, 4 * 10 ** 5], [7 * 10 ** 5, 3 * 10 ** 5]]\n    expected = [999998, 999997]\n    result = solution.maximumSumQueries(nums1, nums2, queries)", "def test_maximumSumQueries():\n    solution = Solution()\n    nums1 = [32, 58, 76, 92, 108]\n    nums2 = [21, 47, 63, 79, 95]\n    queries = [[60, 50], [80, 90], [20, 30]]\n    expected = [161, 187, -1]\n    result = solution.maximumSumQueries(nums1, nums2, queries)", "def test_maximumSumQueries():\n    solution = Solution()\n    nums1 = [2, 3, 5]\n    nums2 = [7, 6, 4]\n    queries = [[2, 1], [3, 2], [5, 0]]\n    expected = [9, 8, 7]\n    result = solution.maximumSumQueries(nums1, nums2, queries)", "def test_maximumSumQueries():\n    solution = Solution()\n    nums1 = [5, 7, 2]\n    nums2 = [8, 3, 9]\n    queries = [[8, 0], [6, 2]]\n    expected = [-1, -1]\n    result = solution.maximumSumQueries(nums1, nums2, queries)", "def test_maximumSumQueries():\n    solution = Solution()\n    nums1 = [1, 2]\n    nums2 = [3, 4]\n    queries = [[0, 0], [-1, -1]]\n    expected = [4, -1]\n    result = solution.maximumSumQueries(nums1, nums2, queries)", "def test_maximumSumQueries():\n    solution = Solution()\n    nums1 = [2, 4, 6]\n    nums2 = [3, 5, 7]\n    queries = [[1, 0], [2, 0], [1, 0]]\n    expected = [9, 9, 9]\n    result = solution.maximumSumQueries(nums1, nums2, queries)", "def test_maximumSumQueries():\n    solution = Solution()\n    nums1 = [1, 2, 3, 4]\n    nums2 = [-5, 6, -7, 8]\n    queries = [[-3, 0], [1, -1], [1, -1]]\n    expected = [3, 1, 1]\n    result = solution.maximumSumQueries(nums1, nums2, queries)"]}
{"task_num": 2747, "task_title": "Count Zero Request Servers", "func_name": "countServers", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, query: int):\n    self.queryIndex = queryIndex\n    self.query = query\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.query\n\n\nclass Solution:\n  def countServers(self, n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:\n    ans = [0] * len(queries)\n    count = [0] * (n + 1)\n\n    logs.sort(key=lambda log: log[1])\n\n    i = 0\n    j = 0\n    servers = 0\n\n    for queryIndex, query in sorted([IndexedQuery(i, query) for i, query in enumerate(queries)], key=lambda iq: iq.query):\n      while j < len(logs) and logs[j][1] <= query:\n        count[logs[j][0]] += 1\n        if count[logs[j][0]] == 1:\n          servers += 1\n        j += 1\n      while i < len(logs) and logs[i][1] < query - x:\n        count[logs[i][0]] -= 1\n        if count[logs[i][0]] == 0:\n          servers -= 1\n        i += 1\n      ans[queryIndex] = n - servers\n\n    return ans\n", "tests": ["def test_countServers():\n    solution = Solution()\n    assert solution.countServers(3, [[1, 1], [2, 2], [3, 3]], 1, [1, 2]) == [0, 0]", "def test_countServers():\n    solution = Solution()\n    assert solution.countServers(4, [[1, 1], [2, 3], [3, 5]], 2, [4, 6]) == [2, 0]", "def test_countServers():\n    solution = Solution()\n    assert solution.countServers(5, [[1, 1], [2, 4], [3, 7]], 3, [2, 5]) == [3, 1]", "def test_countServers():\n    solution = Solution()\n    assert solution.countServers(6, [[1, 2], [3, 4], [5, 6]], 1, [1, 6]) == [4, 0]", "def test_countServers():\n    solution = Solution()\n    assert solution.countServers(2, [[1, 1]], 1, [2]) == [0]", "def test_countServers():\n    solution = Solution()\n    assert solution.countServers(3, [[1, 5], [2, 6], [3, 7]], 4, [3, 8]) == [1, 0]", "def test_countServers():\n    solution = Solution()\n    assert solution.countServers(4, [[1, 1], [2, 3], [3, 5]], 2, [1]) == [2]", "def test_countServers():\n    solution = Solution()\n    assert solution.countServers(4, [[1, 3], [2, 6], [3, 9]], 5, [5]) == [0]", "def test_countServers():\n    solution = Solution()\n    assert solution.countServers(3, [[1, 2], [2, 4], [3, 6]], 3, [0]) == [3]", "def test_countServers():\n    solution = Solution()\n    assert solution.countServers(5, [[1, 1], [2, 3], [3, 7]], 4, [4]) == [0]", "def test_countServers():\n    solution = Solution()\n    assert solution.countServers(6, [[1, 2], [3, 4], [5, 6]], 1, [7]) == [0]", "def test_countServers():\n    solution = Solution()\n    assert solution.countServers(5, [[1, 1], [2, 3], [3, 7]], 4, [6]) == [0]", "def test_countServers():\n    solution = Solution()\n    assert solution.countServers(3, [[1, 2], [2, 4], [3, 6]], 5, [3]) == [0]", "def test_countServers():\n    solution = Solution()\n    assert solution.countServers(4, [[1, 2], [3, 5]], 2, [2]) == [2]", "def test_countServers():\n    solution = Solution()\n    assert solution.countServers(4, [[1, 1], [2, 4], [3, 7]], 3, [5]) == [0]", "def test_countServers():\n    solution = Solution()\n    assert solution.countServers(5, [[1, 3], [2, 6], [3, 9]], 4, [7]) == [0]", "def test_countServers():\n    solution = Solution()\n    assert solution.countServers(3, [[1, 2], [2, 4], [3, 6]], 3, [9]) == [0]", "def test_countServers():\n    solution = Solution()\n    assert solution.countServers(4, [[1, 2], [3, 5]], 2, [7]) == [0]", "def test_countServers():\n    solution = Solution()\n    assert solution.countServers(6, [[1, 2], [3, 4], [5, 6]], 1, [8]) == [0]", "def test_countServers():\n    solution = Solution()\n    assert solution.countServers(5, [[1, 1], [2, 3], [3, 7]], 4, [8]) == [0]"]}
{"task_num": 2751, "task_title": "Robot Collisions", "func_name": "survivedRobotsHealths", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\nfrom dataclasses import dataclass\n\n@dataclass\nclass Robot:\n  index: int\n  position: int\n  health: int\n  direction: str\n\n\nclass Solution:\n  def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\n    robots = sorted([Robot(index, position, health, direction) for index, (position, health, direction) in enumerate(zip(positions, healths, directions))], key=lambda robot: robot.position)\n    stack: List[Robot] = []\n\n    for robot in robots:\n      if robot.direction == 'R':\n        stack.append(robot)\n        continue\n      while stack and stack[-1].direction == 'R' and robot.health > 0:\n        if stack[-1].health == robot.health:\n          stack.pop()\n          robot.health = 0\n        elif stack[-1].health < robot.health:\n          stack.pop()\n          robot.health -= 1\n        else:\n          stack[-1].health -= 1\n          robot.health = 0\n      if robot.health > 0:\n        stack.append(robot)\n\n    stack.sort(key=lambda robot: robot.index)\n    return [robot.health for robot in stack]\n", "tests": ["def test_survivedRobotsHealths():\n    solution = Solution()\n    assert solution.survivedRobotsHealths([1, 3, 5], [2, 2, 2], 'RRR') == [2, 2, 2]", "def test_survivedRobotsHealths():\n    solution = Solution()\n    assert solution.survivedRobotsHealths([4, 3, 2, 1], [1, 2, 3, 4], 'LLRR') == [0, 0, 2, 3]", "def test_survivedRobotsHealths():\n    solution = Solution()\n    assert solution.survivedRobotsHealths([10, 20, 30], [5, 5, 5], 'RLL') == [5, 4, 0]", "def test_survivedRobotsHealths():\n    solution = Solution()\n    assert solution.survivedRobotsHealths([1, 2, 3, 4], [5, 5, 5, 5], 'RRLL') == [0, 4, 3, 0]", "def test_survivedRobotsHealths():\n    solution = Solution()\n    assert solution.survivedRobotsHealths([2, 4], [10, 5], 'RL') == [10]", "def test_survivedRobotsHealths():\n    solution = Solution()\n    assert solution.survivedRobotsHealths([1, 2, 3], [1, 8, 5], 'RLL') == [0, 7, 4]", "def test_survivedRobotsHealths():\n    solution = Solution()\n    assert solution.survivedRobotsHealths([10, 2], [3, 5], 'LL') == [0, 0]", "def test_survivedRobotsHealths():\n    solution = Solution()\n    assert solution.survivedRobotsHealths([1, 3], [2, 4], 'RL') == [0, 2]", "def test_survivedRobotsHealths():\n    solution = Solution()\n    assert solution.survivedRobotsHealths([100, 200], [50, 50], 'LR') == [50, 49]", "def test_survivedRobotsHealths():\n    solution = Solution()\n    assert solution.survivedRobotsHealths([1, 2], [3, 2], 'RL') == [0, 2]", "def test_survivedRobotsHealths():\n    solution = Solution()\n    assert solution.survivedRobotsHealths([20, 15], [8, 9], 'RRLL') == [7, 8]", "def test_survivedRobotsHealths():\n    solution = Solution()\n    assert solution.survivedRobotsHealths([10, 20, 30], [5, 10, 15], 'RLL') == [5, 14, 10]", "def test_survivedRobotsHealths():\n    solution = Solution()\n    assert solution.survivedRobotsHealths([10, 20, 30], [5, 10, 5], 'RLL') == [5, 9, 4]", "def test_survivedRobotsHealths():\n    solution = Solution()\n    assert solution.survivedRobotsHealths([1, 2, 3], [5, 5, 5], 'RRR') == [5, 5, 5]", "def test_survivedRobotsHealths():\n    solution = Solution()\n    assert solution.survivedRobotsHealths([1, 3, 5], [2, 4, 6], 'RRR') == [2, 4, 6]", "def test_survivedRobotsHealths():\n    solution = Solution()\n    assert solution.survivedRobotsHealths([2, 4, 6], [1, 3, 5], 'LLL') == [0, 2, 4]", "def test_survivedRobotsHealths():\n    solution = Solution()\n    assert solution.survivedRobotsHealths([10, 20], [5, 5], 'RR') == [5, 5]", "def test_survivedRobotsHealths():\n    solution = Solution()\n    assert solution.survivedRobotsHealths([1, 2, 3], [5, 10, 7], 'RLL') == [5, 9, 6]", "def test_survivedRobotsHealths():\n    solution = Solution()\n    assert solution.survivedRobotsHealths([5, 3], [2, 4], 'RL') == [0, 2]", "def test_survivedRobotsHealths():\n    solution = Solution()\n    assert solution.survivedRobotsHealths([10, 20, 30], [5, 7, 8], 'RLL') == [5, 6, 7]"]}
{"task_num": 2812, "task_title": "Find the Safest Path in a Grid", "func_name": "maximumSafenessFactor", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumSafenessFactor(self, grid: List[List[int]]) -> int:\n    self.dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    n = len(grid)\n    distToThief = self._getDistToThief(grid)\n\n    def hasValidPath(safeness: int) -> bool:\n      if distToThief[0][0] < safeness:\n        return False\n\n      q = collections.deque([(0, 0)])\n      seen = {(0, 0)}\n\n      while q:\n        i, j = q.popleft()\n        if distToThief[i][j] < safeness:\n          continue\n        if i == n - 1 and j == n - 1:\n          return True\n        for dx, dy in self.dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == n or y < 0 or y == n:\n            continue\n          if (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n\n      return False\n\n    return bisect.bisect_left(range(n * 2), True, key=lambda m: not hasValidPath(m)) - 1\n\n  def _getDistToThief(self, grid: List[List[int]]) -> List[List[int]]:\n    n = len(grid)\n    distToThief = [[0] * n for _ in range(n)]\n    q = collections.deque()\n    seen = set()\n\n    for i in range(n):\n      for j in range(n):\n        if grid[i][j] == 1:\n          q.append((i, j))\n          seen.add((i, j))\n\n    dist = 0\n    while q:\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        distToThief[i][j] = dist\n        for dx, dy in self.dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == n or y < 0 or y == n:\n            continue\n          if (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n      dist += 1\n\n    return distToThief\n", "tests": ["def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[0, 1, 1], [0, 0, 0], [0, 0, 0]]\n    result = solution.maximumSafenessFactor(grid)", "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    result = solution.maximumSafenessFactor(grid)", "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\n    result = solution.maximumSafenessFactor(grid)", "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[0, 0], [0, 0]]\n    result = solution.maximumSafenessFactor(grid)", "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 0, 1], [0, 0, 0]]\n    result = solution.maximumSafenessFactor(grid)", "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[1, 0, 0], [0, 0, 0], [0, 0, 0]]\n    result = solution.maximumSafenessFactor(grid)", "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[0, 1, 0], [1, 0, 1], [0, 0, 0]]\n    result = solution.maximumSafenessFactor(grid)", "def test_maximumSafenessFactor():\n    solution = Solution()\n    n = 100\n    grid = [[0] * n for _ in range(n)]\n    grid[0][0] = 1\n    result = solution.maximumSafenessFactor(grid)", "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 0, 1], [1, 0, 0]]\n    result = solution.maximumSafenessFactor(grid)", "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[0, 1, 0], [0, 0, 0], [1, 0, 0]]\n    result = solution.maximumSafenessFactor(grid)", "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[1, 0, 0], [0, 0, 0], [0, 1, 0]]\n    result = solution.maximumSafenessFactor(grid)", "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[0, 1, 0], [0, 0, 0], [0, 0, 0]]\n    result = solution.maximumSafenessFactor(grid)", "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[1, 0], [0, 0]]\n    result = solution.maximumSafenessFactor(grid)", "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[0, 0], [1, 0]]\n    result = solution.maximumSafenessFactor(grid)", "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[0, 1], [0, 0]]\n    result = solution.maximumSafenessFactor(grid)", "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[0, 1], [1, 0]]\n    result = solution.maximumSafenessFactor(grid)", "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[0, 1, 0], [1, 0, 1], [0, 1, 0]]\n    result = solution.maximumSafenessFactor(grid)", "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]\n    result = solution.maximumSafenessFactor(grid)", "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[0, 0], [0, 1]]\n    result = solution.maximumSafenessFactor(grid)", "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[0, 0, 0], [1, 0, 0], [0, 0, 0]]\n    result = solution.maximumSafenessFactor(grid)"]}
{"task_num": 2818, "task_title": "Apply Operations to Maximize Score", "func_name": "maximumScore", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumScore(self, nums: List[int], k: int) -> int:\n    kMod = 1_000_000_007\n    n = len(nums)\n    ans = 1\n    minPrimeFactors = self._sieveEratosthenes(max(nums) + 1)\n    primeScores = [self._getPrimeScore(num, minPrimeFactors) for num in nums]\n    left = [-1] * n\n    right = [n] * n\n    stack = []\n\n    for i in reversed(range(n)):\n      while stack and primeScores[stack[-1]] <= primeScores[i]:\n        left[stack.pop()] = i\n      stack.append(i)\n\n    stack = []\n\n    for i in range(n):\n      while stack and primeScores[stack[-1]] < primeScores[i]:\n        right[stack.pop()] = i\n      stack.append(i)\n\n    numAndIndexes = [(num, i) for i, num in enumerate(nums)]\n\n    def modPow(x: int, n: int) -> int:\n      if n == 0:\n        return 1\n      if n & 1:\n        return x * modPow(x, n - 1) % kMod\n      return modPow(x * x % kMod, n // 2)\n\n    for num, i in sorted(numAndIndexes, key=lambda x: (-x[0], x[1])):\n      rangeCount = (i - left[i]) * (right[i] - i)\n      actualCount = min(rangeCount, k)\n      k -= actualCount\n      ans *= modPow(num, actualCount)\n      ans %= kMod\n\n    return ans\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeScore(self, num: int, minPrimeFactors: List[int]) -> int:\n    primeFactors = set()\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      primeFactors.add(divisor)\n      while num % divisor == 0:\n        num //= divisor\n    return len(primeFactors)\n", "tests": ["def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([3, 2, 1], 2) == 6", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([4, 5, 6], 1) == 20", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([7, 9, 3], 3) == 2520 % 1000000007", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([2, 3, 5, 7], 4) == 105 % 1000000007", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([10, 20, 30, 40, 50], 2) == 8000 % 1000000007", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([1], 1) == 1", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([2, 4, 6, 8], 3) == 1024 % 1000000007", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([1, 2, 3, 4], 0) == 1", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([11, 13, 17], 2) == 3003 % 1000000007", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([221, 309], 1) == 52921 % 1000000007", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([29, 31, 37], 3) == 4560 % 1000000007", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([2, 5, 8, 13, 21], 4) == 703687441 % 1000000007", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([31, 29, 23], 2) == 65025 % 1000000007", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([34, 18, 29], 3) == 7680 % 1000000007", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([13, 5, 9], 2) == 6075 % 1000000007", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([15, 25, 35], 1) == 945 % 1000000007", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([49, 51, 53], 2) == 1067625 % 1000000007", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([2, 3, 5, 7], 1) == 20", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([2, 3, 5], 0) == 1", "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([100, 200, 300], 2) == 6000000 % 1000000007"]}
{"task_num": 2836, "task_title": "Maximize Value of Function in a Ball Passing Game", "func_name": "getMaxFunctionValue", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:\n    n = len(receiver)\n    m = int(math.log2(k)) + 1\n    ans = 0\n    jump = [[0] * m for _ in range(n)]\n    summ = [[0] * m for _ in range(n)]\n\n    for i in range(n):\n      jump[i][0] = receiver[i]\n      summ[i][0] = receiver[i]\n\n    for j in range(1, m):\n      for i in range(n):\n        midNode = jump[i][j - 1]\n        jump[i][j] = jump[midNode][j - 1]\n        summ[i][j] = summ[i][j - 1] + summ[midNode][j - 1]\n\n    for i in range(n):\n      currSum = i\n      currPos = i\n      for j in range(m):\n        if (k >> j) & 1 == 1:\n          currSum += summ[currPos][j]\n          currPos = jump[currPos][j]\n      ans = max(ans, currSum)\n\n    return ans\n", "tests": ["def test_getMaxFunctionValue():\n    solution = Solution()\n    assert solution.getMaxFunctionValue([2, 1, 3, 0], 4) == 7", "def test_getMaxFunctionValue():\n    solution = Solution()\n    assert solution.getMaxFunctionValue([1, 0], 3) == 4", "def test_getMaxFunctionValue():\n    solution = Solution()\n    assert solution.getMaxFunctionValue([1, 2, 3, 4], 1) == 1", "def test_getMaxFunctionValue():\n    solution = Solution()\n    assert solution.getMaxFunctionValue([0, 2, 1], 5) == 7", "def test_getMaxFunctionValue():\n    solution = Solution()\n    assert solution.getMaxFunctionValue([0, 1, 2], 6) == 9", "def test_getMaxFunctionValue():\n    solution = Solution()\n    assert solution.getMaxFunctionValue([3, 2, 1, 0], 2) == 7", "def test_getMaxFunctionValue():\n    solution = Solution()\n    assert solution.getMaxFunctionValue([1, 3, 2], 4) == 9", "def test_getMaxFunctionValue():\n    solution = Solution()\n    assert solution.getMaxFunctionValue([0, 1, 2, 3], 3) == 9", "def test_getMaxFunctionValue():\n    solution = Solution()\n    assert solution.getMaxFunctionValue([2, 0, 1], 5) == 9", "def test_getMaxFunctionValue():\n    solution = Solution()\n    assert solution.getMaxFunctionValue([0, 3, 1, 2], 6) == 14", "def test_getMaxFunctionValue():\n    solution = Solution()\n    assert solution.getMaxFunctionValue([1], 0) == 0", "def test_getMaxFunctionValue():\n    solution = Solution()\n    assert solution.getMaxFunctionValue([0, 2, 1], 7) == 14", "def test_getMaxFunctionValue():\n    solution = Solution()\n    assert solution.getMaxFunctionValue([3, 0, 2, 1], 8) == 21", "def test_getMaxFunctionValue():\n    solution = Solution()\n    assert solution.getMaxFunctionValue([0, 1], 1) == 2", "def test_getMaxFunctionValue():\n    solution = Solution()\n    assert solution.getMaxFunctionValue([2, 3, 1, 0], 5) == 14", "def test_getMaxFunctionValue():\n    solution = Solution()\n    assert solution.getMaxFunctionValue([0, 3, 2, 1], 4) == 11", "def test_getMaxFunctionValue():\n    solution = Solution()\n    assert solution.getMaxFunctionValue([1, 2, 3], 7) == 14", "def test_getMaxFunctionValue():\n    solution = Solution()\n    assert solution.getMaxFunctionValue([3, 2, 0, 1], 6) == 15", "def test_getMaxFunctionValue():\n    solution = Solution()\n    assert solution.getMaxFunctionValue([0, 2], 3) == 4", "def test_getMaxFunctionValue():\n    solution = Solution()\n    assert solution.getMaxFunctionValue([1, 2], 2) == 3"]}
{"task_num": 2844, "task_title": "Minimum Operations to Make a Special Number", "func_name": "minimumOperations", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumOperations(self, num: str) -> int:\n    n = len(num)\n    seenFive = False\n    seenZero = False\n\n    for i in range(n - 1, -1, -1):\n      if seenZero and num[i] == '0':\n        return n - i - 2\n      if seenZero and num[i] == '5':\n        return n - i - 2\n      if seenFive and num[i] == '2':\n        return n - i - 2\n      if seenFive and num[i] == '7':\n        return n - i - 2\n      seenZero = seenZero or num[i] == '0'\n      seenFive = seenFive or num[i] == '5'\n\n    if seenZero:\n      return n - 1\n    else:\n      return n\n", "tests": ["def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('10') == 1", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('37') == 2", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('105') == 1", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('207') == 1", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('250') == 1", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('270') == 1", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('05') == 1", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('07') == 1", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('0050') == 2", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('139') == 3", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('50') == 1", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('70') == 1", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('5050') == 2", "", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('0') == 1", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('5') == 1", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('7') == 1", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('7070') == 2", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('1390') == 2", "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('125') == 1"]}
{"task_num": 2846, "task_title": "Minimum Edge Weight Equilibrium Queries in a Tree", "func_name": "minOperationsQueries", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minOperationsQueries(self, n: int, edges: List[List[int]], queries: List[List[int]]) -> List[int]:\n    kMax = 26\n    m = int(math.log2(n)) + 1\n    ans = []\n    graph = [[] for _ in range(n)]\n    jump = [[0] * m for _ in range(n)]\n    count = [[] for _ in range(n)]\n    depth = [0] * n\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    def dfs(u: int, prev: int, d: int):\n      if prev != -1:\n        jump[u][0] = prev\n      depth[u] = d\n      for v, w in graph[u]:\n        if v == prev:\n          continue\n        count[v] = count[u][:]\n        count[v][w] += 1\n        dfs(v, u, d + 1)\n\n    count[0] = [0] * (kMax + 1)\n    dfs(0, -1, 0)\n\n    for j in range(1, m):\n      for i in range(n):\n        jump[i][j] = jump[jump[i][j - 1]][j - 1]\n\n    def getLCA(u: int, v: int) -> int:\n      if depth[u] > depth[v]:\n        return getLCA(v, u)\n      for j in range(m):\n        if depth[v] - depth[u] >> j & 1:\n          v = jump[v][j]\n      if u == v:\n        return u\n      for j in range(m - 1, -1, -1):\n        if jump[u][j] != jump[v][j]:\n          u = jump[u][j]\n          v = jump[v][j]\n      return jump[v][0]\n\n    for u, v in queries:\n      lca = getLCA(u, v)\n      numEdges = depth[u] + depth[v] - 2 * depth[lca]\n      maxFreq = max(count[u][j] + count[v][j] - 2 * count[lca][j] for j in range(1, kMax + 1))\n      ans.append(numEdges - maxFreq)\n\n    return ans\n", "tests": ["def test_minOperationsQueries():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 2], [0, 2, 3], [1, 4, 1]]\n    queries = [[0, 4], [1, 3]]\n    expected = [1, 1]\n    assert solution.minOperationsQueries(n, edges, queries) == expected", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 6\n    edges = [[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5]]\n    queries = [[0, 5], [1, 3], [2, 4]]\n    expected = [2, 1, 1]\n    assert solution.minOperationsQueries(n, edges, queries) == expected", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 1], [1, 2, 2]]\n    queries = [[0, 2]]\n    expected = [1]\n    assert solution.minOperationsQueries(n, edges, queries) == expected", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 2], [1, 2, 3], [1, 3, 1]]\n    queries = [[0, 3], [2, 3]]\n    expected = [2, 1]\n    assert solution.minOperationsQueries(n, edges, queries) == expected", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 7\n    edges = [[0, 1, 1], [0, 2, 4], [1, 3, 2], [1, 4, 5], [2, 5, 3], [2, 6, 1]]\n    queries = [[3, 6], [0, 5], [1, 2]]\n    expected = [3, 2, 2]\n    assert solution.minOperationsQueries(n, edges, queries) == expected", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 3], [1, 2, 5], [2, 3, 2], [3, 4, 1]]\n    queries = [[0, 4], [1, 3], [2, 4]]\n    expected = [2, 1, 1]\n    assert solution.minOperationsQueries(n, edges, queries) == expected", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 6\n    edges = [[0, 1, 4], [1, 2, 2], [2, 3, 5], [3, 4, 3], [4, 5, 1]]\n    queries = [[0, 5], [1, 3], [2, 4]]\n    expected = [2, 1, 1]\n    assert solution.minOperationsQueries(n, edges, queries) == expected", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 2], [1, 2, 3], [1, 3, 1]]\n    queries = [[0, 2], [2, 3]]\n    expected = [1, 1]\n    assert solution.minOperationsQueries(n, edges, queries) == expected", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 7\n    edges = [[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6]]\n    queries = [[0, 6], [1, 3], [2, 5]]\n    expected = [2, 1, 1]\n    assert solution.minOperationsQueries(n, edges, queries) == expected", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5]]\n    queries = [[0, 4], [1, 3], [2, 4]]\n    expected = [2, 1, 1]\n    assert solution.minOperationsQueries(n, edges, queries) == expected", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 8\n    edges = [[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7]]\n    queries = [[0, 7], [1, 3], [2, 5], [4, 6]]\n    expected = [2, 1, 1, 1]\n    assert solution.minOperationsQueries(n, edges, queries) == expected", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 1], [1, 2, 2], [2, 3, 1]]\n    queries = [[0, 3]]\n    expected = [1]\n    assert solution.minOperationsQueries(n, edges, queries) == expected", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 3], [1, 2, 2], [2, 3, 5], [3, 4, 1]]\n    queries = [[0, 4], [1, 3], [2, 4]]\n    expected = [2, 1, 1]\n    assert solution.minOperationsQueries(n, edges, queries) == expected", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 6\n    edges = [[0, 1, 4], [1, 2, 2], [2, 3, 5], [3, 4, 3], [4, 5, 1]]\n    queries = [[0, 5], [1, 3], [2, 4]]\n    expected = [2, 1, 1]\n    assert solution.minOperationsQueries(n, edges, queries) == expected", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 2], [1, 2, 3], [1, 3, 1]]\n    queries = [[0, 2], [2, 3]]\n    expected = [1, 1]\n    assert solution.minOperationsQueries(n, edges, queries) == expected", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 7\n    edges = [[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6]]\n    queries = [[0, 6], [1, 3], [2, 5]]\n    expected = [2, 1, 1]\n    assert solution.minOperationsQueries(n, edges, queries) == expected", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5]]\n    queries = [[0, 4], [1, 3], [2, 4]]\n    expected = [2, 1, 1]\n    assert solution.minOperationsQueries(n, edges, queries) == expected", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 8\n    edges = [[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7]]\n    queries = [[0, 7], [1, 3], [2, 5], [4, 6]]\n    expected = [2, 1, 1, 1]\n    assert solution.minOperationsQueries(n, edges, queries) == expected", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 2], [1, 2, 3], [1, 3, 1]]\n    queries = [[0, 3]]\n    expected = [1]\n    assert solution.minOperationsQueries(n, edges, queries) == expected", "def test_minOperationsQueries():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 3], [1, 2, 2], [2, 3, 5], [3, 4, 1]]\n    queries = [[0, 4], [1, 3], [2, 4]]\n    expected = [2, 1, 1]\n    assert solution.minOperationsQueries(n, edges, queries) == expected"]}
{"task_num": 2850, "task_title": "Minimum Moves to Spread Stones Over Grid", "func_name": "minimumMoves", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumMoves(self, grid: List[List[int]]) -> int:\n    if sum(row.count(0) for row in grid) == 0:\n      return 0\n\n    ans = math.inf\n\n    for i in range(3):\n      for j in range(3):\n        if grid[i][j] == 0:\n          for x in range(3):\n            for y in range(3):\n              if grid[x][y] > 1:\n                grid[x][y] -= 1\n                grid[i][j] += 1\n                ans = min(ans, abs(x - i) + abs(y - j) + self.minimumMoves(grid))\n                grid[x][y] += 1\n                grid[i][j] -= 1\n\n    return ans\n", "tests": ["def test_minimumMoves():\n    solution = Solution()\n    grid = [[1, 0, 2], [3, 4, 5], [6, 7, 8]]\n    assert solution.minimumMoves(grid) == 9", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n    assert solution.minimumMoves(grid) == 0", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[2, 0, 0], [0, 1, 1], [0, 0, 0]]\n    assert solution.minimumMoves(grid) == 3", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    assert solution.minimumMoves(grid) == 36", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[1, 0, 2], [3, 4, 5], [6, 7, 1]]\n    assert solution.minimumMoves(grid) == 8", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[1, 0, 1], [1, 1, 1], [1, 1, 1]]\n    assert solution.minimumMoves(grid) == 2", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n    assert solution.minimumMoves(grid) == 8", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[4, 0, 0], [0, 5, 0], [0, 0, 6]]\n    assert solution.minimumMoves(grid) == 34", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 1, 0], [1, 0, 1], [0, 1, 0]]\n    assert solution.minimumMoves(grid) == 8", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    assert solution.minimumMoves(grid) == 36", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[2, 3, 4], [5, 6, 7], [8, 9, 10]]\n    assert solution.minimumMoves(grid) == 30", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[2, 2, 2], [2, 2, 2], [2, 2, 2]]\n    assert solution.minimumMoves(grid) == 0", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[3, 3, 3], [3, 3, 3], [3, 3, 3]]\n    assert solution.minimumMoves(grid) == 0", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[1, 0, 0], [0, 2, 0], [0, 0, 3]]\n    assert solution.minimumMoves(grid) == 6", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[2, 0, 0], [0, 3, 0], [0, 0, 4]]\n    assert solution.minimumMoves(grid) == 6", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[4, 5, 6], [7, 8, 9], [10, 11, 12]]\n    assert solution.minimumMoves(grid) == 30", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[5, 6, 7], [8, 9, 10], [11, 12, 13]]\n    assert solution.minimumMoves(grid) == 30", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[1, 0, 2], [3, 4, 5], [6, 7, 0]]\n    assert solution.minimumMoves(grid) == 8", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[2, 0, 3], [4, 5, 6], [7, 8, 0]]\n    assert solution.minimumMoves(grid) == 8", "def test_minimumMoves():\n    solution = Solution()\n    grid = [[3, 1, 2], [4, 0, 5], [6, 7, 8]]\n    assert solution.minimumMoves(grid) == 12"]}
{"task_num": 2851, "task_title": "String Transformation", "func_name": "numberOfWays", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numberOfWays(self, s: str, t: str, k: int) -> int:\n    kMod = 1_000_000_007\n    n = len(s)\n    negOnePowK = 1 if k % 2 == 0 else -1  # (-1)^k\n    z = self._zFunction(s + t + t)\n\n    indices = [i - n for i in range(n, n + n) if z[i] >= n]\n    dp = [0] * 2\n    dp[1] = (pow(n - 1, k, kMod) - negOnePowK) * pow(n, kMod - 2, kMod)\n    dp[0] = dp[1] + negOnePowK\n    res = 0\n    for index in indices:\n      if index == 0:\n        res += dp[0]\n      else: \n        res += dp[1]\n    return res % kMod\n\n\n  def _zFunction(self, s: str) -> List[int]:\n    n = len(s)\n    z = [0] * n\n    l = 0\n    r = 0\n    for i in range(1, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l])\n      while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n    return z\n", "tests": ["def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('abc', 'cba', 2) == 1", "def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('aaaa', 'aaaa', 3) == 4", "def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('abcde', 'edcba', 4) == 0", "def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('ab', 'ba', 1) == 2", "def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('abc', 'cba', 1) == 2", "def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('abcd', 'dcba', 2) == 1", "def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('abc', 'acb', 2) == 1", "def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('abc', 'bac', 3) == 0", "def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('aaa', 'aaa', 1) == 3", "def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('abc', 'cab', 4) == 0", "def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('abc', 'acb', 1) == 2", "def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('abc', 'bac', 2) == 1", "def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('abc', 'acb', 3) == 0", "def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('abcd', 'dcba', 1) == 2", "def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('abc', 'bac', 4) == 0", "def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('abc', 'cba', 5) == 1", "def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('abc', 'acb', 5) == 0", "def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('abc', 'bac', 6) == 1", "def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('abc', 'cba', 6) == 1", "def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('abcd', 'dcba', 7) == 2"]}
{"task_num": 2876, "task_title": "Count Visited Nodes in a Directed Graph", "func_name": "countVisitedNodes", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countVisitedNodes(self, edges: List[int]) -> List[int]:\n    n = len(edges)\n    ans = [0] * n\n    inDegrees = [0] * n\n    seen = [False] * n\n    stack = []\n\n    for v in edges:\n      inDegrees[v] += 1\n\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n\n    while q:\n      u = q.popleft()\n      inDegrees[edges[u]] -= 1\n      if inDegrees[edges[u]] == 0:\n        q.append(edges[u])\n      stack.append(u)\n      seen[u] = True\n\n    for i in range(n):\n      if not seen[i]:\n        self._fillCycle(edges, i, seen, ans)\n\n    while stack:\n      u = stack.pop()\n      ans[u] = ans[edges[u]] + 1\n\n    return ans\n\n  def _fillCycle(self, edges: List[int], start: int, seen: List[bool], ans: List[int]) -> None:\n    cycleLength = 0\n    u = start\n    while not seen[u]:\n      cycleLength += 1\n      seen[u] = True\n      u = edges[u]\n    ans[start] = cycleLength\n    u = edges[start]\n    while u != start:\n      ans[u] = cycleLength\n      u = edges[u]\n", "tests": ["def test_countVisitedNodes():\n    solution = Solution()\n    edges = [1, 2, 0]\n    expected = [3, 1, 1]\n    assert solution.countVisitedNodes(edges) == expected", "def test_countVisitedNodes():\n    solution = Solution()\n    edges = [2, 0, 1]\n    expected = [3, 3, 3]\n    assert solution.countVisitedNodes(edges) == expected", "def test_countVisitedNodes():\n    solution = Solution()\n    edges = [1, 2, -1, 3]\n    expected = [2, 2, 1, 1]\n    assert solution.countVisitedNodes(edges) == expected", "def test_countVisitedNodes():\n    solution = Solution()\n    n = 1000\n    edges = list(range(1, n)) + [-1]\n    expected = [n] * (n - 1) + [1]\n    assert solution.countVisitedNodes(edges) == expected", "def test_countVisitedNodes():\n    solution = Solution()\n    n = 5\n    edges = [0] * n\n    expected = [n] * n\n    assert solution.countVisitedNodes(edges) == expected", "def test_countVisitedNodes():\n    solution = Solution()\n    edges = [0] * 3 + [1, 2, 0]\n    expected = [4, 1, 1, 4]\n    assert solution.countVisitedNodes(edges) == expected", "def test_countVisitedNodes():\n    solution = Solution()\n    edges = [0, 1, -1, -1, 2, 3, -1, -1, 4, 5, 6, -1, 7, 8, 9, -1, 10, 11, 12, -1]\n    expected = [3, 3, 1, 1, 7, 7, 7, 7, 1]\n    assert solution.countVisitedNodes(edges) == expected", "def test_countVisitedNodes():\n    import random\n    solution = Solution()\n    n = 100\n    edges = [-1 if i == 0 else random.randint(0, i - 1) for i in range(n)]\n    expected = [n] * n\n    assert solution.countVisitedNodes(edges) == expected", "def test_countVisitedNodes():\n    import random\n    solution = Solution()\n    n = 100\n    edges = [-1 if i == 0 else random.randint(0, i - 1) % (i // 20) for i in range(n)]\n    expected = [n] * n\n    assert solution.countVisitedNodes(edges) == expected", "def test_countVisitedNodes():\n    import random\n    solution = Solution()\n    n = 100\n    edges = [-1 if i % 5 == 0 else random.randint(0, i - 1) % (i // 20) for i in range(n)]\n    cycle_length = random.randint(3, n)\n    for _ in range(cycle_length):\n        edges.append(random.randint(0, n - 1))\n    expected = [n] * n\n    assert solution.countVisitedNodes(edges) == expected", "def test_large_cycle_with_multiple_paths():\n    import solution  # Assuming the solution is in a file named 'solution.py'\n    \n    # Generate the test case\n    edges = generate_test_case()\n    \n    # Run the function under test\n    result = solution.count_visited_nodes(edges)\n    \n    # Verify the result (this part depends on what the expected output should be)\n    # For example, if we expect the entire graph to be visited:\n    assert result == len(edges), \"The entire graph should be visited\"\n\n# Call the test function\ntest_large_cycle_with_multiple_paths()\n```\n\n#### Explanation:\n\n1. **Cycle Creation**: The cycle is created using a simple loop that connects each node to the next one.\n2. **Path Creation**: Paths are added from every fifth node in the cycle, ensuring they don't go back to themselves and avoiding duplicate edges.\n3. **Self-Loops**: A small probability is used to introduce self-loops in some nodes within the cycle.\n4. **Parallel Edges**: Parallel edges between random pairs of nodes are added with a low probability.\n", "def test_multiple_disconnected_components():\n    import solution  # Assuming the solution is in a file named 'solution.py'\n    \n    # Generate the test case\n    edges = generate_test_case()\n    \n    # Run the function under test\n    result = solution.count_visited_nodes(edges)\n    \n    # Verify the result (this part depends on what the expected output should be)\n    # For example, if we expect each component to be visited separately:\n    num_components = 3  # Number of disconnected components\n    expected_visits_per_component = [5, 8, 7]\n    for i, expected in enumerate(expected_visits_per_component):\n        assert result[i] == expected, f\"Component {i+1} should have been fully visited\"\n\n# Call the test function\ntest_multiple_disconnected_components()\n```\n\n#### Explanation:\n\n1. **Component Creation**: The graph is divided into multiple disconnected components.\n2. **Cycle and Path Creation**: Each component contains at least one cycle and one path, ensuring various connectivity patterns.\n3. **Self-Loops**: A small probability is used to introduce self-loops in some nodes within each component.\n4. **Parallel Edges**: Parallel edges between random pairs of nodes are added with a low probability within each component.\n", "def test_mixed_connectivity():\n    import solution  # Assuming the solution is in a file named 'solution.py'\n    \n    # Generate the test case\n    edges = generate_test_case()\n    \n    # Run the function under test\n    result = solution.count_visited_nodes(edges)\n    \n    # Verify the result (this part depends on what the expected output should be)\n    # For example, if we expect each component to be visited separately and isolated nodes to count as visited:\n    num_components = 3  # Number of connected components\n    expected_visits_per_component = [5, 8, 7]\n    for i, expected in enumerate(expected_visits_per_component):\n        assert result[i] == expected, f\"Component {i+1} should have been fully visited\"\n    \n    isolated_nodes = 5  # Number of isolated nodes\n    for i in range(isolated_nodes):\n        assert result[-(i + 1)] != -2, \"Isolated node should be considered as visited\"\n\n# Call the test function\ntest_mixed_connectivity()\n```\n\n#### Explanation:\n\n1. **Component Creation**: The graph is divided into multiple connected components.\n2. **Isolated Nodes**: Some isolated nodes are added to the graph using a special value (`-2`).\n3. **Cycle and Path Creation**: Each component contains at least one cycle and one path, ensuring various connectivity patterns.\n4. **Self-Loops**: A small probability is used to introduce self-loops in some nodes within each component.\n5. **Parallel Edges**: Parallel edges between random pairs of nodes are added with a low probability within each component.\n", "def test_complex_interconnected_components():\n    import solution  # Assuming the solution is in a file named 'solution.py'\n    \n    # Generate the test case\n    edges = generate_test_case()\n    \n    # Run the function under test\n    result = solution.count_visited_nodes(edges)\n    \n    # Verify the result (this part depends on what the expected output should be)\n    # For example, if we expect each component to be visited and bridges to connect them:\n    num_components = 3  # Number of connected components\n    expected_visits_per_component = [5, 8, 7]\n    for i, expected in enumerate(expected_visits_per_component):\n        assert result[i] == expected, f\"Component {i+1} should have been fully visited\"\n    \n    bridge_count = 2  # Number of bridges connecting components\n    for _ in range(bridge_count):\n        # Check if the bridge connects nodes from different components\n        found_bridge = False\n        for i in range(n):\n            if edges[i] >= n:\n                source_comp = -1\n                target_comp = -1\n                \n                for j, size in enumerate(component_sizes):\n                    if i < size:\n                        source_comp = j\n                        break\n                    elif i < size + component_sizes[j]:\n                        source_comp = j\n                        break\n                \n                for j, size in enumerate(component_sizes):\n                    if edges[i] < current_node + size:\n                        target_comp = j\n                        break\n                    elif edges[i] < current_node + size + component_sizes[j]:\n                        target_comp = j\n                        break\n                \n                assert source_comp != target_comp, \"Bridge should connect nodes from different components\"\n                found_bridge = True\n                break\n        \n        assert found_bridge, \"No bridges were found connecting components\"\n\n# Call the test function\ntest_complex_interconnected_components()\n```\n\n#### Explanation:\n\n1. **Component Creation**: The graph is divided into multiple interconnected components.\n2. **Cycle and Path Creation**: Each component contains at least one cycle and one path, ensuring various connectivity patterns.\n3. **Self-Loops**: A small probability is used to introduce self-loops in some nodes within each component.\n4. **Parallel Edges**: Parallel edges between random pairs of nodes are added with a low probability within each component.\n5. **Bridges or Intermediate Nodes**: Intermediary bridges connecting different components are inserted.\n", "def test_highly_interconnected_components():\n    import solution  # Assuming the solution is in a file named 'solution.py'\n    \n    # Generate the test case\n    edges = generate_test_case()\n    \n    # Run the function under test\n    result = solution.count_visited_nodes(edges)\n    \n    # Verify the result (this part depends on what the expected output should be)\n    # For example, if we expect each component to be visited and bridges to connect them:\n    num_components = 3  # Number of highly interconnected components\n    expected_visits_per_component = [4, 7, 9]\n    for i, expected in enumerate(expected_visits_per_component):\n        assert result[i] == expected, f\"Component {i+1} should have been fully visited\"\n    \n    bridge_count = 5  # Number of bridges connecting components\n    for _ in range(bridge_count):\n        # Check if the bridge connects nodes from different components\n        found_bridge = False\n        for i in range(n):\n            if edges[i] >= n:\n                source_comp = -1\n                target_comp = -1\n                \n                for j, size in enumerate(component_sizes):\n                    if i < size:\n                        source_comp = j\n                        break\n                    elif i < size + component_sizes[j]:\n                        source_comp = j\n                        break\n                \n                for j, size in enumerate(component_sizes):\n                    if edges[i] < current_node + size:\n                        target_comp = j\n                        break\n                    elif edges[i] < current_node + size + component_sizes[j]:\n                        target_comp = j\n                        break\n                \n                assert source_comp != target_comp, \"Bridge should connect nodes from different components\"\n                found_bridge = True\n                break\n        \n        assert found_bridge, \"No bridges were found connecting components\"\n\n# Call the test function\ntest_highly_interconnected_components()\n```\n\n#### Explanation:\n\n1. **Component Creation**: The graph is divided into multiple highly interconnected components.\n2. **Cycle and Path Creation**: Each component contains complex structures with multiple cycles and long paths.\n3. **Self-Loops**: A small probability is used to introduce self-loops in some key nodes within each component.\n4. **Parallel Edges**: Parallel edges between important nodes are added to increase complexity.\n5. **Bridges or Intermediate Nodes**: Numerous bridges and intermediate nodes that connect different components.\n", "def test_disconnected_components():\n    import solution  # Assuming the solution is in a file named 'solution.py'\n    \n    # Generate the test case\n    edges = generate_test_case()\n    \n    # Run the function under test\n    result = solution.count_visited_nodes(edges)\n    \n    # Verify the result (this part depends on what the expected output should be)\n    # For example, if we expect each component to be visited and bridges to connect them:\n    num_components = 3  # Number of disconnected components\n    for i in range(num_components):\n        assert result[i] == 0, f\"Component {i+1} should not have been visited as it is disconnected\"\n\n# Call the test function\ntest_disconnected_components()\n```\n\n#### Explanation:\n\n1. **Component Creation**: The graph is divided into multiple disconnected components.\n2. **Cycle and Path Creation**: Each component contains simple structures like single nodes or very short paths.\n3. **Self-Loops**: A small probability is used to introduce self-loops in some key nodes within each component.\n4. **Parallel Edges**: Parallel edges between important nodes are added to increase complexity slightly.\n", "def test_small_interconnected_components():\n    import solution  # Assuming the solution is in a file named 'solution.py'\n    \n    # Generate the test case\n    edges = generate_test_case()\n    \n    # Run the function under test\n    result = solution.count_visited_nodes(edges)\n    \n    # Verify the result (this part depends on what the expected output should be)\n    # For example, if we expect each component to be visited and bridges to connect them:\n    num_components = 3  # Number of small interconnected components\n    for i in range(num_components):\n        assert result[i] == 1, f\"Component {i+1} should have been visited as it is interconnected\"\n\n# Call the test function\ntest_small_interconnected_components()\n```\n\n#### Explanation:\n\n1. **Component Creation**: The graph is divided into multiple small interconnected components.\n2. **Cycle and Path Creation**: Each component contains simple structures like single nodes, short paths, or cycles.\n3. **Self-Loops**: A small probability is used to introduce self-loops in some key nodes within each component.\n4. **Parallel Edges**: Parallel edges between important nodes are added to increase complexity slightly.\n5. **Interconnections**: A few connections are added between the components to ensure they are not completely isolated.\n", "def test_large_interconnected_components():\n    import solution  # Assuming the solution is in a file named 'solution.py'\n    \n    # Generate the test case\n    edges = generate_test_case()\n    \n    # Run the function under test\n    result = solution.count_visited_nodes(edges)\n    \n    # Verify the result (this part depends on what the expected output should be)\n    # For example, if we expect each component to be visited and bridges to connect them:\n    num_components = 3  # Number of large interconnected components\n    for i in range(num_components):\n        assert result[i] == 1, f\"Component {i+1} should have been visited as it is fully interconnected\"\n\n# Call the test function\ntest_large_interconnected_components()\n```\n\n#### Explanation:\n\n1. **Component Creation**: The graph is divided into multiple large interconnected components.\n2. **Cycle and Path Creation**: Each component contains complex structures like multiple nodes, cycles, and paths.\n3. **Self-Loops**: A small probability is used to introduce self-loops in some key nodes within each component.\n4. **Parallel Edges**: Parallel edges between important nodes are added to increase complexity slightly.\n5. **Interconnections**: Numerous connections are added between the components to ensure they are fully interconnected.\n", "def test_mixed_interconnected_components():\n    import solution  # Assuming the solution is in a file named 'solution.py'\n    \n    # Generate the test case\n    edges = generate_test_case()\n    \n    # Run the function under test\n    result = solution.count_visited_nodes(edges)\n    \n    # Verify the result (this part depends on what the expected output should be)\n    # For example, if we expect all components to be visited except the disconnected one:\n    num_components = 5  # Total number of components (1 disconnected + 4 interconnected)\n    for i in range(1, num_components):  # Skip the disconnected component\n        assert result[i] == 1, f\"Component {i+1} should have been visited as it is interconnected\"\n    \n    # The disconnected component should not be visited\n    assert result[0] == 0, \"Disconnected component should not be visited\"\n\n# Call the test function\ntest_mixed_interconnected_components()\n```\n\n#### Explanation:\n\n1. **Disconnected Component**: A single node that is not connected to any other node.\n2. **Interconnected Components**: Multiple interconnected components with varying degrees of complexity.\n3. **Cycle and Path Creation**: Each component contains complex structures like multiple nodes, cycles, and paths.\n4. **Self-Loops**: A small probability is used to introduce self-loops in some key nodes within the interconnected components.\n5. **Parallel Edges**: Parallel edges between important nodes are added to increase complexity slightly.\n", "def test_nested_and_complex_interconnected_components():\n    import solution  # Assuming the solution is in a file named 'solution.py'\n    \n    # Generate the test case\n    edges = generate_test_case()\n    \n    # Run the function under test\n    result = solution.count_visited_nodes(edges)\n    \n    # Verify the result (this part depends on what the expected output should be)\n    # For example, if we expect all components to be visited:\n    num_components = 5  # Total number of components within the top-level component\n    \n    for i in range(num_components):\n        assert result[i] == 1, f\"Component {i+1} should have been visited as it is interconnected\"\n    \n    # The top-level component itself should also be visited\n    assert result[top_level_component_size - 1] == 1, \"Top-level component should have been visited\"\n\n# Call the test function\ntest_nested_and_complex_interconnected_components()\n```\n\n#### Explanation:\n\n1. **Top-Level Component**: The graph starts with a top-level component containing several interconnected sub-components.\n2. **Sub-Components**: Some of these nodes create nested sub-components within the top-level component.\n3. **Cycle and Path Creation**: Each sub-component contains complex structures like multiple nodes, cycles, paths, and sub-sub-components.\n4. **Self-Loops**: A small probability is used to introduce self-loops in some key nodes within the interconnected components.\n5. **Parallel Edges**: Parallel edges between important nodes are added to increase complexity slightly.\n"]}
{"task_num": 2901, "task_title": "Longest Unequal Adjacent Groups Subsequence II", "func_name": "getWordsInLongestSubsequence", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def getWordsInLongestSubsequence(self, words: List[str], groups: List[int]) -> List[str]:\n    ans = []\n    n=len(words)\n    dp = [1] * n\n    prev = [-1] * n\n\n    for i in range(1, n):\n      for j in range(i):\n        if groups[i] == groups[j]:\n          continue\n        if len(words[i]) != len(words[j]):\n          continue\n        if sum(a != b for a, b in zip(words[i], words[j])) != 1:\n          continue\n        if dp[i] < dp[j] + 1:\n          dp[i] = dp[j] + 1\n          prev[i] = j\n\n    index = dp.index(max(dp))\n    while index != -1:\n      ans.append(words[index])\n      index = prev[index]\n\n    return ans[::-1]\n", "tests": ["def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    assert solution.getWordsInLongestSubsequence(['abc', 'bcd', 'ace'], [0, 1, 2]) == ['bcd']", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    assert solution.getWordsInLongestSubsequence(['aaa', 'aab', 'aac'], [0, 1, 2]) == ['aab']", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    assert solution.getWordsInLongestSubsequence(['abc', 'acb', 'bac'], [0, 1, 2]) == ['acb']", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    assert solution.getWordsInLongestSubsequence(['abc', 'def'], [0, 1]) == ['abc']", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    assert solution.getWordsInLongestSubsequence(['abc', 'acb', 'bac'], [0, 1, 2]) == ['acb']", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    assert solution.getWordsInLongestSubsequence(['abc', 'acb', 'bac'], [0, 1, 2]) == ['acb']", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    assert solution.getWordsInLongestSubsequence(['abc', 'acb', 'bac'], [0, 1, 2]) == ['acb']", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    assert solution.getWordsInLongestSubsequence(['abc', 'acb', 'bac'], [0, 1, 2]) == ['acb']", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    assert solution.getWordsInLongestSubsequence(['abc', 'acb', 'bac'], [0, 1, 2]) == ['acb']", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    assert solution.getWordsInLongestSubsequence(['abc', 'acb', 'bac'], [0, 1, 2]) == ['acb']", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    assert solution.getWordsInLongestSubsequence(['abc', 'acb', 'bac'], [0, 1, 2]) == ['acb']", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    assert solution.getWordsInLongestSubsequence(['abc', 'acb', 'bac'], [0, 1, 2]) == ['acb']", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    assert solution.getWordsInLongestSubsequence(['abc', 'acb', 'bac'], [0, 1, 2]) == ['acb']", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    assert solution.getWordsInLongestSubsequence(['abc', 'acb', 'bac'], [0, 1, 2]) == ['acb']", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    assert solution.getWordsInLongestSubsequence(['abc', 'acb', 'bac'], [0, 1, 2]) == ['acb']", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    assert solution.getWordsInLongestSubsequence(['abc', 'acb', 'bac'], [0, 1, 2]) == ['acb']", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    assert solution.getWordsInLongestSubsequence(['abc', 'acb', 'bac'], [0, 1, 2]) == ['acb']", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    assert solution.getWordsInLongestSubsequence(['abc', 'acb', 'bac'], [0, 1, 2]) == ['acb']", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    assert solution.getWordsInLongestSubsequence(['abc', 'acb', 'bac'], [0, 1, 2]) == ['acb']", "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    assert solution.getWordsInLongestSubsequence(['abc', 'acb', 'bac'], [0, 1, 2]) == ['acb']"]}
{"task_num": 2904, "task_title": "Shortest and Lexicographically Smallest Beautiful String", "func_name": "shortestBeautifulSubstring", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def shortestBeautifulSubstring(self, s: str, k: int) -> str:\n    bestLeft = -1\n    minLength = len(s) + 1\n    ones = 0\n\n    l = 0\n    for r, c in enumerate(s):\n      if c == '1':\n        ones += 1\n      while ones == k:\n        if r - l + 1 < minLength:\n          bestLeft = l\n          minLength = r - l + 1\n        elif r - l + 1 == minLength and s[l:l + minLength] < s[bestLeft:bestLeft + minLength]:\n          bestLeft = l\n        if s[l] == '1':\n          ones -= 1\n        l += 1\n\n    if bestLeft == -1:\n      return \"\"\n    else:\n      return s[bestLeft:bestLeft + minLength]\n", "tests": ["def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('1001110', 3) == '111'", "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('000', 2) == ''", "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('1101010', 2) == '10'", "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('111', 3) == '111'", "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('0001', 1) == '1'", "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('0100011', 3) == '10001'", "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('1000100', 2) == '00'", "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('101010', 2) == '01'", "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('11111', 5) == '11111'", "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('001010', 2) == '10'", "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('0110110', 3) == '110'", "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('111000', 2) == '11'", "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('00011', 2) == '11'", "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('10101', 3) == '010'", "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('1111000', 3) == '111'", "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('01001', 2) == '01'", "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('00100', 2) == '10'", "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('000', 2) == ''", "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('1000100', 2) == '00'", "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('1101010', 2) == '10'"]}
{"task_num": 2911, "task_title": "Minimum Changes to Make K Semi-palindromes", "func_name": "minimumChanges", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumChanges(self, s: str, k: int) -> int:\n    n = len(s)\n    factors = self._getFactors(n)\n    cost = self._getCost(s, n, factors)\n    dp = [[n] * (k + 1) for _ in range(n + 1)]\n\n    dp[n][0] = 0\n\n    for i in range(n - 1, -1, -1):\n      for j in range(1, k + 1):\n        for l in range(i + 1, n):\n          dp[i][j] = min(dp[i][j], dp[l + 1][j - 1] + cost[i][l])\n\n    return dp[0][k]\n\n  def _getFactors(self, n: int) -> List[List[int]]:\n    factors = [[1] for _ in range(n + 1)]\n    for d in range(2, n):\n      for i in range(d * 2, n + 1, d):\n        factors[i].append(d)\n    return factors\n\n  def _getCost(self, s: str, n: int, factors: List[List[int]]) -> List[List[int]]:\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n      for j in range(i + 1, n):\n        length = j - i + 1\n        minCost = length\n        for d in factors[length]:\n          minCost = min(minCost, self._getCostD(s, i, j, d))\n        cost[i][j] = minCost\n    return cost\n\n  def _getCostD(self, s: str, i: int, j: int, d: int) -> int:\n    cost = 0\n    for offset in range(d):\n      l = i + offset\n      r = j - d + 1 + offset\n      while l < r:\n        if s[l] != s[r]:\n          cost += 1\n        l += d\n        r -= d\n    return cost\n", "tests": ["def test_minimumChanges():\n    solution = Solution()\n    assert solution.minimumChanges('abcabc', 2) == 0", "def test_minimumChanges():\n    solution = Solution()\n    assert solution.minimumChanges('abccba', 1) == 0", "def test_minimumChanges():\n    solution = Solution()\n    assert solution.minimumChanges('abc', 4) == len('abc')", "def test_minimumChanges():\n    solution = Solution()\n    assert solution.minimumChanges('a', 1) == 0", "def test_minimumChanges():\n    solution = Solution()\n    assert solution.minimumChanges('abcdea', 3) == 1", "def test_minimumChanges():\n    solution = Solution()\n    assert solution.minimumChanges('abcdeffedcba', 4) == 2", "def test_minimumChanges():\n    solution = Solution()\n    s = 'a' * 1000 + 'b'\n    k = 2\n    assert solution.minimumChanges(s, k) == 999", "def test_minimumChanges():\n    solution = Solution()\n    assert solution.minimumChanges('ababa', 2) == 0", "def test_minimumChanges():\n    solution = Solution()\n    assert solution.minimumChanges('abc', 2) == 1", "def test_minimumChanges():\n    solution = Solution()\n    assert solution.minimumChanges('aaa', 3) == 0", "def test_minimumChanges():\n    solution = Solution()\n    s = 'abcdefghijklmnopqrstuvwxyz'\n    k = 26\n    assert solution.minimumChanges(s, k) == len(s)", "def test_minimumChanges():\n    solution = Solution()\n    s = 'a' * 100 + 'b'\n    k = 2\n    assert solution.minimumChanges(s, k) == 99", "def test_minimumChanges():\n    solution = Solution()\n    assert solution.minimumChanges('abcdeffedcba', 2) == 1", "def test_minimumChanges():\n    solution = Solution()\n    assert solution.minimumChanges('aaaaa', 2) == 0", "def test_minimumChanges():\n    solution = Solution()\n    s = 'abc'\n    k = len(s)\n    assert solution.minimumChanges(s, k) == 0", "def test_minimumChanges():\n    solution = Solution()\n    assert solution.minimumChanges('abc', 0) == len('abc')", "def test_minimumChanges():\n    solution = Solution()\n    assert solution.minimumChanges('abcd', 2) == 2", "def test_minimumChanges():\n    solution = Solution()\n    assert solution.minimumChanges('ababab', 3) == 0", "def test_minimumChanges():\n    solution = Solution()\n    s = 'a' * 1000 + 'b'\n    k = 1001\n    assert solution.minimumChanges(s, k) == len(s) - 1", "def test_minimumChanges():\n    solution = Solution()\n    assert solution.minimumChanges('abc', 1) == len('abc') - 1"]}
{"task_num": 2932, "task_title": "Maximum Strong Pair XOR I", "func_name": "maximumStrongPairXor", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Optional\n\nclass TrieNode:\n  def __init__(self):\n    self.children: List[Optional[TrieNode]] = [None] * 2\n    self.min = math.inf\n    self.max = -math.inf\n\n\nclass BitTrie:\n  def __init__(self, maxBit: int):\n    self.maxBit = maxBit\n    self.root = TrieNode()\n\n  def insert(self, num: int) -> None:\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n      node.min = min(node.min, num)\n      node.max = max(node.max, num)\n\n  def getMaxXor(self, x: int) -> int:\n    maxXor = 0\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = x >> i & 1\n      toggleBit = bit ^ 1\n      if node.children[toggleBit] and node.children[toggleBit].max > x and node.children[toggleBit].min <= 2 * x:\n        maxXor = maxXor | 1 << i\n        node = node.children[toggleBit]\n      elif node.children[bit]:\n        node = node.children[bit]\n      else:\n        return 0\n    return maxXor\n\n\nclass Solution:\n  def maximumStrongPairXor(self, nums: List[int]) -> int:\n    maxNum = max(nums)\n    maxBit = int(math.log2(maxNum))\n    bitTrie = BitTrie(maxBit)\n\n    for num in nums:\n      bitTrie.insert(num)\n\n    return max(bitTrie.getMaxXor(num) for num in nums)\n", "tests": ["def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [1, 2, 3, 4]\n    assert solution.maximumStrongPairXor(nums) == 7", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [4, 8, 12]\n    assert solution.maximumStrongPairXor(nums) == 0", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [17, 8, 3, 15]\n    assert solution.maximumStrongPairXor(nums) == 15", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [2, 4, 8, 16]\n    assert solution.maximumStrongPairXor(nums) == 0", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [7, 3, 2]\n    assert solution.maximumStrongPairXor(nums) == 6", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [10, 9, 5]\n    assert solution.maximumStrongPairXor(nums) == 8", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [15, 5, 3]\n    assert solution.maximumStrongPairXor(nums) == 8", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [12, 3, 7]\n    assert solution.maximumStrongPairXor(nums) == 8", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [20, 15, 5]\n    assert solution.maximumStrongPairXor(nums) == 16", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [31, 15, 7]\n    assert solution.maximumStrongPairXor(nums) == 30", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [16, 8, 4, 2]\n    assert solution.maximumStrongPairXor(nums) == 0", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [1023, 512, 256]\n    assert solution.maximumStrongPairXor(nums) == 768", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [1, 2]\n    assert solution.maximumStrongPairXor(nums) == 3", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [10, 20, 30]\n    assert solution.maximumStrongPairXor(nums) == 0", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [127, 64, 32]\n    assert solution.maximumStrongPairXor(nums) == 95", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [160, 80, 40]\n    assert solution.maximumStrongPairXor(nums) == 0", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [255, 128, 64]\n    assert solution.maximumStrongPairXor(nums) == 191", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [320, 160, 80]\n    assert solution.maximumStrongPairXor(nums) == 0", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [512, 256, 128]\n    assert solution.maximumStrongPairXor(nums) == 384", "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [1023, 511, 255]\n    assert solution.maximumStrongPairXor(nums) == 768"]}
{"task_num": 2940, "task_title": "Find Building Where Alice and Bob Can Meet", "func_name": "leftmostBuildingQueries", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, a: int, b: int):\n    self.queryIndex = queryIndex\n    self.a = a\n    self.b = b\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.a\n    yield self.b\n\n\nclass Solution:\n  def leftmostBuildingQueries(self, heights: List[int], queries: List[List[int]]) -> List[int]:\n    ans = [-1] * len(queries)\n    stack = []\n\n    heightsIndex = len(heights) - 1\n    for queryIndex, a, b in sorted([IndexedQuery(i, min(a, b), max(a, b)) for i, (a, b) in enumerate(queries)], key=lambda iq: -iq.b):\n      if a == b or heights[a] < heights[b]:\n        ans[queryIndex] = b\n      else:\n        while heightsIndex > b:\n          while stack and heights[stack[-1]] <= heights[heightsIndex]:\n            stack.pop()\n          stack.append(heightsIndex)\n          heightsIndex -= 1\n        j = self._lastGreater(stack, a, heights)\n        if j != -1:\n          ans[queryIndex] = stack[j]\n\n    return ans\n\n  def _lastGreater(self, A: List[int], target: int, heights: List[int]):\n    l = -1\n    r = len(A) - 1\n    while l < r:\n      m = (l + r + 1) // 2\n      if heights[A[m]] > heights[target]:\n        l = m\n      else:\n        r = m - 1\n    return l\n", "tests": ["def test_leftmostBuildingQueries():\n    solution = Solution()\n    assert solution.leftmostBuildingQueries([7, 6, 5, 4, 3, 2, 1], [[0, 6]]) == [6]", "def test_leftmostBuildingQueries():\n    solution = Solution()\n    assert solution.leftmostBuildingQueries([1, 2, 3, 4, 5], [[0, 4]]) == [4]", "def test_leftmostBuildingQueries():\n    solution = Solution()\n    assert solution.leftmostBuildingQueries([5, 4, 3, 2, 1], [[0, 4]]) == [-1]", "def test_leftmostBuildingQueries():\n    solution = Solution()\n    assert solution.leftmostBuildingQueries([2, 1, 3], [[0, 2]]) == [2]", "def test_leftmostBuildingQueries():\n    solution = Solution()\n    assert solution.leftmostBuildingQueries([10, 9, 8, 7, 6, 5], [[0, 5], [1, 4]]) == [5, 4]", "def test_leftmostBuildingQueries():\n    solution = Solution()\n    assert solution.leftmostBuildingQueries([1, 3, 2], [[0, 1]]) == [1]", "def test_leftmostBuildingQueries():\n    solution = Solution()\n    assert solution.leftmostBuildingQueries([3, 2, 1], [[0, 2]]) == [-1]", "def test_leftmostBuildingQueries():\n    solution = Solution()\n    assert solution.leftmostBuildingQueries([5, 10, 7], [[0, 2]]) == [1]", "def test_leftmostBuildingQueries():\n    solution = Solution()\n    assert solution.leftmostBuildingQueries([8, 7, 9], [[0, 2]]) == [2]", "def test_leftmostBuildingQueries():\n    solution = Solution()\n    assert solution.leftmostBuildingQueries([3, 2, 4], [[0, 2]]) == [2]", "def test_leftmostBuildingQueries():\n    solution = Solution()\n    assert solution.leftmostBuildingQueries([6, 4, 2, 5, 3, 7], [[1, 5]]) == [4]", "def test_leftmostBuildingQueries():\n    solution = Solution()\n    assert solution.leftmostBuildingQueries([10, 2, 3, 5], [[0, 3]]) == [3]", "def test_leftmostBuildingQueries():\n    solution = Solution()\n    assert solution.leftmostBuildingQueries([10, 5, 2, 7], [[0, 3]]) == [3]", "def test_leftmostBuildingQueries():\n    solution = Solution()\n    assert solution.leftmostBuildingQueries([9, 8, 7, 6, 5], [[0, 4]]) == [-1]", "def test_leftmostBuildingQueries():\n    solution = Solution()\n    assert solution.leftmostBuildingQueries([10, 9, 8, 7, 6], [[2, 4]]) == [4]", "def test_leftmostBuildingQueries():\n    solution = Solution()\n    assert solution.leftmostBuildingQueries([5, 3, 2, 4, 1], [[0, 3]]) == [3]", "def test_leftmostBuildingQueries():\n    solution = Solution()\n    assert solution.leftmostBuildingQueries([2, 3, 5, 4, 6], [[0, 4]]) == [4]", "def test_leftmostBuildingQueries():\n    solution = Solution()\n    assert solution.leftmostBuildingQueries([8, 5, 3, 7, 2], [[0, 4]]) == [3]", "def test_leftmostBuildingQueries():\n    solution = Solution()\n    assert solution.leftmostBuildingQueries([4, 3, 2, 1], [[0, 3]]) == [-1]", "def test_leftmostBuildingQueries():\n    solution = Solution()\n    assert solution.leftmostBuildingQueries([10, 6, 2], [[0, 2]]) == [-1]"]}
{"task_num": 2948, "task_title": "Make Lexicographically Smallest Array by Swapping Elements", "func_name": "lexicographicallySmallestArray", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def lexicographicallySmallestArray(self, nums: List[int], limit: int) -> List[int]:\n    ans = [0] * len(nums)\n    numAndIndexes = sorted([(num, i) for i, num in enumerate(nums)])\n    numAndIndexesGroups: List[List[Tuple[int, int]]] = []\n\n    for numAndIndex in numAndIndexes:\n      if not numAndIndexesGroups or numAndIndex[0] - numAndIndexesGroups[-1][-1][0] > limit:\n        numAndIndexesGroups.append([numAndIndex])\n      else:\n        numAndIndexesGroups[-1].append(numAndIndex)\n\n    for numAndIndexesGroup in numAndIndexesGroups:\n      sortedNums = [num for num, _ in numAndIndexesGroup]\n      sortedIndices = sorted([index for _, index in numAndIndexesGroup])\n      for num, index in zip(sortedNums, sortedIndices):\n        ans[index] = num\n\n    return ans\n", "tests": ["def test_lexicographicallySmallestArray():\n    solution = Solution()\n    assert solution.lexicographicallySmallestArray([3, 6, 2, 8], 2) == [2, 3, 6, 8]", "def test_lexicographicallySmallestArray():\n    solution = Solution()\n    assert solution.lexicographicallySmallestArray([10, 5, 12, 3, 8], 4) == [3, 5, 10, 8, 12]", "def test_lexicographicallySmallestArray():\n    solution = Solution()\n    assert solution.lexicographicallySmallestArray([1, 2, 3], 0) == [1, 2, 3]", "def test_lexicographicallySmallestArray():\n    solution = Solution()\n    assert solution.lexicographicallySmallestArray([7, 3, 9, 1], 2) == [1, 3, 7, 9]", "def test_lexicographicallySmallestArray():\n    solution = Solution()\n    assert solution.lexicographicallySmallestArray([5, 5, 5, 5], 1) == [5, 5, 5, 5]", "def test_lexicographicallySmallestArray():\n    solution = Solution()\n    assert solution.lexicographicallySmallestArray([100, 99, 1, 2], 50) == [1, 2, 99, 100]", "def test_lexicographicallySmallestArray():\n    solution = Solution()\n    assert solution.lexicographicallySmallestArray([1, 3, 2], 1) == [1, 2, 3]", "def test_lexicographicallySmallestArray():\n    solution = Solution()\n    assert solution.lexicographicallySmallestArray([4, 3, 2, 1], 5) == [1, 2, 3, 4]", "def test_lexicographicallySmallestArray():\n    solution = Solution()\n    assert solution.lexicographicallySmallestArray([10, 20, 30], 5) == [10, 20, 30]", "def test_lexicographicallySmallestArray():\n    solution = Solution()\n    assert solution.lexicographicallySmallestArray([5], 10) == [5]", "def test_lexicographicallySmallestArray():\n    solution = Solution()\n    assert solution.lexicographicallySmallestArray([10, 15, 10, 20], 5) == [10, 10, 15, 20]", "def test_lexicographicallySmallestArray():\n    solution = Solution()\n    assert solution.lexicographicallySmallestArray([10, 3, 5, 8], 2) == [3, 5, 8, 10]", "def test_lexicographicallySmallestArray():\n    solution = Solution()\n    assert solution.lexicographicallySmallestArray([100, 50, 25, 75], 25) == [25, 50, 75, 100]", "def test_lexicographicallySmallestArray():\n    solution = Solution()\n    assert solution.lexicographicallySmallestArray([10, 9, 8, 7], 1) == [7, 8, 9, 10]", "def test_lexicographicallySmallestArray():\n    solution = Solution()\n    assert solution.lexicographicallySmallestArray([100, 90, 80, 70], 20) == [70, 80, 90, 100]", "def test_lexicographicallySmallestArray():\n    solution = Solution()\n    assert solution.lexicographicallySmallestArray([20, 18, 16, 14, 12, 10], 2) == [10, 12, 14, 16, 18, 20]", "def test_lexicographicallySmallestArray():\n    solution = Solution()\n    assert solution.lexicographicallySmallestArray([100, 95, 90, 85], 4) == [85, 90, 95, 100]", "def test_lexicographicallySmallestArray():\n    solution = Solution()\n    assert solution.lexicographicallySmallestArray([10, 6, 4, 8], 3) == [4, 6, 8, 10]", "def test_lexicographicallySmallestArray():\n    solution = Solution()\n    assert solution.lexicographicallySmallestArray([100, 90, 80], 15) == [80, 90, 100]", "def test_lexicographicallySmallestArray():\n    solution = Solution()\n    assert solution.lexicographicallySmallestArray([50, 40, 30, 20, 10], 10) == [10, 20, 30, 40, 50]"]}
{"task_num": 2953, "task_title": "Count Complete Substrings", "func_name": "countCompleteSubstrings", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countCompleteSubstrings(self, word: str, k: int) -> int:\n    uniqueLetters = len(set(word))\n    return sum(self._countCompleteStrings(word, k, windowSize) for windowSize in range(k, k * uniqueLetters + 1, k))\n\n  def _countCompleteStrings(self, word: str, k: int, windowSize: int) -> int:\n    res = 0\n    countLetters = 0\n    count = collections.Counter()\n\n    for i, c in enumerate(word):\n      count[c] += 1\n      countLetters += 1\n      if i > 0 and abs(ord(c) - ord(word[i - 1])) > 2:\n        count = collections.Counter()\n        count[c] += 1\n        countLetters = 1\n      if countLetters == windowSize + 1:\n        count[word[i - windowSize]] -= 1\n        countLetters -= 1\n      if countLetters == windowSize:\n        res += all(freq == 0 or freq == k for freq in count.values())\n\n    return res\n", "tests": ["def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings('ababa', 2) == 4", "def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings('aaaaa', 1) == 5", "def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings('abcde', 1) == 5", "def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings('abcde', 2) == 0", "def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings('aaaabbbb', 2) == 9", "def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings('abcabca', 2) == 4", "def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings('abcde', 3) == 0", "def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings('zzz', 3) == 1", "def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings('abacabad', 2) == 6", "def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings('abcabc', 2) == 8", "def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings('abcdefg', 2) == 0", "def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings('aabbcc', 2) == 9", "def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings('zzzzz', 1) == 5", "def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings('abcabcabc', 3) == 10", "def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings('abcde', 1) == 5", "def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings('abcde', 3) == 0", "def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings('aaaabbbbcccc', 2) == 18", "def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings('abcde', 4) == 0", "def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings('abcdefg', 1) == 7", "def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings('abababab', 2) == 16"]}
{"task_num": 2959, "task_title": "Number of Possible Sets of Closing Branches", "func_name": "numberOfSets", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:\n    return sum(self._floydWarshall(n, maxDistance, roads, mask) <= maxDistance for mask in range(1 << n))\n\n  def _floydWarshall(self, n: int, maxDistanceThreshold: int, roads: List[List[int]], mask: int) -> List[List[int]]:\n    maxDistance = 0\n    dist = [[maxDistanceThreshold + 1] * n for _ in range(n)]\n\n    for i in range(n):\n      if mask >> i & 1:\n        dist[i][i] = 0\n\n    for u, v, w in roads:\n      if mask >> u & 1 and mask >> v & 1:\n        dist[u][v] = min(dist[u][v], w)\n        dist[v][u] = min(dist[v][u], w)\n\n    for k in range(n):\n      if mask >> k & 1:\n        for i in range(n):\n          if mask >> i & 1:\n            for j in range(n):\n              if mask >> j & 1:\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    for i in range(n):\n      if mask >> i & 1:\n        for j in range(i + 1, n):\n          if mask >> j & 1:\n            maxDistance = max(maxDistance, dist[i][j])\n\n    return maxDistance\n", "tests": ["def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(4, 10, [[0, 1, 3], [0, 2, 5], [0, 3, 8], [1, 2, 2], [1, 3, 6], [2, 3, 1]]) == 7", "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(3, 5, []) == 1", "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(4, 3, [[0, 1, 5], [0, 2, 7], [0, 3, 9], [1, 2, 1], [1, 3, 3], [2, 3, 2]]) == 1", "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(1, 10, []) == 2", "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(4, 10, [[0, 1, 3], [0, 2, 5], [0, 3, 8], [1, 2, 2], [1, 3, 6], [2, 3, 1]]) == 1", "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(4, 100, [[0, 1, 3], [0, 2, 5], [0, 3, 8], [1, 2, 2], [1, 3, 6], [2, 3, 1]]) == 16", "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(5, 10, [[0, 2, 3], [1, 3, 4], [3, 4, 2]]) == 4", "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(5, 5, [[0, 1, 2], [0, 2, 3], [0, 3, 4], [1, 2, 1], [1, 3, 2], [1, 4, 3], [2, 3, 1], [2, 4, 2], [3, 4, 1]]) == 15", "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(3, 10, [[0, 1, 5], [0, 1, 5], [1, 2, 5]]) == 4", "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(3, 10, [[0, 1, -5], [1, 2, -5]]) == 4", "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(5, 1000, [[0, 1, 3], [0, 2, 5], [0, 3, 8], [1, 2, 2], [1, 3, 6], [2, 3, 1]]) == 32", "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(3, 10, [[0, 1, 5]]) == 4", "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(4, 10, [[0, 1, 3], [0, 2, 5], [0, 3, 8], [1, 2, 2], [1, 3, 6], [2, 3, 1]]) == 1", "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(3, 10, [[0, 1, 5], [2, 1, 5]]) == 4", "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(3, 10, [[0, 1, 5], [0, 2, 5], [1, 2, 5]]) == 4", "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(4, 10, [[0, 1, 5], [2, 3, 5]]) == 8", "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(5, 10, [[0, 1, 5], [2, 3, 5], [4, 1, 5]]) == 8", "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(3, 10, [[0, 1, 5], [1, 2, 5], [2, 0, 5]]) == 4", "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(4, 10, [[0, 1, 5], [1, 2, 5], [2, 3, 5], [3, 0, 5]]) == 8", "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(5, 10, [[0, 1, 3], [1, 2, 7], [2, 4, 2]]) == 8"]}
{"task_num": 2973, "task_title": "Find Number of Coins to Place in Tree Nodes", "func_name": "placedCoins", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass ChildCost:\n  def __init__(self, cost: int):\n    self.numNodes = 1\n    self.maxPosCosts = [cost] if cost > 0 else []\n    self.minNegCosts = [cost] if cost < 0 else []\n\n  def update(self, childCost: 'ChildCost') -> None:\n    self.numNodes += childCost.numNodes\n    self.maxPosCosts.extend(childCost.maxPosCosts)\n    self.minNegCosts.extend(childCost.minNegCosts)\n    self.maxPosCosts.sort(reverse=True)\n    self.minNegCosts.sort()\n    self.maxPosCosts = self.maxPosCosts[:3]\n    self.minNegCosts = self.minNegCosts[:2]\n\n  def maxProduct(self) -> int:\n    if self.numNodes < 3:\n      return 1\n    if not self.maxPosCosts:\n      return 0\n    res = 0\n    if len(self.maxPosCosts) == 3:\n      res = self.maxPosCosts[0] * self.maxPosCosts[1] * self.maxPosCosts[2]\n    if len(self.minNegCosts) == 2:\n      res = max(res, self.minNegCosts[0] * self.minNegCosts[1] * self.maxPosCosts[0])\n    return res\n\n\nclass Solution:\n  def placedCoins(self, edges: List[List[int]], cost: List[int]) -> List[int]:\n    n = len(cost)\n    ans = [0] * n\n    tree = [[] for _ in range(n)]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, prev: int) -> None:\n      res = ChildCost(cost[u])\n      for v in tree[u]:\n        if v != prev:\n          res.update(dfs(v, u))\n      ans[u] = res.maxProduct()\n      return res\n\n    dfs(0, -1)\n    return ans\n", "tests": ["def test_placedCoins():\n    solution = Solution()\n    edges = [[0, 1], [0, 2]]\n    cost = [3, -1, 4]\n    expected = [6, 0, 12]\n    assert solution.placedCoins(edges, cost) == expected", "def test_placedCoins():\n    solution = Solution()\n    edges = [[0, 1], [0, 2], [1, 3], [1, 4]]\n    cost = [-5, -2, 0, 1, -3]\n    expected = [0, 0, 0, 0, 6]\n    assert solution.placedCoins(edges, cost) == expected", "def test_placedCoins():\n    solution = Solution()\n    edges = [[0, 1], [0, 2], [2, 3], [2, 4], [2, 5]]\n    cost = [-1, -1, 2, -3, 4, 5]\n    expected = [0, 0, 60, 6, 0, 0]\n    assert solution.placedCoins(edges, cost) == expected", "def test_placedCoins():\n    solution = Solution()\n    edges = [[0, 1], [0, 2], [1, 3]]\n    cost = [1, 2, 3, 4]\n    expected = [1, 1, 6, 1]\n    assert solution.placedCoins(edges, cost) == expected", "def test_placedCoins():\n    solution = Solution()\n    edges = [[0, 1], [1, 2], [1, 3], [1, 4]]\n    cost = [1, -1, 2, -2, 3]\n    expected = [6, 0, 6, 6, 6]\n    assert solution.placedCoins(edges, cost) == expected", "def test_placedCoins():\n    solution = Solution()\n    edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5]]\n    cost = [-2, -2, -2, -2, -2, -2]\n    expected = [0, 0, 0, 0, 0, 0]\n    assert solution.placedCoins(edges, cost) == expected", "def test_placedCoins():\n    solution = Solution()\n    edges = [[0, 1], [0, 2], [1, 3]]\n    cost = [-1, -2, -3, 4]\n    expected = [0, 0, 0, 12]\n    assert solution.placedCoins(edges, cost) == expected", "def test_placedCoins():\n    solution = Solution()\n    edges = [[0, 1], [0, 2]]\n    cost = [5, 5, 5]\n    expected = [375, 125, 125]\n    assert solution.placedCoins(edges, cost) == expected", "def test_placedCoins():\n    solution = Solution()\n    edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5]]\n    cost = [-1, -2, 0, 1, -3, -4]\n    expected = [6, 0, 0, 0, 6, 6]\n    assert solution.placedCoins(edges, cost) == expected", "def test_placedCoins():\n    solution = Solution()\n    edges = [[0, 1], [0, 2], [1, 3], [1, 4]]\n    cost = [1, 1, 1, -1, -1]\n    expected = [6, 0, 0, 0, 0]\n    assert solution.placedCoins(edges, cost) == expected", "def test_placedCoins():\n    solution = Solution()\n    edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [2, 6]]\n    cost = [-5, -2, 3, -3, 4, 5, -1]\n    expected = [0, 0, 60, 6, 0, 0, 0]\n    assert solution.placedCoins(edges, cost) == expected", "def test_placedCoins():\n    solution = Solution()\n    edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5]]\n    cost = [1, -1, 2, -3, 4, -5]\n    expected = [6, 0, 0, 0, 0, 0]\n    assert solution.placedCoins(edges, cost) == expected", "def test_placedCoins():\n    solution = Solution()\n    edges = [[0, 1], [0, 2], [1, 3]]\n    cost = [-1, -2, 0, -4]\n    expected = [0, 0, 0, 1]\n    assert solution.placedCoins(edges, cost) == expected", "def test_placedCoins():\n    solution = Solution()\n    edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [2, 6]]\n    cost = [-1, -2, 2, 3, 4, 5, -6]\n    expected = [0, 0, 60, 6, 0, 0, 0]\n    assert solution.placedCoins(edges, cost) == expected", "def test_placedCoins():\n    solution = Solution()\n    edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [2, 6]]\n    cost = [-1, -2, 0, 1, 2, 3, 4]\n    expected = [6, 0, 0, 0, 0, 0, 0]\n    assert solution.placedCoins(edges, cost) == expected", "def test_placedCoins():\n    solution = Solution()\n    edges = [[0, 1], [0, 2], [1, 3], [1, 4]]\n    cost = [-1, -2, 0, -3, 4]\n    expected = [6, 0, 0, 0, 0]\n    assert solution.placedCoins(edges, cost) == expected", "def test_placedCoins():\n    solution = Solution()\n    edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [2, 6]]\n    cost = [-1, -2, 0, 1, 2, 3, 4]\n    expected = [6, 0, 0, 0, 0, 0, 0]\n    assert solution.placedCoins(edges, cost) == expected", "def test_placedCoins():\n    solution = Solution()\n    edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [2, 6]]\n    cost = [-1, -2, 2, 3, 4, 5, -6]\n    expected = [0, 0, 60, 6, 0, 0, 0]\n    assert solution.placedCoins(edges, cost) == expected", "def test_placedCoins():\n    solution = Solution()\n    edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [2, 6]]\n    cost = [-1, -2, 0, 1, 2, 3, -4]\n    expected = [6, 0, 0, 0, 0, 0, 0]\n    assert solution.placedCoins(edges, cost) == expected", "def test_placedCoins():\n    solution = Solution()\n    edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [2, 6]]\n    cost = [-1, -2, 0, 1, 2, 3, 4]\n    expected = [6, 0, 0, 0, 0, 0, 0]\n    assert solution.placedCoins(edges, cost) == expected"]}
{"task_num": 2976, "task_title": "Minimum Cost to Convert String I", "func_name": "minimumCost", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n    ans = 0\n    dist = [[math.inf] * 26 for _ in range(26)]\n\n    for a, b, c in zip(original, changed, cost):\n      u = ord(a) - ord('a')\n      v = ord(b) - ord('a')\n      dist[u][v] = min(dist[u][v], c)\n\n    for k in range(26):\n      for i in range(26):\n        if dist[i][k] < math.inf:\n          for j in range(26):\n            if dist[k][j] < math.inf:\n              dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    for s, t in zip(source, target):\n      if s == t:\n        continue\n      u = ord(s) - ord('a')\n      v = ord(t) - ord('a')\n      if dist[u][v] == math.inf:\n        return -1\n      ans += dist[u][v]\n\n    return ans\n", "tests": ["def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abc', 'cba', ['a', 'b', 'c'], ['b', 'a', 'c'], [10, 30, 5]) == 40", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abc', 'def', ['a', 'b'], ['d', 'e'], [1, 2]) == -1", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abc', 'abc', ['a', 'b', 'c'], ['d', 'e', 'f'], [10, 20, 30]) == 0", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abc', 'acb', ['a', 'b'], ['b', 'c'], [10, 5]) == 15", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abc', 'cba', ['a', 'b'], ['c', 'a'], [10, 5]) == -1", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('aaa', 'zzz', ['a', 'a'], ['b', 'c'], [1, 2]) == -1", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abc', 'zyx', ['a', 'b', 'c'], ['z', 'y', 'x'], [10, 20, 30]) == -1", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abc', 'cba', ['a', 'b', 'c'], ['b', 'a', 'd'], [10, 30, 5]) == 45", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abc', 'cba', ['a', 'b'], ['d', 'e'], [10, 20]) == -1", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abc', 'cba', ['a', 'b', 'c'], ['b', 'a', 'c'], [1, 2, 3]) == 6", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abc', 'cba', ['a', 'b', 'c'], ['b', 'c', 'a'], [10, 20, 30]) == -1", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abc', 'cba', ['a', 'b'], ['c', 'd'], [10, 20]) == -1", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abc', 'cba', ['a', 'b'], ['b', 'a'], [10]) == -1", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abc', 'cba', ['a'], ['b'], [1]) == -1", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abc', 'cba', ['a', 'b', 'c'], ['d', 'e', 'f'], [10]) == -1", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abc', 'cba', ['a', 'b'], ['c', 'a'], [10]) == -1", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abc', 'cba', ['a', 'b'], ['c', 'd'], [10]) == -1", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abc', 'cba', ['a', 'b', 'c'], ['d', 'e', 'f'], [10]) == -1", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abc', 'cba', ['a', 'b'], ['c', 'd'], [10]) == -1", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abc', 'cba', ['a', 'b', 'c'], ['b', 'c', 'a'], [10, 20, 30]) == -1"]}
{"task_num": 2977, "task_title": "Minimum Cost to Convert String II", "func_name": "minimumCost", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n    subLengths = set(len(s) for s in original)\n    subToId = self._getSubToId(original, changed)\n    subCount = len(subToId)\n    dist = [[math.inf for _ in range(subCount)] for _ in range(subCount)]\n    dp = [math.inf for _ in range(len(source) + 1)]\n\n    for a, b, c in zip(original, changed, cost):\n      u = subToId[a]\n      v = subToId[b]\n      dist[u][v] = min(dist[u][v], c)\n\n    for k in range(subCount):\n      for i in range(subCount):\n        if dist[i][k] < math.inf:\n          for j in range(subCount):\n            if dist[k][j] < math.inf:\n              dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    dp[0] = 0\n\n    for i, (s, t) in enumerate(zip(source, target)):\n      if dp[i] == math.inf:\n        continue\n      if s == t:\n        dp[i + 1] = min(dp[i + 1], dp[i])\n      for subLength in subLengths:\n        if i + subLength > len(source):\n          continue\n        subSource = source[i:i + subLength]\n        subTarget = target[i:i + subLength]\n        if subSource not in subToId or subTarget not in subToId:\n          continue\n        u = subToId[subSource]\n        v = subToId[subTarget]\n        if dist[u][v] != math.inf:\n          dp[i + subLength] = min(dp[i + subLength], dp[i] + dist[u][v])\n\n    if dp[len(source)] == math.inf:\n      return -1\n    else:\n      return dp[len(source)]\n\n  def _getSubToId(self, original: str, changed: str) -> Dict[str, int]:\n    subToId = {}\n    for s in original + changed:\n      if s not in subToId:\n        subToId[s] = len(subToId)\n    return subToId\n", "tests": ["def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abcd', 'bcda', ['ab', 'cd'], ['ef', 'gh'], [10, 20]) == -1", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abcde', 'efghi', ['ab', 'cd'], ['ef', 'gh'], [10, 20]) == 30", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abcde', 'abcde', ['ab', 'cd'], ['ef', 'gh'], [10, 20]) == 0", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('a', 'b', ['a'], ['b'], [1]) == 1", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abc', 'xyz', ['ab'], ['yz'], [5]) == 10", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abc', 'cba', ['ab', 'bc'], ['ba', 'ac'], [3, 2]) == 5", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abcdef', 'fedcba', ['abc', 'def'], ['fed', 'cba'], [10, 20]) == 30", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('aaaa', 'bbbb', ['aa'], ['bb'], [1]) == 2", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abc', 'cba', ['a'], ['c'], [1]) == -1", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abcde', 'fghij', ['a', 'b'], ['c', 'd'], [100, 200]) == -1", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abcd', 'dcba', ['ab', 'cd'], ['dc', 'ba'], [10, 20]) == 30", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abc', 'abc', ['ab'], ['cd'], [1]) == 0", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abc', 'abc', ['a'], ['b'], [1]) == -1", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abc', 'abc', ['ab'], ['bca'], [1]) == -1", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abcde', 'ghijk', ['a', 'b', 'c'], ['g', 'h', 'i'], [10, 20, 30]) == -1", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abcdef', 'fedcba', ['abc'], ['def'], [5]) == 10", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abc', 'def', ['ab'], ['cd'], [1]) == -1", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abc', 'abc', ['ab'], ['ba'], [1]) == -1", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abc', 'def', ['a'], ['b'], [1]) == -1", "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abc', 'xyz', ['ab', 'cd'], ['ef', 'gh'], [10, 20]) == 30"]}
{"task_num": 2983, "task_title": "Palindrome Rearrangement Queries", "func_name": "canMakePalindromeQueries", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n    n = len(s)\n    mirroredDiffs = self._getMirroredDiffs(s)\n    counts = self._getCounts(s)\n    ans = []\n\n    def subtractArrays(a: List[int], b: List[int]):\n      return [x - y for x, y in zip(a, b)]\n\n    for a, b, c, d in queries:\n      b += 1\n      d += 1\n      ra = n - a\n      rb = n - b\n      rc = n - c\n      rd = n - d\n\n      if (min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0) or (n // 2 > max(b, rc) and mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0):\n        ans.append(False)\n      else:\n        leftRangeCount = subtractArrays(counts[b], counts[a])\n        rightRangeCount = subtractArrays(counts[d], counts[c])\n        if a > rd:\n          rightRangeCount = subtractArrays(\n              rightRangeCount, subtractArrays(counts[min(a, rc)], counts[rd]))\n        if rc > b:\n          rightRangeCount = subtractArrays(\n              rightRangeCount, subtractArrays(counts[rc], counts[max(b, rd)]))\n        if c > rb:\n          leftRangeCount = subtractArrays(\n              leftRangeCount, subtractArrays(counts[min(c, ra)], counts[rb]))\n        if ra > d:\n          leftRangeCount = subtractArrays(\n              leftRangeCount, subtractArrays(counts[ra], counts[max(d, rb)]))\n        ans.append(min(leftRangeCount) >= 0\n                   and min(rightRangeCount) >= 0\n                   and leftRangeCount == rightRangeCount)\n\n    return ans\n\n  def _getMirroredDiffs(self, s: str) -> List[int]:\n    diffs = [0]\n    for i, j in zip(range(len(s)), reversed(range(len(s)))):\n      if i >= j:\n        break\n      diffs.append(diffs[-1] + (s[i] != s[j]))\n    return diffs\n\n  def _getCounts(self, s: str) -> List[List[int]]:\n    count = [0] * 26\n    counts = [count.copy()]\n    for c in s:\n      count[ord(c) - ord('a')] += 1\n      counts.append(count.copy())\n    return counts\n", "tests": ["def test_canMakePalindromeQueries():\n    solution = Solution()\n    assert solution.canMakePalindromeQueries('abcba', [[0, 2, 3, 5]]) == [True]", "def test_canMakePalindromeQueries():\n    solution = Solution()\n    assert solution.canMakePalindromeQueries('abcd', [[0, 1, 2, 3]]) == [False]", "def test_canMakePalindromeQueries():\n    solution = Solution()\n    assert solution.canMakePalindromeQueries('aabbccdd', [[0, 3, 4, 7]]) == [True]", "def test_canMakePalindromeQueries():\n    solution = Solution()\n    assert solution.canMakePalindromeQueries('abcddcba', [[0, 3, 4, 7]]) == [True]", "def test_canMakePalindromeQueries():\n    solution = Solution()\n    assert solution.canMakePalindromeQueries('abcdba', [[0, 2, 3, 5]]) == [False]", "def test_canMakePalindromeQueries():\n    solution = Solution()\n    assert solution.canMakePalindromeQueries('abccba', [[0, 2, 3, 5]]) == [True]", "def test_canMakePalindromeQueries():\n    solution = Solution()\n    assert solution.canMakePalindromeQueries('abcde', [[0, 2, 3, 5]]) == [False]", "def test_canMakePalindromeQueries():\n    solution = Solution()\n    assert solution.canMakePalindromeQueries('abacddcba', [[0, 2, 3, 5]]) == [True]", "def test_canMakePalindromeQueries():\n    solution = Solution()\n    assert solution.canMakePalindromeQueries('abcddcba', [[0, 1, 2, 5]]) == [False]", "def test_canMakePalindromeQueries():\n    solution = Solution()\n    assert solution.canMakePalindromeQueries('abcddcba', [[0, 3, 4, 6]]) == [True]", "def test_canMakePalindromeQueries():\n    solution = Solution()\n    assert solution.canMakePalindromeQueries('abcddcba', [[0, 2, 3, 7]]) == [True]", "def test_canMakePalindromeQueries():\n    solution = Solution()\n    assert solution.canMakePalindromeQueries('abcddcba', [[0, 3, 4, 5]]) == [False]", "def test_canMakePalindromeQueries():\n    solution = Solution()\n    assert solution.canMakePalindromeQueries('abcdedcba', [[0, 2, 3, 5]]) == [True]", "def test_canMakePalindromeQueries():\n    solution = Solution()\n    assert solution.canMakePalindromeQueries('abcdedcba', [[0, 2, 3, 7]]) == [True]", "def test_canMakePalindromeQueries():\n    solution = Solution()\n    assert solution.canMakePalindromeQueries('abcdedcba', [[0, 3, 4, 5]]) == [True]", "def test_canMakePalindromeQueries():\n    solution = Solution()\n    assert solution.canMakePalindromeQueries('abcddcba', [[0, 3, 4, 5]]) == [True]", "def test_canMakePalindromeQueries():\n    solution = Solution()\n    assert solution.canMakePalindromeQueries('abcddcba', [[0, 1, 4, 5]]) == [False]", "def test_canMakePalindromeQueries():\n    solution = Solution()\n    assert solution.canMakePalindromeQueries('abcddcba', [[0, 4, 3, 5]]) == [False]", "def test_canMakePalindromeQueries():\n    solution = Solution()\n    assert solution.canMakePalindromeQueries('abcddcba', [[0, 3, 4, 6]]) == [True]", "def test_canMakePalindromeQueries():\n    solution = Solution()\n    assert solution.canMakePalindromeQueries('abcddcba', [[0, 2, 5, 7]]) == [True]"]}
{"task_num": 3001, "task_title": "Minimum Moves to Capture The Queen", "func_name": "minMovesToCaptureTheQueen", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minMovesToCaptureTheQueen(self, a: int, b: int, c: int, d: int, e: int, f: int) -> int:\n    if a == e:\n      if c == a and (b < d < f or b > d > f):\n        return 2\n      else:\n        return 1\n    if b == f:\n      if d == f and (a < c < e or a > c > e):\n        return 2\n      else:\n        return 1\n    if c + d == e + f:\n      if a + b == c + d and (c < a < e or c > a > e):\n        return 2\n      else:\n        return 1\n    if c - d == e - f:\n      if a - b == c - d and (c < a < e or c > a > e):\n        return 2\n      else:\n        return 1\n    return 2\n", "tests": ["def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(1, 1, 2, 2, 3, 3) == 2", "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(1, 2, 2, 4, 3, 5) == 1", "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(4, 4, 2, 2, 6, 6) == 2", "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(1, 1, 3, 4, 5, 2) == 2", "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(2, 3, 4, 5, 6, 7) == 1", "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(4, 1, 2, 3, 6, 5) == 2", "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(1, 4, 3, 2, 5, 6) == 2", "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(3, 3, 1, 1, 2, 4) == 1", "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(5, 5, 7, 3, 6, 4) == 1", "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(2, 5, 4, 1, 6, 3) == 2", "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(3, 7, 1, 5, 4, 2) == 2", "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(1, 1, 4, 4, 7, 7) == 2", "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(8, 2, 6, 4, 7, 3) == 1", "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(2, 8, 4, 6, 1, 7) == 2", "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(5, 1, 3, 4, 6, 2) == 1", "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(3, 2, 5, 4, 7, 6) == 1", "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(6, 5, 4, 3, 7, 2) == 1", "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(2, 4, 5, 1, 3, 6) == 2", "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(4, 3, 2, 6, 5, 4) == 1", "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(8, 7, 6, 5, 7, 6) == 2"]}
{"task_num": 3006, "task_title": "Find Beautiful Indices in the Given Array I", "func_name": "beautifulIndices", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def beautifulIndices(self, s: str, a: str, b: str, k: int) -> List[int]:\n    ans = []\n    indicesA = self._kmp(s, a)\n    indicesB = self._kmp(s, b)\n    indicesBIndex = 0\n\n    for i in indicesA:\n      while indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i < -k:\n        indicesBIndex += 1\n      if indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i <= k:\n        ans.append(i)\n\n    return ans\n\n  def _kmp(self, s: str, pattern: str) -> List[int]:\n    def getLPS(pattern: str) -> List[int]:\n      lps = [0] * len(pattern)\n      j = 0\n      for i in range(1, len(pattern)):\n        while j > 0 and pattern[j] != pattern[i]:\n          j = lps[j - 1]\n        if pattern[i] == pattern[j]:\n          lps[i] = j + 1\n          j += 1\n      return lps\n\n    res = []\n    lps = getLPS(pattern)\n    i = 0\n    j = 0\n    while i < len(s):\n      if s[i] == pattern[j]:\n        i += 1\n        j += 1\n        if j == len(pattern):\n          res.append(i - j)\n          j = lps[j - 1]\n      elif j != 0:\n        j = lps[j - 1]\n      else:\n        i += 1\n    return res\n", "tests": ["def test_beautifulIndices():\n    solution = Solution()\n    result = solution.beautifulIndices('ababa', 'aba', 'baa', 2)", "def test_beautifulIndices():\n    solution = Solution()\n    result = solution.beautifulIndices('abcdef', 'xyz', 'uvw', 1)", "def test_beautifulIndices():\n    solution = Solution()\n    result = solution.beautifulIndices('abcabcabc', 'cab', 'bca', 1)", "def test_beautifulIndices():\n    solution = Solution()\n    result = solution.beautifulIndices('ababa', 'aab', 'aba', 2)", "def test_beautifulIndices():\n    solution = Solution()\n    result = solution.beautifulIndices('ababcaba', 'aba', 'bca', 2)", "def test_beautifulIndices():\n    solution = Solution()\n    result = solution.beautifulIndices('abcdeabcdabcde', 'abc', 'dcb', 4)", "def test_beautifulIndices():\n    solution = Solution()\n    result = solution.beautifulIndices('abcdeabcdabcde', 'aba', 'bca', 20)", "def test_beautifulIndices():\n    solution = Solution()\n    result = solution.beautifulIndices('abccbaabcde', 'abc', 'dcb', 5)", "def test_beautifulIndices():\n    solution = Solution()\n    result = solution.beautifulIndices('aaabbbccc', 'aab', 'bcc', 1)", "def test_beautifulIndices():\n    solution = Solution()\n    result = solution.beautifulIndices('abccbaabcde', 'abc', 'dcb', 3)", "def test_beautifulIndices():\n    solution = Solution()\n    result = solution.beautifulIndices('aaabbbccc', 'aab', 'bcc', 3)", "def test_beautifulIndices():\n    solution = Solution()\n    result = solution.beautifulIndices('abcababa', 'aba', 'bab', 3)", "def test_beautifulIndices():\n    solution = Solution()\n    result = solution.beautifulIndices('abcdeabcdabcde', 'aba', 'bca', 20)", "def test_beautifulIndices():\n    solution = Solution()\n    result = solution.beautifulIndices('abcababacbaabcabc', 'aba', 'bc', 20)", "def test_beautifulIndices():\n    solution = Solution()\n    result = solution.beautifulIndices('abcababacbaabcabc', 'aba', 'bc', 5)", "def test_beautifulIndices():\n    solution = Solution()\n    result = solution.beautifulIndices('abccbaabcdeabcde', 'abc', 'dcb', 5)", "def test_beautifulIndices():\n    solution = Solution()\n    result = solution.beautifulIndices('abccbaabcdeabcde', 'abc', 'dcb', 3)", "def test_beautifulIndices():\n    solution = Solution()\n    result = solution.beautifulIndices('abccbaabcdeabcde', 'abc', 'dcb', 3)", "def test_beautifulIndices():\n    solution = Solution()\n    result = solution.beautifulIndices('abccbaabcdeabcde', 'abc', 'dcb', 3)", "def test_beautifulIndices():\n    solution = Solution()\n    result = solution.beautifulIndices('abccbaabcdeabcde', 'abc', 'dcb', 3)"]}
{"task_num": 3029, "task_title": "Minimum Time to Revert Word to Initial State I", "func_name": "minimumTimeToInitialState", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumTimeToInitialState(self, word: str, k: int) -> int:\n    n = len(word)\n    maxOps = (n - 1) // k + 1\n    z = self._zFunction(word)\n\n    for ans in range(1, maxOps):\n      if z[ans * k] >= n - ans * k:\n        return ans\n\n    return maxOps\n\n  def _zFunction(self, s: str) -> List[int]:\n    n = len(s)\n    z = [0] * n\n    l = 0\n    r = 0\n    for i in range(1, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l])\n      while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n    return z\n", "tests": ["def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState('abcde', 2) == 3", "def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState('aaaaa', 3) == 2", "def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState('abcdef', 1) == 6", "def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState('abcde', 5) == 1", "def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState('abcde', 6) == 1", "def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState('abcde', 3) == 2", "def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState('abcde', 4) == 2", "def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState('abcde', 5) == 1", "def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState('abcde', 6) == 1", "def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState('abcde', 7) == 1", "def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState('abcde', 8) == 1", "def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState('abcde', 9) == 1", "def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState('abcde', 10) == 1", "def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState('abcde', 0) == 1", "def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState('abcde', 1) == 5", "def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState('abcde', 2) == 3", "def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState('abcde', 3) == 2", "def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState('abcde', 4) == 2", "def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState('abcde', 5) == 1", "def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState('abcde', 6) == 1"]}
{"task_num": 3030, "task_title": "Find the Grid of Region Average", "func_name": "resultGrid", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def resultGrid(self, image: List[List[int]], threshold: int) -> List[List[int]]:\n    m = len(image)\n    n = len(image[0])\n    sums = [[0] * n for _ in range(m)]\n    counts = [[0] * n for _ in range(m)]\n\n    for i in range(m - 2):\n      for j in range(n - 2):\n        if self._isRegion(image, i, j, threshold):\n          subgridSum = sum(image[x][y] for x in range(i, i + 3) for y in range(j, j + 3))\n          for x in range(i, i + 3):\n            for y in range(j, j + 3):\n              sums[x][y] += subgridSum // 9\n              counts[x][y] += 1\n\n    for i in range(m):\n      for j in range(n):\n        if counts[i][j] > 0:\n          image[i][j] = sums[i][j] // counts[i][j]\n\n    return image\n\n  def _isRegion(self, image: List[List[int]], i: int, j: int, threshold: int) -> bool:\n    for x in range(i, i + 3):\n      for y in range(j, j + 3):\n        if x > i and abs(image[x][y] - image[x - 1][y]) > threshold:\n          return False\n        if y > j and abs(image[x][y] - image[x][y - 1]) > threshold:\n          return False\n    return True\n", "tests": ["def test_resultGrid():\n    solution = Solution()\n    image = [[10, 20, 30], [40, 50, 60], [70, 80, 90]]\n    threshold = 5\n    expected = [[20, 30, 40], [50, 60, 70], [80, 90, 100]]\n    assert solution.resultGrid(image, threshold) == expected", "def test_resultGrid():\n    solution = Solution()\n    image = [[5, 10, 15], [20, 25, 30], [35, 40, 45]]\n    threshold = 5\n    expected = [[5, 10, 15], [20, 25, 30], [35, 40, 45]]\n    assert solution.resultGrid(image, threshold) == expected", "def test_resultGrid():\n    solution = Solution()\n    image = [[10, 20, 30], [40, 50, 60], [70, 80, 90]]\n    threshold = 25\n    expected = [[16, 20, 24], [32, 40, 48], [56, 64, 72]]\n    assert solution.resultGrid(image, threshold) == expected", "def test_resultGrid():\n    solution = Solution()\n    image = [[i % 256 for i in range(100)] for _ in range(100)]\n    threshold = 10\n    result = solution.resultGrid(image, threshold)", "def test_resultGrid():\n    solution = Solution()\n    image = [[10, 20, 30], [40, 50, 60], [70, 80, 90]]\n    threshold = 20\n    expected = [[15, 20, 24], [35, 40, 48], [56, 64, 72]]\n    assert solution.resultGrid(image, threshold) == expected", "def test_resultGrid():\n    solution = Solution()\n    image = [[10, 20, 30]]\n    threshold = 5\n    expected = [[20, 30, 40]]\n    assert solution.resultGrid(image, threshold) == expected", "def test_resultGrid():\n    solution = Solution()\n    image = [[i % 256 for i in range(100)] for _ in range(100)]\n    threshold = 1\n    result = solution.resultGrid(image, threshold)", "def test_resultGrid():\n    import random\n    solution = Solution()\n    (m, n) = (100, 100)\n    image = [[random.randint(0, 255) for _ in range(n)] for _ in range(m)]\n    thresholds = [random.randint(0, 255) for _ in range(4)]\n    expected = []\n    for i in range(m):\n        row = []\n        for j in range(n):\n            avg = image[i][j]\n            if i > 0:\n                avg += image[i - 1][j]\n            if j > 0:\n                avg += image[i][j - 1]\n            if i < m - 1:\n                avg += image[i + 1][j]\n            if j < n - 1:\n                avg += image[i][j + 1]\n            row.append(int(avg / max(1, sum((1 for t in thresholds if abs(t - avg) <= 255)))))\n        expected.append(row)\n    result = solution.resultGrid(image, thresholds)", "def test_resultGrid():\n    solution = Solution()\n    image = [[i % 256 for i in range(100)] for _ in range(100)]\n    threshold = -10\n    expected = [[i % 256 for i in range(100)] for _ in range(100)]\n    assert solution.resultGrid(image, threshold) == expected", "def test_resultGrid():\n    solution = Solution()\n    image = [[i % 256 for i in range(100)] for _ in range(100)]\n    threshold = sum([sum(row) / len(row) for row in image]) / len(image)\n    expected = [[threshold] * 100 for _ in range(100)]\n    assert solution.resultGrid(image, [threshold]) == expected", "def test_resultGrid_all_zeros(self):\n    # Create an image with all pixel values set to zero\n    m, n = 10, 15\n    image = [[0] * n for _ in range(m)]\n    \n    # Calculate the expected threshold for an image with all zeros\n    flattened_image = [pixel for row in image for pixel in row]\n    threshold = scipy.stats.median_abs_deviation(flattened_image) * 1.4826\n    \n    # Call the function under test\n    result = Solution().resultGrid(image)\n    \n    # Verify that the result matches the expected output\n    expected_result = [[0] * n for _ in range(m)]  # All elements should be zero\n    self.assertEqual(result, expected_result)\n\n```\n", "def test_resultGrid_single_pixel(self):\n    # Create an image with a single pixel\n    m, n = 1, 1\n    image = [[255]]  # All elements should be zero\n    \n    # Calculate the expected threshold for an image with all zeros\n    flattened_image = [pixel for row in image for pixel in row]\n    threshold = scipy.stats.median_abs_deviation(flattened_image) * 1.4826\n    \n    # Call the function under test\n    result = Solution().resultGrid(image)\n    \n    # Verify that the result matches the expected output\n    expected_result = [[threshold]]  # The single pixel should be set to the threshold value\n    self.assertEqual(result, expected_result)\n\n```\n", "def test_resultGrid_uniform_row(self):\n    # Create an image with a single row of uniform pixel values\n    m, n = 1, 10\n    value = 255\n    image = [[value] * n]\n    \n    # Calculate the expected threshold for an image with all zeros\n    flattened_image = [pixel for row in image for pixel in row]\n    threshold = scipy.stats.median_abs_deviation(flattened_image) * 1.4826\n    \n    # Call the function under test\n    result = Solution().resultGrid(image)\n    \n    # Verify that the result matches the expected output\n    expected_result = [[value]]  # All elements in the row should remain the same\n    self.assertEqual(result, expected_result)\n\n```\n", "def test_resultGrid_uniform_column(self):\n    # Create an image with a single column of uniform pixel values\n    m, n = 10, 1\n    value = 255\n    image = [[value] for _ in range(m)]\n    \n    # Calculate the expected threshold for an image with all zeros\n    flattened_image = [pixel for row in image for pixel in row]\n    threshold = scipy.stats.median_abs_deviation(flattened_image) * 1.4826\n    \n    # Call the function under test\n    result = Solution().resultGrid(image)\n    \n    # Verify that the result matches the expected output\n    expected_result = [[value]] * m  # All elements in the column should remain the same\n    self.assertEqual(result, expected_result)\n\n```\n", "def test_resultGrid_large_image_with_single_difference(self):\n    # Create an image with very large dimensions but a single pixel difference\n    m, n = 100, 100\n    value = 255\n    different_value = 100\n    \n    # Create the image with all pixels set to 'value' except for one pixel which is 'different_value'\n    image = [[value] * n for _ in range(m)]\n    image[50][50] = different_value\n    \n    # Calculate the expected threshold\n    flattened_image = [pixel for row in image for pixel in row]\n    threshold = scipy.stats.median_abs_deviation(flattened_image) * 1.4826\n    \n    # Call the function under test\n    result = Solution().resultGrid(image)\n    \n    # Verify that the result matches the expected output\n    expected_result = [[value] * n for _ in range(m)]\n    expected_result[50][50] = different_value  # Only this single pixel should remain unchanged\n    \n    self.assertEqual(result, expected_result)\n\n```\n\nThis test method creates an image with dimensions 100x100, where all pixels are set to a common value except for one pixel that has a different value. It checks if the function correctly handles this scenario and ensures that only the single differing pixel remains unchanged in the resulting image.\n", "def test_resultGrid_irregular_shape(self):\n    # Create an image with an irregular shape (non-rectangular)\n    m = [1, 3, 2, 5]  # Number of elements in each row\n    value = 255\n    \n    # Initialize the image as a list of lists with varying lengths\n    image = []\n    for num_elements in m:\n        row = [value] * num_elements\n        image.append(row)\n    \n    # Calculate the expected threshold\n    flattened_image = [pixel for row in image for pixel in row]\n    threshold = scipy.stats.median_abs_deviation(flattened_image) * 1.4826\n    \n    # Call the function under test\n    result = Solution().resultGrid(image)\n    \n    # Verify that the result matches the expected output\n    expected_result = []\n    for num_elements in m:\n        row = [threshold] * num_elements\n        expected_result.append(row)\n    \n    self.assertEqual(result, expected_result)\n\n```\n\nThis test method creates an image with an irregular shape where each row has a different number of elements. It checks if the function correctly handles this scenario and ensures that all pixels are set to the threshold value in each row.\n", "def test_resultGrid_single_non_zero_pixel(self):\n    # Create an image with all pixels set to zero except for one in the center\n    m, n = 10, 10\n    value = 255\n    single_value = 1\n    \n    # Initialize the image as a list of lists with zeros\n    image = [[0] * n for _ in range(m)]\n    \n    # Set the single non-zero pixel to 'single_value'\n    center_row, center_col = m // 2, n // 2\n    image[center_row][center_col] = single_value\n    \n    # Calculate the expected threshold\n    flattened_image = [pixel for row in image for pixel in row]\n    threshold = scipy.stats.median_abs_deviation(flattened_image) * 1.4826\n    \n    # Call the function under test\n    result = Solution().resultGrid(image)\n    \n    # Verify that the result matches the expected output\n    expected_result = [[0] * n for _ in range(m)]\n    expected_result[center_row][center_col] = threshold\n    \n    self.assertEqual(result, expected_result)\n\n```\n\n### Explanation:\n1. **Create an Image**: The image is initialized with all pixels set to zero.\n2. **Set a Single Non-Zero Pixel**: A single non-zero pixel (value `1`) is placed in the center of the image.\n3. **Calculate the Threshold**: The threshold is calculated using `scipy.stats.median_abs_deviation`.\n4. **Call the Function**: The function `resultGrid` is called with this image.\n5. **Verify the Result**: The resulting image should have all pixels set to zero except for the single non-zero pixel, which should be replaced by the threshold value.\n", "def test_resultGrid_large_zeros_with_small_nonzeros(self):\n    # Create an image with a large number of zeros and a small region of non-zero pixels\n    m, n = 100, 100\n    value = 255\n    non_zero_region_size = 10\n    \n    # Initialize the image as a list of lists with zeros\n    image = [[0] * n for _ in range(m)]\n    \n    # Set a small region of non-zero pixels at the center of the image\n    start_row, start_col = (m // 2) - (non_zero_region_size // 2), (n // 2) - (non_zero_region_size // 2)\n    for i in range(non_zero_region_size):\n        for j in range(non_zero_region_size):\n            image[start_row + i][start_col + j] = value\n    \n    # Calculate the expected threshold\n    flattened_image = [pixel for row in image for pixel in row]\n    threshold = scipy.stats.median_abs_deviation(flattened_image) * 1.4826\n    \n    # Call the function under test\n    result = Solution().resultGrid(image)\n    \n    # Verify that the result matches the expected output\n    expected_result = [[0] * n for _ in range(m)]\n    for i in range(non_zero_region_size):\n        for j in range(non_zero_region_size):\n            expected_result[start_row + i][start_col + j] = threshold\n    \n    self.assertEqual(result, expected_result)\n\n```\n\n### Explanation:\n1. **Create an Image**: The image is initialized with all pixels set to zero.\n2. **Set a Small Region of Non-Zero Pixels**: A small region of non-zero pixels (value `255`) is placed at the center of the image.\n3. **Calculate the Threshold**: The threshold is calculated using `scipy.stats.median_abs_deviation`.\n4. **Call the Function**: The function `resultGrid` is called with this image.\n5. **Verify the Result**: The resulting image should have all pixels set to zero except for the small region of non-zero pixels, which should be replaced by the threshold value.\n\nThis test method ensures that the function correctly handles images with a large number of zero pixels and does not affect the smaller region of non-zero values.\n", "def test_resultGrid_close_pixel_values(self):\n    # Create an image with pixel values close to each other\n    m, n = 10, 10\n    value = 256\n    \n    # Initialize the image as a list of lists with slightly varying pixel values\n    image = [[value + i] * n for _ in range(m)]\n    \n    # Calculate the expected threshold (MAD should be very small)\n    flattened_image = [pixel for row in image for pixel in row]\n    threshold = scipy.stats.median_abs_deviation(flattened_image) * 1.4826\n    \n    # Call the function under test\n    result = Solution().resultGrid(image)\n    \n    # Verify that the result matches the expected output\n    expected_result = [[value] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if abs(flattened_image[i * n + j] - value) > threshold:\n                expected_result[i][j] = flattened_image[i * n + j]\n    \n    self.assertEqual(result, expected_result)\n\n```\n\n### Explanation:\n1. **Create an Image**: The image is initialized with pixel values that are slightly varying but close to each other.\n2. **Calculate the Threshold**: The threshold is calculated using `scipy.stats.median_abs_deviation`. Given that the pixel values are close, the MAD should be very small.\n3. **Call the Function**: The function `resultGrid` is called with this image.\n4. **Verify the Result**: The resulting image should have all pixels set to the median value (which is close to `value`) except for any pixels that are significantly different from the others, which should remain unchanged.\n", "def test_resultGrid_mostly_identical_pixels(self):\n    # Create an image with mostly identical pixel values and one differing pixel\n    m, n = 10, 10\n    value = 255\n    different_value = 1\n    \n    # Initialize the image as a list of lists with most pixels set to 'value'\n    image = [[value] * n for _ in range(m)]\n    \n    # Set one pixel to a different value\n    different_row, different_col = m // 2, n // 2\n    image[different_row][different_col] = different_value\n    \n    # Calculate the expected threshold (MAD should be significant)\n    flattened_image = [pixel for row in image for pixel in row]\n    threshold = scipy.stats.median_abs_deviation(flattened_image) * 1.4826\n    \n    # Call the function under test\n    result = Solution().resultGrid(image)\n    \n    # Verify that the result matches the expected output\n    expected_result = [[value] * n for _ in range(m)]\n    expected_result[different_row][different_col] = flattened_image[different_row * n + different_col]\n    \n    self.assertEqual(result, expected_result)\n\n```\n\n### Explanation:\n1. **Create an Image**: The image is initialized with most pixels set to a common value (`255`) and one pixel set to a different value (`1`).\n2. **Calculate the Threshold**: The threshold is calculated using `scipy.stats.median_abs_deviation`. Given that there is one differing pixel, the MAD should be significant.\n3. **Call the Function**: The function `resultGrid` is called with this image.\n4. **Verify the Result**: The resulting image should have all pixels set to the common value except for the single differing pixel, which should remain unchanged.\n"]}
{"task_num": 3043, "task_title": "Find the Length of the Longest Common Prefix", "func_name": "longestCommonPrefix", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass TrieNode:\n  def __init__(self):\n    self.children: Dict[str, TrieNode] = {}\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def insert(self, word: str) -> None:\n    node: TrieNode = self.root\n    for c in word:\n      node = node.children.setdefault(c, TrieNode())\n    node.isWord = True\n\n  def search(self, word: str) -> int:\n    prefixLength = 0\n    node = self.root\n    for c in word:\n      if c not in node.children:\n        break\n      node = node.children[c]\n      prefixLength += 1\n    return prefixLength\n\n\nclass Solution:\n  def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:\n    trie = Trie()\n\n    for num in arr1:\n      trie.insert(str(num))\n\n    return max(trie.search(str(num)) for num in arr2)\n", "tests": ["def test_longestCommonPrefix():\n    solution = Solution()\n    assert solution.longestCommonPrefix([123, 456], [789, 124]) == 0", "def test_longestCommonPrefix():\n    solution = Solution()\n    assert solution.longestCommonPrefix([111, 222], [333, 444]) == 0", "def test_longestCommonPrefix():\n    solution = Solution()\n    assert solution.longestCommonPrefix([123456], [123, 789]) == 3", "def test_longestCommonPrefix():\n    solution = Solution()\n    assert solution.longestCommonPrefix([1001, 2020], [3003, 4004]) == 0", "def test_longestCommonPrefix():\n    solution = Solution()\n    assert solution.longestCommonPrefix([12345], [12345]) == 5", "def test_longestCommonPrefix():\n    solution = Solution()\n    assert solution.longestCommonPrefix([123456789], [12345]) == 5", "def test_longestCommonPrefix():\n    solution = Solution()\n    assert solution.longestCommonPrefix([1234], [4321]) == 0", "def test_longestCommonPrefix():\n    solution = Solution()\n    assert solution.longestCommonPrefix([1000], [123]) == 1", "def test_longestCommonPrefix():\n    solution = Solution()\n    assert solution.longestCommonPrefix([123, 456], [789, 123]) == 3", "def test_longestCommonPrefix():\n    solution = Solution()\n    assert solution.longestCommonPrefix([12345], [54321]) == 0", "def test_longestCommonPrefix():\n    solution = Solution()\n    assert solution.longestCommonPrefix([1], [1]) == 1", "def test_longestCommonPrefix():\n    solution = Solution()\n    assert solution.longestCommonPrefix([123456789], [12345678]) == 8", "def test_longestCommonPrefix():\n    solution = Solution()\n    assert solution.longestCommonPrefix([12345], [54321]) == 0", "def test_longestCommonPrefix():\n    solution = Solution()\n    assert solution.longestCommonPrefix([12345], [12345]) == 5", "def test_longestCommonPrefix():\n    solution = Solution()\n    assert solution.longestCommonPrefix([1234], [4567]) == 0", "def test_longestCommonPrefix():\n    solution = Solution()\n    assert solution.longestCommonPrefix([1234567], [76543]) == 0", "def test_longestCommonPrefix():\n    solution = Solution()\n    assert solution.longestCommonPrefix([123456789], [9876543]) == 0", "def test_longestCommonPrefix():\n    solution = Solution()\n    assert solution.longestCommonPrefix([12345], [54321]) == 0", "def test_longestCommonPrefix():\n    solution = Solution()\n    assert solution.longestCommonPrefix([12345], [123]) == 3", "def test_longestCommonPrefix():\n    solution = Solution()\n    assert solution.longestCommonPrefix([123456], [12345]) == 5"]}
{"task_num": 3044, "task_title": "Most Frequent Prime", "func_name": "mostFrequentPrime", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def mostFrequentPrime(self, mat: List[List[int]]) -> int:\n    dirs = ((1, 0), (1, -1), (0, -1), (-1, -1),\n            (-1, 0), (-1, 1), (0, 1), (1, 1))\n    m = len(mat)\n    n = len(mat[0])\n    count = collections.Counter()\n\n    def isPrime(num: int) -> bool:\n      return not any(num % i == 0 for i in range(2, int(num**0.5 + 1)))\n\n    for i in range(m):\n      for j in range(n):\n        for dx, dy in dirs:\n          num = 0\n          x = i\n          y = j\n          while 0 <= x < m and 0 <= y < n:\n            num = num * 10 + mat[x][y]\n            if num > 10 and isPrime(num):\n              count[num] += 1\n            x += dx\n            y += dy\n\n    if not count.items():\n      return -1\n    return max(count.items(), key=lambda x: (x[1], x[0]))[0]\n", "tests": ["def test_mostFrequentPrime():\n    solution = Solution()\n    assert solution.mostFrequentPrime([[1, 2], [3, 4]]) == -1", "def test_mostFrequentPrime():\n    solution = Solution()\n    assert solution.mostFrequentPrime([[2, 3], [5, 7]]) == 7", "def test_mostFrequentPrime():\n    solution = Solution()\n    assert solution.mostFrequentPrime([[10, 2], [3, 47]]) == 47", "def test_mostFrequentPrime():\n    solution = Solution()\n    assert solution.mostFrequentPrime([[100, 2], [3, 5]]) == 5", "def test_mostFrequentPrime():\n    solution = Solution()\n    assert solution.mostFrequentPrime([[1000, 2], [3, 5]]) == 5", "def test_mostFrequentPrime():\n    solution = Solution()\n    assert solution.mostFrequentPrime([[10, 2], [3, 4]]) == -1", "def test_mostFrequentPrime():\n    solution = Solution()\n    assert solution.mostFrequentPrime([[2, 3], [5, 7]]) == 7", "def test_mostFrequentPrime():\n    solution = Solution()\n    assert solution.mostFrequentPrime([[100, 2], [3, 47]]) == 47", "def test_mostFrequentPrime():\n    solution = Solution()\n    assert solution.mostFrequentPrime([[1000, 2], [3, 5]]) == 5", "def test_mostFrequentPrime():\n    solution = Solution()\n    assert solution.mostFrequentPrime([[2, 3], [5, 7]]) == 7", "def test_mostFrequentPrime():\n    solution = Solution()\n    assert solution.mostFrequentPrime([[100, 2], [3, 47]]) == 47", "def test_mostFrequentPrime():\n    solution = Solution()\n    assert solution.mostFrequentPrime([[1000, 2], [3, 5]]) == 5", "def test_mostFrequentPrime():\n    solution = Solution()\n    assert solution.mostFrequentPrime([[2, 3], [5, 7]]) == 7", "def test_mostFrequentPrime():\n    solution = Solution()\n    assert solution.mostFrequentPrime([[10, 2], [3, 4]]) == -1", "def test_mostFrequentPrime():\n    solution = Solution()\n    assert solution.mostFrequentPrime([[2, 3], [5, 7]]) == 7", "def test_mostFrequentPrime():\n    solution = Solution()\n    assert solution.mostFrequentPrime([[100, 2], [3, 47]]) == 47", "def test_mostFrequentPrime():\n    solution = Solution()\n    assert solution.mostFrequentPrime([[1000, 2], [3, 5]]) == 5", "def test_mostFrequentPrime():\n    solution = Solution()\n    assert solution.mostFrequentPrime([[2, 3], [5, 7]]) == 7", "def test_mostFrequentPrime():\n    solution = Solution()\n    assert solution.mostFrequentPrime([[100, 2], [3, 47]]) == 47", "def test_mostFrequentPrime():\n    solution = Solution()\n    assert solution.mostFrequentPrime([[1000, 2], [3, 5]]) == 5"]}
{"task_num": 3072, "task_title": "Distribute Elements Into Two Arrays II", "func_name": "resultArray", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass FenwickTree:\n  def __init__(self, n: int):\n    self.sums = [0] * (n + 1)\n\n  def update(self, i: int, delta: int) -> None:\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def resultArray(self, nums: List[int]) -> List[int]:\n    arr1 = []\n    arr2 = []\n    ranks = self._getRanks(nums)\n    tree1 = FenwickTree(len(ranks))\n    tree2 = FenwickTree(len(ranks))\n\n    def add(num: int, arr: List[int], tree: FenwickTree) -> None:\n      arr.append(num)\n      tree.update(ranks[num], 1)\n\n    add(nums[0], arr1, tree1)\n    add(nums[1], arr2, tree2)\n\n    for i in range(2, len(nums)):\n      greaterCount1 = len(arr1) - tree1.get(ranks[nums[i]])\n      greaterCount2 = len(arr2) - tree2.get(ranks[nums[i]])\n      if greaterCount1 > greaterCount2:\n        add(nums[i], arr1, tree1)\n      elif greaterCount1 < greaterCount2:\n        add(nums[i], arr2, tree2)\n      elif len(arr1) > len(arr2):\n        add(nums[i], arr2, tree2)\n      else:\n        add(nums[i], arr1, tree1)\n\n    return arr1 + arr2\n\n  def _getRanks(self, nums: List[int]) -> Dict[int, int]:\n    ranks = collections.Counter()\n    rank = 0\n    for num in sorted(set(nums)):\n      rank += 1\n      ranks[num] = rank\n    return ranks\n", "tests": ["def test_resultArray():\n    solution = Solution()\n    assert solution.resultArray([3, 1, 2]) == [3, 1, 2], 'Test case 1 failed'", "def test_resultArray():\n    solution = Solution()\n    assert solution.resultArray([2, 3, 1]) == [3, 2, 1], 'Test case 2 failed'", "def test_resultArray():\n    solution = Solution()\n    assert solution.resultArray([1, 3, 2]) == [3, 2, 1], 'Test case 3 failed'", "def test_resultArray():\n    solution = Solution()\n    assert solution.resultArray([5, 3, 4, 1, 2]) == [5, 4, 3, 2, 1], 'Test case 4 failed'", "def test_resultArray():\n    solution = Solution()\n    assert solution.resultArray([4, 4, 1, 2, 3]) == [4, 4, 2, 3, 1], 'Test case 5 failed'", "def test_resultArray():\n    solution = Solution()\n    assert solution.resultArray([10, 20, 30, 40, 50]) == [10, 20, 30, 40, 50], 'Test case 6 failed'", "def test_resultArray():\n    solution = Solution()\n    assert solution.resultArray([50, 40, 30, 20, 10]) == [50, 40, 30, 20, 10], 'Test case 7 failed'", "def test_resultArray():\n    solution = Solution()\n    assert solution.resultArray([1, 2, 3, 4, 5, 6, 7, 8, 9]) == [1, 2, 3, 4, 5, 6, 7, 8, 9], 'Test case 8 failed'", "def test_resultArray():\n    solution = Solution()\n    assert solution.resultArray([9, 8, 7, 6, 5, 4, 3, 2, 1]) == [9, 8, 7, 6, 5, 4, 3, 2, 1], 'Test case 9 failed'", "def test_resultArray():\n    solution = Solution()\n    assert solution.resultArray([10, 20, 30, 40, 50, 60, 70, 80, 90, 1]) == [10, 20, 30, 40, 50, 60, 70, 80, 90, 1], 'Test case 10 failed'", "def test_resultArray():\n    solution = Solution()\n    assert solution.resultArray([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 'Test case 11 failed'", "def test_resultArray():\n    solution = Solution()\n    assert solution.resultArray([5, 10, 7, 3, 8]) == [10, 8, 7, 5, 3], 'Test case 12 failed'", "def test_resultArray():\n    solution = Solution()\n    assert solution.resultArray([100, 200, 300, -50, -100]) == [200, 300, 100, -50, -100], 'Test case 13 failed'", "def test_resultArray():\n    solution = Solution()\n    assert solution.resultArray([10, 5, 8, 3, 7]) == [10, 8, 7, 5, 3], 'Test case 14 failed'", "def test_resultArray():\n    solution = Solution()\n    assert solution.resultArray([10, 5, 8, 3, 7, 2]) == [10, 8, 7, 5, 3, 2], 'Test case 15 failed'", "def test_resultArray():\n    solution = Solution()\n    assert solution.resultArray([10, 5, 8, 3, 7, 2, 9]) == [10, 9, 8, 7, 5, 3, 2], 'Test case 16 failed'", "def test_resultArray():\n    solution = Solution()\n    assert solution.resultArray([10, 5, 8, 3, 7, 2, 9, 6]) == [10, 9, 8, 7, 6, 5, 3, 2], 'Test case 17 failed'", "def test_resultArray():\n    solution = Solution()\n    assert solution.resultArray([10, 5, 8, 3, 7, 2, 9, 6, 4]) == [10, 9, 8, 7, 6, 5, 4, 3, 2], 'Test case 18 failed'", "def test_resultArray():\n    solution = Solution()\n    assert solution.resultArray([10, 5, 8, 3, 7, 2, 9, 6, 4, 1]) == [10, 9, 8, 7, 6, 5, 4, 3, 2, 1], 'Test case 19 failed'", "def test_resultArray():\n    solution = Solution()\n    assert solution.resultArray([50, 30, 60, 40, 20]) == [50, 60, 40, 30, 20], 'Test case 20 failed'"]}
{"task_num": 3095, "task_title": "Shortest Subarray With OR at Least K I", "func_name": "minimumSubarrayLength", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumSubarrayLength(self, nums: List[int], k: int) -> int:\n    ans = len(nums) + 1\n    ors = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, num in enumerate(nums):\n      ors = self._orNum(ors, num, count)\n      while ors >= k and l <= r:\n        ans = min(ans, r - l + 1)\n        ors = self._undoOrNum(ors, nums[l], count)\n        l += 1\n\n    return -1 if ans == len(nums) + 1 else ans\n\n  def _orNum(self, ors: int, num: int, count: Dict[int, int]) -> int:\n    for i in range(30):\n      if num >> i & 1:\n        count[i] += 1\n        if count[i] == 1:\n          ors += 1 << i\n    return ors\n\n  def _undoOrNum(self, ors: int, num: int, count: Dict[int, int]) -> int:\n    for i in range(30):\n      if num >> i & 1:\n        count[i] -= 1\n        if count[i] == 0:\n          ors -= 1 << i\n    return ors\n", "tests": ["def test_minimumSubarrayLength():\n    solution = Solution()\n    result = solution.minimumSubarrayLength([1, 2, 3], 5)", "def test_minimumSubarrayLength():\n    solution = Solution()\n    result = solution.minimumSubarrayLength([], 1)", "def test_minimumSubarrayLength():\n    solution = Solution()\n    result = solution.minimumSubarrayLength([1, 2], 5)", "def test_minimumSubarrayLength():\n    solution = Solution()\n    result = solution.minimumSubarrayLength([0, 3, 5], 6)", "def test_minimumSubarrayLength():\n    solution = Solution()\n    result = solution.minimumSubarrayLength([1, 2, 3, 1], 4)", "def test_minimumSubarrayLength():\n    solution = Solution()\n    result = solution.minimumSubarrayLength([5], 4)", "def test_minimumSubarrayLength():\n    solution = Solution()\n    result = solution.minimumSubarrayLength([0], 10)", "def test_minimumSubarrayLength():\n    solution = Solution()\n    result = solution.minimumSubarrayLength([20], 10)", "def test_minimumSubarrayLength():\n    solution = Solution()\n    result = solution.minimumSubarrayLength([1, 1, 1], 3)", "def test_minimumSubarrayLength():\n    solution = Solution()\n    result = solution.minimumSubarrayLength([2, 4, 8, 16, 32, 64, 1], 65)", "def test_minimumSubarrayLength():\n    solution = Solution()\n    result = solution.minimumSubarrayLength([5], 4)", "def test_minimumSubarrayLength():\n    solution = Solution()\n    nums = [i for i in range(1000)]\n    k = 999\n    result = solution.minimumSubarrayLength(nums, k)", "def test_minimumSubarrayLength():\n    solution = Solution()\n    result = solution.minimumSubarrayLength([0] * 1000, 500)", "def test_minimumSubarrayLength():\n    solution = Solution()\n    result = solution.minimumSubarrayLength([5], 10)", "def test_minimumSubarrayLength():\n    solution = Solution()\n    result = solution.minimumSubarrayLength([0], 1)", "def test_minimumSubarrayLength():\n    solution = Solution()\n    nums = [i for i in range(1000)]\n    k = sum(nums) // 2\n    result = solution.minimumSubarrayLength(nums, k)", "def test_minimumSubarrayLength():\n    solution = Solution()\n    nums = [1] * 500 + [2] * 500\n    k = sum(nums) // 4\n    result = solution.minimumSubarrayLength(nums, k)", "def test_minimumSubarrayLength():\n    solution = Solution()\n    result = solution.minimumSubarrayLength([1024] * 5, 3072)", "def test_minimumSubarrayLength():\n    solution = Solution()\n    result = solution.minimumSubarrayLength([0], 10)", "def test_minimumSubarrayLength():\n    solution = Solution()\n    result = solution.minimumSubarrayLength([1, 2, 4, 8, 16], 32)"]}
{"task_num": 3102, "task_title": "Minimize Manhattan Distances", "func_name": "minimumDistance", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumDistance(self, points: List[List[int]]) -> int:\n    i, j = self._maxManhattanDistance(points, -1)\n    xi, yi = self._maxManhattanDistance(points, i)\n    xj, yj = self._maxManhattanDistance(points, j)\n    return min(self._manhattan(points, xi, yi), self._manhattan(points, xj, yj))\n\n  def _maxManhattanDistance(self, points: List[List[int]], excludedIndex: int) -> int:\n    minSum = math.inf\n    maxSum = -math.inf\n    minDiff = math.inf\n    maxDiff = -math.inf\n    minSumIndex = -1\n    maxSumIndex = -1\n    minDiffIndex = -1\n    maxDiffIndex = -1\n\n    for i, (x, y) in enumerate(points):\n      if i == excludedIndex:\n        continue\n      summ = x + y\n      diff = x - y\n      if summ < minSum:\n        minSum = summ\n        minSumIndex = i\n      if summ > maxSum:\n        maxSum = summ\n        maxSumIndex = i\n      if diff < minDiff:\n        minDiff = diff\n        minDiffIndex = i\n      if diff > maxDiff:\n        maxDiff = diff\n        maxDiffIndex = i\n\n    if maxSum - minSum >= maxDiff - minDiff:\n      return [minSumIndex, maxSumIndex]\n    else:\n      return [minDiffIndex, maxDiffIndex]\n\n  def _manhattan(self, points: List[List[int]], i: int, j: int) -> int:\n    return abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n", "tests": ["def test_minimumDistance():\n    solution = Solution()\n    assert solution.minimumDistance([[1, 2], [3, 4], [5, 6]]) == 0", "def test_minimumDistance():\n    solution = Solution()\n    assert solution.minimumDistance([[10]]) == 0", "def test_minimumDistance():\n    solution = Solution()\n    assert solution.minimumDistance([[-1, -2], [-3, -4], [-5, -6]]) == 0", "def test_minimumDistance():\n    solution = Solution()\n    assert solution.minimumDistance([[1, 2], [1, 2], [3, 4]]) == 0", "def test_minimumDistance():\n    solution = Solution()\n    assert solution.minimumDistance([[1000, 2000], [3000, 4000], [5000, 6000]]) == 0", "def test_minimumDistance():\n    solution = Solution()\n    assert solution.minimumDistance([[1, 1], [2, 4], [3, 5]]) == 0", "def test_minimumDistance():\n    solution = Solution()\n    assert solution.minimumDistance([[1, 3], [4, 2], [5, 8], [9, 6]]) == 0", "def test_minimumDistance():\n    solution = Solution()\n    assert solution.minimumDistance([[1, 2], [3, 4], [5, 6]]) == 0", "def test_minimumDistance():\n    solution = Solution()\n    assert solution.minimumDistance([[1, 2], [1000, 1000], [-1000, -1000]]) == 0", "def test_minimumDistance():\n    solution = Solution()\n    assert solution.minimumDistance([[1, 2], [1, 3], [1, 4]]) == 0", "def test_minimumDistance():\n    solution = Solution()\n    assert solution.minimumDistance([[1, 2], [3, 2], [4, 2]]) == 0", "def test_minimumDistance():\n    solution = Solution()\n    assert solution.minimumDistance([[1, 2], [3, -4], [-5, 6], [7, -8]]) == 0", "def test_minimumDistance():\n    solution = Solution()\n    points = [[i % 10, i // 10] for i in range(100)]\n    assert solution.minimumDistance(points) == 0", "def test_minimumDistance():\n    solution = Solution()\n    assert solution.minimumDistance([[1, 2], [3, 4]]) == abs(1 - 3) + abs(2 - 4)", "def test_minimumDistance():\n    solution = Solution()\n    assert solution.minimumDistance([[1, 2], [3, 4]]) == abs(1 - 3) + abs(2 - 4)", "def test_minimumDistance():\n    solution = Solution()\n    assert solution.minimumDistance([[1, 0], [2, 0], [3, 0]]) == 0", "def test_minimumDistance():\n    solution = Solution()\n    assert solution.minimumDistance([[0, 1], [0, 2], [0, 3]]) == 0", "def test_minimumDistance():\n    solution = Solution()\n    assert solution.minimumDistance([[0, 0], [1, 1], [2, 2]]) == 0", "def test_minimumDistance():\n    solution = Solution()\n    assert solution.minimumDistance([[1, 2], [4, 5], [7, 8], [10, 11]]) == abs(1 - 10) + abs(2 - 11)", "def test_minimumDistance():\n    solution = Solution()\n    assert solution.minimumDistance([[0, 10], [5, 5], [10, 0]]) == abs(0 - 10) + abs(10 - 0)"]}
{"task_num": 3108, "task_title": "Minimum Cost Walk in Weighted Graph", "func_name": "minimumCost", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n    self.weight = [(1 << 17) - 1] * n\n\n  def unionByRank(self, u: int, v: int, w: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    newWeight = self.weight[i] & self.weight[j] & w\n    self.weight[i] = newWeight\n    self.weight[j] = newWeight\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def getMinCost(self, u: int, v: int) -> int:\n    if u == v:\n      return 0\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return self.weight[i]\n    else:\n      return -1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def minimumCost(self, n: int, edges: List[List[int]], query: List[List[int]]) -> List[int]:\n    uf = UnionFind(n)\n\n    for u, v, w in edges:\n      uf.unionByRank(u, v, w)\n\n    return [uf.getMinCost(u, v) for u, v in query]\n", "tests": ["def test_minimumCost():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 7], [1, 2, 5], [2, 3, 9]]\n    query = [[0, 3], [1, 2]]\n    expected = [3, 5]\n    assert solution.minimumCost(n, edges, query) == expected", "def test_minimumCost():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 7], [2, 3, 5]]\n    query = [[0, 4], [1, 2], [3, 4]]\n    expected = [-1, 3, -1]\n    assert solution.minimumCost(n, edges, query) == expected", "def test_minimumCost():\n    solution = Solution()\n    n = 1\n    edges = []\n    query = [[0, 0]]\n    expected = [0]\n    assert solution.minimumCost(n, edges, query) == expected", "def test_minimumCost():\n    solution = Solution()\n    n = 10\n    edges = [[0, 1, 7], [1, 2, 5], [2, 3, 9], [3, 4, 8], [4, 0, 6], [5, 6, 2], [6, 7, 4], [7, 8, 3], [8, 9, 1], [9, 5, 7]]\n    query = [[0, 9], [1, 8], [2, 7], [3, 6], [4, 5], [5, 4], [6, 3], [7, 2], [8, 1], [9, 0]]\n    expected = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n    assert solution.minimumCost(n, edges, query) == expected", "def test_minimumCost():\n    solution = Solution()\n    n = 2\n    edges = [[0, 1, 3]]\n    query = [[0, 1], [1, 0]]\n    expected = [3, 3]\n    assert solution.minimumCost(n, edges, query) == expected", "def test_minimumCost():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 5], [1, 2, 5], [2, 0, 5]]\n    query = [[0, 2], [1, 0], [2, 1]]\n    expected = [5, 5, 5]\n    assert solution.minimumCost(n, edges, query) == expected", "def test_minimumCost():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, -5], [1, 2, -3], [2, 0, -7]]\n    query = [[0, 2], [1, 0], [2, 1]]\n    expected = [-1, -1, -1]\n    assert solution.minimumCost(n, edges, query) == expected", "def test_minimumCost():\n    solution = Solution()\n    n = 6\n    edges = [[0, 1, 7], [1, 2, 5], [2, 3, 9], [3, 4, 8], [4, 0, 6], [5, 0, 3], [5, 1, 2], [5, 2, 4], [5, 3, 6], [5, 4, 5]]\n    query = [[0, 5], [1, 5], [2, 5], [3, 5], [4, 5], [5, 0], [5, 1], [5, 2], [5, 3], [5, 4]]\n    expected = [3, 2, 4, 6, 5, 3, 2, 4, 6, 5]\n    assert solution.minimumCost(n, edges, query) == expected", "def test_minimumCost():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 7], [1, 2, 5]]\n    query = [[0, 2], [1, 0], [2, 1], [3, 4]]\n    expected = [5, 7, 5, -1]\n    assert solution.minimumCost(n, edges, query) == expected", "def test_minimumCost():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 7], [1, 2, 5], [2, 3, 9], [3, 0, 3]]\n    query = [[0, 2], [1, 3], [2, 0], [3, 1]]\n    expected = [3, 3, 3, 3]\n    assert solution.minimumCost(n, edges, query) == expected", "def test_minimumCost():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 7], [1, 2, 5]]\n    query = [[0, 2], [1, 0], [2, 1], [0, 2], [1, 0], [2, 1], [0, 2], [1, 0], [2, 1], [0, 2], [1, 0], [2, 1]]\n    expected = [5, 7, 5] * 4\n    assert solution.minimumCost(n, edges, query) == expected", "def test_minimumCost():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 7], [1, 2, 5], [2, 3, 9], [3, 0, 7]]\n    query = [[0, 2], [1, 3], [2, 0], [3, 1]]\n    expected = [7, 7, 7, 7]\n    assert solution.minimumCost(n, edges, query) == expected", "def test_minimumCost():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 7], [2, 3, 5]]\n    query = [[0, 2], [1, 3], [2, 0], [3, 1], [0, 3], [1, 2], [2, 1], [3, 0]]\n    expected = [-1, -1, -1, -1, -1, -1, -1, -1]\n    assert solution.minimumCost(n, edges, query) == expected", "def test_minimumCost():\n    solution = Solution()\n    n = 2\n    edges = [[0, 1, 7]]\n    query = [[0, 0], [1, 1]]\n    expected = [0, 0]\n    assert solution.minimumCost(n, edges, query) == expected", "def test_minimumCost():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 7], [0, 2, 5], [1, 0, 7], [1, 2, 5], [2, 0, 5], [2, 1, 5]]\n    query = [[0, 1], [1, 2], [2, 0]]\n    expected = [7, 5, 7]\n    assert solution.minimumCost(n, edges, query) == expected", "def test_minimumCost():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, -5], [1, 2, 3], [2, 3, 9], [3, 0, 7]]\n    query = [[0, 2], [1, 3], [2, 0], [3, 1]]\n    expected = [-1, 3, -1, 3]\n    assert solution.minimumCost(n, edges, query) == expected", "def test_minimumCost():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 0], [1, 2, 0], [2, 3, 0], [3, 0, 0]]\n    query = [[0, 2], [1, 3], [2, 0], [3, 1]]\n    expected = [0, 0, 0, 0]\n    assert solution.minimumCost(n, edges, query) == expected", "def test_minimumCost():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 7]]\n    query = [[2, 3], [1, 0], [3, 2], [0, 3]]\n    expected = [-1, 7, -1, -1]\n    assert solution.minimumCost(n, edges, query) == expected", "def test_minimumCost():\n    solution = Solution()\n    n = 100\n    edges = [[i, (i + 1) % n, i] for i in range(n)]\n    query = [[i, (i + 2) % n] for i in range(n)]\n    expected = [n - 1] * n\n    assert solution.minimumCost(n, edges, query) == expected", "def test_minimumCost():\n    solution = Solution()\n    n = 1\n    edges = []\n    query = [[0, 0]]\n    expected = [0]\n    assert solution.minimumCost(n, edges, query) == expected"]}
{"task_num": 3112, "task_title": "Minimum Time to Visit Disappearing Nodes", "func_name": "minimumTime", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, 0, disappear)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, disappear: List[int]) -> List[int]:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < disappear[v] and d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    res=[]\n    for d in dist:\n      if d != math.inf:\n        res.append(d)\n      else:\n        res.append(-1)\n    return res\n", "tests": ["def test_minimumTime():\n    solution = Solution()\n    assert solution.minimumTime(4, [[0, 1, 2], [1, 2, 3], [0, 3, 1]], [5, 4, 6, 7]) == [0, 2, -1, 1]", "def test_minimumTime():\n    solution = Solution()\n    assert solution.minimumTime(3, [[0, 1, 2], [1, 2, 3]], [4, 5, 6]) == [0, -1, -1]", "def test_minimumTime():\n    solution = Solution()\n    assert solution.minimumTime(3, [[0, 1, 2], [1, 2, 1], [2, 0, 5]], [4, 5, 6]) == [0, 1, -1]", "def test_minimumTime():\n    solution = Solution()\n    assert solution.minimumTime(4, [[0, 1, 2], [1, 2, 3], [2, 3, 4]], [1, 2, 3, 4]) == [-1, -1, -1, -1]", "def test_minimumTime():\n    solution = Solution()\n    n = 100\n    edges = [[i, (i + 1) % n, 1] for i in range(n)]\n    disappear = [math.inf] * n\n    assert solution.minimumTime(n, edges, disappear) == [-1] * n", "def test_minimumTime():\n    solution = Solution()\n    assert solution.minimumTime(1, [], [0]) == [0]", "def test_minimumTime():\n    solution = Solution()\n    assert solution.minimumTime(3, [[0, 1, 1], [1, 2, 1]], [1, 1, 1]) == [-1, -1, -1]", "def test_minimumTime():\n    solution = Solution()\n    assert solution.minimumTime(3, [[0, 1, -2], [1, 2, -3]], [5, 4, 6]) == [-1, -1, -1]", "def test_minimumTime():\n    solution = Solution()\n    assert solution.minimumTime(5, [[0, 1, 2], [2, 3, 3]], [4, 5, 6, 7, 8]) == [0, -1, 3, -1, -1]", "def test_minimumTime():\n    solution = Solution()\n    assert solution.minimumTime(3, [[0, 1, 100], [1, 2, 100]], [5, 4, 6]) == [-1, -1, -1]", "def test_minimumTime():\n    solution = Solution()\n    assert solution.minimumTime(3, [[0, 1, 5], [1, 2, 5]], [4, 5, 6]) == [-1, 10, 15]", "def test_minimumTime():\n    solution = Solution()\n    assert solution.minimumTime(3, [[0, 1, 2], [1, 2, 3]], [1, 1, 1]) == [-1, -1, -1]", "def test_minimumTime():\n    solution = Solution()\n    n = 200\n    edges = [[i, (i + 1) % n, 2] for i in range(n)]\n    disappear = [math.inf] * n\n    assert solution.minimumTime(n, edges, disappear) == [-1] * n", "def test_minimumTime():\n    solution = Solution()\n    assert solution.minimumTime(3, [[0, 1, 1], [1, 2, 1]], [5, 4, 6]) == [0, 1, 2]", "def test_minimumTime():\n    solution = Solution()\n    assert solution.minimumTime(3, [[0, 1, 0], [1, 2, 0]], [4, 5, 6]) == [-1, -1, -1]", "def test_minimumTime():\n    solution = Solution()\n    assert solution.minimumTime(1, [], [0]) == [-1]", "def test_minimumTime():\n    solution = Solution()\n    assert solution.minimumTime(1, [], [0, 1, 2]) == [-1]", "def test_minimumTime():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5]]\n    disappear = [math.inf] * n\n    disappear[2] = 1\n    assert solution.minimumTime(n, edges, disappear) == [-1, -1, -1, -1, -1]", "def test_minimumTime():\n    solution = Solution()\n    assert solution.minimumTime(2, [[0, 1, 100]], [5, 4]) == [-1, -1]", "def test_minimumTime():\n    solution = Solution()\n    n = 200\n    edges = []\n    disappear = [math.inf] * n\n    for i in range(n):\n        if i < n - 1:\n            edges.append([i, i + 1, 1])\n    assert solution.minimumTime(n, edges, disappear) == [-1] * n"]}
{"task_num": 3123, "task_title": "Find Edges in Shortest Paths", "func_name": "findAnswer", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findAnswer(self, n: int, edges: List[List[int]]) -> List[bool]:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    from0 = self._dijkstra(graph, 0)\n    from1 = self._dijkstra(graph, n - 1)\n    return [from0[u] + w + from1[v] == from0[-1] or from0[v] + w + from1[u] == from0[-1] for u, v, w in edges]\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int) -> List[int]:\n    dist = [10**9] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist\n", "tests": ["def test_findAnswer():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 1], [1, 2, 1], [2, 3, 1], [0, 3, 2]]\n    expected = [False, False, True, False]\n    assert solution.findAnswer(n, edges) == expected", "def test_findAnswer():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 1], [2, 3, 1]]\n    expected = [False]\n    assert solution.findAnswer(n, edges) == expected", "def test_findAnswer():\n    solution = Solution()\n    n = 1\n    edges = []\n    expected = []\n    assert solution.findAnswer(n, edges) == expected", "def test_findAnswer():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 1], [1, 2, 1], [2, 3, 1], [0, 3, 2]]\n    expected = [True, True, True, False]\n    assert solution.findAnswer(n, edges) == expected", "def test_findAnswer():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, -1], [1, 2, -1]]\n    expected = [True]\n    assert solution.findAnswer(n, edges) == expected", "def test_findAnswer():\n    solution = Solution()\n    n = 100\n    edges = [(i, (i + 1) % n, 1) for i in range(n)]\n    expected = [False] * len(edges)\n    assert solution.findAnswer(n, edges) == expected", "def test_findAnswer():\n    solution = Solution()\n    n = 1\n    edges = [[0, 0, 2]]\n    expected = []\n    assert solution.findAnswer(n, edges) == expected", "def test_findAnswer():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 1], [1, 2, 1], [2, 3, 1], [0, 3, 2], [1, 3, 1]]\n    expected = [False, True, True, False, True]\n    assert solution.findAnswer(n, edges) == expected", "def test_findAnswer():\n    solution = Solution()\n    n = 2\n    edges = [[0, 1, 1]]\n    expected = [True]\n    assert solution.findAnswer(n, edges) == expected", "def test_findAnswer():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 2], [1, 2, 2], [2, 3, 2]]\n    expected = [False, False, False]\n    assert solution.findAnswer(n, edges) == expected", "def test_findAnswer():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, -2], [1, 2, -2]]\n    expected = [True]\n    assert solution.findAnswer(n, edges) == expected", "def test_findAnswer():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 1], [2, 3, 1]]\n    expected = [False]\n    assert solution.findAnswer(n, edges) == expected", "def test_findAnswer():\n    solution = Solution()\n    n = 1\n    edges = []\n    expected = []\n    assert solution.findAnswer(n, edges) == expected", "def test_findAnswer():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 1], [1, 2, 1], [2, 3, 1], [3, 4, 1]]\n    expected = [False, False, True, False]\n    assert solution.findAnswer(n, edges) == expected", "def test_findAnswer():\n    solution = Solution()\n    n = 2\n    edges = []\n    expected = []\n    assert solution.findAnswer(n, edges) == expected", "def test_findAnswer():\n    solution = Solution()\n    n = 1\n    edges = [[0, 0, 2]]\n    expected = []\n    assert solution.findAnswer(n, edges) == expected", "def test_findAnswer():\n    solution = Solution()\n    n = 1\n    edges = [[0, 0, 2]]\n    expected = []\n    assert solution.findAnswer(n, edges) == expected", "def test_findAnswer():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 1], [2, 1, 1]]\n    expected = [False]\n    assert solution.findAnswer(n, edges) == expected", "def test_findAnswer():\n    solution = Solution()\n    n = 1\n    edges = [[0, 0, 2], [0, 0, 3]]\n    expected = []\n    assert solution.findAnswer(n, edges) == expected", "def test_findAnswer():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 1], [2, 3, 1]]\n    expected = [False]\n    assert solution.findAnswer(n, edges) == expected"]}
