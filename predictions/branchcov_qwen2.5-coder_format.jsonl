{"task_num": 4, "task_title": "Median of Two Sorted Arrays", "func_name": "findMedianSortedArrays", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n    n1 = len(nums1)\n    n2 = len(nums2)\n    if n1 > n2:\n      return self.findMedianSortedArrays(nums2, nums1)\n\n    l = 0\n    r = n1\n\n    while l <= r:\n      partition1 = (l + r) // 2\n      partition2 = (n1 + n2 + 1) // 2 - partition1\n      maxLeft1 = -2**31 if partition1 == 0 else nums1[partition1 - 1]\n      maxLeft2 = -2**31 if partition2 == 0 else nums2[partition2 - 1]\n      minRight1 = 2**31 - 1 if partition1 == n1 else nums1[partition1]\n      minRight2 = 2**31 - 1 if partition2 == n2 else nums2[partition2]\n      if maxLeft1 <= minRight2 and maxLeft2 <= minRight1:\n        if (n1 + n2) % 2 == 0:\n          return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) * 0.5\n        else:\n          return max(maxLeft1, maxLeft2)\n      elif maxLeft1 > minRight2:\n        r = partition1 - 1\n      else:\n        l = partition1 + 1\n", "tests": [{"start": 15, "end": 16, "test": "def test_findMedianSortedArrays():\n    solution = Solution()\n    assert solution.findMedianSortedArrays([1, 3], [2]) == 2.0"}, {"start": 28, "end": 32, "test": "def test_findMedianSortedArrays():\n    solution = Solution()\n    assert solution.findMedianSortedArrays([1, 3], [2]) == 2.0"}, {"start": 29, "end": 30, "test": "def test_findMedianSortedArrays():\n    solution = Solution()\n    assert solution.findMedianSortedArrays([1, 3], [2]) == 2.0"}, {"start": 31, "end": 32, "test": "def test_findMedianSortedArrays():\n    solution = Solution()\n    assert solution.findMedianSortedArrays([1, 3], [2]) == 2.0"}, {"start": 33, "end": 34, "test": "def test_findMedianSortedArrays():\n    solution = Solution()\n    assert solution.findMedianSortedArrays([1, 2], [3, 4]) == 2.5"}, {"start": 35, "end": 36, "test": "def test_findMedianSortedArrays():\n    solution = Solution()\n    assert solution.findMedianSortedArrays([1, 2], [3, 4]) == 2.5"}]}
{"task_num": 10, "task_title": "Regular Expression Matching", "func_name": "isMatch", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isMatch(self, s: str, p: str) -> bool:\n    m = len(s)\n    n = len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    def isMatch(i: int, j: int) -> bool:\n      return j >= 0 and p[j] == '.' or s[i] == p[j]\n\n    for j, c in enumerate(p):\n      if c == '*' and dp[0][j - 1]:\n        dp[0][j + 1] = True\n\n    for i in range(m):\n      for j in range(n):\n        if p[j] == '*':\n          noRepeat = dp[i + 1][j - 1]\n          doRepeat = isMatch(i, j - 1) and dp[i][j + 1]\n          dp[i + 1][j + 1] = noRepeat or doRepeat\n        elif isMatch(i, j):\n          dp[i + 1][j + 1] = dp[i][j]\n\n    return dp[m][n]\n", "tests": [{"start": 22, "end": 23, "test": "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('a', '.*') == True"}, {"start": 27, "end": 30, "test": "def test_isMatch():\n    solution = Solution()\n    assert not solution.isMatch('a', 'ab*')"}, {"start": 31, "end": 32, "test": "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('ab', 'a.') == True"}]}
{"task_num": 15, "task_title": "3Sum", "func_name": "threeSum", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def threeSum(self, nums: List[int]) -> List[List[int]]:\n    if len(nums) < 3:\n      return []\n\n    ans = []\n\n    nums.sort()\n\n    for i in range(len(nums) - 2):\n      if i > 0 and nums[i] == nums[i - 1]:\n        continue\n\n      l = i + 1\n      r = len(nums) - 1\n      while l < r:\n        summ = nums[i] + nums[l] + nums[r]\n        if summ == 0:\n          ans.append((nums[i], nums[l], nums[r]))\n          l += 1\n          r -= 1\n          while nums[l] == nums[l - 1] and l < r:\n            l += 1\n          while nums[r] == nums[r + 1] and l < r:\n            r -= 1\n        elif summ < 0:\n          l += 1\n        else:\n          r -= 1\n\n    return ans\n", "tests": [{"start": 13, "end": 14, "test": "def test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([0]) == []"}, {"start": 21, "end": 22, "test": "def test_threeSum():\n    solution = Solution()\n    result = solution.threeSum([-1, 0, 1, 2, -1, -4])"}, {"start": 28, "end": 35, "test": "def test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([-1, 0, 1, 2, -1, -4]) == [(-1, -1, 2), (-1, 0, 1)]"}, {"start": 36, "end": 37, "test": "def test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([-1, 0, 1, 2, -1, -4]) == [(-1, -1, 2), (-1, 0, 1)]"}, {"start": 38, "end": 39, "test": "def test_threeSum():\n    solution = Solution()\n    assert solution.threeSum([-1, 0, 1, 2, -1, -4]) == [(-1, -1, 2), (-1, 0, 1)]"}]}
{"task_num": 44, "task_title": "Wildcard Matching", "func_name": "isMatch", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isMatch(self, s: str, p: str) -> bool:\n    m = len(s)\n    n = len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    def isMatch(i: int, j: int) -> bool:\n      return i >= 0 and p[j] == '?' or s[i] == p[j]\n\n    for j, c in enumerate(p):\n      if c == '*':\n        dp[0][j + 1] = dp[0][j]\n\n    for i in range(m):\n      for j in range(n):\n        if p[j] == '*':\n          matchEmpty = dp[i + 1][j]\n          matchSome = dp[i][j + 1]\n          dp[i + 1][j + 1] = matchEmpty or matchSome\n        elif isMatch(i, j):\n          dp[i + 1][j + 1] = dp[i][j]\n\n    return dp[m][n]\n", "tests": [{"start": 22, "end": 23, "test": "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('abc', '*') == True"}, {"start": 27, "end": 30, "test": "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('abc', 'a*c') == True"}, {"start": 31, "end": 32, "test": "def test_isMatch():\n    solution = Solution()\n    assert solution.isMatch('abc', 'a?c') == True"}]}
{"task_num": 54, "task_title": "Spiral Matrix", "func_name": "spiralOrder", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n    if not matrix:\n      return []\n\n    m = len(matrix)\n    n = len(matrix[0])\n    ans = []\n    r1 = 0\n    c1 = 0\n    r2 = m - 1\n    c2 = n - 1\n\n    while len(ans) < m * n:\n      j = c1\n      while j <= c2 and len(ans) < m * n:\n        ans.append(matrix[r1][j])\n        j += 1\n      i = r1 + 1\n      while i <= r2 - 1 and len(ans) < m * n:\n        ans.append(matrix[i][c2])\n        i += 1\n      j = c2\n      while j >= c1 and len(ans) < m * n:\n        ans.append(matrix[r2][j])\n        j -= 1\n      i = r2 - 1\n      while i >= r1 + 1 and len(ans) < m * n:\n        ans.append(matrix[i][c1])\n        i -= 1\n      r1 += 1\n      c1 += 1\n      r2 -= 1\n      c2 -= 1\n\n    return ans\n", "tests": [{"start": 13, "end": 14, "test": "def test_spiralOrder():\n    solution = Solution()\n    assert solution.spiralOrder([]) == []"}]}
{"task_num": 65, "task_title": "Valid Number", "func_name": "isNumber", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isNumber(self, s: str) -> bool:\n    s = s.strip()\n    if not s:\n      return False\n\n    seenNum = False\n    seenDot = False\n    seenE = False\n\n    for i, c in enumerate(s):\n      if c == '.':\n        if seenDot or seenE:\n          return False\n        seenDot = True\n      elif c == 'e' or c == 'E':\n        if seenE or not seenNum:\n          return False\n        seenE = True\n        seenNum = False\n      elif c in '+-':\n        if i > 0 and s[i - 1] not in 'eE':\n          return False\n        seenNum = False\n      else:\n        if not c.isdigit():\n          return False\n        seenNum = True\n\n    return seenNum\n", "tests": [{"start": 14, "end": 15, "test": "def test_isNumber():\n    solution = Solution()\n    assert not solution.isNumber('')"}, {"start": 22, "end": 25, "test": "def test_isNumber():\n    solution = Solution()\n    assert not solution.isNumber('3.')"}, {"start": 23, "end": 24, "test": "def test_isNumber():\n    solution = Solution()\n    assert not solution.isNumber('123.')"}, {"start": 26, "end": 30, "test": "def test_isNumber():\n    solution = Solution()\n    assert not solution.isNumber('1e')"}, {"start": 27, "end": 28, "test": "def test_isNumber():\n    solution = Solution()\n    assert not solution.isNumber('e10')"}, {"start": 31, "end": 34, "test": "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('+-123') == False"}, {"start": 35, "end": 38, "test": "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('123') == True"}, {"start": 32, "end": 33, "test": "def test_isNumber():\n    solution = Solution()\n    assert solution.isNumber('+-3') == False"}, {"start": 36, "end": 37, "test": "def test_isNumber():\n    solution = Solution()\n    assert not solution.isNumber('abc')"}]}
{"task_num": 73, "task_title": "Set Matrix Zeroes", "func_name": "setZeroes", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def setZeroes(self, matrix: List[List[int]]) -> None:\n    m = len(matrix)\n    n = len(matrix[0])\n    shouldFillFirstRow = 0 in matrix[0]\n    shouldFillFirstCol = 0 in list(zip(*matrix))[0]\n\n    for i in range(1, m):\n      for j in range(1, n):\n        if matrix[i][j] == 0:\n          matrix[i][0] = 0\n          matrix[0][j] = 0\n\n    for i in range(1, m):\n      for j in range(1, n):\n        if matrix[i][0] == 0 or matrix[0][j] == 0:\n          matrix[i][j] = 0\n\n    if shouldFillFirstRow:\n      matrix[0] = [0] * n\n\n    if shouldFillFirstCol:\n      for row in matrix:\n        row[0] = 0\n", "tests": [{"start": 29, "end": 30, "test": "def test_setZeroes():\n    solution = Solution()\n    matrix = [[1, 2, 3], [4, 0, 6], [7, 8, 9]]\n    expected = [[1, 0, 3], [0, 0, 0], [7, 0, 9]]\n    solution.setZeroes(matrix)"}, {"start": 32, "end": 34, "test": "def test_setZeroes():\n    solution = Solution()\n    matrix = [[1, 2, 3], [4, 0, 6], [7, 8, 9]]\n    expected = [[1, 0, 3], [0, 0, 0], [7, 0, 9]]\n    solution.setZeroes(matrix)"}, {"start": 20, "end": 22, "test": "def test_setZeroes():\n    solution = Solution()\n    matrix = [[1, 2, 3], [4, 0, 6], [7, 8, 9]]\n    expected = [[1, 0, 3], [0, 0, 0], [7, 0, 9]]\n    solution.setZeroes(matrix)"}, {"start": 26, "end": 27, "test": "def test_setZeroes():\n    solution = Solution()\n    matrix = [[1, 2, 3], [4, 0, 6], [7, 8, 9]]\n    expected = [[1, 0, 3], [0, 0, 0], [7, 0, 9]]\n    solution.setZeroes(matrix)"}]}
{"task_num": 97, "task_title": "Interleaving String", "func_name": "isInterleave", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n    m = len(s1)\n    n = len(s2)\n    if m + n != len(s3):\n      return False\n\n    dp=[]\n    for _ in range(m + 1):\n      dp.append([False] * (n + 1))\n    dp[0][0] = True\n\n    for i in range(1, m + 1):\n      dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n\n    for j in range(1, n + 1):\n      dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n\n    return dp[m][n]\n", "tests": [{"start": 15, "end": 16, "test": "def test_isInterleave():\n    solution = Solution()\n    assert not solution.isInterleave('abc', 'def', 'abcdefg')"}]}
{"task_num": 126, "task_title": "Word Ladder II", "func_name": "findLadders", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Set\n\nclass Solution:\n  def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n    from collections import deque\n    def connected(a: str, b: str) -> bool:\n      k = 0\n      for i in range(len(a)):\n        if a[i] != b[i]:\n          k += 1\n      return k == 1\n\n    if endWord not in wordList:\n      return []\n\n    visited = set([beginWord])\n\n    q = deque([beginWord])\n    nodes = []\n    find = False\n\n    while q and not find:\n      nodes.append(q.copy())\n      n = len(q)\n      for _ in range(n):\n        word = q.popleft()\n        for item in wordList:\n          if item in visited:\n            continue\n          if not connected(word, item):\n            continue\n          if item == endWord:\n            find = True\n            break\n          visited.add(item)\n          q.append(item)\n        if find:\n          break\n\n    if not find:\n      return []\n\n    ans = []\n\n    def backtracking(word, level: int, steps: List[str]):\n      if word == beginWord:\n        ans.append(steps[::-1])\n        return\n      if level < 0:\n        return\n      for item in nodes[level]:\n        if connected(item, word):\n          steps.append(item)\n          backtracking(item, level-1, steps)\n          steps.pop()\n\n    backtracking(endWord, len(nodes)-1, [endWord])\n    return ans\n", "tests": [{"start": 21, "end": 22, "test": "def test_findLadders():\n    solution = Solution()\n    assert solution.findLadders('hit', 'cog', ['hot', 'dot', 'dog', 'lot', 'log']) == []"}, {"start": 48, "end": 49, "test": "def test_findLadders():\n    solution = Solution()\n    assert solution.findLadders('hit', 'cog', ['hot', 'dot', 'dog', 'lot', 'log']) == []"}, {"start": 54, "end": 56, "test": "def test_findLadders():\n    solution = Solution()\n    assert solution.findLadders('hit', 'cog', ['hot', 'dot', 'dog', 'lot', 'log', 'cog']) == [['hit', 'hot', 'dot', 'dog', 'cog'], ['hit', 'hot', 'lot', 'log', 'cog']]"}, {"start": 57, "end": 58, "test": "def test_findLadders():\n    solution = Solution()\n    assert solution.findLadders('hit', 'cog', ['hot', 'dot', 'dog', 'lot', 'log']) == []"}, {"start": 17, "end": 18, "test": "def test_findLadders():\n    solution = Solution()\n    assert solution.findLadders('hit', 'cog', ['hot', 'dot', 'dog', 'lot', 'log', 'cog']) == [['hit', 'hot', 'dot', 'dog', 'cog'], ['hit', 'hot', 'lot', 'log', 'cog']]"}, {"start": 45, "end": 46, "test": "def test_findLadders():\n    solution = Solution()\n    assert solution.findLadders('hit', 'cog', ['hot', 'dot', 'dog', 'lot', 'log', 'cog']) == [['hit', 'hot', 'dot', 'dog', 'cog'], ['hit', 'hot', 'lot', 'log', 'cog']]"}, {"start": 60, "end": 63, "test": "def test_findLadders():\n    solution = Solution()\n    assert solution.findLadders('hit', 'cog', ['hot', 'dot', 'dog', 'lot', 'log', 'cog']) == [['hit', 'hot', 'dot', 'dog', 'cog'], ['hit', 'hot', 'lot', 'log', 'cog']]"}, {"start": 36, "end": 37, "test": "def test_findLadders():\n    solution = Solution()\n    assert solution.findLadders('hit', 'cog', ['hot', 'dot', 'dog', 'lot', 'log', 'cog']) == [['hit', 'hot', 'dot', 'dog', 'cog'], ['hit', 'hot', 'lot', 'log', 'cog']]"}, {"start": 38, "end": 39, "test": "def test_findLadders():\n    solution = Solution()\n    assert solution.findLadders('hit', 'cog', ['hot', 'dot', 'dog', 'lot', 'log']) == [['hit', 'hot', 'dot', 'dog', 'cog'], ['hit', 'hot', 'lot', 'log', 'cog']]"}, {"start": 40, "end": 42, "test": "def test_findLadders():\n    solution = Solution()\n    assert solution.findLadders('hit', 'cog', ['hot', 'dot', 'dog', 'lot', 'log', 'cog']) == [['hit', 'hot', 'dot', 'dog', 'cog'], ['hit', 'hot', 'lot', 'log', 'cog']]"}]}
{"task_num": 130, "task_title": "Surrounded Regions", "func_name": "solve", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def solve(self, board: List[List[str]]) -> None:\n    if not board:\n      return\n\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(board)\n    n = len(board[0])\n    q = collections.deque()\n\n    for i in range(m):\n      for j in range(n):\n        if i * j == 0 or i == m - 1 or j == n - 1:\n          if board[i][j] == 'O':\n            q.append((i, j))\n            board[i][j] = '*'\n\n    while q:\n      i, j = q.popleft()\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if board[x][y] != 'O':\n          continue\n        q.append((x, y))\n        board[x][y] = '*'\n\n    for row in board:\n      for i, c in enumerate(row):\n        if c == '*':\n          row[i] = 'O'\n        else:\n          row[i] = 'X'\n", "tests": [{"start": 13, "end": 14, "test": "def test_solve():\n    solution = Solution()\n    board = []\n    solution.solve(board)"}, {"start": 23, "end": 26, "test": "def test_solve():\n    solution = Solution()\n    board = [['X', 'O', 'X'], ['O', 'X', 'O'], ['X', 'O', 'X']]\n    expected = [['X', 'O', 'X'], ['O', 'X', 'O'], ['X', 'O', 'X']]\n    solution.solve(board)"}, {"start": 33, "end": 34, "test": "def test_solve():\n    solution = Solution()\n    board = [['X', 'O', 'X'], ['O', 'X', 'O'], ['X', 'O', 'X']]\n    expected = [['X', 'O', 'X'], ['O', 'X', 'O'], ['X', 'O', 'X']]\n    solution.solve(board)"}, {"start": 35, "end": 36, "test": "def test_solve():\n    solution = Solution()\n    board = [['X', 'O', 'X'], ['O', 'X', 'O'], ['X', 'O', 'X']]\n    expected = [['X', 'O', 'X'], ['X', 'X', 'X'], ['X', 'X', 'X']]\n    solution.solve(board)"}, {"start": 42, "end": 43, "test": "def test_solve():\n    solution = Solution()\n    board = [['X', 'O', 'X'], ['O', 'X', 'O'], ['X', 'O', 'X']]\n    expected = [['X', 'O', 'X'], ['O', 'X', 'O'], ['X', 'O', 'X']]\n    solution.solve(board)"}, {"start": 44, "end": 45, "test": "def test_solve():\n    solution = Solution()\n    board = [['X', 'O', 'X'], ['O', 'X', 'O'], ['X', 'O', 'X']]\n    expected = [['X', 'O', 'X'], ['O', 'X', 'O'], ['X', 'X', 'X']]\n    solution.solve(board)"}, {"start": 24, "end": 26, "test": "def test_solve():\n    solution = Solution()\n    board = [['X', 'O', 'X'], ['O', 'X', 'O'], ['X', 'O', 'X']]\n    expected = [['X', 'O', 'X'], ['O', 'X', 'O'], ['X', 'O', 'X']]\n    solution.solve(board)"}]}
{"task_num": 132, "task_title": "Palindrome Partitioning II", "func_name": "minCut", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minCut(self, s: str) -> int:\n    n = len(s)\n    isPalindrome=[]\n    for _ in range(n):\n      isPalindrome.append([True] * n)\n    dp = [n] * n\n\n    for l in range(2, n + 1):\n      i = 0\n      for j in range(l - 1, n):\n        isPalindrome[i][j] = s[i] == s[j] and isPalindrome[i + 1][j - 1]\n        i += 1\n\n    for i in range(n):\n      if isPalindrome[0][i]:\n        dp[i] = 0\n        continue\n\n      for j in range(i):\n        if isPalindrome[j + 1][i]:\n          dp[i] = min(dp[i], dp[j] + 1)\n\n    return dp[-1]\n", "tests": [{"start": 26, "end": 28, "test": "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('a') == 0"}, {"start": 31, "end": 32, "test": "def test_minCut():\n    solution = Solution()\n    assert solution.minCut('aab') == 1"}]}
{"task_num": 218, "task_title": "The Skyline Problem", "func_name": "getSkyline", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:\n    n = len(buildings)\n    if n == 0:\n      return []\n    if n == 1:\n      left, right, height = buildings[0]\n      return [[left, height], [right, 0]]\n\n    left = self.getSkyline(buildings[:n // 2])\n    right = self.getSkyline(buildings[n // 2:])\n    return self._merge(left, right)\n\n  def _merge(self, left: List[List[int]], right: List[List[int]]) -> List[List[int]]:\n    ans = []\n    i = 0\n    j = 0\n    leftY = 0\n    rightY = 0\n\n    while i < len(left) and j < len(right):\n      if left[i][0] < right[j][0]:\n        leftY = left[i][1]\n        self._addPoint(ans, left[i][0], max(left[i][1], rightY))\n        i += 1\n      else:\n        rightY = right[j][1]\n        self._addPoint(ans, right[j][0], max(right[j][1], leftY))\n        j += 1\n\n    while i < len(left):\n      self._addPoint(ans, left[i][0], left[i][1])\n      i += 1\n\n    while j < len(right):\n      self._addPoint(ans, right[j][0], right[j][1])\n      j += 1\n\n    return ans\n\n  def _addPoint(self, ans: List[List[int]], x: int, y: int) -> None:\n    if ans and ans[-1][0] == x:\n      ans[-1][1] = y\n      return\n    if ans and ans[-1][1] == y:\n      return\n    ans.append([x, y])\n", "tests": [{"start": 14, "end": 15, "test": "def test_getSkyline():\n    solution = Solution()\n    assert solution.getSkyline([]) == []"}, {"start": 16, "end": 18, "test": "def test_getSkyline():\n    solution = Solution()\n    assert solution.getSkyline([[2, 9, 10]]) == [[2, 10], [9, 0]]"}, {"start": 52, "end": 54, "test": "def test_getSkyline():\n    solution = Solution()\n    assert solution.getSkyline([[0, 2, 3], [2, 5, 3], [5, 10, 3]]) == [[0, 3], [2, 3], [5, 3], [10, 0]]"}, {"start": 55, "end": 56, "test": "def test_getSkyline():\n    solution = Solution()\n    assert solution.getSkyline([[0, 2, 3], [2, 5, 3], [5, 10, 3]]) == [[0, 3], [2, 3], [5, 3], [10, 0]]"}, {"start": 32, "end": 35, "test": "def test_getSkyline():\n    solution = Solution()\n    assert solution.getSkyline([[2, 9, 10], [3, 7, 15], [5, 12, 12], [15, 20, 10], [19, 24, 8]]) == [[2, 10], [3, 15], [7, 12], [12, 0]]"}, {"start": 36, "end": 39, "test": "def test_getSkyline():\n    solution = Solution()\n    assert solution.getSkyline([[0, 2, 3], [2, 5, 3], [5, 10, 3]]) == [[0, 3], [2, 3], [5, 3], [10, 0]]"}]}
{"task_num": 227, "task_title": "Basic Calculator II", "func_name": "calculate", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def calculate(self, s: str) -> int:\n    ans = 0\n    prevNum = 0\n    currNum = 0\n    op = '+'\n\n    for i, c in enumerate(s):\n      if c.isdigit():\n        currNum = currNum * 10 + int(c)\n      if not c.isdigit() and c != ' ' or i == len(s) - 1:\n        if op == '+' or op == '-':\n          ans += prevNum\n          prevNum = currNum if op == '+' else -currNum\n        elif op == '*':\n          prevNum = prevNum * currNum\n        elif op == '/':\n          if prevNum < 0:\n            prevNum = math.ceil(prevNum / currNum)\n          else:\n            prevNum = prevNum // currNum\n        op = c\n        currNum = 0\n\n    return ans + prevNum\n", "tests": [{"start": 19, "end": 20, "test": "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('3+5*2') == 16"}, {"start": 21, "end": 33, "test": "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('14-3/2') == 5"}, {"start": 22, "end": 24, "test": "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('3+5') == 8"}, {"start": 25, "end": 26, "test": "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('3+5*2') == 13"}, {"start": 27, "end": 31, "test": "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('10/2') == 5"}, {"start": 28, "end": 29, "test": "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('-10/3') == -4"}, {"start": 30, "end": 31, "test": "def test_calculate():\n    solution = Solution()\n    assert solution.calculate('10/2') == 5"}]}
{"task_num": 289, "task_title": "Game of Life", "func_name": "gameOfLife", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def gameOfLife(self, board: List[List[int]]) -> None:\n    m = len(board)\n    n = len(board[0])\n\n    for i in range(m):\n      for j in range(n):\n        ones = 0\n        for x in range(max(0, i - 1), min(m, i + 2)):\n          for y in range(max(0, j - 1), min(n, j + 2)):\n            ones += board[x][y] & 1\n\n        if board[i][j] == 1 and (ones == 3 or ones == 4):\n          board[i][j] |= 0b10\n\n        if board[i][j] == 0 and ones == 3:\n          board[i][j] |= 0b10\n\n    for i in range(m):\n      for j in range(n):\n        board[i][j] >>= 1\n", "tests": [{"start": 23, "end": 24, "test": "def test_gameOfLife():\n    solution = Solution()\n    board = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]\n    expected = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n    solution.gameOfLife(board)"}, {"start": 26, "end": 27, "test": "def test_gameOfLife():\n    solution = Solution()\n    board = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n    expected = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n    solution.gameOfLife(board)"}]}
{"task_num": 310, "task_title": "Minimum Height Trees", "func_name": "findMinHeightTrees", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\n    if n == 1 or not edges:\n      return [0]\n\n    ans = []\n    graph = collections.defaultdict(set)\n\n    for u, v in edges:\n      graph[u].add(v)\n      graph[v].add(u)\n\n    for label, children in graph.items():\n      if len(children) == 1:\n        ans.append(label)\n\n    while n > 2:\n      n -= len(ans)\n      nextLeaves = []\n      for leaf in ans:\n        u = next(iter(graph[leaf]))\n        graph[u].remove(leaf)\n        if len(graph[u]) == 1:\n          nextLeaves.append(u)\n      ans = nextLeaves\n\n    return ans\n", "tests": [{"start": 13, "end": 14, "test": "def test_findMinHeightTrees():\n    solution = Solution()\n    assert solution.findMinHeightTrees(1, []) == [0]"}, {"start": 24, "end": 25, "test": "def test_findMinHeightTrees():\n    solution = Solution()\n    assert solution.findMinHeightTrees(4, [[1, 0], [1, 2], [1, 3]]) == [1]"}, {"start": 33, "end": 34, "test": "def test_findMinHeightTrees():\n    solution = Solution()\n    assert solution.findMinHeightTrees(6, [[0, 1], [0, 2], [0, 3], [3, 4], [4, 5]]) == [3]"}]}
{"task_num": 327, "task_title": "Count of Range Sum", "func_name": "countRangeSum", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countRangeSum(self, nums: List[int], lower: int, upper: int) -> int:\n    n = len(nums)\n    self.ans = 0\n    prefix = [0] + list(itertools.accumulate(nums))\n\n    self._mergeSort(prefix, 0, n, lower, upper)\n    return self.ans\n\n  def _mergeSort(self, prefix: List[int], l: int, r: int, lower: int, upper: int) -> None:\n    if l >= r:\n      return\n\n    m = (l + r) // 2\n    self._mergeSort(prefix, l, m, lower, upper)\n    self._mergeSort(prefix, m + 1, r, lower, upper)\n    self._merge(prefix, l, m, r, lower, upper)\n\n  def _merge(self, prefix: List[int], l: int, m: int, r: int, lower: int, upper: int) -> None:\n    lo = m + 1\n    hi = m + 1\n\n    for i in range(l, m + 1):\n      while lo <= r and prefix[lo] - prefix[i] < lower:\n        lo += 1\n      while hi <= r and prefix[hi] - prefix[i] <= upper:\n        hi += 1\n      self.ans += hi - lo\n\n    sorted = [0] * (r - l + 1)\n    k = 0\n    i = l\n    j = m + 1\n\n    while i <= m and j <= r:\n      if prefix[i] < prefix[j]:\n        sorted[k] = prefix[i]\n        k += 1\n        i += 1\n      else:\n        sorted[k] = prefix[j]\n        k += 1\n        j += 1\n\n    while i <= m:\n      sorted[k] = prefix[i]\n      k += 1\n      i += 1\n\n    while j <= r:\n      sorted[k] = prefix[j]\n      k += 1\n      j += 1\n\n    prefix[l:l + len(sorted)] = sorted\n", "tests": [{"start": 21, "end": 22, "test": "def test_countRangeSum():\n    solution = Solution()\n    assert solution.countRangeSum([], 0, 0) == 0"}, {"start": 46, "end": 49, "test": "def test_countRangeSum():\n    solution = Solution()\n    assert solution.countRangeSum([0, -2, 5], -3, 2) == 3"}, {"start": 50, "end": 53, "test": "def test_countRangeSum():\n    solution = Solution()\n    assert solution.countRangeSum([0, -2, 5], -3, 2) == 3"}]}
{"task_num": 335, "task_title": "Self Crossing", "func_name": "isSelfCrossing", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isSelfCrossing(self, x: List[int]) -> bool:\n    if len(x) <= 3:\n      return False\n\n    for i in range(3, len(x)):\n      if x[i - 2] <= x[i] and x[i - 1] <= x[i - 3]:\n        return True\n      if i >= 4 and x[i - 1] == x[i - 3] and x[i - 2] <= x[i] + x[i - 4]:\n        return True\n      if i >= 5 and x[i - 4] <= x[i - 2] and x[i - 2] <= x[i] + x[i - 4] and x[i - 1] <= x[i - 3] and x[i - 3] <= x[i - 1] + x[i - 5]:\n        return True\n\n    return False\n", "tests": [{"start": 13, "end": 14, "test": "def test_isSelfCrossing():\n    solution = Solution()\n    assert not solution.isSelfCrossing([1, 2, 3])"}, {"start": 17, "end": 18, "test": "def test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([1, 2, 3, 4]) == False"}, {"start": 19, "end": 20, "test": "def test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([1, 1, 1, 1]) == False"}, {"start": 21, "end": 22, "test": "def test_isSelfCrossing():\n    solution = Solution()\n    assert solution.isSelfCrossing([1, 2, 3, 4, 5, 6, 7, 8]) == False"}]}
{"task_num": 336, "task_title": "Palindrome Pairs", "func_name": "palindromePairs", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def palindromePairs(self, words: List[str]) -> List[List[int]]:\n    ans = []\n    dict = {word[::-1]: i for i, word in enumerate(words)}\n\n    for i, word in enumerate(words):\n      if \"\" in dict and dict[\"\"] != i and word == word[::-1]:\n        ans.append([i, dict[\"\"]])\n\n      for j in range(1, len(word) + 1):\n        l = word[:j]\n        r = word[j:]\n        if l in dict and dict[l] != i and r == r[::-1]:\n          ans.append([i, dict[l]])\n        if r in dict and dict[r] != i and l == l[::-1]:\n          ans.append([dict[r], i])\n\n    return ans\n", "tests": [{"start": 17, "end": 18, "test": "def test_palindromePairs():\n    solution = Solution()\n    assert solution.palindromePairs(['abcd', 'dcba', 'lls', 's', 'sssll']) == [[0, 1], [1, 0], [2, 4], [3, 2]]"}, {"start": 23, "end": 24, "test": "def test_palindromePairs():\n    solution = Solution()\n    assert solution.palindromePairs(['abcd', 'dcba', 'lls', 's', 'sssll']) == [[0, 1], [1, 0], [2, 4], [3, 2]]"}, {"start": 25, "end": 26, "test": "def test_palindromePairs():\n    solution = Solution()\n    assert solution.palindromePairs(['abcd', 'dcba', 'lls', 's', 'sssll']) == [[0, 1], [1, 0], [2, 4], [3, 2]]"}]}
{"task_num": 391, "task_title": "Perfect Rectangle", "func_name": "isRectangleCover", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Set\n\nclass Solution:\n  def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\n    area = 0\n    x1 = math.inf\n    y1 = math.inf\n    x2 = -math.inf\n    y2 = -math.inf\n    corners: Set[Tuple[int, int]] = set()\n\n    for x, y, a, b in rectangles:\n      area += (a - x) * (b - y)\n      x1 = min(x1, x)\n      y1 = min(y1, y)\n      x2 = max(x2, a)\n      y2 = max(y2, b)\n\n      for point in [(x, y), (x, b), (a, y), (a, b)]:\n        if point in corners:\n          corners.remove(point)\n        else:\n          corners.add(point)\n\n    if len(corners) != 4:\n      return False\n    if (x1, y1) not in corners or (x1, y2) not in corners or (x2, y1) not in corners or (x2, y2) not in corners:\n      return False\n    return area == (x2 - x1) * (y2 - y1)\n", "tests": [{"start": 33, "end": 34, "test": "def test_isRectangleCover():\n    solution = Solution()\n    assert not solution.isRectangleCover([[0, 0, 1, 1], [0, 0, 2, 1], [1, 0, 2, 2]])"}, {"start": 35, "end": 36, "test": "def test_isRectangleCover():\n    solution = Solution()\n    assert not solution.isRectangleCover([[0, 0, 1, 1], [0, 0, 2, 1], [1, 0, 2, 2]])"}, {"start": 28, "end": 29, "test": "def test_isRectangleCover():\n    solution = Solution()\n    assert solution.isRectangleCover([[0, 0, 1, 1], [1, 0, 2, 1]]) == True"}, {"start": 30, "end": 31, "test": "def test_isRectangleCover():\n    solution = Solution()\n    assert solution.isRectangleCover([[0, 0, 4, 1], [0, 1, 4, 2], [0, 2, 4, 3], [0, 3, 4, 4], [2, 0, 3, 4]]) == True"}]}
{"task_num": 402, "task_title": "Remove K Digits", "func_name": "removeKdigits", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def removeKdigits(self, num: str, k: int) -> str:\n    if len(num) == k:\n      return '0'\n\n    ans = []\n    stack = []\n\n    for i, digit in enumerate(num):\n      while k > 0 and stack and stack[-1] > digit:\n        stack.pop()\n        k -= 1\n      stack.append(digit)\n\n    for _ in range(k):\n      stack.pop()\n\n    for c in stack:\n      if c == '0' and not ans:\n        continue\n      ans.append(c)\n\n    return ''.join(ans) if ans else '0'\n", "tests": [{"start": 13, "end": 14, "test": "def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits('123456789', 9) == '0'"}, {"start": 29, "end": 30, "test": "def test_removeKdigits():\n    solution = Solution()\n    assert solution.removeKdigits('100', 1) == '0'"}]}
{"task_num": 407, "task_title": "Trapping Rain Water II", "func_name": "trapRainWater", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def trapRainWater(self, heightMap: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(heightMap)\n    n = len(heightMap[0])\n    ans = 0\n    minHeap = []\n    seen = set()\n\n    for i in range(m):\n      heapq.heappush(minHeap, (heightMap[i][0], i, 0))\n      heapq.heappush(minHeap, (heightMap[i][n - 1], i, n - 1))\n      seen.add((i, 0))\n      seen.add((i, n - 1))\n\n    for j in range(1, n - 1):\n      heapq.heappush(minHeap, (heightMap[0][j], 0, j))\n      heapq.heappush(minHeap, (heightMap[m - 1][j], m - 1, j))\n      seen.add((0, j))\n      seen.add((m - 1, j))\n\n    while minHeap:\n      h, i, j = heapq.heappop(minHeap)\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if (x, y) in seen:\n          continue\n        if heightMap[x][y] < h:\n          ans += h - heightMap[x][y]\n          heapq.heappush(minHeap, (h, x, y))\n        else:\n          heapq.heappush(minHeap, (heightMap[x][y], x, y))\n        seen.add((x, y))\n\n    return ans\n", "tests": [{"start": 37, "end": 38, "test": "def test_trapRainWater():\n    solution = Solution()\n    heightMap = [[1, 4, 3, 1], [3, 2, 1, 4], [2, 2, 7, 5]]"}, {"start": 39, "end": 40, "test": "def test_trapRainWater():\n    solution = Solution()\n    heightMap = [[1, 4, 3], [4, 2, 1]]\n    assert solution.trapRainWater(heightMap) == 1"}, {"start": 41, "end": 43, "test": "def test_trapRainWater():\n    solution = Solution()\n    assert solution.trapRainWater([[1, 4, 3, 1, 3, 2], [3, 2, 1, 3, 2, 4], [2, 3, 3, 2, 3, 1]]) == 4"}, {"start": 44, "end": 45, "test": "def test_trapRainWater():\n    solution = Solution()\n    heightMap = [[12, 13, 1, 12], [13, 4, 13, 12], [13, 8, 10, 12], [12, 13, 12, 13], [13, 13, 13, 13]]"}]}
{"task_num": 417, "task_title": "Pacific Atlantic Water Flow", "func_name": "pacificAtlantic", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(heights)\n    n = len(heights[0])\n    qP = collections.deque()\n    qA = collections.deque()\n    seenP = [[False] * n for _ in range(m)]\n    seenA = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n      qP.append((i, 0))\n      qA.append((i, n - 1))\n      seenP[i][0] = True\n      seenA[i][n - 1] = True\n\n    for j in range(n):\n      qP.append((0, j))\n      qA.append((m - 1, j))\n      seenP[0][j] = True\n      seenA[m - 1][j] = True\n\n    def bfs(q: collections.deque, seen: List[List[bool]]):\n      while q:\n        i, j = q.popleft()\n        h = heights[i][j]\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if seen[x][y] or heights[x][y] < h:\n            continue\n          q.append((x, y))\n          seen[x][y] = True\n\n    bfs(qP, seenP)\n    bfs(qA, seenA)\n\n    res=[]\n    for i in range(m):\n      for j in range(n):\n        if seenP[i][j] and seenA[i][j]:\n          res.append([i, j])\n    return res\n", "tests": [{"start": 53, "end": 54, "test": "def test_pacificAtlantic():\n    solution = Solution()\n    heights = [[1, 2, 3], [8, 9, 4], [7, 6, 5]]\n    expected = [[0, 0], [0, 1], [0, 2], [1, 2], [2, 2]]\n    assert solution.pacificAtlantic(heights) == expected"}, {"start": 40, "end": 41, "test": "def test_pacificAtlantic():\n    solution = Solution()\n    heights = [[1, 2, 3], [8, 9, 4], [7, 6, 5]]\n    expected = [[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]]\n    assert sorted(solution.pacificAtlantic(heights)) == sorted(expected)"}, {"start": 42, "end": 43, "test": "def test_pacificAtlantic():\n    solution = Solution()\n    heights = [[1, 2, 2, 3, 5], [3, 2, 3, 4, 4], [2, 4, 5, 3, 1], [6, 7, 1, 4, 5], [5, 1, 1, 2, 4]]\n    expected = [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]]\n    assert sorted(solution.pacificAtlantic(heights)) == sorted(expected)"}]}
{"task_num": 420, "task_title": "Strong Password Checker", "func_name": "strongPasswordChecker", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def strongPasswordChecker(self, password: str) -> int:\n    n = len(password)\n    missing = self._getMissing(password)\n    replaces = 0\n    oneSeq = 0\n    twoSeq = 0\n\n    i = 2\n    while i < n:\n      if password[i] == password[i - 1] and password[i - 1] == password[i - 2]:\n        length = 2\n        while i < n and password[i] == password[i - 1]:\n          length += 1\n          i += 1\n        replaces += length // 3\n        if length % 3 == 0:\n          oneSeq += 1\n        if length % 3 == 1:\n          twoSeq += 1\n      else:\n        i += 1\n\n    if n < 6:\n      return max(6 - n, missing)\n    if n <= 20:\n      return max(replaces, missing)\n\n    deletes = n - 20\n    replaces -= min(oneSeq, deletes)\n    replaces -= min(max(deletes - oneSeq, 0), twoSeq * 2) // 2\n    replaces -= max(deletes - oneSeq - twoSeq * 2, 0) // 3\n    return deletes + max(replaces, missing)\n\n  def _getMissing(self, password: str) -> int:\n    return 3 - any(c.isupper() for c in password) - any(c.islower() for c in password) - any(c.isdigit() for c in password)\n", "tests": [{"start": 34, "end": 35, "test": "def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('a') == 5"}, {"start": 36, "end": 37, "test": "def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('Aa1') == 2"}, {"start": 21, "end": 30, "test": "def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('aaa123') == 3"}, {"start": 31, "end": 32, "test": "def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('aaaAAA') == 4"}, {"start": 27, "end": 28, "test": "def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('aaaaaaa') == 3"}, {"start": 29, "end": 30, "test": "def test_strongPasswordChecker():\n    solution = Solution()\n    assert solution.strongPasswordChecker('aaa123') == 1"}]}
{"task_num": 423, "task_title": "Reconstruct Original Digits from English", "func_name": "originalDigits", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def originalDigits(self, s: str) -> str:\n    count = [0] * 10\n\n    for c in s:\n      if c == 'z':\n        count[0] += 1\n      if c == 'o':\n        count[1] += 1\n      if c == 'w':\n        count[2] += 1\n      if c == 'h':\n        count[3] += 1\n      if c == 'u':\n        count[4] += 1\n      if c == 'f':\n        count[5] += 1\n      if c == 'x':\n        count[6] += 1\n      if c == 's':\n        count[7] += 1\n      if c == 'g':\n        count[8] += 1\n      if c == 'i':\n        count[9] += 1\n\n    count[1] -= count[0] + count[2] + count[4]\n    count[3] -= count[8]\n    count[5] -= count[4]\n    count[7] -= count[6]\n    count[9] -= count[5] + count[6] + count[8]\n\n    return ''.join(chr(i + ord('0')) for i, c in enumerate(count) for j in range(c))\n", "tests": [{"start": 16, "end": 17, "test": "def test_originalDigits():\n    solution = Solution()\n    result = solution.originalDigits('zeroonetwothreefourfivesixseveneightnine')"}, {"start": 18, "end": 19, "test": "def test_originalDigits():\n    solution = Solution()\n    result = solution.originalDigits('one')"}, {"start": 20, "end": 21, "test": "def test_originalDigits():\n    solution = Solution()\n    result = solution.originalDigits('two')"}, {"start": 22, "end": 23, "test": "def test_originalDigits():\n    solution = Solution()\n    result = solution.originalDigits('three')"}, {"start": 24, "end": 25, "test": "def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits('four') == '4'"}, {"start": 26, "end": 27, "test": "def test_originalDigits():\n    solution = Solution()\n    result = solution.originalDigits('five')"}, {"start": 28, "end": 29, "test": "def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits('six') == '6'"}, {"start": 30, "end": 31, "test": "def test_originalDigits():\n    solution = Solution()\n    assert solution.originalDigits('seven') == '7'"}, {"start": 32, "end": 33, "test": "def test_originalDigits():\n    solution = Solution()\n    result = solution.originalDigits('eight')"}, {"start": 34, "end": 35, "test": "def test_originalDigits():\n    solution = Solution()\n    result = solution.originalDigits('onefouronetwothree')"}]}
{"task_num": 457, "task_title": "Circular Array Loop", "func_name": "circularArrayLoop", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def circularArrayLoop(self, nums: List[int]) -> bool:\n    def advance(i: int) -> int:\n      return (i + nums[i]) % len(nums)\n\n    if len(nums) < 2:\n      return False\n\n    for i, num in enumerate(nums):\n      if num == 0:\n        continue\n\n      slow = i\n      fast = advance(slow)\n      while num * nums[fast] > 0 and num * nums[advance(fast)] > 0:\n        if slow == fast:\n          if slow == advance(slow):\n            break\n          return True\n        slow = advance(slow)\n        fast = advance(advance(fast))\n\n      slow = i\n      sign = num\n      while sign * nums[slow] > 0:\n        next = advance(slow)\n        nums[slow] = 0\n        slow = next\n\n    return False\n", "tests": [{"start": 16, "end": 17, "test": "def test_circularArrayLoop():\n    solution = Solution()\n    assert not solution.circularArrayLoop([0])"}, {"start": 20, "end": 21, "test": "def test_circularArrayLoop():\n    solution = Solution()\n    assert not solution.circularArrayLoop([0, 1])"}, {"start": 26, "end": 29, "test": "def test_circularArrayLoop():\n    solution = Solution()\n    assert solution.circularArrayLoop([1, -1]) == False"}, {"start": 27, "end": 28, "test": "def test_circularArrayLoop():\n    solution = Solution()\n    assert not solution.circularArrayLoop([1, -1])"}]}
{"task_num": 524, "task_title": "Longest Word in Dictionary through Deleting", "func_name": "findLongestWord", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findLongestWord(self, s: str, d: List[str]) -> str:\n    ans = ''\n\n    for word in d:\n      i = 0\n      for c in s:\n        if i < len(word) and c == word[i]:\n          i += 1\n      if i == len(word):\n        if len(word) > len(ans) or len(word) == len(ans) and word < ans:\n          ans = word\n\n    return ans\n", "tests": [{"start": 20, "end": 22, "test": "def test_findLongestWord():\n    solution = Solution()\n    assert solution.findLongestWord('abpcplea', ['ale', 'apple', 'monkey', 'plea']) == 'apple'"}, {"start": 18, "end": 19, "test": "def test_findLongestWord():\n    solution = Solution()\n    assert solution.findLongestWord('abpcplea', ['ale', 'apple', 'monkey', 'plea']) == 'apple'"}, {"start": 21, "end": 22, "test": "def test_findLongestWord():\n    solution = Solution()\n    assert solution.findLongestWord('abpcplea', ['ale', 'apple', 'monkey', 'plea']) == 'apple'"}]}
{"task_num": 542, "task_title": "01 Matrix", "func_name": "updateMatrix", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(mat)\n    n = len(mat[0])\n    q = collections.deque()\n    seen = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j] == 0:\n          q.append((i, j))\n          seen[i][j] = True\n\n    while q:\n      i, j = q.popleft()\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if seen[x][y]:\n          continue\n        mat[x][y] = mat[i][j] + 1\n        q.append((x, y))\n        seen[x][y] = True\n\n    return mat\n", "tests": [{"start": 21, "end": 23, "test": "def test_updateMatrix():\n    solution = Solution()\n    mat = [[0, 0, 0], [0, 1, 0], [1, 1, 1]]\n    expected_output = [[0, 0, 0], [0, 1, 0], [1, 2, 1]]\n    assert solution.updateMatrix(mat) == expected_output"}, {"start": 30, "end": 31, "test": "def test_updateMatrix():\n    solution = Solution()\n    mat = [[0, 0, 0], [0, 1, 0], [1, 1, 1]]\n    expected_output = [[0, 0, 0], [0, 1, 0], [1, 2, 1]]\n    assert solution.updateMatrix(mat) == expected_output"}, {"start": 32, "end": 33, "test": "def test_updateMatrix():\n    solution = Solution()\n    mat = [[0, 0, 0], [0, 1, 0], [1, 1, 1]]\n    expected_output = [[0, 0, 0], [0, 1, 0], [1, 2, 1]]\n    assert solution.updateMatrix(mat) == expected_output"}]}
{"task_num": 547, "task_title": "Number of Provinces", "func_name": "findCircleNum", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    self.count -= 1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findCircleNum(self, isConnected: List[List[int]]) -> int:\n    n = len(isConnected)\n    uf = UnionFind(n)\n\n    for i in range(n):\n      for j in range(i, n):\n        if isConnected[i][j] == 1:\n          uf.unionByRank(i, j)\n\n    return uf.count\n", "tests": [{"start": 20, "end": 21, "test": "def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]\n    assert solution.findCircleNum(isConnected) == 2"}, {"start": 22, "end": 23, "test": "def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]\n    assert solution.findCircleNum(isConnected) == 2"}, {"start": 32, "end": 33, "test": "def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    assert solution.findCircleNum(isConnected) == 3"}, {"start": 24, "end": 25, "test": "def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    assert solution.findCircleNum(isConnected) == 3"}, {"start": 26, "end": 28, "test": "def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    assert solution.findCircleNum(isConnected) == 3"}, {"start": 44, "end": 45, "test": "def test_findCircleNum():\n    solution = Solution()\n    isConnected = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    assert solution.findCircleNum(isConnected) == 3"}]}
{"task_num": 581, "task_title": "Shortest Unsorted Continuous Subarray", "func_name": "findUnsortedSubarray", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findUnsortedSubarray(self, nums: List[int]) -> int:\n    mini = math.inf\n    maxi = -math.inf\n    flag = False\n\n    for i in range(1, len(nums)):\n      if nums[i] < nums[i - 1]:\n        flag = True\n      if flag:\n        mini = min(mini, nums[i])\n\n    flag = False\n\n    for i in reversed(range(len(nums) - 1)):\n      if nums[i] > nums[i + 1]:\n        flag = True\n      if flag:\n        maxi = max(maxi, nums[i])\n\n    for l in range(len(nums)):\n      if nums[l] > mini:\n        break\n\n    for r, num in reversed(list(enumerate(nums))):\n      if num < maxi:\n        break\n\n    return 0 if l >= r else r - l + 1\n", "tests": [{"start": 18, "end": 19, "test": "def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([2, 6, 4, 8, 10, 9, 15]) == 5"}, {"start": 20, "end": 21, "test": "def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([2, 6, 4, 8, 10, 9, 15]) == 5"}, {"start": 26, "end": 27, "test": "def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([2, 6, 4, 8, 10, 9, 15]) == 5"}, {"start": 28, "end": 29, "test": "def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([1, 3, 5, 2, 4, 6]) == 3"}, {"start": 32, "end": 33, "test": "def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([2, 6, 4, 8, 10, 9, 15]) == 5"}, {"start": 36, "end": 37, "test": "def test_findUnsortedSubarray():\n    solution = Solution()\n    assert solution.findUnsortedSubarray([1, 2, 4, 3, 5]) == 3"}]}
{"task_num": 591, "task_title": "Tag Validator", "func_name": "isValid", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isValid(self, code: str) -> bool:\n    if code[0] != '<' or code[-1] != '>':\n      return False\n\n    containsTag = False\n    stack = []\n\n    def isValidCdata(s: str) -> bool:\n      return s.find('[CDATA[') == 0\n\n    def isValidTagName(tagName: str, isEndTag: bool) -> bool:\n      nonlocal containsTag\n      if not tagName or len(tagName) > 9:\n        return False\n      if any(not c.isupper() for c in tagName):\n        return False\n\n      if isEndTag:\n        return stack and stack.pop() == tagName\n\n      containsTag = True\n      stack.append(tagName)\n      return True\n\n    i = 0\n    while i < len(code):\n      if not stack and containsTag:\n        return False\n      if code[i] == '<':\n        if stack and code[i + 1] == '!':\n          closeIndex = code.find(']]>', i + 2)\n          if closeIndex == -1 or not isValidCdata(code[i + 2:closeIndex]):\n            return False\n        elif code[i + 1] == '/':\n          closeIndex = code.find('>', i + 2)\n          if closeIndex == -1 or not isValidTagName(code[i + 2:closeIndex], True):\n            return False\n        else:\n          closeIndex = code.find('>', i + 1)\n          if closeIndex == -1 or not isValidTagName(code[i + 1:closeIndex], False):\n            return False\n        i = closeIndex\n      i += 1\n\n    return not stack and containsTag\n", "tests": [{"start": 13, "end": 14, "test": "def test_isValid():\n    solution = Solution()\n    assert not solution.isValid('a<>')"}, {"start": 24, "end": 25, "test": "def test_isValid():\n    solution = Solution()\n    assert not solution.isValid('<A></B>')"}, {"start": 26, "end": 27, "test": "def test_isValid():\n    solution = Solution()\n    assert not solution.isValid('<A></a>')"}, {"start": 29, "end": 30, "test": "def test_isValid():\n    solution = Solution()\n    assert not solution.isValid('<A></A><B></B>')"}, {"start": 38, "end": 39, "test": "def test_isValid():\n    solution = Solution()\n    assert not solution.isValid('a<>')"}, {"start": 40, "end": 53, "test": "def test_isValid():\n    solution = Solution()\n    assert not solution.isValid('<!CDATA[123]]><abc></abc>')"}, {"start": 41, "end": 44, "test": "def test_isValid():\n    solution = Solution()\n    assert solution.isValid('<![CDATA[abc]]><TAG></TAG>') == True"}, {"start": 43, "end": 44, "test": "def test_isValid():\n    solution = Solution()\n    assert not solution.isValid('<![CDATA[abc]]>'), 'Test case for CDATA content without matching end tag failed'"}, {"start": 45, "end": 48, "test": "def test_isValid():\n    solution = Solution()\n    assert solution.isValid('<A></A>') == True"}, {"start": 49, "end": 52, "test": "def test_isValid():\n    solution = Solution()\n    assert solution.isValid('<A></A>') == True"}, {"start": 47, "end": 48, "test": "def test_isValid():\n    solution = Solution()\n    assert not solution.isValid('<A></A><B></C>')"}, {"start": 51, "end": 52, "test": "def test_isValid():\n    solution = Solution()\n    assert not solution.isValid('<A><B></C></A>')"}]}
{"task_num": 648, "task_title": "Replace Words", "func_name": "replaceWords", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def __init__(self):\n    self.root = {}\n\n  def insert(self, word: str) -> None:\n    node = self.root\n    for c in word:\n      if c not in node:\n        node[c] = {}\n      node = node[c]\n    node['word'] = word\n\n  def search(self, word: str) -> str:\n    node = self.root\n    for c in word:\n      if 'word' in node:\n        return node['word']\n      if c not in node:\n        return word\n      node = node[c]\n    return word\n\n  def replaceWords(self, dictionary: List[str], sentence: str) -> str:\n    for word in dictionary:\n      self.insert(word)\n\n    words = sentence.split(' ')\n    return ' '.join([self.search(word) for word in words])\n", "tests": [{"start": 18, "end": 19, "test": "def test_replaceWords():\n    solution = Solution()\n    dictionary = ['cat', 'bat']\n    sentence = 'the cattle was rattled by the battery'\n    expected_output = 'the cat was rattled by the bat'\n    assert solution.replaceWords(dictionary, sentence) == expected_output"}, {"start": 26, "end": 27, "test": "def test_replaceWords():\n    solution = Solution()\n    dictionary = ['cat', 'bat']\n    sentence = 'the cattle was chased by the bear'\n    expected_output = 'the cat was chased by the bear'\n    assert solution.replaceWords(dictionary, sentence) == expected_output"}, {"start": 28, "end": 29, "test": "def test_replaceWords():\n    solution = Solution()\n    dictionary = ['cat', 'bat']\n    sentence = 'the cattle was rattled by the battery'\n    expected_output = 'the cat was rattled by the bat'\n    assert solution.replaceWords(dictionary, sentence) == expected_output"}]}
{"task_num": 673, "task_title": "Number of Longest Increasing Subsequence", "func_name": "findNumberOfLIS", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findNumberOfLIS(self, nums: List[int]) -> int:\n    ans = 0\n    maxLength = 0\n    length = [1] * len(nums)\n    count = [1] * len(nums)\n\n    for i, num in enumerate(nums):\n      for j in range(i):\n        if nums[j] < num:\n          if length[i] < length[j] + 1:\n            length[i] = length[j] + 1\n            count[i] = count[j]\n          elif length[i] == length[j] + 1:\n            count[i] += count[j]\n\n    for i, l in enumerate(length):\n      if l > maxLength:\n        maxLength = l\n        ans = count[i]\n      elif l == maxLength:\n        ans += count[i]\n\n    return ans\n", "tests": [{"start": 28, "end": 30, "test": "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([1, 2, 4, 3, 5]) == 3"}, {"start": 20, "end": 25, "test": "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([1, 3, 5, 4, 7]) == 2"}, {"start": 31, "end": 32, "test": "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([1, 2, 4, 3, 5, 7, 2, 1]) == 2"}, {"start": 21, "end": 23, "test": "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([1, 2, 4, 3, 5]) == 3"}, {"start": 24, "end": 25, "test": "def test_findNumberOfLIS():\n    solution = Solution()\n    assert solution.findNumberOfLIS([1, 3, 5, 4, 7]) == 2"}]}
{"task_num": 684, "task_title": "Redundant Connection", "func_name": "findRedundantConnection", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n    uf = UnionFind(len(edges) + 1)\n\n    for edge in edges:\n      u, v = edge\n      if not uf.unionByRank(u, v):\n        return edge\n", "tests": [{"start": 19, "end": 20, "test": "def test_findRedundantConnection():\n    solution = Solution()\n    assert solution.findRedundantConnection([[1, 2], [1, 3], [2, 3]]) == [2, 3]"}, {"start": 21, "end": 22, "test": "def test_findRedundantConnection():\n    solution = Solution()\n    assert solution.findRedundantConnection([[1, 2], [1, 3], [2, 3]]) == [2, 3]"}, {"start": 31, "end": 32, "test": "def test_findRedundantConnection():\n    solution = Solution()\n    assert solution.findRedundantConnection([[1, 2], [1, 3], [2, 3]]) == [2, 3]"}, {"start": 23, "end": 24, "test": "def test_findRedundantConnection():\n    solution = Solution()\n    assert solution.findRedundantConnection([[1, 2], [1, 3], [2, 3]]) == [2, 3]"}, {"start": 25, "end": 27, "test": "def test_findRedundantConnection():\n    solution = Solution()\n    assert solution.findRedundantConnection([[1, 2], [1, 3], [2, 3]]) == [2, 3]"}, {"start": 42, "end": 43, "test": "def test_findRedundantConnection():\n    solution = Solution()\n    assert solution.findRedundantConnection([[1, 2], [1, 3], [2, 3]]) == [2, 3]"}]}
{"task_num": 685, "task_title": "Redundant Connection II", "func_name": "findRedundantDirectedConnection", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\n    ids = [0] * (len(edges) + 1)\n    nodeWithTwoParents = 0\n\n    for _, v in edges:\n      ids[v] += 1\n      if ids[v] == 2:\n        nodeWithTwoParents = v\n\n    def findRedundantDirectedConnection(skippedEdgeIndex: int) -> List[int]:\n      uf = UnionFind(len(edges) + 1)\n\n      for i, edge in enumerate(edges):\n        if i == skippedEdgeIndex:\n          continue\n        if not uf.unionByRank(edge[0], edge[1]):\n          return edge\n\n      return []\n\n    if nodeWithTwoParents == 0:\n      return findRedundantDirectedConnection(-1)\n\n    for i in reversed(range(len(edges))):\n      _, v = edges[i]\n      if v == nodeWithTwoParents:\n        if not findRedundantDirectedConnection(i):\n          return edges[i]\n", "tests": [{"start": 19, "end": 20, "test": "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    assert solution.findRedundantDirectedConnection([[1, 2], [1, 3], [2, 3]]) == [2, 3]"}, {"start": 21, "end": 22, "test": "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    assert solution.findRedundantDirectedConnection([[1, 2], [1, 3], [2, 3]]) == [2, 3]"}, {"start": 31, "end": 32, "test": "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    assert solution.findRedundantDirectedConnection([[1, 2], [1, 3], [2, 3]]) == [2, 3]"}, {"start": 57, "end": 58, "test": "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    assert solution.findRedundantDirectedConnection([[1, 2], [1, 3], [2, 3]]) == [2, 3]"}, {"start": 23, "end": 24, "test": "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    assert solution.findRedundantDirectedConnection([[1, 2], [1, 3], [2, 3]]) == [2, 3]"}, {"start": 25, "end": 27, "test": "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    edges = [[1, 2], [1, 3], [2, 3]]\n    assert solution.findRedundantDirectedConnection(edges) == [2, 3]"}, {"start": 43, "end": 44, "test": "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    assert solution.findRedundantDirectedConnection([[1, 2], [1, 3], [2, 3]]) == [2, 3]"}, {"start": 62, "end": 64, "test": "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    assert solution.findRedundantDirectedConnection([[1, 2], [1, 3], [2, 3]]) == [2, 3]"}, {"start": 50, "end": 51, "test": "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    assert solution.findRedundantDirectedConnection([[1, 2], [1, 3], [2, 3]]) == [2, 3]"}, {"start": 52, "end": 53, "test": "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    assert solution.findRedundantDirectedConnection([[1, 2], [1, 3], [2, 3]]) == [2, 3]"}, {"start": 63, "end": 64, "test": "def test_findRedundantDirectedConnection():\n    solution = Solution()\n    assert solution.findRedundantDirectedConnection([[1, 2], [1, 3], [2, 3]]) == [2, 3]"}]}
{"task_num": 688, "task_title": "Knight Probability in Chessboard", "func_name": "knightProbability", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\n    dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n    dp = [[0] * n for _ in range(n)]\n    dp[row][column] = 1.0\n\n    for _ in range(k):\n      newDp = [[0] * n for _ in range(n)]\n      for i in range(n):\n        for j in range(n):\n          for dx, dy in dirs:\n            x = i + dx\n            y = j + dy\n            if 0 <= x < n and 0 <= y < n:\n              newDp[i][j] += dp[x][y]\n      dp = newDp\n\n    return sum(map(sum, dp)) / 8**k\n", "tests": [{"start": 24, "end": 25, "test": "def test_knightProbability():\n    solution = Solution()\n    assert abs(solution.knightProbability(3, 2, 0, 0) - 0.1875) < 1e-06"}]}
{"task_num": 689, "task_title": "Maximum Sum of 3 Non-Overlapping Subarrays", "func_name": "maxSumOfThreeSubarrays", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:\n    n = len(nums) - k + 1\n    sums = [0] * n\n    l = [0] * n\n    r = [0] * n\n\n    summ = 0\n    for i, num in enumerate(nums):\n      summ += num\n      if i >= k:\n        summ -= nums[i - k]\n      if i >= k - 1:\n        sums[i - k + 1] = summ\n\n    maxIndex = 0\n    for i in range(n):\n      if sums[i] > sums[maxIndex]:\n        maxIndex = i\n      l[i] = maxIndex\n\n    maxIndex = n - 1\n    for i in range(n - 1, -1, -1):\n      if sums[i] >= sums[maxIndex]:\n        maxIndex = i\n      r[i] = maxIndex\n\n    ans = [-1, -1, -1]\n\n    for i in range(k, n - k):\n      if ans[0] == -1 or sums[ans[0]] + sums[ans[1]] + sums[ans[2]] < sums[l[i - k]] + sums[i] + sums[r[i + k]]:\n        ans[0] = l[i - k]\n        ans[1] = i\n        ans[2] = r[i + k]\n\n    return ans\n", "tests": [{"start": 21, "end": 22, "test": "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([1, 2, 3, 4, 5], 1) == [0, 1, 2]"}, {"start": 23, "end": 24, "test": "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([1, 2, 1, 2, 6], 2) == [0, 2, 4]"}, {"start": 28, "end": 29, "test": "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([1, 2, 3, 4, 5], 1) == [0, 1, 2]"}, {"start": 34, "end": 35, "test": "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([1, 2, 3, 4, 5], 1) == [0, 1, 2]"}, {"start": 41, "end": 44, "test": "def test_maxSumOfThreeSubarrays():\n    solution = Solution()\n    assert solution.maxSumOfThreeSubarrays([1, 2, 3, 4, 5], 1) == [0, 1, 2]"}]}
{"task_num": 691, "task_title": "Stickers to Spell Word", "func_name": "minStickers", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minStickers(self, stickers: List[str], target: str) -> int:\n    maxMask = 1 << len(target)\n    dp = [math.inf] * maxMask\n    dp[0] = 0\n\n    for mask in range(maxMask):\n      if dp[mask] == math.inf:\n        continue\n      for sticker in stickers:\n        superMask = mask\n        for c in sticker:\n          for i, t in enumerate(target):\n            if c == t and not (superMask >> i & 1):\n              superMask |= 1 << i\n              break\n        dp[superMask] = min(dp[superMask], dp[mask] + 1)\n\n    return -1 if dp[-1] == math.inf else dp[-1]\n", "tests": [{"start": 18, "end": 19, "test": "def test_minStickers():\n    solution = Solution()\n    stickers = ['with', 'example']\n    target = 'ex'\n    assert solution.minStickers(stickers, target) == 1"}, {"start": 24, "end": 26, "test": "def test_minStickers():\n    solution = Solution()\n    assert solution.minStickers(['with', 'example'], 'ex') == 1"}]}
{"task_num": 722, "task_title": "Remove Comments", "func_name": "removeComments", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def removeComments(self, source: List[str]) -> List[str]:\n    ans = []\n    commenting = False\n    modified = ''\n\n    for line in source:\n      i = 0\n      while i < len(line):\n        if i + 1 == len(line):\n          if not commenting:\n            modified += line[i]\n          i += 1\n          break\n        twoChars = line[i:i + 2]\n        if twoChars == '/*' and not commenting:\n          commenting = True\n          i += 2\n        elif twoChars == '*/' and commenting:\n          commenting = False\n          i += 2\n        elif twoChars == '//':\n          if not commenting:\n            break\n          else:\n            i += 2\n        else:\n          if not commenting:\n            modified += line[i]\n          i += 1\n      if modified and not commenting:\n        ans.append(modified)\n        modified = ''\n\n    return ans\n", "tests": [{"start": 41, "end": 43, "test": "def test_removeComments():\n    solution = Solution()\n    source = ['int main() {', '  // This is a line comment.', '  int x = 5;', '  /* This is a block comment */', '  int y = 10;', '}']\n    expected_output = ['int main() {', '  int x = 5;', '  int y = 10;', '}']\n    assert solution.removeComments(source) == expected_output"}, {"start": 20, "end": 24, "test": "def test_removeComments():\n    solution = Solution()\n    source = ['a/*comment', 'line']\n    expected = ['a']\n    assert solution.removeComments(source) == expected"}, {"start": 26, "end": 28, "test": "def test_removeComments():\n    solution = Solution()\n    source = ['a/*comment', 'line', 'more comments*/b']\n    expected = ['ab']\n    assert solution.removeComments(source) == expected"}, {"start": 21, "end": 22, "test": "def test_removeComments():\n    solution = Solution()\n    source = ['a/*comment', 'line', 'more comments*/b']\n    expected = ['ab']\n    assert solution.removeComments(source) == expected"}, {"start": 29, "end": 31, "test": "def test_removeComments():\n    solution = Solution()\n    source = ['class Solution {', 'public:', '    vector<int> twoSum(vector<int>& nums, int target) {', '        unordered_map<int, int> mp;', '        for (int i = 0; i < nums.size(); ++i) {', '            if (mp.find(target - nums[i]) != mp.end()) {', '                return {mp[target - nums[i]], i};', '            }', '            mp[nums[i]] = i;', '        }', '        return {};', '    }', '};']\n    expected = ['class Solution {', 'public:', '    vector<int> twoSum(vector<int>& nums, int target) {', '        unordered_map<int, int> mp;', '        for (int i = 0; i < nums.size(); ++i) {', '            if (mp.find(target - nums[i]) != mp.end()) {', '                return {mp[target - nums[i]], i};', '            }', '            mp[nums[i]] = i;', '        }', '        return {};', '    }', '};']\n    assert solution.removeComments(source) == expected"}, {"start": 32, "end": 36, "test": "def test_removeComments():\n    solution = Solution()\n    source = ['a/*comment', 'line', '//comment']\n    expected = ['a']\n    assert solution.removeComments(source) == expected"}, {"start": 37, "end": 40, "test": "def test_removeComments():\n    solution = Solution()\n    source = ['a/*comment', 'line', 'more_comment*/b']\n    expected = ['ab']\n    assert solution.removeComments(source) == expected"}, {"start": 33, "end": 34, "test": "def test_removeComments():\n    solution = Solution()\n    source = ['a/*comment', 'line', 'more_comment*/b']\n    expected = ['ab']\n    assert solution.removeComments(source) == expected"}, {"start": 35, "end": 36, "test": "def test_removeComments():\n    solution = Solution()\n    source = ['a/*comment', 'line', 'more_comment*/b']\n    expected = ['ab']\n    assert solution.removeComments(source) == expected"}, {"start": 38, "end": 39, "test": "def test_removeComments():\n    solution = Solution()\n    source = ['a/*comment', 'line', 'more comments*/b']\n    expected = ['ab']\n    assert solution.removeComments(source) == expected"}]}
{"task_num": 730, "task_title": "Count Different Palindromic Subsequences", "func_name": "countPalindromicSubsequences", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countPalindromicSubsequences(self, s: str) -> int:\n    kMod = 1_000_000_007\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n      dp[i][i] = 1\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        if s[i] == s[j]:\n          lo = i + 1\n          hi = j - 1\n          while lo <= hi and s[lo] != s[i]:\n            lo += 1\n          while lo <= hi and s[hi] != s[i]:\n            hi -= 1\n          if lo > hi:\n            dp[i][j] = dp[i + 1][j - 1] * 2 + 2\n          elif lo == hi:\n            dp[i][j] = dp[i + 1][j - 1] * 2 + 1\n          else:\n            dp[i][j] = dp[i + 1][j - 1] * 2 - dp[lo + 1][hi - 1]\n        else:\n          dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1]\n        dp[i][j] = (dp[i][j] + kMod) % kMod\n\n    return dp[0][n - 1]\n", "tests": [{"start": 23, "end": 35, "test": "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('abcba') == 7"}, {"start": 36, "end": 37, "test": "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('abcab') == 7"}, {"start": 30, "end": 31, "test": "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('abcda') == 10"}, {"start": 32, "end": 33, "test": "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('aa') == 3"}, {"start": 34, "end": 35, "test": "def test_countPalindromicSubsequences():\n    solution = Solution()\n    assert solution.countPalindromicSubsequences('abba') == 4"}]}
{"task_num": 735, "task_title": "Asteroid Collision", "func_name": "asteroidCollision", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def asteroidCollision(self, asteroids: List[int]) -> List[int]:\n    stack = []\n\n    for a in asteroids:\n      if a > 0:\n        stack.append(a)\n      else:\n        while stack and stack[-1] > 0 and stack[-1] < -a:\n          stack.pop()\n        if not stack or stack[-1] < 0:\n          stack.append(a)\n        elif stack[-1] == -a:\n          stack.pop()\n        else:\n          pass\n\n    return stack\n", "tests": [{"start": 16, "end": 17, "test": "def test_asteroidCollision():\n    solution = Solution()\n    assert solution.asteroidCollision([5]) == [5]"}, {"start": 18, "end": 26, "test": "def test_asteroidCollision():\n    solution = Solution()\n    assert solution.asteroidCollision([10, 2, -5]) == [10], 'Test case failed'"}, {"start": 21, "end": 22, "test": "def test_asteroidCollision():\n    solution = Solution()\n    assert solution.asteroidCollision([5, 10, -5]) == [5, 10], 'Test case failed'"}, {"start": 23, "end": 24, "test": "def test_asteroidCollision():\n    solution = Solution()\n    assert solution.asteroidCollision([5, 10, -5]) == [5, 10], 'Test case failed'"}, {"start": 25, "end": 26, "test": "def test_asteroidCollision():\n    solution = Solution()\n    assert solution.asteroidCollision([1, 2, -3]) == [1], 'Test case for branch else: pass failed'"}]}
{"task_num": 743, "task_title": "Network Delay Time", "func_name": "networkDelayTime", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in times:\n      graph[u - 1].append((v - 1, w))\n\n    return self._dijkstra(graph, k - 1)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int) -> int:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    maxDist = max(dist)\n    return maxDist if maxDist != math.inf else -1\n", "tests": [{"start": 28, "end": 29, "test": "def test_networkDelayTime():\n    solution = Solution()\n    times = [[1, 2, 1], [2, 3, 2], [1, 3, 4]]\n    n = 3\n    k = 1\n    assert solution.networkDelayTime(times, n, k) == 3"}, {"start": 31, "end": 33, "test": "def test_networkDelayTime():\n    solution = Solution()\n    times = [[1, 2, 1]]\n    n = 2\n    k = 1\n    assert solution.networkDelayTime(times, n, k) == 1"}]}
{"task_num": 770, "task_title": "Basic Calculator IV", "func_name": "basicCalculatorIV", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Poly:\n  def __init__(self, term: str = None, coef: int = None):\n    if term and coef:\n      self.terms = collections.Counter({term: coef})\n    else:\n      self.terms = collections.Counter()\n\n  def __add__(self, other):\n    for term, coef in other.terms.items():\n      self.terms[term] += coef\n    return self\n\n  def __sub__(self, other):\n    for term, coef in other.terms.items():\n      self.terms[term] -= coef\n    return self\n\n  def __mul__(self, other):\n    res = Poly()\n    for a, aCoef in self.terms.items():\n      for b, bCoef in other.terms.items():\n        res.terms[self._merge(a, b)] += aCoef * bCoef\n    return res\n\n  def toList(self) -> List[str]:\n    for term in list(self.terms.keys()):\n      if not self.terms[term]:\n        del self.terms[term]\n\n    def cmp(term: str) -> tuple:\n      if term == '1':\n        return (0,)\n      var = term.split('*')\n      return (-len(var), term)\n\n    def concat(term: str) -> str:\n      if term == '1':\n        return str(self.terms[term])\n      return str(self.terms[term]) + '*' + term\n\n    terms = list(self.terms.keys())\n    terms.sort(key=cmp)\n    return [concat(term) for term in terms]\n\n  def _merge(self, a: str, b: str) -> str:\n    if a == '1':\n      return b\n    if b == '1':\n      return a\n    res = []\n    A = a.split('*')\n    B = b.split('*')\n    i = 0\n    j = 0\n    while i < len(A) and j < len(B):\n      if A[i] < B[j]:\n        res.append(A[i])\n        i += 1\n      else:\n        res.append(B[j])\n        j += 1\n    return '*'.join(res + A[i:] + B[j:])\n\n\nclass Solution:\n  def basicCalculatorIV(self, expression: str, evalvars: List[str], evalints: List[int]) -> List[str]:\n    tokens = list(self._getTokens(expression))\n    evalMap = {a: b for a, b in zip(evalvars, evalints)}\n\n    for i, token in enumerate(tokens):\n      if token in evalMap:\n        tokens[i] = str(evalMap[token])\n\n    postfix = self._infixToPostfix(tokens)\n    return self._evaluate(postfix).toList()\n\n  def _getTokens(self, s: str) -> Iterator[str]:\n    i = 0\n    for j, c in enumerate(s):\n      if c == ' ':\n        if i < j:\n          yield s[i:j]\n        i = j + 1\n      elif c in '()+-*':\n        if i < j:\n          yield s[i:j]\n        yield c\n        i = j + 1\n    if i < len(s):\n      yield s[i:]\n\n  def _infixToPostfix(self, tokens: List[str]) -> List[str]:\n    postfix = []\n    ops = []\n\n    def precedes(prevOp: str, currOp: str) -> bool:\n      if prevOp == '(':\n        return False\n      return prevOp == '*' or currOp in '+-'\n\n    for token in tokens:\n      if token == '(':\n        ops.append(token)\n      elif token == ')':\n        while ops[-1] != '(':\n          postfix.append(ops.pop())\n        ops.pop()\n      elif token in '+-*':\n        while ops and precedes(ops[-1], token):\n          postfix.append(ops.pop())\n        ops.append(token)\n      else:\n        postfix.append(token)\n    return postfix + ops[::-1]\n\n  def _evaluate(self, postfix: List[str]) -> Poly:\n    polys: List[Poly] = []\n    for token in postfix:\n      if token in '+-*':\n        b = polys.pop()\n        a = polys.pop()\n        if token == '+':\n          polys.append(a + b)\n        elif token == '-':\n          polys.append(a - b)\n        else:\n          polys.append(a * b)\n      elif token.lstrip('-').isnumeric():\n        polys.append(Poly(\"1\", int(token)))\n      else:\n        polys.append(Poly(token, 1))\n    return polys[0]\n", "tests": [{"start": 13, "end": 14, "test": "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('e + 8 - a + 5', ['e'], [1]) == ['-1*a', '14']"}, {"start": 15, "end": 16, "test": "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('x', [], []) == ['x']"}, {"start": 56, "end": 57, "test": "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('a*b*c', [], []) == ['a*b*c']"}, {"start": 58, "end": 59, "test": "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('a*b*c', [], []) == ['a*b*c']"}, {"start": 99, "end": 100, "test": "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('a + b', ['a'], [1]) == ['1*b', '1*a']"}, {"start": 37, "end": 38, "test": "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('a - b + c', [], []) == ['-1*a', '1*b', '1*c']"}, {"start": 41, "end": 42, "test": "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('e + 8 - a + 5', ['e'], [1]) == ['-1*a', '14']"}, {"start": 47, "end": 48, "test": "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('e + 8 - a + 5', ['e'], [1]) == ['-1*a', '14']"}, {"start": 66, "end": 68, "test": "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('a*b*c + b*a*c', [], []) == ['2*a*b*c']"}, {"start": 69, "end": 71, "test": "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('a*b*c', [], []) == ['a*b*c']"}, {"start": 81, "end": 82, "test": "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('e + 8 - a + 5', ['e'], [1]) == ['-1*a', '14']"}, {"start": 90, "end": 93, "test": "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('e + 8 - a + 5', ['e'], [1]) == ['-1*a', '14']"}, {"start": 107, "end": 108, "test": "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('(a + b) * (c - d)', [], []) == ['-1*a*c', '1*a*d', '-1*b*c', '1*b*d']"}, {"start": 112, "end": 113, "test": "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('(a + b) * (c - d)', [], []) == ['-1*a*c', '1*a*d', '-1*b*c', '1*b*d']"}, {"start": 129, "end": 137, "test": "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('a + b', ['a'], [1]) == ['1*b', '1*a']"}, {"start": 91, "end": 92, "test": "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('a + b', ['a'], [1]) == ['1*b', '1*a']"}, {"start": 94, "end": 98, "test": "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('a * b', ['a'], [2]) == ['2*b']"}, {"start": 114, "end": 117, "test": "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('(a + b) * (c - d)', [], []) == ['-1*a*c', '-1*a*d', '1*b*c', '1*b*d']"}, {"start": 132, "end": 133, "test": "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('e + 8 - a + 5', ['e'], [1]) == ['-1*a', '14']"}, {"start": 138, "end": 139, "test": "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('2 * 3 + 5', [], []) == ['6*3', '5']"}, {"start": 140, "end": 141, "test": "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('x', [], []) == ['x']"}, {"start": 95, "end": 96, "test": "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('a + b', ['a'], [1]) == ['1*b', '1*a']"}, {"start": 118, "end": 121, "test": "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('a + b * c - d', ['a'], [1]) == ['-1*d', '1*b*c', '1*a']"}, {"start": 122, "end": 123, "test": "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('a', ['a'], [1]) == ['1']"}, {"start": 134, "end": 135, "test": "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('a - b + c', ['a'], [1]) == ['-1*b', '1*c']"}, {"start": 136, "end": 137, "test": "def test_basicCalculatorIV():\n    solution = Solution()\n    assert solution.basicCalculatorIV('a*b*c', [], []) == ['a*b*c']"}]}
{"task_num": 777, "task_title": "Swap Adjacent in LR String", "func_name": "canTransform", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def canTransform(self, start: str, end: str) -> bool:\n    if start.replace('X', '') != end.replace('X', ''):\n      return False\n\n    i = 0\n    j = 0\n\n    while i < len(start) and j < len(end):\n      while i < len(start) and start[i] == 'X':\n        i += 1\n      while j < len(end) and end[j] == 'X':\n        j += 1\n      if i == len(start) and j == len(end):\n        return True\n      if i == len(start) or j == len(end):\n        return False\n      if start[i] == 'L' and i < j:\n        return False\n      if start[i] == 'R' and i > j:\n        return False\n      i += 1\n      j += 1\n\n    return True\n", "tests": [{"start": 13, "end": 14, "test": "def test_canTransform():\n    solution = Solution()\n    assert not solution.canTransform('RXXLRXRXL', 'XRLXXRRLX')"}, {"start": 24, "end": 25, "test": "def test_canTransform():\n    solution = Solution()\n    assert solution.canTransform('XXXX', 'XXXX') == True"}, {"start": 26, "end": 27, "test": "def test_canTransform():\n    solution = Solution()\n    assert not solution.canTransform('RXXLRXRXL', 'XRLXXRRLX')"}, {"start": 28, "end": 29, "test": "def test_canTransform():\n    solution = Solution()\n    assert not solution.canTransform('RXXLRXRXL', 'XRLXXRRLX')"}, {"start": 30, "end": 31, "test": "def test_canTransform():\n    solution = Solution()\n    assert not solution.canTransform('RXXLRXRXL', 'XRLXXRRLX')"}]}
{"task_num": 782, "task_title": "Transform to Chessboard", "func_name": "movesToChessboard", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def movesToChessboard(self, board: List[List[int]]) -> int:\n    n = len(board)\n\n    for i in range(n):\n      for j in range(n):\n        if board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]:\n          return -1\n\n    rowSum = sum(board[0])\n    colSum = sum(board[i][0] for i in range(n))\n\n    if rowSum != n // 2 and rowSum != (n + 1) // 2:\n      return -1\n    if colSum != n // 2 and colSum != (n + 1) // 2:\n      return -1\n\n    rowSwaps = sum(board[i][0] == (i & 1) for i in range(n))\n    colSwaps = sum(board[0][i] == (i & 1) for i in range(n))\n\n    if n & 1:\n      if rowSwaps & 1:\n        rowSwaps = n - rowSwaps\n      if colSwaps & 1:\n        colSwaps = n - colSwaps\n    else:\n      rowSwaps = min(rowSwaps, n - rowSwaps)\n      colSwaps = min(colSwaps, n - colSwaps)\n\n    return (rowSwaps + colSwaps) // 2\n", "tests": [{"start": 23, "end": 24, "test": "def test_movesToChessboard():\n    solution = Solution()\n    assert solution.movesToChessboard([[0, 1], [1, 0]]) == 0"}, {"start": 25, "end": 26, "test": "def test_movesToChessboard():\n    solution = Solution()\n    assert solution.movesToChessboard([[0, 1], [1, 0]]) == 0"}, {"start": 31, "end": 35, "test": "def test_movesToChessboard():\n    solution = Solution()\n    assert solution.movesToChessboard([[0, 1], [1, 0]]) == 0"}, {"start": 36, "end": 38, "test": "def test_movesToChessboard():\n    solution = Solution()\n    assert solution.movesToChessboard([[0, 1], [1, 0]]) == 0"}, {"start": 32, "end": 33, "test": "def test_movesToChessboard():\n    solution = Solution()\n    assert solution.movesToChessboard([[0, 1], [1, 0]]) == 0"}, {"start": 34, "end": 35, "test": "def test_movesToChessboard():\n    solution = Solution()\n    assert solution.movesToChessboard([[0, 1], [1, 0]]) == 0"}, {"start": 17, "end": 18, "test": "def test_movesToChessboard():\n    solution = Solution()\n    assert solution.movesToChessboard([[0, 1], [1, 0]]) == 0"}]}
{"task_num": 786, "task_title": "K-th Smallest Prime Fraction", "func_name": "kthSmallestPrimeFraction", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\n    n = len(arr)\n    ans = [0, 1]\n    l = 0\n    r = 1\n\n    while True:\n      m = (l + r) / 2\n      ans[0] = 0\n      count = 0\n      j = 1\n\n      for i in range(n):\n        while j < n and arr[i] > m * arr[j]:\n          j += 1\n        count += n - j\n        if j == n:\n          break\n        if ans[0] * arr[j] < ans[1] * arr[i]:\n          ans[0] = arr[i]\n          ans[1] = arr[j]\n\n      if count < k:\n        l = m\n      elif count > k:\n        r = m\n      else:\n        return ans\n", "tests": [{"start": 34, "end": 35, "test": "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    assert solution.kthSmallestPrimeFraction([1, 2, 3, 5], 3) == [2, 5]"}, {"start": 28, "end": 29, "test": "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    assert solution.kthSmallestPrimeFraction([1, 3, 5], 2) == [1, 3]"}, {"start": 30, "end": 32, "test": "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    assert solution.kthSmallestPrimeFraction([1, 2, 3, 5], 3) == [2, 5]"}, {"start": 36, "end": 37, "test": "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    assert solution.kthSmallestPrimeFraction([1, 2, 3, 5], 3) == [2, 5]"}, {"start": 38, "end": 39, "test": "def test_kthSmallestPrimeFraction():\n    solution = Solution()\n    assert solution.kthSmallestPrimeFraction([1, 2, 3, 5], 3) == [2, 5]"}]}
{"task_num": 787, "task_title": "Cheapest Flights Within K Stops", "func_name": "findCheapestPrice", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in flights:\n      graph[u].append((v, w))\n\n    return self._dijkstra(graph, src, dst, k)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, k: int) -> int:\n    dist=[]\n    for i in range(len(graph)):\n      dist.append([math.inf for _ in range(k + 2)])\n\n    dist[src][k + 1] = 0\n    minHeap = [(dist[src][k + 1], src, k + 1)]\n\n    while minHeap:\n      d, u, stops = heapq.heappop(minHeap)\n      if u == dst:\n        return d\n      if stops == 0 or d > dist[u][stops]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v][stops - 1]:\n          dist[v][stops - 1] = d + w\n          heapq.heappush(minHeap, (dist[v][stops - 1], v, stops - 1))\n\n    return -1\n", "tests": [{"start": 30, "end": 31, "test": "def test_findCheapestPrice():\n    solution = Solution()\n    assert solution.findCheapestPrice(4, [[0, 1, 100], [1, 2, 100], [2, 3, 100]], 0, 3, 1) == -1"}, {"start": 32, "end": 33, "test": "def test_findCheapestPrice():\n    solution = Solution()\n    n = 4\n    flights = [[0, 1, 100], [1, 2, 100], [2, 3, 100]]\n    src = 0\n    dst = 3\n    k = 0\n    assert solution.findCheapestPrice(n, flights, src, dst, k) == -1"}, {"start": 35, "end": 37, "test": "def test_findCheapestPrice():\n    solution = Solution()\n    assert solution.findCheapestPrice(3, [[0, 1, 100], [1, 2, 100], [0, 2, 500]], 0, 2, 1) == 150"}]}
{"task_num": 794, "task_title": "Valid Tic-Tac-Toe State", "func_name": "validTicTacToe", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def validTicTacToe(self, board: List[str]) -> bool:\n    def isWin(c: str) -> bool:\n      return any(row.count(c) == 3 for row in board) or any(row.count(c) == 3 for row in list(zip(*board))) or all(board[i][i] == c for i in range(3)) or all(board[i][2 - i] == c for i in range(3))\n\n    countX = sum(row.count('X') for row in board)\n    countO = sum(row.count('O') for row in board)\n\n    if countX < countO or countX - countO > 1:\n      return False\n    if isWin('X') and countX == countO or isWin('O') and countX != countO:\n      return False\n\n    return True\n", "tests": [{"start": 19, "end": 20, "test": "def test_validTicTacToe():\n    solution = Solution()\n    assert not solution.validTicTacToe(['XXX', 'OOO', '   '])"}, {"start": 21, "end": 22, "test": "def test_validTicTacToe():\n    solution = Solution()\n    assert not solution.validTicTacToe(['XXX', 'OOO', '   '])"}]}
{"task_num": 805, "task_title": "Split Array With Same Average", "func_name": "splitArraySameAverage", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def splitArraySameAverage(self, nums: List[int]) -> bool:\n    n = len(nums)\n    summ = sum(nums)\n    if not any(i * summ % n == 0 for i in range(1, n // 2 + 1)):\n      return False\n\n    sums = [set() for _ in range(n // 2 + 1)]\n    sums[0].add(0)\n\n    for num in nums:\n      for i in range(n // 2, 0, -1):\n        for val in sums[i - 1]:\n          sums[i].add(num + val)\n\n    for i in range(1, n // 2 + 1):\n      if i * summ % n == 0 and i * summ // n in sums[i]:\n        return True\n\n    return False\n", "tests": [{"start": 15, "end": 16, "test": "def test_splitArraySameAverage():\n    solution = Solution()\n    assert not solution.splitArraySameAverage([1, 2, 3])"}, {"start": 27, "end": 28, "test": "def test_splitArraySameAverage():\n    solution = Solution()\n    assert solution.splitArraySameAverage([1, 2, 3, 4]) == True"}]}
{"task_num": 815, "task_title": "Bus Routes", "func_name": "numBusesToDestination", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:\n    if source == target:\n      return 0\n\n    graph = collections.defaultdict(list)\n    usedBuses = set()\n\n    for i in range(len(routes)):\n      for route in routes[i]:\n        graph[route].append(i)\n\n    ans = 0\n    q = collections.deque([source])\n\n    while q:\n      ans += 1\n      for _ in range(len(q)):\n        for bus in graph[q.popleft()]:\n          if bus in usedBuses:\n            continue\n          usedBuses.add(bus)\n          for nextRoute in routes[bus]:\n            if nextRoute == target:\n              return ans\n            q.append(nextRoute)\n\n    return -1\n", "tests": [{"start": 13, "end": 14, "test": "def test_numBusesToDestination():\n    solution = Solution()\n    assert solution.numBusesToDestination([[1, 2, 7]], 1, 1) == 0"}, {"start": 30, "end": 31, "test": "def test_numBusesToDestination():\n    solution = Solution()\n    routes = [[7, 12], [4, 5, 6], [7]]\n    source = 4\n    target = 6\n    assert solution.numBusesToDestination(routes, source, target) == -1"}, {"start": 34, "end": 35, "test": "def test_numBusesToDestination():\n    solution = Solution()\n    routes = [[1, 2], [2, 3], [3, 4]]\n    source = 1\n    target = 4\n    assert solution.numBusesToDestination(routes, source, target) == 2"}]}
{"task_num": 838, "task_title": "Push Dominoes", "func_name": "pushDominoes", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def pushDominoes(self, dominoes: str) -> str:\n    ans = list(dominoes)\n    L = -1\n    R = -1\n\n    for i in range(len(dominoes) + 1):\n      if i == len(dominoes) or dominoes[i] == 'R':\n        if L < R:\n          while R < i:\n            ans[R] = 'R'\n            R += 1\n        R = i\n      elif dominoes[i] == 'L':\n        if R < L or (L, R) == (-1, -1):\n          if (L, R) == (-1, -1):\n            L += 1\n          while L < i:\n            ans[L] = 'L'\n            L += 1\n        else:\n          l = R + 1\n          r = i - 1\n          while l < r:\n            ans[l] = 'R'\n            ans[r] = 'L'\n            l += 1\n            r -= 1\n        L = i\n\n    return ''.join(ans)\n", "tests": [{"start": 18, "end": 23, "test": "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('R.') == 'RR'"}, {"start": 19, "end": 22, "test": "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('RR.L') == 'RR.L'"}, {"start": 24, "end": 39, "test": "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('.L.') == 'LL.'"}, {"start": 25, "end": 30, "test": "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('.L.') == 'LL.'"}, {"start": 31, "end": 38, "test": "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('R.L') == 'R.L'"}, {"start": 26, "end": 27, "test": "def test_pushDominoes():\n    solution = Solution()\n    assert solution.pushDominoes('.L.') == 'LL.'"}]}
{"task_num": 845, "task_title": "Longest Mountain in Array", "func_name": "longestMountain", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def longestMountain(self, arr: List[int]) -> int:\n    ans = 0\n    i = 0\n\n    while i + 1 < len(arr):\n      while i + 1 < len(arr) and arr[i] == arr[i + 1]:\n        i += 1\n\n      increasing = 0\n      decreasing = 0\n\n      while i + 1 < len(arr) and arr[i] < arr[i + 1]:\n        increasing += 1\n        i += 1\n\n      while i + 1 < len(arr) and arr[i] > arr[i + 1]:\n        decreasing += 1\n        i += 1\n\n      if increasing > 0 and decreasing > 0:\n        ans = max(ans, increasing + decreasing + 1)\n\n    return ans\n", "tests": [{"start": 31, "end": 32, "test": "def test_longestMountain():\n    solution = Solution()\n    assert solution.longestMountain([2, 1, 4, 7, 3, 2, 5]) == 5"}]}
{"task_num": 854, "task_title": "K-Similar Strings", "func_name": "kSimilarity", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def kSimilarity(self, s1: str, s2: str) -> int:\n    ans = 0\n    q = collections.deque([s1])\n    seen = {s1}\n\n    while q:\n      for _ in range(len(q)):\n        curr = q.popleft()\n        if curr == s2:\n          return ans\n        for child in self._getChildren(curr, s2):\n          if child in seen:\n            continue\n          q.append(child)\n          seen.add(child)\n      ans += 1\n\n    return -1\n\n  def _getChildren(self, curr: str, target: str) -> List[str]:\n    children = []\n    s = list(curr)\n    i = 0\n    while curr[i] == target[i]:\n      i += 1\n\n    for j in range(i + 1, len(s)):\n      if s[j] == target[i]:\n        s[i], s[j] = s[j], s[i]\n        children.append(''.join(s))\n        s[i], s[j] = s[j], s[i]\n\n    return children\n", "tests": [{"start": 39, "end": 42, "test": "def test_kSimilarity():\n    solution = Solution()\n    assert solution.kSimilarity('ab', 'ba') == 1"}, {"start": 20, "end": 21, "test": "def test_kSimilarity():\n    solution = Solution()\n    assert solution.kSimilarity('abc', 'bca') == 2"}, {"start": 23, "end": 24, "test": "def test_kSimilarity():\n    solution = Solution()\n    assert solution.kSimilarity('abc', 'bca') == 1"}]}
{"task_num": 861, "task_title": "Score After Flipping Matrix", "func_name": "matrixScore", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def matrixScore(self, grid: List[List[int]]) -> int:\n    for row in grid:\n      if row[0] == 0:\n        self._flip(row)\n\n    for j, col in enumerate(list(zip(*grid))):\n      if sum(col) * 2 < len(grid):\n        self._flipCol(grid, j)\n\n    return sum(self._binary(row) for row in grid)\n\n  def _flip(self, row: List[int]) -> None:\n    for i in range(len(row)):\n      row[i] ^= 1\n\n  def _flipCol(self, grid: List[List[int]], j: int) -> None:\n    for i in range(len(grid)):\n      grid[i][j] ^= 1\n\n  def _binary(self, row: List[int]) -> int:\n    res = row[0]\n    for j in range(1, len(row)):\n      res = res * 2 + row[j]\n    return res\n", "tests": [{"start": 14, "end": 15, "test": "def test_matrixScore():\n    solution = Solution()\n    grid = [[0, 0], [1, 1]]\n    assert solution.matrixScore(grid) == 3"}, {"start": 18, "end": 19, "test": "def test_matrixScore():\n    solution = Solution()\n    grid = [[0, 0, 1], [1, 0, 1]]\n    assert solution.matrixScore(grid) == 6"}]}
{"task_num": 866, "task_title": "Prime Palindrome", "func_name": "primePalindrome", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def primePalindrome(self, n: int) -> int:\n    def getPalindromes(n: int):\n      length = n // 2\n      for i in range(10**(length - 1), 10**length):\n        s = str(i)\n        for j in range(10):\n          yield int(s + str(j) + s[::-1])\n\n    def isPrime(num: int) -> bool:\n      for i in range(2, int(num**0.5 + 1)):\n        if num % i == 0:\n          return False\n      return True\n\n    if n <= 2:\n      return 2\n    if n == 3:\n      return 3\n    if n <= 5:\n      return 5\n    if n <= 7:\n      return 7\n    if n <= 11:\n      return 11\n\n    nLength = len(str(n))\n\n    while True:\n      for num in getPalindromes(nLength):\n        if num >= n and isPrime(num):\n          return num\n      nLength += 1\n", "tests": [{"start": 26, "end": 27, "test": "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(1) == 2"}, {"start": 28, "end": 29, "test": "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(3) == 3"}, {"start": 30, "end": 31, "test": "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(4) == 5"}, {"start": 32, "end": 33, "test": "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(8) == 11"}, {"start": 34, "end": 35, "test": "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(10) == 11"}, {"start": 22, "end": 23, "test": "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(14) == 17"}, {"start": 41, "end": 42, "test": "def test_primePalindrome():\n    solution = Solution()\n    assert solution.primePalindrome(3) == 3"}]}
{"task_num": 882, "task_title": "Reachable Nodes In Subdivided Graph", "func_name": "reachableNodes", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def reachableNodes(self, edges: List[List[int]], maxMoves: int, n: int) -> int:\n    graph = [[] for _ in range(n)]\n    dist = [maxMoves + 1] * n\n\n    for u, v, cnt in edges:\n      graph[u].append((v, cnt))\n      graph[v].append((u, cnt))\n\n    reachableNodes = self._dijkstra(graph, 0, maxMoves, dist)\n    reachableSubnodes = 0\n\n    for u, v, cnt in edges:\n      a = 0 if dist[u] > maxMoves else min(maxMoves - dist[u], cnt)\n      b = 0 if dist[v] > maxMoves else min(maxMoves - dist[v], cnt)\n      reachableSubnodes += min(a + b, cnt)\n\n    return reachableNodes + reachableSubnodes\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, maxMoves: int, dist: List[int]) -> int:\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if dist[u] >= maxMoves:\n        break\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        newDist = d + w + 1\n        if newDist < dist[v]:\n          dist[v] = newDist\n          heapq.heappush(minHeap, (newDist, v))\n\n    return sum(d <= maxMoves for d in dist)\n", "tests": [{"start": 36, "end": 37, "test": "def test_reachableNodes():\n    solution = Solution()\n    edges = [[0, 1, 2]]\n    maxMoves = 4\n    n = 2\n    assert solution.reachableNodes(edges, maxMoves, n) == 3"}, {"start": 38, "end": 39, "test": "def test_reachableNodes():\n    solution = Solution()\n    edges = [[0, 1, 2]]\n    maxMoves = 5\n    n = 2\n    assert solution.reachableNodes(edges, maxMoves, n) == 3"}, {"start": 42, "end": 44, "test": "def test_reachableNodes():\n    solution = Solution()\n    edges = [[0, 1, 2]]\n    maxMoves = 3\n    n = 2\n    assert solution.reachableNodes(edges, maxMoves, n) == 3"}]}
{"task_num": 909, "task_title": "Snakes and Ladders", "func_name": "snakesAndLadders", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def snakesAndLadders(self, board: List[List[int]]) -> int:\n    n = len(board)\n    ans = 0\n    q = collections.deque([1])\n    seen = set()\n    A = [0] * (1 + n * n)\n\n    for i in range(n):\n      for j in range(n):\n        if n - i & 1 :\n          A[(n - 1 - i) * n + (j + 1)] = board[i][j]\n        else:\n          A[(n - 1 - i) * n + (n - j)] = board[i][j]\n\n    while q:\n      ans += 1\n      for _ in range(len(q)):\n        curr = q.popleft()\n        for next in range(curr + 1, min(curr + 6, n * n) + 1):\n          dest = A[next] if A[next] > 0 else next\n          if dest == n * n:\n            return ans\n          if dest in seen:\n            continue\n          q.append(dest)\n          seen.add(dest)\n\n    return -1\n", "tests": [{"start": 21, "end": 22, "test": "def test_snakesAndLadders():\n    solution = Solution()\n    board = [[-1, -1], [-1, 30]]\n    assert solution.snakesAndLadders(board) == 2"}, {"start": 23, "end": 24, "test": "def test_snakesAndLadders():\n    solution = Solution()\n    board = [[-1, 4], [-1, 3]]\n    assert solution.snakesAndLadders(board) == 2"}, {"start": 32, "end": 33, "test": "def test_snakesAndLadders():\n    solution = Solution()\n    board = [[-1, -1], [-1, 9]]\n    assert solution.snakesAndLadders(board) == 2"}, {"start": 34, "end": 35, "test": "def test_snakesAndLadders():\n    solution = Solution()\n    board = [[-1, -1], [-1, 3]]\n    assert solution.snakesAndLadders(board) == 2"}]}
{"task_num": 913, "task_title": "Cat and Mouse", "func_name": "catMouseGame", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import IntEnum\n\n\nclass State(IntEnum):\n  kDraw = 0\n  kMouseWin = 1\n  kCatWin = 2\n\n\nclass Solution:\n  def catMouseGame(self, graph: List[List[int]]) -> int:\n    n = len(graph)\n    states = [[[0] * 2 for i in range(n)] for j in range(n)]\n    outDegree = [[[0] * 2 for i in range(n)] for j in range(n)]\n    q = collections.deque()\n\n    for cat in range(n):\n      for mouse in range(n):\n        outDegree[cat][mouse][0] = len(graph[mouse])\n        outDegree[cat][mouse][1] = len(graph[cat]) - graph[cat].count(0)\n\n    for cat in range(1, n):\n      for move in range(2):\n        states[cat][0][move] = int(State.kMouseWin)\n        q.append((cat, 0, move, int(State.kMouseWin)))\n        states[cat][cat][move] = int(State.kCatWin)\n        q.append((cat, cat, move, int(State.kCatWin)))\n\n    while q:\n      cat, mouse, move, state = q.popleft()\n      if cat == 2 and mouse == 1 and move == 0:\n        return state\n      prevMove = move ^ 1\n      for prev in graph[cat if prevMove else mouse]:\n        prevCat = prev if prevMove else cat\n        if prevCat == 0:\n          continue\n        prevMouse = mouse if prevMove else prev\n        if states[prevCat][prevMouse][prevMove]:\n          continue\n        if prevMove == 0 and state == int(State.kMouseWin) or \\\n                prevMove == 1 and state == int(State.kCatWin):\n          states[prevCat][prevMouse][prevMove] = state\n          q.append((prevCat, prevMouse, prevMove, state))\n        else:\n          outDegree[prevCat][prevMouse][prevMove] -= 1\n          if outDegree[prevCat][prevMouse][prevMove] == 0:\n            states[prevCat][prevMouse][prevMove] = state\n            q.append((prevCat, prevMouse, prevMove, state))\n\n    return states[2][1][0]\n", "tests": [{"start": 41, "end": 42, "test": "def test_catMouseGame():\n    solution = Solution()\n    graph = [[2, 5], [3], [0, 4, 5], [1, 4, 5], [2, 3], [0, 2, 3]]\n    assert solution.catMouseGame(graph) == 2"}, {"start": 46, "end": 47, "test": "def test_catMouseGame():\n    solution = Solution()\n    graph = [[2, 5], [3], [0, 4, 5], [1, 4, 5], [2, 3], [0, 2, 3]]\n    assert solution.catMouseGame(graph) == 2"}, {"start": 49, "end": 50, "test": "def test_catMouseGame():\n    solution = Solution()\n    graph = [[2, 5], [3], [0, 4, 5], [1, 4, 5], [3, 4], [0, 2, 3]]\n    assert solution.catMouseGame(graph) == 2"}, {"start": 51, "end": 54, "test": "def test_catMouseGame():\n    solution = Solution()\n    graph = [[2, 5], [3], [0, 4, 5], [1, 4, 5], [3, 4], [0, 2, 3]]\n    assert solution.catMouseGame(graph) == 2"}, {"start": 55, "end": 59, "test": "def test_catMouseGame():\n    solution = Solution()\n    graph = [[2, 5], [3], [0, 4, 5], [1, 4, 5], [3, 4], [0, 2, 3]]\n    assert solution.catMouseGame(graph) == 2"}, {"start": 57, "end": 59, "test": "def test_catMouseGame():\n    solution = Solution()\n    graph = [[2, 5], [3], [0, 4, 5], [1, 4, 5], [3, 4], [0, 2, 3]]\n    assert solution.catMouseGame(graph) == 2"}]}
{"task_num": 923, "task_title": "3Sum With Multiplicity", "func_name": "threeSumMulti", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def threeSumMulti(self, arr: List[int], target: int) -> int:\n    kMod = 1_000_000_007\n    ans = 0\n    count = collections.Counter(arr)\n\n    for i, x in count.items():\n      for j, y in count.items():\n        k = target - i - j\n        if k not in count:\n          continue\n        if i == j and j == k:\n          ans = (ans + x * (x - 1) * (x - 2) // 6) % kMod\n        elif i == j and j != k:\n          ans = (ans + x * (x - 1) // 2 * count[k]) % kMod\n        elif i < j and j < k:\n          ans = (ans + x * y * count[k]) % kMod\n\n    return ans % kMod\n", "tests": [{"start": 20, "end": 21, "test": "def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([1, 1, 2], 3) == 1"}, {"start": 22, "end": 23, "test": "def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([1, 1, 1], 3) == 1"}, {"start": 24, "end": 25, "test": "def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([1, 1, 2], 3) == 1"}, {"start": 26, "end": 27, "test": "def test_threeSumMulti():\n    solution = Solution()\n    assert solution.threeSumMulti([1, 2, 3, 4, 5], 6) == 1"}]}
{"task_num": 927, "task_title": "Three Equal Parts", "func_name": "threeEqualParts", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def threeEqualParts(self, arr: List[int]) -> List[int]:\n    ones = sum(a == 1 for a in arr)\n\n    if ones == 0:\n      return [0, len(arr) - 1]\n    if ones % 3 != 0:\n      return [-1, -1]\n\n    k = ones // 3\n    i = 0\n\n    for i in range(len(arr)):\n      if arr[i] == 1:\n        first = i\n        break\n\n    gapOnes = k\n\n    for j in range(i + 1, len(arr)):\n      if arr[j] == 1:\n        gapOnes -= 1\n        if gapOnes == 0:\n          second = j\n          break\n\n    gapOnes = k\n\n    for i in range(j + 1, len(arr)):\n      if arr[i] == 1:\n        gapOnes -= 1\n        if gapOnes == 0:\n          third = i\n          break\n\n    while third < len(arr) and arr[first] == arr[second] == arr[third]:\n      first += 1\n      second += 1\n      third += 1\n\n    if third == len(arr):\n      return [first - 1, second]\n    return [-1, -1]\n", "tests": [{"start": 15, "end": 16, "test": "def test_threeEqualParts():\n    solution = Solution()\n    assert solution.threeEqualParts([0, 0, 0]) == [0, len(arr) - 1]"}, {"start": 17, "end": 18, "test": "def test_threeEqualParts():\n    solution = Solution()\n    assert solution.threeEqualParts([0, 0, 0]) == [0, 2]"}, {"start": 51, "end": 52, "test": "def test_threeEqualParts():\n    solution = Solution()\n    assert solution.threeEqualParts([0, 0, 0]) == [0, 2]"}, {"start": 24, "end": 26, "test": "def test_threeEqualParts():\n    solution = Solution()\n    assert solution.threeEqualParts([0, 1, 0, 1, 0]) == [-1, -1]"}, {"start": 31, "end": 35, "test": "def test_threeEqualParts():\n    solution = Solution()\n    assert solution.threeEqualParts([1, 0, 1, 0, 1]) == [2, 4]"}, {"start": 40, "end": 44, "test": "def test_threeEqualParts():\n    solution = Solution()\n    assert solution.threeEqualParts([1, 0, 1, 0, 1]) == [2, 4]"}, {"start": 33, "end": 35, "test": "def test_threeEqualParts():\n    solution = Solution()\n    assert solution.threeEqualParts([1, 0, 1, 0, 1]) == [2, 4]"}, {"start": 42, "end": 44, "test": "def test_threeEqualParts():\n    solution = Solution()\n    assert solution.threeEqualParts([1, 0, 1, 0, 1]) == [2, 4]"}]}
{"task_num": 935, "task_title": "Knight Dialer", "func_name": "knightDialer", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def knightDialer(self, n: int) -> int:\n    dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n    kMod = 1_000_000_007\n\n    dp = [[1] * 3 for _ in range(4)]\n    dp[3][0] = dp[3][2] = 0\n\n    for _ in range(n - 1):\n      newDp = [[0] * 3 for _ in range(4)]\n      for i in range(4):\n        for j in range(3):\n          if (i, j) in ((3, 0), (3, 2)):\n            continue\n          for dx, dy in dirs:\n            x = i + dx\n            y = j + dy\n            if x < 0 or x >= 4 or y < 0 or y >= 3:\n              continue\n            if (x, y) in ((3, 0), (3, 2)):\n              continue\n            newDp[x][y] = (newDp[x][y] + dp[i][j]) % kMod\n      dp = newDp\n\n    return sum(map(sum, dp)) % kMod\n", "tests": [{"start": 23, "end": 24, "test": "def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(1) == 10"}, {"start": 28, "end": 29, "test": "def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(1) == 10"}, {"start": 30, "end": 31, "test": "def test_knightDialer():\n    solution = Solution()\n    assert solution.knightDialer(1) == 10"}]}
{"task_num": 939, "task_title": "Minimum Area Rectangle", "func_name": "minAreaRect", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minAreaRect(self, points: List[List[int]]) -> int:\n    ans = math.inf\n    xToYs = collections.defaultdict(set)\n\n    for x, y in points:\n      xToYs[x].add(y)\n\n    for i in range(len(points)):\n      for j in range(i):\n        x1, y1 = points[i]\n        x2, y2 = points[j]\n        if x1 == x2 or y1 == y2:\n          continue\n        if y2 in xToYs[x1] and y1 in xToYs[x2]:\n          ans = min(ans, abs(x1 - x2) * abs(y1 - y2))\n\n    return ans if ans < math.inf else 0\n", "tests": [{"start": 23, "end": 24, "test": "def test_minAreaRect():\n    solution = Solution()\n    points = [[0, 0], [0, 1], [1, 0]]\n    assert solution.minAreaRect(points) == 0"}, {"start": 25, "end": 26, "test": "def test_minAreaRect():\n    solution = Solution()\n    points = [[0, 0], [0, 1], [1, 0], [1, 1]]\n    assert solution.minAreaRect(points) == 1"}]}
{"task_num": 952, "task_title": "Largest Component Size by Common Factor", "func_name": "largestComponentSize", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def largestComponentSize(self, nums: List[int]) -> int:\n    ans = 0\n    uf = UnionFind(max(nums) + 1)\n    count = collections.Counter()\n\n    for num in nums:\n      for x in range(2, int(math.sqrt(num) + 1)):\n        if num % x == 0:\n          uf.unionByRank(num, x)\n          uf.unionByRank(num, num // x)\n\n    for num in nums:\n      numRoot = uf.find(num)\n      count[numRoot] += 1\n      ans = max(ans, count[numRoot])\n\n    return ans\n", "tests": [{"start": 19, "end": 20, "test": "def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([1, 2]) == 2"}, {"start": 21, "end": 22, "test": "def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([10, 15, 20]) == 3"}, {"start": 30, "end": 31, "test": "def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([2, 3, 5, 7]) == 1"}, {"start": 23, "end": 24, "test": "def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([10, 15, 20]) == 3"}, {"start": 25, "end": 27, "test": "def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([4, 6, 8, 9]) == 3"}, {"start": 43, "end": 45, "test": "def test_largestComponentSize():\n    solution = Solution()\n    assert solution.largestComponentSize([10, 25, 30]) == 3"}]}
{"task_num": 963, "task_title": "Minimum Area Rectangle II", "func_name": "minAreaFreeRect", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\nfrom math import sqrt\n\nclass Solution:\n  def minAreaFreeRect(self, points: List[List[int]]) -> float:\n    ans = math.inf\n    centerToPoints = collections.defaultdict(list)\n\n    for ax, ay in points:\n      for bx, by in points:\n        center = ((ax + bx) / 2, (ay + by) / 2)\n        centerToPoints[center].append((ax, ay, bx, by))\n\n    def dist(px: int, py: int, qx: int, qy: int) -> float:\n      return (px - qx)**2 + (py - qy)**2\n\n    for points in centerToPoints.values():\n      for ax, ay, _, _ in points:\n        for cx, cy, dx, dy in points:\n          if (cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0:\n            squaredArea = dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy)\n            if squaredArea > 0:\n              ans = min(ans, squaredArea)\n\n    return 0 if ans == math.inf else sqrt(ans)\n", "tests": [{"start": 28, "end": 31, "test": "def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[0, 0], [1, 1], [2, 2], [3, 3]]\n    assert solution.minAreaFreeRect(points) == 0.0"}, {"start": 30, "end": 31, "test": "def test_minAreaFreeRect():\n    solution = Solution()\n    points = [[0, 0], [1, 1], [2, 2], [3, 3]]\n    assert solution.minAreaFreeRect(points) == 0.0"}]}
{"task_num": 990, "task_title": "Satisfiability of Equality Equations", "func_name": "equationsPossible", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n\n  def union(self, u: int, v: int) -> None:\n    self.id[self.find(u)] = self.find(v)\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def equationsPossible(self, equations: List[str]) -> bool:\n    uf = UnionFind(26)\n\n    for x, op, _, y in equations:\n      if op == '=':\n        uf.union(ord(x) - ord('a'), ord(y) - ord('a'))\n\n    for x, op, _, y in equations:\n      if op == '!':\n        if uf.find(ord(x) - ord('a')) == uf.find(ord(y) - ord('a')):\n          return False\n    return True\n", "tests": [{"start": 19, "end": 20, "test": "def test_equationsPossible():\n    solution = Solution()\n    assert solution.equationsPossible(['a==b', 'b!=a']) == False"}, {"start": 29, "end": 30, "test": "def test_equationsPossible():\n    solution = Solution()\n    assert solution.equationsPossible(['a==b', 'b!=a']) == False"}, {"start": 33, "end": 35, "test": "def test_equationsPossible():\n    solution = Solution()\n    assert not solution.equationsPossible(['a==b', 'b!=a'])"}, {"start": 34, "end": 35, "test": "def test_equationsPossible():\n    solution = Solution()\n    assert not solution.equationsPossible(['a==b', 'b!=a'])"}]}
{"task_num": 999, "task_title": "Available Captures for Rook", "func_name": "numRookCaptures", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numRookCaptures(self, board: List[List[str]]) -> int:\n    ans = 0\n\n    for i in range(8):\n      for j in range(8):\n        if board[i][j] == 'R':\n          i0 = i\n          j0 = j\n\n    for d in [[1, 0], [0, 1], [-1, 0], [0, -1]]:\n      i = i0 + d[0]\n      j = j0 + d[1]\n      while 0 <= i < 8 and 0 <= j < 8:\n        if board[i][j] == 'p':\n          ans += 1\n        if board[i][j] != '.':\n          break\n        i += d[0]\n        j += d[1]\n\n    return ans\n", "tests": [{"start": 17, "end": 19, "test": "def test_numRookCaptures():\n    solution = Solution()\n    board = [['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', 'p', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['R', '.', '.', '.', '.', '.', '.', '.']]\n    assert solution.numRookCaptures(board) == 1"}, {"start": 25, "end": 26, "test": "def test_numRookCaptures():\n    solution = Solution()"}, {"start": 27, "end": 28, "test": "def test_numRookCaptures():\n    solution = Solution()"}]}
{"task_num": 1001, "task_title": "Grid Illumination", "func_name": "gridIllumination", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def gridIllumination(self, n: int, lamps: List[List[int]], queries: List[List[int]]) -> List[int]:\n    ans = []\n    rows = collections.Counter()\n    cols = collections.Counter()\n    diag1 = collections.Counter()\n    diag2 = collections.Counter()\n    lampsSet = set()\n\n    for i, j in lamps:\n      if (i, j) not in lampsSet:\n        lampsSet.add((i, j))\n        rows[i] += 1\n        cols[j] += 1\n        diag1[i + j] += 1\n        diag2[i - j] += 1\n\n    for i, j in queries:\n      if rows[i] or cols[j] or diag1[i + j] or diag2[i - j]:\n        ans.append(1)\n        for y in range(max(0, i - 1), min(n, i + 2)):\n          for x in range(max(0, j - 1), min(n, j + 2)):\n            if (y, x) in lampsSet:\n              lampsSet.remove((y, x))\n              rows[y] -= 1\n              cols[x] -= 1\n              diag1[y + x] -= 1\n              diag2[y - x] -= 1\n      else:\n        ans.append(0)\n\n    return ans\n", "tests": [{"start": 21, "end": 26, "test": "def test_gridIllumination():\n    solution = Solution()\n    assert solution.gridIllumination(5, [[0, 0]], [[0, 0]]) == [1]"}, {"start": 29, "end": 38, "test": "def test_gridIllumination():\n    solution = Solution()\n    assert solution.gridIllumination(5, [[0, 0], [4, 4]], [[1, 1], [1, 1]]) == [1, 0]"}, {"start": 39, "end": 40, "test": "def test_gridIllumination():\n    solution = Solution()\n    assert solution.gridIllumination(5, [[1, 2]], [[1, 2]]) == [0]"}, {"start": 33, "end": 38, "test": "def test_gridIllumination():\n    solution = Solution()\n    assert solution.gridIllumination(5, [[0, 0], [4, 4]], [[1, 1], [1, 1]]) == [1, 0]"}]}
{"task_num": 1093, "task_title": "Statistics from a Large Sample", "func_name": "sampleStats", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def sampleStats(self, count: List[int]) -> List[float]:\n    minimum = next((i for i, num in enumerate(count) if num), None)\n    maximum = next((i for i, num in reversed(list(enumerate(count))) if num), None)\n    n = sum(count)\n    mean = sum(i * c / n for i, c in enumerate(count))\n    mode = count.index(max(count))\n\n    numCount = 0\n    leftMedian = 0\n    for i, c in enumerate(count):\n      numCount += c\n      if numCount >= n / 2:\n        leftMedian = i\n        break\n\n    numCount = 0\n    rightMedian = 0\n    for i, c in reversed(list(enumerate(count))):\n      numCount += c\n      if numCount >= n / 2:\n        rightMedian = i\n        break\n\n    return [minimum, maximum, mean, (leftMedian + rightMedian) / 2, mode]\n", "tests": [{"start": 23, "end": 25, "test": "def test_sampleStats():\n    solution = Solution()\n    result = solution.sampleStats([0, 1] * 128)"}, {"start": 31, "end": 33, "test": "def test_sampleStats():\n    solution = Solution()\n    result = solution.sampleStats([0, 1] * 5)"}]}
{"task_num": 1129, "task_title": "Shortest Path with Alternating Colors", "func_name": "shortestAlternatingPaths", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import Enum\n\n\nclass Color(Enum):\n  kInit = 0\n  kRed = 1\n  kBlue = 2\n\n\nclass Solution:\n  def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:\n    ans = [-1] * n\n    graph = [[] for _ in range(n)]\n    q = collections.deque([(0, Color.kInit)])\n\n    for u, v in redEdges:\n      graph[u].append((v, Color.kRed))\n\n    for u, v in blueEdges:\n      graph[u].append((v, Color.kBlue))\n\n    step = 0\n    while q:\n      for _ in range(len(q)):\n        u, prevColor = q.popleft()\n        if ans[u] == -1:\n          ans[u] = step\n        for i, (v, edgeColor) in enumerate(graph[u]):\n          if v == -1 or edgeColor == prevColor:\n            continue\n          q.append((v, edgeColor))\n          graph[u][i] = (-1, edgeColor)\n      step += 1\n\n    return ans\n", "tests": [{"start": 36, "end": 37, "test": "def test_shortestAlternatingPaths():\n    solution = Solution()\n    assert solution.shortestAlternatingPaths(3, [[0, 1], [1, 2]], []) == [-1, 1, -1]"}, {"start": 39, "end": 40, "test": "def test_shortestAlternatingPaths():\n    solution = Solution()\n    assert solution.shortestAlternatingPaths(3, [[0, 1], [1, 2]], [[1, 0]]) == [0, 1, -1]"}]}
{"task_num": 1139, "task_title": "Largest 1-Bordered Square", "func_name": "largest1BorderedSquare", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n\n    leftOnes = [[0] * n for _ in range(m)]\n    topOnes = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1:\n          if j==0:\n            leftOnes[i][j]=1\n          else:\n            leftOnes[i][j]=1+leftOnes[i][j-1]\n          if i==0:\n            topOnes[i][j]=1\n          else:\n            topOnes[i][j]=1+topOnes[i-1][j]\n\n    for sz in range(min(m, n), 0, -1):\n      for i in range(m - sz + 1):\n        for j in range(n - sz + 1):\n          x = i + sz - 1\n          y = j + sz - 1\n          if min(leftOnes[i][y], leftOnes[x][y], topOnes[x][j], topOnes[x][y]) >= sz:\n            return sz * sz\n\n    return 0\n", "tests": [{"start": 21, "end": 29, "test": "def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[0, 1, 1], [1, 1, 1], [1, 1, 1]]\n    assert solution.largest1BorderedSquare(grid) == 9"}, {"start": 22, "end": 23, "test": "def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[0, 1], [1, 1]]\n    assert solution.largest1BorderedSquare(grid) == 4"}, {"start": 24, "end": 25, "test": "def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[0, 1, 1], [1, 1, 1], [1, 1, 1]]\n    assert solution.largest1BorderedSquare(grid) == 9"}, {"start": 26, "end": 27, "test": "def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[0, 1], [1, 1]]\n    assert solution.largest1BorderedSquare(grid) == 4"}, {"start": 28, "end": 29, "test": "def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[1, 0, 1], [1, 1, 1], [1, 1, 1]]\n    assert solution.largest1BorderedSquare(grid) == 9"}, {"start": 36, "end": 37, "test": "def test_largest1BorderedSquare():\n    solution = Solution()\n    grid = [[1, 1, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]]\n    assert solution.largest1BorderedSquare(grid) == 4"}]}
{"task_num": 1162, "task_title": "As Far from Land as Possible", "func_name": "maxDistance", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxDistance(self, grid: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    q = collections.deque()\n    water = 0\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 0:\n          water += 1\n        else:\n          q.append((i, j))\n\n    if water == 0 or water == m * n:\n      return -1\n\n    ans = 0\n    d = 0\n\n    while q:\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        ans = d\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if grid[x][y] > 0:\n            continue\n          q.append((x, y))\n          grid[x][y] = 2\n      d += 1\n\n    return ans\n", "tests": [{"start": 26, "end": 27, "test": "def test_maxDistance():\n    solution = Solution()\n    grid = [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\n    assert solution.maxDistance(grid) == -1"}, {"start": 21, "end": 22, "test": "def test_maxDistance():\n    solution = Solution()\n    assert solution.maxDistance([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == -1"}, {"start": 23, "end": 24, "test": "def test_maxDistance():\n    solution = Solution()\n    grid = [[1, 0, 1], [0, 0, 0], [1, 0, 1]]\n    assert solution.maxDistance(grid) == 2"}, {"start": 39, "end": 40, "test": "def test_maxDistance():\n    solution = Solution()\n    grid = [[1, 0, 0], [0, 0, 0], [0, 0, 0]]\n    assert solution.maxDistance(grid) == -1"}, {"start": 41, "end": 42, "test": "def test_maxDistance():\n    solution = Solution()\n    assert solution.maxDistance([[1, 0, 1], [0, 0, 0], [1, 0, 1]]) == 2"}]}
{"task_num": 1202, "task_title": "Smallest String With Swaps", "func_name": "smallestStringWithSwaps", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n    ans = ''\n    uf = UnionFind(len(s))\n    map = collections.defaultdict(list)\n\n    for a, b in pairs:\n      uf.unionByRank(a, b)\n\n    for i, c in enumerate(s):\n      map[uf.find(i)].append(c)\n\n    for key in map.keys():\n      map[key].sort(reverse=True)\n\n    for i in range(len(s)):\n      ans += map[uf.find(i)].pop()\n\n    return ans\n", "tests": [{"start": 19, "end": 20, "test": "def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'dcab'\n    pairs = [[0, 3], [1, 2]]\n    assert solution.smallestStringWithSwaps(s, pairs) == 'abcd'"}, {"start": 21, "end": 22, "test": "def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'dcab'\n    pairs = [[0, 3], [1, 2]]\n    assert solution.smallestStringWithSwaps(s, pairs) == 'abcd'"}, {"start": 30, "end": 31, "test": "def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'dcab'\n    pairs = [[0, 3], [1, 2]]\n    assert solution.smallestStringWithSwaps(s, pairs) == 'abcd'"}, {"start": 23, "end": 24, "test": "def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'dcab'\n    pairs = [[0, 3], [1, 2]]\n    assert solution.smallestStringWithSwaps(s, pairs) == 'abcd'"}, {"start": 25, "end": 27, "test": "def test_smallestStringWithSwaps():\n    solution = Solution()\n    s = 'dcab'\n    pairs = [[0, 3], [1, 2]]\n    assert solution.smallestStringWithSwaps(s, pairs) == 'abcd'"}]}
{"task_num": 1210, "task_title": "Minimum Moves to Reach Target with Rotations", "func_name": "minimumMoves", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import IntEnum\n\n\nclass Pos(IntEnum):\n  kHorizontal = 0\n  kVertical = 1\n\n\nclass Solution:\n  def minimumMoves(self, grid: List[List[int]]) -> int:\n    n = len(grid)\n    ans = 0\n\n    q = collections.deque([(0, 0, Pos.kHorizontal)])\n    seen = {(0, 0, Pos.kHorizontal)}\n\n    def canMoveRight(x: int, y: int, pos: Pos) -> bool:\n      if pos == Pos.kHorizontal:\n        return y + 2 < n and not grid[x][y + 2]\n      return y + 1 < n and not grid[x][y + 1] and not grid[x + 1][y + 1]\n\n    def canMoveDown(x: int, y: int, pos: Pos) -> bool:\n      if pos == Pos.kVertical:\n        return x + 2 < n and not grid[x + 2][y]\n      return x + 1 < n and not grid[x + 1][y] and not grid[x + 1][y + 1]\n\n    def canRotateClockwise(x: int, y: int, pos: Pos) -> bool:\n      return pos == Pos.kHorizontal and x + 1 < n and \\\n          not grid[x + 1][y + 1] and not grid[x + 1][y]\n\n    def canRotateCounterclockwise(x: int, y: int, pos: Pos) -> bool:\n      return pos == Pos.kVertical and y + 1 < n and \\\n          not grid[x + 1][y + 1] and not grid[x][y + 1]\n\n    while q:\n      for _ in range(len(q)):\n        x, y, pos = q.popleft()\n        if x == n - 1 and y == n - 2 and pos == Pos.kHorizontal:\n          return ans\n        if canMoveRight(x, y, pos) and (x, y + 1, pos) not in seen:\n          q.append((x, y + 1, pos))\n          seen.add((x, y + 1, pos))\n        if canMoveDown(x, y, pos) and (x + 1, y, pos) not in seen:\n          q.append((x + 1, y, pos))\n          seen.add((x + 1, y, pos))\n        newPos = Pos.kVertical if pos == Pos.kHorizontal else Pos.kHorizontal\n        if (canRotateClockwise(x, y, pos) or canRotateCounterclockwise(x, y, pos)) and (x, y, newPos) not in seen:\n          q.append((x, y, newPos))\n          seen.add((x, y, newPos))\n      ans += 1\n\n    return -1\n", "tests": [{"start": 28, "end": 29, "test": "def test_minimumMoves():\n    solution = Solution()\n    assert solution.minimumMoves([[0, 0, 1], [0, 0, 0]]) == -1"}, {"start": 33, "end": 34, "test": "def test_minimumMoves():\n    solution = Solution()\n    assert solution.minimumMoves([[0, 0, 1], [0, 0, 0], [0, 0, 0]]) == 2"}, {"start": 48, "end": 49, "test": "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n    assert solution.minimumMoves(grid) == 2"}, {"start": 50, "end": 52, "test": "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n    assert solution.minimumMoves(grid) == 2"}, {"start": 53, "end": 55, "test": "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n    assert solution.minimumMoves(grid) == 2"}, {"start": 57, "end": 59, "test": "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]\n    assert solution.minimumMoves(grid) == 4"}]}
{"task_num": 1253, "task_title": "Reconstruct a 2-Row Binary Matrix", "func_name": "reconstructMatrix", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def reconstructMatrix(self, upper: int, lower: int, colsum: List[int]) -> List[List[int]]:\n    if upper + lower != sum(colsum):\n      return []\n    if min(upper, lower) < colsum.count(2):\n      return []\n\n    ans = [[0] * len(colsum) for _ in range(2)]\n\n    for j, c in enumerate(colsum):\n      if c == 2:\n        ans[0][j] = 1\n        ans[1][j] = 1\n        upper -= 1\n        lower -= 1\n\n    for j, c in enumerate(colsum):\n      if c == 1 and upper > 0:\n        ans[0][j] = 1\n        c -= 1\n        upper -= 1\n      if c == 1 and lower > 0:\n        ans[1][j] = 1\n        lower -= 1\n\n    return ans\n", "tests": [{"start": 13, "end": 14, "test": "def test_reconstructMatrix():\n    solution = Solution()\n    result = solution.reconstructMatrix(2, 3, [2, 0, 1])"}, {"start": 15, "end": 16, "test": "def test_reconstructMatrix():\n    solution = Solution()\n    result = solution.reconstructMatrix(3, 2, [2, 1, 1])"}, {"start": 21, "end": 25, "test": "def test_reconstructMatrix():\n    solution = Solution()\n    result = solution.reconstructMatrix(3, 3, [2, 1, 1])"}, {"start": 28, "end": 31, "test": "def test_reconstructMatrix():\n    solution = Solution()\n    result = solution.reconstructMatrix(2, 2, [2, 0, 1])"}, {"start": 32, "end": 34, "test": "def test_reconstructMatrix():\n    solution = Solution()\n    result = solution.reconstructMatrix(2, 2, [2, 0, 1])"}]}
{"task_num": 1254, "task_title": "Number of Closed Islands", "func_name": "closedIsland", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def closedIsland(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n\n    def dfs(i: int, j: int) -> None:\n      if i < 0 or i == m or j < 0 or j == n:\n        return\n      if grid[i][j] == 1:\n        return\n\n      grid[i][j] = 1\n      dfs(i + 1, j)\n      dfs(i - 1, j)\n      dfs(i, j + 1)\n      dfs(i, j - 1)\n\n    for i in range(m):\n      for j in range(n):\n        if i * j == 0 or i == m - 1 or j == n - 1:\n          if grid[i][j] == 0:\n            dfs(i, j)\n\n    ans = 0\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 0:\n          dfs(i, j)\n          ans += 1\n\n    return ans\n", "tests": [{"start": 17, "end": 18, "test": "def test_closedIsland():\n    solution = Solution()\n    grid = [[1, 1, 1, 1], [1, 0, 0, 1], [1, 0, 0, 1], [1, 1, 1, 1]]\n    assert solution.closedIsland(grid) == 0"}, {"start": 19, "end": 20, "test": "def test_closedIsland():\n    solution = Solution()\n    assert solution.closedIsland([[1, 1, 1, 1], [1, 0, 0, 1], [1, 0, 0, 1], [1, 1, 1, 1]]) == 0"}, {"start": 30, "end": 32, "test": "def test_closedIsland():\n    solution = Solution()\n    assert solution.closedIsland([[1, 1, 1, 1], [1, 0, 0, 1], [1, 0, 0, 1], [1, 1, 1, 1]]) == 0"}, {"start": 38, "end": 40, "test": "def test_closedIsland():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n    assert solution.closedIsland(grid) == 1"}, {"start": 31, "end": 32, "test": "def test_closedIsland():\n    solution = Solution()\n    assert solution.closedIsland([[1, 1, 1, 1], [1, 0, 0, 1], [1, 0, 0, 1], [1, 1, 1, 1]]) == 0"}]}
{"task_num": 1263, "task_title": "Minimum Moves to Move a Box to Their Target Location", "func_name": "minPushBox", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\nfrom collections import deque\n\nclass Solution:\n  def minPushBox(self, grid: List[List[str]]) -> int:\n    for i in range(len(grid)):\n      for j in range(len(grid[0])):\n        if grid[i][j] == \"T\":\n          target = (i,j)\n        if grid[i][j] == \"B\":\n          box = (i,j)\n        if grid[i][j] == \"S\":\n          person = (i,j)\n\n    def valid(x,y):\n      return 0<=x<len(grid) and 0<=y<len(grid[0]) and grid[x][y]!='#'\n\n    def check(curr,dest,box):\n      que = deque([curr])\n      v = set()\n      while que:\n        pos = que.popleft()\n        if pos == dest: \n          return True\n        new_pos = [(pos[0]+1,pos[1]),(pos[0]-1,pos[1]),(pos[0],pos[1]+1),(pos[0],pos[1]-1)]\n        for x,y in new_pos:\n          if valid(x,y) and (x,y) not in v and (x,y)!=box:\n            v.add((x,y))\n            que.append((x,y))\n      return False\n\n    q = deque([(0,box,person)])\n    vis = {box+person}\n    while q :\n      dist, box, person = q.popleft()\n      if box == target:\n        return dist\n\n      b_coord = [(box[0]+1,box[1]),(box[0]-1,box[1]),(box[0],box[1]+1),(box[0],box[1]-1)]\n      p_coord = [(box[0]-1,box[1]),(box[0]+1,box[1]),(box[0],box[1]-1),(box[0],box[1]+1)]\n\n      for new_box,new_person in zip(b_coord,p_coord): \n        if valid(*new_box) and new_box+box not in vis:\n          if valid(*new_person) and check(person,new_person,box):\n            vis.add(new_box+box)\n            q.append((dist+1,new_box,box))\n\n    return -1\n", "tests": [{"start": 44, "end": 45, "test": "def test_minPushBox():\n    solution = Solution()\n    grid = [['#', '#', '#', '#', '#', '#'], ['#', 'T', '#', '#', '#', '#'], ['#', '.', '.', 'S', '#', '#'], ['#', '#', '#', '#', '#', '#']]\n    assert solution.minPushBox(grid) == -1"}, {"start": 16, "end": 17, "test": "def test_minPushBox():\n    solution = Solution()"}, {"start": 18, "end": 19, "test": "def test_minPushBox():\n    solution = Solution()"}, {"start": 20, "end": 21, "test": "def test_minPushBox():\n    solution = Solution()"}, {"start": 31, "end": 32, "test": "def test_minPushBox():\n    solution = Solution()\n    grid = [['#', '#', '#', '#', '#', '#'], ['#', 'T', '#', '#', '#', '#'], ['#', '.', '.', 'S', '#', '#'], ['#', '#', '#', '#', '#', '#']]\n    assert solution.minPushBox(grid) == -1"}, {"start": 51, "end": 54, "test": "def test_minPushBox():\n    solution = Solution()\n    grid = [['#', '#', '#', '#', '#', '#'], ['#', 'T', '#', '#', '#', '#'], ['#', '.', '.', 'S', '#', '#'], ['#', '#', '#', '#', '#', '#']]\n    assert solution.minPushBox(grid) == -1"}, {"start": 35, "end": 37, "test": "def test_minPushBox():\n    solution = Solution()\n    grid = [['#', '#', '#', '#', '#', '#'], ['#', 'T', '#', '#', '#', '#'], ['#', '.', '.', 'S', '#', '#'], ['#', '#', '#', '#', '#', '#']]\n    assert solution.minPushBox(grid) == -1"}, {"start": 52, "end": 54, "test": "def test_minPushBox():\n    solution = Solution()\n    grid = [['#', '#', '#', '#', '#', '#'], ['#', 'T', '#', '#', '#', '#'], ['#', '.', '.', 'S', '#', '#'], ['#', '#', '#', '#', '#', '#']]\n    assert solution.minPushBox(grid) == -1"}]}
{"task_num": 1267, "task_title": "Count Servers that Communicate", "func_name": "countServers", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countServers(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    ans = 0\n    rows = [0] * m\n    cols = [0] * n\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1:\n          rows[i] += 1\n          cols[j] += 1\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1 and (rows[i] > 1 or cols[j] > 1):\n          ans += 1\n\n    return ans\n", "tests": [{"start": 21, "end": 23, "test": "def test_countServers():\n    solution = Solution()\n    grid = [[0, 0, 1], [0, 1, 0], [1, 0, 0]]\n    assert solution.countServers(grid) == 2"}, {"start": 27, "end": 28, "test": "def test_countServers():\n    solution = Solution()\n    grid = [[1, 0, 0], [0, 0, 0], [1, 0, 1]]"}]}
{"task_num": 1284, "task_title": "Minimum Number of Flips to Convert Binary Matrix to Zero Matrix", "func_name": "minFlips", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minFlips(self, mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    hash = self._getHash(mat, m, n)\n    if hash == 0:\n      return 0\n\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    step = 0\n    q = collections.deque([hash])\n    seen = {hash}\n\n    while q:\n      step += 1\n      for _ in range(len(q)):\n        curr = q.popleft()\n        for i in range(m):\n          for j in range(n):\n            next = curr ^ 1 << (i * n + j)\n            for dx, dy in dirs:\n              x = i + dx\n              y = j + dy\n              if x < 0 or x == m or y < 0 or y == n:\n                continue\n              next ^= 1 << (x * n + y)\n            if next == 0:\n              return step\n            if next in seen:\n              continue\n            q.append(next)\n            seen.add(next)\n\n    return -1\n\n  def _getHash(self, mat: List[List[int]], m: int, n: int) -> int:\n    hash = 0\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j]:\n          hash |= 1 << (i * n + j)\n    return hash\n", "tests": [{"start": 16, "end": 17, "test": "def test_minFlips():\n    solution = Solution()\n    assert solution.minFlips([[0, 0], [0, 0]]) == 0"}, {"start": 50, "end": 51, "test": "def test_minFlips():\n    solution = Solution()\n    assert solution.minFlips([[0, 0], [0, 0]]) == 0"}, {"start": 37, "end": 38, "test": "def test_minFlips():\n    solution = Solution()\n    mat = [[1, 0], [0, 1]]\n    assert solution.minFlips(mat) == 2"}, {"start": 39, "end": 40, "test": "def test_minFlips():\n    solution = Solution()\n    mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]"}, {"start": 34, "end": 35, "test": "def test_minFlips():\n    solution = Solution()\n    mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    assert solution.minFlips(mat) == -1"}]}
{"task_num": 1293, "task_title": "Shortest Path in a Grid with Obstacles Elimination", "func_name": "shortestPath", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def shortestPath(self, grid: List[List[int]], k: int) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    if m == 1 and n == 1:\n      return 0\n\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    steps = 0\n    q = collections.deque([(0, 0, k)])\n    seen = {(0, 0, k)}\n\n    while q:\n      steps += 1\n      for _ in range(len(q)):\n        i, j, eliminate = q.popleft()\n        for l in range(4):\n          x = i + dirs[l][0]\n          y = j + dirs[l][1]\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if x == m - 1 and y == n - 1:\n            return steps\n          if grid[x][y] == 1 and eliminate == 0:\n            continue\n          newEliminate = eliminate - grid[x][y]\n          if (x, y, newEliminate) in seen:\n            continue\n          q.append((x, y, newEliminate))\n          seen.add((x, y, newEliminate))\n\n    return -1\n", "tests": [{"start": 15, "end": 16, "test": "def test_shortestPath():\n    solution = Solution()\n    assert solution.shortestPath([[0]], 0) == 0"}, {"start": 30, "end": 31, "test": "def test_shortestPath():\n    solution = Solution()\n    grid = [[0, 0], [1, 1]]\n    k = 1\n    assert solution.shortestPath(grid, k) == -1"}, {"start": 32, "end": 33, "test": "def test_shortestPath():\n    solution = Solution()\n    grid = [[0, 0], [0, 0]]\n    k = 1\n    assert solution.shortestPath(grid, k) == 2"}, {"start": 34, "end": 35, "test": "def test_shortestPath():\n    solution = Solution()\n    assert solution.shortestPath([[0, 0, 0], [1, 1, 0], [0, 0, 0]], 1) == 4"}, {"start": 37, "end": 38, "test": "def test_shortestPath():\n    solution = Solution()\n    grid = [[0, 1, 1], [0, 0, 0], [1, 1, 0]]\n    k = 1\n    assert solution.shortestPath(grid, k) == 4"}]}
{"task_num": 1301, "task_title": "Number of Paths with Max Score", "func_name": "pathsWithMaxScore", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def pathsWithMaxScore(self, board: List[str]) -> List[int]:\n    kMod = 1_000_000_007\n    n = len(board)\n    dirs = ((0, 1), (1, 0), (1, 1))\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    count = [[0] * (n + 1) for _ in range(n + 1)]\n\n    dp[0][0] = 0\n    dp[n - 1][n - 1] = 0\n    count[n - 1][n - 1] = 1\n\n    for i in reversed(range(n)):\n      for j in reversed(range(n)):\n        if board[i][j] == 'S' or board[i][j] == 'X':\n          continue\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if dp[i][j] < dp[x][y]:\n            dp[i][j] = dp[x][y]\n            count[i][j] = count[x][y]\n          elif dp[i][j] == dp[x][y]:\n            count[i][j] += count[x][y]\n            count[i][j] %= kMod\n\n        if dp[i][j] != -1 and board[i][j] != 'E':\n          dp[i][j] += int(board[i][j])\n          dp[i][j] %= kMod\n\n    return [dp[0][0], count[0][0]]\n", "tests": [{"start": 25, "end": 26, "test": "def test_pathsWithMaxScore():\n    solution = Solution()\n    result = solution.pathsWithMaxScore(['S', '1', 'X'], ['3', '2', 'E'])"}, {"start": 37, "end": 39, "test": "def test_pathsWithMaxScore():\n    solution = Solution()\n    board = ['S12', '34X', '56E']\n    assert solution.pathsWithMaxScore(board) == [17, 1]"}, {"start": 30, "end": 32, "test": "def test_pathsWithMaxScore():\n    solution = Solution()\n    board = ['X', 'S']\n    assert solution.pathsWithMaxScore(board) == [0, 0]"}, {"start": 33, "end": 35, "test": "def test_pathsWithMaxScore():\n    solution = Solution()\n    board = ['X', 'S']\n    assert solution.pathsWithMaxScore(board) == [0, 0]"}]}
{"task_num": 1334, "task_title": "Find the City With the Smallest Number of Neighbors at a Threshold Distance", "func_name": "findTheCity", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -> int:\n    ans = -1\n    minCitiesCount = n\n    dist = self._floydWarshall(n, edges, distanceThreshold)\n\n    for i in range(n):\n      citiesCount = sum(dist[i][j] <= distanceThreshold for j in range(n))\n      if citiesCount <= minCitiesCount:\n        ans = i\n        minCitiesCount = citiesCount\n\n    return ans\n\n  def _floydWarshall(self, n: int, edges: List[List[int]], distanceThreshold: int) -> List[List[int]]:\n    dist = [[distanceThreshold + 1] * n for _ in range(n)]\n\n    for i in range(n):\n      dist[i][i] = 0\n\n    for u, v, w in edges:\n      dist[u][v] = w\n      dist[v][u] = w\n\n    for k in range(n):\n      for i in range(n):\n        for j in range(n):\n          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    return dist\n", "tests": [{"start": 19, "end": 21, "test": "def test_findTheCity():\n    solution = Solution()\n    assert solution.findTheCity(4, [[0, 1, 3], [1, 2, 1], [1, 3, 4], [2, 3, 1]], 4) == 3"}]}
{"task_num": 1340, "task_title": "Jump Game V", "func_name": "maxJumps", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxJumps(self, arr: List[int], d: int) -> int:\n    n = len(arr)\n    dp = [1] * n\n    stack = []\n\n    for i in range(n + 1):\n      while stack and (i == n or arr[stack[-1]] < arr[i]):\n        indices = [stack.pop()]\n        while stack and arr[stack[-1]] == arr[indices[0]]:\n          indices.append(stack.pop())\n        for j in indices:\n          if i < n and i - j <= d:\n            dp[i] = max(dp[i], dp[j] + 1)\n          if stack and j - stack[-1] <= d:\n            dp[stack[-1]] = max(dp[stack[-1]], dp[j] + 1)\n      stack.append(i)\n\n    return max(dp)\n", "tests": [{"start": 23, "end": 24, "test": "def test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([6, 4, 2, 0, 3, 2, 0], 2) == 3"}, {"start": 25, "end": 26, "test": "def test_maxJumps():\n    solution = Solution()\n    assert solution.maxJumps([7, 6, 5, 4, 3, 2, 1], 2) == 7"}]}
{"task_num": 1345, "task_title": "Jump Game IV", "func_name": "minJumps", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minJumps(self, arr: List[int]) -> int:\n    n = len(arr)\n    graph = collections.defaultdict(list)\n    step = 0\n    q = collections.deque([0])\n    seen = {0}\n\n    for i, a in enumerate(arr):\n      graph[a].append(i)\n\n    while q:\n      for _ in range(len(q)):\n        i = q.popleft()\n        if i == n - 1:\n          return step\n        seen.add(i)\n        u = arr[i]\n        if i + 1 < n:\n          graph[u].append(i + 1)\n        if i - 1 >= 0:\n          graph[u].append(i - 1)\n        for v in graph[u]:\n          if v in seen:\n            continue\n          q.append(v)\n        graph[u].clear()\n      step += 1\n", "tests": [{"start": 25, "end": 26, "test": "def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([0, 1, 2, 3, 4, 5]) == 5"}, {"start": 29, "end": 30, "test": "def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([2, 3, 1, 1, 4]) == 2"}, {"start": 31, "end": 32, "test": "def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([4, 1, 2, 3, 1, 1]) == 3"}, {"start": 34, "end": 35, "test": "def test_minJumps():\n    solution = Solution()\n    assert solution.minJumps([1, 2, 3, 4, 1]) == 3"}]}
{"task_num": 1377, "task_title": "Frog Position After T Seconds", "func_name": "frogPosition", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n    tree = [[] for _ in range(n + 1)]\n    q = collections.deque([1])\n    seen = [False] * (n + 1)\n    prob = [0] * (n + 1)\n\n    prob[1] = 1\n    seen[1] = True\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    for _ in range(t):\n      for _ in range(len(q)):\n        a = q.popleft()\n        nChildren = sum(not seen[b] for b in tree[a])\n        for b in tree[a]:\n          if seen[b]:\n            continue\n          seen[b] = True\n          prob[b] = prob[a] / nChildren\n          q.append(b)\n        if nChildren > 0:\n          prob[a] = 0\n\n    return prob[target]\n", "tests": [{"start": 35, "end": 36, "test": "def test_frogPosition():\n    solution = Solution()\n    result = solution.frogPosition(5, [[1, 2], [1, 3], [1, 4], [2, 5]], 0, 5)"}, {"start": 30, "end": 31, "test": "def test_frogPosition():\n    solution = Solution()\n    result = solution.frogPosition(5, [[1, 2], [1, 3], [2, 4], [2, 5]], 2, 3)"}]}
{"task_num": 1417, "task_title": "Reformat The String", "func_name": "reformat", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def reformat(self, s: str) -> str:\n    A=[]\n    for c in s:\n      if c.isalpha():\n        A.append(c)\n    B=[]\n    for c in s:\n      if c.isdigit():\n        B.append(c)\n\n    if len(A) < len(B):\n      A, B = B, A\n    if len(A) - len(B) > 1:\n      return ''\n\n    ans = []\n\n    for i in range(len(B)):\n      ans.append(A[i])\n      ans.append(B[i])\n\n    if len(A) == len(B) + 1:\n      ans.append(A[-1])\n    return ''.join(ans)\n", "tests": [{"start": 22, "end": 23, "test": "def test_reformat():\n    solution = Solution()\n    assert solution.reformat('a0b1c2') == 'abc012'"}, {"start": 24, "end": 25, "test": "def test_reformat():\n    solution = Solution()\n    assert solution.reformat('a0b1c2') == ''"}, {"start": 33, "end": 34, "test": "def test_reformat():\n    solution = Solution()\n    assert solution.reformat('a0b1c2') == 'abc012'"}, {"start": 15, "end": 16, "test": "def test_reformat():\n    solution = Solution()\n    assert solution.reformat('a0b1c2') == 'abc012'"}, {"start": 19, "end": 20, "test": "def test_reformat():\n    solution = Solution()\n    assert solution.reformat('a0b1c2') == 'abc012'"}]}
{"task_num": 1462, "task_title": "Course Schedule IV", "func_name": "checkIfPrerequisite", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:\n    graph = [[] for _ in range(numCourses)]\n    isPrerequisite = [[False] * numCourses for _ in range(numCourses)]\n\n    for u, v in prerequisites:\n      graph[u].append(v)\n\n    for i in range(numCourses):\n      self._dfs(graph, i, isPrerequisite[i])\n\n    return [isPrerequisite[u][v] for u, v in queries]\n\n  def _dfs(self, graph: List[List[int]], u: int, used: List[bool]) -> None:\n    for v in graph[u]:\n      if used[v]:\n        continue\n      used[v] = True\n      self._dfs(graph, v, used)\n", "tests": [{"start": 26, "end": 27, "test": "def test_checkIfPrerequisite():\n    solution = Solution()\n    numCourses = 3\n    prerequisites = [[0, 1], [1, 2]]\n    queries = [[0, 2]]\n    expected = [True]\n    assert solution.checkIfPrerequisite(numCourses, prerequisites, queries) == expected"}]}
{"task_num": 1489, "task_title": "Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree", "func_name": "findCriticalAndPseudoCriticalEdges", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Union\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n    criticalEdges = []\n    pseudoCriticalEdges = []\n\n    for i in range(len(edges)):\n      edges[i].append(i)\n\n    edges.sort(key=lambda x: x[2])\n\n    def getMSTWeight(firstEdge: List[int], deletedEdgeIndex: int) -> Union[int, float]:\n      mstWeight = 0\n      uf = UnionFind(n)\n\n      if firstEdge:\n        uf.unionByRank(firstEdge[0], firstEdge[1])\n        mstWeight += firstEdge[2]\n\n      for u, v, weight, index in edges:\n        if index == deletedEdgeIndex:\n          continue\n        if uf.find(u) == uf.find(v):\n          continue\n        uf.unionByRank(u, v)\n        mstWeight += weight\n\n      root = uf.find(0)\n      if any(uf.find(i) != root for i in range(n)):\n        return math.inf\n\n      return mstWeight\n\n    mstWeight = getMSTWeight([], -1)\n\n    for edge in edges:\n      index = edge[3]\n      if getMSTWeight([], index) > mstWeight:\n        criticalEdges.append(index)\n      elif getMSTWeight(edge, -1) == mstWeight:\n        pseudoCriticalEdges.append(index)\n\n    return [criticalEdges, pseudoCriticalEdges]\n", "tests": [{"start": 19, "end": 20, "test": "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 2], [1, 2, 3], [2, 3, 4], [0, 3, 5]]\n    expected_output = [[0, 1], [2]]\n    assert solution.findCriticalAndPseudoCriticalEdges(n, edges) == expected_output"}, {"start": 21, "end": 22, "test": "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 2], [1, 2, 3], [2, 3, 4], [0, 3, 5]]\n    expected_output = [[0, 2], [1, 3]]\n    assert solution.findCriticalAndPseudoCriticalEdges(n, edges) == expected_output"}, {"start": 30, "end": 31, "test": "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 1], [1, 2, 1], [2, 3, 1], [0, 3, 1]]\n    expected_output = [[], []]\n    assert solution.findCriticalAndPseudoCriticalEdges(n, edges) == expected_output"}, {"start": 23, "end": 24, "test": "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 0, 6]]\n    expected_output = [[0, 1, 2, 3, 4], []]\n    assert solution.findCriticalAndPseudoCriticalEdges(n, edges) == expected_output"}, {"start": 25, "end": 27, "test": "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 2], [1, 2, 3], [2, 3, 4], [0, 3, 5]]\n    expected_output = [[0, 1], [2]]\n    assert solution.findCriticalAndPseudoCriticalEdges(n, edges) == expected_output"}, {"start": 49, "end": 51, "test": "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 1], [1, 2, 1], [2, 3, 1], [0, 3, 2]]\n    expected_output = [[0, 1, 2], [3]]\n    assert solution.findCriticalAndPseudoCriticalEdges(n, edges) == expected_output"}, {"start": 62, "end": 63, "test": "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 1], [1, 2, 1], [2, 3, 1], [0, 3, 2]]\n    expected_output = [[0, 1, 2], [3]]\n    assert solution.findCriticalAndPseudoCriticalEdges(n, edges) == expected_output"}, {"start": 71, "end": 72, "test": "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 2], [1, 2, 3], [2, 3, 4], [0, 3, 5]]\n    expected_output = [[0], [1, 2, 3]]\n    assert solution.findCriticalAndPseudoCriticalEdges(n, edges) == expected_output"}, {"start": 54, "end": 55, "test": "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 2], [1, 2, 3], [2, 3, 4], [0, 3, 5]]\n    expected_output = [[0, 1], [2]]\n    assert solution.findCriticalAndPseudoCriticalEdges(n, edges) == expected_output"}, {"start": 56, "end": 57, "test": "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 2], [1, 2, 3], [2, 3, 4], [0, 3, 5]]\n    expected_output = [[0, 1], [2]]\n    assert solution.findCriticalAndPseudoCriticalEdges(n, edges) == expected_output"}, {"start": 73, "end": 74, "test": "def test_findCriticalAndPseudoCriticalEdges():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 0, 6]]\n    expected_output = [[], [0, 1, 2, 3, 4]]\n    assert solution.findCriticalAndPseudoCriticalEdges(n, edges) == expected_output"}]}
{"task_num": 1573, "task_title": "Number of Ways to Split a String", "func_name": "numWays", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numWays(self, s: str) -> int:\n    kMod = 1_000_000_007\n    ones = s.count('1')\n    if ones % 3 != 0:\n      return 0\n    if ones == 0:\n      n = len(s)\n      return (n - 1) * (n - 2) // 2 % kMod\n\n    s1End = -1\n    s2Start = -1\n    s2End = -1\n    s3Start = -1\n    onesSoFar = 0\n\n    for i, c in enumerate(s):\n      if c == '1':\n        onesSoFar += 1\n      if s1End == -1 and onesSoFar == ones // 3:\n        s1End = i\n      elif s2Start == -1 and onesSoFar == ones // 3 + 1:\n        s2Start = i\n      if s2End == -1 and onesSoFar == ones // 3 * 2:\n        s2End = i\n      elif s3Start == -1 and onesSoFar == ones // 3 * 2 + 1:\n        s3Start = i\n\n    return (s2Start - s1End) * (s3Start - s2End) % kMod\n", "tests": [{"start": 15, "end": 16, "test": "def test_numWays():\n    solution = Solution()\n    assert solution.numWays('000') == 3"}, {"start": 17, "end": 19, "test": "def test_numWays():\n    solution = Solution()\n    assert solution.numWays('000') == 3"}, {"start": 28, "end": 29, "test": "def test_numWays():\n    solution = Solution()\n    assert solution.numWays('000') == 3"}, {"start": 30, "end": 31, "test": "def test_numWays():\n    solution = Solution()\n    assert solution.numWays('000') == 3"}, {"start": 34, "end": 35, "test": "def test_numWays():\n    solution = Solution()\n    assert solution.numWays('00111') == 6"}, {"start": 32, "end": 33, "test": "def test_numWays():\n    solution = Solution()\n    assert solution.numWays('000') == 3"}, {"start": 36, "end": 37, "test": "def test_numWays():\n    solution = Solution()\n    assert solution.numWays('000') == 3"}]}
{"task_num": 1574, "task_title": "Shortest Subarray to be Removed to Make Array Sorted", "func_name": "findLengthOfShortestSubarray", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n    n = len(arr)\n    l = 0\n    r = n - 1\n\n    while l < n - 1 and arr[l + 1] >= arr[l]:\n      l += 1\n    while r > 0 and arr[r - 1] <= arr[r]:\n      r -= 1\n    ans = min(n - 1 - l, r)\n\n    i = l\n    j = n - 1\n    while i >= 0 and j >= r and j > i:\n      if arr[i] <= arr[j]:\n        j -= 1\n      else:\n        i -= 1\n      ans = min(ans, j - i)\n\n    return ans\n", "tests": [{"start": 26, "end": 27, "test": "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([1, 2, 3, 10, 4, 2, 3, 5]) == 3"}, {"start": 28, "end": 29, "test": "def test_findLengthOfShortestSubarray():\n    solution = Solution()\n    assert solution.findLengthOfShortestSubarray([1, 2, 3, 10, 4, 2, 3, 5]) == 3"}]}
{"task_num": 1579, "task_title": "Remove Max Number of Edges to Keep Graph Fully Traversable", "func_name": "maxNumEdgesToRemove", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    self.count -= 1\n    return True\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\n    alice = UnionFind(n)\n    bob = UnionFind(n)\n    requiredEdges = 0\n\n    for type, u, v in sorted(edges, reverse=True):\n      u -= 1\n      v -= 1\n      if type == 3:\n        if alice.unionByRank(u, v) | bob.unionByRank(u, v):\n          requiredEdges += 1\n      elif type == 2:\n        if bob.unionByRank(u, v):\n          requiredEdges += 1\n      else:\n        if alice.unionByRank(u, v):\n          requiredEdges += 1\n\n    if alice.count == 1 and bob.count == 1:\n        return len(edges) - requiredEdges\n    else:\n        return -1\n", "tests": [{"start": 20, "end": 21, "test": "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    assert solution.maxNumEdgesToRemove(4, [[3, 1, 2], [3, 2, 3], [3, 3, 4], [3, 4, 1], [1, 1, 2], [2, 2, 3]]) == 2"}, {"start": 22, "end": 23, "test": "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    assert solution.maxNumEdgesToRemove(4, [[1, 2, 3], [2, 3, 4], [3, 4, 1], [3, 2, 4]]) == 1"}, {"start": 33, "end": 34, "test": "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    assert solution.maxNumEdgesToRemove(4, [[3, 1, 2], [3, 2, 3], [3, 3, 4], [1, 1, 2], [2, 2, 3]]) == 1"}, {"start": 57, "end": 58, "test": "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    assert solution.maxNumEdgesToRemove(4, [[3, 1, 2], [3, 2, 3], [3, 3, 4], [1, 1, 2], [2, 2, 3]]) == 1"}, {"start": 59, "end": 60, "test": "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    assert solution.maxNumEdgesToRemove(4, [[3, 1, 2], [3, 2, 3], [3, 3, 4], [1, 1, 2], [2, 2, 3]]) == -1"}, {"start": 24, "end": 25, "test": "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    assert solution.maxNumEdgesToRemove(4, [[3, 1, 2], [3, 2, 3], [3, 3, 4], [1, 1, 2], [2, 2, 3]]) == 1"}, {"start": 26, "end": 28, "test": "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    assert solution.maxNumEdgesToRemove(4, [[3, 1, 2], [3, 2, 3], [3, 3, 4], [1, 1, 2], [2, 2, 3]]) == 1"}, {"start": 47, "end": 49, "test": "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    assert solution.maxNumEdgesToRemove(3, [[3, 1, 2], [3, 2, 3], [3, 1, 3]]) == 0"}, {"start": 48, "end": 49, "test": "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    assert solution.maxNumEdgesToRemove(3, [[3, 1, 2], [3, 2, 3], [3, 1, 3], [1, 1, 2], [2, 2, 3]]) == 1"}, {"start": 50, "end": 53, "test": "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    assert solution.maxNumEdgesToRemove(4, [[3, 1, 2], [3, 2, 3], [3, 3, 4], [1, 1, 2], [2, 2, 3]]) == 1"}, {"start": 51, "end": 52, "test": "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    assert solution.maxNumEdgesToRemove(4, [[3, 1, 2], [3, 2, 3], [3, 3, 4], [1, 1, 2], [2, 2, 3]]) == 1"}, {"start": 54, "end": 55, "test": "def test_maxNumEdgesToRemove():\n    solution = Solution()\n    assert solution.maxNumEdgesToRemove(4, [[3, 1, 2], [3, 2, 3], [3, 3, 4], [1, 1, 2], [2, 2, 3]]) == 1"}]}
{"task_num": 1582, "task_title": "Special Positions in a Binary Matrix", "func_name": "numSpecial", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numSpecial(self, mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    ans = 0\n    rowOnes = [0] * m\n    colOnes = [0] * n\n\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j] == 1:\n          rowOnes[i] += 1\n          colOnes[j] += 1\n\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j] == 1 and rowOnes[i] == 1 and colOnes[j] == 1:\n          ans += 1\n\n    return ans\n", "tests": [{"start": 21, "end": 23, "test": "def test_numSpecial():\n    solution = Solution()\n    mat = [[0, 0, 1], [0, 1, 0], [1, 0, 0]]"}, {"start": 27, "end": 28, "test": "def test_numSpecial():\n    solution = Solution()\n    mat = [[0, 0, 1], [0, 1, 0], [1, 0, 0]]"}]}
{"task_num": 1583, "task_title": "Count Unhappy Friends", "func_name": "unhappyFriends", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\n    ans = 0\n    matches = [0] * n\n    prefer = [{} for _ in range(n)]\n\n    for x, y in pairs:\n      matches[x] = y\n      matches[y] = x\n\n    for i in range(n):\n      for j in range(n - 1):\n        prefer[i][preferences[i][j]] = j\n\n    for x in range(n):\n      for u in prefer[x].keys():\n        y = matches[x]\n        v = matches[u]\n        if prefer[x][u] < prefer[x][y] and prefer[u][x] < prefer[u][v]:\n          ans += 1\n          break\n\n    return ans\n", "tests": [{"start": 29, "end": 31, "test": "def test_unhappyFriends():\n    solution = Solution()\n    n = 4\n    preferences = [[1, 2, 3], [0, 2, 3], [0, 1, 3], [0, 1, 2]]\n    pairs = [[0, 1], [2, 3]]\n    assert solution.unhappyFriends(n, preferences, pairs) == 2"}]}
{"task_num": 1591, "task_title": "Strange Printer II", "func_name": "isPrintable", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import Enum\n\n\nclass State(Enum):\n  kInit = 0\n  kVisiting = 1\n  kVisited = 2\n\n\nclass Solution:\n  def isPrintable(self, targetGrid: List[List[int]]) -> bool:\n    kMaxColor = 60\n    m = len(targetGrid)\n    n = len(targetGrid[0])\n\n    graph = [set() for _ in range(kMaxColor + 1)]\n\n    for color in range(1, kMaxColor + 1):\n      minI = m\n      minJ = n\n      maxI = -1\n      maxJ = -1\n      for i in range(m):\n        for j in range(n):\n          if targetGrid[i][j] == color:\n            minI = min(minI, i)\n            minJ = min(minJ, j)\n            maxI = max(maxI, i)\n            maxJ = max(maxJ, j)\n\n      for i in range(minI, maxI + 1):\n        for j in range(minJ, maxJ + 1):\n          if targetGrid[i][j] != color:\n            graph[color].add(targetGrid[i][j])\n\n    states = [State.kInit] * (kMaxColor + 1)\n\n    def hasCycle(u: int) -> bool:\n      if states[u] == State.kVisiting:\n        return True\n      if states[u] == State.kVisited:\n        return False\n\n      states[u] = State.kVisiting\n      if any(hasCycle(v) for v in graph[u]):\n        return True\n      states[u] = State.kVisited\n\n      return False\n\n    for i in range(1, kMaxColor + 1):\n      if hasCycle(i):\n        return False\n    return True\n", "tests": [{"start": 49, "end": 50, "test": "def test_isPrintable():\n    solution = Solution()\n    targetGrid = [[1, 2], [2, 3]]\n    assert not solution.isPrintable(targetGrid)"}, {"start": 51, "end": 52, "test": "def test_isPrintable():\n    solution = Solution()\n    targetGrid = [[1, 1, 1], [1, 2, 1], [1, 1, 1]]\n    assert not solution.isPrintable(targetGrid)"}, {"start": 55, "end": 56, "test": "def test_isPrintable():\n    solution = Solution()\n    targetGrid = [[1, 2], [2, 3]]\n    assert not solution.isPrintable(targetGrid)"}, {"start": 62, "end": 63, "test": "def test_isPrintable():\n    solution = Solution()\n    targetGrid = [[1, 1, 2], [1, 2, 2]]\n    assert not solution.isPrintable(targetGrid)"}, {"start": 35, "end": 39, "test": "def test_isPrintable():\n    solution = Solution()\n    targetGrid = [[1, 2], [3, 4]]\n    assert solution.isPrintable(targetGrid) == True"}, {"start": 43, "end": 44, "test": "def test_isPrintable():\n    solution = Solution()\n    assert not solution.isPrintable([[1, 2], [2, 3]])"}]}
{"task_num": 1604, "task_title": "Alert Using Same Key-Card Three or More Times in a One Hour Period", "func_name": "alertNames", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n    nameToMinutes = collections.defaultdict(list)\n\n    for name, time in zip(keyName, keyTime):\n      minutes = self._getMinutes(time)\n      nameToMinutes[name].append(minutes)\n\n    res=[]\n    for name, minutes in nameToMinutes.items():\n      if self._hasAlert(minutes):\n        res.append(name)\n    return sorted(res)\n\n  def _hasAlert(self, minutes: List[int]) -> bool:\n    if len(minutes) > 70:\n      return True\n    minutes.sort()\n    for i in range(2, len(minutes)):\n      if minutes[i - 2] + 60 >= minutes[i]:\n        return True\n    return False\n\n  def _getMinutes(self, time: str) -> int:\n    h, m = map(int, time.split(':'))\n    return 60 * h + m\n", "tests": [{"start": 26, "end": 27, "test": "def test_alertNames():\n    solution = Solution()\n    keyName = ['a', 'a', 'a', 'a']\n    keyTime = ['00:01', '23:59', '23:58', '23:57']\n    assert solution.alertNames(keyName, keyTime) == ['a']"}, {"start": 21, "end": 22, "test": "def test_alertNames():\n    solution = Solution()\n    keyName = ['a', 'a', 'a']\n    keyTime = ['00:01', '23:59', '23:58']\n    assert solution.alertNames(keyName, keyTime) == ['a']"}, {"start": 30, "end": 31, "test": "def test_alertNames():\n    solution = Solution()\n    keyName = ['a', 'a', 'a']\n    keyTime = ['23:58', '23:59', '00:01']\n    assert solution.alertNames(keyName, keyTime) == ['a']"}]}
{"task_num": 1615, "task_title": "Maximal Network Rank", "func_name": "maximalNetworkRank", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\n    degrees = [0] * n\n\n    for u, v in roads:\n      degrees[u] += 1\n      degrees[v] += 1\n\n    maxDegree1 = 0\n    maxDegree2 = 0\n    for degree in degrees:\n      if degree > maxDegree1:\n        maxDegree2 = maxDegree1\n        maxDegree1 = degree\n      elif degree > maxDegree2:\n        maxDegree2 = degree\n\n    countMaxDegree1 = 0\n    countMaxDegree2 = 0\n    for degree in degrees:\n      if degree == maxDegree1:\n        countMaxDegree1 += 1\n      elif degree == maxDegree2:\n        countMaxDegree2 += 1\n\n    if countMaxDegree1 == 1:\n      edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree2) + self._getEdgeCount(roads, degrees, maxDegree2, maxDegree1)\n      return maxDegree1 + maxDegree2 - (countMaxDegree2 == edgeCount)\n    else:\n      edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree1)\n      maxPossibleEdgeCount = countMaxDegree1 * (countMaxDegree1 - 1) // 2\n      return 2 * maxDegree1 - (maxPossibleEdgeCount == edgeCount)\n\n  def _getEdgeCount(self, roads: List[List[int]], degrees: List[int], degreeU: int, degreeV: int) -> int:\n    edgeCount = 0\n    for u, v in roads:\n      if degrees[u] == degreeU and degrees[v] == degreeV:\n        edgeCount += 1\n    return edgeCount\n", "tests": [{"start": 36, "end": 38, "test": "def test_maximalNetworkRank():\n    solution = Solution()\n    assert solution.maximalNetworkRank(5, [[0, 1], [0, 4], [1, 2], [1, 3], [2, 3], [3, 4]]) == 5"}, {"start": 39, "end": 42, "test": "def test_maximalNetworkRank():\n    solution = Solution()\n    assert solution.maximalNetworkRank(5, [[0, 1], [0, 2], [0, 3], [1, 2], [1, 4], [2, 3]]) == 6"}, {"start": 22, "end": 24, "test": "def test_maximalNetworkRank():\n    solution = Solution()\n    assert solution.maximalNetworkRank(5, [[0, 1], [0, 4], [1, 2], [1, 3], [1, 4], [2, 3], [3, 4]]) == 6"}, {"start": 31, "end": 32, "test": "def test_maximalNetworkRank():\n    solution = Solution()\n    assert solution.maximalNetworkRank(5, [[0, 1], [0, 4], [1, 2], [1, 3], [2, 3], [3, 4]]) == 4"}, {"start": 47, "end": 48, "test": "def test_maximalNetworkRank():\n    solution = Solution()\n    assert solution.maximalNetworkRank(5, [[0, 1], [0, 4], [1, 2], [1, 3], [2, 3], [3, 4]]) == 4"}, {"start": 25, "end": 26, "test": "def test_maximalNetworkRank():\n    solution = Solution()\n    assert solution.maximalNetworkRank(5, [[0, 1], [0, 3], [1, 2], [1, 3], [2, 3], [3, 4]]) == 6"}, {"start": 33, "end": 34, "test": "def test_maximalNetworkRank():\n    solution = Solution()\n    assert solution.maximalNetworkRank(5, [[0, 1], [0, 4], [1, 2], [1, 3], [2, 3], [3, 4]]) == 5"}]}
{"task_num": 1616, "task_title": "Split Two Strings to Make Palindrome", "func_name": "checkPalindromeFormation", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def checkPalindromeFormation(self, a: str, b: str) -> bool:\n    return self._check(a, b) or self._check(b, a)\n\n  def _check(self, a: str, b: str) -> bool:\n    i, j = 0, len(a) - 1\n    while i < j:\n      if a[i] != b[j]:\n        return self._isPalindrome(a, i, j) or self._isPalindrome(b, i, j)\n      i += 1\n      j -= 1\n    return True\n\n  def _isPalindrome(self, s: str, i: int, j: int) -> bool:\n    while i < j:\n      if s[i] != s[j]:\n        return False\n      i += 1\n      j -= 1\n    return True\n", "tests": [{"start": 18, "end": 19, "test": "def test_checkPalindromeFormation():\n    solution = Solution()\n    assert solution.checkPalindromeFormation('abc', 'cba') == True"}, {"start": 26, "end": 27, "test": "def test_checkPalindromeFormation():\n    solution = Solution()\n    assert solution.checkPalindromeFormation('abc', 'cba') == True"}]}
{"task_num": 1617, "task_title": "Count Subtrees With Max Distance Between Cities", "func_name": "countSubgraphsForEachDiameter", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:\n    maxMask = 1 << n\n    dist = self._floydWarshall(n, edges)\n    ans = [0] * (n - 1)\n\n    for mask in range(maxMask):\n      maxDist = self._getMaxDist(mask, dist, n)\n      if maxDist > 0:\n        ans[maxDist - 1] += 1\n\n    return ans\n\n  def _floydWarshall(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n    dist = [[n] * n for _ in range(n)]\n\n    for i in range(n):\n      dist[i][i] = 0\n\n    for u, v in edges:\n      dist[u - 1][v - 1] = 1\n      dist[v - 1][u - 1] = 1\n\n    for k in range(n):\n      for i in range(n):\n        for j in range(n):\n          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    return dist\n\n  def _getMaxDist(self, mask: int, dist: List[List[int]], n: int) -> int:\n    maxDist = 0\n    edgeCount = 0\n    cityCount = 0\n    for u in range(n):\n      if (mask >> u) & 1 == 0:\n        continue\n      cityCount += 1\n      for v in range(u + 1, n):\n        if (mask >> v) & 1 == 0:\n          continue\n        if dist[u][v] == 1:\n          edgeCount += 1\n        maxDist = max(maxDist, dist[u][v])\n\n    if edgeCount == cityCount - 1:\n      return maxDist\n    else:\n      return 0\n", "tests": [{"start": 56, "end": 57, "test": "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    n = 4\n    edges = [[1, 2], [2, 3], [3, 4]]\n    expected = [1]\n    assert solution.countSubgraphsForEachDiameter(n, edges) == expected"}, {"start": 58, "end": 59, "test": "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    n = 3\n    edges = [[1, 2], [2, 3]]\n    assert solution.countSubgraphsForEachDiameter(n, edges) == [0]"}, {"start": 19, "end": 20, "test": "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    n = 4\n    edges = [[1, 2], [2, 3], [3, 4]]\n    expected = [0, 1, 1]\n    assert solution.countSubgraphsForEachDiameter(n, edges) == expected"}, {"start": 46, "end": 47, "test": "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    n = 3\n    edges = [[1, 2], [2, 3]]\n    expected = [0, 1]\n    assert solution.countSubgraphsForEachDiameter(n, edges) == expected"}, {"start": 50, "end": 51, "test": "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    n = 4\n    edges = [[1, 2], [2, 3], [3, 4]]\n    expected = [0, 1, 1]\n    assert solution.countSubgraphsForEachDiameter(n, edges) == expected"}, {"start": 52, "end": 53, "test": "def test_countSubgraphsForEachDiameter():\n    solution = Solution()\n    n = 4\n    edges = [[1, 2], [2, 3], [3, 4]]\n    expected = [0, 1, 1]\n    assert solution.countSubgraphsForEachDiameter(n, edges) == expected"}]}
{"task_num": 1627, "task_title": "Graph Connectivity With Threshold", "func_name": "areConnected", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def areConnected(self, n: int, threshold: int, queries: List[List[int]]) -> List[bool]:\n    uf = UnionFind(n + 1)\n\n    for z in range(threshold + 1, n + 1):\n      for x in range(z * 2, n + 1, z):\n        uf.unionByRank(z, x)\n\n    return [uf.find(a) == uf.find(b) for a, b in queries]\n", "tests": [{"start": 19, "end": 20, "test": "def test_areConnected():\n    solution = Solution()\n    assert solution.areConnected(5, 1, [[1, 2], [3, 4]]) == [False, False]"}, {"start": 21, "end": 22, "test": "def test_areConnected():\n    solution = Solution()\n    assert solution.areConnected(10, 3, [[4, 9], [2, 8]]) == [True, True]"}, {"start": 31, "end": 32, "test": "def test_areConnected():\n    solution = Solution()\n    assert solution.areConnected(5, 1, [[1, 2], [3, 4], [2, 4]]) == [False, False, True]"}, {"start": 23, "end": 24, "test": "def test_areConnected():\n    solution = Solution()\n    assert solution.areConnected(10, 3, [[2, 9], [4, 6]]) == [False, True]"}, {"start": 25, "end": 27, "test": "def test_areConnected():\n    solution = Solution()\n    assert solution.areConnected(5, 1, [[1, 4]]) == [True]"}]}
{"task_num": 1631, "task_title": "Path With Minimum Effort", "func_name": "minimumEffortPath", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumEffortPath(self, heights: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(heights)\n    n = len(heights[0])\n    diff = [[math.inf] * n for _ in range(m)]\n    seen = set()\n\n    minHeap = [(0, 0, 0)]\n    diff[0][0] = 0\n\n    while minHeap:\n      d, i, j = heapq.heappop(minHeap)\n      if i == m - 1 and j == n - 1:\n        return d\n      seen.add((i, j))\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if (x, y) in seen:\n          continue\n        newDiff = abs(heights[i][j] - heights[x][y])\n        maxDiff = max(diff[i][j], newDiff)\n        if diff[x][y] > maxDiff:\n          diff[x][y] = maxDiff\n          heapq.heappush(minHeap, (diff[x][y], x, y))\n", "tests": [{"start": 24, "end": 25, "test": "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[1, 2], [3, 4]]\n    assert solution.minimumEffortPath(heights) == 2"}, {"start": 30, "end": 31, "test": "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    assert solution.minimumEffortPath(heights) == 0"}, {"start": 32, "end": 33, "test": "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    assert solution.minimumEffortPath(heights) == 0"}, {"start": 36, "end": 38, "test": "def test_minimumEffortPath():\n    solution = Solution()\n    heights = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]"}]}
{"task_num": 1632, "task_title": "Rank Transform of a Matrix", "func_name": "matrixRankTransform", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self):\n    self.id = {}\n\n  def union(self, u: int, v: int) -> None:\n    self.id.setdefault(u, u)\n    self.id.setdefault(v, v)\n    i = self._find(u)\n    j = self._find(v)\n    if i != j:\n      self.id[i] = j\n\n  def getGroupIdToValues(self) -> Dict[int, List[int]]:\n    groupIdToValues = collections.defaultdict(list)\n    for u in self.id.keys():\n      groupIdToValues[self._find(u)].append(u)\n    return groupIdToValues\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def matrixRankTransform(self, matrix: List[List[int]]) -> List[List[int]]:\n    m = len(matrix)\n    n = len(matrix[0])\n    ans = [[0] * n for _ in range(m)]\n    valToGrids = collections.defaultdict(list)\n    maxRankSoFar = [0] * (m + n)\n\n    for i, row in enumerate(matrix):\n      for j, val in enumerate(row):\n        valToGrids[val].append((i, j))\n\n    for _, grids in sorted(valToGrids.items()):\n      uf = UnionFind()\n      for i, j in grids:\n        uf.union(i, j + m)\n      for values in uf.getGroupIdToValues().values():\n        maxRank = max(maxRankSoFar[i] for i in values)\n        for i in values:\n          maxRankSoFar[i] = maxRank + 1\n      for i, j in grids:\n        ans[i][j] = maxRankSoFar[i]\n\n    return ans\n", "tests": [{"start": 20, "end": 21, "test": "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[1, 2], [3, 4]]\n    expected_output = [[1, 2], [3, 4]]\n    assert solution.matrixRankTransform(matrix) == expected_output"}, {"start": 30, "end": 31, "test": "def test_matrixRankTransform():\n    solution = Solution()\n    matrix = [[2, 3], [1, 3]]\n    expected_output = [[1, 2], [2, 2]]\n    assert solution.matrixRankTransform(matrix) == expected_output"}]}
{"task_num": 1654, "task_title": "Minimum Jumps to Reach Home", "func_name": "minimumJumps", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import Enum\n\n\nclass Direction(Enum):\n  kForward = 0\n  kBackward = 1\n\n\nclass Solution:\n  def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\n    furthest = max(x + a + b, max(pos + a + b for pos in forbidden))\n    seenForward = {pos for pos in forbidden}\n    seenBackward = {pos for pos in forbidden}\n\n    q = collections.deque([(Direction.kForward, 0)])\n\n    ans = 0\n    while q:\n      for _ in range(len(q)):\n        dir, pos = q.popleft()\n        if pos == x:\n          return ans\n        forward = pos + a\n        backward = pos - b\n        if forward <= furthest and forward not in seenForward:\n          seenForward.add(forward)\n          q.append((Direction.kForward, forward))\n        if dir == Direction.kForward and backward >= 0 and backward not in seenBackward:\n          seenBackward.add(backward)\n          q.append((Direction.kBackward, backward))\n      ans += 1\n\n    return -1\n", "tests": [{"start": 31, "end": 32, "test": "def test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([0, 1], 2, 1, 0) == -1"}, {"start": 35, "end": 37, "test": "def test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([1, 2], 2, 1, 3) == -1"}, {"start": 38, "end": 40, "test": "def test_minimumJumps():\n    solution = Solution()\n    assert solution.minimumJumps([1, 2], 2, 1, 3) == -1"}]}
{"task_num": 1655, "task_title": "Distribute Repeating Integers", "func_name": "canDistribute", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\n    freqs = list(collections.Counter(nums).values())\n    validDistribution = self._getValidDistribution(freqs, quantity)\n    n = len(freqs)\n    m = len(quantity)\n    maxMask = 1 << m\n    dp = [[False] * maxMask for _ in range(n + 1)]\n    dp[n][maxMask - 1] = True\n\n    for i in range(n - 1, -1, -1):\n      for mask in range(maxMask):\n        dp[i][mask] = dp[i + 1][mask]\n        availableMask = ~mask & (maxMask - 1)\n        submask = availableMask\n        while submask > 0:\n          if validDistribution[i][submask]:\n            dp[i][mask] = dp[i][mask] or dp[i + 1][mask | submask]\n          submask = (submask - 1) & availableMask\n\n    return dp[0][0]\n\n  def _getValidDistribution(self, freqs: List[int], quantity: List[int]) -> List[List[bool]]:\n    maxMask = 1 << len(quantity)\n    validDistribution = [[False] * maxMask for _ in range(len(freqs))]\n    for i, freq in enumerate(freqs):\n      for mask in range(maxMask):\n        if freq >= self._getQuantitySum(quantity, mask):\n          validDistribution[i][mask] = True\n    return validDistribution\n\n  def _getQuantitySum(self, quantity: List[int], mask: int) -> int:\n    res=[]\n    for i, q in enumerate(quantity):\n      if mask >> i & 1:\n        res.append(q)\n    return sum(res)\n", "tests": [{"start": 45, "end": 46, "test": "def test_canDistribute():\n    solution = Solution()\n    assert solution.canDistribute([1, 2, 3, 4], [1, 1, 1]) == True"}, {"start": 38, "end": 39, "test": "def test_canDistribute():\n    solution = Solution()\n    assert solution.canDistribute([1, 2, 2, 3], [2, 1]) == True"}, {"start": 27, "end": 28, "test": "def test_canDistribute():\n    solution = Solution()\n    assert solution.canDistribute([1, 2, 3, 4], [1, 1, 1]) == True"}]}
{"task_num": 1681, "task_title": "Minimum Incompatibility", "func_name": "minimumIncompatibility", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def __init__(self):\n    self.kMaxNum = 16\n\n  def minimumIncompatibility(self, nums: List[int], k: int) -> int:\n    kMaxCompatibility = (16 - 1) * (16 // 2)\n    n = len(nums)\n    subsetSize = n // k\n    maxMask = 1 << n\n    incompatibilities = self._getIncompatibilities(nums, subsetSize)\n\n    dp = [kMaxCompatibility] * maxMask\n    dp[0] = 0\n\n    for mask in range(1, maxMask):\n      if mask.bit_count() % subsetSize != 0:\n        continue\n      submask = mask\n      while submask > 0:\n        if incompatibilities[submask] != -1:\n          dp[mask] = min(dp[mask], dp[mask - submask] + incompatibilities[submask])\n        submask = (submask - 1) & mask\n\n    if dp[-1] != kMaxCompatibility:\n      return dp[-1]\n    else:\n      return -1\n\n  def _getIncompatibilities(self, nums: List[int], subsetSize: int) -> List[int]:\n    maxMask = 1 << len(nums)\n    incompatibilities = [-1] * maxMask\n    for mask in range(maxMask):\n      if mask.bit_count() == subsetSize and self._isUnique(nums, mask, subsetSize):\n        incompatibilities[mask] = self._getIncompatibility(nums, mask)\n    return incompatibilities\n\n  def _isUnique(self, nums: List[int], mask: int, subsetSize: int) -> bool:\n    used = 0\n    for i, num in enumerate(nums):\n      if mask >> i & 1:\n        used |= 1 << num\n    return used.bit_count() == subsetSize\n\n  def _getIncompatibility(self, nums: List[int], mask: int) -> int:\n    mini = self.kMaxNum\n    maxi = 0\n    for i, num in enumerate(nums):\n      if mask >> i & 1:\n        maxi = max(maxi, num)\n        mini = min(mini, num)\n    return maxi - mini\n", "tests": [{"start": 34, "end": 35, "test": "def test_minimumIncompatibility():\n    solution = Solution()\n    assert solution.minimumIncompatibility([1, 2, 3, 4], 2) == 1"}, {"start": 36, "end": 37, "test": "def test_minimumIncompatibility():\n    solution = Solution()\n    assert solution.minimumIncompatibility([1, 2, 3, 4], 5) == -1"}, {"start": 26, "end": 27, "test": "def test_minimumIncompatibility():\n    solution = Solution()\n    assert solution.minimumIncompatibility([1, 2, 3, 4], 2) == 1"}, {"start": 43, "end": 44, "test": "def test_minimumIncompatibility():\n    solution = Solution()\n    assert solution.minimumIncompatibility([1, 2, 3, 4], 2) == 1"}, {"start": 50, "end": 51, "test": "def test_minimumIncompatibility():\n    solution = Solution()\n    assert solution.minimumIncompatibility([1, 2, 3, 4], 2) == 1"}, {"start": 58, "end": 60, "test": "def test_minimumIncompatibility():\n    solution = Solution()\n    assert solution.minimumIncompatibility([1, 2, 3, 4], 2) == 1"}, {"start": 30, "end": 31, "test": "def test_minimumIncompatibility():\n    solution = Solution()\n    assert solution.minimumIncompatibility([1, 2, 3, 4], 2) == 1"}]}
{"task_num": 1687, "task_title": "Delivering Boxes from Storage to Ports", "func_name": "boxDelivering", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\n    n = len(boxes)\n    dp = [0] * (n + 1)\n    trips = 2\n    weight = 0\n\n    l = 0\n    for r in range(n):\n      weight += boxes[r][1]\n\n      if r > 0 and boxes[r][0] != boxes[r - 1][0]:\n        trips += 1\n\n      while r - l + 1 > maxBoxes or weight > maxWeight or (l < r and dp[l + 1] == dp[l]):\n        weight -= boxes[l][1]\n        if boxes[l][0] != boxes[l + 1][0]:\n          trips -= 1\n        l += 1\n\n      dp[r + 1] = dp[l] + trips\n\n    return dp[n]\n", "tests": [{"start": 22, "end": 23, "test": "def test_boxDelivering():\n    solution = Solution()\n    assert solution.boxDelivering([[1, 1], [2, 2]], 2, 3, 4) == 3"}, {"start": 27, "end": 28, "test": "def test_boxDelivering():\n    solution = Solution()\n    assert solution.boxDelivering([[1, 1], [1, 1]], 2, 2, 3) == 2"}]}
{"task_num": 1705, "task_title": "Maximum Number of Eaten Apples", "func_name": "eatenApples", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def eatenApples(self, apples: List[int], days: List[int]) -> int:\n    n = len(apples)\n    ans = 0\n    minHeap = []\n\n    i = 0\n    while i < n or minHeap:\n      while minHeap and minHeap[0][0] <= i:\n        heapq.heappop(minHeap)\n      if i < n and apples[i] > 0:\n        heapq.heappush(minHeap, (i + days[i], apples[i]))\n      if minHeap:\n        rottenDay, numApples = heapq.heappop(minHeap)\n        if numApples > 1:\n          heapq.heappush(minHeap, (rottenDay, numApples - 1))\n        ans += 1\n      i += 1\n\n    return ans\n", "tests": [{"start": 21, "end": 22, "test": "def test_eatenApples():\n    solution = Solution()\n    assert solution.eatenApples([1, 2, 3, 5, 2], [3, 2, 1, 4, 2]) == 7"}, {"start": 23, "end": 27, "test": "def test_eatenApples():\n    solution = Solution()\n    assert solution.eatenApples([1, 2, 3, 5, 2], [3, 2, 1, 4, 2]) == 7"}, {"start": 25, "end": 26, "test": "def test_eatenApples():\n    solution = Solution()\n    assert solution.eatenApples([2, 7, 3], [2, 2, 1]) == 5"}]}
{"task_num": 1706, "task_title": "Where Will the Ball Fall", "func_name": "findBall", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findBall(self, grid: List[List[int]]) -> List[int]:\n    m = len(grid)\n    n = len(grid[0])\n    dp = [i for i in range(n)]\n    ans = [-1] * n\n\n    for i in range(m):\n      newDp = [-1] * n\n      for j in range(n):\n        if j + grid[i][j] < 0 or j + grid[i][j] == n:\n          continue\n        if grid[i][j] == 1 and grid[i][j + 1] == -1 or grid[i][j] == -1 and grid[i][j - 1] == 1:\n          continue\n        newDp[j + grid[i][j]] = dp[j]\n      dp = newDp\n\n    for i, ball in enumerate(dp):\n      if ball != -1:\n        ans[ball] = i\n\n    return ans\n", "tests": [{"start": 29, "end": 30, "test": "def test_findBall():\n    solution = Solution()\n    grid = [[1, 1, 1], [-1, -1, -1]]\n    assert solution.findBall(grid) == [2, 0]"}, {"start": 21, "end": 22, "test": "def test_findBall():\n    solution = Solution()\n    assert solution.findBall([[1, -1], [-1, 1]]) == [-1, -1]"}, {"start": 23, "end": 24, "test": "def test_findBall():\n    solution = Solution()\n    assert solution.findBall([[1, -1], [-1, 1]]) == [-1, -1]"}]}
{"task_num": 1707, "task_title": "Maximum XOR With an Element From Array", "func_name": "maximizeXor", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Optional\n\nclass TrieNode:\n  def __init__(self):\n    self.children: List[Optional[TrieNode]] = [None] * 2\n\n\nclass BitTrie:\n  def __init__(self, maxBit: int):\n    self.maxBit = maxBit\n    self.root = TrieNode()\n\n  def insert(self, num: int) -> None:\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n\n  def getMaxXor(self, num: int) -> int:\n    maxXor = 0\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      toggleBit = bit ^ 1\n      if node.children[toggleBit]:\n        maxXor = maxXor | 1 << i\n        node = node.children[toggleBit]\n      elif node.children[bit]:\n        node = node.children[bit]\n      else:\n        return 0\n    return maxXor\n\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, x: int, m: int):\n    self.queryIndex = queryIndex\n    self.x = x\n    self.m = m\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.x\n    yield self.m\n\n\nclass Solution:\n  def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n    ans = [-1] * len(queries)\n    maxBit = int(math.log2(max(max(nums), max(x for x, _ in queries))))\n    bitTrie = BitTrie(maxBit)\n\n    nums.sort()\n\n    i = 0\n    for queryIndex, x, m in sorted([IndexedQuery(i, x, m) for i, (x, m) in enumerate(queries)], key=lambda iq: iq.m):\n      while i < len(nums) and nums[i] <= m:\n        bitTrie.insert(nums[i])\n        i += 1\n      if i > 0 and nums[i - 1] <= m:\n        ans[queryIndex] = bitTrie.getMaxXor(x)\n\n    return ans\n", "tests": [{"start": 25, "end": 26, "test": "def test_maximizeXor():\n    solution = Solution()\n    nums = [1, 2, 3]\n    queries = [[4, 5], [6, 7]]\n    expected = [-1, 7]\n    assert solution.maximizeXor(nums, queries) == expected"}, {"start": 35, "end": 37, "test": "def test_maximizeXor():\n    solution = Solution()\n    nums = [0, 1, 2, 3, 4, 5, 6, 7]\n    queries = [[3, 3], [1, 2]]\n    expected = [3, 3]\n    assert solution.maximizeXor(nums, queries) == expected"}, {"start": 70, "end": 71, "test": "def test_maximizeXor():\n    solution = Solution()\n    nums = [3, 10, 5]\n    queries = [[2, 7], [4, 9], [1, 8]]\n    expected = [7, 11, 7]\n    assert solution.maximizeXor(nums, queries) == expected"}, {"start": 38, "end": 39, "test": "def test_maximizeXor():\n    solution = Solution()\n    nums = [1, 2, 4, 8]\n    queries = [[3, 5], [7, 10]]\n    expected = [3, 15]\n    assert solution.maximizeXor(nums, queries) == expected"}, {"start": 40, "end": 41, "test": "def test_maximizeXor():\n    solution = Solution()\n    nums = [3, 10, 5]\n    queries = [[2, 7], [3, 9]]\n    expected = [7, 10]\n    assert solution.maximizeXor(nums, queries) == expected"}]}
{"task_num": 1717, "task_title": "Maximum Score From Removing Substrings", "func_name": "maximumGain", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumGain(self, s: str, x: int, y: int) -> int:\n    if x > y:\n      return self._gain(s, 'ab', x, 'ba', y)\n    else:\n      return self._gain(s, 'ba', y, 'ab', x)\n\n  def _gain(self, s: str, sub1: str, point1: int, sub2: str, point2: int) -> int:\n    points = 0\n    stack1 = []\n    stack2 = []\n\n    for c in s:\n      if stack1 and stack1[-1] == sub1[0] and c == sub1[1]:\n        stack1.pop()\n        points += point1\n      else:\n        stack1.append(c)\n\n    for c in stack1:\n      if stack2 and stack2[-1] == sub2[0] and c == sub2[1]:\n        stack2.pop()\n        points += point2\n      else:\n        stack2.append(c)\n\n    return points\n", "tests": [{"start": 13, "end": 14, "test": "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('aabb', 2, 1) == 4"}, {"start": 15, "end": 16, "test": "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('aabb', 1, 2) == 4"}, {"start": 24, "end": 26, "test": "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('abab', 2, 3) == 4"}, {"start": 27, "end": 28, "test": "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('abba', 1, 1) == 2"}, {"start": 31, "end": 33, "test": "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('abba', 1, 1) == 4"}, {"start": 34, "end": 35, "test": "def test_maximumGain():\n    solution = Solution()\n    assert solution.maximumGain('abba', 1, 1) == 4"}]}
{"task_num": 1719, "task_title": "Number Of Ways To Reconstruct A Tree", "func_name": "checkWays", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def checkWays(self, pairs: List[List[int]]) -> int:\n    kMax = 501\n    graph = collections.defaultdict(list)\n    degrees = [0] * kMax\n    connected = [[False] * kMax for _ in range(kMax)]\n\n    for u, v in pairs:\n      graph[u].append(v)\n      graph[v].append(u)\n      degrees[u] += 1\n      degrees[v] += 1\n      connected[u][v] = True\n      connected[v][u] = True\n\n    for _, children in graph.items():\n      children.sort(key=lambda a: degrees[a], reverse=True)\n\n    root = next((i for i, d in enumerate(degrees) if d == len(graph) - 1), -1)\n    if root == -1:\n      return 0\n\n    hasMoreThanOneWay = False\n\n    def dfs(u: int, ancestors: List[int], seen: List[bool]) -> bool:\n      nonlocal hasMoreThanOneWay\n      seen[u] = True\n      for ancestor in ancestors:\n        if not connected[u][ancestor]:\n          return False\n      ancestors.append(u)\n      for v in graph[u]:\n        if seen[v]:\n          continue\n        if degrees[v] == degrees[u]:\n          hasMoreThanOneWay = True\n        if not dfs(v, ancestors, seen):\n          return False\n      ancestors.pop()\n      return True\n\n    if not dfs(root, [], [False] * kMax):\n      return 0\n    if hasMoreThanOneWay:\n      return 2\n    else:\n      return 1\n", "tests": [{"start": 30, "end": 31, "test": "def test_checkWays():\n    solution = Solution()\n    assert solution.checkWays([]) == 0"}, {"start": 52, "end": 53, "test": "def test_checkWays():\n    solution = Solution()\n    pairs = [[1, 2], [2, 3], [3, 4]]\n    assert solution.checkWays(pairs) == 0"}, {"start": 54, "end": 55, "test": "def test_checkWays():\n    solution = Solution()\n    pairs = [[1, 2], [1, 3], [2, 4], [2, 5], [3, 6]]\n    assert solution.checkWays(pairs) == 2"}, {"start": 56, "end": 57, "test": "def test_checkWays():\n    solution = Solution()\n    assert solution.checkWays([[1, 2], [2, 3]]) == 1"}, {"start": 39, "end": 40, "test": "def test_checkWays():\n    solution = Solution()\n    pairs = [[1, 2], [2, 3], [3, 4], [4, 5]]\n    assert solution.checkWays(pairs) == 0"}, {"start": 43, "end": 44, "test": "def test_checkWays():\n    solution = Solution()\n    pairs = [[1, 2], [1, 3], [2, 4], [2, 5], [3, 6]]\n    assert solution.checkWays(pairs) == 1"}, {"start": 45, "end": 46, "test": "def test_checkWays():\n    solution = Solution()\n    pairs = [[1, 2], [2, 3], [3, 4], [4, 5]]\n    assert solution.checkWays(pairs) == 2"}, {"start": 47, "end": 48, "test": "def test_checkWays():\n    solution = Solution()\n    pairs = [[1, 2], [1, 3], [2, 4], [2, 5], [3, 6]]\n    assert solution.checkWays(pairs) == 2"}]}
{"task_num": 1722, "task_title": "Minimize Hamming Distance After Swap Operations", "func_name": "minimumHammingDistance", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -> int:\n    n = len(source)\n    ans = 0\n    uf = UnionFind(n)\n    groupIdToCount = [collections.Counter() for _ in range(n)]\n\n    for a, b in allowedSwaps:\n      uf.unionByRank(a, b)\n\n    for i in range(n):\n      groupIdToCount[uf.find(i)][source[i]] += 1\n\n    for i in range(n):\n      groupId = uf.find(i)\n      count = groupIdToCount[groupId]\n      if target[i] not in count:\n        ans += 1\n      else:\n        count[target[i]] -= 1\n        if count[target[i]] == 0:\n          del count[target[i]]\n\n    return ans\n", "tests": [{"start": 19, "end": 20, "test": "def test_minimumHammingDistance():\n    solution = Solution()\n    assert solution.minimumHammingDistance([1, 2, 3], [1, 2, 3], [[0, 1]]) == 0"}, {"start": 21, "end": 22, "test": "def test_minimumHammingDistance():\n    solution = Solution()\n    source = [1, 2, 3]\n    target = [1, 3, 2]\n    allowedSwaps = [[0, 1], [1, 2]]\n    assert solution.minimumHammingDistance(source, target, allowedSwaps) == 0"}, {"start": 30, "end": 31, "test": "def test_minimumHammingDistance():\n    solution = Solution()\n    source = [1, 2, 3]\n    target = [1, 2, 3]\n    allowedSwaps = [[0, 1], [1, 2]]\n    assert solution.minimumHammingDistance(source, target, allowedSwaps) == 0"}, {"start": 23, "end": 24, "test": "def test_minimumHammingDistance():\n    solution = Solution()\n    source = [1, 2, 3]\n    target = [1, 3, 2]\n    allowedSwaps = [[0, 1], [1, 2]]\n    assert solution.minimumHammingDistance(source, target, allowedSwaps) == 0"}, {"start": 25, "end": 27, "test": "def test_minimumHammingDistance():\n    solution = Solution()\n    source = [1, 2, 3]\n    target = [1, 2, 3]\n    allowedSwaps = [[0, 1], [1, 2]]\n    assert solution.minimumHammingDistance(source, target, allowedSwaps) == 0"}, {"start": 51, "end": 52, "test": "def test_minimumHammingDistance():\n    solution = Solution()\n    source = [1, 2, 3]\n    target = [1, 2, 4]\n    allowedSwaps = [[0, 1], [1, 2]]\n    assert solution.minimumHammingDistance(source, target, allowedSwaps) == 1"}, {"start": 53, "end": 56, "test": "def test_minimumHammingDistance():\n    solution = Solution()\n    assert solution.minimumHammingDistance([1, 2, 3], [1, 2, 3], [[0, 1]]) == 0"}, {"start": 55, "end": 56, "test": "def test_minimumHammingDistance():\n    solution = Solution()\n    assert solution.minimumHammingDistance([1, 2, 3], [1, 2, 4], [[0, 1]]) == 1"}]}
{"task_num": 1735, "task_title": "Count Ways to Make Array With Product", "func_name": "waysToFillArray", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def waysToFillArray(self, queries: List[List[int]]) -> List[int]:\n    kMod = 1_000_000_007\n    kMax = 10_000\n    minPrimeFactors = self._sieveEratosthenes(kMax + 1)\n\n    @functools.lru_cache(None)\n    def fact(i: int) -> int:\n      return 1 if i <= 1 else i * fact(i - 1) % kMod\n\n    @functools.lru_cache(None)\n    def inv(i: int) -> int:\n      return pow(i, kMod - 2, kMod)\n\n    @functools.lru_cache(None)\n    def nCk(n: int, k: int) -> int:\n      return fact(n) * inv(fact(k)) * inv(fact(n - k)) % kMod\n\n    ans = []\n\n    for n, k in queries:\n      res = 1\n      for freq in self._getPrimeFactorsCount(k, minPrimeFactors).values():\n        res = res * nCk(n - 1 + freq, freq) % kMod\n      ans.append(res)\n\n    return ans\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeFactorsCount(self, num: int, minPrimeFactors: List[int]) -> Dict[int, int]:\n    count = collections.Counter()\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      while num % divisor == 0:\n        num //= divisor\n        count[divisor] += 1\n    return count\n", "tests": [{"start": 42, "end": 44, "test": "def test_waysToFillArray():\n    solution = Solution()\n    assert solution.waysToFillArray([[2, 4]]) == [3]"}]}
{"task_num": 1765, "task_title": "Map of Highest Peak", "func_name": "highestPeak", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(isWater)\n    n = len(isWater[0])\n    ans = [[-1] * n for _ in range(m)]\n    q = collections.deque()\n\n    for i in range(m):\n      for j in range(n):\n        if isWater[i][j] == 1:\n          q.append((i, j))\n          ans[i][j] = 0\n\n    while q:\n      i, j = q.popleft()\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if ans[x][y] != -1:\n          continue\n        ans[x][y] = ans[i][j] + 1\n        q.append((x, y))\n\n    return ans\n", "tests": [{"start": 21, "end": 23, "test": "def test_highestPeak():\n    solution = Solution()\n    isWater = [[1]]\n    expected_output = [[0]]\n    assert solution.highestPeak(isWater) == expected_output"}, {"start": 30, "end": 31, "test": "def test_highestPeak():\n    solution = Solution()\n    isWater = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n    expected_output = [[2, 1, 2], [1, 0, 1], [2, 1, 2]]\n    assert solution.highestPeak(isWater) == expected_output"}, {"start": 32, "end": 33, "test": "def test_highestPeak():\n    solution = Solution()\n    isWater = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n    expected_output = [[2, 1, 2], [1, 0, 1], [2, 1, 2]]\n    assert solution.highestPeak(isWater) == expected_output"}]}
{"task_num": 1782, "task_title": "Count Pairs Of Nodes", "func_name": "countPairs", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:\n    ans = [0] * len(queries)\n\n    count = [0] * (n + 1)\n\n    shared = [collections.Counter() for _ in range(n + 1)]\n\n    for u, v in edges:\n      count[u] += 1\n      count[v] += 1\n      shared[min(u, v)][max(u, v)] += 1\n\n    sortedCount = sorted(count)\n\n    for k, query in enumerate(queries):\n      i = 1\n      j = n\n      while i < j:\n        if sortedCount[i] + sortedCount[j] > query:\n          ans[k] += j - i\n          j -= 1\n        else:\n          i += 1\n      for i in range(1, n + 1):\n        for j, sh in shared[i].items():\n          if count[i] + count[j] > query and count[i] + count[j] - sh <= query:\n            ans[k] -= 1\n\n    return ans\n", "tests": [{"start": 30, "end": 32, "test": "def test_countPairs():\n    solution = Solution()\n    assert solution.countPairs(4, [[1, 2], [2, 3], [3, 4]], [2, 3]) == [0, 1]"}, {"start": 33, "end": 34, "test": "def test_countPairs():\n    solution = Solution()\n    result = solution.countPairs(5, [[1, 2], [2, 3], [3, 4], [4, 5]], [6])"}, {"start": 37, "end": 38, "test": "def test_countPairs():\n    solution = Solution()\n    assert solution.countPairs(4, [[1, 2], [2, 3], [3, 4]], [2, 3]) == [0, 1]"}]}
{"task_num": 1786, "task_title": "Number of Restricted Paths From First to Last Node", "func_name": "countRestrictedPaths", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countRestrictedPaths(self, n: int, edges: List[List[int]]) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u - 1].append((v - 1, w))\n      graph[v - 1].append((u - 1, w))\n\n    return self._dijkstra(graph, 0, n - 1)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int) -> int:\n    kMod = 10**9 + 7\n    ways = [0] * len(graph)\n    dist = [math.inf] * len(graph)\n\n    ways[dst] = 1\n    dist[dst] = 0\n    minHeap = [(dist[dst], dst)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n        if dist[v] < dist[u]:\n          ways[u] += ways[v]\n          ways[u] %= kMod\n\n    return ways[src]\n", "tests": [{"start": 32, "end": 33, "test": "def test_countRestrictedPaths():\n    solution = Solution()\n    n = 5\n    edges = [[1, 2, 3], [1, 3, 4], [2, 3, 1], [2, 4, 2], [3, 4, 5]]\n    assert solution.countRestrictedPaths(n, edges) == 0"}, {"start": 35, "end": 37, "test": "def test_countRestrictedPaths():\n    solution = Solution()\n    n = 5\n    edges = [[1, 2, 3], [1, 3, 4], [2, 3, 1], [2, 4, 2], [3, 4, 5]]\n    assert solution.countRestrictedPaths(n, edges) == 2"}, {"start": 38, "end": 40, "test": "def test_countRestrictedPaths():\n    solution = Solution()\n    n = 5\n    edges = [[1, 2, 3], [1, 3, 4], [2, 3, 1], [2, 4, 2], [3, 4, 5]]\n    assert solution.countRestrictedPaths(n, edges) == 2"}]}
{"task_num": 1793, "task_title": "Maximum Score of a Good Subarray", "func_name": "maximumScore", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumScore(self, nums: List[int], k: int) -> int:\n    ans = 0\n    stack = []\n\n    for i in range(len(nums) + 1):\n      while stack and (i == len(nums) or nums[stack[-1]] > nums[i]):\n        h = nums[stack.pop()]\n        w = i - stack[-1] - 1 if stack else i\n        if (not stack or stack[-1] + 1 <= k) and i - 1 >= k:\n          ans = max(ans, h * w)\n      stack.append(i)\n\n    return ans\n", "tests": [{"start": 20, "end": 21, "test": "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([1, 4, 3, 7, 4, 5], 2) == 16"}]}
{"task_num": 1805, "task_title": "Number of Different Integers in a String", "func_name": "numDifferentIntegers", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numDifferentIntegers(self, word: str) -> int:\n    nums = set()\n    curr = []\n\n    for c in word:\n      if c.isdigit():\n        curr.append(c)\n      elif curr:\n        nums.add(''.join(self._removeLeadingZeros(curr)))\n        curr = []\n\n    if curr:\n      nums.add(''.join(self._removeLeadingZeros(curr)))\n\n    return len(nums)\n\n  def _removeLeadingZeros(self, s: str) -> str:\n    index = next((i for i, c in enumerate(s) if c != '0'), -1)\n    if index == -1:\n      return ['0']\n    else:\n      return s[index:]\n", "tests": [{"start": 23, "end": 24, "test": "def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers('abc123') == 1"}, {"start": 30, "end": 31, "test": "def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers('abc') == 1"}, {"start": 32, "end": 33, "test": "def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers('a0b1c2') == 3"}, {"start": 17, "end": 18, "test": "def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers('a123bc34d8ef34') == 4"}, {"start": 19, "end": 21, "test": "def test_numDifferentIntegers():\n    solution = Solution()\n    assert solution.numDifferentIntegers('a1b2c3') == 3"}]}
{"task_num": 1857, "task_title": "Largest Color Value in a Directed Graph", "func_name": "largestPathValue", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\n    n = len(colors)\n    ans = 0\n    processed = 0\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n    q = collections.deque()\n    count = [[0] * 26 for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      inDegrees[v] += 1\n\n    for i, degree in enumerate(inDegrees):\n      if degree == 0:\n        q.append(i)\n\n    while q:\n      u = q.popleft()\n      processed += 1\n      count[u][ord(colors[u]) - ord('a')] += 1\n      ans = max(ans, count[u][ord(colors[u]) - ord('a')])\n      for v in graph[u]:\n        for i in range(26):\n          count[v][i] = max(count[v][i], count[u][i])\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    if processed == n:\n      return ans\n    else:\n      return -1\n", "tests": [{"start": 41, "end": 42, "test": "def test_largestPathValue():\n    solution = Solution()\n    colors = 'ab'\n    edges = [[0, 1]]\n    assert solution.largestPathValue(colors, edges) == 2"}, {"start": 43, "end": 44, "test": "def test_largestPathValue():\n    solution = Solution()\n    colors = 'a'\n    edges = [[0, 0]]\n    assert solution.largestPathValue(colors, edges) == -1"}, {"start": 26, "end": 27, "test": "def test_largestPathValue():\n    solution = Solution()\n    colors = 'ab'\n    edges = [[0, 1]]\n    assert solution.largestPathValue(colors, edges) == 2"}, {"start": 38, "end": 39, "test": "def test_largestPathValue():\n    solution = Solution()\n    colors = 'ab'\n    edges = [[0, 1]]\n    assert solution.largestPathValue(colors, edges) == 2"}]}
{"task_num": 1878, "task_title": "Get Biggest Three Rhombus Sums in a Grid", "func_name": "getBiggestThree", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom sortedcontainers import SortedSet\n\n\nclass Solution:\n  def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\n    m = len(grid)\n    n = len(grid[0])\n    sums = SortedSet()\n\n    for i in range(m):\n      for j in range(n):\n        sz = 0\n        while i + sz < m and i - sz >= 0 and j + 2 * sz < n:\n          summ = grid[i][j] if sz == 0 else self._getSum(grid, i, j, sz)\n          sums.add(summ)\n          if len(sums) > 3:\n            sums.pop(0)\n          sz += 1\n\n    return reversed(sums)\n\n  def _getSum(self, grid: List[List[int]], i: int, j: int, sz: int) -> int:\n    x = i\n    y = j\n    summ = 0\n\n    for _ in range(sz):\n      x -= 1\n      y += 1\n      summ += grid[x][y]\n\n    for _ in range(sz):\n      x += 1\n      y += 1\n      summ += grid[x][y]\n\n    for _ in range(sz):\n      x += 1\n      y -= 1\n      summ += grid[x][y]\n\n    for _ in range(sz):\n      x -= 1\n      y -= 1\n      summ += grid[x][y]\n\n    return summ\n", "tests": [{"start": 26, "end": 27, "test": "def test_getBiggestThree():\n    solution = Solution()\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    assert solution.getBiggestThree(grid) == [20, 18, 16]"}]}
{"task_num": 1896, "task_title": "Minimum Cost to Change the Final Value of Expression", "func_name": "minOperationsToFlip", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minOperationsToFlip(self, expression: str) -> int:\n    stack = []\n\n    for e in expression:\n      if e in '(&|':\n        stack.append((e, 0))\n        continue\n      if e == ')':\n        lastPair = stack.pop()\n        stack.pop()\n      else: \n        lastPair = (e, 1)\n      if stack and stack[-1][0] in '&|':\n        op = stack.pop()[0]\n        a, costA = stack.pop()\n        b, costB = lastPair\n        if op == '&':\n          if a == '0' and b == '0':\n            lastPair = ('0', 1 + min(costA, costB))\n          elif a == '0' and b == '1':\n            lastPair = ('0', 1)\n          elif a == '1' and b == '0':\n            lastPair = ('0', 1)\n          else:\n            lastPair = ('1', min(costA, costB))\n        else:\n          if a == '0' and b == '0':\n            lastPair = ('0', min(costA, costB))\n          elif a == '0' and b == '1':\n            lastPair = ('1', 1)\n          elif a == '1' and b == '0':\n            lastPair = ('1', 1)\n          else:\n            lastPair = ('1', 1 + min(costA, costB))\n      stack.append(lastPair)\n\n    return stack[-1][1]\n", "tests": [{"start": 16, "end": 18, "test": "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('(&|') == 2"}, {"start": 19, "end": 21, "test": "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('((0))') == 1"}, {"start": 22, "end": 23, "test": "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('0') == 1"}, {"start": 24, "end": 45, "test": "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('0&1|0') == 2"}, {"start": 28, "end": 37, "test": "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('0&1') == 1"}, {"start": 29, "end": 30, "test": "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('0&0') == 2"}, {"start": 38, "end": 39, "test": "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('1&0') == 1"}, {"start": 31, "end": 32, "test": "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('0&1') == 1"}, {"start": 40, "end": 41, "test": "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('0|1') == 1"}, {"start": 33, "end": 34, "test": "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('1&0') == 1"}, {"start": 35, "end": 36, "test": "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('0&1|1') == 1"}, {"start": 42, "end": 43, "test": "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('1&0') == 1"}, {"start": 44, "end": 45, "test": "def test_minOperationsToFlip():\n    solution = Solution()\n    assert solution.minOperationsToFlip('0&1|1') == 2"}]}
{"task_num": 1906, "task_title": "Minimum Absolute Difference Queries", "func_name": "minDifference", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom bisect import bisect_left\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minDifference(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n    numToIndices = [[] for _ in range(101)]\n\n    for i, num in enumerate(nums):\n      numToIndices[num].append(i)\n\n    if len(numToIndices[nums[0]]) == len(nums):\n      return [-1] * len(queries)\n\n    ans = []\n\n    for l, r in queries:\n      prevNum = -1\n      minDiff = 101\n      for num in range(1, 101):\n        indices = numToIndices[num]\n        i = bisect_left(indices, l)\n        if i == len(indices) or indices[i] > r:\n          continue\n        if prevNum != -1:\n          minDiff = min(minDiff, num - prevNum)\n        prevNum = num\n      ans.append(-1 if minDiff == 101 else minDiff)\n\n    return ans\n", "tests": [{"start": 19, "end": 20, "test": "def test_minDifference():\n    solution = Solution()\n    nums = [3, 3, 3, 3]\n    queries = [[0, 3]]\n    assert solution.minDifference(nums, queries) == [-1]"}, {"start": 30, "end": 31, "test": "def test_minDifference():\n    solution = Solution()\n    nums = [1, 2, 3, 4, 5]\n    queries = [[0, 4], [1, 3]]\n    expected = [-1, 1]\n    assert solution.minDifference(nums, queries) == expected"}, {"start": 32, "end": 33, "test": "def test_minDifference():\n    solution = Solution()\n    nums = [5, 2, 3, 7, 2]\n    queries = [[1, 4]]\n    expected = [1]\n    assert solution.minDifference(nums, queries) == expected"}]}
{"task_num": 1923, "task_title": "Longest Common Subpath", "func_name": "longestCommonSubpath", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Set\n\nclass Solution:\n  def __init__(self):\n    self.kMod = 8_417_508_174_513\n    self.kBase = 165_131\n\n  def longestCommonSubpath(self, n: int, paths: List[List[int]]) -> int:\n    l = 0\n    r = len(paths[0])\n\n    while l < r:\n      m = l + (r - l + 1) // 2\n      if self._checkCommonSubpath(paths, m):\n        l = m\n      else:\n        r = m - 1\n\n    return l\n\n  def _checkCommonSubpath(self, paths: List[List[int]], m: int) -> bool:\n    hashSets = [self._rabinKarp(path, m) for path in paths]\n\n    for subpathHash in hashSets[0]:\n      if all(subpathHash in hashSet for hashSet in hashSets):\n        return True\n\n    return False\n\n  def _rabinKarp(self, path: List[int], m: int) -> Set[int]:\n    hashes = set()\n    maxPower = 1\n    hash = 0\n\n    for i, num in enumerate(path):\n      hash = (hash * self.kBase + num) % self.kMod\n      if i >= m:\n        hash = (hash - path[i - m] * maxPower % self.kMod + self.kMod) % self.kMod\n      else:\n        maxPower = maxPower * self.kBase % self.kMod\n      if i >= m - 1:\n        hashes.add(hash)\n\n    return hashes\n", "tests": [{"start": 22, "end": 23, "test": "def test_longestCommonSubpath():\n    solution = Solution()\n    assert solution.longestCommonSubpath(5, [[1, 2], [1, 3]]) == 0"}, {"start": 24, "end": 25, "test": "def test_longestCommonSubpath():\n    solution = Solution()\n    assert solution.longestCommonSubpath(3, [[0, 1], [1, 2], [2, 0]]) == 0"}, {"start": 33, "end": 34, "test": "def test_longestCommonSubpath():\n    solution = Solution()\n    n = 5\n    paths = [[1, 2, 3], [2, 3, 4], [3, 4, 5]]\n    assert solution.longestCommonSubpath(n, paths) == 2"}, {"start": 45, "end": 46, "test": "def test_longestCommonSubpath():\n    solution = Solution()\n    assert solution.longestCommonSubpath(3, [[1, 2], [2, 3], [1, 2]]) == 1"}, {"start": 47, "end": 48, "test": "def test_longestCommonSubpath():\n    solution = Solution()\n    assert solution.longestCommonSubpath(3, [[1, 2], [1, 2, 3], [1, 2]]) == 2"}, {"start": 49, "end": 50, "test": "def test_longestCommonSubpath():\n    solution = Solution()\n    assert solution.longestCommonSubpath(3, [[1, 2], [1, 2, 3], [1, 2]]) == 2"}]}
{"task_num": 1926, "task_title": "Nearest Exit from Entrance in Maze", "func_name": "nearestExit", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def nearestExit(self, maze: List[List[str]], entrance: List[int]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(maze)\n    n = len(maze[0])\n    ans = 0\n    q = collections.deque([(entrance[0], entrance[1])])\n    seen = {(entrance[0], entrance[1])}\n\n    while q:\n      ans += 1\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if (x, y) in seen or maze[x][y] == '+':\n            continue\n          if x == 0 or x == m - 1 or y == 0 or y == n - 1:\n            return ans\n          q.append((x, y))\n          seen.add((x, y))\n\n    return -1\n", "tests": [{"start": 27, "end": 28, "test": "def test_nearestExit():\n    solution = Solution()\n    assert solution.nearestExit([['+', '+', '.', '+'], ['.', '.', '.', '+'], ['+', '+', '+', '.']], [1, 2]) == 3"}, {"start": 29, "end": 30, "test": "def test_nearestExit():\n    solution = Solution()\n    assert solution.nearestExit([['+', '.', '+'], ['.', '.', '.'], ['+', '+', '.']], [1, 2]) == -1"}, {"start": 31, "end": 32, "test": "def test_nearestExit():\n    solution = Solution()\n    assert solution.nearestExit([['+', '.', '.'], ['.', '.', '.'], ['.', '.', 'e']], [1, 2]) == 1"}]}
{"task_num": 1928, "task_title": "Minimum Cost to Reach Destination in Time", "func_name": "minCost", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\n    n = len(passingFees)\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, 0, n - 1, maxTime, passingFees)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, maxTime: int, passingFees: List[int]) -> int:\n    cost = [math.inf for _ in range(len(graph))]\n    dist = [maxTime + 1 for _ in range(len(graph))]\n\n    cost[src] = passingFees[src]\n    dist[src] = 0\n    minHeap = [(cost[src], dist[src], src)]\n\n    while minHeap:\n      currCost, d, u = heapq.heappop(minHeap)\n      if u == dst:\n        return cost[dst]\n      if d > dist[u] and currCost > cost[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w > maxTime:\n          continue\n        if currCost + passingFees[v] < cost[v]:\n          cost[v] = currCost + passingFees[v]\n          dist[v] = d + w\n          heapq.heappush(minHeap, (cost[v], dist[v], v))\n        elif d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (currCost + passingFees[v], dist[v], v))\n\n    return -1\n", "tests": [{"start": 32, "end": 33, "test": "def test_minCost():\n    solution = Solution()\n    maxTime = 10\n    edges = [[0, 1, 5], [1, 2, 3], [2, 3, 2]]\n    passingFees = [0, 1, 2, 3]\n    assert solution.minCost(maxTime, edges, passingFees) == 6"}, {"start": 34, "end": 35, "test": "def test_minCost():\n    solution = Solution()\n    maxTime = 10\n    edges = [[0, 1, 2], [1, 2, 3], [2, 3, 4]]\n    passingFees = [0, 1, 2, 3]\n    assert solution.minCost(maxTime, edges, passingFees) == -1"}, {"start": 37, "end": 38, "test": "def test_minCost():\n    solution = Solution()\n    assert solution.minCost(5, [[0, 1, 10], [1, 2, 10], [2, 3, 10]], [0, 1, 2, 10]) == -1"}, {"start": 39, "end": 42, "test": "def test_minCost():\n    solution = Solution()\n    assert solution.minCost(30, [[0, 1, 10], [1, 2, 10], [2, 3, 10]], [0, 1, 2, 1]) == 6"}, {"start": 43, "end": 45, "test": "def test_minCost():\n    solution = Solution()\n    assert solution.minCost(30, [[0, 1, 10], [1, 2, 10], [2, 3, 10]], [0, 1, 2, 1]) == -1"}]}
{"task_num": 1938, "task_title": "Maximum Genetic Difference Query", "func_name": "maxGeneticDifference", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass TrieNode:\n  def __init__(self):\n    self.children = [None] * 2\n    self.count = 0\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n    self.kHeight = 17\n\n  def update(self, num: int, val: int) -> None:\n    node = self.root\n    for i in range(self.kHeight, -1, -1):\n      bit = (num >> i) & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n      node.count += val\n\n  def query(self, num: int) -> int:\n    ans = 0\n    node = self.root\n    for i in range(self.kHeight, -1, -1):\n      bit = (num >> i) & 1\n      targetBit = bit ^ 1\n      if node.children[targetBit] and node.children[targetBit].count > 0:\n        ans += 1 << i\n        node = node.children[targetBit]\n      else:\n        node = node.children[targetBit ^ 1]\n    return ans\n\n\nclass Solution:\n  def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\n    n = len(parents)\n    ans = [0] * len(queries)\n    rootVal = -1\n    tree = [[] for _ in range(n)]\n    nodeToQueries = collections.defaultdict(list)\n    trie = Trie()\n\n    for i, parent in enumerate(parents):\n      if parent == -1:\n        rootVal = i\n      else:\n        tree[parent].append(i)\n\n    for i, (node, val) in enumerate(queries):\n      nodeToQueries[node].append((i, val))\n\n    def dfs(node: int) -> None:\n      trie.update(node, 1)\n\n      for i, val in nodeToQueries[node]:\n        ans[i] = trie.query(val)\n\n      for child in tree[node]:\n        dfs(child)\n\n      trie.update(node, -1)\n\n    dfs(rootVal)\n    return ans\n", "tests": [{"start": 26, "end": 27, "test": "def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [-1, 0, 1]\n    queries = [[2, 3]]\n    expected = [3]\n    assert solution.maxGeneticDifference(parents, queries) == expected"}, {"start": 37, "end": 39, "test": "def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [-1, 0, 1, 2, 3]\n    queries = [[1, 5], [2, 7], [4, 8]]\n    expected = [6, 7, 7]\n    assert solution.maxGeneticDifference(parents, queries) == expected"}, {"start": 40, "end": 41, "test": "def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [-1, 0, 1, 2, 3]\n    queries = [[1, 5], [2, 7], [4, 9]]\n    expected = [6, 7, 8]\n    assert solution.maxGeneticDifference(parents, queries) == expected"}, {"start": 55, "end": 56, "test": "def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [-1, 0]\n    queries = [[0, 5], [1, 3]]\n    expected = [4, 6]\n    assert solution.maxGeneticDifference(parents, queries) == expected"}, {"start": 57, "end": 58, "test": "def test_maxGeneticDifference():\n    solution = Solution()\n    parents = [-1, 0, 1]\n    queries = [[2, 3]]\n    expected = [3]\n    assert solution.maxGeneticDifference(parents, queries) == expected"}]}
{"task_num": 1971, "task_title": "Find if Path Exists in Graph", "func_name": "validPath", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def validPath(self, n: int, edges: List[List[int]], source: int, destination: int) -> bool:\n    uf = UnionFind(n)\n\n    for u, v in edges:\n      uf.unionByRank(u, v)\n\n    return uf.find(source) == uf.find(destination)\n", "tests": [{"start": 19, "end": 20, "test": "def test_validPath():\n    solution = Solution()\n    assert solution.validPath(3, [[0, 1], [1, 2]], 0, 2) == True"}, {"start": 21, "end": 22, "test": "def test_validPath():\n    solution = Solution()\n    assert solution.validPath(3, [[0, 1], [1, 2]], 0, 2) == True"}, {"start": 30, "end": 31, "test": "def test_validPath():\n    solution = Solution()\n    assert solution.validPath(5, [[0, 1], [2, 3], [4, 2]], 0, 4) == False"}, {"start": 23, "end": 24, "test": "def test_validPath():\n    solution = Solution()\n    assert solution.validPath(3, [[0, 1], [1, 2]], 0, 2) == True"}, {"start": 25, "end": 27, "test": "def test_validPath():\n    solution = Solution()\n    assert solution.validPath(3, [[0, 1], [1, 2]], 0, 2) == True"}]}
{"task_num": 1976, "task_title": "Number of Ways to Arrive at Destination", "func_name": "countPaths", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countPaths(self, n: int, roads: List[List[int]]) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in roads:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, 0, n - 1)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int) -> int:\n    kMod = 10**9 + 7\n    ways = [0] * len(graph)\n    dist = [math.inf] * len(graph)\n\n    ways[src] = 1\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          ways[v] = ways[u]\n          heapq.heappush(minHeap, (dist[v], v))\n        elif d + w == dist[v]:\n          ways[v] += ways[u]\n          ways[v] %= kMod\n\n    return ways[dst]\n", "tests": [{"start": 32, "end": 33, "test": "def test_countPaths():\n    solution = Solution()\n    assert solution.countPaths(4, [[0, 1, 2], [1, 2, 3], [2, 3, 1]]) == 2"}, {"start": 35, "end": 38, "test": "def test_countPaths():\n    solution = Solution()\n    assert solution.countPaths(4, [[0, 1, 1], [1, 2, 2], [2, 3, 1]]) == 2"}, {"start": 39, "end": 41, "test": "def test_countPaths():\n    solution = Solution()\n    assert solution.countPaths(3, [[0, 1, 1], [1, 2, 1]]) == 2"}]}
{"task_num": 1977, "task_title": "Number of Ways to Separate Numbers", "func_name": "numberOfCombinations", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numberOfCombinations(self, num: str) -> int:\n    if num[0] == '0':\n      return 0\n\n    kMod = 1_000_000_007\n    n = len(num)\n    dp = [[0] * (n + 1) for _ in range(n)]\n    lcs = [[0] * (n + 1) for _ in range(n + 1)]\n\n    for i in range(n - 1, -1, -1):\n      for j in range(i + 1, n):\n        if num[i] == num[j]:\n          lcs[i][j] = lcs[i + 1][j + 1] + 1\n\n    for i in range(n):\n      for k in range(1, i + 2):\n        dp[i][k] += dp[i][k - 1]\n        dp[i][k] %= kMod\n        s = i - k + 1\n        if num[s] == '0':\n          continue\n        if s == 0:\n          dp[i][k] += 1\n          continue\n        if s < k:\n          dp[i][k] += dp[s - 1][s]\n          continue\n        l = lcs[s - k][s]\n        if l >= k or num[s - k + l] <= num[s + l]:\n          dp[i][k] += dp[s - 1][k]\n        else:\n          dp[i][k] += dp[s - 1][k - 1]\n\n    return dp[n - 1][n] % kMod\n", "tests": [{"start": 13, "end": 14, "test": "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('0') == 0"}, {"start": 23, "end": 24, "test": "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('123') == 6"}, {"start": 31, "end": 32, "test": "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('01') == 0"}, {"start": 33, "end": 35, "test": "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('0') == 0"}, {"start": 36, "end": 38, "test": "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('102') == 2"}, {"start": 40, "end": 41, "test": "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('12345') == 1"}, {"start": 42, "end": 43, "test": "def test_numberOfCombinations():\n    solution = Solution()\n    assert solution.numberOfCombinations('101') == 2"}]}
{"task_num": 1994, "task_title": "The Number of Good Subsets", "func_name": "numberOfGoodSubsets", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numberOfGoodSubsets(self, nums: List[int]) -> int:\n    kMod = 1_000_000_007\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n    n = 1 << len(primes)\n    dp = [1] + [0] * (n - 1)\n    count = collections.Counter(nums)\n\n    for num, freq in count.items():\n      if num == 1:\n        continue\n      if any(num % squared == 0 for squared in [4, 9, 25]):\n        continue\n      numPrimesMask = 0\n      for i, prime in enumerate(primes):\n        if num % prime == 0:\n          numPrimesMask += 1 << i\n      for primesMask in range(n):\n        if primesMask & numPrimesMask > 0:\n          continue\n        nextPrimesMask = numPrimesMask | primesMask\n        dp[nextPrimesMask] += dp[primesMask] * freq\n        dp[nextPrimesMask] %= kMod\n\n    return (1 << count[1]) * sum(dp[1:]) % kMod\n", "tests": [{"start": 20, "end": 21, "test": "def test_numberOfGoodSubsets():\n    solution = Solution()\n    assert solution.numberOfGoodSubsets([1, 2, 3, 4]) == 6"}, {"start": 22, "end": 23, "test": "def test_numberOfGoodSubsets():\n    solution = Solution()\n    assert solution.numberOfGoodSubsets([1, 4]) == 0"}, {"start": 26, "end": 27, "test": "def test_numberOfGoodSubsets():\n    solution = Solution()\n    assert solution.numberOfGoodSubsets([1, 2, 3, 4]) == 6"}, {"start": 29, "end": 30, "test": "def test_numberOfGoodSubsets():\n    solution = Solution()\n    assert solution.numberOfGoodSubsets([1, 2, 4]) == 3"}]}
{"task_num": 1998, "task_title": "GCD Sort of an Array", "func_name": "gcdSort", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def gcdSort(self, nums: List[int]) -> bool:\n    maxNum = max(nums)\n    minPrimeFactors = self._sieveEratosthenes(maxNum + 1)\n    uf = UnionFind(maxNum + 1)\n\n    for num in nums:\n      for primeFactor in self._getPrimeFactors(num, minPrimeFactors):\n        uf.unionByRank(num, primeFactor)\n\n    for a, b in zip(nums, sorted(nums)):\n      if uf.find(a) != uf.find(b):\n        return False\n\n    return True\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeFactors(self, num: int, minPrimeFactors: List[int]) -> List[int]:\n    primeFactors = []\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      primeFactors.append(divisor)\n      while num % divisor == 0:\n        num //= divisor\n    return primeFactors\n", "tests": [{"start": 19, "end": 20, "test": "def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([4, 2, 3, 8]) == True"}, {"start": 21, "end": 22, "test": "def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([8, 4, 2]) == True"}, {"start": 31, "end": 32, "test": "def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([4, 2, 3, 8]) == True"}, {"start": 23, "end": 24, "test": "def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([8, 10]) == True"}, {"start": 25, "end": 27, "test": "def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([8, 4, 2]) == True"}, {"start": 47, "end": 48, "test": "def test_gcdSort():\n    solution = Solution()\n    assert not solution.gcdSort([12, 6, 3])"}, {"start": 55, "end": 57, "test": "def test_gcdSort():\n    solution = Solution()\n    assert solution.gcdSort([10, 25, 5]) == True"}]}
{"task_num": 2019, "task_title": "The Score of Students Solving Math Expression", "func_name": "scoreOfStudents", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nimport operator\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def scoreOfStudents(self, s: str, answers: List[int]) -> int:\n    n = len(s) // 2 + 1\n    ans = 0\n    func = {'+': operator.add, '*': operator.mul}\n    dp = [[set() for j in range(n)] for _ in range(n)]\n\n    for i in range(n):\n      dp[i][i].add(int(s[i * 2]))\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        for k in range(i, j):\n          op = s[k * 2 + 1]\n          for a in dp[i][k]:\n            for b in dp[k + 1][j]:\n              res = func[op](a, b)\n              if res <= 1000:\n                dp[i][j].add(res)\n\n    correctAnswer = eval(s)\n\n    for answer, freq in collections.Counter(answers).items():\n      if answer == correctAnswer:\n        ans += 5 * freq\n      elif answer in dp[0][n - 1]:\n        ans += 2 * freq\n\n    return ans\n", "tests": [{"start": 36, "end": 37, "test": "def test_scoreOfStudents():\n    solution = Solution()\n    assert solution.scoreOfStudents('1+2*3', [6, 9, 8]) == 5"}, {"start": 38, "end": 39, "test": "def test_scoreOfStudents():\n    solution = Solution()\n    assert solution.scoreOfStudents('3+5*2', [10, 16, 14, 8]) == 7"}, {"start": 30, "end": 31, "test": "def test_scoreOfStudents():\n    solution = Solution()\n    assert solution.scoreOfStudents('3+5*2', [10, 15, 7]) == 7"}]}
{"task_num": 2030, "task_title": "Smallest K-Length Subsequence With Occurrences of a Letter", "func_name": "smallestSubsequence", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\n    stack = []\n    required = repetition\n    nLetters = s.count(letter)\n\n    for i, c in enumerate(s):\n      while stack and stack[-1] > c  and len(stack) + len(s) - i - 1 >= k and (stack[-1] != letter or nLetters > required):\n        if stack.pop() == letter:\n          required += 1\n      if len(stack) < k:\n        if c == letter:\n          stack.append(c)\n          required -= 1\n        elif k - len(stack) > required:\n          stack.append(c)\n      if c == letter:\n        nLetters -= 1\n\n    return ''.join(stack)\n", "tests": [{"start": 21, "end": 26, "test": "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('aabbcc', 4, 'b', 1) == 'abbc'"}, {"start": 27, "end": 28, "test": "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('aaabbbcc', 6, 'a', 2) == 'aabbbb'"}, {"start": 19, "end": 20, "test": "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('aabbcc', 5, 'b', 2) == 'aabbc'"}, {"start": 22, "end": 24, "test": "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('aaabbbcc', 6, 'a', 2) == 'aabbbb'"}, {"start": 25, "end": 26, "test": "def test_smallestSubsequence():\n    solution = Solution()\n    assert solution.smallestSubsequence('aabbcc', 5, 'b', 2) == 'aabbc'"}]}
{"task_num": 2040, "task_title": "Kth Smallest Product of Two Sorted Arrays", "func_name": "kthSmallestProduct", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int) -> int:\n    A1 = [-num for num in nums1 if num < 0][::-1]\n    A2 = [num for num in nums1 if num >= 0]\n    B1 = [-num for num in nums2 if num < 0][::-1]\n    B2 = [num for num in nums2 if num >= 0]\n\n    negCount = len(A1) * len(B2) + len(A2) * len(B1)\n\n    if k > negCount:\n      k -= negCount\n      sign = 1\n    else:\n      k = negCount - k + 1\n      sign = -1\n      B1, B2 = B2, B1\n\n    def numProductNoGreaterThan(A: List[int], B: List[int], m: int) -> int:\n      ans = 0\n      j = len(B) - 1\n      for i in range(len(A)):\n        while j >= 0 and A[i] * B[j] > m:\n          j -= 1\n        ans += j + 1\n      return ans\n\n    l = 0\n    r = 10**10\n\n    while l < r:\n      m = (l + r) // 2\n      if numProductNoGreaterThan(A1, B1, m) + numProductNoGreaterThan(A2, B2, m) >= k:\n        r = m\n      else:\n        l = m + 1\n\n    return sign * l\n", "tests": [{"start": 20, "end": 22, "test": "def test_kthSmallestProduct():\n    solution = Solution()\n    assert solution.kthSmallestProduct([-5, -4], [2, 3], 1) == -30"}, {"start": 23, "end": 26, "test": "def test_kthSmallestProduct():\n    solution = Solution()\n    assert solution.kthSmallestProduct([-5, -4], [3, 2], 1) == 20"}, {"start": 42, "end": 43, "test": "def test_kthSmallestProduct():\n    solution = Solution()\n    assert solution.kthSmallestProduct([-1, -2], [-3, -4], 5) == 6"}, {"start": 44, "end": 45, "test": "def test_kthSmallestProduct():\n    solution = Solution()\n    assert solution.kthSmallestProduct([-2, -1], [3, 4], 5) == -6"}]}
{"task_num": 2045, "task_title": "Second Minimum Time to Reach Destination", "func_name": "secondMinimum", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\n    graph = [[] for _ in range(n + 1)]\n    q = collections.deque([(1, 0)])\n    minTime = [[math.inf] * 2 for _ in range(n + 1)]\n    minTime[1][0] = 0\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    while q:\n      i, prevTime = q.popleft()\n\n      numChangeSignal = prevTime // change\n      waitTime = change - (prevTime % change) if numChangeSignal & 1 else 0\n      newTime = prevTime + waitTime + time\n      for j in graph[i]:\n        if newTime < minTime[j][0]:\n          minTime[j][0] = newTime\n          q.append((j, newTime))\n        elif minTime[j][0] < newTime < minTime[j][1]:\n          if j == n:\n            return newTime\n          minTime[j][1] = newTime\n          q.append((j, newTime))\n", "tests": [{"start": 29, "end": 31, "test": "def test_secondMinimum():\n    solution = Solution()\n    assert solution.secondMinimum(5, [[1, 2], [1, 3], [2, 4], [2, 5]], 3, 5) == 16"}, {"start": 32, "end": 36, "test": "def test_secondMinimum():\n    solution = Solution()\n    assert solution.secondMinimum(5, [[1, 2], [1, 3], [2, 4], [2, 5]], 3, 5) == 17"}, {"start": 33, "end": 34, "test": "def test_secondMinimum():\n    solution = Solution()\n    assert solution.secondMinimum(5, [[1, 2], [1, 3], [2, 4], [2, 5]], 3, 5) == 16"}]}
{"task_num": 2059, "task_title": "Minimum Operations to Convert Number", "func_name": "minimumOperations", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\n    ans = 0\n    q = collections.deque([start])\n    seen = {start}\n\n    while q:\n      ans += 1\n      for _ in range(len(q)):\n        x = q.popleft()\n        for num in nums:\n          for res in (x + num, x - num, x ^ num):\n            if res == goal:\n              return ans\n            if res < 0 or res > 1000 or res in seen:\n              continue\n            seen.add(res)\n            q.append(res)\n\n    return -1\n", "tests": [{"start": 23, "end": 24, "test": "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations([1, 2, 3], 5, 7) == 1"}, {"start": 25, "end": 26, "test": "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations([1, 2, 3], 5, 8) == -1"}]}
{"task_num": 2076, "task_title": "Process Restricted Friend Requests", "func_name": "friendRequests", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\n    ans = []\n    uf = UnionFind(n)\n\n    for u, v in requests:\n      pu = uf.find(u)\n      pv = uf.find(v)\n      isValid = True\n      if pu != pv:\n        for x, y in restrictions:\n          px = uf.find(x)\n          py = uf.find(y)\n          if (pu, pv) in [(px, py), (py, px)]:\n            isValid = False\n            break\n      ans.append(isValid)\n      if isValid:\n        uf.unionByRank(pu, pv)\n\n    return ans\n", "tests": [{"start": 19, "end": 20, "test": "def test_friendRequests():\n    solution = Solution()\n    result = solution.friendRequests(3, [[0, 1]], [[0, 1], [1, 2]])"}, {"start": 21, "end": 22, "test": "def test_friendRequests():\n    solution = Solution()\n    n = 3\n    restrictions = [[0, 1]]\n    requests = [[0, 2], [1, 2]]\n    expected = [True, False]\n    assert solution.friendRequests(n, restrictions, requests) == expected"}, {"start": 30, "end": 31, "test": "def test_friendRequests():\n    solution = Solution()\n    n = 5\n    restrictions = [[0, 2], [1, 3]]\n    requests = [[0, 1], [1, 2], [2, 3], [3, 4]]\n    expected = [True, False, True, True]\n    assert solution.friendRequests(n, restrictions, requests) == expected"}, {"start": 23, "end": 24, "test": "def test_friendRequests():\n    solution = Solution()\n    n = 5\n    restrictions = [[0, 1], [1, 2]]\n    requests = [[0, 2], [2, 3], [3, 4]]\n    expected = [False, True, False]\n    assert solution.friendRequests(n, restrictions, requests) == expected"}, {"start": 25, "end": 27, "test": "def test_friendRequests():\n    solution = Solution()\n    n = 4\n    restrictions = [[0, 1], [1, 2]]\n    requests = [[0, 2], [0, 3], [1, 3]]\n    expected = [False, True, False]\n    assert solution.friendRequests(n, restrictions, requests) == expected"}, {"start": 44, "end": 50, "test": "def test_friendRequests():\n    solution = Solution()\n    assert solution.friendRequests(3, [[0, 1]], [[0, 2], [1, 2]]) == [True, False]"}, {"start": 52, "end": 53, "test": "def test_friendRequests():\n    solution = Solution()\n    n = 4\n    restrictions = [[0, 1], [2, 3]]\n    requests = [[0, 2], [1, 3], [0, 3]]\n    expected = [True, True, False]\n    assert solution.friendRequests(n, restrictions, requests) == expected"}, {"start": 48, "end": 50, "test": "def test_friendRequests():\n    solution = Solution()\n    n = 3\n    restrictions = [[0, 1]]\n    requests = [[0, 2], [1, 2]]\n    expected = [True, False]\n    assert solution.friendRequests(n, restrictions, requests) == expected"}]}
{"task_num": 2086, "task_title": "Minimum Number of Food Buckets to Feed the Hamsters", "func_name": "minimumBuckets", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumBuckets(self, street: str) -> int:\n    A = list(street)\n\n    for i, c in enumerate(A):\n      if c == 'H':\n        if i > 0 and A[i - 1] == 'B':\n          continue\n        if i + 1 < len(A) and A[i + 1] == '.':\n          A[i + 1] = 'B'\n        elif i > 0 and A[i - 1] == '.':\n          A[i - 1] = 'B'\n        else:\n          return -1\n\n    return A.count('B')\n", "tests": [{"start": 16, "end": 24, "test": "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('H.H') == 2"}, {"start": 17, "end": 18, "test": "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('H.H') == 2"}, {"start": 19, "end": 20, "test": "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('H.H') == 2"}, {"start": 21, "end": 22, "test": "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('H.H') == 2"}, {"start": 23, "end": 24, "test": "def test_minimumBuckets():\n    solution = Solution()\n    assert solution.minimumBuckets('H.H') == -1"}]}
{"task_num": 2092, "task_title": "Find All People With Secret", "func_name": "findAllPeople", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def connected(self, u: int, v: int) -> bool:\n    return self._find(self.id[u]) == self._find(self.id[v])\n\n  def reset(self, u: int) -> None:\n    self.id[u] = u\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\n    uf = UnionFind(n)\n    timeToPairs = collections.defaultdict(list)\n\n    uf.unionByRank(0, firstPerson)\n\n    for x, y, time in meetings:\n      timeToPairs[time].append((x, y))\n\n    for _, pairs in sorted(timeToPairs.items(), key=lambda x: x[0]):\n      peopleUnioned = set()\n      for x, y in pairs:\n        uf.unionByRank(x, y)\n        peopleUnioned.add(x)\n        peopleUnioned.add(y)\n      for person in peopleUnioned:\n        if not uf.connected(person, 0):\n          uf.reset(person)\n\n    res=[]\n    for i in range(n):\n      if uf.connected(i, 0):\n        res.append(i)\n    return res\n", "tests": [{"start": 19, "end": 20, "test": "def test_findAllPeople():\n    solution = Solution()\n    n = 5\n    meetings = [[1, 2, 0], [2, 3, 0], [3, 4, 0]]\n    firstPerson = 1\n    expected = [0, 1, 2, 3, 4]\n    assert solution.findAllPeople(n, meetings, firstPerson) == expected"}, {"start": 21, "end": 22, "test": "def test_findAllPeople():\n    solution = Solution()\n    n = 5\n    meetings = [[0, 1, 1], [1, 2, 2], [3, 4, 3]]\n    firstPerson = 1\n    expected = [0, 1]\n    assert sorted(solution.findAllPeople(n, meetings, firstPerson)) == expected"}, {"start": 36, "end": 37, "test": "def test_findAllPeople():\n    solution = Solution()\n    n = 5\n    meetings = [[0, 1, 2], [1, 2, 3]]\n    firstPerson = 1\n    expected = [0, 1, 2]\n    assert sorted(solution.findAllPeople(n, meetings, firstPerson)) == expected"}, {"start": 23, "end": 24, "test": "def test_findAllPeople():\n    solution = Solution()\n    n = 5\n    meetings = [[0, 1, 2], [1, 2, 3]]\n    firstPerson = 1\n    expected = [0, 1]\n    assert sorted(solution.findAllPeople(n, meetings, firstPerson)) == expected"}, {"start": 25, "end": 27, "test": "def test_findAllPeople():\n    solution = Solution()\n    n = 5\n    meetings = [[0, 1, 2], [1, 2, 3]]\n    firstPerson = 1\n    expected = [0, 1, 2]\n    assert sorted(solution.findAllPeople(n, meetings, firstPerson)) == expected"}, {"start": 63, "end": 64, "test": "def test_findAllPeople():\n    solution = Solution()\n    n = 5\n    meetings = [[1, 2, 5], [1, 3, 6]]\n    firstPerson = 1\n    expected = [0, 1]\n    assert sorted(solution.findAllPeople(n, meetings, firstPerson)) == expected"}, {"start": 58, "end": 59, "test": "def test_findAllPeople():\n    solution = Solution()\n    n = 6\n    meetings = [[1, 2, 5], [1, 3, 6]]\n    firstPerson = 1\n    expected = [0, 1, 2]\n    assert sorted(solution.findAllPeople(n, meetings, firstPerson)) == expected"}]}
{"task_num": 2115, "task_title": "Find All Possible Recipes from Given Supplies", "func_name": "findAllRecipes", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n    ans = []\n    supplies = set(supplies)\n    graph = collections.defaultdict(list)\n    inDegrees = collections.Counter()\n    q = collections.deque()\n\n    for i, recipe in enumerate(recipes):\n      for ingredient in ingredients[i]:\n        if ingredient not in supplies:\n          graph[ingredient].append(recipe)\n          inDegrees[recipe] += 1\n\n    for recipe in recipes:\n      if inDegrees[recipe] == 0:\n        q.append(recipe)\n\n    while q:\n      u = q.popleft()\n      ans.append(u)\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    return ans\n", "tests": [{"start": 26, "end": 27, "test": "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['bread', 'sandwich']\n    ingredients = [['yeast', 'flour'], ['bread']]\n    supplies = ['yeast', 'flour', 'meat']\n    assert solution.findAllRecipes(recipes, ingredients, supplies) == ['bread', 'sandwich']"}, {"start": 21, "end": 23, "test": "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['bread', 'sandwich']\n    ingredients = [['yeast', 'flour'], ['bread']]\n    supplies = ['yeast', 'flour', 'meat']\n    assert solution.findAllRecipes(recipes, ingredients, supplies) == ['bread', 'sandwich']"}, {"start": 34, "end": 35, "test": "def test_findAllRecipes():\n    solution = Solution()\n    recipes = ['bread', 'sandwich']\n    ingredients = [['yeast', 'flour'], ['bread']]\n    supplies = ['yeast', 'flour', 'meat']\n    assert solution.findAllRecipes(recipes, ingredients, supplies) == ['bread', 'sandwich']"}]}
{"task_num": 2127, "task_title": "Maximum Employees to Be Invited to a Meeting", "func_name": "maximumInvitations", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import Enum\n\n\nclass State(Enum):\n  kInit = 0\n  kVisiting = 1\n  kVisited = 2\n\n\nclass Solution:\n  def maximumInvitations(self, favorite: List[int]) -> int:\n    n = len(favorite)\n    sumComponentsLength = 0\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n    maxChainLength = [1] * n\n\n    for i, f in enumerate(favorite):\n      graph[i].append(f)\n      inDegrees[f] += 1\n\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n\n    while q:\n      u = q.popleft()\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n        maxChainLength[v] = max(maxChainLength[v], 1 + maxChainLength[u])\n\n    for i in range(n):\n      if favorite[favorite[i]] == i:\n        sumComponentsLength += maxChainLength[i] + maxChainLength[favorite[i]]\n\n    maxCycleLength = 0\n    parent = [-1] * n\n    seen = set()\n    states = [State.kInit] * n\n\n    def findCycle(u: int) -> None:\n      nonlocal maxCycleLength\n      seen.add(u)\n      states[u] = State.kVisiting\n      for v in graph[u]:\n        if v not in seen:\n          parent[v] = u\n          findCycle(v)\n        elif states[v] == State.kVisiting:\n          curr = u\n          cycleLength = 1\n          while curr != v:\n            curr = parent[curr]\n            cycleLength += 1\n          maxCycleLength = max(maxCycleLength, cycleLength)\n      states[u] = State.kVisited\n\n    for i in range(n):\n      if i not in seen:\n        findCycle(i)\n\n    return max(sumComponentsLength // 2, maxCycleLength)\n", "tests": [{"start": 43, "end": 44, "test": "def test_maximumInvitations():\n    solution = Solution()\n    assert solution.maximumInvitations([3, 0, 1, 4, 1]) == 5"}, {"start": 69, "end": 70, "test": "def test_maximumInvitations():\n    solution = Solution()\n    assert solution.maximumInvitations([3, 0, 1, 4, 1]) == 5"}, {"start": 38, "end": 39, "test": "def test_maximumInvitations():\n    solution = Solution()\n    assert solution.maximumInvitations([1, 2, 3, 0]) == 4"}, {"start": 56, "end": 58, "test": "def test_maximumInvitations():\n    solution = Solution()\n    favorite = [1, 2, 3, 0]\n    assert solution.maximumInvitations(favorite) == 4"}, {"start": 59, "end": 65, "test": "def test_maximumInvitations():\n    solution = Solution()\n    favorite = [3, 0, 1, 4, 1]\n    assert solution.maximumInvitations(favorite) == 5"}]}
{"task_num": 2132, "task_title": "Stamping the Grid", "func_name": "possibleToStamp", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def possibleToStamp(self, grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:\n    m = len(grid)\n    n = len(grid[0])\n    A = [[0] * (n + 1) for _ in range(m + 1)]\n    B = [[0] * (n + 1) for _ in range(m + 1)]\n    fit = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        A[i + 1][j + 1] = A[i + 1][j] + A[i][j + 1] - A[i][j] + grid[i][j]\n        if i + 1 >= stampHeight and j + 1 >= stampWidth:\n          x = i - stampHeight + 1\n          y = j - stampWidth + 1\n          if A[i + 1][j + 1] - A[x][j + 1] - A[i + 1][y] + A[x][y] == 0:\n            fit[i][j] = True\n\n    for i in range(m):\n      for j in range(n):\n        B[i + 1][j + 1] = B[i + 1][j] + B[i][j + 1] - B[i][j] + fit[i][j]\n\n    for i in range(m):\n      for j in range(n):\n        if not grid[i][j]:\n          x = min(i + stampHeight, m)\n          y = min(j + stampWidth, n)\n          if B[x][y] - B[i][y] - B[x][j] + B[i][j] == 0:\n            return False\n\n    return True\n", "tests": [{"start": 22, "end": 26, "test": "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[1, 0, 0], [0, 0, 0], [0, 0, 1]]\n    stampHeight = 2\n    stampWidth = 2\n    assert not solution.possibleToStamp(grid, stampHeight, stampWidth)"}, {"start": 34, "end": 38, "test": "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[1, 0, 0], [0, 0, 0], [0, 0, 1]]\n    stampHeight = 2\n    stampWidth = 2\n    assert not solution.possibleToStamp(grid, stampHeight, stampWidth)"}, {"start": 25, "end": 26, "test": "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[1, 0, 0], [0, 0, 0], [0, 0, 1]]\n    stampHeight = 2\n    stampWidth = 2\n    assert not solution.possibleToStamp(grid, stampHeight, stampWidth)"}, {"start": 37, "end": 38, "test": "def test_possibleToStamp():\n    solution = Solution()\n    grid = [[1, 0, 0], [0, 0, 0], [0, 0, 1]]\n    stampHeight = 2\n    stampWidth = 2\n    assert not solution.possibleToStamp(grid, stampHeight, stampWidth)"}]}
{"task_num": 2146, "task_title": "K Highest Ranked Items Within a Price Range", "func_name": "highestRankedKItems", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    low, high = pricing\n    row, col = start\n    ans = []\n\n    if low <= grid[row][col] <= high:\n      ans.append([row, col])\n      if k == 1:\n        return ans\n\n    q = collections.deque([(row, col)])\n    seen = {(row, col)}\n\n    while q:\n      neighbors = []\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for t in range(4):\n          x = i + dirs[t][0]\n          y = j + dirs[t][1]\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if not grid[x][y] or (x, y) in seen:\n            continue\n          if low <= grid[x][y] <= high:\n            neighbors.append([x, y])\n          q.append((x, y))\n          seen.add((x, y))\n      neighbors.sort(key=lambda x: (grid[x[0]][x[1]], x[0], x[1]))\n      for neighbor in neighbors:\n        if len(ans) < k:\n          ans.append(neighbor)\n        if len(ans) == k:\n          return ans\n\n    return ans\n", "tests": [{"start": 20, "end": 23, "test": "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    pricing = [2, 5]\n    start = [0, 0]\n    k = 1\n    expected = [[0, 0]]\n    assert solution.highestRankedKItems(grid, pricing, start, k) == expected"}, {"start": 22, "end": 23, "test": "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    pricing = [1, 1]\n    start = [0, 0]\n    k = 1\n    expected = [[0, 0]]\n    assert solution.highestRankedKItems(grid, pricing, start, k) == expected"}, {"start": 45, "end": 46, "test": "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    pricing = [2, 8]\n    start = [0, 0]\n    k = 4\n    expected = [[0, 0], [0, 1], [1, 0], [1, 1]]\n    assert solution.highestRankedKItems(grid, pricing, start, k) == expected"}, {"start": 47, "end": 48, "test": "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    pricing = [2, 8]\n    start = [0, 0]\n    k = 4\n    expected = [[0, 0], [0, 1], [1, 0], [1, 1]]\n    assert solution.highestRankedKItems(grid, pricing, start, k) == expected"}, {"start": 35, "end": 36, "test": "def test_highestRankedKItems():\n    solution = Solution()\n    grid = [[1, 2, 0], [0, 3, 4], [5, 6, 7]]\n    pricing = [1, 2]\n    start = [0, 0]\n    k = 3\n    expected = [[0, 0], [0, 1]]\n    assert solution.highestRankedKItems(grid, pricing, start, k) == expected"}, {"start": 37, "end": 38, "test": "def test_highestRankedKItems():\n    solution = Solution()\n    assert solution.highestRankedKItems([[1, 2, 0], [4, 3, 5]], [1, 3], [0, 0], 2) == [[0, 0], [0, 1]]"}, {"start": 39, "end": 40, "test": "def test_highestRankedKItems():\n    solution = Solution()\n    assert solution.highestRankedKItems([[1, 2, 3], [4, 5, 6], [7, 8, 9]], [2, 5], [0, 0], 3) == [[0, 0], [0, 1], [1, 0]]"}]}
{"task_num": 2157, "task_title": "Groups of Strings", "func_name": "groupStrings", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.sz = [1] * n\n\n  def unionBySize(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.sz[i] < self.sz[j]:\n      self.sz[j] += self.sz[i]\n      self.id[i] = j\n    else:\n      self.sz[i] += self.sz[j]\n      self.id[j] = i\n    self.count -= 1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def groupStrings(self, words: List[str]) -> List[int]:\n    uf = UnionFind(len(words))\n\n    def getMask(s: str) -> int:\n      mask = 0\n      for c in s:\n        mask |= 1 << ord(c) - ord('a')\n      return mask\n\n    def getAddedMasks(mask: int):\n      for i in range(26):\n        if not (mask >> i & 1):\n          yield mask | 1 << i\n\n    def getDeletedMasks(mask: int):\n      for i in range(26):\n        if mask >> i & 1:\n          yield mask ^ 1 << i\n\n    maskToIndex = {getMask(word): i for i, word in enumerate(words)}\n    deletedMaskToIndex = {}\n\n    for i, word in enumerate(words):\n      mask = getMask(word)\n      for m in getAddedMasks(mask):\n        if m in maskToIndex:\n          uf.unionBySize(i, maskToIndex[m])\n      for m in getDeletedMasks(mask):\n        if m in maskToIndex:\n          uf.unionBySize(i, maskToIndex[m])\n        if m in deletedMaskToIndex:\n          uf.unionBySize(i, deletedMaskToIndex[m])\n        else:\n          deletedMaskToIndex[m] = i\n\n    return [uf.count, max(uf.sz)]\n", "tests": [{"start": 20, "end": 21, "test": "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['abc', 'bcd', 'ace']) == [3, 1]"}, {"start": 22, "end": 24, "test": "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['abc', 'bcd', 'acef', 'xyz']) == [2, 3]"}, {"start": 25, "end": 27, "test": "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['abc', 'bcd', 'acef']) == [1, 3]"}, {"start": 31, "end": 32, "test": "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['abc', 'bcd', 'acef']) == [2, 3]"}, {"start": 48, "end": 49, "test": "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['abc', 'bcd', 'acef']) == [2, 3]"}, {"start": 53, "end": 54, "test": "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['abc', 'bcd', 'acef']) == [2, 3]"}, {"start": 62, "end": 63, "test": "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['abc', 'bcd', 'acef']) == [2, 3]"}, {"start": 65, "end": 66, "test": "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['abc', 'bcd', 'acef']) == [2, 3]"}, {"start": 67, "end": 68, "test": "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['abc', 'bcd', 'acef']) == [2, 3]"}, {"start": 69, "end": 70, "test": "def test_groupStrings():\n    solution = Solution()\n    assert solution.groupStrings(['abc', 'bcd', 'acef']) == [2, 3]"}]}
{"task_num": 2182, "task_title": "Construct String With Repeat Limit", "func_name": "repeatLimitedString", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\n    ans = ''\n    count = collections.Counter(s)\n\n    while True:\n      addOne = ans and self._shouldAddOne(ans, count)\n      c = self._getLargestChar(ans, count)\n      if c == ' ':\n        break\n      repeats = 1 if addOne else min(count[c], repeatLimit)\n      ans += c * repeats\n      count[c] -= repeats\n\n    return ans\n\n  def _shouldAddOne(self, ans: str, count: collections.Counter) -> bool:\n    for c in reversed(string.ascii_lowercase):\n      if count[c]:\n        return ans[-1] == c\n    return False\n\n  def _getLargestChar(self, ans: str, count: collections.Counter) -> int:\n    for c in reversed(string.ascii_lowercase):\n      if count[c] and (not ans or ans[-1] != c):\n        return c\n    return ' '\n", "tests": [{"start": 19, "end": 20, "test": "def test_repeatLimitedString():\n    solution = Solution()\n    result = solution.repeatLimitedString('aaabbbcc', 1)"}, {"start": 29, "end": 30, "test": "def test_repeatLimitedString():\n    solution = Solution()\n    result = solution.repeatLimitedString('aabab', 2)"}, {"start": 35, "end": 36, "test": "def test_repeatLimitedString():\n    solution = Solution()\n    result = solution.repeatLimitedString('aabab', 2)"}]}
{"task_num": 2203, "task_title": "Minimum Weighted Subgraph With the Required Paths", "func_name": "minimumWeight", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\n    graph = [[] for _ in range(n)]\n    reversedGraph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      reversedGraph[v].append((u, w))\n\n    fromSrc1 = self._dijkstra(graph, src1)\n    fromSrc2 = self._dijkstra(graph, src2)\n    fromDest = self._dijkstra(reversedGraph, dest)\n    minWeight = min(a + b + c for a, b, c in zip(fromSrc1, fromSrc2, fromDest))\n    if minWeight == math.inf:\n      return -1\n    else:\n      return minWeight\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int) -> List[int]:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist\n", "tests": [{"start": 24, "end": 25, "test": "def test_minimumWeight():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 1], [1, 2, 1]]\n    src1 = 0\n    src2 = 1\n    dest = 2\n    assert solution.minimumWeight(n, edges, src1, src2, dest) == -1"}, {"start": 26, "end": 27, "test": "def test_minimumWeight():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 1], [1, 2, 2], [2, 3, 3]]\n    src1 = 0\n    src2 = 1\n    dest = 3\n    assert solution.minimumWeight(n, edges, src1, src2, dest) == 6"}, {"start": 37, "end": 38, "test": "def test_minimumWeight():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 2], [0, 2, 4], [1, 3, 1], [2, 3, 2], [3, 4, 1]]\n    src1 = 0\n    src2 = 1\n    dest = 4\n    assert solution.minimumWeight(n, edges, src1, src2, dest) == 5"}, {"start": 40, "end": 42, "test": "def test_minimumWeight():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 1], [1, 2, 2], [2, 3, 3], [3, 4, 4]]\n    src1 = 0\n    src2 = 2\n    dest = 4\n    assert solution.minimumWeight(n, edges, src1, src2, dest) == 9"}]}
{"task_num": 2242, "task_title": "Maximum Score of a Node Sequence", "func_name": "maximumScore", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\n    n = len(scores)\n    ans = -1\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append((scores[v], v))\n      graph[v].append((scores[u], u))\n\n    for i in range(n):\n      graph[i] = heapq.nlargest(3, graph[i])\n\n    for u, v in edges:\n      for scoreA, a in graph[u]:\n        for scoreB, b in graph[v]:\n          if a != b and a != v and b != u:\n            ans = max(ans, scoreA + scores[u] + scores[v] + scoreB)\n\n    return ans\n", "tests": [{"start": 27, "end": 28, "test": "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([1, 2, 3, 4], [[0, 1], [1, 2], [2, 3]]) == 10"}]}
{"task_num": 2245, "task_title": "Maximum Trailing Zeros in a Cornered Path", "func_name": "maxTrailingZeros", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxTrailingZeros(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    leftPrefix2 = [[0] * n for _ in range(m)]\n    leftPrefix5 = [[0] * n for _ in range(m)]\n    topPrefix2 = [[0] * n for _ in range(m)]\n    topPrefix5 = [[0] * n for _ in range(m)]\n\n    def getCount(num: int, factor: int) -> int:\n      count = 0\n      while num % factor == 0:\n        num //= factor\n        count += 1\n      return count\n\n    for i in range(m):\n      for j in range(n):\n        leftPrefix2[i][j] = getCount(grid[i][j], 2)\n        leftPrefix5[i][j] = getCount(grid[i][j], 5)\n        if j:\n          leftPrefix2[i][j] += leftPrefix2[i][j - 1]\n          leftPrefix5[i][j] += leftPrefix5[i][j - 1]\n\n    for j in range(n):\n      for i in range(m):\n        topPrefix2[i][j] = getCount(grid[i][j], 2)\n        topPrefix5[i][j] = getCount(grid[i][j], 5)\n        if i:\n          topPrefix2[i][j] += topPrefix2[i - 1][j]\n          topPrefix5[i][j] += topPrefix5[i - 1][j]\n\n    ans = 0\n    for i in range(m):\n      for j in range(n):\n        curr2 = getCount(grid[i][j], 2)\n        curr5 = getCount(grid[i][j], 5)\n        l2 = leftPrefix2[i][j]\n        l5 = leftPrefix5[i][j]\n        r2 = leftPrefix2[i][n - 1] - (0 if j == 0 else leftPrefix2[i][j - 1])\n        r5 = leftPrefix5[i][n - 1] - (0 if j == 0 else leftPrefix5[i][j - 1])\n        t2 = topPrefix2[i][j]\n        t5 = topPrefix5[i][j]\n        d2 = topPrefix2[m - 1][j] - (0 if i == 0 else topPrefix2[i - 1][j])\n        d5 = topPrefix5[m - 1][j] - (0 if i == 0 else topPrefix5[i - 1][j])\n        ans = max(ans, min(l2 + t2 - curr2, l5 + t5 - curr5), min(r2 + t2 - curr2, r5 + t5 - curr5), min(l2 + d2 - curr2, l5 + d5 - curr5), min(r2 + d2 - curr2, r5 + d5 - curr5))\n\n    return ans\n", "tests": [{"start": 31, "end": 33, "test": "def test_maxTrailingZeros():\n    solution = Solution()\n    grid = [[2, 5], [4, 3]]\n    assert solution.maxTrailingZeros(grid) == 1"}, {"start": 39, "end": 41, "test": "def test_maxTrailingZeros():\n    solution = Solution()\n    grid = [[2, 5], [4, 3]]\n    assert solution.maxTrailingZeros(grid) == 1"}]}
{"task_num": 2257, "task_title": "Count Unguarded Cells in the Grid", "func_name": "countUnguarded", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\n    ans = 0\n    grid = [[0] * n for _ in range(m)]\n    left = [[0] * n for _ in range(m)]\n    right = [[0] * n for _ in range(m)]\n    up = [[0] * n for _ in range(m)]\n    down = [[0] * n for _ in range(m)]\n\n    for row, col in guards:\n      grid[row][col] = 'G'\n\n    for row, col in walls:\n      grid[row][col] = 'W'\n\n    for i in range(m):\n      lastCell = 0\n      for j in range(n):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          left[i][j] = lastCell\n      lastCell = 0\n      for j in range(n - 1, -1, -1):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          right[i][j] = lastCell\n\n    for j in range(n):\n      lastCell = 0\n      for i in range(m):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          up[i][j] = lastCell\n      lastCell = 0\n      for i in range(m - 1, -1, -1):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          down[i][j] = lastCell\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 0 and left[i][j] != 'G' and right[i][j] != 'G' and up[i][j] != 'G' and down[i][j] != 'G':\n          ans += 1\n\n    return ans\n", "tests": [{"start": 29, "end": 30, "test": "def test_countUnguarded():\n    solution = Solution()\n    result = solution.countUnguarded(4, 5, [[0, 0], [1, 2]], [[2, 1]])"}, {"start": 31, "end": 32, "test": "def test_countUnguarded():\n    solution = Solution()\n    result = solution.countUnguarded(4, 5, [[0, 0], [1, 2]], [[2, 1]])"}, {"start": 35, "end": 36, "test": "def test_countUnguarded():\n    solution = Solution()\n    result = solution.countUnguarded(4, 5, [[0, 0], [1, 2]], [[2, 1]])"}, {"start": 37, "end": 38, "test": "def test_countUnguarded():\n    solution = Solution()\n    result = solution.countUnguarded(4, 5, [[0, 0], [1, 2]], [[2, 1]])"}, {"start": 43, "end": 44, "test": "def test_countUnguarded():\n    solution = Solution()\n    result = solution.countUnguarded(3, 4, [[0, 0], [1, 2]], [[0, 1], [2, 3]])"}, {"start": 45, "end": 46, "test": "def test_countUnguarded():\n    solution = Solution()\n    result = solution.countUnguarded(4, 5, [[0, 0], [1, 2]], [[2, 1]])"}, {"start": 49, "end": 50, "test": "def test_countUnguarded():\n    solution = Solution()\n    result = solution.countUnguarded(4, 5, [[0, 0], [1, 2]], [[2, 1]])"}, {"start": 51, "end": 52, "test": "def test_countUnguarded():\n    solution = Solution()\n    result = solution.countUnguarded(4, 5, [[0, 0], [1, 2]], [[2, 1]])"}, {"start": 56, "end": 57, "test": "def test_countUnguarded():\n    solution = Solution()\n    assert solution.countUnguarded(4, 6, [[0, 0], [1, 1], [2, 2]], [[3, 3]]) == 9"}]}
{"task_num": 2258, "task_title": "Escape the Spreading Fire", "func_name": "maximumMinutes", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumMinutes(self, grid: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    kMax = len(grid) * len(grid[0])\n    fireGrid = [[-1] * len(grid[0]) for _ in range(len(grid))]\n    self._buildFireGrid(grid, fireGrid, dirs)\n\n    ans = -1\n    l = 0\n    r = kMax\n\n    while l <= r:\n      m = (l + r) // 2\n      if self._canStayFor(grid, fireGrid, m, dirs):\n        ans = m\n        l = m + 1\n      else:\n        r = m - 1\n\n    return int(1e9) if ans == kMax else ans\n\n  def _buildFireGrid(self, grid: List[List[int]], fireMinute: List[List[int]], dirs: List[int]) -> None:\n    minuteFromFire = 0\n    q = collections.deque()\n\n    for i in range(len(grid)):\n      for j in range(len(grid[0])):\n        if grid[i][j] == 1:\n          q.append((i, j))\n          fireMinute[i][j] = 0\n    while q:\n      minuteFromFire += 1\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == len(grid) or y < 0 or y == len(grid[0]):\n            continue\n          if grid[x][y] == 2:\n            continue\n          if fireMinute[x][y] != -1:\n            continue\n          fireMinute[x][y] = minuteFromFire\n          q.append((x, y))\n\n  def _canStayFor(self, grid: List[List[int]], fireMinute: List[List[int]], minute: int, dirs: List[int]) -> bool:\n    q = collections.deque([(0, 0)])\n    seen = {(0, 0)}\n\n    while q:\n      minute += 1\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == len(grid) or y < 0 or y == len(grid[0]):\n            continue\n          if grid[x][y] == 2:\n            continue\n          if x == len(grid) - 1 and y == len(grid[0]) - 1:\n            if fireMinute[x][y] != -1 and fireMinute[x][y] < minute:\n              continue\n            return True\n          if fireMinute[x][y] != -1 and fireMinute[x][y] <= minute:\n            continue\n          if (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n\n    return False\n", "tests": [{"start": 24, "end": 26, "test": "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 1, 2], [0, 0, 0]]\n    assert solution.maximumMinutes(grid) == 4"}, {"start": 27, "end": 28, "test": "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 1, 2], [0, 0, 0]]\n    assert solution.maximumMinutes(grid) == -1"}, {"start": 38, "end": 40, "test": "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[1, 0, 0], [0, 2, 0], [0, 0, 0]]\n    assert solution.maximumMinutes(grid) == -1"}, {"start": 48, "end": 49, "test": "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[1, 0, 0], [0, 2, 0], [0, 0, 0]]\n    assert solution.maximumMinutes(grid) == -1"}, {"start": 50, "end": 51, "test": "def test_maximumMinutes():\n    solution = Solution()\n    assert solution.maximumMinutes([[0, 0], [0, 2]]) == -1"}, {"start": 52, "end": 53, "test": "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 1, 2], [0, 0, 0]]\n    assert solution.maximumMinutes(grid) == -1"}, {"start": 68, "end": 69, "test": "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[1, 2], [0, 0]]\n    assert solution.maximumMinutes(grid) == -1"}, {"start": 70, "end": 71, "test": "def test_maximumMinutes():\n    solution = Solution()\n    assert solution.maximumMinutes([[0, 0], [0, 2]]) == -1"}, {"start": 72, "end": 75, "test": "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 1, 2], [0, 0, 0], [0, 0, 0]]\n    assert solution.maximumMinutes(grid) == 4"}, {"start": 76, "end": 77, "test": "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 1, 2], [0, 0, 0]]\n    assert solution.maximumMinutes(grid) == 4"}, {"start": 78, "end": 79, "test": "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 1, 2], [0, 0, 0], [0, 0, 0]]\n    assert solution.maximumMinutes(grid) == -1"}, {"start": 73, "end": 74, "test": "def test_maximumMinutes():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 1, 2], [0, 0, 0]]\n    assert solution.maximumMinutes(grid) == 4"}]}
{"task_num": 2290, "task_title": "Minimum Obstacle Removal to Reach Corner", "func_name": "minimumObstacles", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumObstacles(self, grid: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    minHeap = [(grid[0][0], 0, 0)]  # (d, i, j)\n    dist = [[math.inf] * n for _ in range(m)]\n    dist[0][0] = grid[0][0]\n\n    while minHeap:\n      d, i, j = heapq.heappop(minHeap)\n      if i == m - 1 and j == n - 1:\n        return d\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        newDist = d + grid[i][j]\n        if newDist < dist[x][y]:\n          dist[x][y] = newDist\n          heapq.heappush(minHeap, (newDist, x, y))\n\n    return dist[m - 1][n - 1]\n", "tests": [{"start": 22, "end": 23, "test": "def test_minimumObstacles():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n    assert solution.minimumObstacles(grid) == 0"}, {"start": 27, "end": 28, "test": "def test_minimumObstacles():\n    solution = Solution()\n    grid = [[1, 1, 1], [0, 0, 0], [1, 1, 1]]\n    assert solution.minimumObstacles(grid) == 2"}, {"start": 30, "end": 32, "test": "def test_minimumObstacles():\n    solution = Solution()\n    grid = [[0, 1, 1], [1, 0, 1], [1, 1, 0]]\n    assert solution.minimumObstacles(grid) == 2"}]}
{"task_num": 2299, "task_title": "Strong Password Checker II", "func_name": "strongPasswordCheckerII", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def strongPasswordCheckerII(self, password: str) -> bool:\n    if len(password) < 8:\n      return False\n    if not any(c.islower() for c in password):\n      return False\n    if not any(c.isupper() for c in password):\n      return False\n    if not any(c.isdigit() for c in password):\n      return False\n    if not any(\"!@#$%^&*()-+\".find(c) != -1 for c in password):\n      return False\n    return all(a != b for a, b in zip(password, password[1:]))\n", "tests": [{"start": 13, "end": 14, "test": "def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert not solution.strongPasswordCheckerII('abc')"}, {"start": 15, "end": 16, "test": "def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert not solution.strongPasswordCheckerII('ABCDEF12')"}, {"start": 17, "end": 18, "test": "def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert not solution.strongPasswordCheckerII('password')"}, {"start": 19, "end": 20, "test": "def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert not solution.strongPasswordCheckerII('Abcdefgh')"}, {"start": 21, "end": 22, "test": "def test_strongPasswordCheckerII():\n    solution = Solution()\n    assert not solution.strongPasswordCheckerII('password')"}]}
{"task_num": 2301, "task_title": "Match Substring After Replacement", "func_name": "matchReplacement", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def matchReplacement(self, s: str, sub: str, mappings: List[List[str]]) -> bool:\n    isMapped = [[False] * 128 for _ in range(128)]\n\n    for old, new in mappings:\n      isMapped[ord(old)][ord(new)] = True\n\n    for i in range(len(s)):\n      if self._canTransform(s, i, sub, isMapped):\n        return True\n\n    return False\n\n  def _canTransform(self, s: str, start: int, sub: str, isMapped: List[List[bool]]) -> bool:\n    if start + len(sub) > len(s):\n      return False\n\n    for i in range(len(sub)):\n      a = sub[i]\n      b = s[start + i]\n      if a != b and not isMapped[ord(a)][ord(b)]:\n        return False\n\n    return True\n", "tests": [{"start": 25, "end": 26, "test": "def test_matchReplacement():\n    solution = Solution()\n    assert not solution.matchReplacement('abcd', 'abce', [['a', 'b'], ['c', 'd']])"}, {"start": 19, "end": 20, "test": "def test_matchReplacement():\n    solution = Solution()\n    assert solution.matchReplacement('abcd', 'bd', [['a', 'b'], ['c', 'd']]) == True"}, {"start": 31, "end": 32, "test": "def test_matchReplacement():\n    solution = Solution()\n    assert solution.matchReplacement('abcd', 'abz', [['a', 'b'], ['c', 'd'], ['z', 'a']]) == True"}]}
{"task_num": 2322, "task_title": "Minimum Score After Removals on a Tree", "func_name": "minimumScore", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Set\n\nclass Solution:\n  def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\n    n = len(nums)\n    xors = functools.reduce(lambda x, y: x ^ y, nums)\n    subXors = nums[:]\n    tree = [[] for _ in range(n)]\n    children = [{i} for i in range(n)]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, parent: int) -> Tuple[int, Set[int]]:\n      for v in tree[u]:\n        if v == parent:\n          continue\n        vXor, vChildren = dfs(v, u)\n        subXors[u] ^= vXor\n        children[u] |= vChildren\n      return subXors[u], children[u]\n\n    dfs(0, -1)\n\n    ans = math.inf\n    for i in range(len(edges)):\n      a, b = edges[i]\n      if b in children[a]:\n        a, b = b, a\n      for j in range(i):\n        c, d = edges[j]\n        if d in children[c]:\n          c, d = d, c\n\n        if c in children[a] and a != c:\n          cands = [subXors[c], subXors[a] ^ subXors[c], xors ^ subXors[a]]\n        elif a in children[c] and a != c:\n          cands = [subXors[a], subXors[c] ^ subXors[a], xors ^ subXors[c]]\n        else:\n          cands = [subXors[a], subXors[c], xors ^ subXors[a] ^ subXors[c]]\n        ans = min(ans, max(cands) - min(cands))\n\n    return ans\n", "tests": [{"start": 37, "end": 38, "test": "def test_minimumScore():\n    solution = Solution()\n    nums = [1, 2, 3, 4]\n    edges = [[0, 1], [1, 2], [2, 3]]\n    assert solution.minimumScore(nums, edges) == 1"}, {"start": 25, "end": 26, "test": "def test_minimumScore():\n    solution = Solution()\n    nums = [1, 2, 3]\n    edges = [[0, 1], [1, 2]]\n    assert solution.minimumScore(nums, edges) == 0"}, {"start": 41, "end": 42, "test": "def test_minimumScore():\n    solution = Solution()\n    nums = [1, 2, 3, 4]\n    edges = [[0, 1], [1, 2], [2, 3]]\n    assert solution.minimumScore(nums, edges) == 1"}, {"start": 44, "end": 45, "test": "def test_minimumScore():\n    solution = Solution()\n    nums = [1, 2, 3, 4]\n    edges = [[0, 1], [1, 2], [2, 3]]\n    assert solution.minimumScore(nums, edges) == 1"}, {"start": 46, "end": 47, "test": "def test_minimumScore():\n    solution = Solution()\n    nums = [1, 2, 3, 4]\n    edges = [[0, 1], [1, 2], [2, 3]]\n    assert solution.minimumScore(nums, edges) == 1"}, {"start": 48, "end": 49, "test": "def test_minimumScore():\n    solution = Solution()\n    nums = [1, 2, 3, 4]\n    edges = [[0, 1], [1, 2], [2, 3]]\n    assert solution.minimumScore(nums, edges) == 1"}]}
{"task_num": 2332, "task_title": "The Latest Time to Catch a Bus", "func_name": "latestTimeCatchTheBus", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\n    buses.sort()\n    passengers.sort()\n\n    if passengers[0] > buses[-1]:\n      return buses[-1]\n\n    ans = passengers[0] - 1\n    i = 0\n    j = 0\n    while i < len(buses):\n      arrived = 0\n      while arrived < capacity and j < len(passengers) and passengers[j] <= buses[i]:\n        if j > 0 and passengers[j] != passengers[j - 1] + 1:\n          ans = passengers[j] - 1\n        j += 1\n        arrived += 1\n\n      if arrived < capacity and j > 0 and passengers[j - 1] != buses[i]:\n        ans = buses[i]\n      i += 1\n\n    return ans\n", "tests": [{"start": 16, "end": 17, "test": "def test_latestTimeCatchTheBus():\n    solution = Solution()\n    assert solution.latestTimeCatchTheBus([10, 20], [30, 40, 50, 60], 2) == 20"}, {"start": 30, "end": 31, "test": "def test_latestTimeCatchTheBus():\n    solution = Solution()\n    assert solution.latestTimeCatchTheBus([10, 20], [3, 4, 5, 6, 7, 8, 9], 2) == 9"}, {"start": 25, "end": 26, "test": "def test_latestTimeCatchTheBus():\n    solution = Solution()\n    assert solution.latestTimeCatchTheBus([10, 20], [3, 4, 5, 6, 7, 8, 9], 2) == 9"}]}
{"task_num": 2337, "task_title": "Move Pieces to Obtain a String", "func_name": "canChange", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def canChange(self, start: str, target: str) -> bool:\n    n = len(start)\n    i = 0\n    j = 0\n\n    while i <= n and j <= n:\n      while i < n and start[i] == '_':\n        i += 1\n      while j < n and target[j] == '_':\n        j += 1\n      if i == n or j == n:\n        return i == n and j == n\n      if start[i] != target[j]:\n        return False\n      if start[i] == 'R' and i > j:\n        return False\n      if start[i] == 'L' and i < j:\n        return False\n      i += 1\n      j += 1\n\n    return True\n", "tests": [{"start": 22, "end": 23, "test": "def test_canChange():\n    solution = Solution()\n    assert solution.canChange('R_L', '_L_') == False"}, {"start": 24, "end": 25, "test": "def test_canChange():\n    solution = Solution()\n    assert not solution.canChange('R_L', 'L_R')"}, {"start": 26, "end": 27, "test": "def test_canChange():\n    solution = Solution()\n    assert not solution.canChange('R_L', '_L_')"}, {"start": 28, "end": 29, "test": "def test_canChange():\n    solution = Solution()\n    assert not solution.canChange('R_L', '_RL')"}]}
{"task_num": 2392, "task_title": "Build a Matrix With Conditions", "func_name": "buildMatrix", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\n    rowOrder = self._topologicalSort(rowConditions, k)\n    if not rowOrder:\n      return []\n\n    colOrder = self._topologicalSort(colConditions, k)\n    if not colOrder:\n      return []\n\n    ans = [[0] * k for _ in range(k)]\n    nodeToRowIndex = [0] * (k + 1)\n\n    for i, node in enumerate(rowOrder):\n      nodeToRowIndex[node] = i\n\n    for j, node in enumerate(colOrder):\n      i = nodeToRowIndex[node]\n      ans[i][j] = node\n\n    return ans\n\n  def _topologicalSort(self, conditions: List[List[int]], n: int) -> List[int]:\n    order = []\n    graph = [[] for _ in range(n + 1)]\n    inDegrees = [0] * (n + 1)\n\n    for u, v in conditions:\n      graph[u].append(v)\n      inDegrees[v] += 1\n\n    q = collections.deque([i for i in range(1, n + 1) if inDegrees[i] == 0])\n\n    while q:\n      u = q.popleft()\n      order.append(u)\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    if len(order) == n:\n      return order\n    else:\n      return []\n", "tests": [{"start": 14, "end": 15, "test": "def test_buildMatrix():\n    solution = Solution()\n    result = solution.buildMatrix(3, [[2, 1]], [[3, 2]])"}, {"start": 18, "end": 19, "test": "def test_buildMatrix():\n    solution = Solution()\n    result = solution.buildMatrix(3, [[1, 2]], [[1, 3]])"}, {"start": 52, "end": 53, "test": "def test_buildMatrix():\n    solution = Solution()\n    result = solution.buildMatrix(3, [[1, 2]], [[1, 3]])"}, {"start": 54, "end": 55, "test": "def test_buildMatrix():\n    solution = Solution()\n    result = solution.buildMatrix(3, [[1, 2]], [[1, 3]])"}, {"start": 49, "end": 50, "test": "def test_buildMatrix():\n    solution = Solution()\n    result = solution.buildMatrix(3, [[1, 2]], [[1, 3]])"}]}
{"task_num": 2437, "task_title": "Number of Valid Clock Times", "func_name": "countTime", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countTime(self, time: str) -> int:\n    ans = 1\n    if time[3] == '?':\n      ans *= 6\n    if time[4] == '?':\n      ans *= 10\n\n    if time[0] == '?' and time[1] == '?':\n      return ans * 24\n    if time[0] == '?':\n      if time[1] < '4':\n        return ans * 3\n      else:\n        return ans * 2\n    if time[1] == '?':\n      if time[0] == '2':\n        return ans * 4\n      else:\n        return ans * 10\n    return ans\n", "tests": [{"start": 14, "end": 15, "test": "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('2?:?0') == 6"}, {"start": 16, "end": 17, "test": "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('2?:?5') == 60"}, {"start": 19, "end": 20, "test": "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('??:??') == 24"}, {"start": 21, "end": 25, "test": "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('?4:??') == 3"}, {"start": 26, "end": 30, "test": "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('2?:?') == 4"}, {"start": 22, "end": 23, "test": "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('2?:?0') == 3"}, {"start": 24, "end": 25, "test": "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('1?:?0') == 2"}, {"start": 27, "end": 28, "test": "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('2?:?') == 4"}, {"start": 29, "end": 30, "test": "def test_countTime():\n    solution = Solution()\n    assert solution.countTime('2?:?') == 10"}]}
{"task_num": 2456, "task_title": "Most Popular Video Creator", "func_name": "mostPopularCreator", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Creator:\n  def __init__(self, popularity: int, videoId: str, maxView: int):\n    self.popularity = popularity\n    self.videoId = videoId\n    self.maxView = maxView\n\n\nclass Solution:\n  def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\n    ans = []\n    maxPopularity = 0\n    nameToCreator = {}\n\n    for name, id, view in zip(creators, ids, views):\n      if name not in nameToCreator:\n        nameToCreator[name] = Creator(view, id, view)\n        maxPopularity = max(maxPopularity, view)\n        continue\n      creator = nameToCreator[name]\n      creator.popularity += view\n      maxPopularity = max(maxPopularity, creator.popularity)\n      if creator.maxView < view or creator.maxView == view and creator.videoId > id:\n        creator.videoId = id\n        creator.maxView = view\n\n    for name, creator in nameToCreator.items():\n      if creator.popularity == maxPopularity:\n        ans.append([name, creator.videoId])\n\n    return ans\n", "tests": [{"start": 25, "end": 28, "test": "def test_mostPopularCreator():\n    solution = Solution()\n    creators = ['alice']\n    ids = ['1']\n    views = [5]\n    assert solution.mostPopularCreator(creators, ids, views) == [['alice', '1']]"}, {"start": 32, "end": 34, "test": "def test_mostPopularCreator():\n    solution = Solution()\n    creators = ['alice', 'bob', 'alice']\n    ids = ['one', 'two', 'three']\n    views = [10, 5, 7]\n    expected = [['alice', 'three']]\n    assert solution.mostPopularCreator(creators, ids, views) == expected"}, {"start": 37, "end": 38, "test": "def test_mostPopularCreator():\n    solution = Solution()\n    creators = ['alice', 'bob']\n    ids = ['1', '2']\n    views = [10, 10]\n    assert solution.mostPopularCreator(creators, ids, views) == [['alice'], ['bob']]"}]}
{"task_num": 2462, "task_title": "Total Cost to Hire K Workers", "func_name": "totalCost", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\n    ans = 0\n    i = 0\n    j = len(costs) - 1\n    minHeapL = []\n    minHeapR = []\n\n    for _ in range(k):\n      while len(minHeapL) < candidates and i <= j:\n        heapq.heappush(minHeapL, costs[i])\n        i += 1\n      while len(minHeapR) < candidates and i <= j:\n        heapq.heappush(minHeapR, costs[j])\n        j -= 1\n      if not minHeapL:\n        ans += heapq.heappop(minHeapR)\n      elif not minHeapR:\n        ans += heapq.heappop(minHeapL)\n      elif minHeapL[0] <= minHeapR[0]:\n        ans += heapq.heappop(minHeapL)\n      else:\n        ans += heapq.heappop(minHeapR)\n\n    return ans\n", "tests": [{"start": 26, "end": 27, "test": "def test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([1, 2, 3, 4, 5], 3, 2) == 6"}, {"start": 28, "end": 29, "test": "def test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([1, 2, 3, 4, 5], 3, 1) == 6"}, {"start": 30, "end": 31, "test": "def test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([1, 2, 3, 4, 5], 3, 1) == 6"}, {"start": 32, "end": 33, "test": "def test_totalCost():\n    solution = Solution()\n    assert solution.totalCost([1, 2, 3, 4, 5], 3, 2) == 6"}]}
{"task_num": 2467, "task_title": "Most Profitable Path in a Tree", "func_name": "mostProfitablePath", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\n    n = len(amount)\n    tree = [[] for _ in range(n)]\n    parent = [0] * n\n    aliceDist = [-1] * n\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, prev: int, d: int) -> None:\n      parent[u] = prev\n      aliceDist[u] = d\n      for v in tree[u]:\n        if aliceDist[v] == -1:\n          dfs(v, u, d + 1)\n\n    dfs(0, -1, 0)\n\n    u = bob\n    bobDist = 0\n    while u != 0:\n      if bobDist < aliceDist[u]:\n        amount[u] = 0\n      elif bobDist == aliceDist[u]:\n        amount[u] //= 2\n      u = parent[u]\n      bobDist += 1\n\n    return self._getMoney(tree, 0, -1, amount)\n\n  def _getMoney(self, tree: List[List[int]], u: int, prev: int, amount: List[int]) -> int:\n    if len(tree[u]) == 1 and tree[u][0] == prev:\n      return amount[u]\n\n    maxPath = -math.inf\n    for v in tree[u]:\n      if v != prev:\n        maxPath = max(maxPath, self._getMoney(tree, v, u, amount))\n\n    return amount[u] + maxPath\n", "tests": [{"start": 44, "end": 45, "test": "def test_mostProfitablePath():\n    solution = Solution()\n    edges = [[0, 1], [1, 2], [2, 3]]\n    bob = 3\n    amount = [-10, -5, 7, 4]\n    assert solution.mostProfitablePath(edges, bob, amount) == 9"}, {"start": 34, "end": 35, "test": "def test_mostProfitablePath():\n    solution = Solution()\n    edges = [[0, 1], [1, 2], [1, 3]]\n    bob = 1\n    amount = [-5, 10, -6, 4]\n    assert solution.mostProfitablePath(edges, bob, amount) == 9"}, {"start": 49, "end": 50, "test": "def test_mostProfitablePath():\n    solution = Solution()\n    edges = [[0, 1], [1, 2], [1, 3]]\n    bob = 1\n    amount = [-5, 2, -3, 4]\n    assert solution.mostProfitablePath(edges, bob, amount) == 6"}, {"start": 26, "end": 27, "test": "def test_mostProfitablePath():\n    solution = Solution()\n    edges = [[0, 1], [1, 2], [2, 3]]\n    bob = 2\n    amount = [-5, -6, 4, 5]\n    assert solution.mostProfitablePath(edges, bob, amount) == 9"}, {"start": 36, "end": 37, "test": "def test_mostProfitablePath():\n    solution = Solution()\n    edges = [[0, 1], [1, 2], [1, 3]]\n    bob = 1\n    amount = [-5, 10, -6]\n    assert solution.mostProfitablePath(edges, bob, amount) == 9"}]}
{"task_num": 2499, "task_title": "Minimum Total Cost to Make Arrays Unequal", "func_name": "minimumTotalCost", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\n    n = len(nums1)\n    ans = 0\n    maxFreq = 0\n    maxFreqNum = 0\n    shouldBeSwapped = 0\n    conflictedNumCount = [0] * (n + 1)\n\n    for i, (num1, num2) in enumerate(zip(nums1, nums2)):\n      if num1 == num2:\n        conflictedNum = num1\n        conflictedNumCount[conflictedNum] += 1\n        if conflictedNumCount[conflictedNum] > maxFreq:\n          maxFreq = conflictedNumCount[conflictedNum]\n          maxFreqNum = conflictedNum\n        shouldBeSwapped += 1\n        ans += i\n\n    for i, (num1, num2) in enumerate(zip(nums1, nums2)):\n      if maxFreq * 2 <= shouldBeSwapped:\n        break\n      if num1 == num2:\n        continue\n\n      if num1 == maxFreqNum or num2 == maxFreqNum:\n        continue\n      shouldBeSwapped += 1\n      ans += i\n\n    if maxFreq * 2 > shouldBeSwapped:\n      return -1\n    else:\n      return ans\n", "tests": [{"start": 41, "end": 42, "test": "def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([1, 2, 3], [1, 2, 3]) == -1"}, {"start": 43, "end": 44, "test": "def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([1, 2, 3], [1, 2, 3]) == -1"}, {"start": 21, "end": 28, "test": "def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([1, 2, 3], [1, 2, 3]) == -1"}, {"start": 31, "end": 32, "test": "def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([1, 2, 3], [1, 2, 3]) == -1"}, {"start": 33, "end": 34, "test": "def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([1, 2, 3], [1, 2, 3]) == -1"}, {"start": 36, "end": 37, "test": "def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([1, 2, 3], [1, 2, 3]) == -1"}, {"start": 24, "end": 26, "test": "def test_minimumTotalCost():\n    solution = Solution()\n    assert solution.minimumTotalCost([1, 2, 3], [1, 2, 3]) == -1"}]}
{"task_num": 2503, "task_title": "Maximum Number of Points From Grid Queries", "func_name": "maxPoints", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, query: int):\n    self.queryIndex = queryIndex\n    self.query = query\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.query\n\n\nclass Solution:\n  def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    ans = [0] * len(queries)\n    minHeap = [(grid[0][0], 0, 0)]\n    seen = {(0, 0)}\n    accumulate = 0\n\n    for queryIndex, query in sorted([IndexedQuery(i, query) for i, query in enumerate(queries)], key=lambda iq: iq.query):\n      while minHeap:\n        val, i, j = heapq.heappop(minHeap)\n        if val >= query:\n          heapq.heappush(minHeap, (val, i, j))\n          break\n        accumulate += 1\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if (x, y) in seen:\n            continue\n          heapq.heappush(minHeap, (grid[x][y], x, y))\n          seen.add((x, y))\n      ans[queryIndex] = accumulate\n\n    return ans\n", "tests": [{"start": 34, "end": 36, "test": "def test_maxPoints():\n    solution = Solution()\n    grid = [[1, 2], [3, 4]]\n    queries = [5]\n    expected = [0]\n    assert solution.maxPoints(grid, queries) == expected"}, {"start": 41, "end": 42, "test": "def test_maxPoints():\n    solution = Solution()\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    queries = [10]\n    expected = [9]\n    assert solution.maxPoints(grid, queries) == expected"}, {"start": 43, "end": 44, "test": "def test_maxPoints():\n    solution = Solution()\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    queries = [5, 10]\n    expected = [3, 9]\n    assert solution.maxPoints(grid, queries) == expected"}]}
{"task_num": 2508, "task_title": "Add Edges to Make Degrees of All Nodes Even", "func_name": "isPossible", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isPossible(self, n: int, edges: List[List[int]]) -> bool:\n    graph = [set() for _ in range(n)]\n\n    for u, v in edges:\n      graph[u - 1].add(v - 1)\n      graph[v - 1].add(u - 1)\n\n    oddNodes = [i for i, neighbor in enumerate(graph) if len(neighbor) & 1]\n    if not oddNodes:\n      return True\n    if len(oddNodes) == 2:\n      a, b = oddNodes\n      return any(a not in graph[i] and b not in graph[i] for i in range(n))\n    if len(oddNodes) == 4:\n      a, b, c, d = oddNodes\n      return (b not in graph[a] and d not in graph[c]) or (c not in graph[a] and d not in graph[b]) or (d not in graph[a] and c not in graph[b])\n    return False\n", "tests": [{"start": 20, "end": 21, "test": "def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(4, [[1, 2], [3, 4]]) == True"}, {"start": 22, "end": 24, "test": "def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(4, [[1, 2], [3, 4]]) == True"}, {"start": 25, "end": 27, "test": "def test_isPossible():\n    solution = Solution()\n    assert solution.isPossible(4, [[1, 2], [3, 4], [1, 3]]) == True"}]}
{"task_num": 2523, "task_title": "Closest Prime Numbers in Range", "func_name": "closestPrimes", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def closestPrimes(self, left: int, right: int) -> List[int]:\n    isPrime = self._sieveEratosthenes(right + 1)\n    primes=[]\n    for i in range(left, right+1):\n      if isPrime[i]:\n        primes.append(i)\n\n    if len(primes) < 2:\n      return [-1, -1]\n\n    minDiff = math.inf\n    num1 = -1\n    num2 = -1\n\n    for a, b in zip(primes, primes[1:]):\n      diff = b - a\n      if diff < minDiff:\n        minDiff = diff\n        num1 = a\n        num2 = b\n\n    return [num1, num2]\n\n  def _sieveEratosthenes(self, n: int) -> List[bool]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return isPrime\n", "tests": [{"start": 19, "end": 20, "test": "def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(1, 5) == [2, 3], 'Test case 1 failed'"}, {"start": 16, "end": 17, "test": "def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(3, 10) == [5, 7]"}, {"start": 28, "end": 31, "test": "def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(10, 29) == [11, 13], 'Test case failed'"}, {"start": 40, "end": 42, "test": "def test_closestPrimes():\n    solution = Solution()\n    assert solution.closestPrimes(10, 30) == [11, 13]"}]}
{"task_num": 2532, "task_title": "Time to Cross a Bridge", "func_name": "findCrossingTime", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n    ans = 0\n    leftBridgeQueue = [(-leftToRight - rightToLeft, -i) for i, (leftToRight, pickOld, rightToLeft, pickNew) in enumerate(time)]\n    rightBridgeQueue = []\n    leftWorkers = []\n    rightWorkers = []\n\n    heapq.heapify(leftBridgeQueue)\n\n    while n > 0 or rightBridgeQueue or rightWorkers:\n      while leftWorkers and leftWorkers[0][0] <= ans:\n        i = heapq.heappop(leftWorkers)[1]\n        heapq.heappush(leftBridgeQueue, (-time[i][0] - time[i][2], -i))\n      while rightWorkers and rightWorkers[0][0] <= ans:\n        i = heapq.heappop(rightWorkers)[1]\n        heapq.heappush(rightBridgeQueue, (-time[i][0] - time[i][2], -i))\n      if rightBridgeQueue:\n        i = -heapq.heappop(rightBridgeQueue)[1]\n        ans += time[i][2]\n        heapq.heappush(leftWorkers, (ans + time[i][3], i))\n      elif leftBridgeQueue and n > 0:\n        i = -heapq.heappop(leftBridgeQueue)[1]\n        ans += time[i][0]\n        heapq.heappush(rightWorkers, (ans + time[i][1], i))\n        n -= 1\n      else:\n        if leftWorkers and n > 0:\n          ans1=leftWorkers[0][0]\n        else:\n          ans1=math.inf\n        if rightWorkers:\n          ans2=rightWorkers[0][0]\n        else:\n          ans2=math.inf\n        ans=min(ans1,ans2)\n\n    return ans", "tests": [{"start": 28, "end": 31, "test": "def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(1, 2, [[1, 1, 1, 1]]) == 6"}, {"start": 32, "end": 36, "test": "def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(1, 2, [[1, 1, 3, 1]]) == 6"}, {"start": 37, "end": 46, "test": "def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(3, 2, [[1, 1, 4, 1], [5, 1, 4, 1]]) == 7"}, {"start": 38, "end": 39, "test": "def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(2, 3, [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) == 6"}, {"start": 40, "end": 41, "test": "def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(2, 3, [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) == 6"}, {"start": 42, "end": 43, "test": "def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(1, 1, [[1, 2, 3, 4]]) == 7"}, {"start": 44, "end": 45, "test": "def test_findCrossingTime():\n    solution = Solution()\n    assert solution.findCrossingTime(1, 3, [[0, 0, 2, 4], [0, 0, 2, 4], [0, 0, 2, 4]]) == 6"}]}
{"task_num": 2577, "task_title": "Minimum Time to Visit a Cell In a Grid", "func_name": "minimumTime", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumTime(self, grid: List[List[int]]) -> int:\n    if grid[0][1] > 1 and grid[1][0] > 1:\n      return -1\n\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    minHeap = [(0, 0, 0)]\n    seen = {(0, 0)}\n\n    while minHeap:\n      time, i, j = heapq.heappop(minHeap)\n      if i == m - 1 and j == n - 1:\n        return time\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if (x, y) in seen:\n          continue\n        if (grid[x][y] - time) % 2 == 0:\n          extraWait = 1\n        else:\n          extraWait = 0\n        nextTime = max(time + 1, grid[x][y] + extraWait)\n        heapq.heappush(minHeap, (nextTime, x, y))\n        seen.add((x, y))\n", "tests": [{"start": 13, "end": 14, "test": "def test_minimumTime():\n    solution = Solution()\n    assert solution.minimumTime([[2, 3], [1, 1]]) == -1"}, {"start": 24, "end": 25, "test": "def test_minimumTime():\n    solution = Solution()\n    grid = [[0, 1], [1, 0]]\n    assert solution.minimumTime(grid) == 2"}, {"start": 29, "end": 30, "test": "def test_minimumTime():\n    solution = Solution()\n    grid = [[0, 2], [1, 1]]\n    assert solution.minimumTime(grid) == -1"}, {"start": 31, "end": 32, "test": "def test_minimumTime():\n    solution = Solution()\n    grid = [[0, 2], [1, 1]]\n    assert solution.minimumTime(grid) == -1"}, {"start": 33, "end": 34, "test": "def test_minimumTime():\n    solution = Solution()\n    grid = [[0, 2], [1, 1]]\n    assert solution.minimumTime(grid) == -1"}, {"start": 35, "end": 36, "test": "def test_minimumTime():\n    solution = Solution()\n    grid = [[0, 2], [1, 0]]\n    assert solution.minimumTime(grid) == -1"}]}
{"task_num": 2601, "task_title": "Prime Subtraction Operation", "func_name": "primeSubOperation", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def primeSubOperation(self, nums: List[int]) -> bool:\n    kMax = 1000\n    primes = self._sieveEratosthenes(kMax)\n\n    prevNum = 0\n    for num in nums:\n      i = bisect.bisect_left(primes, num - prevNum)\n      if i > 0:\n        num -= primes[i - 1]\n      if num <= prevNum:\n        return False\n      prevNum = num\n\n    return True\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return [i for i in range(n) if isPrime[i]]\n", "tests": [{"start": 19, "end": 20, "test": "def test_primeSubOperation():\n    solution = Solution()\n    assert solution.primeSubOperation([4, 5, 6]) == True"}, {"start": 21, "end": 22, "test": "def test_primeSubOperation():\n    solution = Solution()\n    assert not solution.primeSubOperation([4, 3])"}, {"start": 32, "end": 34, "test": "def test_primeSubOperation():\n    solution = Solution()\n    assert solution.primeSubOperation([10, 5, 7]) == True"}]}
{"task_num": 2603, "task_title": "Collect Coins in a Tree", "func_name": "collectTheCoins", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def collectTheCoins(self, coins: List[int], edges: List[List[int]]) -> int:\n    n = len(coins)\n    tree = [set() for _ in range(n)]\n    leavesToBeRemoved = collections.deque()\n\n    for u, v in edges:\n      tree[u].add(v)\n      tree[v].add(u)\n\n    for u in range(n):\n      while len(tree[u]) == 1 and coins[u] == 0:\n        v = tree[u].pop()\n        tree[v].remove(u)\n        u = v\n      if len(tree[u]) == 1:\n        leavesToBeRemoved.append(u)\n\n    for _ in range(2):\n      for _ in range(len(leavesToBeRemoved)):\n        u = leavesToBeRemoved.popleft()\n        if tree[u]:\n          v = tree[u].pop()\n          tree[v].remove(u)\n          if len(tree[v]) == 1:\n            leavesToBeRemoved.append(v)\n\n    return sum(len(children) for children in tree)\n", "tests": [{"start": 26, "end": 27, "test": "def test_collectTheCoins():\n    solution = Solution()\n    assert solution.collectTheCoins([0, 0, 0], [[0, 1], [1, 2]]) == 0"}, {"start": 32, "end": 36, "test": "def test_collectTheCoins():\n    solution = Solution()\n    assert solution.collectTheCoins([0, 0, 0], [[0, 1], [1, 2]]) == 2"}, {"start": 35, "end": 36, "test": "def test_collectTheCoins():\n    solution = Solution()\n    assert solution.collectTheCoins([0, 0, 0], [[0, 1], [1, 2]]) == 0"}]}
{"task_num": 2653, "task_title": "Sliding Subarray Beauty", "func_name": "getSubarrayBeauty", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\n    ans = []\n    count = [0] * 50\n\n    for i, num in enumerate(nums):\n      if num < 0:\n        count[num + 50] += 1\n      if i - k >= 0 and nums[i - k] < 0:\n        count[nums[i - k] + 50] -= 1\n      if i + 1 >= k:\n        ans.append(self._getXthSmallestNum(count, x))\n\n    return ans\n\n  def _getXthSmallestNum(self, count: List[int], x: int) -> int:\n    prefix = 0\n    for i in range(50):\n      prefix += count[i]\n      if prefix >= x:\n        return i - 50\n    return 0\n", "tests": [{"start": 17, "end": 18, "test": "def test_getSubarrayBeauty():\n    solution = Solution()\n    assert solution.getSubarrayBeauty([-1, -2, -3, -4], 2, 1) == [-1, -2]"}, {"start": 19, "end": 20, "test": "def test_getSubarrayBeauty():\n    solution = Solution()\n    assert solution.getSubarrayBeauty([-3, -2, 7, -4], 3, 1) == [-3, -2, -2]"}, {"start": 21, "end": 22, "test": "def test_getSubarrayBeauty():\n    solution = Solution()\n    assert solution.getSubarrayBeauty([-1, -2, 0, 4, 5], 3, 2) == [-1, -1, -1]"}, {"start": 30, "end": 31, "test": "def test_getSubarrayBeauty():\n    solution = Solution()\n    assert solution.getSubarrayBeauty([-1, -2, -3, -4], 2, 1) == [-1, -2]"}]}
{"task_num": 2662, "task_title": "Minimum Cost of a Path With Special Roads", "func_name": "minimumCost", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\n    return self.dijkstra(specialRoads, *start, *target)\n\n  def dijkstra(self, specialRoads: List[List[int]], srcX: int, srcY: int, dstX: int, dstY: int) -> int:\n    n = len(specialRoads)\n    dist = [math.inf] * n\n    minHeap = []\n\n    for u, (x1, y1, _, _, cost) in enumerate(specialRoads):\n      d = abs(x1 - srcX) + abs(y1 - srcY) + cost\n      dist[u] = d\n      heapq.heappush(minHeap, (dist[u], u))\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      _, _, ux2, uy2, _ = specialRoads[u]\n      for v in range(n):\n        if v == u:\n          continue\n        vx1, vy1, _, _, vcost = specialRoads[v]\n        newDist = d + abs(vx1 - ux2) + abs(vy1 - uy2) + vcost\n        if newDist < dist[v]:\n          dist[v] = newDist\n          heapq.heappush(minHeap, (dist[v], v))\n\n    ans = abs(dstX - srcX) + abs(dstY - srcY)\n    for u in range(n):\n      _, _, x2, y2, _ = specialRoads[u]\n      ans = min(ans, dist[u] + abs(dstX - x2) + abs(dstY - y2))\n\n    return ans\n", "tests": [{"start": 27, "end": 28, "test": "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost([0, 0], [10, 10], [[5, 5, 6, 6, 2]]) == 14"}, {"start": 31, "end": 32, "test": "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost([0, 0], [4, 4], [[1, 1, 2, 2, 5]]) == 8"}, {"start": 35, "end": 37, "test": "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost([0, 0], [10, 10], [[2, 2, 5, 5, 3]]) == 16"}]}
{"task_num": 2663, "task_title": "Lexicographically Smallest Beautiful String", "func_name": "smallestBeautifulString", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def smallestBeautifulString(self, s: str, k: int) -> str:\n    chars = list(s)\n\n    for i in reversed(range(len(chars))):\n      chars[i] = chr(ord(chars[i]) + 1)\n      while self._containsPalindrome(chars, i):\n        chars[i] = chr(ord(chars[i]) + 1)\n      if chars[i] < chr(ord('a') + k):\n        return self._changeSuffix(chars, i + 1)\n\n    return ''\n\n  def _containsPalindrome(self, chars: List[str], i: int) -> bool:\n    return (i > 0 and chars[i] == chars[i - 1]) or (i > 1 and chars[i] == chars[i - 2])\n\n  def _changeSuffix(self, chars: List[str], i: int) -> str:\n    for j in range(i, len(chars)):\n      chars[j] = 'a'\n      while self._containsPalindrome(chars, j):\n        chars[j] = chr(ord(chars[j]) + 1)\n    return ''.join(chars)\n", "tests": [{"start": 19, "end": 20, "test": "def test_smallestBeautifulString():\n    solution = Solution()\n    assert solution.smallestBeautifulString('abc', 3) == 'abd'"}]}
{"task_num": 2672, "task_title": "Number of Adjacent Elements With the Same Color", "func_name": "colorTheArray", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\n    ans = []\n    arr = [0] * n\n    sameColors = 0\n\n    for i, color in queries:\n      if i + 1 < n:\n        if arr[i + 1] > 0 and arr[i + 1] == arr[i]:\n          sameColors -= 1\n        if arr[i + 1] == color:\n          sameColors += 1\n      if i > 0:\n        if arr[i - 1] > 0 and arr[i - 1] == arr[i]:\n          sameColors -= 1\n        if arr[i - 1] == color:\n          sameColors += 1\n      arr[i] = color\n      ans.append(sameColors)\n\n    return ans\n", "tests": [{"start": 18, "end": 22, "test": "def test_colorTheArray():\n    solution = Solution()\n    assert solution.colorTheArray(3, [[0, 1], [1, 2], [1, 1]]) == [0, 1, 2]"}, {"start": 23, "end": 27, "test": "def test_colorTheArray():\n    solution = Solution()\n    assert solution.colorTheArray(3, [[0, 1], [1, 2], [1, 1]]) == [0, 1, 2]"}, {"start": 19, "end": 20, "test": "def test_colorTheArray():\n    solution = Solution()\n    assert solution.colorTheArray(3, [[0, 1], [1, 2], [1, 1]]) == [0, 1, 2]"}, {"start": 21, "end": 22, "test": "def test_colorTheArray():\n    solution = Solution()\n    assert solution.colorTheArray(3, [[0, 1], [1, 2], [1, 1]]) == [0, 1, 2]"}, {"start": 24, "end": 25, "test": "def test_colorTheArray():\n    solution = Solution()\n    assert solution.colorTheArray(3, [[0, 1], [1, 2], [1, 1]]) == [0, 1, 2]"}, {"start": 26, "end": 27, "test": "def test_colorTheArray():\n    solution = Solution()\n    assert solution.colorTheArray(3, [[0, 1], [1, 2], [1, 1]]) == [0, 1, 2]"}]}
{"task_num": 2684, "task_title": "Maximum Number of Moves in a Grid", "func_name": "maxMoves", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxMoves(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n\n    for j in range(n - 2, -1, -1):\n      for i in range(m):\n        if grid[i][j + 1] > grid[i][j]:\n          dp[i][j] = 1 + dp[i][j + 1]\n        if i > 0 and grid[i - 1][j + 1] > grid[i][j]:\n          dp[i][j] = max(dp[i][j], 1 + dp[i - 1][j + 1])\n        if i + 1 < m and grid[i + 1][j + 1] > grid[i][j]:\n          dp[i][j] = max(dp[i][j], 1 + dp[i + 1][j + 1])\n\n    return max(dp[i][0] for i in range(m))\n", "tests": [{"start": 19, "end": 20, "test": "def test_maxMoves():\n    solution = Solution()\n    assert solution.maxMoves([[3, 2, 4], [2, 1, 9], [1, 5, 6]]) == 2"}, {"start": 21, "end": 22, "test": "def test_maxMoves():\n    solution = Solution()\n    grid = [[3, 2, 4], [2, 1, 9], [1, 5, 8]]\n    assert solution.maxMoves(grid) == 2"}, {"start": 23, "end": 24, "test": "def test_maxMoves():\n    solution = Solution()\n    grid = [[3, 2, 4], [2, 1, 9], [1, 5, 8]]\n    assert solution.maxMoves(grid) == 2"}]}
{"task_num": 2685, "task_title": "Count the Number of Complete Components", "func_name": "countCompleteComponents", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n    self.nodeCount = [1] * n\n    self.edgeCount = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    self.edgeCount[i] += 1\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n      self.edgeCount[j] += self.edgeCount[i]\n      self.nodeCount[j] += self.nodeCount[i]\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n      self.edgeCount[i] += self.edgeCount[j]\n      self.nodeCount[i] += self.nodeCount[j]\n    else:\n      self.id[i] = j\n      self.edgeCount[j] += self.edgeCount[i]\n      self.nodeCount[j] += self.nodeCount[i]\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n  def isComplete(self, u):\n    return self.nodeCount[u] * (self.nodeCount[u] - 1) // 2 == self.edgeCount[u]\n\n\nclass Solution:\n  def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\n    ans = 0\n    uf = UnionFind(n)\n    parents = set()\n\n    for u, v in edges:\n      uf.unionByRank(u, v)\n\n    for i in range(n):\n      parent = uf.find(i)\n      if parent not in parents and uf.isComplete(parent):\n        ans += 1\n        parents.add(parent)\n\n    return ans\n", "tests": [{"start": 22, "end": 23, "test": "def test_countCompleteComponents():\n    solution = Solution()\n    assert solution.countCompleteComponents(4, [[0, 1], [1, 2], [2, 3]]) == 0"}, {"start": 24, "end": 27, "test": "def test_countCompleteComponents():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4]]\n    assert solution.countCompleteComponents(n, edges) == 1"}, {"start": 39, "end": 40, "test": "def test_countCompleteComponents():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4]]\n    assert solution.countCompleteComponents(n, edges) == 1"}, {"start": 28, "end": 31, "test": "def test_countCompleteComponents():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4]]\n    assert solution.countCompleteComponents(n, edges) == 1"}, {"start": 32, "end": 36, "test": "def test_countCompleteComponents():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4]]\n    assert solution.countCompleteComponents(n, edges) == 1"}, {"start": 58, "end": 60, "test": "def test_countCompleteComponents():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1], [1, 2], [2, 3]]\n    assert solution.countCompleteComponents(n, edges) == 1"}]}
{"task_num": 2699, "task_title": "Modify Graph Edge Weights", "func_name": "modifiedGraphEdges", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\n\nclass Solution:\n  def modifiedGraphEdges(self, n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:\n    kMax = 2_000_000_000\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      if w == -1:\n        continue\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    distToDestination = self._dijkstra(graph, source, destination)\n    if distToDestination < target:\n      return []\n    if distToDestination == target:\n      for edge in edges:\n        if edge[2] == -1:\n          edge[2] = kMax\n      return edges\n\n    for i, (u, v, w) in enumerate(edges):\n      if w != -1:\n        continue\n      edges[i][2] = 1\n      graph[u].append((v, 1))\n      graph[v].append((u, 1))\n      distToDestination = self._dijkstra(graph, source, destination)\n      if distToDestination <= target:\n        edges[i][2] += target - distToDestination\n        for j in range(i + 1, len(edges)):\n          if edges[j][2] == -1:\n            edges[j][2] = kMax\n        return edges\n\n    return []\n\n  def _dijkstra(self, graph: List[List[int]], src: int, dst: int) -> int:\n    dist = [math.inf] * len(graph)\n    minHeap = []\n    dist[src] = 0\n    heapq.heappush(minHeap, (dist[src], src))\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist[dst]\n", "tests": [{"start": 24, "end": 25, "test": "def test_modifiedGraphEdges():\n    solution = Solution()\n    result = solution.modifiedGraphEdges(3, [[0, 1, -1], [1, 2, -1]], 0, 2, 5)"}, {"start": 26, "end": 30, "test": "def test_modifiedGraphEdges():\n    solution = Solution()\n    result = solution.modifiedGraphEdges(4, [[0, 1, -1], [1, 2, -1], [2, 3, -1]], 0, 3, 6)"}, {"start": 18, "end": 19, "test": "def test_modifiedGraphEdges():\n    solution = Solution()\n    result = solution.modifiedGraphEdges(4, [[0, 1, -1], [1, 2, -1], [2, 3, -1]], 0, 3, 6)"}, {"start": 33, "end": 34, "test": "def test_modifiedGraphEdges():\n    solution = Solution()\n    result = solution.modifiedGraphEdges(5, [[0, 1, -1], [1, 2, -1], [2, 3, -1], [3, 4, -1]], 0, 4, 6)"}, {"start": 39, "end": 44, "test": "def test_modifiedGraphEdges():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, -1], [1, 2, -1], [2, 3, -1], [3, 4, -1]]\n    source = 0\n    destination = 4\n    target = 6\n    expected_output = [[0, 1, 2], [1, 2, 2], [2, 3, 2], [3, 4, 2]]\n    assert solution.modifiedGraphEdges(n, edges, source, destination, target) == expected_output"}, {"start": 56, "end": 57, "test": "def test_modifiedGraphEdges():\n    solution = Solution()\n    result = solution.modifiedGraphEdges(4, [[0, 1, -1], [1, 2, -1], [2, 3, -1]], 0, 3, 6)"}, {"start": 28, "end": 29, "test": "def test_modifiedGraphEdges():\n    solution = Solution()\n    result = solution.modifiedGraphEdges(4, [[0, 1, -1], [1, 2, -1], [2, 3, -1]], 0, 3, 6)"}, {"start": 59, "end": 61, "test": "def test_modifiedGraphEdges():\n    solution = Solution()\n    result = solution.modifiedGraphEdges(4, [[0, 1, -1], [1, 2, -1], [2, 3, -1]], 0, 3, 6)"}, {"start": 42, "end": 43, "test": "def test_modifiedGraphEdges():\n    solution = Solution()\n    result = solution.modifiedGraphEdges(5, [[0, 1, -1], [1, 2, -1], [2, 3, -1], [3, 4, -1]], 0, 4, 6)"}]}
{"task_num": 2708, "task_title": "Maximum Strength of a Group", "func_name": "maxStrength", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxStrength(self, nums: List[int]) -> int:\n    posProd = 1\n    negProd = 1\n    maxNeg = -math.inf\n    negCount = 0\n    hasPos = False\n    hasZero = False\n\n    for num in nums:\n      if num > 0:\n        posProd *= num\n        hasPos = True\n      elif num < 0:\n        negProd *= num\n        maxNeg = max(maxNeg, num)\n        negCount += 1\n      else:\n        hasZero = True\n\n    if negCount == 0 and not hasPos:\n      return 0\n    if negCount % 2 == 0:\n      return negProd * posProd\n    if negCount >= 3:\n      return negProd // maxNeg * posProd\n    if hasPos:\n      return posProd\n    if hasZero:\n      return 0\n    return maxNeg\n", "tests": [{"start": 31, "end": 32, "test": "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([0, -1, -2]) == 0"}, {"start": 33, "end": 34, "test": "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([-1, -2, -3, 4]) == 24"}, {"start": 35, "end": 36, "test": "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([-1, -2, -3, 4]) == 6"}, {"start": 37, "end": 38, "test": "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([1, 2, -3, 4]) == 24"}, {"start": 39, "end": 40, "test": "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([0, -1, -2]) == 0"}, {"start": 21, "end": 23, "test": "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([1, 2, 3]) == 6"}, {"start": 24, "end": 27, "test": "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([-1, -2, -3, -4]) == 24"}, {"start": 28, "end": 29, "test": "def test_maxStrength():\n    solution = Solution()\n    assert solution.maxStrength([0, 0, 0]) == 0"}]}
{"task_num": 2709, "task_title": "Greatest Common Divisor Traversal", "func_name": "canTraverseAllPairs", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.sz = [1] * n\n\n  def unionBySize(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.sz[i] < self.sz[j]:\n      self.sz[j] += self.sz[i]\n      self.id[i] = j\n    else:\n      self.sz[i] += self.sz[j]\n      self.id[j] = i\n\n  def getSize(self, i: int) -> int:\n    return self.sz[i]\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def canTraverseAllPairs(self, nums: List[int]) -> bool:\n    n = len(nums)\n    max_num = max(nums)\n    maxPrimeFactor = self._sieveEratosthenes(max_num + 1)\n    primeToFirstIndex = collections.defaultdict(int)\n    uf = UnionFind(n)\n\n    for i, num in enumerate(nums):\n      for prime_factor in self._getPrimeFactors(num, maxPrimeFactor):\n        if prime_factor in primeToFirstIndex:\n          uf.unionBySize(primeToFirstIndex[prime_factor], i)\n        else:\n          primeToFirstIndex[prime_factor] = i\n\n    return any(uf.getSize(i) == n for i in range(n))\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeFactors(self, num: int, minPrimeFactors: List[int]) -> List[int]:\n    primeFactors = []\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      primeFactors.append(divisor)\n      while num % divisor == 0:\n        num //= divisor\n    return primeFactors\n", "tests": [{"start": 19, "end": 20, "test": "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([1, 1]) == True"}, {"start": 21, "end": 23, "test": "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([10, 20, 40]) == True"}, {"start": 24, "end": 26, "test": "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([10, 20, 40]) == True"}, {"start": 32, "end": 33, "test": "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([2, 4, 8]) == True"}, {"start": 57, "end": 59, "test": "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([2, 4, 8]) == True"}, {"start": 47, "end": 48, "test": "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([2, 4, 8]) == True"}, {"start": 49, "end": 50, "test": "def test_canTraverseAllPairs():\n    solution = Solution()\n    assert solution.canTraverseAllPairs([2, 4, 8]) == True"}]}
{"task_num": 2736, "task_title": "Maximum Sum Queries", "func_name": "maximumSumQueries", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Pair:\n  def __init__(self, x: int, y: int):\n    self.x = x\n    self.y = y\n\n  def __iter__(self):\n    yield self.x\n    yield self.y\n\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, minX: int, minY: int):\n    self.queryIndex = queryIndex\n    self.minX = minX\n    self.minY = minY\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.minX\n    yield self.minY\n\n\nclass Solution:\n  def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n    pairs = sorted([Pair(nums1[i], nums2[i])\n                   for i in range(len(nums1))], key=lambda p: p.x, reverse=True)\n    ans = [0] * len(queries)\n    stack = []  # [(y, x + y)]\n\n    pairsIndex = 0\n    for queryIndex, minX, minY in sorted([IndexedQuery(i, query[0], query[1]) for i, query in enumerate(queries)], key=lambda iq: -iq.minX):\n      while pairsIndex < len(pairs) and pairs[pairsIndex].x >= minX:\n        x, y = pairs[pairsIndex]\n        while stack and x + y >= stack[-1][1]:\n          stack.pop()\n        if not stack or y > stack[-1][0]:\n          stack.append((y, x + y))\n        pairsIndex += 1\n      j = self._firstGreaterEqual(stack, minY)\n      if j == len(stack):\n        ans[queryIndex] = -1\n      else:\n        ans[queryIndex] = stack[j][1]\n\n    return ans\n\n  def _firstGreaterEqual(self, A: List[Tuple[int, int]], target: int) -> int:\n    l = 0\n    r = len(A)\n    while l < r:\n      m = (l + r) // 2\n      if A[m][0] >= target:\n        r = m\n      else:\n        l = m + 1\n    return l\n", "tests": [{"start": 50, "end": 51, "test": "def test_maximumSumQueries():\n    solution = Solution()\n    nums1 = [3, 2, 5]\n    nums2 = [2, 4, 1]\n    queries = [[4, 0], [1, 7]]\n    expected = [-1, 9]\n    assert solution.maximumSumQueries(nums1, nums2, queries) == expected"}, {"start": 52, "end": 53, "test": "def test_maximumSumQueries():\n    solution = Solution()\n    nums1 = [4, 3, 2, 7]\n    nums2 = [2, 5, 10, 6]\n    queries = [[3, 2], [1, 10]]\n    expected = [19, -1]\n    assert solution.maximumSumQueries(nums1, nums2, queries) == expected"}, {"start": 62, "end": 63, "test": "def test_maximumSumQueries():\n    solution = Solution()\n    nums1 = [4, 3, 2, 7]\n    nums2 = [2, 5, 10, 6]\n    queries = [[3, 2], [1, 10]]\n    expected = [19, -1]\n    assert solution.maximumSumQueries(nums1, nums2, queries) == expected"}, {"start": 64, "end": 65, "test": "def test_maximumSumQueries():\n    solution = Solution()\n    nums1 = [3, 2, 5]\n    nums2 = [1, 4, 6]\n    queries = [[2, 2], [1, 1]]\n    expected = [8, 7]\n    assert solution.maximumSumQueries(nums1, nums2, queries) == expected"}, {"start": 46, "end": 47, "test": "def test_maximumSumQueries():\n    solution = Solution()\n    nums1 = [3, 5, 2]\n    nums2 = [2, 4, 6]\n    queries = [[2, 3], [1, 1]]\n    expected = [8, -1]\n    assert solution.maximumSumQueries(nums1, nums2, queries) == expected"}]}
{"task_num": 2747, "task_title": "Count Zero Request Servers", "func_name": "countServers", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, query: int):\n    self.queryIndex = queryIndex\n    self.query = query\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.query\n\n\nclass Solution:\n  def countServers(self, n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:\n    ans = [0] * len(queries)\n    count = [0] * (n + 1)\n\n    logs.sort(key=lambda log: log[1])\n\n    i = 0\n    j = 0\n    servers = 0\n\n    for queryIndex, query in sorted([IndexedQuery(i, query) for i, query in enumerate(queries)], key=lambda iq: iq.query):\n      while j < len(logs) and logs[j][1] <= query:\n        count[logs[j][0]] += 1\n        if count[logs[j][0]] == 1:\n          servers += 1\n        j += 1\n      while i < len(logs) and logs[i][1] < query - x:\n        count[logs[i][0]] -= 1\n        if count[logs[i][0]] == 0:\n          servers -= 1\n        i += 1\n      ans[queryIndex] = n - servers\n\n    return ans\n", "tests": [{"start": 35, "end": 36, "test": "def test_countServers():\n    solution = Solution()\n    n = 3\n    logs = [[1, 2], [2, 4], [3, 6]]\n    x = 2\n    queries = [5]\n    expected = [0]\n    assert solution.countServers(n, logs, x, queries) == expected"}, {"start": 40, "end": 41, "test": "def test_countServers():\n    solution = Solution()\n    n = 3\n    logs = [[1, 2], [2, 5], [3, 7]]\n    x = 4\n    queries = [6]\n    expected = [1]\n    assert solution.countServers(n, logs, x, queries) == expected"}]}
{"task_num": 2751, "task_title": "Robot Collisions", "func_name": "survivedRobotsHealths", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\nfrom dataclasses import dataclass\n\n@dataclass\nclass Robot:\n  index: int\n  position: int\n  health: int\n  direction: str\n\n\nclass Solution:\n  def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\n    robots = sorted([Robot(index, position, health, direction) for index, (position, health, direction) in enumerate(zip(positions, healths, directions))], key=lambda robot: robot.position)\n    stack: List[Robot] = []\n\n    for robot in robots:\n      if robot.direction == 'R':\n        stack.append(robot)\n        continue\n      while stack and stack[-1].direction == 'R' and robot.health > 0:\n        if stack[-1].health == robot.health:\n          stack.pop()\n          robot.health = 0\n        elif stack[-1].health < robot.health:\n          stack.pop()\n          robot.health -= 1\n        else:\n          stack[-1].health -= 1\n          robot.health = 0\n      if robot.health > 0:\n        stack.append(robot)\n\n    stack.sort(key=lambda robot: robot.index)\n    return [robot.health for robot in stack]\n", "tests": [{"start": 26, "end": 28, "test": "def test_survivedRobotsHealths():\n    solution = Solution()\n    assert solution.survivedRobotsHealths([1, 2], [10, 5], 'RL') == [10]"}, {"start": 39, "end": 40, "test": "def test_survivedRobotsHealths():\n    solution = Solution()\n    assert solution.survivedRobotsHealths([1, 2], [10, 5], 'RL') == [10]"}, {"start": 30, "end": 32, "test": "def test_survivedRobotsHealths():\n    solution = Solution()\n    assert solution.survivedRobotsHealths([1, 2], [1, 1], 'RL') == [0, 0]"}, {"start": 33, "end": 35, "test": "def test_survivedRobotsHealths():\n    solution = Solution()\n    assert solution.survivedRobotsHealths([1, 3], [5, 2], 'RL') == [1]"}, {"start": 36, "end": 38, "test": "def test_survivedRobotsHealths():\n    solution = Solution()\n    assert solution.survivedRobotsHealths([1, 2], [10, 5], 'RL') == [5]"}]}
{"task_num": 2812, "task_title": "Find the Safest Path in a Grid", "func_name": "maximumSafenessFactor", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumSafenessFactor(self, grid: List[List[int]]) -> int:\n    self.dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    n = len(grid)\n    distToThief = self._getDistToThief(grid)\n\n    def hasValidPath(safeness: int) -> bool:\n      if distToThief[0][0] < safeness:\n        return False\n\n      q = collections.deque([(0, 0)])\n      seen = {(0, 0)}\n\n      while q:\n        i, j = q.popleft()\n        if distToThief[i][j] < safeness:\n          continue\n        if i == n - 1 and j == n - 1:\n          return True\n        for dx, dy in self.dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == n or y < 0 or y == n:\n            continue\n          if (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n\n      return False\n\n    return bisect.bisect_left(range(n * 2), True, key=lambda m: not hasValidPath(m)) - 1\n\n  def _getDistToThief(self, grid: List[List[int]]) -> List[List[int]]:\n    n = len(grid)\n    distToThief = [[0] * n for _ in range(n)]\n    q = collections.deque()\n    seen = set()\n\n    for i in range(n):\n      for j in range(n):\n        if grid[i][j] == 1:\n          q.append((i, j))\n          seen.add((i, j))\n\n    dist = 0\n    while q:\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        distToThief[i][j] = dist\n        for dx, dy in self.dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == n or y < 0 or y == n:\n            continue\n          if (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n      dist += 1\n\n    return distToThief\n", "tests": [{"start": 18, "end": 19, "test": "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[1, 0, 0], [0, 0, 0], [0, 0, 0]]\n    assert solution.maximumSafenessFactor(grid) == 2"}, {"start": 26, "end": 27, "test": "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[0, 1, 0], [0, 0, 0], [0, 0, 0]]\n    assert solution.maximumSafenessFactor(grid) == 2"}, {"start": 28, "end": 29, "test": "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n    assert solution.maximumSafenessFactor(grid) == 2"}, {"start": 52, "end": 54, "test": "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[1, 0, 0], [0, 0, 0], [0, 0, 0]]\n    assert solution.maximumSafenessFactor(grid) == 2"}, {"start": 33, "end": 34, "test": "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[1, 0, 0], [0, 0, 0], [0, 0, 0]]\n    assert solution.maximumSafenessFactor(grid) == 2"}, {"start": 35, "end": 36, "test": "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[0, 1, 0], [0, 0, 0], [0, 0, 0]]\n    assert solution.maximumSafenessFactor(grid) == 2"}, {"start": 64, "end": 65, "test": "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[1, 0, 0], [0, 0, 0], [0, 0, 0]]\n    assert solution.maximumSafenessFactor(grid) == 2"}, {"start": 66, "end": 67, "test": "def test_maximumSafenessFactor():\n    solution = Solution()\n    grid = [[0, 1, 0], [0, 0, 0], [0, 0, 0]]\n    assert solution.maximumSafenessFactor(grid) == 2"}]}
{"task_num": 2818, "task_title": "Apply Operations to Maximize Score", "func_name": "maximumScore", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumScore(self, nums: List[int], k: int) -> int:\n    kMod = 1_000_000_007\n    n = len(nums)\n    ans = 1\n    minPrimeFactors = self._sieveEratosthenes(max(nums) + 1)\n    primeScores = [self._getPrimeScore(num, minPrimeFactors) for num in nums]\n    left = [-1] * n\n    right = [n] * n\n    stack = []\n\n    for i in reversed(range(n)):\n      while stack and primeScores[stack[-1]] <= primeScores[i]:\n        left[stack.pop()] = i\n      stack.append(i)\n\n    stack = []\n\n    for i in range(n):\n      while stack and primeScores[stack[-1]] < primeScores[i]:\n        right[stack.pop()] = i\n      stack.append(i)\n\n    numAndIndexes = [(num, i) for i, num in enumerate(nums)]\n\n    def modPow(x: int, n: int) -> int:\n      if n == 0:\n        return 1\n      if n & 1:\n        return x * modPow(x, n - 1) % kMod\n      return modPow(x * x % kMod, n // 2)\n\n    for num, i in sorted(numAndIndexes, key=lambda x: (-x[0], x[1])):\n      rangeCount = (i - left[i]) * (right[i] - i)\n      actualCount = min(rangeCount, k)\n      k -= actualCount\n      ans *= modPow(num, actualCount)\n      ans %= kMod\n\n    return ans\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeScore(self, num: int, minPrimeFactors: List[int]) -> int:\n    primeFactors = set()\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      primeFactors.add(divisor)\n      while num % divisor == 0:\n        num //= divisor\n    return len(primeFactors)\n", "tests": [{"start": 37, "end": 38, "test": "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([1], 0) == 1"}, {"start": 39, "end": 40, "test": "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([300], 1) == 300"}, {"start": 55, "end": 57, "test": "def test_maximumScore():\n    solution = Solution()\n    assert solution.maximumScore([2, 3, 5, 7, 11], 4) == 105"}]}
{"task_num": 2836, "task_title": "Maximize Value of Function in a Ball Passing Game", "func_name": "getMaxFunctionValue", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:\n    n = len(receiver)\n    m = int(math.log2(k)) + 1\n    ans = 0\n    jump = [[0] * m for _ in range(n)]\n    summ = [[0] * m for _ in range(n)]\n\n    for i in range(n):\n      jump[i][0] = receiver[i]\n      summ[i][0] = receiver[i]\n\n    for j in range(1, m):\n      for i in range(n):\n        midNode = jump[i][j - 1]\n        jump[i][j] = jump[midNode][j - 1]\n        summ[i][j] = summ[i][j - 1] + summ[midNode][j - 1]\n\n    for i in range(n):\n      currSum = i\n      currPos = i\n      for j in range(m):\n        if (k >> j) & 1 == 1:\n          currSum += summ[currPos][j]\n          currPos = jump[currPos][j]\n      ans = max(ans, currSum)\n\n    return ans\n", "tests": [{"start": 33, "end": 35, "test": "def test_getMaxFunctionValue():\n    solution = Solution()\n    assert solution.getMaxFunctionValue([1, 2, 3], 3) == 6"}]}
{"task_num": 2844, "task_title": "Minimum Operations to Make a Special Number", "func_name": "minimumOperations", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumOperations(self, num: str) -> int:\n    n = len(num)\n    seenFive = False\n    seenZero = False\n\n    for i in range(n - 1, -1, -1):\n      if seenZero and num[i] == '0':\n        return n - i - 2\n      if seenZero and num[i] == '5':\n        return n - i - 2\n      if seenFive and num[i] == '2':\n        return n - i - 2\n      if seenFive and num[i] == '7':\n        return n - i - 2\n      seenZero = seenZero or num[i] == '0'\n      seenFive = seenFive or num[i] == '5'\n\n    if seenZero:\n      return n - 1\n    else:\n      return n\n", "tests": [{"start": 29, "end": 30, "test": "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('50') == 1"}, {"start": 31, "end": 32, "test": "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('123456789') == 9"}, {"start": 18, "end": 19, "test": "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('50') == 1"}, {"start": 20, "end": 21, "test": "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('05') == 1"}, {"start": 22, "end": 23, "test": "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('1052') == 2"}, {"start": 24, "end": 25, "test": "def test_minimumOperations():\n    solution = Solution()\n    assert solution.minimumOperations('1057') == 3"}]}
{"task_num": 2846, "task_title": "Minimum Edge Weight Equilibrium Queries in a Tree", "func_name": "minOperationsQueries", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minOperationsQueries(self, n: int, edges: List[List[int]], queries: List[List[int]]) -> List[int]:\n    kMax = 26\n    m = int(math.log2(n)) + 1\n    ans = []\n    graph = [[] for _ in range(n)]\n    jump = [[0] * m for _ in range(n)]\n    count = [[] for _ in range(n)]\n    depth = [0] * n\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    def dfs(u: int, prev: int, d: int):\n      if prev != -1:\n        jump[u][0] = prev\n      depth[u] = d\n      for v, w in graph[u]:\n        if v == prev:\n          continue\n        count[v] = count[u][:]\n        count[v][w] += 1\n        dfs(v, u, d + 1)\n\n    count[0] = [0] * (kMax + 1)\n    dfs(0, -1, 0)\n\n    for j in range(1, m):\n      for i in range(n):\n        jump[i][j] = jump[jump[i][j - 1]][j - 1]\n\n    def getLCA(u: int, v: int) -> int:\n      if depth[u] > depth[v]:\n        return getLCA(v, u)\n      for j in range(m):\n        if depth[v] - depth[u] >> j & 1:\n          v = jump[v][j]\n      if u == v:\n        return u\n      for j in range(m - 1, -1, -1):\n        if jump[u][j] != jump[v][j]:\n          u = jump[u][j]\n          v = jump[v][j]\n      return jump[v][0]\n\n    for u, v in queries:\n      lca = getLCA(u, v)\n      numEdges = depth[u] + depth[v] - 2 * depth[lca]\n      maxFreq = max(count[u][j] + count[v][j] - 2 * count[lca][j] for j in range(1, kMax + 1))\n      ans.append(numEdges - maxFreq)\n\n    return ans\n", "tests": [{"start": 26, "end": 27, "test": "def test_minOperationsQueries():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 1], [1, 2, 1]]\n    queries = [[0, 2]]\n    expected = [0]\n    assert solution.minOperationsQueries(n, edges, queries) == expected"}, {"start": 44, "end": 45, "test": "def test_minOperationsQueries():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 2], [1, 2, 3]]\n    queries = [[0, 2]]\n    expected = [1]\n    assert solution.minOperationsQueries(n, edges, queries) == expected"}, {"start": 49, "end": 50, "test": "def test_minOperationsQueries():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 1], [1, 2, 1]]\n    queries = [[0, 2]]\n    expected = [0]\n    assert solution.minOperationsQueries(n, edges, queries) == expected"}, {"start": 30, "end": 31, "test": "def test_minOperationsQueries():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 1], [1, 2, 1], [2, 3, 1]]\n    queries = [[0, 3]]\n    expected = [0]\n    assert solution.minOperationsQueries(n, edges, queries) == expected"}, {"start": 47, "end": 48, "test": "def test_minOperationsQueries():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5]]\n    queries = [[0, 4], [1, 3]]\n    expected = [6, 4]\n    assert solution.minOperationsQueries(n, edges, queries) == expected"}, {"start": 52, "end": 54, "test": "def test_minOperationsQueries():\n    solution = Solution()\n    n = 7\n    edges = [[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7]]\n    queries = [[0, 6], [1, 3], [2, 5]]\n    expected = [3, 2, 1]\n    assert solution.minOperationsQueries(n, edges, queries) == expected"}]}
{"task_num": 2850, "task_title": "Minimum Moves to Spread Stones Over Grid", "func_name": "minimumMoves", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumMoves(self, grid: List[List[int]]) -> int:\n    if sum(row.count(0) for row in grid) == 0:\n      return 0\n\n    ans = math.inf\n\n    for i in range(3):\n      for j in range(3):\n        if grid[i][j] == 0:\n          for x in range(3):\n            for y in range(3):\n              if grid[x][y] > 1:\n                grid[x][y] -= 1\n                grid[i][j] += 1\n                ans = min(ans, abs(x - i) + abs(y - j) + self.minimumMoves(grid))\n                grid[x][y] += 1\n                grid[i][j] -= 1\n\n    return ans\n", "tests": [{"start": 13, "end": 14, "test": "def test_minimumMoves():\n    solution = Solution()\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    assert solution.minimumMoves(grid) == 0"}, {"start": 20, "end": 28, "test": "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 3, 0], [2, 1, 1], [1, 1, 1]]\n    assert solution.minimumMoves(grid) == 4"}, {"start": 23, "end": 28, "test": "def test_minimumMoves():\n    solution = Solution()\n    grid = [[0, 0, 0], [2, 1, 1], [1, 1, 1]]\n    assert solution.minimumMoves(grid) == 4"}]}
{"task_num": 2851, "task_title": "String Transformation", "func_name": "numberOfWays", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numberOfWays(self, s: str, t: str, k: int) -> int:\n    kMod = 1_000_000_007\n    n = len(s)\n    negOnePowK = 1 if k % 2 == 0 else -1  # (-1)^k\n    z = self._zFunction(s + t + t)\n\n    indices = [i - n for i in range(n, n + n) if z[i] >= n]\n    dp = [0] * 2\n    dp[1] = (pow(n - 1, k, kMod) - negOnePowK) * pow(n, kMod - 2, kMod)\n    dp[0] = dp[1] + negOnePowK\n    res = 0\n    for index in indices:\n      if index == 0:\n        res += dp[0]\n      else: \n        res += dp[1]\n    return res % kMod\n\n\n  def _zFunction(self, s: str) -> List[int]:\n    n = len(s)\n    z = [0] * n\n    l = 0\n    r = 0\n    for i in range(1, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l])\n      while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n    return z\n", "tests": [{"start": 24, "end": 25, "test": "def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('abc', 'cba', 1) == 2"}, {"start": 26, "end": 27, "test": "def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('abc', 'cba', 1) == 2"}, {"start": 37, "end": 38, "test": "def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('abc', 'cba', 2) == 0"}, {"start": 41, "end": 43, "test": "def test_numberOfWays():\n    solution = Solution()\n    assert solution.numberOfWays('abc', 'cba', 2) == 1"}]}
{"task_num": 2876, "task_title": "Count Visited Nodes in a Directed Graph", "func_name": "countVisitedNodes", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countVisitedNodes(self, edges: List[int]) -> List[int]:\n    n = len(edges)\n    ans = [0] * n\n    inDegrees = [0] * n\n    seen = [False] * n\n    stack = []\n\n    for v in edges:\n      inDegrees[v] += 1\n\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n\n    while q:\n      u = q.popleft()\n      inDegrees[edges[u]] -= 1\n      if inDegrees[edges[u]] == 0:\n        q.append(edges[u])\n      stack.append(u)\n      seen[u] = True\n\n    for i in range(n):\n      if not seen[i]:\n        self._fillCycle(edges, i, seen, ans)\n\n    while stack:\n      u = stack.pop()\n      ans[u] = ans[edges[u]] + 1\n\n    return ans\n\n  def _fillCycle(self, edges: List[int], start: int, seen: List[bool], ans: List[int]) -> None:\n    cycleLength = 0\n    u = start\n    while not seen[u]:\n      cycleLength += 1\n      seen[u] = True\n      u = edges[u]\n    ans[start] = cycleLength\n    u = edges[start]\n    while u != start:\n      ans[u] = cycleLength\n      u = edges[u]\n", "tests": [{"start": 27, "end": 28, "test": "def test_countVisitedNodes():\n    solution = Solution()\n    edges = [1, 2, 3, 4, 0]\n    expected = [5, 1, 1, 1, 1]\n    assert solution.countVisitedNodes(edges) == expected"}, {"start": 33, "end": 34, "test": "def test_countVisitedNodes():\n    solution = Solution()\n    edges = [1, 2, 0, 3]\n    expected = [4, 3, 2, 1]\n    assert solution.countVisitedNodes(edges) == expected"}]}
{"task_num": 2901, "task_title": "Longest Unequal Adjacent Groups Subsequence II", "func_name": "getWordsInLongestSubsequence", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def getWordsInLongestSubsequence(self, words: List[str], groups: List[int]) -> List[str]:\n    ans = []\n    n=len(words)\n    dp = [1] * n\n    prev = [-1] * n\n\n    for i in range(1, n):\n      for j in range(i):\n        if groups[i] == groups[j]:\n          continue\n        if len(words[i]) != len(words[j]):\n          continue\n        if sum(a != b for a, b in zip(words[i], words[j])) != 1:\n          continue\n        if dp[i] < dp[j] + 1:\n          dp[i] = dp[j] + 1\n          prev[i] = j\n\n    index = dp.index(max(dp))\n    while index != -1:\n      ans.append(words[index])\n      index = prev[index]\n\n    return ans[::-1]\n", "tests": [{"start": 20, "end": 21, "test": "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = ['abc', 'bcd', 'cde']\n    groups = [1, 2, 3]\n    assert solution.getWordsInLongestSubsequence(words, groups) == ['abc', 'bcd', 'cde']"}, {"start": 22, "end": 23, "test": "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = ['abc', 'bcd', 'cde']\n    groups = [1, 2, 3]\n    assert solution.getWordsInLongestSubsequence(words, groups) == ['abc', 'bcd', 'cde']"}, {"start": 24, "end": 25, "test": "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    assert solution.getWordsInLongestSubsequence(['abc', 'acb', 'bac'], [1, 2, 3]) == ['abc', 'acb']"}, {"start": 26, "end": 28, "test": "def test_getWordsInLongestSubsequence():\n    solution = Solution()\n    words = ['abc', 'acb', 'bac']\n    groups = [1, 2, 3]\n    assert solution.getWordsInLongestSubsequence(words, groups) == ['abc', 'acb'], 'Test case failed'"}]}
{"task_num": 2904, "task_title": "Shortest and Lexicographically Smallest Beautiful String", "func_name": "shortestBeautifulSubstring", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def shortestBeautifulSubstring(self, s: str, k: int) -> str:\n    bestLeft = -1\n    minLength = len(s) + 1\n    ones = 0\n\n    l = 0\n    for r, c in enumerate(s):\n      if c == '1':\n        ones += 1\n      while ones == k:\n        if r - l + 1 < minLength:\n          bestLeft = l\n          minLength = r - l + 1\n        elif r - l + 1 == minLength and s[l:l + minLength] < s[bestLeft:bestLeft + minLength]:\n          bestLeft = l\n        if s[l] == '1':\n          ones -= 1\n        l += 1\n\n    if bestLeft == -1:\n      return \"\"\n    else:\n      return s[bestLeft:bestLeft + minLength]\n", "tests": [{"start": 31, "end": 32, "test": "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('000', 1) == ''"}, {"start": 33, "end": 34, "test": "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('1001110', 3) == '111'"}, {"start": 19, "end": 20, "test": "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('110101', 2) == '101'"}, {"start": 22, "end": 24, "test": "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('000111000', 3) == '111'"}, {"start": 27, "end": 28, "test": "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('000111000', 3) == '111'"}, {"start": 25, "end": 26, "test": "def test_shortestBeautifulSubstring():\n    solution = Solution()\n    assert solution.shortestBeautifulSubstring('1001110', 3) == '111'"}]}
{"task_num": 2911, "task_title": "Minimum Changes to Make K Semi-palindromes", "func_name": "minimumChanges", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumChanges(self, s: str, k: int) -> int:\n    n = len(s)\n    factors = self._getFactors(n)\n    cost = self._getCost(s, n, factors)\n    dp = [[n] * (k + 1) for _ in range(n + 1)]\n\n    dp[n][0] = 0\n\n    for i in range(n - 1, -1, -1):\n      for j in range(1, k + 1):\n        for l in range(i + 1, n):\n          dp[i][j] = min(dp[i][j], dp[l + 1][j - 1] + cost[i][l])\n\n    return dp[0][k]\n\n  def _getFactors(self, n: int) -> List[List[int]]:\n    factors = [[1] for _ in range(n + 1)]\n    for d in range(2, n):\n      for i in range(d * 2, n + 1, d):\n        factors[i].append(d)\n    return factors\n\n  def _getCost(self, s: str, n: int, factors: List[List[int]]) -> List[List[int]]:\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n      for j in range(i + 1, n):\n        length = j - i + 1\n        minCost = length\n        for d in factors[length]:\n          minCost = min(minCost, self._getCostD(s, i, j, d))\n        cost[i][j] = minCost\n    return cost\n\n  def _getCostD(self, s: str, i: int, j: int, d: int) -> int:\n    cost = 0\n    for offset in range(d):\n      l = i + offset\n      r = j - d + 1 + offset\n      while l < r:\n        if s[l] != s[r]:\n          cost += 1\n        l += d\n        r -= d\n    return cost\n", "tests": [{"start": 51, "end": 52, "test": "def test_minimumChanges():\n    solution = Solution()\n    assert solution.minimumChanges('abcabc', 3) == 0"}]}
{"task_num": 2932, "task_title": "Maximum Strong Pair XOR I", "func_name": "maximumStrongPairXor", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Optional\n\nclass TrieNode:\n  def __init__(self):\n    self.children: List[Optional[TrieNode]] = [None] * 2\n    self.min = math.inf\n    self.max = -math.inf\n\n\nclass BitTrie:\n  def __init__(self, maxBit: int):\n    self.maxBit = maxBit\n    self.root = TrieNode()\n\n  def insert(self, num: int) -> None:\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n      node.min = min(node.min, num)\n      node.max = max(node.max, num)\n\n  def getMaxXor(self, x: int) -> int:\n    maxXor = 0\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = x >> i & 1\n      toggleBit = bit ^ 1\n      if node.children[toggleBit] and node.children[toggleBit].max > x and node.children[toggleBit].min <= 2 * x:\n        maxXor = maxXor | 1 << i\n        node = node.children[toggleBit]\n      elif node.children[bit]:\n        node = node.children[bit]\n      else:\n        return 0\n    return maxXor\n\n\nclass Solution:\n  def maximumStrongPairXor(self, nums: List[int]) -> int:\n    maxNum = max(nums)\n    maxBit = int(math.log2(maxNum))\n    bitTrie = BitTrie(maxBit)\n\n    for num in nums:\n      bitTrie.insert(num)\n\n    return max(bitTrie.getMaxXor(num) for num in nums)\n", "tests": [{"start": 27, "end": 28, "test": "def test_maximumStrongPairXor():\n    solution = Solution()\n    assert solution.maximumStrongPairXor([1, 2]) == 0"}, {"start": 39, "end": 41, "test": "def test_maximumStrongPairXor():\n    solution = Solution()\n    nums = [3, 5, 7, 9]\n    assert solution.maximumStrongPairXor(nums) == 6"}, {"start": 42, "end": 43, "test": "def test_maximumStrongPairXor():\n    solution = Solution()\n    assert solution.maximumStrongPairXor([1, 2, 3, 4]) == 3"}, {"start": 44, "end": 45, "test": "def test_maximumStrongPairXor():\n    solution = Solution()\n    assert solution.maximumStrongPairXor([1, 2, 3]) == 0"}]}
{"task_num": 2940, "task_title": "Find Building Where Alice and Bob Can Meet", "func_name": "leftmostBuildingQueries", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, a: int, b: int):\n    self.queryIndex = queryIndex\n    self.a = a\n    self.b = b\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.a\n    yield self.b\n\n\nclass Solution:\n  def leftmostBuildingQueries(self, heights: List[int], queries: List[List[int]]) -> List[int]:\n    ans = [-1] * len(queries)\n    stack = []\n\n    heightsIndex = len(heights) - 1\n    for queryIndex, a, b in sorted([IndexedQuery(i, min(a, b), max(a, b)) for i, (a, b) in enumerate(queries)], key=lambda iq: -iq.b):\n      if a == b or heights[a] < heights[b]:\n        ans[queryIndex] = b\n      else:\n        while heightsIndex > b:\n          while stack and heights[stack[-1]] <= heights[heightsIndex]:\n            stack.pop()\n          stack.append(heightsIndex)\n          heightsIndex -= 1\n        j = self._lastGreater(stack, a, heights)\n        if j != -1:\n          ans[queryIndex] = stack[j]\n\n    return ans\n\n  def _lastGreater(self, A: List[int], target: int, heights: List[int]):\n    l = -1\n    r = len(A) - 1\n    while l < r:\n      m = (l + r + 1) // 2\n      if heights[A[m]] > heights[target]:\n        l = m\n      else:\n        r = m - 1\n    return l\n", "tests": [{"start": 30, "end": 31, "test": "def test_leftmostBuildingQueries():\n    solution = Solution()\n    assert solution.leftmostBuildingQueries([5, 2, 3, 4], [[0, 1], [1, 2], [2, 3]]) == [-1, -1, 3]"}, {"start": 32, "end": 40, "test": "def test_leftmostBuildingQueries():\n    solution = Solution()\n    heights = [3, 5, 2, 4, 6]\n    queries = [[0, 4], [1, 2], [2, 3]]\n    expected = [4, -1, 4]\n    assert solution.leftmostBuildingQueries(heights, queries) == expected"}, {"start": 49, "end": 50, "test": "def test_leftmostBuildingQueries():\n    solution = Solution()\n    heights = [1, 2, 3, 4, 5]\n    queries = [[0, 4], [1, 3]]\n    expected = [4, 3]\n    assert solution.leftmostBuildingQueries(heights, queries) == expected"}, {"start": 51, "end": 52, "test": "def test_leftmostBuildingQueries():\n    solution = Solution()\n    heights = [3, 4, 8, 7, 2]\n    queries = [[0, 1], [1, 2], [2, 3], [3, 4]]\n    expected = [1, 2, 3, -1]\n    assert solution.leftmostBuildingQueries(heights, queries) == expected"}, {"start": 39, "end": 40, "test": "def test_leftmostBuildingQueries():\n    solution = Solution()\n    heights = [3, 5, 2, 4, 6]\n    queries = [[0, 1], [1, 2], [2, 3], [3, 4]]\n    expected = [1, -1, 3, 4]\n    assert solution.leftmostBuildingQueries(heights, queries) == expected"}]}
{"task_num": 2948, "task_title": "Make Lexicographically Smallest Array by Swapping Elements", "func_name": "lexicographicallySmallestArray", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def lexicographicallySmallestArray(self, nums: List[int], limit: int) -> List[int]:\n    ans = [0] * len(nums)\n    numAndIndexes = sorted([(num, i) for i, num in enumerate(nums)])\n    numAndIndexesGroups: List[List[Tuple[int, int]]] = []\n\n    for numAndIndex in numAndIndexes:\n      if not numAndIndexesGroups or numAndIndex[0] - numAndIndexesGroups[-1][-1][0] > limit:\n        numAndIndexesGroups.append([numAndIndex])\n      else:\n        numAndIndexesGroups[-1].append(numAndIndex)\n\n    for numAndIndexesGroup in numAndIndexesGroups:\n      sortedNums = [num for num, _ in numAndIndexesGroup]\n      sortedIndices = sorted([index for _, index in numAndIndexesGroup])\n      for num, index in zip(sortedNums, sortedIndices):\n        ans[index] = num\n\n    return ans\n", "tests": [{"start": 18, "end": 19, "test": "def test_lexicographicallySmallestArray():\n    solution = Solution()\n    assert solution.lexicographicallySmallestArray([1, 3, 2], 1) == [1, 2, 3]"}, {"start": 20, "end": 21, "test": "def test_lexicographicallySmallestArray():\n    solution = Solution()\n    assert solution.lexicographicallySmallestArray([3, 2, 1], 1) == [1, 2, 3]"}]}
{"task_num": 2953, "task_title": "Count Complete Substrings", "func_name": "countCompleteSubstrings", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countCompleteSubstrings(self, word: str, k: int) -> int:\n    uniqueLetters = len(set(word))\n    return sum(self._countCompleteStrings(word, k, windowSize) for windowSize in range(k, k * uniqueLetters + 1, k))\n\n  def _countCompleteStrings(self, word: str, k: int, windowSize: int) -> int:\n    res = 0\n    countLetters = 0\n    count = collections.Counter()\n\n    for i, c in enumerate(word):\n      count[c] += 1\n      countLetters += 1\n      if i > 0 and abs(ord(c) - ord(word[i - 1])) > 2:\n        count = collections.Counter()\n        count[c] += 1\n        countLetters = 1\n      if countLetters == windowSize + 1:\n        count[word[i - windowSize]] -= 1\n        countLetters -= 1\n      if countLetters == windowSize:\n        res += all(freq == 0 or freq == k for freq in count.values())\n\n    return res\n", "tests": [{"start": 24, "end": 27, "test": "def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings('abcde', 1) == 5"}, {"start": 28, "end": 30, "test": "def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings('abcabc', 2) == 4"}, {"start": 31, "end": 32, "test": "def test_countCompleteSubstrings():\n    solution = Solution()\n    assert solution.countCompleteSubstrings('abcabc', 2) == 4"}]}
{"task_num": 2959, "task_title": "Number of Possible Sets of Closing Branches", "func_name": "numberOfSets", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:\n    return sum(self._floydWarshall(n, maxDistance, roads, mask) <= maxDistance for mask in range(1 << n))\n\n  def _floydWarshall(self, n: int, maxDistanceThreshold: int, roads: List[List[int]], mask: int) -> List[List[int]]:\n    maxDistance = 0\n    dist = [[maxDistanceThreshold + 1] * n for _ in range(n)]\n\n    for i in range(n):\n      if mask >> i & 1:\n        dist[i][i] = 0\n\n    for u, v, w in roads:\n      if mask >> u & 1 and mask >> v & 1:\n        dist[u][v] = min(dist[u][v], w)\n        dist[v][u] = min(dist[v][u], w)\n\n    for k in range(n):\n      if mask >> k & 1:\n        for i in range(n):\n          if mask >> i & 1:\n            for j in range(n):\n              if mask >> j & 1:\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    for i in range(n):\n      if mask >> i & 1:\n        for j in range(i + 1, n):\n          if mask >> j & 1:\n            maxDistance = max(maxDistance, dist[i][j])\n\n    return maxDistance\n", "tests": [{"start": 20, "end": 21, "test": "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(3, 4, [[0, 1, 2], [1, 2, 3]]) == 4"}, {"start": 24, "end": 26, "test": "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(4, 10, [[0, 1, 5], [1, 2, 3], [2, 3, 8], [0, 3, 7]]) == 6"}, {"start": 29, "end": 34, "test": "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(4, 10, [[0, 1, 5], [1, 2, 3], [2, 3, 8], [0, 3, 7]]) == 6"}, {"start": 37, "end": 40, "test": "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(3, 1, [[0, 1, 2], [1, 2, 1]]) == 4"}, {"start": 31, "end": 34, "test": "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(3, 10, [[0, 1, 5], [1, 2, 5]]) == 4"}, {"start": 39, "end": 40, "test": "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(3, 1, [[0, 1, 2], [1, 2, 1]]) == 4"}, {"start": 33, "end": 34, "test": "def test_numberOfSets():\n    solution = Solution()\n    assert solution.numberOfSets(4, 10, [[0, 1, 5], [1, 2, 3], [2, 3, 8], [0, 3, 7]]) == 6"}]}
{"task_num": 2973, "task_title": "Find Number of Coins to Place in Tree Nodes", "func_name": "placedCoins", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass ChildCost:\n  def __init__(self, cost: int):\n    self.numNodes = 1\n    self.maxPosCosts = [cost] if cost > 0 else []\n    self.minNegCosts = [cost] if cost < 0 else []\n\n  def update(self, childCost: 'ChildCost') -> None:\n    self.numNodes += childCost.numNodes\n    self.maxPosCosts.extend(childCost.maxPosCosts)\n    self.minNegCosts.extend(childCost.minNegCosts)\n    self.maxPosCosts.sort(reverse=True)\n    self.minNegCosts.sort()\n    self.maxPosCosts = self.maxPosCosts[:3]\n    self.minNegCosts = self.minNegCosts[:2]\n\n  def maxProduct(self) -> int:\n    if self.numNodes < 3:\n      return 1\n    if not self.maxPosCosts:\n      return 0\n    res = 0\n    if len(self.maxPosCosts) == 3:\n      res = self.maxPosCosts[0] * self.maxPosCosts[1] * self.maxPosCosts[2]\n    if len(self.minNegCosts) == 2:\n      res = max(res, self.minNegCosts[0] * self.minNegCosts[1] * self.maxPosCosts[0])\n    return res\n\n\nclass Solution:\n  def placedCoins(self, edges: List[List[int]], cost: List[int]) -> List[int]:\n    n = len(cost)\n    ans = [0] * n\n    tree = [[] for _ in range(n)]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, prev: int) -> None:\n      res = ChildCost(cost[u])\n      for v in tree[u]:\n        if v != prev:\n          res.update(dfs(v, u))\n      ans[u] = res.maxProduct()\n      return res\n\n    dfs(0, -1)\n    return ans\n", "tests": [{"start": 27, "end": 28, "test": "def test_placedCoins():\n    solution = Solution()\n    edges = [[0, 1], [0, 2]]\n    cost = [-1, -2, -3]\n    expected = [0, 0, 0]\n    assert solution.placedCoins(edges, cost) == expected"}, {"start": 29, "end": 30, "test": "def test_placedCoins():\n    solution = Solution()\n    edges = [[0, 1], [0, 2]]\n    cost = [-1, -1, -1]\n    expected = [0, 0, 0]\n    assert solution.placedCoins(edges, cost) == expected"}, {"start": 32, "end": 33, "test": "def test_placedCoins():\n    solution = Solution()\n    edges = [[0, 1], [0, 2]]\n    cost = [-1, -2, -3]\n    expected = [0, 0, 0]\n    assert solution.placedCoins(edges, cost) == expected"}, {"start": 34, "end": 35, "test": "def test_placedCoins():\n    solution = Solution()\n    edges = [[0, 1], [0, 2]]\n    cost = [-1, -2, 3]\n    expected = [0, 0, 6]\n    assert solution.placedCoins(edges, cost) == expected"}, {"start": 52, "end": 53, "test": "def test_placedCoins():\n    solution = Solution()\n    edges = [[0, 1], [0, 2]]\n    cost = [-1, -2, -3]\n    expected_output = [0, 0, 0]\n    assert solution.placedCoins(edges, cost) == expected_output"}]}
{"task_num": 2976, "task_title": "Minimum Cost to Convert String I", "func_name": "minimumCost", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n    ans = 0\n    dist = [[math.inf] * 26 for _ in range(26)]\n\n    for a, b, c in zip(original, changed, cost):\n      u = ord(a) - ord('a')\n      v = ord(b) - ord('a')\n      dist[u][v] = min(dist[u][v], c)\n\n    for k in range(26):\n      for i in range(26):\n        if dist[i][k] < math.inf:\n          for j in range(26):\n            if dist[k][j] < math.inf:\n              dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    for s, t in zip(source, target):\n      if s == t:\n        continue\n      u = ord(s) - ord('a')\n      v = ord(t) - ord('a')\n      if dist[u][v] == math.inf:\n        return -1\n      ans += dist[u][v]\n\n    return ans\n", "tests": [{"start": 29, "end": 30, "test": "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abc', 'abc', ['a', 'b', 'c'], ['d', 'e', 'f'], [1, 2, 3]) == 0"}, {"start": 33, "end": 34, "test": "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abc', 'def', ['a', 'b'], ['d', 'e'], [10]) == -1"}, {"start": 23, "end": 26, "test": "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abc', 'def', ['a', 'b', 'c'], ['d', 'e', 'f'], [1, 2, 3]) == 6"}, {"start": 25, "end": 26, "test": "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abc', 'def', ['a', 'b', 'c'], ['d', 'e', 'f'], [1, 2, 3]) == 6"}]}
{"task_num": 2977, "task_title": "Minimum Cost to Convert String II", "func_name": "minimumCost", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n    subLengths = set(len(s) for s in original)\n    subToId = self._getSubToId(original, changed)\n    subCount = len(subToId)\n    dist = [[math.inf for _ in range(subCount)] for _ in range(subCount)]\n    dp = [math.inf for _ in range(len(source) + 1)]\n\n    for a, b, c in zip(original, changed, cost):\n      u = subToId[a]\n      v = subToId[b]\n      dist[u][v] = min(dist[u][v], c)\n\n    for k in range(subCount):\n      for i in range(subCount):\n        if dist[i][k] < math.inf:\n          for j in range(subCount):\n            if dist[k][j] < math.inf:\n              dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    dp[0] = 0\n\n    for i, (s, t) in enumerate(zip(source, target)):\n      if dp[i] == math.inf:\n        continue\n      if s == t:\n        dp[i + 1] = min(dp[i + 1], dp[i])\n      for subLength in subLengths:\n        if i + subLength > len(source):\n          continue\n        subSource = source[i:i + subLength]\n        subTarget = target[i:i + subLength]\n        if subSource not in subToId or subTarget not in subToId:\n          continue\n        u = subToId[subSource]\n        v = subToId[subTarget]\n        if dist[u][v] != math.inf:\n          dp[i + subLength] = min(dp[i + subLength], dp[i] + dist[u][v])\n\n    if dp[len(source)] == math.inf:\n      return -1\n    else:\n      return dp[len(source)]\n\n  def _getSubToId(self, original: str, changed: str) -> Dict[str, int]:\n    subToId = {}\n    for s in original + changed:\n      if s not in subToId:\n        subToId[s] = len(subToId)\n    return subToId\n", "tests": [{"start": 50, "end": 51, "test": "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abc', 'def', ['a', 'b'], ['d', 'e'], [10]) == -1"}, {"start": 52, "end": 53, "test": "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abc', 'def', ['a', 'b'], ['d', 'e'], [10]) == -1"}, {"start": 34, "end": 35, "test": "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abc', 'def', ['a', 'b'], ['d', 'e'], [10]) == -1"}, {"start": 36, "end": 37, "test": "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abc', 'abc', ['a', 'b'], ['c', 'd'], [1, 2]) == -1"}, {"start": 58, "end": 59, "test": "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abc', 'def', ['a', 'b'], ['d', 'e'], [10]) == -1"}, {"start": 26, "end": 29, "test": "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abc', 'def', ['ab', 'bc'], ['cd', 'de'], [1, 2]) == -1"}, {"start": 39, "end": 40, "test": "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abc', 'abc', ['a', 'b'], ['c', 'd'], [1, 2]) == -1"}, {"start": 43, "end": 44, "test": "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abc', 'def', ['a', 'b'], ['d', 'e'], [10, 20]) == -1"}, {"start": 47, "end": 48, "test": "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abc', 'def', ['ab', 'bc'], ['cd', 'de'], [10, 20]) == -1"}, {"start": 28, "end": 29, "test": "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost('abc', 'adc', ['ab', 'ac'], ['cd', 'dc'], [10, 3]) == -1"}]}
{"task_num": 2983, "task_title": "Palindrome Rearrangement Queries", "func_name": "canMakePalindromeQueries", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n    n = len(s)\n    mirroredDiffs = self._getMirroredDiffs(s)\n    counts = self._getCounts(s)\n    ans = []\n\n    def subtractArrays(a: List[int], b: List[int]):\n      return [x - y for x, y in zip(a, b)]\n\n    for a, b, c, d in queries:\n      b += 1\n      d += 1\n      ra = n - a\n      rb = n - b\n      rc = n - c\n      rd = n - d\n\n      if (min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0) or (n // 2 > max(b, rc) and mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0):\n        ans.append(False)\n      else:\n        leftRangeCount = subtractArrays(counts[b], counts[a])\n        rightRangeCount = subtractArrays(counts[d], counts[c])\n        if a > rd:\n          rightRangeCount = subtractArrays(\n              rightRangeCount, subtractArrays(counts[min(a, rc)], counts[rd]))\n        if rc > b:\n          rightRangeCount = subtractArrays(\n              rightRangeCount, subtractArrays(counts[rc], counts[max(b, rd)]))\n        if c > rb:\n          leftRangeCount = subtractArrays(\n              leftRangeCount, subtractArrays(counts[min(c, ra)], counts[rb]))\n        if ra > d:\n          leftRangeCount = subtractArrays(\n              leftRangeCount, subtractArrays(counts[ra], counts[max(d, rb)]))\n        ans.append(min(leftRangeCount) >= 0\n                   and min(rightRangeCount) >= 0\n                   and leftRangeCount == rightRangeCount)\n\n    return ans\n\n  def _getMirroredDiffs(self, s: str) -> List[int]:\n    diffs = [0]\n    for i, j in zip(range(len(s)), reversed(range(len(s)))):\n      if i >= j:\n        break\n      diffs.append(diffs[-1] + (s[i] != s[j]))\n    return diffs\n\n  def _getCounts(self, s: str) -> List[List[int]]:\n    count = [0] * 26\n    counts = [count.copy()]\n    for c in s:\n      count[ord(c) - ord('a')] += 1\n      counts.append(count.copy())\n    return counts\n", "tests": [{"start": 29, "end": 30, "test": "def test_canMakePalindromeQueries():\n    solution = Solution()\n    result = solution.canMakePalindromeQueries('abcba', [[0, 1, 3, 4]])"}, {"start": 31, "end": 48, "test": "def test_canMakePalindromeQueries():\n    solution = Solution()\n    assert solution.canMakePalindromeQueries('abcba', [[0, 1, 3, 4]]) == [True]"}, {"start": 55, "end": 56, "test": "def test_canMakePalindromeQueries():\n    solution = Solution()\n    result = solution.canMakePalindromeQueries('ab', [[0, 0, 1, 1]])"}, {"start": 34, "end": 36, "test": "def test_canMakePalindromeQueries():\n    solution = Solution()\n    result = solution.canMakePalindromeQueries('abccba', [[0, 1, 3, 4]])"}, {"start": 37, "end": 39, "test": "def test_canMakePalindromeQueries():\n    solution = Solution()\n    result = solution.canMakePalindromeQueries('abcba', [[0, 1, 3, 4]])"}, {"start": 40, "end": 42, "test": "def test_canMakePalindromeQueries():\n    solution = Solution()\n    result = solution.canMakePalindromeQueries('abccba', [[0, 1, 3, 4]])"}, {"start": 43, "end": 45, "test": "def test_canMakePalindromeQueries():\n    solution = Solution()\n    result = solution.canMakePalindromeQueries('abcba', [[0, 1, 3, 4]])"}]}
{"task_num": 3001, "task_title": "Minimum Moves to Capture The Queen", "func_name": "minMovesToCaptureTheQueen", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minMovesToCaptureTheQueen(self, a: int, b: int, c: int, d: int, e: int, f: int) -> int:\n    if a == e:\n      if c == a and (b < d < f or b > d > f):\n        return 2\n      else:\n        return 1\n    if b == f:\n      if d == f and (a < c < e or a > c > e):\n        return 2\n      else:\n        return 1\n    if c + d == e + f:\n      if a + b == c + d and (c < a < e or c > a > e):\n        return 2\n      else:\n        return 1\n    if c - d == e - f:\n      if a - b == c - d and (c < a < e or c > a > e):\n        return 2\n      else:\n        return 1\n    return 2\n", "tests": [{"start": 13, "end": 17, "test": "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(1, 2, 3, 4, 1, 5) == 2"}, {"start": 18, "end": 22, "test": "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(1, 1, 2, 2, 3, 3) == 2"}, {"start": 23, "end": 27, "test": "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(1, 1, 2, 2, 4, 4) == 2"}, {"start": 28, "end": 32, "test": "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(1, 1, 2, 3, 4, 5) == 2"}, {"start": 14, "end": 15, "test": "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(1, 1, 3, 2, 5, 2) == 2"}, {"start": 16, "end": 17, "test": "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(1, 2, 3, 4, 5, 6) == 1"}, {"start": 19, "end": 20, "test": "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(1, 1, 3, 2, 5, 2) == 2"}, {"start": 21, "end": 22, "test": "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(1, 1, 2, 3, 4, 5) == 1"}, {"start": 24, "end": 25, "test": "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(1, 1, 3, 3, 5, 5) == 2"}, {"start": 26, "end": 27, "test": "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(1, 1, 2, 3, 4, 5) == 1"}, {"start": 29, "end": 30, "test": "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(1, 1, 3, 3, 5, 5) == 2"}, {"start": 31, "end": 32, "test": "def test_minMovesToCaptureTheQueen():\n    solution = Solution()\n    assert solution.minMovesToCaptureTheQueen(1, 1, 2, 2, 3, 3) == 1"}]}
{"task_num": 3006, "task_title": "Find Beautiful Indices in the Given Array I", "func_name": "beautifulIndices", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def beautifulIndices(self, s: str, a: str, b: str, k: int) -> List[int]:\n    ans = []\n    indicesA = self._kmp(s, a)\n    indicesB = self._kmp(s, b)\n    indicesBIndex = 0\n\n    for i in indicesA:\n      while indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i < -k:\n        indicesBIndex += 1\n      if indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i <= k:\n        ans.append(i)\n\n    return ans\n\n  def _kmp(self, s: str, pattern: str) -> List[int]:\n    def getLPS(pattern: str) -> List[int]:\n      lps = [0] * len(pattern)\n      j = 0\n      for i in range(1, len(pattern)):\n        while j > 0 and pattern[j] != pattern[i]:\n          j = lps[j - 1]\n        if pattern[i] == pattern[j]:\n          lps[i] = j + 1\n          j += 1\n      return lps\n\n    res = []\n    lps = getLPS(pattern)\n    i = 0\n    j = 0\n    while i < len(s):\n      if s[i] == pattern[j]:\n        i += 1\n        j += 1\n        if j == len(pattern):\n          res.append(i - j)\n          j = lps[j - 1]\n      elif j != 0:\n        j = lps[j - 1]\n      else:\n        i += 1\n    return res\n", "tests": [{"start": 21, "end": 22, "test": "def test_beautifulIndices():\n    solution = Solution()\n    assert solution.beautifulIndices('abababa', 'aba', 'baa', 3) == [0, 2, 4]"}, {"start": 43, "end": 48, "test": "def test_beautifulIndices():\n    solution = Solution()\n    assert solution.beautifulIndices('abababa', 'aba', 'baa', 2) == [0, 3]"}, {"start": 33, "end": 35, "test": "def test_beautifulIndices():\n    solution = Solution()\n    assert solution.beautifulIndices('abababa', 'aba', 'baa', 2) == [0, 3]"}, {"start": 46, "end": 48, "test": "def test_beautifulIndices():\n    solution = Solution()\n    result = solution.beautifulIndices('abababa', 'aba', 'baa', 2)"}, {"start": 49, "end": 50, "test": "def test_beautifulIndices():\n    solution = Solution()\n    result = solution.beautifulIndices('abababa', 'aba', 'baa', 2)"}, {"start": 51, "end": 52, "test": "def test_beautifulIndices():\n    solution = Solution()\n    result = solution.beautifulIndices('abababa', 'aba', 'baa', 2)"}]}
{"task_num": 3029, "task_title": "Minimum Time to Revert Word to Initial State I", "func_name": "minimumTimeToInitialState", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumTimeToInitialState(self, word: str, k: int) -> int:\n    n = len(word)\n    maxOps = (n - 1) // k + 1\n    z = self._zFunction(word)\n\n    for ans in range(1, maxOps):\n      if z[ans * k] >= n - ans * k:\n        return ans\n\n    return maxOps\n\n  def _zFunction(self, s: str) -> List[int]:\n    n = len(s)\n    z = [0] * n\n    l = 0\n    r = 0\n    for i in range(1, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l])\n      while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n    return z\n", "tests": [{"start": 18, "end": 19, "test": "def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState('abcde', 2) == 3"}, {"start": 29, "end": 30, "test": "def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState('abcde', 2) == 3"}, {"start": 33, "end": 35, "test": "def test_minimumTimeToInitialState():\n    solution = Solution()\n    assert solution.minimumTimeToInitialState('abcde', 2) == 3"}]}
{"task_num": 3030, "task_title": "Find the Grid of Region Average", "func_name": "resultGrid", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def resultGrid(self, image: List[List[int]], threshold: int) -> List[List[int]]:\n    m = len(image)\n    n = len(image[0])\n    sums = [[0] * n for _ in range(m)]\n    counts = [[0] * n for _ in range(m)]\n\n    for i in range(m - 2):\n      for j in range(n - 2):\n        if self._isRegion(image, i, j, threshold):\n          subgridSum = sum(image[x][y] for x in range(i, i + 3) for y in range(j, j + 3))\n          for x in range(i, i + 3):\n            for y in range(j, j + 3):\n              sums[x][y] += subgridSum // 9\n              counts[x][y] += 1\n\n    for i in range(m):\n      for j in range(n):\n        if counts[i][j] > 0:\n          image[i][j] = sums[i][j] // counts[i][j]\n\n    return image\n\n  def _isRegion(self, image: List[List[int]], i: int, j: int, threshold: int) -> bool:\n    for x in range(i, i + 3):\n      for y in range(j, j + 3):\n        if x > i and abs(image[x][y] - image[x - 1][y]) > threshold:\n          return False\n        if y > j and abs(image[x][y] - image[x][y - 1]) > threshold:\n          return False\n    return True\n", "tests": [{"start": 20, "end": 25, "test": "def test_resultGrid():\n    solution = Solution()\n    image = [[10, 20, 30], [40, 50, 60], [70, 80, 90]]\n    threshold = 10\n    expected_output = [[20, 30, 40], [50, 60, 70], [80, 90, 100]]\n    assert solution.resultGrid(image, threshold) == expected_output"}, {"start": 29, "end": 30, "test": "def test_resultGrid():\n    solution = Solution()\n    image = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    threshold = 0\n    expected_output = [[5, 5, 5], [5, 5, 5], [5, 5, 5]]\n    assert solution.resultGrid(image, threshold) == expected_output"}, {"start": 37, "end": 38, "test": "def test_resultGrid():\n    solution = Solution()\n    image = [[10, 20, 30], [40, 50, 60], [70, 80, 90]]\n    threshold = 15\n    expected_output = [[10, 20, 30], [40, 50, 60], [70, 80, 90]]\n    assert solution.resultGrid(image, threshold) == expected_output"}, {"start": 39, "end": 40, "test": "def test_resultGrid():\n    solution = Solution()\n    image = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    threshold = 0\n    expected_output = [[5, 5, 5], [5, 5, 5], [5, 5, 5]]\n    assert solution.resultGrid(image, threshold) == expected_output"}]}
{"task_num": 3043, "task_title": "Find the Length of the Longest Common Prefix", "func_name": "longestCommonPrefix", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass TrieNode:\n  def __init__(self):\n    self.children: Dict[str, TrieNode] = {}\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def insert(self, word: str) -> None:\n    node: TrieNode = self.root\n    for c in word:\n      node = node.children.setdefault(c, TrieNode())\n    node.isWord = True\n\n  def search(self, word: str) -> int:\n    prefixLength = 0\n    node = self.root\n    for c in word:\n      if c not in node.children:\n        break\n      node = node.children[c]\n      prefixLength += 1\n    return prefixLength\n\n\nclass Solution:\n  def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:\n    trie = Trie()\n\n    for num in arr1:\n      trie.insert(str(num))\n\n    return max(trie.search(str(num)) for num in arr2)\n", "tests": [{"start": 30, "end": 31, "test": "def test_longestCommonPrefix():\n    solution = Solution()\n    assert solution.longestCommonPrefix([123, 456], [789, 12]) == 0"}]}
{"task_num": 3044, "task_title": "Most Frequent Prime", "func_name": "mostFrequentPrime", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def mostFrequentPrime(self, mat: List[List[int]]) -> int:\n    dirs = ((1, 0), (1, -1), (0, -1), (-1, -1),\n            (-1, 0), (-1, 1), (0, 1), (1, 1))\n    m = len(mat)\n    n = len(mat[0])\n    count = collections.Counter()\n\n    def isPrime(num: int) -> bool:\n      return not any(num % i == 0 for i in range(2, int(num**0.5 + 1)))\n\n    for i in range(m):\n      for j in range(n):\n        for dx, dy in dirs:\n          num = 0\n          x = i\n          y = j\n          while 0 <= x < m and 0 <= y < n:\n            num = num * 10 + mat[x][y]\n            if num > 10 and isPrime(num):\n              count[num] += 1\n            x += dx\n            y += dy\n\n    if not count.items():\n      return -1\n    return max(count.items(), key=lambda x: (x[1], x[0]))[0]\n", "tests": [{"start": 35, "end": 36, "test": "def test_mostFrequentPrime():\n    solution = Solution()\n    assert solution.mostFrequentPrime([[2, 3], [5, 7]]) == -1"}, {"start": 30, "end": 31, "test": "def test_mostFrequentPrime():\n    solution = Solution()\n    assert solution.mostFrequentPrime([[2, 3], [5, 7]]) == 7"}]}
{"task_num": 3072, "task_title": "Distribute Elements Into Two Arrays II", "func_name": "resultArray", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass FenwickTree:\n  def __init__(self, n: int):\n    self.sums = [0] * (n + 1)\n\n  def update(self, i: int, delta: int) -> None:\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def resultArray(self, nums: List[int]) -> List[int]:\n    arr1 = []\n    arr2 = []\n    ranks = self._getRanks(nums)\n    tree1 = FenwickTree(len(ranks))\n    tree2 = FenwickTree(len(ranks))\n\n    def add(num: int, arr: List[int], tree: FenwickTree) -> None:\n      arr.append(num)\n      tree.update(ranks[num], 1)\n\n    add(nums[0], arr1, tree1)\n    add(nums[1], arr2, tree2)\n\n    for i in range(2, len(nums)):\n      greaterCount1 = len(arr1) - tree1.get(ranks[nums[i]])\n      greaterCount2 = len(arr2) - tree2.get(ranks[nums[i]])\n      if greaterCount1 > greaterCount2:\n        add(nums[i], arr1, tree1)\n      elif greaterCount1 < greaterCount2:\n        add(nums[i], arr2, tree2)\n      elif len(arr1) > len(arr2):\n        add(nums[i], arr2, tree2)\n      else:\n        add(nums[i], arr1, tree1)\n\n    return arr1 + arr2\n\n  def _getRanks(self, nums: List[int]) -> Dict[int, int]:\n    ranks = collections.Counter()\n    rank = 0\n    for num in sorted(set(nums)):\n      rank += 1\n      ranks[num] = rank\n    return ranks\n", "tests": [{"start": 50, "end": 51, "test": "def test_resultArray():\n    solution = Solution()\n    assert solution.resultArray([3, 1, 4, 2]) == [3, 4, 1, 2]"}, {"start": 52, "end": 53, "test": "def test_resultArray():\n    solution = Solution()\n    assert solution.resultArray([10, 20, 30, 40, 50]) == [10, 20, 30, 40, 50]"}, {"start": 54, "end": 55, "test": "def test_resultArray():\n    solution = Solution()\n    assert solution.resultArray([3, 1, 4, 1, 5, 9]) == [3, 4, 9, 1, 1, 5]"}, {"start": 56, "end": 57, "test": "def test_resultArray():\n    solution = Solution()\n    assert solution.resultArray([3, 2, 1]) == [3, 2, 1]"}]}
{"task_num": 3095, "task_title": "Shortest Subarray With OR at Least K I", "func_name": "minimumSubarrayLength", "difficulty": 1, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumSubarrayLength(self, nums: List[int], k: int) -> int:\n    ans = len(nums) + 1\n    ors = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, num in enumerate(nums):\n      ors = self._orNum(ors, num, count)\n      while ors >= k and l <= r:\n        ans = min(ans, r - l + 1)\n        ors = self._undoOrNum(ors, nums[l], count)\n        l += 1\n\n    return -1 if ans == len(nums) + 1 else ans\n\n  def _orNum(self, ors: int, num: int, count: Dict[int, int]) -> int:\n    for i in range(30):\n      if num >> i & 1:\n        count[i] += 1\n        if count[i] == 1:\n          ors += 1 << i\n    return ors\n\n  def _undoOrNum(self, ors: int, num: int, count: Dict[int, int]) -> int:\n    for i in range(30):\n      if num >> i & 1:\n        count[i] -= 1\n        if count[i] == 0:\n          ors -= 1 << i\n    return ors\n", "tests": [{"start": 29, "end": 32, "test": "def test_minimumSubarrayLength():\n    solution = Solution()\n    assert solution.minimumSubarrayLength([1, 2, 3], 3) == 1"}, {"start": 37, "end": 40, "test": "def test_minimumSubarrayLength():\n    solution = Solution()\n    assert solution.minimumSubarrayLength([1, 2, 3], 7) == -1"}, {"start": 31, "end": 32, "test": "def test_minimumSubarrayLength():\n    solution = Solution()\n    assert solution.minimumSubarrayLength([1, 2, 3], 3) == 1"}, {"start": 39, "end": 40, "test": "def test_minimumSubarrayLength():\n    solution = Solution()\n    assert solution.minimumSubarrayLength([1, 2, 3], 7) == -1"}]}
{"task_num": 3102, "task_title": "Minimize Manhattan Distances", "func_name": "minimumDistance", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumDistance(self, points: List[List[int]]) -> int:\n    i, j = self._maxManhattanDistance(points, -1)\n    xi, yi = self._maxManhattanDistance(points, i)\n    xj, yj = self._maxManhattanDistance(points, j)\n    return min(self._manhattan(points, xi, yi), self._manhattan(points, xj, yj))\n\n  def _maxManhattanDistance(self, points: List[List[int]], excludedIndex: int) -> int:\n    minSum = math.inf\n    maxSum = -math.inf\n    minDiff = math.inf\n    maxDiff = -math.inf\n    minSumIndex = -1\n    maxSumIndex = -1\n    minDiffIndex = -1\n    maxDiffIndex = -1\n\n    for i, (x, y) in enumerate(points):\n      if i == excludedIndex:\n        continue\n      summ = x + y\n      diff = x - y\n      if summ < minSum:\n        minSum = summ\n        minSumIndex = i\n      if summ > maxSum:\n        maxSum = summ\n        maxSumIndex = i\n      if diff < minDiff:\n        minDiff = diff\n        minDiffIndex = i\n      if diff > maxDiff:\n        maxDiff = diff\n        maxDiffIndex = i\n\n    if maxSum - minSum >= maxDiff - minDiff:\n      return [minSumIndex, maxSumIndex]\n    else:\n      return [minDiffIndex, maxDiffIndex]\n\n  def _manhattan(self, points: List[List[int]], i: int, j: int) -> int:\n    return abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n", "tests": [{"start": 46, "end": 47, "test": "def test_minimumDistance():\n    solution = Solution()\n    points = [[1, 2], [3, 4], [5, 6]]\n    assert solution.minimumDistance(points) == 0"}, {"start": 48, "end": 49, "test": "def test_minimumDistance():\n    solution = Solution()\n    points = [[1, 2], [3, 4], [5, 6], [7, 8]]\n    assert solution.minimumDistance(points) == 0"}, {"start": 29, "end": 30, "test": "def test_minimumDistance():\n    solution = Solution()\n    points = [[1, 1], [1, 2], [2, 1]]\n    assert solution.minimumDistance(points) == 0"}, {"start": 33, "end": 35, "test": "def test_minimumDistance():\n    solution = Solution()\n    points = [[0, 0], [1, 2], [3, 4]]\n    assert solution.minimumDistance(points) == 2"}, {"start": 36, "end": 38, "test": "def test_minimumDistance():\n    solution = Solution()\n    points = [[1, 2], [3, 4], [5, 6]]\n    assert solution.minimumDistance(points) == 2"}, {"start": 39, "end": 41, "test": "def test_minimumDistance():\n    solution = Solution()\n    points = [[-1, 0], [0, -1], [1, 0], [0, 1]]\n    assert solution.minimumDistance(points) == 2"}, {"start": 42, "end": 44, "test": "def test_minimumDistance():\n    solution = Solution()\n    points = [[1, 2], [3, 4], [5, 6]]\n    assert solution.minimumDistance(points) == 2"}]}
{"task_num": 3108, "task_title": "Minimum Cost Walk in Weighted Graph", "func_name": "minimumCost", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n    self.weight = [(1 << 17) - 1] * n\n\n  def unionByRank(self, u: int, v: int, w: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    newWeight = self.weight[i] & self.weight[j] & w\n    self.weight[i] = newWeight\n    self.weight[j] = newWeight\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def getMinCost(self, u: int, v: int) -> int:\n    if u == v:\n      return 0\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return self.weight[i]\n    else:\n      return -1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def minimumCost(self, n: int, edges: List[List[int]], query: List[List[int]]) -> List[int]:\n    uf = UnionFind(n)\n\n    for u, v, w in edges:\n      uf.unionByRank(u, v, w)\n\n    return [uf.getMinCost(u, v) for u, v in query]\n", "tests": [{"start": 23, "end": 24, "test": "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost(3, [[0, 1, 7], [1, 2, 5]], [[0, 2]]) == [-1]"}, {"start": 25, "end": 26, "test": "def test_minimumCost():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 3], [1, 2, 5], [2, 3, 7]]\n    query = [[0, 3]]\n    expected = [1]\n    assert solution.minimumCost(n, edges, query) == expected"}, {"start": 34, "end": 35, "test": "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost(2, [[0, 1, 3]], [[0, 0]]) == [0]"}, {"start": 38, "end": 39, "test": "def test_minimumCost():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 7], [1, 2, 5], [2, 3, 3], [3, 0, 9]]\n    query = [[0, 0], [1, 3]]\n    expected = [7, -1]\n    assert solution.minimumCost(n, edges, query) == expected"}, {"start": 40, "end": 41, "test": "def test_minimumCost():\n    solution = Solution()\n    assert solution.minimumCost(3, [[0, 1, 2], [1, 2, 4]], [[0, 2]]) == [-1]"}, {"start": 44, "end": 45, "test": "def test_minimumCost():\n    solution = Solution()\n    n = 3\n    edges = [[0, 1, 7], [1, 2, 5]]\n    query = [[0, 2]]\n    expected = [-1]\n    assert solution.minimumCost(n, edges, query) == expected"}, {"start": 27, "end": 28, "test": "def test_minimumCost():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 3], [1, 2, 5], [2, 3, 7]]\n    query = [[0, 3]]\n    expected = [-1]\n    assert solution.minimumCost(n, edges, query) == expected"}, {"start": 29, "end": 31, "test": "def test_minimumCost():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 7], [1, 2, 5], [2, 3, 3], [3, 0, 9]]\n    query = [[0, 3], [1, 2], [2, 0], [3, 1]]\n    expected = [3, 5, -1, -1]\n    assert solution.minimumCost(n, edges, query) == expected"}]}
{"task_num": 3112, "task_title": "Minimum Time to Visit Disappearing Nodes", "func_name": "minimumTime", "difficulty": 2, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, 0, disappear)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, disappear: List[int]) -> List[int]:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < disappear[v] and d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    res=[]\n    for d in dist:\n      if d != math.inf:\n        res.append(d)\n      else:\n        res.append(-1)\n    return res\n", "tests": [{"start": 29, "end": 30, "test": "def test_minimumTime():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5]]\n    disappear = [math.inf, math.inf, 6, math.inf, math.inf]\n    expected = [-1, -1, 5, -1, -1]\n    assert solution.minimumTime(n, edges, disappear) == expected"}, {"start": 38, "end": 39, "test": "def test_minimumTime():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 2], [1, 2, 3], [2, 4, 1], [4, 3, 1]]\n    disappear = [math.inf, math.inf, 4, math.inf, math.inf]\n    expected = [0, -1, 3, -1, 4]\n    assert solution.minimumTime(n, edges, disappear) == expected"}, {"start": 40, "end": 41, "test": "def test_minimumTime():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 2], [1, 2, 3], [2, 4, 1]]\n    disappear = [math.inf, math.inf, 3, math.inf, math.inf]\n    expected = [-1, -1, 3, -1, -1]\n    assert solution.minimumTime(n, edges, disappear) == expected"}, {"start": 32, "end": 34, "test": "def test_minimumTime():\n    solution = Solution()\n    n = 5\n    edges = [[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5]]\n    disappear = [math.inf, math.inf, 6, math.inf, math.inf]\n    expected = [0, -1, -1, -1, -1]\n    assert solution.minimumTime(n, edges, disappear) == expected"}]}
{"task_num": 3123, "task_title": "Find Edges in Shortest Paths", "func_name": "findAnswer", "difficulty": 3, "code": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findAnswer(self, n: int, edges: List[List[int]]) -> List[bool]:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    from0 = self._dijkstra(graph, 0)\n    from1 = self._dijkstra(graph, n - 1)\n    return [from0[u] + w + from1[v] == from0[-1] or from0[v] + w + from1[u] == from0[-1] for u, v, w in edges]\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int) -> List[int]:\n    dist = [10**9] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist\n", "tests": [{"start": 31, "end": 32, "test": "def test_findAnswer():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 1], [1, 2, 1], [2, 3, 1], [0, 3, 10]]\n    expected = [True, True, True, False]\n    assert solution.findAnswer(n, edges) == expected"}, {"start": 34, "end": 36, "test": "def test_findAnswer():\n    solution = Solution()\n    n = 4\n    edges = [[0, 1, 2], [1, 2, 3], [2, 3, 1], [0, 3, 5]]\n    expected = [True, True, False, False]\n    assert solution.findAnswer(n, edges) == expected"}]}
